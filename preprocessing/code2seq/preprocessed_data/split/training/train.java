	/**
	 * Returns the pushes lowerbound of this board position.
	 * 
	 * @return the pushes lowerbound
	 */

	public int getPushesLowerbound() {
		return pushesLowerbound;
	}

	/**
	 * Sets the pushes lowerbound of this board position.
	 * 
	 * @param pushesLowerbound
	 */

	public void setPushesLowerbound(int pushesLowerbound) {
		this.pushesLowerbound = pushesLowerbound;
	}

		/**
		 * Play a sound.
		 */

		public void play() {
			
			// If no sound file is there nothing can be played.
			if(currentSoundFilename.equals(""))
				return;
			
			// Check if the this sound must be read from another file (the user has
			// chosen another sound to be played).
			String settingsFileName = Settings.get(soundSettingsKey);
			if(!currentSoundFilename.equals(settingsFileName)) {
				loadClip(settingsFileName);			
			}
			
			// Stop the currently playing sound to play the new sound if necessary.
			if (clip.isRunning()) {
				clip.stop();
			}
			
			// Rewind to the beginning.
			clip.setFramePosition(0); 
			
			// Start playing.
			clip.start();    
		}

	/**
	 * Returns the influence value between the positions of the passed boxes.
	 * <p>
	 * The LOWER the influence value the more influence has the box on the other box.
	 * 
	 * @param boxNo1  the position of the first  box whose position is considered
	 * @param boxNo2  the position of the second box whose position is considered
	 * @return the influence value 
	 */

	public int getInfluenceValue(int boxNo1, int boxNo2) {
		return influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),
				                               board.boxData.getBoxPosition(boxNo2) );
	}

	/**
	 * Sets the box positions and the player position.
	 *     
	 * @param positions positions of the boxes and the player
	 */

	public void setPositions(int[] positions){
		this.positions = positions;
	}

	/**
	 * Returns the player position of this board position.
	 * 
	 * @return the player position
	 */

	public int getPlayerPosition() {
		return positions[positions.length-1];
	}

	/**
	 * Returns the number of the moved box.
	 * 
	 * @return the number of the moved box
	 */

	public int getPulledBoxNumber() {
		return pulledBoxNo;
	}

	/**
	 * Returns the start position of the pulled box.
	 * 
	 * @return the position of the box before it was pulled.
	 */

	public int getStartBoxPosition() {
		return startPosition;
	}

	/**
	 * Returns the target position of the pulled box.
	 * 
	 * @return the position of the box after it was pulled.
	 */

	public int getTargetBoxPosition() {
		return targetPosition;
	}

    /**
     * Returns the preceding board position of this board position.
     *
     * @return the preceding board position of this board position
     */

    public BoardPositionPackingSequence getPrecedingBoardPosition() {
    	return precedingBoardPosition;
    }

	/**
	 * Compares both board positions. Note: lower values means high priority
	 * in the <code>PriorityQueue</code>.
	 */

	public int compareTo(BoardPositionPackingSequence boardPosition) {
		return boardPosition.getRelevance() - getRelevance();
	}

	/**
	 * Returns whether the push is a forced push, that means a box 
	 * must be pushed from the start position to the target position.
	 */

	public boolean isForcedPush() {
		return isPushForced;
	}

	/**
	 * Sets the status bar text.
	 * 
	 * @param text
	 *            the text to be shown in the status bar
	 */

	final public void setInfoText(String text) {
		infoText.setText(text);
	}

	/**
	 * Returns whether the solver has been stopped due to insufficient memory.
	 * 
	 * @return <code>true</code> if the solver stopped due to insufficient memory, and
	 *        <code>false</code> otherwise
	 */

	public boolean isSolverStoppedDueToOutOfMemory() {
		return isSolverStoppedDueToOutOfMemory;
	}

	/**
	 * Returns the board position with the shortest determined solution path length.
	 *
     * @return board position with the shortest determined solution path length.
     */

    final protected IBoardPositionMoves getBestBoardPosition(){

		// Nimmt die Liste aller Stellungen mit einer bestimmten Lösungspfadlänge auf
		LinkedList<IBoardPositionMoves> boardPositionList;
		
		for(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {
		
			// Liste der Stellungen mit der aktuellen Pfadlänge holen. 
			boardPositionList = boardPositionQueue.get(solutionLength);
			
			if(boardPositionList.size() > 0){	 
			    shortestSolutionPathLength = solutionLength;
			    
				// Die zuletzt eingefügte Stellung zurückgeben
	    		return boardPositionList.removeLast();
			}
		}
		
		return null;
	}

	/**
	 * Returns the preceding board position of this board position.
	 * 
	 * @return preceding board position
	 */

	final public IBoardPosition getPrecedingBoardPosition() {
		return precedingBoardPosition;
	}

	/**
	 * Returns the direction the box has been pushed.
	 * 
	 * @return Direction of the push
	 */

	final public int getDirection() {
		return positionData >>> 13;
	}

	/**
	 * Returns the number of the pushed box.
	 * 
	 * @return Number of the pushed box
	 */

	public int getBoxNo() {
		return positionData & ((1 << 10) - 1);
	}

	/**
	 * Gives the name of this solver as used to tag new solutions.
	 * @return the name of this solver
	 */

	protected String creatorName() {
		return Texts.getText("solver");
	}

	/**
	 * Return the player position of this board position.
	 * 
	 * @return the player position
	 */

	final public int getPlayerPosition() {
		return playerPosition;
	}

	/**
	 * Sets the box- and the player positions.
	 *     
	 * @param positions Positions of the boxes and the player
	 */

	final public void setPositions(int[] positions) {
		this.positions = positions;
	}

	/**
	 * An absolute board position usually hasn't a preceding board position. This method is
	 * implemented for easier working with linked lists.
	 *
	 * @return always null
	 */

	final public IBoardPosition getPrecedingBoardPosition() {
		return null;
	}

	/**
	 * Sets the searchdirection of the solutionsearch this class is created in.
	 * 
	 * @param searchDirection Direction of the search
	 */

	final public void setSearchDirection(SearchDirection searchDirection) {

		if (searchDirection == SearchDirection.FORWARD) {
			forwardsSearch  = true;
		} else {
			backwardsSearch = true;
		}
	}

	/**
	 * For avoiding some casts this method is implemented here. Actually, this method
	 * is only needed for relative board positions.
	 *
	 * @return always 0
	 */

	final public int getDirection() {
		return 0;
	}

	/** 
	 * Returns the number of pushes of this board position.
	 * 
	 * @return number of pushes
	 */

	public int getPushesCount() {

		int pushesCount = 0;

		for (BoardPosition currentBoardPosition = this; currentBoardPosition
				.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition
				.getPrecedingBoardPosition()) {
			if (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {
				pushesCount++;
			}
		}

		return pushesCount;
	}

	/**
	 * Absolute board positions are only created when no box has been pushed. This value is interpreted 
	 * during a search for a solution (no box has been pushed so no tunnel check has to be performed).
	 *
	 * @return always <code>NO_BOX_PUSHED</code>
	 */

	final public int getBoxNo() {
		return NO_BOX_PUSHED;
	}

	/**
	 * Sets the maximum solution length. 
	 * This is a value representing the iteration depth during the search for a solution.
	 * (first all board positions are created that have a maximum solution length of x pushes.
	 * Then all board positions are created with a maximum solution length of x+1, ...
	 *  
	 * @param maximumSolutionLength	the maximum solution length to be set
	 */

	public void setMaximumSolutionLength(short maximumSolutionLength) {
		maximumPushesCurrentIteration = maximumSolutionLength;
	}

	/**
	 * Return the player position of this board position.
	 * 
	 * @return the player position
	 */

	final public int getPlayerPosition() {
		return positions[boxCount];
	}

	/**
	 * Returns the maximum solution length (= iteration depth).
	 * 
	 * @return	the maximum solution length stored in this board position
	 */

	public short getMaximumSolutionLength() {
		return maximumPushesCurrentIteration;
	}

	/**
	 * Returns the number of pushes that were made to reach this board position.
	 * An absolute board position is only created at the beginning, so this is
	 * always 0.
	 * This number is used in the solving methods.
	 * 
	 * @return always 0
	 */

	final public int getPushesCount() {
		return 0;
	}

	/**
	 * Returns a string to be attached to a solution, which says that this
	 * solver did create the solution at the passed point in time.
	 * 
	 * @param date the creation time point, or <code>null</code> for "now"
	 * @return string identifying the solver as solution creator
	 * @see Solution#name
	 */

	protected String solutionByMeAt(Date date) {
		return  Texts.getText("createdBy")
		      + " " + creatorName()
		      + " " + Utilities.dateString(date);
	}

	/**
	 * Sets the number of moves.
	 * 
	 * @param movesCount	Number of moves the player has done
	 */

	final public void setMovesCount(int movesCount) {
		this.movesCount = (short) movesCount;
	}

	/**
	 * Returns the index in the packing sequence that has already been reached.
	 * 
	 * @return index in the packing sequence
	 */

	public int getIndexPackingSequence() {
		return indexPackingSequence;
	}

	/**
	 * Sets the index in the packing sequence that has been reached.
	 * 
	 * @param indexPackingSequence the index in the packing sequence
	 */

	public void setIndexPackingSequence(int indexPackingSequence) {
		this.indexPackingSequence = indexPackingSequence;
	}

	/**
	 * Returns, whether a box is inactive, and therefore a position value 0
	 * has to be assumed.
	 *
	 * @param  boxNo number of the box to be checked for being inactive
	 * @return <code>true</code> if the box is inactive, and
	 * 		  <code>false</code> if the box is active
	 */

	protected boolean isBoxInactive(int boxNo) {
		return isBoxInactive[boxNo];
	}

	/**
	 *  Returns whether the pushed box has been inactive.
	 *
	 * @return <code>true</code> the box is inactive
	 * 			<code>false</code> the box is active
	 */

	final public boolean isBoxInactive() {
		return (positionData & INACTIVE_BOX) > 0;
	}

	/**
	 * Mark this board position to be a deadlock.
	 */

	public void setCorralDeadlock() {
		isDeadlock = true;
	}

	/**
	 * Mark this board position not to be a deadlock.
	 * <p>
	 * Attention: this board position is only for the current
	 * investigated corral assumed not to be a deadlock.
	 * Nevertheless it can be a deadlock, because not all
	 * deadlocks are detected.
	 */

	public void setNotCorralDeadlock() {
		isNotDeadlock = true;
	}

		/**
		 * Retrieves the current value of the debug variable
		 * described by this object, by using reflection.
		 * 
		 * @return current value of the described debug variable
		 */

		public boolean getValue() {
			/*
			 * Since we here are inside of class Settings, we should not get
			 * an IllegalAccessException.
			 * Hence, we catch the exceptions here, and return false,
			 * just in case.
			 */
			try {
				return field.getBoolean(null);
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
			return false;
		}

	/**
	 * Returns a string to be attached to a solution, which says that this
	 * solver did create the solution "now".
	 * 
	 * @return string identifying the solver as solution creator
	 * @see Solution#name
	 */

	protected String solutionByMeNow() {
		return solutionByMeAt(null);
	}

	/**
	 * Sets the number of the corral this board position belongs to.
	 * 
	 * @param corralNo the number of the corral
	 */

	public void setCorralNo(int corralNo) {
		this.corralNo = corralNo;
	}

	/**
	 * Sets the status bar text.
	 * 
	 * @param text
	 *            the text to be shown in the status bar
	 */

	public void setInfoText(String text) {
		infoText.setText(text);
	}

	/**
	 * Returns the number of the corral this board position belongs to.
	 * 
	 * @return the number of the corral
	 */

	public int getCorralNo() {
		return corralNo;
	}

	/**
	 * Returns whether this board position has been proven to be a corral deadlock.
	 * 
	 * @return <code>true</code> if this board position is a corral deadlock, and
	 * 	     <code>false</code> if this board position has not been proven to be a deadlock
	 */

	public boolean isCorralDeadlock() {
		return isDeadlock;
	}

	/**
	 * Returns whether this board position is classified not to be a corral deadlock.
	 * <p>
	 * This board position can be a corral deadlock, anyhow. For example the corral
	 * detection could be aborted due to a reached time limit. Nevertheless it would
	 * be classified as not to be a corral deadlock.
	 * 
	 * @return <code>true</code> this board position has been classified not to be a corral deadlock
	 * 		  <code>false</code> otherwise
	 */

	public boolean isNotCorralDeadlock() {
		return isNotDeadlock;
	}

	/**
	 * Returns whether this board position has been classified (deadlock or no deadlock).
	 * <p>
	 * This method returns the same value as <code>!isBeeingAnalyzed()</code>
	 * 
	 * @return <code>true</code> this board position has been classified.
	 * 		<code>false</code> this board position has not been classified yet.
	 */

	public boolean isClassified() {
		return isDeadlock || isNotDeadlock;
	}

	/**
	 * Returns whether is currently beeing analyzed to be a corral deadlock or not.
	 * <p>
	 * Every corral (= board position) not classified counts as "beeingAnalyzed". Due to every
	 * board position occured during the corral detection getting a corral number - even if it
	 * isn't a corral at all - finally there can be board positions still having the status
	 * "isBeeingAnalyzed".
	 * 
	 * @return <code>true</code> if the deadlock status of this board position
	 *                           is currently beeing analyzed, and
	 * 		  <code>false</code> otherwise
	 */

	public boolean isBeeingAnalyzed() {
		return !isDeadlock && !isNotDeadlock;
	}

	/**
	 * Returns a deep clone of the current board.
	 * 
	 * @return the clone of this board
	 */

	public CBoard getClone() {
		return new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);
	}

		/**
		 * Sets the value of the debug variable described by this object
		 * by using reflection.
		 * 
		 * @param value  to be assigned to the described debug variable
		 */

		public void setValue(boolean value) {
			/*
			 * Regarding exceptions see comment in "getValue"
			 */
			try {
				field.setBoolean(null, value);
				System.out.println("Setting: DebugVar: "+field.getName()+" set to "+value);
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
			// well... forget it.
		}

	/**
	 * Returns whether the two box configurations are equal.
	 * 
	 * @param boxConfigurationNumber logical index into our flat data array
	 * @param boxConfiguration the candidate box configuration to compare with
	 * @return <code>true</code> if both box configurations are equal, and<br>
	 *        <code>false</code> otherwise
	 */

	private boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {
		
		int indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;
		
		// Compare byte by byte of both box configurations.
		for(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {
			if (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {
				return false;
			}
		}
		
		return true;
	}

	/**
	 * Returns the maximal capacity of this storage.
	 * 
	 * @return the maximal capacity of this storage
	 */

	public int getMaxCapacity() {
		return maxCapacity;
	}

	/**
	 * Adds data to the queue.
	 * 
	 * @param boardPositionIndex the board position to be added
	 * @param boardPositionPredecessor the predecessor to be added
	 */

	public void add(int boardPositionIndex, int boardPositionPredecessor) {
		
		// The moves queue also contains an arbitrary number of span markers.
		// Therefore after every added board position there must be done
		// a check whether the memory block is already full.
		add(boardPositionIndex      );
		add(boardPositionPredecessor);
	}

	/**
	 * Logically removes all board positions from the queue
	 * until a board position different to the passed one occurs in the queue.
	 * 
	 * @param boardPosition the board position to be over jumped
	 */

	public void jumpOverBoardPosition(int boardPosition) {
	
		// "Remove" all values from the queue which are equal to the passed one
		// FFS/hm: does the caller guarantee that the Q cannot become empty by this?
		while(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {
			removeBoardPosition();
		}
	}

	/**
	 * Retrieves and removes the last board position of this queue.
	 * 
	 * @return the previous board position
	 */

	public int removeLastBoardPosition() {
						
		if(nextIndexToWrite == 0) {
			
			// The previous memory block becomes the new current memory block.
			memoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;
			nextIndexToWrite = MEMORY_BLOCK_SIZE;
		}
		
		return memoryBlockToWrite.memory[--nextIndexToWrite];
	}

	/**
	 * Jumps backwards in the queue by the passed number of board positions.
	 * 
	 * @param jumpCount number of board positions to be skipped backwards
	 */

	public void jumpXBoardPositionsBackwards(int jumpCount) {
		
		while(jumpCount > nextIndexToWrite) {
							
			// Assign the previous memory block of the queue.
			memoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;
			
			jumpCount -= nextIndexToWrite;
			nextIndexToWrite = MEMORY_BLOCK_SIZE;					
		}
		nextIndexToWrite -= jumpCount;
	}

	/**
	 * Returns whether the queue is empty.
	 * 
	 * @return <code>true</code> when queue is empty, and<br>
	 *        <code>false</code> otherwise
	 */

	public boolean isEmpty() {
		// This method is only called for the moves queue which has recycling activated.
		return memoryBlockToRead == memoryBlockToWrite
		    && nextIndexToRead   == nextIndexToWrite;
	}

	/**
	 * Returns whether all box configurations could be generated. 
	 * 
	 * @return <code>true</code> if all box configurations have been generated,
	 * 	      <code>false</code> if there is insufficient memory available,
	 *        and not all box configurations have been generated.
	 */

	public boolean isGenerationStoppedDueToFullStorage() {
		return generationStoppedDueToFullStorage;
	}

	/**
	 * Every object of this class gets passed a pushes depth. This depth holds
	 * the number of pushes needed to reach the box configuration passed
	 * to the constructor. This value is unique because there is only one
	 * generation Runnable for every box configuration of the solution
	 * to be optimized. By reading this value the optimizer can identify
	 * each object of this class.
	 * 
	 * @return the pushes depth that has been passed to the constructor of this object
	 */

	public int getBoxConfigurationNumber() {
		return uniqueBoxConfigurationNumber;
	}

	/**
	 * Determine, whether this solution is better than the passed solution,
	 * with respect to moves and then pushes.
	 * 
	 * @param other the other solution we compare against
	 * @return whether this solution is better
	 */

	public boolean isBetterMovesPushesThan( OptimizerSolution other ) {
		if (other == null) {
			return true;			// everybody is better than nobody
		}
		return Utilities.intCompare2Pairs( movesCount , other.movesCount,
		                                   pushesCount, other.pushesCount )
		     < 0 ;
	}

	/**
	 * Determine, whether this solution is better than the passed solution,
	 * with respect to pushes and then moves.
	 * 
	 * @param other the other solution we compare against
	 * @return whether this solution is better
	 */

	public boolean isBetterPushesMovesThan( OptimizerSolution other ) {
		if (other == null) {
			return true;			// everybody is better than nobody
		}
		return Utilities.intCompare2Pairs( pushesCount, other.pushesCount,
		                                   movesCount , other.movesCount  )
		     < 0 ;
	}

	/**
	 * Adds the specified board position into this priority queue.
	 */

	public void add(OptimizerBoardPosition boardPosition) {

		// Ensure that a real board position has been passed.
        if (boardPosition == null)
            throw new NullPointerException();
		
		// Double the size of the queue if it is full.
		if (count >= queue.length) {
			queue = Arrays.copyOf(queue, queue.length * 2);	
		}		
		
		// Add the new value at the correct position. 
		siftUp(count, boardPosition);
		
		// One more board position has been stored => increase the counter.
		count++;
	}

	/**
	 * Returns the number of stored <code>OptimizerBoardPositions</code>.
	 * 
	 * @return the number of stored <code>OptimizerBoardPositions</code>
	 */

	public int size() {
		return count;
	}

	/**
	 * Removes and returns the board position having the lowest metrics (moves, pushes, ...).
	 * 
	 * @return  board position having the lowest metrics 
	 */

	public OptimizerBoardPosition removeFirst() {

		if (count == 0)
			return null;

		// The head of the queue must be returned.
		OptimizerBoardPosition result = queue[0];
		
		// The head of the queue has (logically) been removed => adjust the size.
		--count;
		
		// Remove the last board position.
		OptimizerBoardPosition x = queue[count];
		queue[count] = null;
		
		// If there is at least one board position left in the queue then 
		// shift the board positions so the queue has a new head.
		if (count != 0)
			siftDown(0, x);

		return result;
	}

	/**
	 * Adds the passed <code>String</code> to the log texts of the optimizer
	 * to inform the user about the progress of the optimizer,
	 * or to inform the developer about statistical data.
	 * 
	 * @param text       text to be added to the log
	 * @param stylename  registered name of style to be used
	 */

	private void addLogTextStyle(final String text, final String stylename) {
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				try {
					StyledDocument doc = optimizerLog.getStyledDocument(); 
					doc.insertString(doc.getLength(), text+"\n", doc.getStyle(stylename));			
				} catch (BadLocationException e) {	/* ignore */ }
			}
		});
	}

	 /**
	  *Inserts the passed board position at the passed position.
	  * <p>
	  * This method moves the passed board position down until 
	  * it is less than or equal to its children (or is a leaf).
	  *
	  * @param position the position to start the search for the correct position to insert into
	  * @param boardPosition the board position to be inserted
	  */

	 private void siftDown(int position, OptimizerBoardPosition boardPosition) {
		 
		 // Calculate the half of the size as the maximum position the loop must go to.
		 int half = count >>> 1;        
		 
		 while (position < half) {
			 int childIndex = (position << 1) + 1; // assuming the left child is the "better" board position
			 OptimizerBoardPosition child = queue[childIndex];
			 int rightChildIndex = childIndex + 1;
			 if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)
				 child = queue[childIndex = rightChildIndex];
			 if (boardPosition.compareTo(child) <= 0)
				 break;
			 queue[position] = child;
			 position = childIndex;
		 }
		 
		 queue[position] = boardPosition;
	 }

	/**
	 * Returns the number of board positions stored in this hash table.
	 *
	 * @return  the number of board positions stored in this hash table.
	 */

	public int getNumberOfStoredBoardPositions() {
		return count.get();
	}

	/**
	 * Removes all markings of squares.  
	 */

	public void removeAllMarkings() {
		markedSquares = null;
	}

	/**
	 * Debug method: without {@link Settings#isDebugModeActivated} nothing
	 * visible happens.
	 * In debug mode we print the current statistics to the optimizer logging.
	 */

	public void showDeadlockQueryStats() {
		dlqTotStats.sumFrom(dlqCurStats);
		if ( ! dlqTotStats.equals(dlqCurStats)) {
			show1DLQStats("total", dlqTotStats, 0);
		}
		
		show1DLQStats("this time", dlqCurStats, dlqTotStats.dlqAsked);
		dlqCurStats.clear();
	}

	/**
	 * Returns the box configuration index of the passed board position.
	 * 
	 * @param boardPositionIndex  the index of the board position
	 * @return the index the box configuration is stored at in the box configuration storage
	 */

	private int getBoxConfigurationIndex(int boardPositionIndex) {
		// The board position may just been locked by another thread. However,
		// this method is only called for already completely stored board positions.
		// Hence, the index can't hold just the "LOCKED" value but must
		// always also contain a valid box configuration index.
		return table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); 
	}

	/**
	 * Returns whether the second passed box configuration is a subset
	 * of the first passed box configuration.
	 * 
	 * @param boxConfiguration1
	 *            box configuration 1
	 * @param boxConfigurationArray
	 *            array which contains the box configuration to be checked for
	 *            being a subset
	 * @param indexInArray
	 *            index of the box configuration in the array
	 * 
	 * @return <code>true</code> if the second passed box configuration is a subset
	 *         of the first passed box configuration, and <code>false</code> otherwise
	 */

	final private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {
		for (int i = 0; i < packedBoardByteSize; i++) {
			byte b2 = boxConfigurationArray[indexInArray + i];
			// "b2" is a subset, if all its 1-bits survive the ANDing with the first byte
			if ((boxConfiguration1[i] & b2) != b2) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns the player position of the passed board position.
	 * 
	 * @param boardPositionIndex  the index of the board position
	 * @return the player position of the passed board position
	 */

	private int getPlayerPosition(int boardPositionIndex) {
		// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.
		return table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;
	}	

		/**
		 * Doubles the tree size.
		 */

		final private void doubleTreeSize() {
	
			// Double the tree size.
			int[] newArrayPointers = new int[2*2*treeSizeMax];
			System.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);
			arrayPointers = newArrayPointers;
	
			byte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];
			System.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);
			treeData = newArrayData;
	
			treeSizeMax <<= 1;
		}

		/**
		 * Fills the sorted list with the box configurations from the tree.
		 * 
		 * @param indexInTree index of the box configuration in the tree
		 * @param last	
		 * @return "lowest" boxConfiguration at the moment in the tree
		 */

		final private int treeToSortedListRecursively(int indexInTree, int last) {
	
			// If the end of the tree has been reached return the last index.
			if (indexInTree == -1) {
				return last;
			}
	
			// Left side of the tree.
			int d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);
			sortedList[d++] = indexInTree;
	
			// Right side of the tree.
			return (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));
		}

	/**
	 * Returns the number of the currently selected object.
	 * 
	 * @return number of the currently selected obj
	 */

	final public int getNumberOfSelectedObject() {
		return currentlyMarkedObject;
	}

		/**
		 * Transforms the tree to a binary heap.
		 * This method destroys the tree. That means:
		 * only the binary heap can be used after this method has been called.
		 */

		final private void binaryTreeToBinaryHeap() {
		
			byte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];
		
			for (int i=0, indexInVector = 0; i<treeSize; i++) {
				System.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);
				indexInVector += packedBoardByteSize;
			}
		
			treeData = treeDataTemp;
			arrayPointers = null;
		}

	/**
	 * Using the mouse wheel is interpreted as a move through the selectable objects. 
	 *
	 * @param evt the <code>MouseWheelEvent</code> fired
	 */

	final public void mouseWheelMoved(MouseWheelEvent evt) {

		int scrollDirection = evt.getWheelRotation();

		// Scrollen nach oben
		if (scrollDirection < 0 && currentlyMarkedObject > 0) {
			currentlyMarkedObject--;
		}

		// Scrollen nach unten
		if (scrollDirection > 0 && currentlyMarkedObject < 4) {
			currentlyMarkedObject++;
		}

		application.redraw(false);
	}

	/**
	 * Sets the "is already processed" status of the passed board position.
	 * 
	 * @param boardPositionIndex  index of the board position in this storage
	 * @param processedStatus processed status to set
	 */

	public void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {
		
		// Set/delete the "processed"-flag. This needn't to be done using compareAndSwap
		// because all of the other information stored at that offset have already been 
		// stored and cannot change anymore while this method is executed.
		int currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);
		if(processedStatus == true)
			table.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);
		else
			table.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));
	}

    /**
	 * This method is called when the user selects another view.
	 */

	public void stateChanged(final ChangeEvent e) {
				
		// Get the tabbed pane all views are stored in.
		JTabbedPane tabbedPane = (JTabbedPane) e.getSource();
		
		/*
		 * View on the levels
		 */
		if(tabbedPane.getSelectedComponent() == languageSettings) {
		
		}		
		
	}

		/**
		 * Sets all variables to null for the garbage collection.
		 */

		protected void finalize() {
			arrayPointers = null;
			sortedList = null;
			treeData = null;
		}

    /**
	 * This method is called when the user selects another view.
	 */

	public void stateChanged(final ChangeEvent e) {
				
		// Get the tabbed pane all views are stored in.
		JTabbedPane tabbedPane = (JTabbedPane) e.getSource();
		
		/*
		 * Language settings
		 */
		if(tabbedPane.getSelectedComponent() == languageSettings) {
		
		}		
		
	}

	/**
	 * Creates all things this panel needs.
	 */

	private void createPanel() {
		
		setLayout(new BorderLayout());

		JPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));
		guiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));

		// Just a quick and dirty test coding ...
		NimRODFontDialog d = new NimRODFontDialog(null);
		Component[] c = d.getContentPane().getComponents();
		guiPanel.add(c[0]);
		
		add(guiPanel, BorderLayout.NORTH);
	}

	/**
	 * Use the current value of the check box to enable or disable
	 * the text field and label components.
	 */

	private void updateElements() {
		final boolean selected = checkboxGUI.isSelected();
		
		textfieldGUI.setEnabled(selected);
		labelGUI.setEnabled(selected);
	}

	/**
	 * Returns the value of the input field as double.
	 * 
	 * @return the value of the input field, or {@code null}
	 */

	public Double getValueAsDouble() {
		return checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;
	}

	/**
	 * Returns the value of the input field as integer.
	 * 
	 * @return the value of the input field, or {@code null}
	 */

	public Integer getValueAsInteger() {
		return checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;
	}

	/**
	 * Convenience function: enters this object as the default table cell
	 * renderer for type {@link java.util.Date}.
	 * This is the expected usage for this class.
	 * 
	 * @param table
	 */

	public void enterMeForTypeDate(JTable table) {
		table.setDefaultRenderer(java.util.Date.class, this);
	}

	/**
	 * Adds a level to be displayed
	 * @param level level to be displayed
	 */

	public void addLevel(Level level) {
		displayedLevels.add(level);
		if (displayedLevels.size() < levelsPerPage) {
			lastLevelIndex = displayedLevels.size() - 1;
		} else {
			lastLevelIndex = levelsPerPage - 1;
		}
	}

	/**
	 * Returns whether the field is set "active".
	 * 
	 * @return <code>true</code> if the field is active, and
	 *        <code>false</code> otherwise
	 */

	public boolean isFieldActive() {
		return textfieldGUI.isEnabled();
	}

	/**
	 * Adds a collection of levels to be displayed
	 * @param collection collection of levels
	 * @param startNumber index of the start level in the collection
	 * @param endNumber index of the end level in the collection
	 */

	public void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {
		for(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {
			addLevel(collection.getLevel(levelNo));
		}
	}

	/**
	 * Sets a new value for the display field.<br>
	 * If the value is higher than the maximum or lower than the minimum,
	 * the maximum or minimum value is used, respectively.
	 * In any case the effectively used value is returned.
	 * 
	 * @param value the value to be set
	 * @return the set value
	 */

	public double setValue(double value) {

		double rc = value;
		if (value > maximumValue) {
			rc = maximumValue;
		} else if (value < minimumValue) {
			rc = minimumValue;
		} else {
			rc = value;
		}
		textfieldGUI.setValue(rc);

		return rc;		
	}

	/**
	 * Method for closing the window after the ok-button has been clicked
	 * 
	 * @param actionevent the action event to be analyzed
	 */

	public void actionPerformed(ActionEvent actionevent) {
		if (actionevent.getActionCommand() == "okbutton") {
			dispose();
		}
	}

	/**
	 * Informs all listeners using objects generated by the passed generator.
	 * While calling the listener method for this notification this
	 * ListenerSet object is not synchronized, any more.
	 * Only the initial copying of the listener list is synchronized.
	 * 
	 * @param eventgen generates the events to be passed to the listeners
	 *                  ({@code null} is taken to generate {@code nulls})
	 */

	public void informAllUnsync(Generator<E> eventgen) {
		/*
		 * We must not directly use (weakhashmap.keySet()), since it still
		 * is coupled to the weakhashmap itself, which needs synchronization.
		 * Hence we first must obtain a copy.
		 */
		for (L listener : getListenersCopy()) {
			final E evt = ((eventgen != null) ? eventgen.generate() : null);
			caller.call(listener, evt);
		}
	}

	/**
	 * Sets up the button for the "start" version.
	 */

	public void setToStart() {
		setTo(true);
	}

	/**
	 * Sets up the button for the "stop" version.
	 */

	public void setToStop() {
		setTo(false);
	}

	/**
	 * Sets up the button for the indicated version.
	 * 
	 * @param forStart whether to set up for the "start" version
	 */

	private void setTo( boolean forStart ) {
		String textkey = (forStart ? startkey           : stopkey          );
		String action  = (forStart ? startActionCommand : stopActionCommand);
		
		setText(Texts.getText( textkey ));
		setActionCommand( action );
		
		setupBorder(forStart);
		setupBgColor(forStart);
	}

	/**
	 * Partial setup regarding the border.
	 * 
	 * @param forStart whether to set up for the "start" version
	 */

	private void setupBorder(boolean forStart) {
		setBorder( useBorder ? makeBorder(forStart) : null );
	}

	/**
	 * Partial setup regarding the background color.
	 * 
	 * @param forStart whether to set up for the "start" version
	 */

	private void setupBgColor(boolean forStart) {
		if (useBgColor) {
			int rgb = (forStart ? bgColorStart : bgColorStop);
			
			setBackground( new Color(rgb) );
			setOpaque(false);
		} else {
			// FFS/hm: should we actively put away a background color?
		}
	}

	/**
	 * Create the border for the indicated version.
	 * Does <em>not</em> look at {@link #useBorder}.
	 * 
	 * @param forStart whether to create it for the "start" version
	 * @return         border for the indicated version
	 */

	public Border makeBorder(boolean forStart) {
		int rgb = (forStart ? borderColorStart : borderColorStop);
		return makeRgbBorder(rgb, useRoundedCorners);
	}

	/**
	 * Creates and returns a border for the "start" version.
	 * Does <em>not</em> look at {@link #useBorder}.
	 * 
	 * @return border for a "start" version
	 */

	public Border makeStartBorder() {
		return makeBorder(true);
	}

	/**
	 * Creates and returns a border for the "stop" version.
	 * Does <em>not</em> look at {@link #useBorder}.
	 * 
	 * @return border for a "stop" version
	 */

	public Border makeStopBorder() {
		return makeBorder(false);
	}

	/**
	 * Does not have effect before the next {@link #setToStart()}
	 * or {@link #setToStop()}.
	 * @param useBorder the useBorder to set
	 */

	public void setUseBorder(boolean useBorder) {
		this.useBorder = useBorder;
	}

	/**
	 * Does not have effect before the next {@link #setToStart()}
	 * or {@link #setToStop()}.
	 * @param useBgColor the useBgColor to set
	 */

	public void setUseBgColor(boolean useBgColor) {
		this.useBgColor = useBgColor;
	}

	/**
	 * Does not have effect before the next {@link #setToStart()}.
	 * @param borderColorStart the borderColorStart to set
	 */

	public void setBorderColorStart(int borderColorStart) {
		this.borderColorStart = borderColorStart;
	}

	/**
	 * Does not have effect before the next {@link #setToStop()}.
	 * @param borderColorStop the borderColorStop to set
	 */

	public void setBorderColorStop(int borderColorStop) {
		this.borderColorStop = borderColorStop;
	}

	/**
	 * Does not have effect before the next {@link #setToStart()}.
	 * @param bgColorStart the bgColorStart to set
	 */

	public void setBgColorStart(int bgColorStart) {
		this.bgColorStart = bgColorStart;
	}

	/**
	 * Does not have effect before the next {@link #setToStop()}.
	 * @param bgColorStop the bgColorStop to set
	 */

	public void setBgColorStop(int bgColorStop) {
		this.bgColorStop = bgColorStop;
	}

	/**
	 * Computes and returns whether the rectangle given by the left upper corner
	 * and both dimensions is completely outside the specified clip rectangle.
	 * When the clip rectangle is missing, it is considered to be arbitrarily large.
	 * 
	 * @param x    x of upper left corner
	 * @param y    y of upper left corner
	 * @param xlen width
	 * @param ylen height
	 * @param clip rectangle we compare against
	 * @return whether (x,y,xlen,ylen) is completely outside of "clip"
	 */

	static private boolean isOutsideClip(int x, int y, int xlen, int ylen, Rectangle clip) {

		// Non-existing rectangle stands for the complete plane => nothing is outside of the complete plane.
		// We are "outside" of "clip", if we do not intersect with it.
		return clip != null && ! clip.intersects(x, y, xlen, ylen);
		
	}

	/**
	 * Returns whether this shortcut has an alias.
	 * 
	 * @return <code>true</code> if this shortcut has an alias,
	 *        <code>false</code> otherwise
	 */

	public boolean hasAlias() {
		return (alias.length() > 0);
	}

	/**
	 * Returns the alias of this shortcut.
	 * 
	 * @return the alias of this shortcut
	 */

	public String getAlias() {
		return alias;
	}

	/**
	 * Sets the alias of this shortcut.
	 * 
	 * @param newAlias the new alias of this shortcut
	 */

	public void setAlias(String newAlias) {
		alias = newAlias;
	}

	/**
	 * Returns the path stored in this shortcut.
	 * 
	 * @return the path
	 */

	public String getPath() {
		return path;
	}

	/**
	 * Returns the name of this shortcut.
	 * <p>
	 * If there is an alias this alias is returned. Otherwise the path is returned.
	 * 
	 * @return the name of this shortcut
	 */

	public String getName() {
		if (hasAlias()) {
			return alias;
		}
		return path;
	}

	/**
	 * Returns formatted shortcut's name for display.
	 *
	 * @return the display name of this shortcut
	 */

	public String getDisplayName() {
		if (hasAlias()) {
			return '[' + alias + ']';
		}
		return path;
	}

	/**
	 * Extracts the graphic specified by the passed name from the passed graphic
	 * which contains all graphics of the skin.
	 * <p>
	 * This method is only used for reducing the lines of code when extracting
	 * the graphics from the entire graphic containing all skin graphics.
	 * This method assumes that the position of the graphic to be extracted
	 * is stored in the settings as "x, y" coordinates.
	 * 
	 * @param entireGraphic  skin graphic containing all skin graphics
	 * @param graphicName  the name of the graphic to extract
	 * @return the extracted <code>BufferedImage</code>
	 */

	private BufferedImage extractGraphicTwoCoordinates(BufferedImage entireGraphic, String graphicName) {
	
		try {
			Point graphicCoordinates = getPoint(graphicName);
			if(graphicCoordinates != null) {
				return entireGraphic.getSubimage(graphicCoordinates.x * graphicWidth,
						                         graphicCoordinates.y * graphicHeight,
						                         graphicWidth, graphicHeight);
			}
		} catch (Exception e) {
			if(Settings.isDebugModeActivated) {
				e.printStackTrace();
			}
		}
		
		return null;
	}

	/**
	 * Returns the color of this shortcut.
	 * 
	 * @return the color of this shortcut
	 */

	public Color getColor() {
		return color;
	}

	/**
	 * Sets the color of this shortcut.
	 * 
	 * @param color color to be set
	 */

	public void setColor(String color) {
		this.color = parseColor(color);
	}

	/**
	 * Sets the board this GUI shows.
	 * 
	 * @param board board to be shown
	 */

	public void setBoardToDisplay(Board board) {

		// Save the reference.
		this.board = board;

		// Create new array for storing information about which positions have to be drawn when repainting.
		graphicStatus = new byte[board.size];

		// Initialize the debug array used for showing numbers on the board.
		Arrays.fill(numbersToShow, -1);

		// Reset the transformation of the board.
		transformBoard(-1);
	}

	/**
	 * Returns the <code>String</code> representation of the shortcut's color.
	 * 
	 * @return color of this shortcut as <code>String</code>
	 */

	public String getColorString() {
		return colorToString(color);
	}

	/**
	 * Extracts the graphic specified by the passed name from the passed graphic
	 * which contains all graphics of the skin.
	 * <p>
	 * This method is only used for reducing the lines of code when extracting
	 * the graphics from the entire graphic containing all skin graphics.
	 * This method assumes that only the x-coordinate is relevant for locating
	 * a sub graphic in the entire graphic. 
	 * 
	 * @param entireGraphic  skin graphic containing all skin graphics
	 * @param graphicName  the name of the graphic to extract
	 * @return the extracted <code>BufferedImage</code>
	 */

	private BufferedImage extractGraphicOneCoordinate(BufferedImage entireGraphic, String graphicName) {
	
		try {
			int xCoordinate = getInt(graphicName, -1);
			if(xCoordinate == -1) {
				return null;
			}
			return entireGraphic.getSubimage(xCoordinate * graphicWidth, 0, graphicWidth, graphicHeight);
		} catch (Exception e) {
			if(Settings.isDebugModeActivated) {
				e.printStackTrace();
			}
		}
		
		return null;
	}

	/**
	 * Erase any comments of the passed property string.
	 * A comment starts at the first '#' (hash sign).
	 * Also, blanks and tabs are trimmed from the (right) end of the result.
	 * 
	 * @param propertyValue value of a property as a String
	 * @return trimmed value
	 */

	private String trimValue(String propertyValue) {
	
		if (propertyValue == null || propertyValue.length() == 0) {
			return "";
		}
	
		int lastpos = propertyValue.indexOf('#');
		if (lastpos == -1) {
			lastpos = propertyValue.length() - 1;
		}
		
		
		for(; lastpos >= 0 ; --lastpos ) {
			char c = propertyValue.charAt(lastpos);
			if (c != ' ' && c != '\t') {
				break;
			}
		}
		
		// Now, "lastpos" indexes the last char to be retained (or -1 if there is none)
		
		// Return the trimmed value.
		return propertyValue.substring(0, lastpos + 1);
	}

	/**
	 * Returns the current transformation as String.
	 * This String is saved into the file of the level as information.
	 * Note: this string is NOT influenced by any language settings.
	 * 
	 * @return the transformation as <code>String</code>
	 * @see #newlevel()
	 */

	static public String getTransformationAsString() {

		// If the level isn't displayed transformed return an empty String.
		if (getRotationValue() == ROTATION_BY_0_DEGREES && isLevelFlippedHorizontally() == false) {
			return "";
		}

		// Build the transformation string and return it.
		String transformationString = "View: Rotated "
			                        + getRotationAsString()
			                        + " degrees clockwise";
		if (isLevelFlippedHorizontally()) {
			transformationString += ", flipped horizontally.";
		} else {
			transformationString += ".";
		}

		return transformationString;
	}

	/**
	 * This default generator implementation just returns the {@link #base}
	 * object reference.
	 * That probably works only for immutable types T.
	 * <p>
	 * Most implementations should override this method by something that
	 * clones the {@link #base} or uses it as basis for a constructor.
	 * E.g. ActionEvents are neither immutable nor do they support cloning.
	 * 
	 * @return the next generated object
	 */

	public T generate() {
		return base;
	}

	/**
	 * Creates a button for the tool bar.
	 * 
	 * @param iconName		the name of the icon for the button
	 * @param actionCommand the action command of the button
	 * @param toolTipText 	the tool tip text for the button
	 * @return the created button
	 * @see #createToolBarButtonByKey(String, String, String)
	 */

	final private JButton createToolBarButton(String iconName, String actionCommand, String toolTipText) {

		// Create and initialize the button.
		JButton button = new JButton(Utilities.getIcon(iconName, null));
		button.setActionCommand(actionCommand);
		button.setToolTipText(toolTipText);
		button.addActionListener(this);

		// The buttons must be clicked with the mouse.
		button.setFocusable(false);

		return button;
	}

	/**
	 * Returns the currently used skin.
	 * 
	 * @return the <code>Skin</code> currently used
	 */

	public Skin getCurrentSkin() {
		return skin;
	}

	/**
	 * Returns the string corresponding to the passed property name.
	 * 
	 * @param name name of property	
	 * @param defaultValue value to be set if the property value can't be set
	 * @return value of the property as string or null, if no property is found
	 */

	private String getString(String name, String ... defaultValue) {
	
		// Get the value of the property.
		String propertyValue = trimValue(properties.getProperty(name));
	
		// If the the property couldn't be found set the default value.
		if (propertyValue == null) {
			if(defaultValue.length > 0) {
				return defaultValue[0];
			}
		}
	
		return propertyValue;
	}

	/**
	 * Creates a button for the tool bar.
	 * 
	 * @param iconName       the name of the icon for the button
	 * @param actionCommand  the action command of the button
	 * @param toolTipTextKey the text key for the tool tip text for the button
	 * @return the created button
	 * @see #createToolBarButton(String, String, String)
	 */

	final private JButton createToolBarButtonByKey(String iconName, String actionCommand, String toolTipTextKey) {
		String toolTipText = Texts.getText(toolTipTextKey);
		return createToolBarButton(iconName, actionCommand, toolTipText);
	}

	/**
	 * Sets a new delay for the animations that are shown.
	 * <p>
	 * Depending on the skin there may be an animation for a selected box and
	 * the selected player.
	 * 
	 * @param delay
	 *            the delay in milliseconds
	 */

	public void setSkinAnimationDelay(int delay) {

		// Save the delay in the settings.
		Settings.set("skinAnimationDelay", "" + delay);

		// If a timer is running set the new delay value.
		if (animationTimer != null && animationTimer.isRunning()) {
			animationTimer.setDelay(delay);
		}
	}

	/**
	 * Sets the view direction of the player to the passed direction.
	 * <p>
	 * The view direction is important for some skins in order to be able to
	 * show the correct graphic.
	 * 
	 * @param viewDirection
	 *            the view direction of the player
	 */

	public void setViewDirection(int viewDirection) {
		this.viewDirection = (byte) viewDirection;
	}

	/**
	 * Sets the maximum factor for scaling the graphics.
	 * <p>
	 * Some skins offer bad quality graphics which shouldn't be scaled too much.
	 * Hence the user can set a maximum scaling factor. This way the graphics
	 * aren't scaled beyond this factor even if there is enough space for the
	 * graphics to be drawn.
	 * 
	 * @param maximumScalingFactor
	 *            the new factor to be set
	 */

	public void setMaximumScalingFactor(int maximumScalingFactor) {

		maximumScaling = maximumScalingFactor;

		recalculateGraphicSizes();
		repaint();

		// Save the zooming factor.
		Settings.set("maximumScaling", "" + maximumScaling);
	}

	/**
	 * Sets the flag that a recalculation has to be done.
	 */

	public void recalculateGraphicSizes() {
		isRecalculationNecessary = true;
	}

	/**
	 * Transforms the board (rotation and mirroring)
	 * 
	 * @param transformationValue  kind of transformation
	 */

	public void transformBoard(int transformationValue) {

		// Tell it to the Transformation class.
		Transformation.transform(transformationValue);

		// Since the transformation may have exchanged height and width, we force a
		// recalculation of the graphics, as if we had loaded a new level.
		isRecalculationNecessary = true;

		// Show new graphics
		repaint();
	}

	/**
	 * Sets the passed level as level to be displayed in this Panel.
	 * 
	 * @param levelToBeDisplayed  the <code>Level</code> to be displayed
	 */

	public void setLevelToDisplay(Level levelToBeDisplayed) {
		
		// Create an own board.
		board = new Board(application);
		
		// Set the passed level on the board.
		try {
			board.setBoardFromString(levelToBeDisplayed.getBoardDataAsString());
		} catch (Exception e) {
			// Show the error message.
			Utilities.showExceptionError(this, e);
		}

		// Array containing the information which graphic has to be drawn at a specific position.
		graphicStatus = new byte[board.height * board.width];
		
		// New level means every thing has to be recalculated to refresh the Panel.
		isRecalculationNecessary = true;

		// Repaint this Panel.
		repaint();
	}

	/**
	 * Sets the passed board to be displayed.
	 * 
	 * @param boardAsString the board data as <code>String</code>
	 */

	public void setBoardToDisplay(String boardAsString) {
		
		// Create an new board.
		board = new Board(application);
		
		// Create an own board from the board of the level.
		try {
			board.setBoardFromString(boardAsString);
		} catch (Exception e) {
			e.printStackTrace();
		}

		// Array containing the information which graphic has to be drawn at a specific position.
		graphicStatus = new byte[board.height * board.width];
		
		// New level means every thing has to be recalculated to refresh the Panel.
		isRecalculationNecessary = true;

		// Repaint this Panel.
		repaint();
	}

	/**
	 * Sets the flag specifying whether the infobar is to be shown or not.
	 * 
	 * @param visibleStatus
	 *            visibility status of the infobar to set
	 */

	public void setInfoBarVisible(boolean visibleStatus) {
		isInfoBarVisible = visibleStatus;
	}

	/**
	 * Sets the passed board to be displayed.
	 * 
	 * @param board the board to be displayed
	 */

	public void setBoardToDisplay(Board board) {
		
		this.board = board;
		
		// Array containing the information which graphic has to be drawn at a specific position.
		graphicStatus = new byte[board.height * board.width];
		
		// New level means every thing has to be recalculated to refresh the Panel.
		isRecalculationNecessary = true;

		// Repaint this Panel.
		repaint();
	}

	/**
	 * Returns the <code>Board</code> displayed in this class.
	 * 
	 * @return the <code>Board</code> of this class
	 */

	public Board getBoard() {
		return board;
	}

	/**
	 * Returns the <code>Level</code> displayed in this class
	 * 
	 * @return the <code>Level</code> of this class
	 */

	public Level getDisplayedLevel() {
		return displayedLevel;
	}

	/**
	 * Returns the current width of a square from the current scaled skin.
	 * @return width of a square
	 */

	public int getSquareWidth() {
		if (skin == null) {
			return 0;
		}
		return skin.graphicWidth;
	}

	/**
	 * Returns the current height of a square from the current scaled skin.
	 * @return height of a square
	 */

	public int getSquareHeight() {
		if (skin == null) {
			return 0;
		}
		return skin.graphicHeight;
	}

	/**
	 * Sets the flag indication that the sizes must be recalculated.
	 * If e.g. we switch into editor mode, we have less space for the board,
	 * since we have to draw some objects for the editor.
	 */

	final public void recalculateGraphicSizes() {
		isRecalculationNecessary = true;
	}

	/**
	 * Resets the <code>board</code> and the player position members
	 * from the <code>boardInitial</code> member.
	 */

	private void setInitialBoardPosition() {
		board      = boardInitial.boardElements.clone();
		playerPosX = boardInitial.playerPositionX;
		playerPosY = boardInitial.playerPositionY;
	}

	/**
	 * Repaints the GUI immediately.
	 * This is the sledge-hammer method: everything is painted, again.
	 */

	public void paintImmediately() {
		paintImmediately(0, 0, getWidth(), getHeight());
	}

	/**
	 * Packs the passed unpacked box configuration into a new packed box configuration.
	 * 
	 * @param newPackedBoxConfiguration
	 * @param unpackedBoxConfiguration
	 */

	private void packBoxConfiguration(byte[] newPackedBoxConfiguration, byte[] unpackedBoxConfiguration) {

		int bytePosition = 0, bitPosition = 0;

		// Loop over all internal box positions.
		for (int i = 0; i < boxPositionsCount; i++) {

			bytePosition = i >> 3;
			bitPosition  = i & 7;

			if ((unpackedBoxConfiguration[boxInternalToExternalPosition[i]] & BOX) == BOX)
				newPackedBoxConfiguration[bytePosition] |= 1 << bitPosition;
			else
				newPackedBoxConfiguration[bytePosition] &= (255 - (1 << bitPosition));
		}
	}

	/**
	 * Marks the passed board position as visited.
	 * 
	 * @param boardPositionIndex
	 *            index of the board position in the visitedData array
	 */

	private void setVisited(int boardPositionIndex) {
		int bytePosition = (boardPositionIndex >>> 3), bitPosition = (boardPositionIndex & 7);
		visitedData[bytePosition] |= (1 << bitPosition);
	}

	/**
	 * Sets the cursor image to the specified cursor.
	 * 
	 * @param cursor The value of the cursor to be set
	 */

	final public void setCursor(int cursor) {

		// Set the specified predefined cursor.
		mainBoardDisplay.setCursor(Cursor.getPredefinedCursor(cursor));
	}

	/**
	 * If the coordinates of the point aren't located on the board
	 * they are adjusted so they are on the edge of the board.
	 * 
	 * @param p  <code>Point</code> containing the data which is adjusted
	 */

	protected void adjustToBoard(Point p) {
		
		// Clip both point coordinates at their allowed minimum (inclusive).
		if( p.x < xOffset ) {
			p.x = xOffset;
		}
		if( p.y < yOffset ) {
			p.y = yOffset;
		}
		
		// Compute maximal point coordinates, inclusive...
		int xmax = xOffset + Transformation.getOutputLevelWidth()  * skin.graphicWidth  - 1;
		int ymax = yOffset + Transformation.getOutputLevelHeight() * skin.graphicHeight - 1;
		
		// ... and use them to clip off larger values:
		if( p.x > xmax ) {
			p.x = xmax;
		}
		if( p.y > ymax ) {
			p.y = ymax;	
		}
	}

	/**
	 * Repaints part of the GUI immediately.  Only a rectangle inside the board is
	 * considered to be changed, specified in external board square coordinates.
	 * But, the number of moves and pushes has also be considered to be changed,
	 * which implies some more updates.
	 * 
	 * @param xmin      upper left X of board square rectangle
	 * @param ymin      upper left Y of board square rectangle
	 * @param extWidth  width  of rectangle in board squares
	 * @param extHeight height of rectangle in board squares
	 */

	private void paintExtSqRect(int xmin, int ymin, int extWidth, int extHeight) {
		int pixXmin   = xOffset + xmin * skin.graphicWidth;
		int pixYmin   = yOffset + ymin * skin.graphicHeight;
		int pixWidth  =      extWidth  * skin.graphicWidth;
		int pixHeight =      extHeight * skin.graphicHeight;
		
		if (pixWidth > 0 || pixHeight > 0) {
			repaint(pixXmin, pixYmin, pixWidth, pixHeight);
			paintMovesPushes();
		}
	}

	/**
	 * Returns the influence distance between the start and the target square.
	 * The higher the distance the less influence the target square has
	 * on the start square.
	 * 
	 * @param startSquare  position of the start square
	 * @param targetSquare position of the target square
	 * 
	 * @return influence distance from the start square to the target square
	 */

	public int getInfluenceDistance(int startSquare, int targetSquare) {
		return influenceDistances[startSquare][targetSquare];
	}

	/**
	 * This method sets the currently set language in all menu bar
	 * and tool bar components.
	 */

	final public void setNewLanguage() {

		// Create a new menu bar and and a new tool bar according to the new language.
		application.setJMenuBar(createMenuBar());
		createToolBar();
	}

	/**
	 * Returns whether the board position (box + player positions) is marked as
	 * visited.
	 * 
	 * @param boardPositionIndex
	 *            index of the board position in the visitedData array
	 * @return <code>true</code>board position has already been visited;
	 *         <code>false</code>otherwise
	 */

	private boolean isVisited(int boardPositionIndex) {
		int i = (boardPositionIndex >>> 3), j = (boardPositionIndex & 7);
		return (visitedData[i] & (1 << j)) > 0;
	}

	/**
	 * Inserts a move of the player into the history.
	 * 
	 * @param direction	into which the player moved
	 */

	final public void addPlayerMove(int direction) {
		addMovement(direction, -1);
	}

		/**
		 * Set the collected values back to the initial values,
		 * indicating an empty range.
		 */

		public void clear() {
			minX = Integer.MAX_VALUE;
			maxX = Integer.MIN_VALUE;
			minY = Integer.MAX_VALUE;
			maxY = Integer.MIN_VALUE;
		}

	/**
	 * Returns the next movement from the history,
	 * and advances the "current" pointer to it.
	 * 
	 * @return <code>null</code>, or the <code>HistoryElement</code> containing the data
	 *         for the next movement of the history
	 */

	final public HistoryElement getSuccessorMovement() {
		if (hasSuccessorMovement() == false) {
			return null;
		}
		return movementHistory.get( ++currentMovementNo );
	}

	/**
	 * Returns the previously executed movement from the history,
	 * and moves back the "current" pointer before it.
	 * 
	 * @return <code>null</code>, or the <code>HistoryElement</code> containing the data
	 *         for the previously executed movement 
	 */

	final public HistoryElement getPrecedingMovement() {
		if (hasPrecedingMovement() == false) {
			return null;
		}
		return movementHistory.get( currentMovementNo-- );
	}

	/**
	 * Returns the movement with the given number.
	 * 
	 * @param movementNo number of the movement to be returned
	 * @return  <code>null</code>, or the <code>HistoryElement</code> of the movement
	 *          with the given number
	 */

	final public HistoryElement getMovement(int movementNo) {

		if (movementNo < 0 || movementNo > movementHistory.size() - 1) {
			return null;
		}
		return movementHistory.get(movementNo);
	}

	/**
	 * Returns the index of the last executed movement.
	 * That is also the count of the player moves up to now/here. 
	 * 
	 * @return index of the last executed movement
	 */

	final public int getCurrentMovementNo() {
		return currentMovementNo;	
	}

		/**
		 * Returns whether the collected area is empty.
		 * 
		 * @return whether the area is empty
		 */

		public boolean isEmpty() {
			return (minX > maxX) || (minY > maxY);
		}

	/**
	 * Returns the total count of the stored movements.
	 * 
	 * @return total count of movements
	 */

	final public int getMovementsCount() {
		return movementHistory.size();
	}

	/**
	 * Returns the (total) number of pushes contained in the history.
	 * 
	 * @return number of pushes in the history
	 */

	final public int getPushesCount() {

		int pushesCount = 0;

		for (HistoryElement historyElement : movementHistory) {
			if (historyElement.pushedBoxNo != -1) {
				pushesCount++;
			}
		}
		return pushesCount;
	}

	/**
	 * Returns the LURD string of all movements up to the current movement.
	 * 
	 * @return LURD string till the current movement (inclusive)
	 * @see #getLURDString(int, int)
	 */

	final public String getLURDString() {
		return getLURDString(0, currentMovementNo);
	}

		/**
		 * Adds a point to the area, given by its components.
		 * 
		 * @param x
		 * @param y
		 */

		public void add(int x, int y) {
			minX = Math.min(minX, x);
			maxX = Math.max(maxX, x);
			minY = Math.min(minY, y);
			maxY = Math.max(maxY, y);
		}

	/**
	 * Returns the complete LURD string of all movements, independent from the
	 * current point inside of the history.
	 * 
	 * @return LURD string till the end (inclusive)
	 * @see #getLURDString(int, int)
	 */

	final public String getLURDStringTotal() {
		return getLURDString(0, getMovementsCount() - 1);
	}

	/**
	 * Sets the history to the first movement.
	 */

	final public void setHistoryToStart() {
		currentMovementNo = -1;
	}

	/**
	 * Sets the "current" pointer to the specified index.
	 * This changes to reference point for further "undo" and "redo" operations.
	 * This is the way to quickly jump to an arbitrary point in the history.
	 *
	 * @param movementNo the movement number to be set
	 */

	final public void setMovementNo(int movementNo) {
		currentMovementNo = movementNo;
	}

	/**
	 * Sets the marker which indicates that the next movement will be the start
	 * of a combined movement.
	 */

	final public void setStartOfCombinedMovement() {
		isStartOfCombinedMovement = true;
	}

		/**
		 * Collect another external position.
		 * External positions are what is handled in the GUI, they reflect screen
		 * positions after any transformation.
		 * 
		 * @param externalPos <code>-1</code>. or external position to collect
		 */

		public void addExternal(int externalPos) {
			if (externalPos != -1) {
				int externalWidth = Transformation.getOutputLevelWidth();
				int extX = externalPos % externalWidth;
				int extY = externalPos / externalWidth;
				
				add(extX, extY);
			}
		}

	/**
	 * Sets back the "current" pointer to the previous movement.
	 * This operation is unchecked / unconditional.
	 */

	final public void goToPrecedingMovement() {
		currentMovementNo--;
	}

	/**
	 * Sets forward the "current" pointer to the next movement.
	 * This operation is unchecked / unconditional.
	 */

	final public void goToNextMovement() {
		++currentMovementNo;
	}

		/**
		 * Collect another internal position (from the model).
		 * Before it is collected, it must be translated to an external position
		 * according to the current transformation.
		 * 
		 * @param internalPos <code>-1</code>. or internal position to collect
		 */

		public void addInternal(int internalPos) {
			if (internalPos != -1) {
				int externalPos = Transformation.getExternalPosition(internalPos);
				
				addExternal(externalPos);
			}
		}

	/**
	 * Returns whether there is a preceding movement.
	 * 
	 * @return <code>true</code>, if there is a  preceding movement,<br>
	 *   	  <code>false</code>, if there is no preceding movement
	 */

	final public boolean hasPrecedingMovement() {
		return currentMovementNo >= 0;
	}

	/**
	 * Returns whether there is a successor movement.
	 * 
	 * @return <code>true</code> if there is a  successor movement,<br>
	 * 		  <code>false</code> if there is no successor movement
	 */

	final public boolean hasSuccessorMovement() {
		return (currentMovementNo + 1) < movementHistory.size();
	}

	/**
	 * Repaints part of the GUI.
	 * Just the number of moves and the number of pushes is considered changed.
	 */

	private void paintMovesPushes() {
		// Moves and pushes are displayed as part of the history slider panel.
		if (historySliderPanel != null) {
			// We have to include the textual representation, as well as the graphical
			// slider representation.  That includes most of the area.
			int w = historySliderPanel.getWidth();
			int h = historySliderPanel.getHeight();
			
			// Redraw the slider. This needn't to be done immediately. Repaint is much
			// faster then paintImmediately.
			historySliderPanel.repaint(0, 0, w, h);
		}
	}

	/**
	 * Return the number of steps to the preceding element one can do,
	 * until the first movement is reached, or one that is marked to be
	 * the start of a combined movement.
	 * 
	 * @return length of the last combined movement
	 */

	final public int combinedLengthPreceding() {
		int steps = 0;
		
		for( int mNo = currentMovementNo; mNo >= 0 ; --mNo ) {
			HistoryElement histElem = getMovement(mNo);
			
			if( histElem == null ) {
				break;
			}
			++steps;
			if( histElem.isStartOfCombinedMovement ) {
				break;
			}
		}
		return steps;
	}

	/**
	 * Return the length of the next combined movement, i.e. how many steps
	 * forward can we do until we find an element which is marked to be
	 * the start of a combined movement (excluding the current element).
	 * 
	 * @return length of the next combined movement
	 */

	final public int combinedLengthSuccessor() {
		int steps = 0;
		int mNo = currentMovementNo;
		
		for(;;) {
			++mNo;
			
			HistoryElement histElem = getMovement(mNo);
			
			if( histElem == null ) {
				break;
			}
			++steps;
			if( histElem.isStartOfCombinedMovement ) {
				break;
			}
		}
		
		return steps;
	}

	/**
	 * Starting with the current movement, count the number of combined
	 * segments.  Even when the first (current) movement is not marked
	 * to be the start of a combined movement, we count it as start
	 * of such a segment.
	 * 
	 * @return count of segments starting at current movement
	 */

	final public int countCombinedForward() {
		int starts = 0;
		int mNo = currentMovementNo;
		
		for(;;) {
			HistoryElement histElem = getMovement(mNo);
			
			if( histElem == null ) {
				break;
			}
			if( histElem.isStartOfCombinedMovement ) {
				++starts;
			} else if( starts == 0 ) {
				++starts;
			}
			++mNo;
		}
		
		return starts;
	}

	/**
	 * Starting with the current movement we scan forward and compute the
	 * average length of combined segments.
	 * @return average length of movement segments starting at current movement
	 */

	final public float averageLengthCombinedForward() {
		int len = getMovementsCount() - currentMovementNo;
		if( len <= 0 ) {
			return 0.0f;
		}
		int cntcombined = countCombinedForward();
		return (float)len / cntcombined;
	}

	/**
	 * Returns if a box has been pushed.
	 * 
	 * @return true = A box has been pushed, false = no box has been pushed
	 */

	public boolean isABoxBeenMoved() {
		return pushedBoxNo != -1;
	}

	/**
	 * Returns the mouse listener for this class.
	 * 
	 * @return the mouse listener
	 */

	private MouseListener getMouseListener() {
		return new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if(e.getClickCount() > 1) {
					int index = locationToIndex(e.getPoint());
					if (index >= 0) {
						
						// This action can be disabled (for instance when the solver is running).
						if(!isTakeSolutionAsHistoryEnabled) {
							return;
						}
						
						Solution clickedSolution = (Solution) listModel.getElementAt(index);
						
						// Set the selected solution as new history in the game.
						application.takeSolutionForHistory(clickedSolution);
					}
				}
			}
		};
	}

	/**
	 * Sets whether the editor menu item is enabled.
	 * @param enabled
	 */

	final public void setEditorMenuItemEnabled(boolean enabled) {
		editorMenuItem.setEnabled(enabled);
	}

	/**
	 * Returns the menu item for saving a level.
	 * 
	 * @return the <code>JMenuItem</code> for saving a level
	 */

	final public JMenuItem getSaveLevelMenuItem() {
		return saveLevelMenuItem;
	}

	/**
	 * Returns the button for showing info in the menu bar.
	 * <p>
	 * The caller can fully access this button.
	 * 
	 * @return the <code>JMenuItem</code> for saving a level
	 */

	final public JButton getInfoButton() {
		return infoButton;
	}

	/**
	 * Sets the objects enabled or disabled depending on the current mode
	 * (play or editor mode). 
	 */

	final public void setModeDependentObjectStatus() {

		// Ensure to change status on the EDT (event dispatcher thread),
		// because this method may be called from a background thread.
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				for (Component button : playModeDependentObjects) {
					button.setEnabled(application.isPlayModeActivated());
				}

				for (AbstractButton button : editorModeDependentObjects) {
					button.setEnabled(application.isEditorModeActivated());
				}
			}
		});
	}

	/**
	 * Displays the passed board position for debug purposes.
	 * 
	 * @param storage
	 *            storage the box configuration is stored in
	 * @param boardPositionIndex
	 *            index of the board position in the visited data array
	 * @param graphicOutput
	 *            flag, indicating whether there should be a graphical display
	 *            or not
	 * @param waitForEnter
	 *            flag, indicating whether the program has to wait for "enter"
	 *            after displaying the box configuration
	 */

	private void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boardPositionIndex, final boolean graphicOutput, final boolean waitForEnter) {
		byte[] temp = new byte[packedBoardByteSize];
		storage.copyBoxConfiguration(temp, boardPositionIndex / playerSquaresCount);
		int playerPosition = boardPositionIndex % playerSquaresCount;
		debugDisplayBoxConfiguration(temp, playerPosition, graphicOutput, waitForEnter);
	}

	/**
	 * Sets a color for the passed <code>Solution</code> in this GUI.
	 * <p>
	 * If "null" is passed as color the solution is set back to the default color.
	 * 
	 * @param solution the <code>Solution</code> to be colored
	 * @param color the <code>Color</code>
	 */

	public void setSolutionColor(Solution solution, Color color) {
		if(color == null) {
			coloredSolutions.remove(solution);
		} else {
			coloredSolutions.put(solution, color);
		}
	}

	/**
	 * Sets the status of the solver mode dependent objects.
	 * 
	 * @param enabledStatus <code>true</code>, if the objects are enabled, and
	 * 						<code>false</code> if the objects are disabled
	 */

	final public void setSolverDependentObjectsEnabled(final boolean enabledStatus) {
		
		// Ensure to change status on the EDT (event dispatcher thread),
		// because this method may be called from a background thread.
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				for (Component component : solverModeDependentObjects) {
					component.setEnabled(enabledStatus);
				}
			}
		});
	}

		/**
		 * Returns whether the the current solution type is a valid
		 * and new solution.
		 * @return <code>true</code> if the solution is a valid new solution,
		 *   or<br><code>false</code> otherwise
		 */

		public boolean isValidNewSolution() {
			return this != INVALID_SOLUTION && this != DUPLICATE_SOLUTION;
		}

	/**
	 * Sets the background color for all solutions to the default color.
	 */

	public void setAllSolutionsUncolored() {
		coloredSolutions.clear();
	}

	/**
	 * Makes a single row "selected".
	 * When the passed view row index is negative (e.g. as result of a
	 * failed conversion) the current selection remains unchanged.
	 * 
	 * @param viewrowindex the view index of the row to be selected
	 */

	private void setSelectedViewRow(int viewrowindex) {
		if (       (viewrowindex >= 0)
				&& (tableModelSolutionData != null)
				&& (tableModelSolutionData.getRowCount() > 0)
				&& (tableSolutionData != null)) {
			ListSelectionModel lsm = tableSolutionData.getSelectionModel();
			lsm.setSelectionInterval(viewrowindex, viewrowindex);
		}
	}

	/**
	 * Adds the passed {@code ActionListener} to the listeners being informed
	 * when an action is fired. 
	 * 
	 * @param actionListener  the {@code ActionListener} to be added
	 */

	public void addActionListener(ActionListener actionListener) {
		actionListenerSet.register(actionListener);
	}

	/**
	 * Shows an information dialog with translated title "note" and the message text
	 * for the text key "solutionList.noSolutionSelected".
	 */

	protected void showNoSolutionsSelected() {
		Utilities.showInfoNoteTextKey(getParent(), "solutionList.noSolutionSelected");
	}

	/**
	 * Removes the passed {@code ActionListener} from the listeners of this object.
	 * 
	 * @param actionListener  the {@code ActionListener} to be removed
	 */

	public void removeActionListener(ActionListener actionListener) {
		actionListenerSet.unregister(actionListener);
	}

	/**
	 * Displays the passed board position for debug purposes.
	 * 
	 * @param storage
	 *            storage the box configuration is stored in
	 * @param boxConfigurationIndex
	 *            index of the box configurtaion in the visited data array
	 * @param playerPosition
	 * 		      position of the player in internal format
	 * @param graphicOutput
	 *            flag, indicating whether there should be a graphical display
	 *            or not
	 * @param waitForEnter
	 *            flag, indicating whether the program has to wait for "enter"
	 *            after displaying the box configuration
	 */

	private void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boxConfigurationIndex, int playerPosition, final boolean graphicOutput, final boolean waitForEnter) {
		byte[] temp = new byte[packedBoardByteSize];
		storage.copyBoxConfiguration(temp, boxConfigurationIndex);
		debugDisplayBoxConfiguration(temp,playerPosition, graphicOutput, waitForEnter);
	}

	/**
	 * Sets the enabled status of the undo buttons.
	 * 
	 * @param enabledStatus <code>true</code>, if the objects are enabled, and
	 * 						<code>false</code> if the objects are disabled
	 */

	final public void setUndoButtonsEnabled(final boolean enabledStatus) {

		// Ensure to change status on the EDT, because this method may be called from a background thread.
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				for (Component component : undoButtons) {
					component.setEnabled(enabledStatus);
				}
			}
		});
	}

		/**
		 * Handles the mouse event "mouseDragged".
		 * 
		 * @param evt  the event that has been fired
		 */

		public void mouseDragged(MouseEvent evt) {
		
			if(isMouseDragged == false) {
			
				startOfLastDrag = evt.getWhen();
				
				// Save the dragged status.
				isMouseDragged = true;
			}
			
			mousePressed(evt);
		}		

	/**
	 * This is the kernel of {@link #informListeners(Solution, String)},
	 * after that method has decided, in which thread we have to work.
	 * @param solution
	 * @param action
	 */

	private void informThemHere(final Solution solution, final String action) {
		actionListenerSet.informAllSync(makeActionGenerator(solution, action));
	}

	/**
	 * Informs all listeners about a change of the stored solutions.
	 * <p>
	 * The listeners must know which actions can be caught from this class
	 * (this avoids an extra interface containing methods for the different actions).
	 */

	private void informListeners(final Solution solution, final String action) {
	
		// The GUI should be updated in the EDT.
		if(SwingUtilities.isEventDispatchThread()) {
			informThemHere(solution, action);
		}
		else {
			// Update the GUI before this thread continues. 
			try {
				SwingUtilities.invokeAndWait(new Runnable() {
					@Override
					public void run() {
						informThemHere(solution, action);
					}
				});
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			} catch (InvocationTargetException e) { /* just continue */ }
		}
	}

	/**
	 * Sets the visibility of the "take solution as history" menu item.
	 * 
	 * @param isVisible <code>true</code> sets the "take solution as history" menu item visible
	 * 				   <code>false</code> sets the "take solution as history" menu item invisible
	 */

	public void setTakeSolutionAsHistoryVisible(boolean isVisible) {
		isTakeSolutionAsHistoryEnabled = isVisible;
	}

	/**
	 * Sets the enabled status of the redo buttons.
	 * 
	 * @param enabledStatus <code>true</code> if the objects are enabled, and
	 * 					   <code>false</code> if the objects are disabled
	 */

	final public void setRedoButtonsEnabled(final boolean enabledStatus) {

		// Ensure to change status on the EDT, because this method may be called from a background thread.
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				for (Component component : redoButtons) {
					component.setEnabled(enabledStatus);
				}
			}
		});
	}

		/**
		 * Add the passed solution as solution to be highlighted.
		 * 
		 * @param solution <code>Solution</code> to be highlighted
		 */

		public void addSolutionToBeHighlighted(Solution solution) {
			highlightedSolutions.put(solution, 10);
			
			// Inform this thread that new solutions are to be highlighted.
			synchronized(this) {
				notify();
			}
		}

		/**
		 * Removes all solutions to be highlighted.
		 */

		public void removeAllSolutionsToBeHighlighted() {
			highlightedSolutions.clear();
		}

		/**
		 * Returns the intensity the passed solution is to be highlighted.
		 *
		 * @param solution the <code>Solution</code> whose highlight intensity is returned
		 * @return the highlight intensity or null if the passed solution isn't to be highlighted
		 */

		public Integer getHighlightIntensity(Solution solution) {
			return highlightedSolutions.get(solution);
		}

	/**
	 * This methods sets the enabled status of specific GUI elements.
	 * <p>
	 * If the current loaded level is invalid then some of the GUI elements
	 * have to be disabled.
	 * 
	 * @param enabledStatus  whether the GUI elements are to be enabled
	 */

	final public void setInvalidLevelModeDependentObjectsEnabled(boolean enabledStatus) {

		for (Component component : invalidLevelModeDependentObjects) {
			component.setEnabled(enabledStatus);
		}

		// An invalid level can't have a movement history.
		// Hence, disable the undo/redo buttons.
		setUndoButtonsEnabled(enabledStatus);
		setRedoButtonsEnabled(enabledStatus);

		// Enable the editor menu item so the user can open the editor.
		setEditorMenuItemEnabled(true);
	}

	/**
	 * Tell whether we currently have a valid {@code lastChanged} data.
	 * 
	 * @return whether the {@code lastChanged} data is valid
	 */

	public boolean isValidLastChanged() {
		if (lastChanged != null) {
			if (lastChanged.getTime() > 0) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Sets the debug menu visible or invisible.
	 * 
	 * @param isToBeVisible <code>true</code>, if the debug menu shall be visible, and
	 * 						<code>false</code> if the debug menu shall be invisible
	 */

	final public void setDebugMenuVisible(boolean isToBeVisible) {
		for (Component component : debugModeDependentObjects) {
			component.setVisible(isToBeVisible);
		}
	}

	/**
	 * Returns the solutions view.
	 * <p>
	 * The solutions are shown in an own JPanel at the left of the main GUI.
	 * 
	 * @return the <code>solutionsGUI</code> displaying the solutions
	 */

	public SolutionsGUI getSolutionsView() {
		return solutionsGUI;
	}

	/**
	 * Method used for the SQL commands CREATE, DROP, INSERT and UPDATE
	 * 
	 * @param expression the SQL command to be executed
	 */

	final public void update(String expression) {

		try {
			Statement st = conn.createStatement();

			// Run the query.
			if (st.executeUpdate(expression) == -1) {
				System.out.println("db error: " + expression);
			}

			// Close the Statement object.
			st.close();

		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Wait for the deadlock identification (detection) to be ready.
	 * This must be done prior to generation of box configurations,
	 * since the results of deadlock computation are used there
	 * without any further checks.
	 */

	private void waitForDeadlockIdentification() {
		try {
			if(deadlockIdentification.isAlive()) {
				optimizerGUI.setInfoText(Texts.getText("optimizer.waitingForDeadlockDetection"));
				deadlockIdentification.join();
			}
		} catch (InterruptedException e) {}
	}

	/**
	 * Saves the passed level using the passed file name.
	 *
	 * @param level the <code>Level</code> to save
	 * @param fileName the file the level is to be saved to
	 * @throws IOException thrown when the level couldn't be saved
	 */

	final public void saveLevel(Level level, String fileName) throws IOException {

		// Create a PrintWriter for writing the data to hard disk.
		PrintWriter levelFile = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));

		// Write the level data to the file.
		writeLevelToFile(level, levelFile);

		// Check the error status.
		boolean isFileSavingFailed = levelFile.checkError();

		// Close the file.
		levelFile.close();

		// Throw exception in the case of an error.
		if (isFileSavingFailed) {
			throw new IOException(Texts.getText("errorBySaving"));
		}
	}

	/**
	 * Returns the char code of the square at the specified location.
	 *  
	 * @param xPosition X coordinate of the square to return a char for
	 * @param yPosition Y coordinate of the square to return a char for
	 * @return			char code for the square, or a blank if the position is outside
	 *                  the implemented part of the board
	 */

	final public int getSquareCharacter(int xPosition, int yPosition) {

		// Select the line by the Y coordinate
		if (yPosition < 0 || yPosition >= boardData.size()) {
			return ' ';
		}
		final String line = boardData.get(yPosition);
		
		// The level lines need not be filled with spaces at the end.
		// Such a line may be shorter than the level width.
		if (xPosition < 0 || xPosition >= line.length()) {
			return ' ';
		}

		return line.charAt(xPosition);
	}

	/**
	 * Reload the data of this view from the database.
	 */

	protected void refreshView() {
		actionPerformed(new ActionEvent(this, 0, "refreshView"));
	}

		/**
		 * Return the ID of the stored string.
		 * 
		 * @return the ID
		 */

		public int getID() {
			return ID;
		}

	/**
	 * Adds all author names to the author <code>ComboxBox</code>es.
	 */

	protected void updateComboBoxAuthors() {
		
		// Update all needed ComoboBoxes of this view.
		super.updateComboBoxAuthors(comboBoxAuthors, selectionAuthor);
		
		// When adding new items the combo boxes should not fire actions.
		// (If this isn't set the combo boxes refresh the views every time their content changes)
		doNotFireActions = true;
		
		// The selection ComboBox's first item is always the wildcard "*".
		selectionAuthor.insertItemAt(new ComboBoxEntry("*", 0), 0);
		
		// Set the wildcard as selected.
		selectionAuthor.setSelectedIndex(0);
		
		// Actions may be fired again.
		doNotFireActions = false;
	}

	/**
     * Close this dialog and return to the caller of this dialog. 
     */

    protected void finalize() {
    	databaseViews.dispose();
    	databaseViews = null;
    }

    	/**
    	 * Called from the author view when the user has changed data
    	 * for the authors that is relevant for the other views.
    	 */

    	static public void authorsNamesChanged() {
    		for(int i=0; i<changeInAuthorView.length; i++) {
    			changeInAuthorView[i] = true;
    		}
    	}

    	/**
    	 * Called from collection view when the user has changed something
    	 * that is relevant for the other views.
    	 */

    	static public void collectionNamesChanged() {
    		for(int i=0; i<changeInCollectionView.length; i++) {
    			changeInCollectionView[i] = true;
    		}
    	}

    	/**
    	 * Called from level assignment view when the user has changed
    	 * something that is relevant for the other views. 
    	 */

    	static public void changeInAssignmentView() {
    		for(int i=0; i<changeInAssignmentView.length; i++) {
    			changeInAssignmentView[i] = true;
    		}
    	}

    	/**
    	 * Called from level view when the user has changed something that is
    	 * relevant for the other views.
    	 */

    	static public void changeInLevelView() {
    		for(int i=0; i<changeInLevelView.length; i++) {
    			changeInLevelView[i] = true;
    		}
    	}

    	/**
    	 * After a view has been refreshed the data is up-to-date again.
    	 * Hence all update flags for this view can be reset. 
    	 */

    	static public void resetUpdateFlags(int view) {
    		changeInAuthorView[view]     = false;
        	changeInCollectionView[view] = false;
        	changeInAssignmentView[view] = false;
        	changeInLevelView[view]      = false;
    	}

    	/**
    	 * Marks the passed view for being refreshed because data have changed. 
    	 */

    	static public void setUpdateFlags(int view) {
    		changeInAuthorView[view]     = true;
        	changeInCollectionView[view] = true;
        	changeInAssignmentView[view] = true;
        	changeInLevelView[view]      = true;
    	}

	/**
	 * This method is called whenever the additional information of a selected
	 * level has changed.
	 * (For example, when a solution has been deleted)
	 */

	protected void updateAdditionalInformation() {
		int firstSelectedRow = tableLevelData.convertRowIndexToModel(tableLevelData.getSelectionModel().getMinSelectionIndex());
		valueChanged(new ListSelectionEvent(tableLevelData.getSelectionModel(), firstSelectedRow, firstSelectedRow, false));
	}

	/**
	 * Returns the number of board positions in this hash table.
	 *
	 * @return  the number of board positions in this hash table.
	 */

	final public int getNumberOfStoredBoardPositions() {
		return count;
	}

	/**
	 * Clears the storage so that it contains no board positions anymore.
	 */

	final public void clear() {
		// This code is similar to hash table.clear()
		Entry tab[] = table;
		
		for (int index = tab.length; --index >= 0;) {
			tab[index] = null;
		}
		count = 0;
	}

		/**
		 * Returns the stored board positions.
		 * 
		 * @return	the board position that is stored in this entry.
		 */

		public Object getBoardPosition() {
			return boardPosition;
		}

	/**
	 * Returns the selected collection.
	 * 
	 * @return the currently selected collection item
	 */

	protected Object getSelectedCollection() {
		return selectionCollection.getSelectedItem();
	}

	/** This class has 4 bytes per atom */

	protected int bytesPerAtom() {
		return (4);
	}

	/** Any multiple of 4 will do, 72 might be common */

	protected int bytesPerLine() {
		return (72);
	}

		/**
		 * This method should return, if it knows, the number of bytes
		 * that will be decoded. Many formats such as uuencoding provide
		 * this information. By default we return the maximum bytes that
		 * could have been encoded on the line.
		 */

		protected int decodeLinePrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException {
			return (bytesPerLine());
		}

		/**
		 * This method does an actual decode. It takes the decoded bytes and
		 * writes them to the OutputStream. The integer <i>l</i> tells the
		 * method how many bytes are required. This is always <= bytesPerAtom().
		 */

		protected void decodeAtom(PushbackInputStream aStream, OutputStream bStream, int l) throws IOException {
			throw new IOException();
		}

		/**
		 * Alternate decode interface that takes a String containing the encoded
		 * buffer and returns a byte array containing the data.
		 * @exception CEFormatException An error has occurred while decoding
		 */

		public byte decodeBuffer(String inputString)[] throws IOException {
			byte    inputBuffer[] = new byte[inputString.length()];
			ByteArrayInputStream inStream;
			ByteArrayOutputStream outStream;

			inputBuffer = inputString.getBytes();
			inStream = new ByteArrayInputStream(inputBuffer);
			outStream = new ByteArrayOutputStream();
			decodeBuffer(inStream, outStream);
			return (outStream.toByteArray());
		}

		/**
		 * Decode the contents of the inputstream into a buffer.
		 */

		public byte decodeBuffer(InputStream in)[] throws IOException {
			ByteArrayOutputStream outStream = new ByteArrayOutputStream();
			decodeBuffer(in, outStream);
			return (outStream.toByteArray());
		}

	/**
	 * Sets the basic delay step to be used, in milliseconds.
	 * 
	 * @param msStep delay time in milliseconds
	 */

	public void setStep(int msStep) {
		stepMillis = msStep;
	}

	/**
	 * Returns the current delay time in milliseconds.
	 * 
	 * @return current delay time in milliseconds
	 */

	public int getStep() {
		return stepMillis;
	}

	/**
	 * Sets the intended sequence length of delay steps.
	 * Positive values are used to somewhat reduce the total time of the
	 * sequence by reducing the effective single step delay time.
	 * 
	 * @param len intended sequence length of delay steps
	 */

	public void setLength(int len) {
		intendedLength = len;
	}

	/**
	 * Returns the current intended sequence length of delay steps.
	 * @return the current intended sequence length of delay steps
	 */

	public int getLength() {
		return intendedLength;
	}

	/**
	 * Construct and return a new object for the standard step delay
	 * from the Settings.
	 * 
	 * @return new standard <code>Delays</code> object
	 */

	static public Delays makeDelayNormal() {
		return makeDelayNormal(0);
	}

	/**
	 * Construct and return a new object for the standard step delay
	 * from the Settings, and the indicated intended sequence length.
	 * 
	 * @param seqLength intended length of the sequence
	 * @return new standard <code>Delays</code> object
	 */

	static public Delays makeDelayNormal(int seqLength) {
		return new Delays(Settings.delayValue, seqLength);
	}

	/**
	 * Construct and return a new object for the undo/redo step delay
	 * from the Settings, and the indicated intended sequence length.
	 * 
	 * @return new undo/redo <code>Delays</code> object
	 */

	static public Delays makeDelayUndoRedo() {
		return makeDelayUndoRedo(0);
	}

	/**
	 * Handle save button action.
	 */

	private void saveButtonActionPerformed() {

		// Save properties to a file.
		saveProperties(newLanguageProperties, getFilepathFromLanguageCode(newLanguageCode));

		// Make new backup copy of properties.
		lastSavedNewLanguageProperties = (Properties) newLanguageProperties.clone();
	}

	/**
	 * Construct and return a new object for the undo/redo step delay
	 * from the Settings, and the indicated intended sequence length.
	 * 
	 * @param seqLength intended length of the sequence
	 * @return new undo/redo <code>Delays</code> object
	 */

	static public Delays makeDelayUndoRedo(int seqLength) {
		return new Delays(Settings.delayValueUndoRedo, seqLength);
	}

	/**
	 * Start the Delay object.  If not yet started, this determines and
	 * remembers "now" as the base time stamp for the next (first) delay.
	 */

	public void start() {
		if ( ! started ) {
			lastNow = System.currentTimeMillis();
			started = true;
		}
	}

	/**
	 * Stops the Delay object.
	 * This just invalidates the last remembered wall clock time.
	 */

	public void stop() {
		started = false;
	}

	/**
	 * Based of the mathematical value from {@link #effStep(boolean)}
	 * we compute a meaningful approximation,
	 * and return an <code>int</code> value.
	 * 
	 * @param slowstep whether this delay shall be extra large
	 * @return integral approximation of current delay in milliseconds
	 */

	private int effStepInt( boolean slowstep ) {
		float step = effStep(slowstep);
		int  istep = Math.round(step);
		
		// When we would tell a zero delay (or even less), but the original
		// intention was a positive delay, we shall return the smallest
		// possible positive value: 1.
		if( istep <= 0 ) {
			if( stepMillis > 0 ) {
				istep = 1;
			}
		}
		
		// Never consider negative values
		if( istep < 0 ) {
			istep = 0;
		}
		
		return istep;
	}

			/**
			 * Starts a new backward search.
			 */

			public void run() {

				try {
					// Start the backward search.
					backwardSearch();

				} catch (OutOfMemoryError e) {
					// Stop the optimizer by setting the proper stop reason.
					optimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;
				}
			}

	/**
	 * The main method of this application.
	 * <p>
	 * 
	 * @param argv passed parameters
	 */

	static public void main(String[] argv) {

		// Check for debug parameters.
		for(String parameter : argv) {
			if(parameter.equalsIgnoreCase("-debug")) {
				Settings.isDebugModeActivated = true;	
			}
			if(parameter.equalsIgnoreCase("-debugSettings")) {
				Settings.isSettingsDebugModeActivated = true;
			}
			if(parameter.equalsIgnoreCase("-debugTiming")) {
				Settings.isTimingDebugModeActivated = true;
			}
		}
		
		// Save the information whether this program is started as "web start application".
		Settings.isStartedAsWebStartApplication =
					   (argv.length > 0 && argv[0].equals("-webstart"))
					|| (argv.length > 1 && argv[1].equals("-webstart"));
		
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				new JSoko().startProgram();
			}
		});
	}

	/**
	 * We are going to wait somewhat to create an observable motion.
	 * If the wait amount is zero, we do not even call {@link Thread#sleep(long)}.
	 * 
	 * @param reassertIntr whether a possible <code>InterruptedException</code>
	 *                      is to be reasserted (<em>not</em> rethrown).
	 *                      Else it is ignored.
	 */

	public void sleep(boolean reassertIntr) {
		sleep(reassertIntr, false);
	}

	/**
	 * Decrypts special character regions of the ascii code.
	 * 
	 * @param c  <code>Character</code> to be decrypted
	 * @param start minimum ascii value to be used for decrypting
	 * @param end   maximum ascii value to be used for decrypting
	 * @param offset  offset the character has to be shifted by
	 * @return the decrypted <code>Character</code>
	 */

	private char decryptCharcode(int c, int start, int end, int offset) {
		
		c+=offset;
		if(offset > 0 && c > end){
			c= (start+(c-end-1));
		}
		else if(offset < 0 && c < start){
			c= (end-(start-c-1));
		}
		return (char) c;
	}

	/**
	 * Restores the last saved properties.
	 * 
	 * @param evt
	 */

	private void restoreButtonActionPerformed(ActionEvent evt) {
		newLanguageProperties = (Properties) lastSavedNewLanguageProperties.clone();

		loadLanguageTexts(NEW_LANGUAGE_COLUMN);
		refreshTranslationTextAreas();
	}

	/**
	 * Inform every listener about the change of the state.
	 */

	protected void stateChanged() {
		ChangeEvent e = new ChangeEvent(this);
		for (ChangeListener listener : changeListeners) {
			listener.stateChanged(e);
		}
	}

	/**
	 * Adds the passed listener.
	 * 
	 * @param listener  listener to be added
	 */

	public void addValueListener(ChangeListener listener) {
		changeListeners.add(listener);
	}

	/**
	 * Returns the value of the spinner as double.
	 * 
	 * @return the value
	 */

	public double getValueAsDouble() {
		Object currentValue = getValue();
		if (currentValue instanceof Double) {
			return (Double) currentValue;
		}
		if (currentValue instanceof Integer) {
			return ((Integer) currentValue).doubleValue();
		}

		return 0;
	}

	/**
	 * Returns the value of the spinner as integer.
	 * 
	 * @return the value
	 */

	public int getValueAsInteger() {
		Object currentValue = getValue();
		if (currentValue instanceof Double) {
			return ((Double) currentValue).intValue();
		}
		if (currentValue instanceof Integer) {
			return (Integer) currentValue;
		}

		return 0;
	}

	/**
	 * If the available memory (RAM) is less than this bound,
	 * then we are going to remove the eldest entry whenever we add a new one,
	 * i.e. we do not expand our memory foot print.
	 * <p>
	 * Negative values indicate "no such limit exists".
	 * 
	 * @param minRAMinMiB the minRAMinMiB to set
	 * @see Utilities#getMaxUsableRAMinMiB()
	 */

	public void setMinRAMinMiB(long minRAMinMiB) {
		this.minRAMinMiB = minRAMinMiB;
	}

	/**
	 * Inside this method (we override it) we implement our deletion strategy.
	 * Either we return {@code true}, indicating the caller shall delete
	 * that eldest entry, but in that case we are not allowed to change
	 * the object ourselves.
	 * <p>
	 * Or we decide to take our own steps, return {@code false} to hinder
	 * the caller to take any action, but may have removed one or more
	 * elements ourselves.
	 * 
	 * @param eldest   the currently eldest element, deletion candidate
	 * @return whether the caller shall really remove that eldest entry
	 */

	protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
		if (minRAMinMiB >= 0) {
			// We are limited...
			if (size() >= 2) {
				// We are large enough to loose an entry...
				if (Utilities.getMaxUsableRAMinMiB() < minRAMinMiB) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * This is like {@link LinkedHashMap#get(Object)}, but forces the
	 * correct type of the key.
	 * 
	 * @param key the key for which we search the mapped value
	 * @return the mapped value, or {@code null}.
	 */

	public V getV(K key) {
		return map.get(key);
	}

	/**
	 * Adds a key/value pair to the cache mapping.
	 * We expect the key to be new, but we do not enforce (or check) that,
	 * since the typical cache user will first use {@link #getV(Object)},
	 * anyhow.
	 * 
	 * @param key   key of the new cache entry
	 * @param value value of the new cache entry
	 */

	public void add(K key, V value) {
		map.put(key, value);
	}

	/**
	 * Trim down the memory usage to the currently needed amount.
	 * This is a user hint, and we need not really take any action,
	 * e.g. if the implementation does not know how to do that.
	 * @see ArrayList#trimToSize()
	 */

	public void trimToSize() {
		// we cannot do anything useful, here
	}

	/**
	 * Creation of a box data clone.
	 *
	 *@return  the cloned box data object
	 */

	final public Object clone() {
		return new BoxData(this);
	}

	/**
	 * Define the initial location (position) of a box.
	 *
	 *@param boxNo       number of the box, the location of which is to be set
	 *@param boxPosition position of the box
	 */

	final public void setBoxStartPosition(int boxNo, int boxPosition) {
		boxPositions[boxNo] = boxPosition;
	}

	/**
	 * Change the location (position) of a box.
	 *
	 *@param boxNo		 number of the box, the location of which is to be set
	 *@param boxPosition new position of the box
	 */

	final public void setBoxPosition(int boxNo, int boxPosition) {
		boxPositions[boxNo] = boxPosition;
	}

	/**
	 * Set / change the position of all boxes at once.
	 * The passed array often contains an additional player position
	 * (at the end of the array).  We don't care much, the array is
	 * just one larger than necessary.
	 *
	 *@param  newBoxPositions the new box positions to be set
	 */

	final public void setBoxPositions(int[] newBoxPositions) {

		// We must use a copy of the the array!
		// The caller does not donate this object, he will continue
		// to use and modify that array, while we expect to own this array.
		boxPositions = newBoxPositions.clone();
	}

	/**
	 * Activate a box.
	 *
	 *@param  boxNo number of the box that shall be activated
	 */

	final public void setBoxActive(int boxNo) {
		isBoxInactive[boxNo] = false;
	}

	/**
	 * Deactivate a box.
	 * Implies {@link #removeBoxFromCorral(int)}.
	 *
	 *@param  boxNo number of the box that shall be set inactive
	 */

	final public void setBoxInactive(int boxNo) {
		isBoxInactive[boxNo] = true;

		// An inactive box cannot be part of a corral
		isBoxInCorral[boxNo] = false;
	}

	/**
	 * Tell whether a box is active.
	 *
	 *@param  boxNo number of the box we want to investigate
	 *@return state of the box: <code>true</code> = is active
	 */

	final public boolean isBoxActive(int boxNo) {
		return isBoxInactive[boxNo] == false;
	}

	/**
	 * Tell whether a box is inactive.
	 *
	 *@param  boxNo number of the box we want to investigate
	 *@return state of the box: <code>true</code> = is inactive
	 */

	final public boolean isBoxInactive(int boxNo) {
		return isBoxInactive[boxNo];
	}

	/**
	 * Mark a specified box to be frozen.
	 * <p>
	 * Such a box can never again be moved (pushed), regardless all other
	 * possible changes on the board... except for an "undo" action.
	 * <p>
	 * Only boxes on goals are to be marked as frozen, as otherwise
	 * it would constitute a deadlock condition.
	 *
	 *@param  boxNo number of the box to be marked "frozen"
	 */

	final public void setBoxFrozen(int boxNo) {
		isBoxFrozen[boxNo] = true;
	}

	/**
	 * Sets a new level for playing.
	 * 
	 * @param levelNo
	 *            number of the level to set (first is 1)
	 */

	public void setLevelForPlaying(int levelNo) {
		setLevelForPlaying(currentLevelCollection.getLevel(levelNo));
	}

	/**
	 * Tell whether a box is frozen.
	 * A box can be frozen on a goal, only, since otherwise it would be
	 * a deadlock condition.
	 *
	 *@param  boxNo number of the box we want to investigate
	 *@return       whether the box is frozen
	 */

	final public boolean isBoxFrozen(int boxNo) {
		return isBoxFrozen[boxNo];
	}

	/**
	 * Mark a specified box to not be frozen, anymore
	 * This method is used for "undo" (on a frozen box).
	 *
	 *@param  boxNo number of the box to be unmarked
	 */

	final public void setBoxUnfrozen(int boxNo) {
		isBoxFrozen[boxNo] = false;
	}

	/**
	 * Mark a specified box to be part of a corral.
	 *
	 *@param  boxNo number of the box which is part of a corral
	 */

	final public void setBoxInCorral(int boxNo) {
		isBoxInCorral[boxNo] = true;
	}

	/**
	 * Mark a specified box to not be part of any corral.
	 *
	 *@param  boxNo number of the box which is not part of any corral
	 */

	final public void removeBoxFromCorral(int boxNo) {
		isBoxInCorral[boxNo] = false;
	}

	/**
	 * Tell whether a box is part of a corral.
	 *
	 *@param  boxNo number of the box we want to investigate
	 *@return <code>true</code> = box is part of a corral
	 */

	final public boolean isBoxInCorral(int boxNo) {
		return isBoxInCorral[boxNo];
	}

	/**
	 * Tell the location of a box by its number.
	 *
	 *@param  boxNo number of the box we want to investigate
	 *@return       position (location) of the box
	 */

	final public int getBoxPosition(int boxNo) {
		return boxPositions[boxNo];
	}

	/**
	 * Tells whether all our boxes are on some goal.
	 *
	 *@return <code>true</code> if all boxes are on a goal, and
	 *       <code>false</code> if at least one box is on a non-goal
	 */

	final public boolean isEveryBoxOnAGoal() {

		// Check all boxes for "on goal"
		for (int boxNo = 0; boxNo < boxCount; boxNo++) {
			// ignore deactivated boxes
			if (isBoxInactive(boxNo))
				continue;

			if (board.isBoxOnGoal(boxPositions[boxNo]) == false) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns the number of boxes on a goal.
	 * 
	 * @return number of boxes on a goal
	 */

	public int getBoxesOnGoalsCount() {
		int boxesOnGoalsCount = 0;
		for(int boxNo=0; boxNo<boxCount; boxNo++) {
			// TODO: explain why inactive boxes are not ignored Answer: bad programming. this method
			// is only used when a new level is loaded and all boxes are active. Inactive boxes are
			// only there during deadlock detection. Nevertheless, I think it's better to check for 
			// inactive boxes here, too. I will have a look at this at some time. 
			if(board.isGoal(getBoxPosition(boxNo))) {
				boxesOnGoalsCount++;
			}
		}
		return boxesOnGoalsCount;
	}

	/**
	 * Returns whether all active boxes are located on a backward goal.
	 * 
	 * @return <code>true</code> if all active boxes are on backward goals, and
	 * <code>false</code> if at least one active box not on a backward goal.
	 */

	final public boolean isEveryBoxOnABackwardGoal() {

		int[] backwardGoalPositions = board.getGoalPositionsBackward();

		for (int boxNo = 0; boxNo < boxCount; boxNo++) {
			if (isBoxInactive(boxNo)) {
				continue;
			}
			if (board.isBox(backwardGoalPositions[boxNo]) == false) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Tell whether all corral boxes are located on goals.
	 *
	 *@return <code>true</code> if all corral boxes are on goals, and
	 *		 <code>false</code> if at least one corral box is on a non-goal
	 */

	final public boolean isEveryCorralBoxOnAGoal() {

		// check all boxes
		for (int boxNo = 0; boxNo < boxCount; boxNo++) {
			// ignore deactivated and non-corral boxes
			if (isBoxInactive(boxNo) || isBoxInCorral(boxNo) == false) {
				continue;
			}
			if (board.isBoxOnGoal(boxPositions[boxNo]) == false) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Mark all boxes as not frozen.
	 */

	final public void setAllBoxesNotFrozen() {
		for (int boxNo = 0; boxNo < boxCount; boxNo++) {
			isBoxFrozen[boxNo] = false;
		}
	}

	/**
	 * Tell the overall size of the large index byte array.
	 * Corresponds to the member of same name of array objects.
	 * @return size of the array
	 */

	public long length() {
		return size;
	}

	/**
	 * Reads the element value at the passed large index.
	 * Models the array read access.
	 * 
	 * @param lax large index of the array member
	 * @return value of the array member at the index {@code lax}
	 */

	public byte getAt(long lax) {
		if ((lax < 0) || (lax >= size)) {
			throw new ArrayIndexOutOfBoundsException("lax="+lax+",size="+size);
		}
		if (lax < blocksize) {
			// the simple case: one flat array
			return (arrvec[0][ (int)lax ]);
		}
		long blockno = lax / blocksize;
		long eleminx = lax % blocksize;
		return (arrvec[(int)blockno][(int)eleminx]);
	}

	/**
	 * Writes an element value at the passed large index.
	 * 
	 * @param lax large index of the array member
	 * @param val the value to store
	 * @return the just stored value
	 */

	public byte putAt(long lax, byte val) {
		if (lax < blocksize) {
			// the simple case: one flat array
			return (arrvec[0][ (int)lax ] = val);
		}
		long blockno = lax / blocksize;
		long eleminx = lax % blocksize;
		// FFS/hm: index out of range
		return (arrvec[(int)blockno][(int)eleminx] = val);
	}

	/**
	 * Modifies the byte at the specified large array index
	 * by "oring in" the passed byte value.
	 * Models the operation {@code (arr[lax] |= val)}.
	 * 
	 * @param lax large index of the array member to modify
	 * @param val the value to "or in"
	 * @return the resulting (stored) byte value
	 */

	public byte orAt(long lax, byte val) {
		if (lax < blocksize) {
			// the simple case: one flat array
			return (arrvec[0][ (int)lax ] |= val);
		}
		long blockno = lax / blocksize;
		long eleminx = lax % blocksize;
		// FFS/hm: index out of range
		return (arrvec[(int)blockno][(int)eleminx] |= val);
	}

	/**
	 * Fetch a bit sized fragment of a {@code long} from a contiguous series
	 * of bits from this "array".
	 * The result is presented in unsigned interpretation (except the
	 * {@code bitcnt} is 64).
	 * 
	 * @param bitlax index of the first bit (not byte) to fetch
	 * @param totbits number of bits to fetch (at most 64)
	 * @return the indicated bits as unsigned value
	 */

	public long getNumBitsAt( long bitlax, int totbits ) {
		if (totbits > 64 || totbits < 0) {
			throw new java.lang.UnsupportedOperationException("bits="+totbits);
		}
		// asserted: 0 <= totbits <= 64
		long result = 0;
		
		int  resoff = 0;
		while (totbits > resoff) {
			int  toget  = totbits - resoff;
			byte bitoff = (byte)(bitlax & 0x07);	// [0..7]
			long lax    = bitlax >>> 3;

			int bitlen = 8 - bitoff;		// so many in this byte [1..8]
			if (bitlen > toget) {
				bitlen = toget;
			}
			long v    = getAt(lax) & 0xffL;
			v      >>>= bitoff;
			v        &= (1L << bitlen) - 1;

			result |= (v << resoff);
			resoff += bitlen;
			bitlax += bitlen;
		}
		return result;
	}

	/**
	 * Shows dialog which informs about missing file.
	 * <p>
	 * If error is critical (it is when <code>messageType</code> equals
	 * <code>JOptionPane.ERROR_MESSAGE</code> then application is closed.
	 *
	 * @param filePath	path of the missing file
	 * @param messageType	<code>JOptionPane.WARNING_MESSAGE</code> if missing file is non-critical;
	 *						<code>JOptionPane.ERROR_MESSAGE</code> if missing file is critical
	 */

	public void showMissingFileDialog(String filePath, int messageType) {
		JOptionPane.showMessageDialog(
				parent,
				"File: " + filePath + " is missing!",
				"Error",
				messageType);

		if (messageType == JOptionPane.ERROR_MESSAGE) {
			setBlankProject();
		}
	}

	/**
	 * Tells, whether the SparseArray does not contain any non-{@code null}
	 * element.
	 * <p>
	 * This is also part of the {@link Map} interface.
	 * 
	 * @return whether the SparseArray is empty
	 */

	public boolean isEmpty() {
		return root == null;
	}

	/**
	 * Removes all entries from the object.
	 * <p>
	 * This method is also part of the map interface.
	 */

	public void clear() {
		this.root      = null;
		this.elemcount = 0;
	}

	/**
	 * Load properties from a file.
	 *
	 * @param fileName	name of the file
	 * @return	<code>Properties</code> variable containing loaded properties
	 */

	private Properties loadPropertiesByFilename(String fileName) throws IOException {

		// Create new properties.
		Properties tempProp = new Properties();

		// Get input stream to the property file.
		InputStream inPropFile = Utilities.getInputStream(fileName);
		
		try {
			// Load properties.
			tempProp.load(inPropFile);
			
			// Close file.
			inPropFile.close();
		}
		catch(Exception e) {
			throw new IOException(e.getLocalizedMessage());
		}

		// Return the read properties.
		return tempProp;

	}

	/**
	 * Load the properties corresponding to the passed language code.
	 *
	 * @param languageCode code of the language (example: "en")
	 * @return	<code>Properties</code> variable containing loaded properties
	 */

	private Properties loadPropertiesByLanguageCode(String languageCode) throws IOException {

		// Return the read properties.
		return loadPropertiesByFilename(getFilepathFromLanguageCode(languageCode));

	}

	/**
	 * Read the array element at the specified index.
	 * 
	 * @param inx indexes the (sparse) array
	 * @return {@code null}, or the element at index {@code inx}
	 */

	public V rd(long inx) {
		return rd(root, MAX_DEP, inx);
	}

	/**
	 * This is a helper method for {@link #wr(Node, byte, long, Object)}.
	 * We store a new reference where we fetched the last {@code Node}
	 * reference during tree path scanning: at {@code Node pa}
	 * with index {@code painx}.
	 * If {@code pa} is {@code null}, we must have fetched from the
	 * {@link #root} and thus we here store to it.
	 * 
	 * @param pa    the node to which we store a new reference, or {@code null}
	 * @param painx the index of the store
	 * @param nref  the new reference to store
	 */

	private void paput(Inner<V> pa, byte painx, Node<V> nref) {
		if (pa == null) {
			root = nref;
		} else {
			// Store leaf where we found the null in the last step
			pa.iput(painx, nref);
		}
	}

	/**
	 * Reloads all non-static GUI components.
	 */

	private void reloadGUI() {
		changeLanguageComboBoxes();

		loadLanguageTexts(NEW_LANGUAGE_COLUMN);
		loadLanguageTexts(HINT_LANGUAGE_COLUMN);

		// Set new and hint language combo boxes for default values.
		String language = (new Locale(Settings.get("newTranslationLanguage"))).getDisplayLanguage(getUserLocale());

		newLanguageComboBox.setSelectedItem(language);

		language = (new Locale(Settings.get("hintTranslationLanguage"))).getDisplayLanguage(getUserLocale());
		hintLanguageComboBox.setSelectedItem(language);

		// By default select the first row of the table.
		if (table.getRowCount() > 0) {
			table.changeSelection(0, NEW_LANGUAGE_COLUMN, false, false);
		}
	}

	/**
	 * Redraws the screen and waits for "enter" if needed.
	 * 
	 * @param waitForEnter  whether the method is to wait for enter after drawing
	 */

	public void redraw(boolean waitForEnter) {

		// Draw the new GUI.
		applicationGUI.mainBoardDisplay.repaint();

		// For debugging purposes wait for "Enter"
		if (waitForEnter) {
			JDialog dialog = new JOptionPane("").createDialog(null, "Waiting for Enter");
			dialog.setLocation(getX() + getWidth() + 45, getY() + 10);
			dialog.setVisible(true);
			// Beginners explanation: The above dialog is "modal", and hence freezes
			// all other graphics activity.  That way "we wait" by being frozen.
			// When "setVisible(true)" returns, the dialog is done!
		}
	}

	/**
	 * Stores the specified value into the array slot with the specified index,
	 * and returns the former value of that array slot.
	 * <p>
	 * Storing a {@code null} value means to remove any former value
	 * from the indexed array slot.
	 * 
	 * @param inx the index of the array slot to write to
	 * @param val the value to store at index {@code inx}
	 * @return the former content of the array slot at index {@code inx}
	 */

	public V wr(long inx, V val) {
		return wr(root, MAX_DEP, inx, val);
	}

	/**
	 * Removes a box from the passed position.
	 * 
	 * @param position the position a box is to be removed from.
	 */

	final public void removeBox(int position) {
		boxesArray[position] = false;
	}

	/**
	 * Debug: Calculates and displays the lower bound for all levels.
	 */

	private void calculateLowerboundOfAllLevel() {

		final int maxLevelNo = currentLevelCollection.getNumberOfLevels();
		int[] lowerbounds = new int[1 + maxLevelNo];

		for (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {
			setLevelForPlaying(levelNo);
			lowerbounds[levelNo] = board.lowerbound.calculateLowerbound(SearchDirection.FORWARD);
		}

		for (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {
			System.out.printf("Level: %3d  Name: %-60s Lowerbound: %3d \n",
					levelNo, currentLevelCollection.getLevel(levelNo).getTitle(), lowerbounds[levelNo]);
		}
	}

			/**
			 * Starts a new forward search.
			 */

			public void run() {

				try {
					// Start a new forward search.
					forwardSearch();

				} catch (OutOfMemoryError e) {
					// Stop the optimizer by setting the proper stop reason.
					optimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;
				}

			}

	/**
	 * Removes the box having the passed number.
	 * 
	 * @param boxNo the number of the box that is to be removed.
	 */

	final public void removeBoxByNumber(int boxNo) {
		boxesArray[boxData.getBoxPosition(boxNo)] = false;
	}

	/**
	 * Returns whether the game is in play mode, just now.
	 * 
	 * @return <code>true</code>, if the game is in play mode
	 */

	public boolean isPlayModeActivated() {
		return gameMode == GameMode.PLAY;
	}

	/**
	 * Removes a box from the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x	the x-coordinate of the position the box is to be removed from.
	 * @param y the y-coordinate of the position the box is to be removed from.
	 */

	final public void removeBox(int x, int y) {
		boxesArray[x + width * y] = false;
	}

	/**
	 * Returns whether the game is in editor mode, just now.
	 * 
	 * @return <code>true</code>, iff the game is in editor mode
	 */

	public boolean isEditorModeActivated() {
		return gameMode == GameMode.EDITOR;
	}

	/**
	 * Removes a wall from the passed position.
	 * 
	 * @param position the position a wall is to be removed from.
	 */

	final public void removeWall(int position) {
		wallsArray[position] -= ((wallsArray[position] > 0) ? 1 : 0);
	}

	/**
	 * Sets the "invalid level" mode. The current level is invalid. Therefore
	 * the user isn't allowed to play it. Furthermore the solver and the optimizer are disabled.
	 */

	private void setInvalidLevelMode() {
		applicationGUI.setInvalidLevelModeDependentObjectsEnabled(false);
		gameMode = GameMode.INVALID_LEVEL;
	}

	/**
	 * Removes a wall from the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x	the x-coordinate of the position the wall is to be removed from.
	 * @param y the y-coordinate of the position the wall is to be removed from.
	 */

	final public void removeWall(int x, int y) {
		wallsArray[x + width * y] -= ((wallsArray[x + width * y] > 0) ? 1 : 0);
	}

	/**
	 * Removes a goal from the passed position.
	 * 
	 * @param position the position a goal is to be removed from.
	 */

	final public void removeGoal(int position) {
		goalsArray[position] = false;
	}

	/**
	 * Removes a goal from the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x	the x-coordinate of the position the goal is to be removed from.
	 * @param y the y-coordinate of the position the goal is to be removed from.
	 */

	final public void removeGoal(int x, int y) {
		goalsArray[x + width * y] = false;
	}

	/**
	 * Determines the first key associated with a non-{@code null} value.
	 * Sorting order is native: signed.
	 * @return the first key in the sparse array
	 * @see SortedMap#firstKey()
	 */

	public long firstInx() {
		if (isEmpty()) {
			throw new NoSuchElementException();
		}
		ArrEntry<V> e = findFiLa(true, true, null);
		return e.inx;
	}

	/**
	 * Determines the last key associated with a non-{@code null} value.
	 * Sorting order is native: signed.
	 * @return the last key in the sparse array
	 * @see SortedMap#lastKey()
	 */

	public long lastInx() {
		if (isEmpty()) {
			throw new NoSuchElementException();
		}
		ArrEntry<V> e = findFiLa(false, true, null);
		return e.inx;
	}

	/**
	 * Removes the player from the board.
	 */

	final public void removePlayer() {
		playerPosition = NO_PLAYER;
	}

	/**
	 * Sets a box at the passed position.
	 * 
	 * @param position the position a box is to be set.
	 */

	final public void setBox(int position) {
		boxesArray[position] = true;
	}

    /**
     * Method that is backed to a submit button of a form.
     */

    public String send(){
        //do real logic
        return ("success");
    }

	/**
	 * Sets a box at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position a box is to be set.
	 * @param y the y-coordinate of the position a box is to be set.
	 */

	final public void setBox(int x, int y) {
		boxesArray[x + width * y] = true;
	}

	/**
	 * Generate an id for a new lock. Uniqueness per cache instance is very 
	 * desirable but not absolutely critical. Must be called from one of the 
	 * synchronized methods of this class.
	 */

	private int nextLockId() {
		if (nextLockId==Integer.MAX_VALUE) nextLockId = Integer.MIN_VALUE;
		return nextLockId++;
	}

	/**
	 * decrement a lock and put it back in the cache
	 */

	private void decrementLock(Object key, Lock lock) throws CacheException {
		//decrement the lock
		lock.unlock( cache.nextTimestamp() );
		if ( cache instanceof ClusterCache)
			((ClusterCache)cache).putQuiet(key, lock);
		else
			cache.put(key, lock);
	}

    /**
     * Gets a value of an element which matches the given key.
     * @param key the key of the element to return.
     * @return The value placed into the cache with an earlier put, or null if not found or expired
     * @throws CacheException
     */

    public Object get(Object key) throws CacheException {
        try {
            if ( log.isDebugEnabled() ) {
                log.debug("key: " + key);
            }
            if (key == null) {
                return null;
            } 
            else {
                Element element = cache.get( (Serializable) key );
                if (element == null) {
                    if ( log.isDebugEnabled() ) {
                        log.debug("Element for " + key + " is null");
                    }
                    return null;
                } 
                else {
                    return element.getValue();
                }
            }
        } 
        catch (net.sf.ehcache.CacheException e) {
            throw new CacheException(e);
        }
    }

	/**
	 * Sets a box with the passed number at the passed position.
	 * 
	 * @param position the position a box is to be set.	 
	 * @param boxNo	the number of the box to be set
	 */

	final public void setBoxWithNo(int boxNo, int position) {
		boxesArray[position] = true;
		boxNumbers[position] = boxNo;
	}

    /**
     * Puts an object into the cache.
     * @param key a {@link Serializable} key
     * @param value a {@link Serializable} value
     * @throws CacheException if the parameters are not {@link Serializable}, the {@link CacheManager}
     * is shutdown or another {@link Exception} occurs.
     */

    public void put(Object key, Object value) throws CacheException {
        try {
            Element element = new Element( (Serializable) key, (Serializable) value );
            cache.put(element);
        } 
        catch (IllegalArgumentException e) {
            throw new CacheException(e);
        } 
        catch (IllegalStateException e) {
            throw new CacheException(e);
        }

    }

    /**
     * Removes the element which matches the key.
     * <p>
     * If no element matches, nothing is removed and no Exception is thrown.
     * @param key the key of the element to remove
     * @throws CacheException
     */

    public void remove(Object key) throws CacheException {
        try {
            cache.remove( (Serializable) key );
        } 
        catch (ClassCastException e) {
            throw new CacheException(e);
        } 
        catch (IllegalStateException e) {
            throw new CacheException(e);
        }
    }

    /**
     * Remove all elements in the cache, but leave the cache
     * in a useable state.
     * @throws CacheException
     */

    public void clear() throws CacheException {
        try {
            cache.removeAll();
        } 
        catch (IllegalStateException e) {
            throw new CacheException(e);
        } 
        catch (IOException e) {
            throw new CacheException(e);
        }
    }

    /**
     * Remove the cache and make it unuseable.
     * @throws CacheException
     */

    public void destroy() throws CacheException {
        try {
            CacheManager.getInstance().removeCache( cache.getName() );
        } 
        catch (IllegalStateException e) {
            throw new CacheException(e);
        } 
        catch (net.sf.ehcache.CacheException e) {
            throw new CacheException(e);
        }
    }

    /**
     * Calls to this method should perform there own synchronization.
     * It is provided for distributed caches. Because EHCache is not distributed
     * this method does nothing.
     */

    public void lock(Object key) throws CacheException {
    }

    /**
     * Calls to this method should perform there own synchronization.
     * It is provided for distributed caches. Because EHCache is not distributed
     * this method does nothing.
     */

    public void unlock(Object key) throws CacheException {
    }

	/**
	 * Enables or disables the buttons for "undo" and "redo" by inspection of
	 * the history, i.e. whether there is something to undo or redo.
	 */

	private void setUndoRedoFromHistory() {
		applicationGUI.setUndoButtonsEnabled(movementHistory.hasPrecedingMovement());
		applicationGUI.setRedoButtonsEnabled(movementHistory.hasSuccessorMovement());
	}

		/**
		 * The timestamp on the cached data
		 */

		public long getFreshTimestamp() {
			return freshTimestamp;
		}

    /**
     * Gets the next timestamp;
     */

    public long nextTimestamp() {
        return Timestamper.next();
    }

    /**
     * Returns the lock timeout for this cache.
     */

    public int getTimeout() {
        // 60 second lock timeout
        return Timestamper.ONE_MS * 60000;
    }

		/**
		 * The actual cached data
		 */

		public Object getValue() {
			return value;
		}

		/**
		 * Lock the item
		 */

		public Lock lock(long timeout, int id) {
			return new Lock(timeout, id, version);
		}

		/**
		 * Not a lock!
		 */

		public boolean isLock() {
			return false;
		}

		/**
		 * Is this item visible to the timestamped
		 * transaction?
		 */

		public boolean isGettable(long txTimestamp) {
			return freshTimestamp < txTimestamp;
		}

		/**
		 * Don't overwite already cached items
		 */

		public boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {
			// we really could refresh the item if it  
			// is not a lock, but it might be slower
			//return freshTimestamp < txTimestamp
			return  ( version!=null && newVersion!=null)&& comparator.compare(version, newVersion) < 0;
		}

	/**
	 * Sets a box with the passed number at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position a box is to be set.
	 * @param y the y-coordinate of the position a box is to be set.
	 * @param boxNo	the number of the box to be set
	 */

	final public void setBoxWithNo(int boxNo, int x, int y) {
		boxesArray[x + width * y] = true;
		boxNumbers[x + width * y] = boxNo;
	}

	/**
	 * Check if this lock mode is more restrictive than the given lock mode.
	 *
	 * @param mode LockMode to check
	 * @return true if this lock mode is more restrictive than given lock mode
	 */

	public boolean greaterThan(LockMode mode) {
		return level > mode.level;
	}

	/**
	 * Check if this lock mode is less restrictive than the given lock mode.
	 *
	 * @param mode LockMode to check
	 * @return true if this lock mode is less restrictive than given lock mode
	 */

	public boolean lessThan(LockMode mode) {
		return level < mode.level;
	}

		/**
		 * Increment the lock, setting the
		 * new lock timeout
		 */

		public Lock lock(long timeout, int id) {
			concurrentLock = true;
			multiplicity++;
			this.timeout = timeout;
			return this;
		}

		/**
		 * Decrement the lock, setting the unlock
		 * timestamp if now unlocked
		 * @param currentTimestamp
		 */

		public void unlock(long currentTimestamp) {
			if ( --multiplicity == 0 ) {
				unlockTimestamp = currentTimestamp;
			}
		}

		/**
		 * Can the timestamped transaction re-cache this
		 * locked item now?
		 */

		public boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {
			if (timeout < txTimestamp) return true;
			if (multiplicity>0) return false;
			return version==null || newVersion==null? 
				unlockTimestamp < txTimestamp :
				comparator.compare(version, newVersion) < 0; //by requiring <, we rely on lock timeout in the case of an unsuccessful update!
		}

		/**
		 * Was this lock held concurrently by multiple
		 * transactions?
		 */

		public boolean wasLockedConcurrently() {
			return concurrentLock;
		}

		/**
		 * Yes, this is a lock
		 */

		public boolean isLock() {
			return true;
		}

		/**
		 * locks are not returned to the client!
		 */

		public boolean isGettable(long txTimestamp) {
			return false;
		}

	/**
	 * Sets a box and a goal at the passed position.
	 * 
	 * @param position the position the objects are to be set.
	 */

	final public void setBoxOnGoal(int position) {
		boxesArray[position] = true;
		goalsArray[position] = true;
	}

	/**
     * Defines the mapper to map source to destination files.
     */

    public Mapper createMapper() throws BuildException {
        if (_mapper != null) {
            throw new BuildException("Cannot define more than one mapper");
        }
        _mapper = new Mapper(this.getProject());
        return _mapper;
    }

	/**
	 * Copies the data of the current level to the clipboard, optionally
	 * using run length encoding (RLE).
	 * 
	 * @param withRLE whether to use RLE
	 * @see #exportLevelToClipboard(boolean, boolean)
	 */

	private void exportLevelToClipboard(boolean withRLE) {
		exportLevelToClipboard(withRLE, false);
	}

	/**
	 * Sets a box and a goal at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position the objects are to be set.
	 * @param y the y-coordinate of the position the objects are to be set.
	 */

	final public void setBoxOnGoal(int x, int y) {
		boxesArray[x + width * y] = true;
		goalsArray[x + width * y] = true;
	}

	/**
	 * Sets a a goal at the passed position.
	 * 
	 * @param position the position the goal is to be set.
	 */

	final public void setGoal(int position) {
		goalsArray[position] = true;
	}

	/**
	 * Sets a goal at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position a goal is to be set.
	 * @param y the y-coordinate of the position a goal is to be set.
	 */

	final public void setGoal(int x, int y) {
		goalsArray[x + width * y] = true;
	}

	/**
	 * Sets a wall at the passed position.
	 * 
	 * @param position the position the wall is to be set.
	 */

	final public void setWall(int position) {
		wallsArray[position]++;
	}

	/**
	 * Sets a wall at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position a wall is to be set.
	 * @param y the y-coordinate of the position a wall is to be set.
	 */

	final public void setWall(int x, int y) {
		wallsArray[x + width * y]++;
	}

	/**
	 * Sets the number of a box at the passed position.
	 * 
	 * @param boxNo	the box number to be set
	 * @param position the position the box number is to be set.
	 */

	final public void setBoxNo(int boxNo, int position) {
		boxNumbers[position] = boxNo;
	}

	/**
	 * Sets the number of a box at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param boxNo	the box number to be set
	 * @param x the x-coordinate of the position the box number is to be set.
	 * @param y the y-coordinate of the position the box number is to be set.
	 */

	final public void setBoxNo(int boxNo, int x, int y) {
		boxNumbers[x + width * y] = boxNo;
	}

	/**
	 * Sets the square at the the passed position to be an advanced deadlock
	 * square.
	 * 
	 * @param position the position of the square
	 */

	final public void setAdvancedSimpleDeadlock(int position) {
		advancedSimpleDeadlockSquareForwards[position] = true;
	}

	/**
	 * Sets the player to the passed position.
	 * 
	 * @param position Position the player is to be set at.
	 */

	final public void setPlayerPosition(int position) {
		playerPosition = position;
	}

	/**
	 * Sets the player to the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position the player is to be set at.
	 * @param y the y-coordinate of the position the player is to be set at.
	 */

	final public void setPlayerPosition(int x, int y) {
		playerPosition = x + width * y;
	}

	/**
	 * Returns whether the square at the the passed position is a corral
	 * forcer square.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a corral forcer square at the
	 *                           passed position, or<br>
	 * 		  <code>false</code> if there isn't a corral forcer square at the
	 *                           passed position
	 */

	final public boolean isCorralForcerSquare(int position) {
		return corralForcer[position];
	}

	/**
	 * Returns whether the square at the the passed position is a corral
	 * forcer square.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if there is a corral forcer square at the
	 *                           passed position, or<br>
	 * 		  <code>false</code> if there isn't a corral forcer square at the
	 *                           passed position
	 */

	final public boolean isCorralForcerSquare(int x, int y) {
		return corralForcer[x + width * y];
	}

	/**
	 * Returns whether there is a box at the passed position.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a box at the passed position,
	 * or<br> <code>false</code> if there isn't a box at the passed position
	 */

	final public boolean isBox(int position) {
		return boxesArray[position];
	}

	/**
	 * Returns whether there is a box at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if there is a box at the passed position,
	 * or<br> <code>false</code> if there isn't a box at the passed position
	 */

	final public boolean isBox(int x, int y) {
		return boxesArray[x + width * y];
	}

	/**
	 * Returns whether there is a wall at the passed position.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a wall at the passed position,
	 * or<br> <code>false</code> if there isn't a wall at the passed position
	 */

	final public boolean isWall(int position) {
		return wallsArray[position] > 0;
	}

	/**
	 * Returns if a box has been selected.
	 * 
	 * @return <code>true</code> a box has been selected <code>false</code> no box
	 *         has been selected
	 */

	public boolean isABoxSelected() {
		return isABoxSelected;
	}

	/**
	 * Returns whether there is a wall at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if there is a wall at the passed position,
	 * or<br> <code>false</code> if there isn't a wall at the passed position
	 */

	final public boolean isWall(int x, int y) {
		return wallsArray[x + width * y] > 0;
	}

	/**
	 * Returns whether the player reachable squares are to be highlighted.
	 * 
	 * @return <code>true</code> if the player reachable squares are to be highlighted,<br>
	 * 	      <code>false</code> otherwise
	 */

	public boolean isHighLightingOfPlayerReachableSquaresActivated() {
		return isHighLightOfPlayerSquaresActivated;
	}

	/**
	 * The location of ant-installer.jar and sysout.jar and possibly jgoodies-edited-1_2_2.jar
	 * @param antInstallLib The antInstallLib to set.
	 */

	public void setAntInstallLib(File antInstallLib) {
		this.antInstallLib = antInstallLib;
		FileSet set = new FileSet();
		set.setFile(new File(antInstallLib,"tikal-antinstaller.jar"));
		set.setFile(new File(antInstallLib,"sysout.jar"));
		addZipGroupFileset(set);
	}

	/**
	 * The location of ant.jar and ant-launcher.jar
	 * @param antLib The antLib to set.
	 */

	public void setAntLib(File antLib) {
		this.antLib = antLib;
		FileSet set = new FileSet();
		set.setFile(new File(antLib,"tikal-ant.jar"));
		set.setFile(new File(antLib,"ant-launcher.jar"));
		addZipGroupFileset(set);
	}

	/**
	 * Returns whether there is a goal at the passed position.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a goal at the passed position,
	 * or<br> <code>false</code> if there isn't a goal at the passed position
	 */

	final public boolean isGoal(int position) {
		return goalsArray[position];
	}

	/**
	 * Returns the position of the selected box.
	 * 
	 * @return the position of the selected box
	 */

	public int getSelectedBoxPosition() {
		return selectedBoxPosition;
	}

	/**
	 * Returns whether there is a goal at the passed position.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if there is a goal at the passed position,
	 * or<br> <code>false</code> if there isn't a goal at the passed position
	 */

	final public boolean isGoal(int x, int y) {
		return goalsArray[x + width * y];
	}

	/**
	 * Returns whether the square at the passed position is either a goal
	 * or a wall.
	 * 
	 * @param position  the position of the square
	 * @return <code>true</code> if the square is a goal or a wall, or<br>
	 * 		  <code>false</code> otherwise
	 */	

	public boolean isGoalOrWall(int position) {
		return goalsArray[position] || wallsArray[position] > 0;
	}

	/**
	 * Plays the next movements from the history movements, in an own thread,
	 * in order to avoid blocking the event dispatcher thread (EDT).
	 * 
	 * @param redoAllMovements whether all movements have to be redone
	 */

	private void redoMovementInOwnThread(final boolean redoAllMovements) {
		
		movePlayerThread = new Thread() {
			public void run() {
				redoMovement(redoAllMovements);

				// The "setUndoRedoFromHistory()" has happened already.

				// This thread has finished its work. The thread isn't needed any more.
				movePlayerThread = null;
			}
		};
		movePlayerThread.start();
	}

	/**
	 * Returns whether there is a corral forcer at the passed position.
	 * A corral forcer divides the board into areas the player can reach
	 * and can't reach.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a corral forcer at the position,
	 * or<br> <code>false</code> if there isn't a corral forcer at the position 
	 */

	final public boolean isCorralForcer(int position) {
		return corralForcer[position] == true;
	}

    /**
     * Returns a list of all elements in the cache. Only keys of non-expired
     * elements are returned.
     * <p/>
     * The returned keys are unique and can be considered a set.
     * <p/>
     * The List returned is not live. It is a copy.
     * <p/>
     * The time taken is O(n), where n is the number of elements in the cache. On
     * a 1.8Ghz P4, the time taken is approximately 200ms per 1000 entries. This method
     * is not syncrhonized, because it relies on a non-live list returned from {@link #getKeys()}
     * , which is synchronised, and which takes 8ms per 1000 entries. This way
     * cache liveness is preserved, even if this method is very slow to return.
     * <p/>
     * Consider whether your usage requires checking for expired keys. Because
     * this method takes so long, depending on cache settings, the list could be
     * quite out of date by the time you get it.
     *
     * @return a list of {@link Serializable} keys
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public List getKeysWithExpiryCheck() throws IllegalStateException, CacheException {
        List allKeyList = getKeys();
        //remove keys of expired elements
        ArrayList nonExpiredKeys = new ArrayList(allKeyList.size());
        int allKeyListSize = allKeyList.size();
        for (int i = 0; i < allKeyListSize; i++) {
            Serializable key = (Serializable) allKeyList.get(i);
            Element element = getQuiet(key);
            if (element != null) {
                nonExpiredKeys.add(key);
            }
        }
        nonExpiredKeys.trimToSize();
        return nonExpiredKeys;
    }

	/**
	 * Returns whether there is a backward search goal at the passed position.
	 * The backward search goals are the positions of the boxes
	 * at the beginning of a level.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a backward search goal
	 *                           at the passed position, or<br>
	 * 		  <code>false</code> if there isn't a backward search goal
	 *                           at the passed position
	 */

	final public boolean isGoalBackwardsSearch(int position) {
		return goalSquareBackwardsSearch[position];
	}

    /**
     * Returns the number of elements in the memory store.
     *
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public long getMemoryStoreSize() throws IllegalStateException {
        checkStatus();
        return memoryStore.getSize();
    }

    /**
     * Returns the number of elements in the disk store.
     *
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public int getDiskStoreSize() throws IllegalStateException {
        checkStatus();
        if (overflowToDisk) {
            return diskStore.getSize();
        } else {
            return 0;
        }
    }

	/**
	 * Returns whether there is a backward search goal at the passed position.
	 * The backward search goals are the positions of the boxes
	 * at the beginning of a level.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if there is a backward search goal
	 *                           at the passed position, or<br>
	 * 		  <code>false</code> if there isn't a backward search goal
	 *                           at the passed position
	 */

	final public boolean isGoalBackwardsSearch(int x, int y) {
		return goalSquareBackwardsSearch[x + width * y];
	}

    /**
     * Gets the status attribute of the Cache
     *
     * @return The status value from the Status enum class
     */

    public Status getStatus() {
        return status;
    }

	/**
	 * Undoes the last movement in an own thread,
	 * in order to avoid blocking the event dispatcher thread (EDT).
	 */

	private void undoMovementInOwnThread() {

		movePlayerThread = new Thread() {
			@SuppressWarnings("synthetic-access")
			public void run() {
				undoMovement();

				// Enable / disable the undo / redo button depending on the history status.
				setUndoRedoFromHistory();			}
		};
		movePlayerThread.start();
	}

    /**
     * Receive a Locator object for document events.
     */

    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    /**
     * Number of times a requested item was found in the Memory Store
     *
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public int getMemoryStoreHitCount() throws IllegalStateException {
        checkStatus();
        return memoryStoreHitCount;
    }

	/**
	 * Returns whether there is an empty square at the passed position.
	 * NB: a goal is <em>not</em> considered to be empty.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is an empty square
	 *                           at the passed position, or<br>
	 * 		  <code>false</code> if there isn't an empty square
	 *                           at the passed position
	 */

	final public boolean isEmptySquare(int position) {
		return ! (boxesArray[position] || wallsArray[position] > 0 || goalsArray[position]);
	}

    /**
     * Number of times a requested item was found in the Disk Store
     *
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public int getDiskStoreHitCount() throws IllegalStateException {
        checkStatus();
        return diskStoreHitCount;
    }

    /**
     * Finds a creator method.
     */

    private Method findCreateMethod(Class objClass, String name) {
        final String methodName = makeMethodName("create", name);
        final Method[] methods = objClass.getMethods();
        for (int i = 0; i < methods.length; i++) {
            final Method method = methods[i];
            if (!method.getName().equals(methodName)) {
                continue;
            }
            if (Modifier.isStatic(method.getModifiers())) {
                continue;
            }
            if (method.getParameterTypes().length != 0) {
                continue;
            }
            if (method.getReturnType().isPrimitive() || method.getReturnType().isArray()) {
                continue;
            }
            return method;
        }

        return null;
    }

    /**
     * Builds a method name from an element or attribute name.
     */

    private String makeMethodName(final String prefix, final String name) {
        return prefix + Character.toUpperCase(name.charAt(0)) + name.substring(1);
    }

    /**
     * Number of times a requested element was not found in the cache. This
     * may be because it expired, in which case this will also be recorded in {@link #getMissCountExpired},
     * or because it was simply not there.
     *
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public int getMissCountNotFound() throws IllegalStateException {
        checkStatus();
        return missCountNotFound;
    }

    /**
     * Number of times a requested element was found but was expired
     *
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     */

    public int getMissCountExpired() throws IllegalStateException {
        checkStatus();
        return missCountExpired;
    }

	/**
	 * Returns whether there is an empty square at the passed position.
	 * NB: a goal is <em>not</em> considered to be empty.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if there is an empty square
	 *                           at the passed position, or<br>
	 * 		  <code>false</code> if there isn't an empty square
	 *                           at the passed position
	 */

	final public boolean isEmptySquare(int x, int y) {
		return ! (   boxesArray[x + width * y]
		          || wallsArray[x + width * y] > 0
		          || goalsArray[x + width * y]     );
	}

    /**
     * Gets the cache name
     */

    public String getName() {
        return name;
    }

    /**
     * Formats the current document location.
     */

    private String getLocation() {
        return locator.getSystemId() + ':' + locator.getLineNumber();
    }

    /**
     * Gets timeToIdleSeconds
     */

    public long getTimeToIdleSeconds() {
        return timeToIdleSeconds;
    }

    /**
     * Gets timeToLiveSeconds
     */

    public long getTimeToLiveSeconds() {
        return timeToLiveSeconds;
    }

	/**
	 * Returns whether the square at the passed is accessible,
	 * that means: not a box and not a wall.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if the square is accessible, or<br>
	 * 		  <code>false</code> if the square isn't accessible
	 */

	final public boolean isAccessible(int position) {
		return ! (wallsArray[position] > 0 || boxesArray[position]);
	}

    /**
     * Does the overflow go to disk
     */

    public boolean isOverflowToDisk() {
        return overflowToDisk;
    }

    /**
     * Gets the maximum number of elements to hold in memory
     */

    public int getMaxElementsInMemory() {
        return maxElementsInMemory;
    }

	/**
	 * Returns whether the square at the passed is accessible,
	 * i.e. not a box and not a wall.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is accessible, or<br>
	 * 		  <code>false</code> if the square isn't accessible
	 */

	final public boolean isAccessible(int x, int y) {
		return ! (wallsArray[x + width * y] > 0 || boxesArray[x + width * y]);
	}

    /**
     * The policy used to evict elements from the {@link net.sf.ehcache.store.MemoryStore}.
     * This can be one of:
     * <ol>
     * <li>LRU - least recently used
     * <li>LFU - least frequently used
     * <li>FIFO - first in first out, the oldest element by creation time
     * </ol>
     * The default value is LRU
     *
     * @since 1.2
     */

    public MemoryStoreEvictionPolicy getMemoryStoreEvictionPolicy() {
        return memoryStoreEvictionPolicy;
    }

    /**
     * Gets the disk cache path
     */

    public String getDiskCachePath() {
        if (diskStore != null) {
            return diskStore.path;
        } else {
            return null;
        }
    }

    /**
     * Gets a Map of caches
     */

    public Set getCacheKeySet() {
        return caches.keySet();
    }

    /**
     * Checks whether this cache element has expired.
     * <p/>
     * The element is expired if:
     * <ol>
     * <li> the idle time is non-zero and has elapsed, unless the cache is eternal; or
     * <li> the time to live is non-zero and has elapsed, unless the cache is eternal; or
     * <li> the value of the element is null.
     * </ol>
     *
     * @return true if it has expired
     * @throws IllegalStateException if the cache is not {@link Status#STATUS_ALIVE}
     * @throws NullPointerException  if the element is null
     */

    public boolean isExpired(Element element) throws IllegalStateException, NullPointerException {
        checkStatus();
        boolean expired;
        synchronized (element) {
            if (element.getValue() == null) {
                expired = true;
            }
            if (!eternal) {
                expired = checkExpirationForNotEternal(element);
            } else {
                expired = false;
            }
            if (LOG.isDebugEnabled()) {
                Serializable key = null;
                if (element != null) {
                    key = element.getKey();
                }
                LOG.debug(getName() + ": Is element with key " + key + " expired?: " + expired);
            }
            return expired;
        }
    }

	/**
	 * Returns whether the square at the passed position is accessible for
	 * a box.  A square is accessible for a box if there is neither a wall
	 * nor a box at this square AND the square is no simple deadlock square.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if the square is accessible for a box, or<br>
	 * 		  <code>false</code> if the square isn't accessible for a box
	 */

	final public boolean isAccessibleBox(int position) {
		return ! (   wallsArray[position] > 0
				  || boxesArray[position]
				  || simpleDeadlockSquareForwards[position]
				  || advancedSimpleDeadlockSquareForwards[position] );
	}

    /**
     * Clones a cache. This is only legal if the cache has not been
     * initialized. At that point only primitives have been set and no
     * {@link net.sf.ehcache.store.LruMemoryStore} or {@link net.sf.ehcache.store.DiskStore} has been created.
     *
     * @return an object of type {@link Cache}
     * @throws CloneNotSupportedException
     */

    public Object clone() throws CloneNotSupportedException {
        if (!(memoryStore == null && diskStore == null)) {
            throw new CloneNotSupportedException("Cannot clone an initialized cache.");
        }
        //added by yanai
        Cache cache = (Cache) super.clone();
        cache.cacheEventNotificationService = new CacheEventNotificationService(cache);
        return cache;
       //end of add
    }

        /**
         * Sets the class name
         *
         * @param fullyQualifiedClassPath
         */

        public void setClass(String fullyQualifiedClassPath) {
            this.fullyQualifiedClassPath = fullyQualifiedClassPath;
        }

	/**
	 * Returns whether the square at the passed position is accessible for
	 * a box.  A square is accessible for a box if there is neither a wall
	 * nor a box at this square AND the square is no simple deadlock square.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is accessible for a box, or<br>
	 * 		  <code>false</code> if the square isn't accessible for a box
	 */

	final public boolean isAccessibleBox(int x, int y) {
		return ! (   wallsArray[x + width * y] > 0
				  || boxesArray[x + width * y]
				  || simpleDeadlockSquareForwards[x + width * y]
				  || advancedSimpleDeadlockSquareForwards[x + width * y] );
	}

        /**
         * Sets the name of the cache. This must be unique
         */

        public void setName(String name) {
            this.name = name;
        }

    /**
     * Use this to access the service in order to register and unregister listeners
     *
     * @return the CacheEventNotificationService instance for this cache.
     */

    public CacheEventNotificationService getCacheEventNotificationService() {
        return cacheEventNotificationService;
    }

        /**
         * Sets the maximum objects to be held in memory
         */

        public void setMaxElementsInMemory(int maxElementsInMemory) {
            this.maxElementsInMemory = maxElementsInMemory;
        }

    /**
     * Notifies all registered listeners, in no guaranteed order, that an element was removed
     * @param element
     * @see CacheEventListener#notifyElementRemoved
     */

    public void notifyElementRemoved(Element element) {
        Iterator iterator = cacheEventListeners.iterator();
        while (iterator.hasNext()) {
            CacheEventListener cacheEventListener = (CacheEventListener) iterator.next();
            cacheEventListener.notifyElementRemoved(cache, element);
        }
    }

        /**
         * Sets the eviction policy. An invalid argument will set it to null
         */

        public void setMemoryStoreEvictionPolicy(String memoryStoreEvictionPolicy) {
            this.memoryStoreEvictionPolicy = MemoryStoreEvictionPolicy.fromString(memoryStoreEvictionPolicy);
        }

    /**
     * Notifies all registered listeners, in no guaranteed order, that an element has expired
     * @param element
     * @see CacheEventListener#notifyElementExpired
     */

    public void notifyElementExpiry(Element element) {
        Iterator iterator = cacheEventListeners.iterator();
        while (iterator.hasNext()) {
            CacheEventListener cacheEventListener =  (CacheEventListener) iterator.next();
            cacheEventListener.notifyElementExpired(cache, element);
        }
    }

    /**
     * Adds a listener to the notification service. No guarantee is made that listeners will be
     * notified in the order they were added.
     * @param cacheEventListener
     * @return true if the listener is being added and was not already added
     */

    public boolean registerListener(CacheEventListener cacheEventListener) {
        return cacheEventListeners.add(cacheEventListener);
    }

    /**
     * Removes a listener from the notification service.
     * @param cacheEventListener
     * @return true if the listener was present
     */

    public boolean unregisterListener(CacheEventListener cacheEventListener) {
        return cacheEventListeners.remove(cacheEventListener);
    }

    /**
     * Gets a list of the listeners registered to this class
     * @return a list of type <code>CacheEventListener</code>
     */

    public Set getCacheEventListeners() {
        return cacheEventListeners;
    }

	/**
	 * Returns whether the square at the passed position is a wall
	 * or a simple deadlock square.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if the square is a wall or a simple
	 *                           deadlock square, or<br>
	 * 		  <code>false</code> if the square is neither a wall nor a simple
	 *                           deadlock square
	 */

	final public boolean isWallOrIllegalSquare(int position) {
		return     wallsArray[position] > 0
				|| simpleDeadlockSquareForwards[position]
				|| advancedSimpleDeadlockSquareForwards[position];
	}

        /**
         * Sets whether elements are eternal. If eternal,  timeouts are ignored and the element
         * is never expired.
         */

        public void setEternal(boolean eternal) {
            this.eternal = eternal;
        }

	/**
	 * Returns whether the current level is valid.
	 * <P>
	 * If the level is invalid an info message is displayed.
	 * 
	 * @return <code>true</code> if the level is valid, and<br>
	 *        <code>false</code> if the level is invalid
	 */

	public boolean isLevelValid() {

		StringBuilder validityMessage = new StringBuilder();

		// Let the board check if it is valid.
		boolean levelIsValid = board.isValid(validityMessage);

		// If the level is invalid the editor mustn't be left and the
		// reason for the invalidity is displayed.
		if (levelIsValid == false) {
			displayInfotext(validityMessage.toString());
			applicationGUI.setEditorMenuItemEnabled(false);
		} else {
			displayInfotext("");
			applicationGUI.setEditorMenuItemEnabled(true);
		}

		return levelIsValid;
	}

	/**
	 * Uses JavaGroups to broadcast the supplied notification message across the
	 * cluster.
	 * 
	 * @param message
	 *            The cluster nofication message to broadcast.
	 */

	public void sendNotification(ClusterNotification message) {
		if (log.isDebugEnabled())
			log.debug("sendNotification : " + message);
		bus.sendNotification(message);
	}

        /**
         * Sets the time to idle for an element before it expires. Is only used
         * if the element is not eternal.
         */

        public void setTimeToIdleSeconds(int timeToIdleSeconds) {
            this.timeToIdleSeconds = timeToIdleSeconds;
        }

	/**
	 * We are not using the caching, so we just return something that identifies
	 * us. This method should never be called directly.
	 */

	public Serializable getCache() {
		return "BroadcastingManager: " + bus.getLocalAddress();
	}

	/**
	 * A callback that is fired when a new member joins the cluster. This method
	 * should never be called directly.
	 * 
	 * @param address
	 *            The address of the member who just joined.
	 */

	public void memberJoined(Address address) {
		if (log.isInfoEnabled()) {
			log.info("A new member at address '" + address + "' has joined the cluster");
		}
	}

	/**
	 * A callback that is fired when an existing member leaves the cluster. This
	 * method should never be called directly.
	 * 
	 * @param address
	 *            The address of the member who left.
	 */

	public void memberLeft(Address address) {
		if (log.isInfoEnabled()) {
			log.info("Member at address '" + address + "' left the cluster");
		}
	}

        /**
         * Sets the time to idle for an element before it expires. Is only used
         * if the element is not eternal.
         */

        public void setTimeToLiveSeconds(int timeToLiveSeconds) {
            this.timeToLiveSeconds = timeToLiveSeconds;
        }

	/**
	 * Returns whether the square at the passed position is a wall
	 * or a simple deadlock square.
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is a wall or a simple
	 *                           deadlock square, or<br>
	 * 		  <code>false</code> if the square is neither a wall nor a simple
	 *                           deadlock square
	 */

	final public boolean isWallOrIllegalSquare(int x, int y) {
		return     wallsArray[x + width * y] > 0
				|| simpleDeadlockSquareForwards[x + width * y]
				|| advancedSimpleDeadlockSquareForwards[x + width * y];
	}

    /**
     * Shuts down the CacheManager.
     * <p/>
     * If the shutdown occurs on the singleton, then the singleton is removed, so that if a singleton access method
     * is called, a new singleton will be created.
     */

    public void shutdown() {
        if (status.equals(Status.STATUS_SHUTDOWN)) {
            if (LOG.isWarnEnabled()) {
                LOG.warn("CacheManager already shutdown");
            }
            return;
        }
        synchronized (CacheManager.class) {
            allCacheManagersDiskStorePaths.remove(diskStorePath);
            Enumeration allCaches = caches.elements();
            while (allCaches.hasMoreElements()) {
                Cache cache = (Cache) allCaches.nextElement();
                if (cache != null) {
                    cache.dispose();
                }
            }
            if ( getBroadcastingManager()!=null) getBroadcastingManager().stop();
            status = Status.STATUS_SHUTDOWN;
            
            //only delete singleton if the singleton is shutting down.
            if (this == singleton) {
                singleton = null;
            }
        }
    }

        /**
         * Sets whether elements can overflow to disk when the in-memory cache
         * has reached the set limit.
         */

        public void setOverflowToDisk(boolean overflowToDisk) {
            this.overflowToDisk = overflowToDisk;
        }

        /**
         * Sets whether, for caches that overflow to disk,
         * the disk cache persist between CacheManager instances
         */

        public void setDiskPersistent(boolean diskPersistent) {
            this.diskPersistent = diskPersistent;
        }

        /**
         * Sets the interval in seconds between runs of the disk expiry thread.
         * <p/>
         * 2 minutes is the default.
         * This is not the same thing as time to live or time to idle. When the thread runs it checks
         * these things. So this value is how often we check for expiry.
         */

        public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {
            this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;
        }

	/**
	 * Returns whether the passed position is an outer square or a wall.
	 * An outer square is a square which is outside the reachable area
	 * of the player even if there weren't any boxes on the board.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if the square is an outer square or a wall,
	 * or<br> <code>false</code> if the square isn't an outer square or a wall 
	 */

	final public boolean isOuterSquareOrWall(int position) {
		return    ! playersReachableSquaresOnlyWallsAtLevelStart[position]
		       || wallsArray[position] > 0;
	}

	/**
	 * Returns whether the square at the passed position is a simple
	 * deadlock square.
	 * <p>
	 * The search direction doesn't matter, because the simple deadlock squares
	 * of the other direction can never be reached from a specific direction.
	 * Therefore both the forward and the backward simple deadlock squares
	 * are checked.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if the square is a simple deadlock square,
	 * or<br> <code>false</code> if the square isn't a simple deadlock square
	 */

	final public boolean isSimpleDeadlockSquare(int position) {
		return     simpleDeadlockSquareForwards[position]
				|| advancedSimpleDeadlockSquareForwards[position]
				|| simpleDeadlockSquareBackwards[position];
	}

	/**
	 * This method is called upon plug-in activation
	 */

	public void start(BundleContext context) throws Exception {
		super.start(context);
	}

	/**
	 * This method is called when the plug-in is stopped
	 */

	public void stop(BundleContext context) throws Exception {
		super.stop(context);
		plugin = null;
	}

    /**
     *	Set the current input focus to self's destination entry field
     */

    protected void giveFocusToProjectsNames() {
        projectsNamesCombo.setFocus();
    }

	/**
	 * Returns whether the square at the passed position is a simple
	 * deadlock square.
	 * <p>
	 * The search direction doesn't matter, because the simple deadlock squares
	 * of the other direction can never be reached from a specific direction.
	 * Therefore both the forward and the backward simple deadlock squares
	 * are checked.
	 * <p>
	 * The arguments are not checked against the board dimensions.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is a simple deadlock square,
	 * or<br> <code>false</code> if the square isn't a simple deadlock square
	 */

	final public boolean isSimpleDeadlockSquare(int x, int y) {
		return     simpleDeadlockSquareForwards[x + width * y]
				|| advancedSimpleDeadlockSquareForwards[x + width * y]
				|| simpleDeadlockSquareBackwards[x + width * y];
	}

	/**
	 * Sets a new collection for playing.
	 * 
	 * @param levelCollection
	 *            the level collection to be set
	 */

	public void setCurrentCollection(LevelCollection levelCollection) {

		currentLevelCollection = levelCollection;

		// Update the combo box showing all levels.
		updateLevelComboBox();
		
//		if (Settings.isDebugModeActivated) {
//			System.out.println( "Set collection with "
//					            + levelCollection.getNumberOfLevels() + " levels" );
//			System.out.println( "  ID = " + levelCollection.getDatabaseID());
//			System.out.println( "  title = " + levelCollection.getTitle());
//		}
	}

	/**
	 * Uses the standard container selection fileDialog to choose the new value
	 * for the container field.
	 */

	protected String handleDirectoryBrowse(String path) {
		DirectoryDialog directoryDialog = new DirectoryDialog(getShell());
		if (path != null && !"".equals(path)) {
			directoryDialog.setFilterPath(path);
		}
		String dirName = directoryDialog.open();

		return dirName;
	}

	/**
	 * Method only for debugging:
	 * Returns whether the square at the passed position is
	 * a simple deadlock forward square.
	 *  
	 * @param position the position of the square
	 * @return <code>true</code> if the square is a wall or a simple
	 *                           deadlock forward square,
	 * or<br> <code>false</code> if the square isn't a wall nor a simple
	 *                           deadlock forward square
	 */

	final public boolean isSimpleDeadlockSquareForwardsDebug(int position) {
		return simpleDeadlockSquareForwards[position];
	}

	/**
	 * Method only for debugging:
	 * Returns whether the square at the passed position is
	 * a simple deadlock forward square.
	 *  
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is a wall or a simple
	 *                           deadlock forward square,
	 * or<br> <code>false</code> if the square isn't a wall nor a simple
	 *                           deadlock forward square
	 */

	final public boolean isSimpleDeadlockSquareForwardsDebug(int x, int y) {
		return simpleDeadlockSquareForwards[x + width * y];
	}

	/**
	 * Method only for debugging:
	 * Returns whether the square at the passed position is
	 * a simple deadlock backward square.
	 *  
	 * @param position the position of the square
	 * @return <code>true</code> if the square is a wall or a simple
	 *                           deadlock backward square,
	 * or<br> <code>false</code> if the square isn't a wall nor a simple
	 *                           deadlock backward square
	 */

	final public boolean isSimpleDeadlockSquareBackwardsDebug(int position) {
		return simpleDeadlockSquareBackwards[position];
	}

	/**
	 * If the current level collection contains the level with the
	 * specified data base ID, we return the title of that current collection.
	 * Otherwise we return null.
	 * <p>
	 * NOTE: There may be other collections containing that levelID.
	 * 
	 * @param levelID ID of the level to search for
	 * @return the title of the collection containing the levelID
	 */

	public String collectionTitleOfLevelID(int levelID) {
		if (findLevelByID(levelID) != null) {
			return currentLevelCollection.getTitle();
		}
		return null;
	}

    /**
     * Save a transient object.
     * An id is generated, assigned to the given object and returned.
     */

    public Serializable save(Object obj) throws HibernateException {

        if (obj==null) throw new NullPointerException("attempted to save null");

        Object object = unproxy(obj); //throws exception if uninitialized

        EntityEntry e = getEntry(object);
        if ( e!=null ) {
            if ( e.status==DELETED ) {
                forceFlush(e);
            }
            else {
                log.trace( "object already associated with session" );
                return e.id;
            }
        }

        Serializable id = saveWithGeneratedIdentifier(object, Cascades.ACTION_SAVE_UPDATE, null); //id might be generated by SQL insert
        reassociateProxy(obj, id); //TODO: move into saveWithGeneratedIdentifier()?
        return id;

    }

	/**
	 * Method only for debugging:
	 * Returns whether the square at the passed position is a simple deadlock backward square.
	 *  
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is a wall or a simple
	 *                           deadlock backward square,
	 * or<br> <code>false</code> if the square isn't a wall nor a simple
	 *                           deadlock backward square
	 */

	final public boolean isSimpleDeadlockSquareBackwardsDebug(int x, int y) {
		return simpleDeadlockSquareBackwards[x + width * y];
	}

	/**
	 * Method only for debugging:
	 * Returns whether the square at the passed position is
	 * an advanced simple deadlock forward square.
	 *  
	 * @param position the position of the square
	 * @return <code>true</code> if the square is a wall or an advanced
	 *                           simple deadlock forward square,
	 * or<br> <code>false</code> if the square isn't a wall nor a advanced
	 *                           simple deadlock forward square
	 */

	final public boolean isAdvancedSimpleDeadlockSquareForwards(int position) {
		return advancedSimpleDeadlockSquareForwards[position];
	}

	/**
	 * Method only for debugging:
	 * Returns whether the square at the passed position is a advanced simple deadlock forward square.
	 *  
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the square is a wall or an advanced
	 *                           simple deadlock forward square,
	 * or<br> <code>false</code> if the square isn't a wall nor a advanced
	 *                           simple deadlock forward square
	 */

	final public boolean isAdvancedSimpleDeadlockSquareForwards(int x, int y) {
		return advancedSimpleDeadlockSquareForwards[x + width * y];
	}

	/**
	 * Returns whether there is a box and a goal at the passed position.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if there is a box and a goal
	 *                           at the passed position,
	 * or<br> <code>false</code> if there isn't a box and a goal
	 *                           at the passed position
	 */

	final public boolean isBoxOnGoal(int position) {
		return boxesArray[position] && goalsArray[position];
	}

	/**
	 * Returns whether there is a box and a goal at the passed position.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @param position the position of the square
	 * @return <code>true</code> if there is a box and a goal
	 *                           at the passed position,
	 * or<br> <code>false</code> if there isn't a box and a goal
	 *                           at the passed position
	 */

	final public boolean isBoxOnGoal(int x, int y) {
		return boxesArray[x + width * y] && goalsArray[x + width * y];
	}

	/**
	 * Returns whether there is a player in the level.
	 * <p>
	 * Usually there is a player in every level. This method is just used for
	 * determining "special" squares for displaying them correctly. 
	 * 
	 * @return <code>true</code> if there is a player in the level,
	 * or<br> <code>false</code> if there isn't a player in the level
	 */

	final public boolean isPlayerInLevel() {
		return playerPosition != NO_PLAYER;
	}

	/**
	 * Method only for debugging:
	 * Returns whether the passed position is marked.
	 * <p>
	 * Marked positions are displayed with a little square.
	 * 
	 * @param position the position of the square
	 * @return <code>true</code> if the passed position is marked,
	 * or<br> <code>false</code> if the passed position is not marked
	 */

	final public boolean isMarked(int position) {
		return marked[position];
	}

	/**
	 * Method only for debugging:
	 * Returns whether the passed position is marked.
	 * <p>
	 * Marked positions are displayed with a little square graphic.
	 * 
	 * @param x the x-coordinate of the position
	 * @param y the y-coordinate of the position
	 * @return <code>true</code> if the passed position is marked,
	 * or<br> <code>false</code> if the passed position is not marked
	 */

	final public boolean isMarked(int x, int y) {
		return marked[x + width * y];
	}

	/**
	 * Removes a marking from the passed position.
	 * 
	 * @param position the position a marking is to be removed from.
	 */

	final public void removeMarking(int position) {
		marked[position] = false;
	}

	/**
	 * Removes a marking from the passed position.
	 * 
	 * @param x	the x-coordinate of the position the marking is to be removed from.
	 * @param y the y-coordinate of the position the marking is to be removed from.
	 */

	final public void removeMarking(int x, int y) {
		marked[x + width * y] = false;
	}

	/**
	 * Removes all marking from the board.
	 */

	final public void removeAllMarking() {
		Arrays.fill(marked, false);			// this is not time critical
	}

	/**
	 * Sets a marking at the passed position.
	 * 
	 * @param position the position the marking is to be set.
	 */

	final public void setMarking(int position) {
		marked[position] = true;
	}

    /**
     * associate a proxy that was instantiated by another session with this session
     */

    private void reassociateProxy(LazyInitializer li, HibernateProxy proxy) throws MappingException {
        if ( li.getSession()!=this ) {
            ClassPersister persister = getClassPersister( li.getPersistentClass() );
            Key key = new Key( li.getIdentifier(), persister );
            if ( !proxiesByKey.containsKey(key) ) proxiesByKey.put(key, proxy); // any earlier proxy takes precedence
            HibernateProxyHelper.getLazyInitializer( proxy ).setSession(this);
        }
    }

	/**
	 * Sets a marking at the passed position.
	 * 
	 * @param x the x-coordinate of the position a marking is to be set.
	 * @param y the y-coordinate of the position a marking is to be set.
	 */

	final public void setMarking(int x, int y) {
		marked[x + width * y] = true;
	}

	/**
	 * Marks the passed position with the passed value.
	 * 
	 * @param position  what position is to be marked
	 * @param markValue with what value the position id to be marked
	 */

	final public void assignMarking(int position, boolean markValue) {
		marked[position] = markValue;
	}

	/**
	 * Changes the making status of the passed position.
	 * 
	 * @param position the position is to be changed
	 */

	final public void flipMarking(int position) {
		marked[position] = ! marked[position];
	}

	/**
	 * Returns the number of the box located at the passed position.
	 * For positions without a box the return value is undefined.
	 * 
	 * @param position the position of the square	 
	 * @return	the number of the box
	 */

	final public int getBoxNo(int position) {
		return boxNumbers[position];
	}

	/**
	 * Returns the number of the goal located at the passed position.
	 * For positions without a goal the return value is undefined.
	 * 
	 * @param position the position of the square	 
	 * @return	the number of the goal
	 */

	final public int getGoalNo(int position) {
		return goalsNumbers[position];
	}

	/**
	 * Returns the position of the goal with the passed goal number.
	 * 
	 * @param goalNo the number of the goal
	 * @return the position of the goal
	 */

	final public int getGoalPosition(int goalNo) {
		return goalsPositions[goalNo];
	}

	/**
	 * Returns the distance which the player has to walk,
	 * starting from one square in order to reach a second square.
	 * 
	 * @param fromSquare player start position
	 * @param toSquare	 player walk destination
	 * @return number of steps the player needs to walk
	 */

	final public int getPlayerDistance(int fromSquare, int toSquare) {
		return playerDistances[fromSquare][toSquare];
	}

	/**
	 * Sets a new board position.
	 * 
	 * @param position Board position to be set.
	 */

	final public void setBoardPosition(IBoardPosition position) {
		setBoardPosition(position.getPositions());
	}

	/**
	 * Sets a new board position.
	 * 
	 * @param positions box and player positions to be set.
	 */

	final public void setBoardPosition(int[] positions) {

		// remove all boxes from the board
		removeAllBoxes();

		// store the new box positions in our box data object
		boxData.setBoxPositions(positions);

		// Put the new boxes into the board
		for (int boxNo = 0; boxNo < boxCount; boxNo++) {
			setBoxWithNo(boxNo, positions[boxNo]);
		}

		// set up the new player location
		playerPosition = positions[boxCount];
	}

	/**
	 * Removes all boxes from the board.
	 */

	final public void removeAllBoxes() {
		for (int boxNo = 0; boxNo < boxCount; boxNo++) {
			removeBox(boxData.getBoxPosition(boxNo));
		}
	}

	/**
	 * The goals of the backward search are the box positions at search start.
	 * Here we set the goals for the backward search from the current box
	 * positions.
	 */

	final public void setGoalsBackwardsSearch() {

		int goalNo = 0;

		// Set up the new goals for backwards search, and clear the old ones
		for (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {
			if (isBox(position) && isOuterSquareOrWall(position) == false) {
				goalSquareBackwardsSearch[position] = true;
				goalsPositionsBackwardsSearch[goalNo++] = position;
			} else {
				goalSquareBackwardsSearch[position] = false;
			}
		}
	}

    /**
     * Retrieve a list of persistent objects using a hibernate query
     */

    public List find(String query) throws HibernateException {
        return find(query, NO_ARGS, NO_TYPES);
    }

		/**
		 * Returns the push distance of a specific box to a specific goal.
		 * <p>
		 * The distance is calculated under the assumption that:
		 * <ol>
		 *  <li> the box is the only one on the whole board
		 *  <li> the player can reach every side of the box at the moment
		 * </ol>
		 *  
		 * @param boxNo number of the relevant box
		 * @param goalNo number of the relevant goal
		 * @return push distance
		 */

		public int getBoxDistanceForwardsPlayerPositionIndependentNo(int boxNo, int goalNo) {
			return getBoxDistanceForwardsPlayerPositionIndependent(boxData.getBoxPosition(boxNo), goalsPositions[goalNo]);
		}

	/**
	 * The action has been activated. The argument of the
	 * method represents the 'real' action sitting
	 * in the workbench UI.
	 * @see IWorkbenchWindowActionDelegate#run
	 */

	public void run(IAction action) {
		UpdateManagerDialog d = new UpdateManagerDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
		d.open();
	}

	/**
	 * Selection in the workbench has been changed. We 
	 * can change the state of the 'real' action here
	 * if we want, but this can only happen after 
	 * the delegate has been created.
	 * @see IWorkbenchWindowActionDelegate#selectionChanged
	 */

	public void selectionChanged(IAction action, ISelection selection) {
	}

	/**
	 * We can use this method to dispose of any system
	 * resources we previously allocated.
	 * @see IWorkbenchWindowActionDelegate#dispose
	 */

	public void dispose() {
	}

	/**
	 * We will cache window object in order to
	 * be able to provide parent shell for the message dialog.
	 * @see IWorkbenchWindowActionDelegate#init
	 */

	public void init(IWorkbenchWindow window) {
		this.window = window;
	}

    /**
     * The <code>addToHierarchyToCheckedStore</code> implementation of this 
     * <code>WizardDataTransferPage</code> method returns <code>false</code>. 
     * Subclasses may override this method.
     */

    protected boolean allowNewContainerName() {
        return false;
    }

    /**
     * This method must be called just before this window becomes visible.
     */

    public void aboutToOpen() {
        determineWhiteCheckedDescendents(root);
        checkNewTreeElements(treeContentProvider.getElements(root));

        //select the first element in the list
        Object[] elements = treeContentProvider.getElements(root);
        Object primary = elements.length > 0 ? elements[0] : null;
        if (primary != null) {
            treeViewer.setSelection(new StructuredSelection(primary));
        }
        treeViewer.getControl().setFocus();
    }

    /**
     *	Add the passed listener to self's collection of clients
     *	that listen for changes to element checked states
     *
     *	@param listener ICheckStateListener
     */

    public void addCheckStateListener(ICheckStateListener listener) {
        addListenerObject(listener);
    }

    /**
     * Returns a content provider for <code>IResource</code>s that returns 
     * only children of the given resource type.
     */

    private ITreeContentProvider getResourceProvider(final int resourceType) {
        return new WorkbenchContentProvider() {
            @SuppressWarnings("unchecked")
			public Object[] getChildren(Object o) {
                //input element case
                if (o instanceof ArrayList) {
                    return ((ArrayList) o).toArray();
                } 
               return new Object[0];            	
            }
        };
    }

    /**
     *	Return a boolean indicating whether all children of the passed tree element
     *	are currently white-checked
     *
     *	@return boolean
     *	@param treeElement java.lang.Object
     */

    protected boolean areAllChildrenWhiteChecked(Object treeElement) {
        Object[] children = treeContentProvider.getChildren(treeElement);
        for (int i = 0; i < children.length; ++i) {
            if (!whiteCheckedTreeItems.contains(children[i])) {
				return false;
			}
        }

        return true;
    }

    /**
     *	Return a boolean indicating whether all list elements associated with
     *	the passed tree element are currently checked
     *
     *	@return boolean
     *	@param treeElement java.lang.Object
     */

    protected boolean areAllElementsChecked(Object treeElement) {
        List checkedElements = (List) checkedStateStore.get(treeElement);
        if (checkedElements == null) {
			return false;
		}
        return true;
    }

    /**
     *	Iterate through the passed elements which are being realized for the first
     *	time and check each one in the tree viewer as appropriate
     */

    protected void checkNewTreeElements(Object[] elements) {
        for (int i = 0; i < elements.length; ++i) {
            Object currentElement = elements[i];
            boolean checked = checkedStateStore.containsKey(currentElement);
            treeViewer.setChecked(currentElement, checked);
            treeViewer.setGrayed(currentElement, checked
                    && !whiteCheckedTreeItems.contains(currentElement));
        }
    }

    /**
     * Returns this page's collection of currently-specified resources to be 
     * exported. This is the primary resource selection facility accessor for 
     * subclasses.
     *
     * @return an iterator over the collection of resources currently selected 
     * for export (element type: <code>IResource</code>). This will include
     * white checked folders and individually checked files.
     */

    protected Iterator getSelectedResourcesIterator() {
        return this.resourceGroup.getAllCheckedListItems().iterator();
    }

    /**
     *	An item was checked in one of self's two views.  Determine which
     *	view this occurred in and delegate appropriately
     *
     *	@param event CheckStateChangedEvent
     */

    public void checkStateChanged(final CheckStateChangedEvent event) {

        //Potentially long operation - show a busy cursor
        BusyIndicator.showWhile(treeViewer.getControl().getDisplay(),
            new Runnable() {
                public void run() {
                    if (event.getCheckable().equals(treeViewer)) {
						treeItemChecked(event.getElement(), event
                                .getChecked());
					}

                    notifyCheckStateChangeListeners(event);
                }
            });
    }

    /**
     * Returns the resource extensions currently specified to be exported.
     *
     * @return the resource extensions currently specified to be exported (element 
     *   type: <code>String</code>)
     */

    protected List getTypesToExport() {
        return selectedTypes;
    }

    /**
     * Returns this page's collection of currently-specified resources to be 
     * exported. This returns both folders and files - for just the files use
     * getSelectedResources.
     *
     * @return a collection of resources currently selected 
     * for export (element type: <code>IResource</code>)
     */

    protected List getWhiteCheckedResources() {
        return this.resourceGroup.getAllWhiteCheckedItems();
    }

    /**
     *	Create this group's tree viewer.
     */

    protected void createTreeViewer(Composite parent, boolean useHeightHint) {
        Tree tree = new Tree(parent, SWT.CHECK | SWT.BORDER);
        GridData data = new GridData(GridData.FILL_BOTH);
        if (useHeightHint) {
			data.heightHint = PREFERRED_HEIGHT;
		}
        tree.setLayoutData(data);
        tree.setFont(parent.getFont());

        treeViewer = new CheckboxTreeViewer(tree);
        treeViewer.setContentProvider(treeContentProvider);
        treeViewer.setLabelProvider(treeLabelProvider);
        treeViewer.addTreeListener(this);
        treeViewer.addCheckStateListener(this);
        treeViewer.addSelectionChangedListener(this);
    }

    /**
     * Returns whether the extension of the given resource name is an extension that
     * has been specified for export by the user.
     *
     * @param resourceName the resource name
     * @return <code>true</code> if the resource name is suitable for export based 
     *   upon its extension
     */

    protected boolean hasExportableExtension(String resourceName) {
        if (selectedTypes == null) {
			return true;
		}

        int separatorIndex = resourceName.lastIndexOf("."); //$NON-NLS-1$
        if (separatorIndex == -1) {
			return false;
		}

        String extension = resourceName.substring(separatorIndex + 1);

        Iterator it = selectedTypes.iterator();
        while (it.hasNext()) {
            if (extension.equalsIgnoreCase((String) it.next())) {
				return true;
			}
        }

        return false;
    }

    /**
     * Returns a boolean indicating whether the passed tree item should be
     * white-checked.
     *
     * @return boolean
     * @param treeElement java.lang.Object
     */

    protected boolean determineShouldBeWhiteChecked(Object treeElement) {
        return areAllChildrenWhiteChecked(treeElement)
                && areAllElementsChecked(treeElement);
    }

    /**
     *	Recursively add appropriate tree elements to the collection of
     *	known white-checked tree elements.
     *
     *	@param treeElement java.lang.Object
     */

    protected void determineWhiteCheckedDescendents(Object treeElement) {
        // always go through all children first since their white-checked
        // statuses will be needed to determine the white-checked status for
        // this tree element
        Object[] children = treeContentProvider.getElements(treeElement);
        for (int i = 0; i < children.length; ++i) {
			determineWhiteCheckedDescendents(children[i]);
		}

        // now determine the white-checked status for this tree element
        if (determineShouldBeWhiteChecked(treeElement)) {
			setWhiteChecked(treeElement, true);
		}
    }

    /**
     * Persists resource specification control setting that are to be restored
     * in the next instance of this page. Subclasses wishing to persist additional
     * setting for their controls should extend hook method 
     * <code>internalSaveWidgetValues</code>.
     */

    protected void saveWidgetValues() {
        // allow subclasses to save values
        internalSaveWidgetValues();
    }

    /**
     * Cause the tree viewer to expand all its items
     */

    public void expandAll() {
        treeViewer.expandAll();
    }

    /**
     * Set the initial selections in the resource group.
     */

    protected void setupBasedOnInitialSelections() {

        Iterator it = this.initialResourceSelection.iterator();
        while (it.hasNext()) {
            IResource currentResource = (IResource) it.next();
            if (currentResource.getType() != IResource.FILE) {
				this.resourceGroup.initialCheckTreeItem(currentResource);
			}
        }
    }

		/**
		 * Returns whether the player can reach the passed position.
		 * 
		 * @param position the position to be tested for reachability
		 * 
		 * @return <code>true</code> the position is reachable by the player
		 * 			<code>false</code> the position isn't reachable by the player
		 */

		final public boolean isSquareReachable(int position) {
			return playersReachableSquaresArray[position] == indicatorReachableSquare;
		}

    /**
     * Save any editors that the user wants to save before export.
     * @return boolean if the save was successful.
     */

    protected boolean saveDirtyEditors() {
        return IDEWorkbenchPlugin.getDefault().getWorkbench().saveAllEditors(
                true);
    }

    /**
     *	Returns a flat list of all of the leaf elements which are checked.
     *
     *	@return all of the leaf elements which are checked. This API does not
     * 	return null in order to keep backwards compatibility.
     */

    public List getAllCheckedListItems() {

        final ArrayList returnValue = new ArrayList();

        IElementFilter passThroughFilter = new IElementFilter() {

            @SuppressWarnings("unchecked")
			public void filterElements(Collection elements,
                    IProgressMonitor monitor) {
                returnValue.addAll(elements);
            }

            @SuppressWarnings("unchecked")
			public void filterElements(Object[] elements,
                    IProgressMonitor monitor) {
                for (int i = 0; i < elements.length; i++) {
                    returnValue.add(elements[i]);
                }
            }
        };

        try {
            getAllCheckedListItems(passThroughFilter, null);
        } catch (InterruptedException exception) {
            return new ArrayList();
        }
        return returnValue;

    }

    /**
     * Check if widgets are enabled or disabled by a change in the dialog.
     */

    protected void updateWidgetEnablements() {

        boolean pageComplete = determinePageCompletion();
        setPageComplete(pageComplete);
        if (pageComplete) {
			setMessage(null);
		}
        super.updateWidgetEnablements();
    }

		/**
		 * Returns a clone of the current object.
		 * 
		 * @return a PlayersReachableSquares object identical to this object
		 */

		final public PlayersReachableSquares getClone() {
			return new PlayersReachableSquares(playersReachableSquaresArray, indicatorReachableSquare);
		}

    /**
     * give the interceptor an opportunity to override the default instantiation
     */

    public Object instantiate(ClassPersister persister, Serializable id) throws HibernateException {
        Object result = interceptor.instantiate( persister.getMappedClass(), id );
        if (result==null) result = persister.instantiate(id);
        return result;
    }

    /**
     *	Add the passed value to self's destination widget's history
     *
     *	@param value java.lang.String
     */

    protected void addDestinationItem(String value) {
        destinationNameField.add(value);
    }

    /**
     *	Returns a list of all of the items that are white checked.
     * 	Any folders that are white checked are added and then any files
     *  from white checked folders are added. 
     *
     *	@return the list of all of the items that are white checked
     */

    public List getAllWhiteCheckedItems() {

        List result = new ArrayList();

        //Iterate through the children of the root as the root is not in the store
        Object[] children = treeContentProvider.getChildren(root);
        for (int i = 0; i < children.length; ++i) {
            findAllWhiteCheckedItems(children[i], result);
        }

        return result;
    }

    /**
     *	Answer the number of elements that have been checked by the
     *	user.
     *
     *	@return int
     */

    public int getCheckedElementCount() {
        return checkedStateStore.size();
    }

    /**
     * Create the buttons for the group that determine if the entire or
     * selected directory structure should be created.
     * @param optionsGroup
     * @param font
     */

    protected void createDirectoryStructureOptions(Composite optionsGroup, Font font) {
        // create directory structure radios
        createDirectoryStructureButton = new Button(optionsGroup, SWT.RADIO
                | SWT.LEFT);
        createDirectoryStructureButton.setText(DataTransferMessages.FileExport_createDirectoryStructure);
        createDirectoryStructureButton.setSelection(false);
        createDirectoryStructureButton.setFont(font);

        // create directory structure radios
        createSelectionOnlyButton = new Button(optionsGroup, SWT.RADIO
                | SWT.LEFT);
        createSelectionOnlyButton.setText(DataTransferMessages.FileExport_createSelectedDirectories);
        createSelectionOnlyButton.setSelection(true);
        createSelectionOnlyButton.setFont(font);
    }

		/**
		 * Returns the position reachable of the player that is
		 * the most top left one.
		 * This is a normalization of the player position, used, where the
		 * exact player position is not relevant, but its reachable area is.
		 * 
		 * @return the position top left
		 */

		final public int getPlayerPositionTopLeft() {

			// Calculate squares reachable by the player.
			update();

			// This is just the square with the smallest index.
			for (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {
				if (isSquareReachable(position)) {
					return position;
				}
			}

			// The player can't reach any square.
			return -1;
		}

    /**
     *	Set the checked state of self and all ancestors appropriately. Do not white check anyone - this is
     *  only done down a hierarchy.
     */

    private void grayUpdateHierarchy(Object treeElement) {

        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);

        treeViewer.setGrayChecked(treeElement, shouldBeAtLeastGray);

        if (whiteCheckedTreeItems.contains(treeElement)) {
			whiteCheckedTreeItems.remove(treeElement);
		}

        // proceed up the tree element hierarchy
        Object parent = treeContentProvider.getParent(treeElement);
        if (parent != null) {
            grayUpdateHierarchy(parent);
        }
    }

    /**
     * Set the initial checked state of the passed element to true,
     * as well as to all of its children and associated list elements
     * @param element
     */

    public void initialCheckTreeItem(Object element) {
        treeItemChecked(element, true);
        selectAndReveal(element);
    }

    /**
     * Attempts to ensure that the specified directory exists on the local file system.
     * Answers a boolean indicating success.
     *
     * @return boolean
     * @param directory java.io.File
     */

    protected boolean ensureDirectoryExists(File directory) {
        if (!directory.exists()) {
            if (!queryYesNoQuestion(DataTransferMessages.DataTransfer_createTargetDirectory)) {
				return false;
			}

            if (!directory.mkdirs()) {
                displayErrorDialog(DataTransferMessages.DataTransfer_directoryCreationError);
                giveFocusToDestination();
                return false;
            }
        }

        return true;
    }

    /**
     *	If the target for export does not exist then attempt to create it.
     *	Answer a boolean indicating whether the target exists (ie.- if it
     *	either pre-existed or this method was able to create it)
     *
     *	@return boolean
     */

    protected boolean ensureTargetIsValid(File targetDirectory) {
        if (targetDirectory.exists() && !targetDirectory.isDirectory()) {
            displayErrorDialog(DataTransferMessages.FileExport_directoryExists);
            giveFocusToDestination();
            return false;
        }

        return ensureDirectoryExists(targetDirectory);
    }

    /**
     *  Set up and execute the passed Operation.  Answer a boolean indicating success.
     *
     *  @return boolean
     */

    protected boolean executeExportOperation(FileSystemExportOperation op) {
        op.setCreateLeadupStructure(createDirectoryStructureButton
                .getSelection());
        op.setOverwriteFiles(overwriteExistingFilesCheckbox.getSelection());

        try {
            getContainer().run(true, true, op);
        } catch (InterruptedException e) {
            return false;
        } catch (InvocationTargetException e) {
            displayErrorDialog(e.getTargetException());
            return false;
        }

        IStatus status = op.getStatus();
        if (!status.isOK()) {
            ErrorDialog.openError(getContainer().getShell(),
                    DataTransferMessages.DataTransfer_exportProblems,
                    null, // no special message
                    status);
            return false;
        }

        return true;
    }

		/**
		 * Returns a (deep) clone of this object.
		 * 
		 * @return a (deep) clone of this object
		 */

		final public PlayersReachableSquaresOnlyWalls getClone() {
			return new PlayersReachableSquaresOnlyWalls(playersReachableSquaresOnlyWallsArray, reachableSquareIndicatorOnlyWalls);
		}

    /**
     *	Answer the string to display in self as the destination type
     *
     *	@return java.lang.String
     */

    protected String getDestinationLabel() {
        return DataTransferMessages.FileExport_toDirectory;
    }

    /**
     *	Remove the passed listener from self's collection of clients
     *	that listen for changes to element checked states
     *
     *	@param listener ICheckStateListener
     */

    public void removeCheckStateListener(ICheckStateListener listener) {
        removeListenerObject(listener);
    }

    /**
     *	Answer the contents of self's destination specification widget
     *
     *	@return java.lang.String
     */

    protected String getDestinationValue() {
        return destinationNameField.getText().trim();
    }

    /**
     *	Set the current input focus to self's destination entry field
     */

    protected void giveFocusToDestination() {
        destinationNameField.setFocus();
    }

		/**
		 * Returns whether a specific Square is reachable by the player. 
		 * 
		 * @param position Position which is checked for being reachable by the player
		 * @return true = Square is reachable; false = Square is not reachable
		 */

		final public boolean isSquareReachable(int position) {
			return playersReachableSquaresOnlyWallsArray[position] == reachableSquareIndicatorOnlyWalls;
		}

    /**
     *	Open an appropriate destination browser so that the user can specify a source
     *	to import from
     */

    protected void handleDestinationBrowseButtonPressed() {
        DirectoryDialog dialog = new DirectoryDialog(getContainer().getShell(),
                SWT.SAVE);
        dialog.setMessage(SELECT_DESTINATION_MESSAGE);
        dialog.setText(SELECT_DESTINATION_TITLE);
        dialog.setFilterPath(getDestinationValue());
        String selectedDirectoryName = dialog.open();

        if (selectedDirectoryName != null) {
            setErrorMessage(null);
            setDestinationValue(selectedDirectoryName);
        }
    }

     /**
     * Set the root of the widget to be new Root. Regenerate all of the tables and lists from this
     * value.
     * @param newRoot 
     */

    public void setRoot(Object newRoot) {
        this.root = newRoot;
        initialize();
    }

    /**
     * Handle all events and enablements for widgets in this page
     * @param e Event
     */

    public void handleEvent(Event e) {
        Widget source = e.widget;

        if (source == destinationBrowseButton) {
			handleDestinationBrowseButtonPressed();
		}

        updatePageCompletion();
    }

    /**
     *	Set the checked state of the passed tree element appropriately, and
     *	do so recursively to all of its child tree elements as well
     */

    protected void setTreeChecked(Object treeElement, boolean state) {

        if (!state) {
			checkedStateStore.remove(treeElement);
		}

        setWhiteChecked(treeElement, state);
        treeViewer.setChecked(treeElement, state);
        treeViewer.setGrayed(treeElement, false);

        // now logically check/uncheck all children as well if it has been expanded
        if (expandedTreeNodes.contains(treeElement)) {
            Object[] children = treeContentProvider.getChildren(treeElement);
            for (int i = 0; i < children.length; ++i) {
                setTreeChecked(children[i], state);
            }
        }
    }

    /**
     * Persists additional setting that are to be restored in the next instance of
     * this page.
     * <p> 
     * The <code>WizardImportPage</code> implementation of this method does
     * nothing. Subclasses may extend to persist additional settings.
     * </p>
     */

    private void internalSaveWidgetValues() {
        // update directory names history
        IDialogSettings settings = getDialogSettings();
        if (settings != null) {
            String[] directoryNames = settings
                    .getArray(STORE_DESTINATION_NAMES_ID);
            if (directoryNames == null) {
				directoryNames = new String[0];
			}

            directoryNames = addToHistory(directoryNames, getDestinationValue());
            settings.put(STORE_DESTINATION_NAMES_ID, directoryNames);

            // options
            settings.put(STORE_OVERWRITE_EXISTING_FILES_ID,
                    overwriteExistingFilesCheckbox.getSelection());

            settings.put(STORE_CREATE_STRUCTURE_ID,
                    createDirectoryStructureButton.getSelection());

        }
    }

    /**
     * If the existing proxy is insufficiently "narrow" (derived), instantiate a new proxy
     * and overwrite the registration of the old one. This breaks == and occurs only for
     * "class" proxies rather than "interface" proxies.
     */

    public Object narrowProxy(Object proxy, ClassPersister persister, Key key, Object object) throws HibernateException {

        if ( !persister.getConcreteProxyClass().isAssignableFrom( proxy.getClass() ) ) {

            if ( log.isWarnEnabled() ) log.warn(
                "Narrowing proxy to " + persister.getConcreteProxyClass() + " - this operation breaks =="
            );

            if (object!=null) {
                proxiesByKey.remove(key);
                return object; //return the proxied object
            }
            else {
                proxy = persister.createProxy( key.getIdentifier(), this );
                proxiesByKey.put(key, proxy); //overwrite old proxy
                return proxy;
            }

        }
        else {
            return proxy;
        }
    }

    /**
     * Set the sorter that is to be applied to self's tree viewer
     * @param sorter
     */

    public void setTreeSorter(ViewerSorter sorter) {
        treeViewer.setSorter(sorter);
    }

    /**
     *	Hook method for restoring widget values to the values that they held
     *	last time this wizard was used to completion.
     */

    protected void restoreWidgetValues() {
        IDialogSettings settings = getDialogSettings();
        if (settings != null) {
            String[] directoryNames = settings
                    .getArray(STORE_DESTINATION_NAMES_ID);
            if (directoryNames == null) {
				return; // ie.- no settings stored
			}

            // destination
            setDestinationValue(directoryNames[0]);
            for (int i = 0; i < directoryNames.length; i++) {
				addDestinationItem(directoryNames[i]);
			}

            // options
            overwriteExistingFilesCheckbox.setSelection(settings
                    .getBoolean(STORE_OVERWRITE_EXISTING_FILES_ID));

            boolean createDirectories = settings
                    .getBoolean(STORE_CREATE_STRUCTURE_ID);
            createDirectoryStructureButton.setSelection(createDirectories);
            createSelectionOnlyButton.setSelection(!createDirectories);
        }
    }

		/**
		 * Returns if a specific Square is reachable by the player.
		 * 
		 * @param x xPosition of square which is checked for being reachable by the player
		 * @param y yPosition of square which is checked for being reachable by the player
		 * @return true = Square is reachable; false = Square is not reachable
		 */

		final public boolean isSquareReachable(int x, int y) {
			return playersReachableSquaresOnlyWallsArray[x + width * y] == reachableSquareIndicatorOnlyWalls;
		}

    /**
     *	Handle the collapsing of an element in a tree viewer
     */

    public void treeCollapsed(TreeExpansionEvent event) {
        // We don't need to do anything with this
    }

    /**
     *	Set the contents of the receivers destination specification widget to
     *	the passed value
     *
     */

    protected void setDestinationValue(String value) {
        destinationNameField.setText(value);
    }

    /**
     *	Handle the expansionsion of an element in a tree viewer
     */

    public void treeExpanded(TreeExpansionEvent event) {
        expandTreeElement(event.getElement());
    }

    /**
     *	Answer a boolean indicating whether the receivers destination specification
     *	widgets currently all contain valid values.
     */

    protected boolean validateDestinationGroup() {
        String destinationValue = getDestinationValue();
        if (destinationValue.length() == 0) {
            setMessage(destinationEmptyMessage());
            return false;
        }

        String conflictingContainer = getConflictingContainerNameFor(destinationValue);
        if (conflictingContainer == null) {
			setErrorMessage(null);
		} else {
            setErrorMessage(NLS.bind(DataTransferMessages.FileExport_conflictingContainer, conflictingContainer));
            giveFocusToDestination();
            return false;
        }

        return true;
    }

    /**
     * Grab the existing proxy for an instance, if
     * one exists. (otherwise return the instance)
     */

    public Object proxyFor(ClassPersister persister, Key key, Object impl) throws HibernateException {
        if ( !persister.hasProxy() ) return impl;
        Object proxy = proxiesByKey.get(key);
        if (proxy!=null) {
            return narrowProxy(proxy, persister, key, impl);
        }
        else {
            return impl;
        }
    }

    /**
     *  Callback that's invoked when the checked status of an item in the tree
     *  is changed by the user.
     */

    protected void treeItemChecked(Object treeElement, boolean state) {

        // recursively adjust all child tree elements appropriately
        setTreeChecked(treeElement, state);

        Object parent = treeContentProvider.getParent(treeElement);
        if (parent == null) {
			return;
		}

        // now update upwards in the tree hierarchy 
        if (state) {
			grayCheckHierarchy(parent);
		} else {
			ungrayCheckHierarchy(parent);
		}

        //Update the hierarchy but do not white select the parent
        grayUpdateHierarchy(parent);
    }

    /**
     *	Logically un-gray-check all ancestors of treeItem iff appropriate.
     */

    protected void ungrayCheckHierarchy(Object treeElement) {
        if (!determineShouldBeAtLeastGrayChecked(treeElement)) {
			checkedStateStore.remove(treeElement);
		}

        Object parent = treeContentProvider.getParent(treeElement);
        if (parent != null) {
			ungrayCheckHierarchy(parent);
		}
    }

    /**
     *	Set the checked state of self and all ancestors appropriately
     */

    protected void updateHierarchy(Object treeElement) {

        boolean whiteChecked = determineShouldBeWhiteChecked(treeElement);
        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);

        treeViewer.setChecked(treeElement, shouldBeAtLeastGray);
        setWhiteChecked(treeElement, whiteChecked);
        if (whiteChecked) {
			treeViewer.setGrayed(treeElement, false);
		} else {
			treeViewer.setGrayed(treeElement, shouldBeAtLeastGray);
		}

        // proceed up the tree element hierarchy but gray select all of them
        Object parent = treeContentProvider.getParent(treeElement);
        if (parent != null) {
            grayUpdateHierarchy(parent);
        }
    }

	/**
     * Get the message used to denote an empty destination.
     */

    protected String destinationEmptyMessage() {
        return DataTransferMessages.FileExport_destinationEmpty;
    }

    /**
     * Returns the name of a container with a location that encompasses targetDirectory.
     * Returns null if there is no conflict.
     * 
     * @param targetDirectory the path of the directory to check.
     * @return the conflicting container name or <code>null</code>
     */

    protected String getConflictingContainerNameFor(String targetDirectory) {

        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
        IPath testPath = new Path(targetDirectory);

        if (root.getLocation().isPrefixOf(testPath)) {
			return DataTransferMessages.FileExport_rootName;
		}

	    IContainer[] containers = root.findContainersForLocation(testPath);
	    if (containers.length > 0){
    		return containers[0].getName();
	    }

        return null;

    }

    /** 
     * Set the focus on to the list widget.
     */

    public void setFocus() {
        this.treeViewer.getTree().setFocus();
    }

    /**
     *	Answer a boolean indicating the number of file resources that were
     *	specified for export
     *
     *	@return int
     */

    protected int countSelectedResources() throws CoreException {
        int result = 0;
        Iterator resources = resourcesToExport.iterator();

        while (resources.hasNext()) {
			result += countChildrenOf((IResource) resources.next());
		}

        return result;
    }

    /**
     *  Create the directories required for exporting the passed resource,
     *  based upon its container hierarchy
     *
     *  @param childResource org.eclipse.core.resources.IResource
     */

    protected void createLeadupDirectoriesFor(IResource childResource) {
        IPath resourcePath = childResource.getFullPath().removeLastSegments(1);
        makePathTree(resourcePath);
    }

    /**
     *  Create the directories required for exporting the passed resource,
     *  based upon its container hierarchy
     *
     *  @param childResource org.eclipse.core.resources.IResource
     */

    protected void createLeadupDirectoriesFor(IPath childPath) {
        IPath resourcePath = childPath.removeLastSegments(1);
        makePathTree(resourcePath);
    }

    /**
     * Create the directories tree
     * @param tree
     */

    private void makePathTree(IPath tree) {
        IPath targetPath = tree.removeLastSegments(tree.segmentCount() - 1);
        for (int i = 1; i < tree.segmentCount(); i++) {
        	targetPath = targetPath.append(tree.segment(i));
            if (!targetPath.toFile().exists())
            	targetPath.toFile().mkdir();
        }    	
    }

    /**
     * Create a "temporary" entry for a newly instantiated entity. The entity is uninitialized,
     * but we need the mapping from id to instance in order to guarantee uniqueness.
     */

    public void addUninitializedEntity(Key key, Object object, LockMode lockMode) {
        addEntity(key, object);
        addEntry( object, LOADING, null, key.getIdentifier(), null, lockMode, true, null /*getPersister(object)*/, false ); //temporary
    }

    /**
     *  Answer a boolean indicating whether the passed child is a descendent
     *  of one or more members of the passed resources collection
     *
     *  @return boolean
     *  @param resources java.util.List
     *  @param child org.eclipse.core.resources.IResource
     */

    protected boolean isDescendent(List resources, IResource child) {
        if (child.getType() == IResource.PROJECT) {
			return false;
		}

        IResource parent = child.getParent();
        if (resources.contains(parent)) {
			return true;
		}

        return isDescendent(resources, parent);
    }

    /**
     *	Set this boolean indicating whether a directory should be created for
     *	Folder resources that are explicitly passed for export
     *
     *	@param value boolean
     */

    public void setCreateContainerDirectories(boolean value) {
        createContainerDirectories = value;
    }

    /**
     *	Set this boolean indicating whether each exported resource's complete path should
     *	include containment hierarchies as dictated by its parents
     *
     *	@param value boolean
     */

    public void setCreateLeadupStructure(boolean value) {
        createLeadupStructure = value;
    }

    /**
     *	Set this boolean indicating whether exported resources should automatically
     *	overwrite existing files when a conflict occurs. If not
     *	query the user.
     *
     *	@param value boolean
     */

    public void setOverwriteFiles(boolean value) {
        if (value) {
			overwriteState = OVERWRITE_ALL;
		}
    }

    /**
     * Add the "hydrated state" (an array) of an uninitialized entity to the session. We don't try
     * to resolve any associations yet, because there might be other entities waiting to be
     * read from the JDBC result set we are currently processing
     */

    public void postHydrate(ClassPersister persister, Serializable id, Object[] values, Object object, LockMode lockMode) throws HibernateException {
        //persister.setIdentifier(object, id);
        Object version = Versioning.getVersion(values, persister);
        addEntry(object, LOADING, values, id, version, lockMode, true, persister, false);

        if ( log.isTraceEnabled() && version!=null ) log.trace("Version: " + version);
    }

		/**
		 * Returns whether the given position has been marked as reachable.
		 * 
		 * @param position  Position to be checked to be reachable.
		 * @return	<code>true</code> if position is reachable,
		 *         <code>false</code> if position isn't reachable
		 */

		final public boolean isSquareReachable(int position) {
			return boxReachableSquaresArray[position] == indicatorReachableSquare;
		}

    /**
     *	Answer a handle to the zip file currently specified as being the source.
     *	Return null if this file does not exist or is not of valid format.
     */

    private ZipFile getSpecifiedSourceFile(String fileName) {
        if (fileName.length() == 0)
            return null;

        try {
            return new ZipFile(fileName);
        } catch (ZipException e) {
           addError(DataTransferMessages.ZipImport_badFormat, e);
        } catch (IOException e) {
           addError(DataTransferMessages.ZipImport_couldNotRead, e);
        }

        return null;
    }

    /**
     * Attempts to close the passed zip file, and answers a boolean indicating success.
     */

    protected boolean closeZipFile(ZipFile file) {
        try {
            file.close();
        } catch (IOException e) {
            addError(NLS.bind(DataTransferMessages.ZipImport_couldNotClose, file.getName()), e);
            return false;
        }

        return true;
    }

	/**
	 * Initializes states of the controls from the preference store.
	 */

	private void initializeValues() {
		final IPreferenceStore store = getPreferenceStore();
		for (Iterator iter = fFields.iterator(); iter.hasNext();) {
			((Field)iter.next()).initializeValue(store);
		}
	}

   /**
	* Returns preference store that belongs to the our plugin.
	* This is important because we want to store
	* our preferences separately from the desktop.
	*
	* @return the preference store for this plugin
	*/

	protected IPreferenceStore doGetPreferenceStore() {
		return CVSUIPlugin.getPlugin().getPreferenceStore();
	}

	/**
	 * Creates an image and places it in the image registry.
	 */

	protected void createImageDescriptor(String id) {
		URL url = FileLocator.find(CVSUIPlugin.getPlugin().getBundle(), new Path(ICVSUIConstants.ICON_PATH + id), null);
		ImageDescriptor desc = ImageDescriptor.createFromURL(url);
		imageDescriptors.put(id, desc);
	}

	/**
	 * Sets the file transfer compression level. (if supported)
	 * Valid levels are: 0 (disabled), 1 (worst/fastest) - 9 (best/slowest)
	 */

	public void setCompressionLevel(int level) {
		compressionLevel = level;
	}

	/**
	 * Gets the file transfer compression level.
	 */

	public int getCompressionLevel() {
		return compressionLevel;
	}

	/**
	 * Returns the image descriptor for the given image ID.
	 * Returns null if there is no such image.
	 */

	public ImageDescriptor getImageDescriptor(String id) {
		return (ImageDescriptor)imageDescriptors.get(id);
	}

	/**
	 * Sets the default keyword substitution mode for text files.
	 */

	public void setDefaultTextKSubstOption(KSubstOption ksubst) {
		defaultTextKSubstOption = ksubst;
	}

	/**
	 * Gets the default keyword substitution mode for text files.
	 */

	public KSubstOption getDefaultTextKSubstOption() {
		return defaultTextKSubstOption;
	}

	/**
	 * Get the bug id (if exists) from the previous comment
	 * @author keren
	 * 
	 */

	private String getPreviousBugId(String string){
		if(string.startsWith(BUG_ID_INITIAL)){
			int newLineIndex = string.indexOf(LINE_SEPARATOR);
			return string.substring(BUG_ID_INITIAL.length(), newLineIndex);
		}
		return "";	
	}

	/**
	 * Should the CVS adapter prune empty directories
	 */

	public boolean getPruneEmptyDirectories() {
		return pruneEmptyDirectories;
	}

	/**
	 * Get the comment string (without the bug id text) from the previous comment
	 * @author keren
	 * 
	 */

	private String getPreviousComment(String string){
		if(string.startsWith(BUG_ID_INITIAL)){
			int newLineIndex = string.indexOf(LINE_SEPARATOR);
			return string.substring(newLineIndex+LINE_SEPARATOR.length(), string.length());
		}
		return string;		
	}

	/**
	 * Set whether the CVS adapter should prune empty directories
	 */

	public void setPruneEmptyDirectories(boolean prune) {
		pruneEmptyDirectories = prune;
	}

	/**
	 * Get the communications timeout value in seconds
	 */

	public int getTimeout() {
		return communicationsTimeout;
	}

	/**
	 * Set the timeout value for communications to a value in seconds.
	 * The value must be greater than or equal 0. If is it 0, there is no timeout.
	 */

	public void setTimeout(int timeout) {
		this.communicationsTimeout = Math.max(0, timeout);
	}

	/**
	 * Utility method that creates a label instance
	 * and sets the default layout data.
	 *
	 * @param parent  the parent for the new label
	 * @param text  the text for the new label
	 * @return the new label
	 */

	private Label createLabel(Composite parent, String text, int horizontalSpan) {
		Label label = new Label(parent, SWT.LEFT);
		label.setText(text);
		GridData data = new GridData();
		data.horizontalSpan = horizontalSpan;
		data.horizontalAlignment = GridData.FILL;
		label.setLayoutData(data);
		return label;
	}

	/**
	 * Creates an new checkbox instance and sets the default
	 * layout data.
	 *
	 * @param group  the composite in which to create the checkbox
	 * @param label  the string to set into the checkbox
	 * @return the new checkbox
	 */

	private Button createCheckBox(Composite group, String label) {
		Button button = new Button(group, SWT.CHECK | SWT.LEFT);
		button.setText(label);
		GridData data = new GridData();
		data.horizontalSpan = 2;
		button.setLayoutData(data);
		return button;
	}	

	/**
	 * Set the quietness option to use with cvs commands.
	 * Can be "", "-q" or "-Q"
	 */

	public void setQuietness(QuietOption option) {
			this.quietness = option;
	}

	/**
	 * Get the quietness option for commands
	 */

	public QuietOption getQuietness() {
		return quietness;
	}

	/**
	 * Set the console listener for commands.
	 * @param consoleListener the listener
	 */

	public void setConsoleListener(IConsoleListener consoleListener) {
	    ConsoleListeners.getInstance().addListener(consoleListener);
	}

	/**
	 * Defaults was clicked. Restore the SVN preferences to
	 * their default values
	 */

	protected void performDefaults() {
		super.performDefaults();
        initializeValues();
		
        verifyValidation();
	}

	/**
	 * Gets the cvsRshCommand.
	 * @return Returns a String
	 */

	public String getCvsRshCommand() {
		return cvsRshCommand;
	}

	/**
	 * Sets the cvsRshCommand.
	 * @param cvsRshCommand The cvsRshCommand to set
	 */

	public void setCvsRshCommand(String cvsRshCommand) {
		this.cvsRshCommand = cvsRshCommand;
	}

	/**
	 * Helper method which access the preference store to determine if the 
	 * project name from the project description file (.project) should be used
	 * as the project name on checkout.
	 */

	public boolean isUseProjectNameOnCheckout() {
		return getPreferenceStore().getBoolean(ICVSUIConstants.PREF_USE_PROJECT_NAME_ON_CHECKOUT);
	}

	/**
	 * Returns the cvsRshParameters.
	 * @return String
	 */

	public String getCvsRshParameters() {
		return cvsRshParameters;
	}

	/**
	 * Sets the cvsRshParameters.
	 * @param cvsRshParameters The cvsRshParameters to set
	 */

	public void setCvsRshParameters(String cvsRshParameters) {
		this.cvsRshParameters = cvsRshParameters;
	}

	/**
	 * Gets the cvsServer.
	 * @return Returns a String
	 */

	public String getCvsServer() {
		return cvsServer;
	}

	/**
	 * Method initializeValues.
	 */

	private void initializeValues() {
		
		// populate the previous comment list
		for (int i = 0; i < comments.length; i++) {
			previousCommentsCombo.add(flattenText(comments[i]));
		}
		
		// We don't want to have an initial selection
		// (see bug 32078: http://bugs.eclipse.org/bugs/show_bug.cgi?id=32078)
		previousCommentsCombo.setText(""); //$NON-NLS-1$
		
		if (commentProperties == null && oldComment == null) text.setText(""); //$NON-NLS-1$
		comment = text.getText();
	}

	/**
	 * Sets the cvsServer.
	 * @param cvsServer The cvsServer to set
	 */

	public void setCvsServer(String cvsServer) {
		this.cvsServer = cvsServer;
	}

	/**
	 * Method signalCtrlEnter.
	 */

	private void signalCtrlEnter() {
		firePropertyChangeChange(OK_REQUESTED, null, null);
	}

	/**
	 * Returns the comment.
	 * @return String
	 */

	public String getComment() {
		IPreferenceStore store = SVNUIPlugin.getPlugin().getPreferenceStore();
		if(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){
			if(comment.length() > 0 && bugId.length() > 0)
			comment = bugId + comment;
		}
		if (comment != null && comment.length() > 0) finished();
		if(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){
			if(comment.length() > 0 && bugId.length() == 0)
		return comment;
	}
		return comment;	
	}

	/**
	 * Gets the etchAbsentDirectories.
	 * @return Returns a boolean
	 */

	public boolean getFetchAbsentDirectories() {
		return fetchAbsentDirectories;
	}

	/**
	 * Sets the fetchAbsentDirectories.
	 * @param etchAbsentDirectories The etchAbsentDirectories to set
	 */

	public void setFetchAbsentDirectories(boolean fetchAbsentDirectories) {
		this.fetchAbsentDirectories = fetchAbsentDirectories;
	}

    /**
     * set the svn client interface
     * @param clientInterface
     */

    private void setSvnClientInterface(String clientInterface) {
        if (CmdLineClientAdapterFactory.COMMANDLINE_CLIENT.equals(clientInterface))
            clientInterface = JavaSvnClientAdapterFactory.JAVASVN_CLIENT;
        SVNProviderPlugin.getPlugin().getSVNClientManager().setSvnClientInterface(clientInterface);
    }

    /**
     * set the svn client config dir
     * @param configDir
     */

    private void setSvnClientConfigDir(String configDir) {
        SVNProviderPlugin plugin = SVNProviderPlugin.getPlugin();
        SVNClientManager svnClientManager = plugin.getSVNClientManager();
        if ("".equals(configDir)) { //$NON-NLS-1$
        	svnClientManager.setConfigDir(null);
        } else {
        	File configDirFile = new File(configDir);
            svnClientManager.setConfigDir(configDirFile);
        }
    }

		/**
		 * Gets the project.
		 * @return Returns a IProject
		 */

		public IProject getProject() {
			return project;
		}

		/**
		 * Sets the project.
		 * @param project The project to set
		 */

		public void setProject(IProject project) {
			this.project = project;
		}

	/**
	 * Gets the replaceUnmanaged.
	 * @return Returns a boolean
	 */

	public boolean isReplaceUnmanaged() {
		return replaceUnmanaged;
	}

	/**
	 * Sets the replaceUnmanaged.
	 * @param replaceUnmanaged The replaceUnmanaged to set
	 */

	public void setReplaceUnmanaged(boolean replaceUnmanaged) {
		this.replaceUnmanaged = replaceUnmanaged;
	}

	/**
	 * Register to receive notification of repository creation and disposal
	 */

	public void addRepositoryListener(ICVSListener listener) {
		KnownRepositories.getInstance().addRepositoryListener(listener);
	}

		/**
		 * Return a InstallerProject if this javaProject has the tikal Installer nature
		 * Return null if Project has not Tikal Installer nature
		 */

		static public InstallerProject create(IJavaProject javaProject) {
			InstallerProject result = null;
			try {
				InstallerProject.addTikalInstallerNature(javaProject);
				result = (InstallerProject)javaProject.getProject().getNature(InstallerPlugin.NATURE_ID);
				if(result != null)
					result.setJavaProject(javaProject);
			} catch(CoreException ex) {
				ex.printStackTrace();
			}
			return result;
		}

	/**
	 * Register to receive notification of enablement of sync info decoration requirements. This
	 * can be useful for providing lazy initialization of caches that are only required for decorating
	 * resource with CVS information.
	 */

	public void addDecoratorEnablementListener(ICVSDecoratorEnablementListener listener) {
		synchronized(decoratorEnablementListeners) {
			decoratorEnablementListeners.add(listener);
		}
	}

		/**
		 * Return a InstallerProject if this javaProject has the tikal Installer nature
		 * Return null if Project has not Tikal Installer nature
		 */

		static public InstallerProject create(IProject project) {

			IJavaProject javaProject = JavaCore.create(project);
			if(javaProject != null) {
				return InstallerProject.create(javaProject);
			} else {
				return null;
			}
		}	

    /**
     * Load the data for the object with the specified id into the supplied
     * instance. A new key will be assigned to the object. If there is an
     * existing uninitialized proxy, this will break identity equals as far
     * as the application is concerned.
     */

    private void doLoadByObject(Object object, Serializable id, LockMode lockMode) throws HibernateException {

        Class clazz = object.getClass();
        if ( getEntry(object)!=null ) throw new PersistentObjectException(
            "attempted to load into an instance that was already associated with the Session: " +
            MessageHelper.infoString(clazz, id)
        );
        Object result = doLoad(clazz, id, object, lockMode, true);
        ObjectNotFoundException.throwIfNull(result, id, clazz);
        if (result!=object) throw new NonUniqueObjectException(id, clazz);

    }

	/**
	 * Gets the determineVersionEnabled.
	 * @return boolean
	 */

	public boolean isDetermineVersionEnabled() {
		return determineVersionEnabled;
	}

	/**
	 * Sets the determineVersionEnabled.
	 * @param determineVersionEnabled The determineVersionEnabled to set
	 */

	public void setDetermineVersionEnabled(boolean determineVersionEnabled) {
		this.determineVersionEnabled = determineVersionEnabled;
	}

    /**
	 * Returns the comment.
	 * @return String
	 */

	public String getComment() {
	    if ((projectProperties != null) && (issue != null) && (issue.length() > 0)) {
	        if (projectProperties.isAppend()) 
	            return commitCommentArea.getComment() + "\n" + projectProperties.getResolvedMessage(issue) + "\n"; //$NON-NLS-1$ //$NON-NLS-2$
	        else
	            return projectProperties.getResolvedMessage(issue) + "\n" + commitCommentArea.getComment(); //$NON-NLS-1$
	    }
		return commitCommentArea.getComment();
	}

	/**
	 * Returns the fileModificationManager.
	 * @return FileModificationManager
	 */

	public FileModificationManager getFileModificationManager() {
		return fileModificationManager;
	}

	/**
	 * Sets the excludesDirs.
	 * 
	 * @param excludesDirs
	 *            The excludesDirs to set
	 */

	public void setExcludesDirs(String[] excludesDirs) {
		this.excludesDirs = excludesDirs;
	}

	/**
	 * Sets the includesDirs.
	 * 
	 * @param includesDirs
	 *            The includesDirs to set
	 */

	public void setIncludesDirs(String[] includesDirs) {
		this.includesDirs = includesDirs;
	}

	/**
	 * Compares source files to destination files to see if they should be
	 * copied.
	 * 
	 */

	private void scan(File fromDir, File toDir, String[] files, String[] toFiles) {
		FileNameMapper mapper = null;
		mapper = new IdentityMapper();
		buildMap(fromDir, toDir, files, mapper, toFiles);

	}

	/**
	 * Compares source files to destination files to see if they should be
	 * copied.
	 */

	private void scan(File fromDir, File toDir, String[] files, String[] dirs) {
		boolean flatten = false;
		FileNameMapper mapper = null;
		if (mapperElement != null) {
			mapper = mapperElement.getImplementation();
		} else if (flatten) {
			mapper = new FlatFileNameMapper();
		} else {
			mapper = new IdentityMapper();
		}
		buildMap(fromDir, toDir, files, mapper);

	}

	/**
	 * Compares source files to destination files to see if they should be
	 * copied.
	 */

	private void scan(File fromDir, File toDir, String[] files, String[] dirs) {
		FileNameMapper mapper = null;
		mapper = new IdentityMapper();
		buildMap(fromDir, toDir, files, mapper);

	}

    /**
     * sets the optional attribute
     *
     * @param optional if true ignore files that are not present,
     *                 default is false
     */

    public void setOptional(boolean optional) {
        this.optional = optional;
    }

    /**
     * the name of the file to import. How relative paths are resolved is still
     * in flux: use absolute paths for safety.
     * @param file the name of the file
     */

    public void setFile(String file) {
        // I don't think we can use File - different rules
        // for relative paths.
        this.file = file;
    }

    /**
     * The classpath to use when looking up a resource.
     * @param classpath to add to any existing classpath
     */

    public void setClasspath(Path classpath) {
        if (this.classpath == null) {
            this.classpath = classpath;
        } else {
            this.classpath.append(classpath);
        }
    }

    /**
     * The classpath to use when looking up a resource.
     */

    public Path createClasspath() {
        if (this.classpath == null) {
            this.classpath = new Path(getProject());
        }
        return this.classpath.createPath();
    }

    /**
     * the classpath to use when looking up a resource,
     * given as reference to a &lt;path&gt; defined elsewhere
     */

    public void setClasspathRef(Reference r) {
        createClasspath().setRefid(r);
    }

	/**
	 * Finds a resource with a given name. This method returns null if no
	 * resource with this name is found. The rules for searching resources
	 * are implemented by the provided
	 * {@link com.tikal.util.ClassLoadersIterationPolicy}.
	 *
	 * @param resourceName the name of the resource to find.
	 * @return a <tt>java.net.URL</tt> instance pointing to the resource, or
	 *         null if the resource wasn't found.
	 */

	public URL getResource(String resourceName) {
		URL result = null;

		while (_policy .hasNext() && result == null) {
			result = _policy.next().getResource(resourceName);
		}

		return result;
	}

	/**
	 * Loads the class with the specified name.  This method searches for
	 * classes while iterating the class-loaders that are provided by the
	 * {@link com.tikal.util.ClassLoadersIterationPolicy}.
	 *
	 * @param className the name of the class to load.
	 * @return an instance of the request class.
	 * @throws ClassNotFoundException if the class wasn't found.
	 */

	public Class loadClass(String className) throws ClassNotFoundException {
		Class result = null;

		while (_policy .hasNext() && result == null) {
			try {
				result = _policy.next().loadClass(className);
			} catch (ClassNotFoundException ignore) {
				// Ignore
			}
		}

		if (result == null) {
			throw new ClassNotFoundException(className);
		}

		return result;
	}

	/**
	 * Indicates whether or not there is a next class-loader to iterate.
	 *
	 * @return true if there's another class-loader to iterate; false otherwise.
	 */

	public boolean hasNext() {
		return _iterator.hasNext();
	}

	/**
	 * The next class-loader in the iteration.
	 *
	 * @return the next class-loader in the iteration.
	 * @throws java.util.NoSuchElementException
	 *          for no more elements.
	 */

	public ClassLoader next() {
		return (ClassLoader) _iterator.next();
	}

	/**
	 * Resets the iterator to start from the beginning.
	 */

	public void reset() {
		init();
	}

	/**
	 * Check if DEBUG level is enabled for this logger.
	 * @return true if a {@link #debug(Object)} method invocation would pass
	 *         the msg to the configured appenders; false otherwise.
	 */

	public boolean isDebugEnabled() {
		Level l = Level.DEBUG;
		if (!_log.isEnabledFor(l)) {
			return false;
		}
		return l.isGreaterOrEqual(_log.getEffectiveLevel());
	}

	/**
	 * Add a log entry with DEBUG level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 */

	public void debug(Object message) {
		_log.log(Level.DEBUG, message, null);
	}

	/**
	 * Add a log entry with DEBUG level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 * @param t a cause to append to the message
	 */

	public void debug(Object message, Throwable t) {
		_log.log(Level.DEBUG, message, t);
	}

	/**
	 * Check if INFO level is enabled for this logger.
	 * @return true if a {@link #info(Object)} method invocation would pass
	 *         the msg to the configured appenders; false otherwise.
	 */

	public boolean isInfoEnabled() {
		Level l = Level.INFO;
		if (!_log.isEnabledFor(l)) {
			return false;
		}
		return l.isGreaterOrEqual(_log.getEffectiveLevel());
	}

	/**
	 * Add a log entry with INFO level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 */

	public void info(Object message) {
		_log.log(Level.INFO, message, null);
	}

	/**
	 * Add a log entry with INFO level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 * @param t a cause to append to the message
	 */

	public void info(Object message, Throwable t) {
		_log.log(Level.INFO, message, t);
	}

	/**
	 * Add a log entry with WARN level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 */

	public void warn(Object message) {
		_log.log(Level.WARN, message, null);
	}

	/**
	 * Add a log entry with WARN level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 * @param t a cause to append to the message
	 */

	public void warn(Object message, Throwable t) {
		_log.log(Level.WARN, message, t);
	}

	/**
	 * Add a log entry with ERROR level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 */

	public void error(Object message) {
		_log.log(Level.ERROR, message, null);
	}

	/**
	 * Add a log entry with ERROR level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 * @param t a cause to append to the message
	 */

	public void error(Object message, Throwable t) {
		_log.log(Level.ERROR, message, t);
	}

	/**
	 * Add a log entry with FATAL level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 */

	public void fatal(Object message) {
		_log.log(Level.FATAL, message, null);
	}

	/**
	 * Add a log entry with FATAL level.
	 * @param message the object whoes <tt>toString</tt> method is the message
	 * @param t a cause to append to the message
	 */

	public void fatal(Object message, Throwable t) {
		_log.log(Level.FATAL, message, t);
	}

	/**
	 * Add a log entry with the given level.
	 */

	public void log(Level l, Object message) {
		_log.log(l, message, null);
	}

    /**
     * Tack the definition and return a popup definition string
     * @param target The target URL
     * @return The resulting popup text.
     */

    public String getJHObject(String target) {
        // crack the definition string.
        if (!definition.startsWith(VIEWER_TAG)) {
            logger.warn("Called with a incorrect definition: " + definition);
            return definition; // do nothing
        }
        String text = null;
        try {
            text = definition.substring(VIEWER_TAG.length());
            PopupObject popup = new PopupObject(props);
            text = popup.getJHObject(target, text);
        }
        catch (IndexOutOfBoundsException e) {
            logger.warn("Error handling definition. " + definition + " : " + e.getMessage());
            text = definition;
        }
        return text;
    }

	/**
	 * Add a log entry with the given level and caus.
	 */

	public void log(Level l, Object message, Throwable t) {
		_log.log(l, message, t);
	}

   /** Get the project name.
    * @return The project name.
    */ 

    public String getProjectName() {
        return projectName;
    }

    /**
     * Create a &lt;param&gt; line
     * @param name The param name
     * @param value The param value
     * @return String representation of the string
     */

    private String paramStr(String name, String value) {
        return "<param name=\"" + name +"\" value=\"" + value + "\">\n"; 
    }

    /**
     * Set the media location for the player.
     * 
     */

    private boolean setPlayerMediaLocation() { 
        
        String location = null;
        if (baseDoc.getBase().getProtocol() != "file")
            messages.append("Unable to handle the " + baseDoc.getBase().getProtocol() + " protocol.\r\n");
        else {
            try {
                URL linkUrl = new URL(baseDoc.getBase(), strUrl);
                location = linkUrl.toString().replaceFirst("file:/", "file://");
            }
            catch (MalformedURLException e) {
                messages.append("Couldn't form URL " + e.getMessage() + "\r\n");
            }
        }
        
        if (location != null) {
            messages.append("Media file: " + location + "\r\n");
            player.setMediaLocation(location);
            return true;
        }
        return false; // can' handle this yet
    }

    /**
     * Get the source folder.
     * @return The source folder.
     */

    public String getSourceFolder() {
        return sourceFolder;
    }

    /**
     * Set the source folder.
     * @param sourceFolder The new source folder.
     */

    public void setSourceFolder(String sourceFolder) {
        this.sourceFolder = sourceFolder;
    }

    /** 
     * Get the parent part of the url
     * @param url The URL to work on
     * @return The parent, including the last /
     */

    private String getParent(URL url) {
        int end = url.getPath().lastIndexOf("/");
        if (end >= 0)
            return url.getPath().substring(0, end + 1);
        else
            return url.getPath();  
    }

    /**
     * Get the project name.
     * @return The name of the project.
     */

    public String getTargetFolder() {
        return targetFolder;
    }

    /**
     * Overide of setView so we can get information about the view.
     */

    public void setViewData(View view) {
        baseDoc = (HTMLDocument)view.getDocument();
        super.setViewData(view);
    }

    /**
     * Get the source name.
     * @return The name of the source file.
     */

    public String getSourceName() {
        return sourceName;
    }

    /**
     * Create a temporary object.
     * @param url URL to create object for.
     */

    private void createTempObject(String url) {
        // File fin = new File();
    }

    /**
     * Set the name of the new source file.
     * @param sourceName The name of the source file.  This is the absolute file path.
     */

    public void setSourceName(String sourceName) {
        this.sourceName = sourceName;
    }

    /** 
     * Called when item is clicked 
     * @param event The calling event.
     */

    public void actionPerformed(ActionEvent event) {
        strUrl = this.getContent();
        if (jd == null)
            createDialog();
        showVideo();
    }

    /**
     * Is file acceptable.
     * @param f The file.
     * @return True if acceptable.
     */

    public boolean accept(File f) { 
        if (f.isDirectory())
            return true;
        String ext = FileManager.getExtension(f);
        return (ext.equals(".hhp"));
    }

    /**
     * Get a description string.
     * @return The description
     */

    public String getDescription() {
        return ("hhp - HTML Help project files");
    }

    /**
     * Build the presentation dialog
     */

    private void createDialog() {
        // set up the messages area
        jd = new JDialog();
        contentPane = jd.getContentPane();

        messages = new JTextArea();
        messages.setLineWrap(true);
        messages.setWrapStyleWord(true);
        messages.setEditable(false);
        messagePanel = new JScrollPane();
        
        messagePanel.setOpaque(false);
        messagePanel.setRequestFocusEnabled(false);
        messagePanel.setPreferredSize(new java.awt.Dimension(400, 200));
        messagePanel.setViewportView(messages);
        contentPane.add(messagePanel, BorderLayout.NORTH);
        northComponent = messagePanel;
        
        jd.pack();
        jd.show();
        jd.requestFocusInWindow();        
    }

    /**
     * Centre the frame.
     */

    private void centre() {
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension winSize = getSize();
        setLocation((screen.width - winSize.width)/2, (screen.height - winSize.height)/2);
    }

        /**
         * Handle the realizeComplete event.
         * @param event The state change event.
         */

        public void realizeComplete(RealizeCompleteEvent event) {
            Component vc = player.getVisualComponent();
            messagePanel.setVisible(false);
           
            if (vc != null) {
                contentPane.add(vc,BorderLayout.CENTER);
                centerComponent = vc;
            } else {
                if (centerComponent != null) {
                    contentPane.remove(centerComponent);
                    contentPane.validate();
                }
            }
            Component cpc = player.getControlPanelComponent();
            if (cpc != null) {
                contentPane.add(cpc, BorderLayout.SOUTH);
                southComponent = cpc;
            } else {
                if (southComponent != null) {
                    contentPane.remove(southComponent);
                    contentPane.validate();
                }
            }
            jd.addWindowListener(new WindowHandler());
            jd.pack();
            jd.setTitle(strUrl);
            jd.show();           
        }

    /**
     * Set the text in the licence area
     */

    private void setLicenceText() {
        URL url = getClass().getResource("/resources/licence.html");
        try {
            informationArea.setPage(url);
        }
        catch (IOException e) {
            informationArea.setText("Unable to open licence page. This program is copyrighted.  Please do not use and re-install.");
        }
    }

    /**
     * Display the window.
     */

    public void display() {
        setLicenceText();
        pack();
        centre();
        setVisible(true); 
        toFront();
        
    }

        /**
         * Stop the player when closing the window and reset the error stream.
         */

        public void windowClosing(WindowEvent e) {
            if (player != null) {
                player.stopAndDeallocate();
                player.close();
            }
            
            jd.dispose();
        }

    /**
     * Initialise the application and show the main window.
     */

    public void init() {
        logger.debug("Initialise the application.");
        configProps = new PropertyManager("configuration.properties");
        window = new MainFrame(this);
        window.pack();
        window.setVisible(true);   
    }

    /**
     * Used to close the Appender and called by the log4J framework.
     */

    public void close() {
        // nothing to do
    }

    /** Get the default source file
     * @return The default helpset file name.
     */

    public String getDefaultSource() {
        return configProps.getProperty("defaultSource", "");
    }

        /**
         * Will be called every time a namespace is reached.
         * It'll verify if the ns was processed, and if not load the task
         * definitions.
         * @param uri The namespace uri.
         */

        protected void checkNamespace(String uri) {

        }

    /**
     * Tell the log4J framework whether or not a Layout is required.
     * @return Always true
     */

    public boolean requiresLayout() {
        return true;
    }

    /** Set the default source file
     * @param defaultSource The name iof the Helpset file.
     */

    public void setDefaultSource(String defaultSource) {
        configProps.setProperty("defaultSource", defaultSource);
    }

    /**
     * Append the text to the text area.
     * @param event The Logging event from the log4J framework.
     */

    public void append(LoggingEvent event) {
        if (textArea != null) {
            Level level = event.getLevel();
            if (level == Level.FATAL)
                textArea.append("[FATAL] ");
            else if (level == Level.WARN)
                textArea.append("[WARN] ");
            else if (level == Level.INFO)
                textArea.append("[INFO] ");
            else if (level == Level.DEBUG)
                textArea.append("[DEBUG] ");
            else 
                textArea.append("[----] ");
            
            textArea.append(event.getRenderedMessage());
            textArea.append("\n");
            
        }
    }

    /**
     * Get the default target as set in the configuration properties.
     * @return The default target.
     */

    public String getDefaultTarget() {
        return configProps.getProperty("defaultTarget", "");
    }

    /**
     * Set the JTextArea to be used to receive the logging commands.
     * @param argTextArea The JTextArea used by the appender.
     */

    public void setTextArea(JTextArea argTextArea) {
        textArea = argTextArea;
    }

    /** Save the default configurations to the property file.
     */

    public void saveConfig() {
        logger.debug("Save the configuration properties.");
        configProps.store();
    }

    /**
      * Copy file routine.  
      * Original source from R�al Gagnon http://64.18.163.122/rgagnon/howto.html
      * @param in Input file
      * @param out Destination file
      * @throws java.lang.Exception Exeption thrown on IO error
      */ 

     static public void copyFile(File in, File out) throws Exception {
        FileInputStream fis  = new FileInputStream(in);
        FileOutputStream fos = new FileOutputStream(out);
        byte[] buf = new byte[1024];
        int i = 0;
        while((i=fis.read(buf))!=-1) {
            fos.write(buf, 0, i);
        }
        fis.close();
        fos.close();
    }

        /**
         * Returns the current ant handler object.
         * @return the current ant handler.
         */

        public AntHandler getCurrentAntHandler() {
            return currentHandler;
        }

     /**
      * Make sure the path is absolute.
      * If the path is absolute, just returns it unchanged.
      * If it's relative, then it is combined with the default directory.
      * @param defaultDir the default directory,
      * @param currentPath the path to check.
      * @return the absolute path.
      */

     static public String makeAbsolute(String currentPath, String defaultDir) {
         File file = new File(currentPath);
         if (file.isAbsolute())
             return currentPath;
         else
             return combine(defaultDir, file.getName());
     }

     /**
      * Build a path from the path, filename and extension.
      * @param dir Directory
      * @param fileName The file name
      * @param ext the extension
      * @return The complete path
      */

     static public String buildPath(String dir, String fileName, String ext) {
         return combine(dir, fileName + ext);
     }

    /** Get the language code for XMML type files.
     * @param encType the encoding type
     * @return language. Empty string if not found
     */

    public String getLanguage(int encType) {
        if (encType == INDEX) {
            return m_props.getProperty("index_lang", "en");
        }
        else if (encType == MAP) {
            return m_props.getProperty("map_lang", "en");
        }
        else if (encType == TOC) {
            return m_props.getProperty("toc_lang", "en");
        }
        else if (encType == HS) {
            return m_props.getProperty("hs_lang", "en");
        }        
        return "en";
    }

    /**
     * Change directory of an absolute file path.
     * @param path The path to amend.
     * @param newDir The directory to change the path to.
     * @return The new path.
     */

    static public String changeDirectory(String path, String newDir) {
        String fileName = "";
        try {
            File file = new File(path);
            fileName = file.getName();
        }
        catch (NullPointerException e) {
            // okay
        }
        
        return combine(newDir, fileName);
    }

    /**
     * Get the directory part of the name
     * @param path The path to analyse.
     * @return The path's directory.
     */

    static public String getDirectory(String path) {
        String dir = path;
        try {
            File file = new File(path);
            dir = file.getParent();
        }
        catch (NullPointerException e) {
            // okay
        }
        return dir;
    }

    /** Get the input encoding type. 
     * @param encType the type of encoding
     * @return the encoding to use
     */

    public String getInputEncoding(int encType) {
        if (encType == HTML) {
            return m_props.getProperty("html_in", "UTF-8");
        }
        else if (encType == CSS) {
            return m_props.getProperty("css_in", "UTF-8");
        }
        else if (encType == HPP) {
            return m_props.getProperty("hpp_in", "UTF-8");
        }
        else if (encType == JS) {
            return m_props.getProperty("js_in", "UTF-8");
        }
        else if (encType == HCC) {
            return m_props.getProperty("hcc_in", "UTF-8");
        }
        m_logger.warn("Attempted to get input encoding for unrecognised encoding type.");
        return "UTF-8";
    }

    /**
     * Get the file name of the path.
     * @param path The absolute path.
     * @return The file name part.
     */

    static public String getName(String path) {
        String name = path;
        try {
            File file = new File(path);
            name = file.getName();
        }
        catch (NullPointerException e) {
            // okay
        }
        return name;
        
    }

    /** Convert JTidy encoding to the JTidy R7 code.
     * @param enc the name
     * @return the R7 code
     */

    public int getEncodingJTidyR7(String enc) {
        if (enc.equalsIgnoreCase("ASCII")) {
            return org.w3c.tidy.Configuration.ASCII;
        }
        else if (enc.equalsIgnoreCase("ISO2022")) {
            return org.w3c.tidy.Configuration.ISO2022;
        }
        else if (enc.equalsIgnoreCase("LATIN1")) {
            return org.w3c.tidy.Configuration.LATIN1;
        }
        else if (enc.equalsIgnoreCase("MACROMAN")) {
            return org.w3c.tidy.Configuration.MACROMAN;
        }
        else if (enc.equalsIgnoreCase("RAW")) {
            return org.w3c.tidy.Configuration.RAW;
        }
        else if (enc.equalsIgnoreCase("UTF8")) {
            return org.w3c.tidy.Configuration.UTF8;
        }
        else {
            return org.w3c.tidy.Configuration.UTF8;
        }
    
    }

    /**
     * Get the file extension.
     * @param f The file.
     * @return The extension including the decimal point.
     */

    static public String getExtension(File f) {
        return getExtension(f.getPath());
    }

    /**
     * Get the file extension.
     * @param path The file.
     * @return The extension including the decimal point.
     */

    static public String getExtension(String path) {
        int extStart = path.lastIndexOf(".");
        if (extStart >= 0)
            return path.substring(extStart).toLowerCase();
        else
            return "";  
    }

    /**
     * Take a full path and change the extension
     * @param path The path.
     * @param newExtension The new extension
     * @return The new path.
     */

    static public String changeExtension(String path, String newExtension) {
        String retStr;
        int extStart = path.lastIndexOf(".");
        if (extStart >= 0)
            retStr = path.substring(0, extStart);
        else
            retStr = path;
        if (newExtension.length() > 0) 
            retStr += (newExtension.charAt(0) == '.' ? newExtension : "." + newExtension);
        return retStr;
    }

    /** 
     * Check whether the path name exists and is a directory
     * @param name The path.
     * @return true if okay
     */

    static public boolean isExistingDirectory(String name) {
        File file = new File(name);
        return file != null && file.exists() && file.isDirectory();
    }

    /** create a buffered file reader suitable for the requested encoding. 
     * @param inname The file name.
     * @param encType the type of encoding to use
     * @return the buffered writer
     */

    public BufferedReader getBufferedFileReader(String inname, int encType) throws java.io.FileNotFoundException {
        String enc = getInputEncoding(encType);
        boolean encodingValid = false;
        try {
            encodingValid = Charset.isSupported(enc);
        }
        catch (Exception e) {
            m_logger.warn("Unable to use encoding " + enc + ".  " + e.getMessage());
        }
        if (encodingValid) {
            m_logger.info("Reader created with encoding " + enc);
            return new BufferedReader(new InputStreamReader(new FileInputStream(inname), Charset.forName(enc)));
        }
        else {
            return new BufferedReader(new InputStreamReader(new FileInputStream(inname)));
        }
    }

    /** 
     * Check whether the path name exists and is a file
     * @param name The path.
     * @return true if okay
     */

    static public boolean isExistingFile(String name) {
        File file = new File(name);
        return file != null && file.exists() && file.isFile();
    }

    /** create a buffered stream reader suitable for the requested encoding. 
     * @param in The input stream.
     * @param encType the type of encoding to use
     * @return the buffered writer
     */

    public BufferedReader getBufferedReader(InputStream in, int encType) {
        String enc = getInputEncoding(encType);
        boolean encodingValid = false;
        try {
            encodingValid = Charset.isSupported(enc);
        }
        catch (Exception e) {
            m_logger.warn("Unable to use encoding " + enc + ".  " + e.getMessage());
        }
        if (encodingValid) {
            m_logger.info("Reader created with encoding " + enc);
            return new BufferedReader(new InputStreamReader(in, Charset.forName(enc)));
        }
        else {
            return new BufferedReader(new InputStreamReader(in));
        }
    }

    /**
     * Parse the node
     * Only actually handles <a> or <script> nodes.
     * @param doc The calling document
     * @param node The node to parse
     * @return null if not handled, else replacement text.
     */               

    public String parse(HTMLDoc doc, Node node) {
        if (node.getNodeName().equals("a"))
            return parseAnchor(doc, node);
        else if (node.getNodeName().equals("script"))
            return parseScript(doc, node);
        
        return null;
            
    }

    /** Convert a file name to a url string.
     * @param name the file name
     * @return the string representation of a uri.
     */

    static public String toUri(String name) {
        File file = new File(name);
        String uri;
        // Convert the file object to a URL
        URL url = null;
        try {
            // The file need not exist. It is made into an absolute path
            // by prefixing the current working directory
            url = file.toURL();          // file:/d:/almanac1.4/java.io/filename
            uri = url.toString();
        } 
        catch (MalformedURLException e) {
            uri = "";
        }
        return uri;
    }

    /**
     * Perform the parsing task.
     * @return True if okay.
     */

    public boolean run() {
        return true;
    }

   /**
    * Create a header using Logger.info.
    * @param header Text to put in the header.
    */

   protected void logRunHeader(String header) {
        logger.info(header);
        logger.info("Source name: " + sourceName);
        logger.info("Target folder: " + project.getTargetFolder());
    }

    /**
     * Create a footer using the Logger.info.
     */

    protected void logRunFooter() {
        // do nothing
    }

        /**
         * Sets the locator in the project helper for future reference.
         *
         * @param locator The locator used by the parser.
         *                Will not be <code>null</code>.
         */

        public void setDocumentLocator(Locator locator) {
            context.setLocator(locator);
        }

    /**
     * Write the HTML for the popup to a file
     * @return true if okay
     * @param targetName The target file.
     * @param text The popup text
     * @param source The source file.
     */ 

    private boolean createHTMLFile(String text, String targetName, String source) {
        String htmlOut = "<html><head><title>popup</title></head><body>" + text + "</body></html>";
        ByteArrayInputStream in = new ByteArrayInputStream(htmlOut.getBytes());
        ParserHTML parser = new ParserHTML(project, source); 
        return parser.run((InputStream)in, targetName);
    }

    /**
     * Create a Logger.info message including the current 
     * line number of the parsed file.
     * @param message Message to write.
     */

    protected void logMessageAtLine(String message) {
        logger.info("Line " + lineNumber + ": " + message);
    }

    /**
     * Create a Logger.warn message including the current 
     * line number of the parsed file.
     * @param message The message to write.
     */

    protected void logWarningAtLine(String message) {
        logger.warn("Line " + lineNumber + ": " + message);
    }

    /**
     * Extract the popup id name from the string
     * @param text The string to search
     * @return The id name.  Null if not found              
     */     

    private String getPopupIdName(String text) {
        int start;
        int end;
        try {
            start = text.indexOf(popupSignature);
            end = start + popupSignature.length();
            
            while (CharUtility.isAsciiVariable(text.charAt(end)) ) {
                end++;
            }
        }
        catch (IndexOutOfBoundsException e) {
            logger.warn("Could not decode popup id from " + text);
            return null;
        }
        if (start >= 0 && end > start) 
            return text.substring(start, end);
        return null;
        
    }

    /**
     * Start the fie parse.  Creates a reader to access
     * the file.
     * @param encType the type of input encoding
     * @return True if okay.
     */

    protected boolean startReader(int encType) {
        boolean bOkay = true;
        reader = null;
        lineNumber = 0;
        try {
            // reader = new BufferedReader(new FileReader(sourceName));
            reader = EncodingManager.getInstance().getBufferedFileReader(sourceName, encType);
        }
        catch(FileNotFoundException e) {
            logger.warn("Cannot open file " + sourceName + ": " + e.toString());
            
            bOkay = false;
        }
        return bOkay;
    }

    /**
     * Process the source file creating a list of popup ids
     * @param name The source file
     */

    private void processSource(String name) {
        if (sourceFiles.contains(name)) {
            logger.debug("Already handled " + name);
            return;
        }

        sourceFiles.add(name);
        
        File f = new File(name);
        String line;
        boolean processing = true;
        while (processing) {
            processing = false;
        }
    
    }

    /**
     * Read the next line from the source.
     * @return The line.  Null if EOF.
     */

    protected String getLine() {
        String retLine = null;
        try {
            retLine = reader.readLine();
            lineNumber++;
        }
        
        catch (IOException e) {
            logger.warn("IO error reading " + sourceName + "at line " + lineNumber + ": " + e.toString());
            
        }
        return retLine;
    }

    /**
     * Handle assignments,i.e lines of the form 
     * key=value
     * @param line The line to assess.
     */

    private void handleAssignments(String line) {
        String[] elements = line.split("=");
        if (elements.length > 1) {
            String attribute = elements[0].trim().toUpperCase();
            String value = elements[1].trim();
            if (attribute.equals("TITLE")) {
                title = value;
                logger.debug("Set attribute " + attribute + " to " + value );
            } 
            else if (attribute.equals("INDEX FILE")) {
                indexName = value;
                logger.debug("Set attribute " + attribute + " to " + value );
            }
            else if (attribute.equals("CONTENTS FILE")) {
                contentsName = value;
                logger.debug("Set attribute " + attribute + " to " + value);
            }
            else if (attribute.equals("DEFAULT TOPIC")) {
                defaultTopic = value;
                logger.debug("Set attribute " + attribute + " to " + value);
            }
        }
    }

    /**
     * Set the map used for resolving IDs and urls.
     * @param argMap The map to use.  URL is key, id is the value.
     */

    public void setMap(HashMap argMap) {
        map = argMap;
    }

    /**
     * Get the name of the index file.
     * @return The index name.
     */

    public String getIndexName() {
        return indexName;
    }

        /**
         * Handles the end of an element. Any required clean-up is performed
         * by the onEndElement() method and then the original handler
         * is restored to the parser.
         *
         * @param uri  The namespace URI for this element.
         * @param name The name of the element which is ending.
         *             Will not be <code>null</code>.
         * @param qName The qualified name for this element.
         *
         * @exception SAXException in case of error (not thrown in
         *                         this implementation)
         *
         */

        public void endElement(String uri, String name, String qName) throws SAXException {
            currentHandler.onEndElement(uri, name, context);
            AntHandler prev = (AntHandler) antHandlers.pop();
            currentHandler = prev;
            if (currentHandler != null) {
                currentHandler.onEndChild(uri, name, qName, context);
            }
        }

    /**
     * Build the map section
     * @param doc The document to contain the map section.
     */

    public void buildMap(XMLDoc doc) {
        org.w3c.dom.Node node;
        org.w3c.dom.Element element;
        element = doc.addElement(null, "maps");
        doc.addElement((org.w3c.dom.Node)element, "homeID", defaultTopicId);
        element = doc.addElement((org.w3c.dom.Node)element, "mapref");
        doc.setAttribute(element, "location", project.getProjectName() + ".jhm");
    }

    /**
     * Get the first quoted element of text.
     * The quotes are removed.
     * @return The text in the quotes.  Escape sequences are unescaped.
     * @param text The text to handle.
     * @param toHTML if true then escape sequences are converted to HTML else to characters
     */

    public String getQuotedText(String text, boolean toHTML) {
        StringBuffer out = new StringBuffer(100);
        int end = text.length();
        try {
            int start = text.indexOf('\"');
            start++;
            while (start < end) {
                if (text.charAt(start) == '\"')
                    break;
                if (text.charAt(start) == '\\')
                    out.append(unescape(text.charAt(++start), toHTML));
                else
                    out.append(text.charAt(start));
                start++;
            }
        }
        catch (IndexOutOfBoundsException e) {
            logger.warn("Error finding javascript quoted line: " + e.getMessage());
            return null;
        }
        return out.toString();
    }

    /**
     * Get the name of the contents file.
     * @return The contents name.
     */

    public String getContentsName() {
        return contentsName;
    }

    /**
     * Unescape special javascript characters
     * @return The text.  Null on error.
     * @param esc The character that was found after the escape character.
     * @param toHTML If true then unescape to HTML equivalent else just to ascii equivalent.
     */

    private String unescape(char esc, boolean toHTML) {
        if (esc == 'n')
            return toHTML ? "<br>" : "\n";
        else if (esc == 'r')
            return toHTML ? "" : "\r"; // ignored as only handle \n
        else if (esc == 't')
            return toHTML ? "&nbsp;&nbsp;&nbsp;&nbsp;" : "\r";
        else if (esc == '\\')
            return "\\";
        else if (esc == 'f')
            return toHTML ? "<hr>" : "\f";
        else if (esc == '\'')
            return "\'";
        else if (esc == '\"')
            return "\"";
        else
            return String.valueOf(esc); // ignore the escaping
    }

    /**
     * Create a view section.
     * @param doc The document to contain the view.
     * @param merge The mergetype attribute.
     * @param name The name attribute.
     * @param label The label attribute.
     * @param typeName The type attribute.
     * @param data The data attribute.
     */

    public void buildView(XMLDoc doc, String merge, String name, String label, String typeName, String data ) {
        org.w3c.dom.Node node;
        org.w3c.dom.Element element;
        
        element = doc.addElement(null, "view");
     
        doc.setAttribute(element, "xml:lang", EncodingManager.getInstance().getLanguage(EncodingManager.HS));
        doc.setAttribute(element, "mergetype", merge);
        doc.addElement((org.w3c.dom.Node)element, "name", name);
        doc.addElement((org.w3c.dom.Node)element, "label", label);
        doc.addElement((org.w3c.dom.Node)element, "type", typeName);
        doc.addElement((org.w3c.dom.Node)element, "data", data);
      
        
    }

    /**
     * Get the title of the help.
     * @return The title.
     */

    public String getTitle() {
        return title;
    }

    /**
     * Get a map of the links in the html files.
     * @return The map of links.
     */

    public HashMap getLinks() {
        return links;
    }

    /**
     * Get the default topic url.
     * @return The url.
     */

    public String getDefaultTopic() {
        return defaultTopic;
    }

    /**
     * Set the default topic.
     * @param id The topic id.
     */

    public void setDefaultTopicId(String id) {
        defaultTopicId = id;
    }

    /**
     * Get the default topic id.
     * @return The default topic id.
     */

    public String getDefaultTopicId() {
        return defaultTopicId;
    }

    /**
     * Get a map of the parsed HTML files.
     * @return The parsed HTML files.
     */

    public HashSet getHtmlFiles() {
        return htmlFiles;
    }

    /**
     * Write the document to the writer.
     * @param writer The Buffered writer to which the output is sent.
     * @throws java.io.IOException IOExceptions thrown.
     * @return True if successfully written.  False if the document has not been parsed.
     */

    public boolean write(BufferedWriter writer) throws IOException {
        logger.debug("Writing the HTMLDoc to file.");
        if (htmlDoc == null) {
            logger.warn("Attempt to write a null XML document.");
            return false;
        }
        // writer.write("<?xml version='1.0' encoding='ISO-8859-1' ?>");
        writer.write(NEW_LINE);
        writer.write(getDocTypeString());
        String rawText = getDocumentNode(htmlDoc.getDocumentElement(), " ");
        writer.write(replaceText(rawText));
        return true;
    }

    /**
     * Sets the map that contains the target references.
     * Note the key is the url and the value is the id.
     * @param argLinks The map containing targets to ids.
     */

    public  void setLinks(HashMap argLinks) {
        links = argLinks;
    }

    /**
     * Get the file name of the helpset.
     * @return The file name.
     */

    public String getFileName() {
        return fileName;
    }

     /**
      * Perform the actual build of the document.
      * @param doc The document to build.
      */

     private void buildDocument(XMLDoc doc) {
        org.w3c.dom.Node node;
        org.w3c.dom.Element element;
        doc.setAttribute(null, "version", "2.0");
        doc.setAttribute(null, "xml:lang", EncodingManager.getInstance().getLanguage(EncodingManager.MAP));
        doc.addComment(null, "Map IDs");

        // iterate through the map adding the links
        Set set = links.entrySet();
        Iterator it = set.iterator();
        while (it.hasNext()) {
            Map.Entry ent = (Map.Entry)it.next();
            String target = (String)ent.getValue();
            String url = (String)ent.getKey();
            addID(doc, target, url);
        }
    }

    /**
     * Perform parsing on the input source.
     * The source is taken as the parser's source file
     * @return True if successful
     */

    public boolean run() {
        logRunHeader("Parsing css file.");
        FileInputStream in = null;

        try {
            in = new FileInputStream(sourceName);
        }
        catch (FileNotFoundException e) {
            logger.warn("Error reading css file: " + e.getMessage());
            return false;
        }
       
        return run(in, sourceName);
    }

     /**
      * Add a mpaID to the document.
      * @param doc The XMLDoc to which the ID should be added.
      * @param target The value of the target attribute.
      * @param url The value of the url attribute.
      */

     private void addID(XMLDoc doc, String target, String url) {
        org.w3c.dom.Element element;
        element = doc.addElement(null, "mapID");
        doc.setAttribute(element, "target", target);
        doc.setAttribute(element, "url", url); 
     }

        /**
         * Start a namespace prefix to uri mapping
         *
         * @param prefix the namespace prefix
         * @param uri the namespace uri
         */

        public void startPrefixMapping(String prefix, String uri) {
            context.startPrefixMapping(prefix, uri);
        }

    /**
     * Perform parsing on the input source.
     * The source is taken as the parser's source file
     * @return True if successful
     */

    public boolean run() {
        logRunHeader("Parsing HTML file.");
        FileInputStream in = null;

        try {
            in = new FileInputStream(sourceName);
        }
        catch (FileNotFoundException e) {
            logger.warn("Error reading HTML file: " + e.getMessage());
            return false;
        }
       
        return run(in, sourceName);
        
        
    }

    /**
     * Replace quotation marks with &quote;
     * @param str The string in which to replace the quotes.
     * @return The string with the quotes replaced.
     */

    public String replaceQuotes(String str) {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == QUOTE) 
                buf.append(QUOTE_ENTITY);
            else
                buf.append(str.charAt(i));
        }
        return buf.toString();
    } 

    /**
     * Copy a image file to the target.
     * @param image The name of the image.
     */

    private void copyImageFile(String image) {
        File fin =new File(FileManager.buildPath(sourceFolder, image, ""));
        File fout = new File(FileManager.buildPath(project.getTargetFolder(), image, ""));
        if (!fin.exists()) 
            logger.warn("Image " + fin.getPath() + "does not exist.");
        else {
            logger.info("Copy " + fin.getPath() + " to " + fout.getPath());
            try {
                FileManager.copyFile(fin, fout);
            }
            catch (Exception e) {
                logger.warn("Error copying files. " + e.toString());
            }
        }
    }

    /**
     * Replace an element with the text found in the replaceElements Properties.
     * @param node The current node of the element.
     * @return The replacement string.  Null if not found.
     */

    private String replaceElement(org.w3c.dom.Node node) {
        String nodeName = node.getNodeName();
        // handle any popup information
        String popup = popupParser.parse(this, node); 
        if (popup != null)
            return popup;
        
        if (nodeName.equals("object")) {
            return objectParser.parse(this, node);
        }
        else if (nodeName.equals("embed")) {
            objectParser.handleEmbed(this, node);
        }
        
        if (replaceElements == null)
            return null;
        return replaceElements.getProperty(nodeName);
    }

    /**
     * Create an index item in the xml document.
     * @param parentIndexItem The item to which this node belongs.
     */

    private void createFullIndexItem(org.w3c.dom.Element parentIndexItem) {
        if (!skipElement(currentIndexItem, currentName)) {
            currentIndexItem = xmlDoc.addElement(parentIndexItem, "indexitem");
            xmlDoc.setAttribute(currentIndexItem, "text", currentName);
            String mapID = (String)map.get(currentTarget);
            if (mapID == null) {
                // couldn't find the mapID
                mapID = handleUnknownTarget(currentTarget);
            }
            xmlDoc.setAttribute(currentIndexItem, "target", mapID);
        }
    }

        /**
         * End a namepace prefix to uri mapping
         *
         * @param prefix the prefix that is not mapped anymore
         */

        public void endPrefixMapping(String prefix) {
            context.endPrefixMapping(prefix);
        }

    /**
     * Handle the situation where the target url is not found
     * @param url The target that couldn't be found.
     * @return The mapID.  Null if none.
     */

    private String handleUnknownTarget(String url) {
        String id = null;
        logger.debug("Unknown target " + url);
        String[] parts = url.split("#");
        if (parts.length > 1) {
            logger.debug("Anchor so add to map.");
            id = (String)map.get(parts[0]);
            if (id != null) {
                // okay the target document does exist so we can add the anchor
                id = id + "#" + parts[1] + "_"; // form a new map id
                map.put(url, id);
            }
            else
                logger.warn("Anchor to missing target file found. " + url);
        }
        
        return id;
    }

    /** 
     * Replace text in the string using replacements found in the replaceText Properties.
     * @param str The string to be processed.
     * @return The string with all the replacements made.
     */

    private String replaceText(String str) {
        return TextReplacer.replaceText(replaceText, str);
    }

    /**
     * Create a targetless index item in the xml document.
     * @param parentIndexItem The item to which this node belongs.
     */

    private void createTargetlessIndexItem(org.w3c.dom.Element parentIndexItem) {
        if (!skipElement(currentIndexItem, currentName)) {
            currentIndexItem = xmlDoc.addElement(parentIndexItem, "indexitem");
            xmlDoc.setAttribute(currentIndexItem, "text", currentName);
        }
    }

    /** 
     * Handle the embed tag which contains the source.
     * Note if not in an object, this is ignored
     * @param doc The html dom.
     * @param node The current node
     */

    public void handleEmbed(HTMLDoc doc, Node node) {
       if (currentNode != null) {
           source = doc.getAttribute(node, "src");
       } 
    }

    /**
     * Extract link and popup text using the classID
     * @param classID The classID attribute of the object
     * @return Get the text that should be used for the link that replaces the object.
     */

    private String getLinkText(String classID) {
        if (classID == null) 
            return "";
        String classText = null;
        
        classText = props.getProperty(classID, props.getProperty("unknownClass", "Unknown object.  Not supported in JavaHelp"));
        if (source == null)
           return classText;
        
        if (classText.startsWith(PopupSecondaryViewer.VIEWER_TAG)) {
            PopupSecondaryViewer sv = new PopupSecondaryViewer(props, classText.replace("__SOURCE__", source));
            return sv.getJHObject(source);
        }
        else
            return classText.replace("__SOURCE__", source);
    }

    /**
     * Called before converting any element to a string.
     * Determines whether the element and it children need to be wrapped in an enclosing element.
     * Outputs tags to wrap the element and determines the necessary tag to finish the wrapping.
     * @param node The element to process.
     * @param nodeStr The buffer to which the wrapping tag is appended.
     * @return The end of the wrapper which the caller is responsible for adding to the output after
     * processing the element.
     */

    private String handleWrapperTag(org.w3c.dom.Node node, StringBuffer nodeStr) {
        String endWrapper = "";
        if (node.getNodeName().equals("table")) {
            String color = getAttribute(node, "bgcolor");
            if (color != null) {
                nodeStr.append("<div style=\"background-color:" +  color + "\">\n");
                endWrapper = "</div>\n";
            }
        }
        return endWrapper;
    }

    /** Get a string representation of the DocType.
     * @return The doctype string.
     */

    public String getDocTypeString() {
        StringBuffer buffer = new StringBuffer(1000);
        String str;
        buffer.append("<!DOCTYPE ");
        buffer.append(docType.getName());
        if ((str = docType.getSystemId()) != null)
            buffer.append("\n   SYSTEM \"" + str + "\"");
        if ((str = docType.getPublicId()) != null)
            buffer.append("\n   PUBLIC \"" + str + "\"");
        if ((str = docType.getInternalSubset()) != null)
            buffer.append("\n   [" + str + "]");
        if (namespace != null)
            buffer.append("\n   \"" + namespace + "\"");
        
        buffer.append(">\n");
        return buffer.toString();
        
    }

    /** Provides a string representation of additional children for a node.
     * @param node the node for which there might be special children
     * @return html for the extra children
     */

    private String additionalChildren(org.w3c.dom.Node node) {
        if (node.getNodeName().equals("head")) {
            // we need to put the encoding string at the top or JavaHelp seems to ignore it.
            return EncodingManager.getInstance().getEncodingTag(EncodingManager.HTML) + "\n";
        }
        return "";
    } 

    /**
     * Check to see if this is a duplicated node.
     * This is used because of the difference in structure of the HMTL index and JavaHelp
     * index. If the text attribute of this node is the same as the text attribute of the 
     * previous node, it should be skipped.
     * @returns True if the previous elements text attibute equals text.
     * @param prev The previous element.
     * @param text The current elements text attribute
     * @return True if the element and its children should be skipped.
     */

    private boolean skipElement(org.w3c.dom.Element prev, String text) {
        String oldText = xmlDoc.getAttribute(prev, "text");
        if (oldText == null)
            return false;
        return oldText.equals(text);
    }

    /**
     * Write the document to an output writer.
     * @param writer The destination.
     * @param tag the xml start line to write
     * @throws java.io.IOException Exception thrown on io error.
     * @return True if okay.
     */

    public boolean write(BufferedWriter writer, String tag) throws IOException {
        if (doc == null) {
            logger.warn("Attempt to write a null XML document.");
            return false;
        }
        writer.write(tag);
        writer.write(NEW_LINE);
        writer.write(getDocTypeString());
        writer.write(getDocumentNode(doc.getDocumentElement(), ""));
        return true;
    }

    /**
     * Get the map.
     * @return The map used for resolving targets.
     */

    public HashMap getMap() {
        return map;
    }

    /**
     * Replace quotes in the string.
     * @param str The string to replace the quotes./
     * @return String with quotes replaced with &amp;quote;  If str is null an empty string is returned.
     */

    public String replaceQuotes(String str) {
        if (str == null) {
            return "";
        }
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == QUOTE) 
                buf.append(QUOTE_ENTITY);
            else
                buf.append(str.charAt(i));
        }
        return buf.toString();
    }

        /**
         * Handle the end of the project, sets the current target of the
         * context to be the implicit target.
         *
         * @param uri The namespace URI of the element.
         * @param tag The name of the element.
         * @param context The current context.
         */

        public void onEndElement(String uri, String tag, AntXMLContext context) {
            context.setCurrentTarget(context.getImplicitTarget());
        }

        /**
         * Handles the end of the element. This pops the wrapper from
         * the context.
         *
         * @param uri The namespace URI for the element.
         * @param tag The name of the element.
         * @param context The current context.
         */

        public void onEndElement(String uri, String tag, AntXMLContext context) {
            context.popWrapper();
        }

	/**
	 * Used to check if the file the correct file. The acceptable files are directories or
	 * files of extension .weights
	 * 
	 * @param f The file that is to be check if its a Performance Test Weights file
	 * @return Returns true if the file is a directory or of type .weights
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public boolean accept(File f){
		if(f.isDirectory()){
			return true;
		}
		String extension = f.getName();
		int index = extension.lastIndexOf('.');
		if(index == -1){
			return false;
		}
		extension = extension.substring(index).toLowerCase();
		if (extension != null) {
	    	if (extension.equals(WEIGHTS_EXTENSION)) {
		        return true;
	    	} else {
	    		return false;
	    	}
	    }

	    return false;
	}

	/**
	 * This method returns the description of the type of file being selected
	 * @return Returns the description of the weights file
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public String getDescription(){
		return WEIGHTS_DESCRIPTION;
	}

	/**
	 * Used to check if the file the correct file. The acceptable files are directories or
	 * files of extension .lsf
	 * 
	 * @param f The file that is to be check if its a Log file
	 * @return Returns true if the file is a directory or of type .lsf
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public boolean accept(File f){
		if(f.isDirectory()){
			return true;
		}
		String extension = f.getName();
		int index = extension.lastIndexOf('.');
		if(index == -1){
			return false;
		}
		extension = extension.substring(index).toLowerCase();
		if (extension != null) {
			if (extension.equals(LOG_FILE_EXTENSION)) {
		        return true;
			} else {
			    return false;
			}
	    }

	    return false;
	}

	/**
	 * This method returns the description of the type of file being selected
	 * @return Returns the description of the Log file
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public String getDescription(){
		return LOG_FILE_DESCRIPTION;
	}

	/**
	 * Used to check if the file the correct file. The acceptable files are directories or
	 * files of extension .ptconfig
	 * 
	 * @param f The file that is to be check if its a Performance Test configuration file
	 * @return Returns true if the file is a directory or of type ptconfig
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public boolean accept(File f){
		if(f.isDirectory()){
			return true;
		}
		String extension = f.getName();
		int index = extension.lastIndexOf('.');
		if(index == -1){
			return false;
		}
		extension = extension.substring(index).toLowerCase();
		if (extension != null) {
	    	if (extension.equals(PERFORMANCE_CONFIG_EXTENSION)) {
		        return true;
	    	} else {
	    		return false;
	    	}
	    }

	    return false;
	}

	/**
	 * This method returns the description of the type of file being selected
	 * @return Returns the description of the performance configuration file
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public String getDescription(){
		return PERFORMANCE_CONFIG_DESCRIPTION;
	}

	/**
	 * Used to check if the file the correct file. The acceptable files are directories or
	 * files of extension .cb
	 * 
	 * @param f The file that is to be check if its a Case Base file
	 * @return Returns true if the file is a directory or of type .cb
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public boolean accept(File f){
		if(f.isDirectory()){
			return true;
		}
		String extension = f.getName();
		int index = extension.lastIndexOf('.');
		if(index == -1){
			return false;
		}
		extension = extension.substring(index).toLowerCase();
	    if (extension != null) {
	    	if (extension.equals(CASEBASE_EXTENSION)) {
		        return true;
	    	} else {
	    		return false;
	    	}
	    }

	    return false;
	}

	/**
	 * This method returns the description of the type of file being selected
	 * @return Returns the description of the case base file
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	public String getDescription(){
		return CASEBASE_DESCRIPTION;
	}

    /** CaseEventListener method called when we don't know the team name.
     *
     * @param ce the CaseEvent.
     *
     * @author Edgar Acosta
     * @since 0.4
     *
     */

    public void TeamNameMissing(CaseEvent ce){
	System.err.println("The Log File doesn't contain initialization messages.");
	System.err.println("Please run again with the third parameter.");
	System.err.println(" ");
	displayUsage();
	System.exit(1);
    }

    /** CaseEventListener method called when the Case Inputs have been parsed.
     *
     * @param ce the CaseEvent. It contains the Case Inputs
     *
     * @author Edgar Acosta
     * @since 0.4
     *
     */

    public void GotInputs(CaseEvent ce){
	m_lastInputs=ce.getAgentInputs();
    }

    /** CaseEventListener method called when the Case Outputs have been parsed.
     *
     * @param ce the CaseEvent. It contains the Case Outputs
     *
     * @author Edgar Acosta
     * @since 0.4
     *
     */

    public void GotActions(CaseEvent ce){
	m_actionList=ce.getAgentActions();
	Case c = new Case(m_lastInputs,m_actionList);
	m_casebase.addCase(c);
    }

    /** Returns a copy of the case base created from the
     * log file.
     * 
     * @return The case base
     *
     * @author Michael W. Floyd
     * @since 0.2
     */

    public CaseBase getCaseBase(){
	return new CaseBase(this.m_casebase);
    }

    /** Saves the case base into the specified file
     * 
     *
     * @author Michael W. Floyd
     * @since 0.2
     */

    public void writeCaseBaseFile() throws IOException {
		
	CaseBaseIO.saveCaseBase(this.m_casebase,this.m_outputFileName);
		
    }

	/** Sets the horizonal position of the flag. Valid values
	 * are the c_LEFT, c_RIGHT and c_CENTER constants.
	 * 
	 * @param pos The horizontal position of the flag.
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setHorizontalPosition(String pos){
		//check params
		if(pos == null){
			throw new IllegalArgumentException("Horizonal position of a flag set to a null value.");
		}
		
		//make sure a valid value was given
		if(!pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM)){
			throw new IllegalArgumentException("Horizonal position of a flag set to an invalid value: " + pos);
		}
		
		this.m_horizontal = pos;
	}

	/** Returns the horizontal position of the flag. This
	 * will be one of the following constants: c_LEFT, 
	 * c_RIGHT, c_CENTER or c_UNKNOWN_POSITION
	 * 
	 * @return The horizontal position
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public String getHorizontalPosition(){
		return this.m_horizontal;
	}

	/** Sets the vertical position of the flag. Valid values
	 * are the c_TOP, c_BOTTOM and c_CENTER constants.
	 * 
	 * @param pos The vertical position of the flag.
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setVerticalPosition(String pos){
		//check params
		if(pos == null){
			throw new IllegalArgumentException("Vertical position of a flag set to a null value.");
		}
		
		//make sure a valid value was given
		if(!pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT)){
			throw new IllegalArgumentException("Vertical position of a flag set to an invalid value: " + pos);
		}
		
		this.m_vertical = pos;
	}

	/** Returns the vertical position of the flag. This
	 * will be one of the following constants: c_TOP, 
	 * c_BOTTOM, c_CENTER or c_UNKNOWN_POSITION
	 * 
	 * @return The horizontal position
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public String getVerticalPosition(){
		return this.m_vertical;
	}

        /** Returns a string representation of the object
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public String toString(){
	    String result=super.toString()+":";
	    result+=Float.toString(this.m_distanceChange)+":";
	    result+=Float.toString(this.m_directionChange);
	    return result;
	}

        /** Returns a copy of this object
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public RoboCupSimulation2DSpatialObject copyOfThis(){
	    RoboCupSimulation2DSpatialObject copy=new RoboCupSimulation2DSpatialObject(this.getFeatureName());
	    copy.setDistance(this.getDistance());
	    copy.setDirection(this.getDirection());
	    copy.setDistanceChange(this.m_distanceChange);
	    copy.setDirectionChange(this.m_directionChange);
	    return copy;
	}

	/** Sets if the flag is located out of bounds.
	 * 
	 * @param out True if the flag is out of bounds.
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setOutOfBounds(boolean out){
		this.m_outOfBounds = out;
	}

	/** Set the distance changed
	 * 
	 * @param distChange The distance changed
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setDistanceChange(float distChange){
		this.m_distanceChange = distChange;
	}

	/** Returns true if the flag is out of bounds.
	 * 
	 * @return If the flag is out of bounds.
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public boolean isOutOfBounds(){
		return this.m_outOfBounds;
	}

	/** Set the direction changed.
	 *  
	 * @param dirChange The direction changed
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setDirectionChange(float dirChange){
		this.m_directionChange = dirChange;
	}

	/** Sets the number of the flag.
	 * 
	 * @param num The number of the flag
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setFlagNumber(int num){
		this.m_flagNumber = num;
	}

	/** Get the distance changed
	 * 
	 * @return The distance changed
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getDistanceChange(){
		return this.m_distanceChange;
	}

	/** Get the direction changed
	 * 
	 * @return
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getDirectionChange(){
		return this.m_directionChange;
	}

	/** Returns the number of the flag.
	 * 
	 * @return The flag number
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public int getFlagNumber(){
		return this.m_flagNumber;
	}

	/** Sets the location of the line. Acceptable locations are
	 * 'l' (left), 'r' (right), 't' (top) and 'b' (bottom).
	 * 
	 * @param s The location of the line
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setLocation(String s){
		//check parameters
		if(s == null){
			throw new IllegalArgumentException("Null parameter given.");
		}
		//check for invalid locations
		String lowerside = s.toLowerCase();
		if( !(lowerside.equals(LineFeature.c_LOCATION_LEFT)) && !(lowerside.equals(LineFeature.c_LOCATION_RIGHT)) && !(lowerside.equals(LineFeature.c_LOCATION_TOP)) && !(lowerside.equals(LineFeature.c_LOCATION_BOTTOM))){
			throw new IllegalArgumentException("Illegal line position: " + lowerside);
		}
		
		this.m_location = lowerside;
	}

	/**
	 * Opens a dialog to find a file that contains a case base.
	 * 
     * @return the path of a file (hopefully a CaseBase)
     * 
	 * @author Mark Kelly
	 * @since 0.5
	 */

	private String browseForExistingFile(int fileType) {
		this.fileChooser.resetChoosableFileFilters();
		switch(fileType){
		case CASE_BASE_FILE:
			this.fileChooser.addChoosableFileFilter(new CaseBaseFileFilter());
			break;
		case WEIGHTS_FILE:
			this.fileChooser.addChoosableFileFilter(new WeightsFileFilter());
			break;
		case CONFIG_FILE:
			this.fileChooser.addChoosableFileFilter(new PerformanceConfigFileFilter());
			break;
		}
		
		int returnVal = this.fileChooser.showOpenDialog(this);
		
		if(returnVal == JFileChooser.APPROVE_OPTION){
			return fileChooser.getSelectedFile().getAbsolutePath();
		}
        else {
            return "";
        }
	}

	/** Sets the box the flag is on. Valid values
	 * are the c_GOAL_BOX or c_PENALTY_BOX.
	 * 
	 * @param pos The box the flag is on.
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setBox(String box){
		//check params
		if(box == null){
			throw new IllegalArgumentException("Box location of a flag set to a null value.");
		}
		
		//make sure a valid value was given
		if(!box.equals(FlagFeature.c_GOAL_BOX) && !box.equals(FlagFeature.c_PENALTY_BOX) ){
			throw new IllegalArgumentException("Box location of a flag set to an invalid value: " + box);
		}
		
		this.m_box = box;
	}

	/** Return the location of the line
	 * 
	 * @return The location of the line
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public String getLocation(){
		return new String(this.m_location);
	}

	/** Returns the body direction of the player
	 * 
	 * @return body direction of player
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getBodyDirection() {
		return this.m_bodyDirection;
	}

	/** Returns the box the flag is on. This
	 * will be one of the following constants: c_GOAL_BOX, 
	 * c_PENALTY_BOX or c_NO_BOX
	 * 
	 * @return The box the flag is on
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public String getBox(){
		return this.m_box;
	}

	/** Sets the body direction of the player
	 * 
	 * @param direction The body direction
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setBodyDirection(float direction) {
		this.m_bodyDirection = direction;
	}

	/** Gets the head direction of the player
	 * 
	 * @return head direction
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getHeadDirection() {
		return this.m_headDirection;
	}

	/** Set the head direction of the player
	 * 
	 * @param direction The head direction
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setHeadDirection(float direction) {
		this.m_headDirection = direction;
	}

	/** Returns true if the player is a goalie.
	 * 
	 * @return True if player is a goalie
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public boolean isGoalie() {
		return this.m_isGoalie;
	}

	/** Set the side to either "l" (left) or "r" (right).
	 * 
	 * @param side The side the net is on
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setSide(String side){
		//test the params
		if(side == null){
			throw new IllegalArgumentException("Null parameter given.");
		}
		//make sure a valid side selected
		String lowerside = side.toLowerCase();
		if( !(lowerside.equals(GoalFeature.c_SIDE_LEFT)) && !(lowerside.equals(GoalFeature.c_SIDE_RIGHT))){
			throw new IllegalArgumentException("Invalid side given for goal.");
		}
		
		//save the side
		this.m_side = lowerside;
	}

	/** Sets if the player is a goalie.
	 * 
	 * @param goalie True if the player is a goalie
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setIsGoalie(boolean goalie) {
		this.m_isGoalie = goalie;
	}

	/** Return the side the GoalFeature is on
	 * 
	 * @return The side the GoalFeature is on
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public String getSide(){
		return new String(this.m_side);
	}

	/** Returns the uniform number of the player.
	 * 
	 * @return The uniform number
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public int getUniformNumber() {
		return this.m_uniformNumber;
	}

	/** Sets the uniform number of the player
	 * 
	 * @param number The uniform number
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setUniformNumber(int number) {
		this.m_uniformNumber = number;
	}

        /** Returns a copy of this TurnNeckAction
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public TurnNeckAction copyThis(){
	    return new TurnNeckAction(this);
	}

        /** Returns a copy of this Dash Action
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public DashAction copyThis(){
	    return new DashAction(this);
	}

	/** Returns the power of the dash.
	 * 
	 * @return The power of the dash
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getDashPower(){
		return this.m_power;
	}

	/** Returns the angle of the neck turn.
	 * 
	 * @return The angle of the turn
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getTurnNeckAngle(){
		return this.m_angle;
	}

        /** Returns the value of an attribute
	 *
	 * @param attrib the attribute name
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public String getAttrib(String attrib){
	    if(attrib.compareTo("power") == 0)
		return Float.toString(this.m_power);
	    return "";
	}

        /** Returns a copy of this CatchAction
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public CatchAction copyThis(){
	    return new CatchAction(this);
	}

        /** Returns the value of an attribute
	 *
	 * @param attrib the attribute name
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public String getAttrib(String attrib){
	    if(attrib.compareTo("angle") == 0)
		return Float.toString(this.m_angle);
	    return "";
	}

	/** Returns the angle of the catch.
	 * 
	 * @return The angle of the catch
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

	public float getCatchAngle(){
		return this.m_angle;
	}

        /** Returns a copy of this KickAction
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public KickAction copyThis(){
	    return new KickAction(this);
	}

	/** Used to run the Log2CaseBase program.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 * 
	 */

	private void runLog2CaseBase(){
		String input = this.jInputFileName.getText();
		String output = this.jOutputFileName.getText();
		String team = this.jTeamName.getText();
		try{
			LogFile2CaseBase builder = new LogFile2CaseBase(input, output, team);
			builder.parseLogFile();
			builder.writeCaseBaseFile();
			JOptionPane.showMessageDialog(this, "Case base written to " + output, "Complete", JOptionPane.INFORMATION_MESSAGE);
		}catch(Exception e){
			JOptionPane.showMessageDialog(this, "Error: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	/** Returns the power of the kick.
	 * 
	 * @return The power of the kick
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getKickPower(){
		return this.m_power;
	}

        /** Returns a copy of this TurnAction
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public TurnAction copyThis(){
	    return new TurnAction(this);
	}

	/** Returns the angle of the kick.
	 * 
	 * @return The angle of the kick
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getKickAngle(){
		return this.m_angle;
	}

        /** Returns the value of an attribute
	 *
	 * @param attrib the attribute name
	 *
	 * @author Edgar Acosta
	 * @since 0.4
	 */

        public String getAttrib(String attrib){
	    if(attrib.compareTo("power") == 0)
		return Float.toString(this.m_power);
	    if(attrib.compareTo("angle") == 0)
		return Float.toString(this.m_angle);
	    return "";
	}

	/** Returns the angle of the turn.
	 * 
	 * @return The angle of the turn
	 *
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getTurnAngle(){
		return this.m_angle;
	}

	/** Used to store a new input to the agent to be processed.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public void see(AgentInputs inputs){
		  this.m_vision.store(inputs);
	  }

	/** Used to tell the brain that the game is over.
	 * 
	 * @param b True if the game is over, false otherwise
	 *
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public void setTimeOver(boolean b) {
		this.m_timeOver = b;
	}

	/** Displays the desired message when user clicks "About" 
	 * menu item from the menu bar.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 * 
	 */

	private void displayAboutMessage(){
		JOptionPane.showMessageDialog(this, this.c_ABOUTMESSAGE, "About RCSImitate", JOptionPane.PLAIN_MESSAGE);
	}

    /** Used to run the agent thread
     * 
     * @Override
     */

    public void run(){
	try {
	    execute();
	} catch (Exception e) {
	    System.out.println("Fatal Error: " + e.getMessage());
	}
    }

    /**
     * Initialize the Agent that will be used for testing.
     * 
     * @param cb the CaseBase that the agent will use
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void initAgent(CaseBase cb) {
	    CaseBaseSearch cbSearch = new NearestNeighbourSearch(1);
	    ActionEstimation ae = new LastActionEstimate();
	    ActionSelection actionSelection = new ClosestNeighbourSelection(ae);
	    
	    // Create an agent with the dummy case base
	    agent = new Agent(cb,cbSearch,actionSelection);
    }

    /**
     * Initializes the Weights object that will be used by the Agent during testing.
     * 
     * @param weightsFile the file that contains the weights
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void initWeights(String weightsFile) {
        // If no file was specified, use default values
        if (weightsFile == null) {
            weights = new Weights(0.0f);
            weights.setWeight(BallFeature.c_BALL, 1.0f);
            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);
            return;
        }

        try {
            weights = WeightsIO.loadWeights(weightsFile);
        }
        catch (FileNotFoundException fnfe) {
            // If an error occurs, use default values
            weights = new Weights(0.0f);
            weights.setWeight(BallFeature.c_BALL, 1.0f);
            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);
        }
    }

	/** Displays the desired message when user clicks "Help"->"Log2CaseBase" 
	 * menu item from the menu bar.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 * 
	 */

	private void displayHelpLog2CaseBaseMessage(){
		JOptionPane.showMessageDialog(this, this.c_HELPLOG2CASEBASEMESSAGE, "Help", JOptionPane.PLAIN_MESSAGE);
	}

    /** Used to move an agent to a specified location
     * 
     * @param x The x coordinate
     * @param y The y coordinate
     *
     * @since 0.3
     */

    public void move(double x, double y){
	//the message will be (move X Y)
	send("(move " + Double.toString(x) + " " + Double.toString(y) + ")");
    }

    /** Registers a new CaseEventListener.
     *
     * @param cel The CaseEventListener
     *
     * @author Edgar Acosta
     *
     */

    public void addCEListener(CaseEventListener cel){
	CEListeners.add(cel);
    }

    /** Turns the agent by a specified moment
     * 
     * @param moment The amount to turn
     *
     * @since 0.3
     */

    public void turn(double moment){
	//the message will be (turn moment)
	send("(turn " + Double.toString(moment) + ")");
    }

    /** Registers a CaseEventListener.
     *
     * @param cel The CaseEventListener
     *
     * @author Edgar Acosta
     *
     */

    public void removeCEListener(CaseEventListener cel){
	CEListeners.remove(cel);
    }

    /** Turns the agent's neck by a specified moment
     * 
     * @param moment The amount to turn
     *
     * @since 0.3
     */

    public void turn_neck(double moment){
	//the message will be (turn_neck moment)
	send("(turn_neck " + Double.toString(moment) + ")");
    }

    /**
     * Run a set of tests.
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    public void performTests() {
	applyPreprocessing(testBase, testFilenameRoot);
	
	applyPreprocessing(agentBase, agentFilenameRoot);

	// the global values must after the weights are final
	setGlobalValues(weights);

	// reset the test classes
	initTests();
	
	initAgent(agentBase);
	
	runTests(testBase);
	
	saveExpectedAndReceived();
	
	System.out.println("[" + getTime() + "]: Results:\n");
	
	System.out.println(getReportString());
	
	// Space out the output
	System.out.println();
	
	// Outputs result data to text files
	outputResultToFile();
	outputExpectedActualToFile();
    }

    /** ParsingEvent that occurs when the client sends an init message.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void ClientInit(ParsingEvent pe){
	m_teamName=pe.get("team_name");
	CaseEvent ce = new CaseEvent(this,m_teamName);
	for(CaseEventListener cel:CEListeners) cel.Connecting(ce);
    }

    /** The agent will dash with a specified power (speed)
     * 
     * @param power The dashing power
     *
     * @since 0.3
     */

    public void dash(double power){
	//the message will be (dash power)
	send("(dash " + Double.toString(power) + ")");
    }

    /** ParsingEvent that occurs when the server acknowledges an init message.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void ServerInit(ParsingEvent pe){
	CaseEvent ce = new CaseEvent(this);
	for(CaseEventListener cel:CEListeners) cel.Connected(ce);
    }

    /** The agent will kick with a specified power and direction
     * 
     * @param power The kicking power
     * @param direction The direction to kick
     *
     * @since 0.3
     */

    public void kick(double power, double direction){
	//the message will be (kick power direction)
	send("(kick " + Double.toString(power) + " " + Double.toString(direction) + ")");
    }

    /**
     * Outputs results of the running the performance test to a text file
     * 
     * @author Caleb Chan
     * @since 0.5
     */

    private void outputResultToFile(){
    	try{
	    	PrintStream output = new PrintStream(new File("Results-" + testID + ".txt"));
	    	output.println("[" + getTime() + "]: Results:\n");
	    	output.println(getReportString());
	    	output.close();
    	}catch(IOException e){
    		System.out.println("Result File Creation Error");
    	}
    }

    /** The agent will say something.
     * 
     * @param message The message to say
     *
     * @since 0.3
     */

    public void say(String message){
	//message will be (say message)
	send("(say " + message + ")");
    }

    /** Parsing Event that occurs when the agent start receiving sensor
     * messages after being sending control messages.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Sensing(ParsingEvent pe){
	if(m_teamName.equals("")){
	    CaseEvent ce = new CaseEvent(this);
	    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);
	}
	else{
	    if(m_lastInputs.getNumberSensoryItems()>0){
		CaseEvent ce = new CaseEvent(this,m_actionList);
		for(CaseEventListener cel:CEListeners) cel.GotActions(ce);
	    }
	    m_lastInputs = new AgentInputs();
	    m_actionList = new ArrayList<AgentAction>();
	}
    }

    /**
     * Outputs the expected and actual to a file 
     * 
     * @author Caleb Chan
     * @since 0.5
     */

    private void outputExpectedActualToFile(){
    	if(saveArtifacts){
	    	try{
	    		PrintStream output = new PrintStream(new File("Expected-Actual-" + testID + ".txt"));
	    		output.println(saveExpectedAndReceived());
	    		output.close();
	    	}catch(IOException e){
	    		System.out.println("Expected Acutal File Creation Error");
	    	}
    	}
    }

    /** Use to change the focus of the agent's view of the world.
     * 
     * @param angle The view angle (size of vision field)
     * @param quality The quality of view
     *
     * @since 0.3
     */

    public void changeView(String angle, String quality){
	//message will be (change_view angle quality)
	send("(change_view " + angle + " " + quality + ")");
    }

    /** Parsing Event that occurs when a see message has been received
     * (before parsing it). Other events will process the objects in
     * the field.
     *
     *  For this parser, since we only care about see messages, the
     *  inputs is resetted in order to avoid a previous see message in
     *  the same group of inputs.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void SeeReceived(ParsingEvent pe){
	m_lastInputs = new AgentInputs();
    }

    /** Used by a goalie to catch the soccer ball.
     * 
     * @param direction The direction to catch
     *
     * @author Michael W. Floyd
     * @since 0.3
     */

    public void catchBall(String direction){
	//message will be (catch direction)
	send("(catch " + direction + ")");
    }

    /**
     * Apply the preprocessing that was specified whan this instance was created.
     * 
     * @param cb the CaseBase to apply preprocessing to
     * 
     * @author Mark Kelly
     * @author 0.5
     */

    private void applyPreprocessing(CaseBase cb, StringBuilder filenameRoot) {
	for (String action : preprocessingActions) {
	    if (action.matches("(?i)(NoActionsFilter)|(naf)")) {
		applyNoActionsFilter(cb, filenameRoot);
	    }
	    else if (action.matches("(?i)(FeatureDistancePresort)|(fdp)")) {
		applyFeatureDistancePresort(cb, filenameRoot);
	    }
	    else if (action.matches("(?i)(SequentialBackwardGeneration)|(sbg)")) {
		applySequentialBackwardGeneration(cb, filenameRoot);
	    }
	    else if (action.matches("(?i)(ZeroWeightFilter)|(zwf)")) {
		applyZeroWeightFilter(cb, filenameRoot);
	    }
	    else if (action.matches("(?i)(RoughSetFeatureSelection)|(rsfs)")) {
		applyRoughSetFeatureSelection(cb, filenameRoot);
	    }
	}
    }

    /** Used to send the initialization command to the server.
     * 
     * @since 0.3
     */

    protected void init(){
	//the message is (init teamname (version 8))
        send("(init " + this.m_teamname + " (version 8))");
    }

    /**
     * Execute all SQL and second-level cache updates, in a
     * special order so that foreign-key constraints cannot
     * be violated:
     * <ol>
     * <li> Inserts, in the order they were performed
     * <li> Updates
     * <li> Deletion of collection elements
     * <li> Insertion of collection elements
     * <li> Deletes, in the order they were performed
     * </ol>
     */

    private void execute() throws HibernateException {

        log.trace("executing flush");

        try {
            // we need to lock the collection caches before
            // executing entity inserts/updates in order to
            // account for bidi associations
            beforeExecutionsAll(collectionRemovals);
            beforeExecutionsAll(collectionUpdates);
            beforeExecutionsAll(collectionCreations);

            // now actually execute SQL and update the
            // second-level cache
            executeAll(insertions);
            executeAll(updates);
            executeAll(collectionRemovals);
            executeAll(collectionUpdates);
            executeAll(collectionCreations);
            executeAll(deletions);
        }
        catch (HibernateException he) {
            log.error("Could not synchronize database state with session");
            throw he;
        }
    }

    /** Parsing Event that occurs when the agent start sending control
     * messages after being receiving sensor messages.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Controling(ParsingEvent pe){
	if(m_lastInputs.getNumberSensoryItems()>0){
	    CaseEvent ce = new CaseEvent(this,m_lastInputs);
	    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);
	}
    }

    /** Parsing Event that occurs when the agent start receiving sensor
     * messages after being sending control messages.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Sensing(ParsingEvent pe){
	if(m_teamName.equals("")){
	    CaseEvent ce = new CaseEvent(this);
	    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);
	}
    }

    /** Used to sent the specified message to the server.
     * 
     * @param message The message to send
     *
     * @author Michael W. Floyd
     * @since 0.3
     */

    private void send(String message){
	byte[] buffer = new byte[RCSImitate.MSG_SIZE];
	buffer = message.getBytes();

	DatagramPacket packet 
	    = new DatagramPacket(buffer, buffer.length, this.m_serverhost, this.m_serverport);

	try{
	    this.m_socket.send(packet);
	}catch(IOException e){
	    System.err.println("Socket sending error : " + e);
	}
    }

    /**
     * Removes cases with no associated action from the case base.
     * 	
     * @param cb the CaseBase to apply preprocessing to
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void applyNoActionsFilter(CaseBase cb, StringBuilder filenameRoot) {
	System.out.println("[" + getTime() + "]: Applying No Actions Filter ...");
	NoActionsFilter naf = new NoActionsFilter();
	cb.setCaseList(naf.filter(cb).getCaseList());
	
	filenameRoot.append("-naf");
	
	if (saveArtifacts) {
	    // Save the new case base
	    System.out.println("[" + getTime() + "]: Saving CaseBase to " + filenameRoot.toString() + ".cb");
	    try {
		CaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + ".cb");
	    }
	    catch (IOException ioe) {
		System.err.println("[" + getTime() + "]: Saving CaseBase after applying NoActionsFilter failed.");
	    }
	}
    }

    /** Generic method to get feature values from a Parsing Event and
     * copy them to a RoboCupSimulation2DSpatialObject.
     *
     * @param so the 2D Spatial Object receiving the feature values
     * @param pe the Parsing Event containing the feature values
     *
     * @author Edgar Acosta
     *
     */

    private void setObjectPosition(RoboCupSimulation2DSpatialObject so,
			    ParsingEvent pe){//this sets the parameters that are common to all field objects
	if(pe.contains("dir_change")) so.setDirectionChange(Float.parseFloat(pe.get("dir_change")));
	if(pe.contains("dist_change")) so.setDistanceChange(Float.parseFloat(pe.get("dist_change")));
	if(pe.contains("direction")) so.setDirection(Float.parseFloat(pe.get("direction")));
	if(pe.contains("distance")) so.setDistance(Float.parseFloat(pe.get("distance")));
    }

    /** Parsing Event that occurs when a see message has been received
     * (before parsing it). Other events will process the objects in
     * the field.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void SeeReceived(ParsingEvent pe){
	if(m_lastInputs.getNumberSensoryItems()>0){
	    CaseEvent ce = new CaseEvent(this,m_actionList);
	    for(CaseEventListener cel:CEListeners) cel.GotActions(ce);
	}
	m_lastInputs = new AgentInputs();
	m_actionList = new ArrayList<AgentAction>();
    }

    /** Used to receive the next message from the server.
     * 
     * @return The message received
     *
     * @author Michael W. Floyd
     * @since 0.3
     */

    private String receive() {
	byte[] buffer = new byte[RCSImitate.MSG_SIZE];
	DatagramPacket packet = new DatagramPacket(buffer, RCSImitate.MSG_SIZE);
	try{
	    this.m_socket.receive(packet);
	}catch(IOException e){
	    System.err.println("Socket receiving error : " + e);
	}
	return new String(buffer);
    }

    /** Parsing Event that occurs when a see message has been parsed.
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void SeeParsed(ParsingEvent pe){
	    CaseEvent ce = new CaseEvent(this,m_lastInputs);
	    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);
    }

    /** Parsing Event that occurs when a goal has been sensed
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Goal(ParsingEvent pe){
	GoalFeature gf = new GoalFeature();
	if(pe.contains("name"))
	    gf.setSide(pe.get("name"));
	setObjectPosition(gf,pe);
	m_lastInputs.addSensoryItem(gf);
    }

    /**
     * Uses a rough set theory to determine weights for features.
     * 
     * @param cb the CaseBase to apply preprocessing to
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void applyRoughSetFeatureSelection(CaseBase cb, StringBuilder filenameRoot) {
		System.out.println("[" + getTime() + "]: Applying RoughSetFeatureSelection");
		weights = WeightAdjuster.featureSelect(WeightAdjuster.ROUGH_SET_FEATURE_SELECTION, cb);
		
		filenameRoot.append("-rsfs");
		
		if (saveArtifacts) {
			// Save generated Weights object
			System.out.println("[" + getTime() + "]: Saving generated Weights object to " + filenameRoot.toString() + ".weights");
			try {
				WeightsIO.saveWeights(weights, filenameRoot.toString() + ".weights");
			}
			catch (IllegalArgumentException iae) {
				System.err.println("[" + getTime() + "]: Saving generated Weights failed.");
			}
		}
	}

    /** Parsing Event that occurs when a ball has been sensed
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Ball(ParsingEvent pe){
	BallFeature bf = new BallFeature();
	setObjectPosition(bf,pe);
	m_lastInputs.addSensoryItem(bf);
    }

    /**
     * Uses a backward sequential search to determine weights for features.
     * 
     * @param cb the CaseBase to apply preprocessing to
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void applySequentialBackwardGeneration(CaseBase cb, StringBuilder filenameRoot) {
		System.out.println("[" + getTime() + "]: Applying SequentialBackwardGeneration");
		weights = WeightAdjuster.featureSelect(WeightAdjuster.SEQUENTIAL_BACKWARD_GENERATION, cb);
		
		filenameRoot.append("-sbg");
		
		if (saveArtifacts) {
			// Save generated Weights object
			System.out.println("[" + getTime() + "]: Saving generated Weights object to " + filenameRoot.toString() + ".weights");
			try {
				WeightsIO.saveWeights(weights, filenameRoot.toString() + ".weights");
			}
			catch (IllegalArgumentException iae) {
				System.err.println("[" + getTime() + "]: Saving generated Weights failed.");
			}
		}
	}

    /** Parsing Event that occurs when a Flag has been sensed
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Flag(ParsingEvent pe){
	FlagFeature flag = new FlagFeature();
	String name=pe.get("name");
	if(pe.contains("Box")) flag.setBox(pe.get("Box"));
	if(pe.contains("hp")) 
	    flag.setHorizontalPosition(pe.get("hp"));
	if(pe.contains("vp")) 
	    flag.setVerticalPosition(pe.get("vp"));
	if(pe.contains("flag_number")){
	    flag.setFlagNumber(Integer.parseInt(pe.get("flag_number")));
	    flag.setOutOfBounds(true);
	} else
	    flag.setOutOfBounds(false);
	setObjectPosition(flag,pe);
	m_lastInputs.addSensoryItem(flag);
    }

	/**
	 * Removes unused features from a case base.
     * 
     * @param cb the CaseBase to apply preprocessing to
     * 
	 * @author Mark Kelly
	 * @since 0.5
	 */

	private void applyZeroWeightFilter(CaseBase cb, StringBuilder filenameRoot) {
		System.out.println("[" + getTime() + "]: Applying Zero Weight Filter");
		ZeroWeightFilter zwf = new ZeroWeightFilter(weights);
		cb.setCaseList(zwf.filter(cb).getCaseList());
		
		filenameRoot.append("-zwf");
		
		if (saveArtifacts) {
			// Save the new case base
			System.out.println("[" + getTime() + "]: Saving CaseBase to " + filenameRoot.toString() + ".cb");
			try {
				CaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + ".cb");
			}
			catch (IOException ioe) {
				System.err.println("[" + getTime() + "]: Saving CaseBase after applying ZeroWeightFilter failed.");
			}
		}
	}

    /** Parsing Event that occurs when a line has been sensed
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Line(ParsingEvent pe){
	LineFeature lf = new LineFeature();
	if(pe.contains("name")) lf.setLocation(pe.get("name"));
	setObjectPosition(lf,pe);
	m_lastInputs.addSensoryItem(lf);
    }

    /** CaseEvent method used to stop the agent
     * 
     * @param ce the Case Event.
     *
     * @author Edgar Acosta
     * @since 0.4
     */

    public void TimeOver(CaseEvent ce){
	this.m_timeOver = true;
	this.m_brain.setTimeOver(true);
    }

    /** Parsing Event that occurs when a catch action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Catch(ParsingEvent pe){
	CatchAction catchAct = new CatchAction();
	if(m_actionList.size()<1)
	    m_actionList.add(catchAct);
    }

    /**
     * Sets certain values in classes
     * 
     * @param w the Weights object that will be used by the agent
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void setGlobalValues(Weights w) {
        GlobalDistanceMeasure gd = new OrderIndexMatchingAlgorithm(w);
		Case.setGlobalDistanceCalculation(gd);
		
		SensoryItem.setDistanceCalculation(new EqualityDistanceAlgorithm());
		SensoryItem.setPenaltyDistanceCalculation(new ConstantPenalty(100));
		Spatial2DObject.setDistanceCalculation(new PolarDistanceAlgorithm());
    }

    /** Parsing Event that occurs when a dash action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Dash(ParsingEvent pe){
	float power =Float.parseFloat(pe.get("power"));
	DashAction dash = new DashAction(power);
	if(m_actionList.size()<1)
	    m_actionList.add(dash);
    }

    /** Parsing Event that occurs when a kick action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Kick(ParsingEvent pe){
	float power =Float.parseFloat(pe.get("power"));
	float angle =Float.parseFloat(pe.get("direction"));
	KickAction kick = new KickAction(power,angle);
	if(m_actionList.size()<1)
	    m_actionList.add(kick);
    }

    /** Parsing Event that occurs when a catch action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Catch(ParsingEvent pe){
	CatchAction catchAct = new CatchAction();
	m_actionList.add(catchAct);
    }

    /** Parsing Event that occurs when a turn action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Turn(ParsingEvent pe){
	float angle =Float.parseFloat(pe.get("direction"));
	TurnAction turn = new TurnAction(angle);
	if(m_actionList.size()<1)
	    m_actionList.add(turn);
    }

    /** Parsing Event that occurs when a dash action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Dash(ParsingEvent pe){
	float power =Float.parseFloat(pe.get("power"));
	DashAction dash = new DashAction(power);
	m_actionList.add(dash);
    }

    /**
     * Show the results from the most recent run of the tests.
     * 
     * @author Mark Kelly
     * @since 0.5
     */

    private void showResults() {
        System.out.println("[" + getTime() + "]: Results:\n");
        
        System.out.println(getReportString());
        
        // Space out the output
        System.out.println();
    }

    /** Parsing Event that occurs when a kick action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Kick(ParsingEvent pe){
	float power =Float.parseFloat(pe.get("power"));
	float angle =Float.parseFloat(pe.get("direction"));
	KickAction kick = new KickAction(power,angle);
	m_actionList.add(kick);
    }

    /** Parsing Event that occurs when a turn neck action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void TurnNeck(ParsingEvent pe){
	float angle =Float.parseFloat(pe.get("neck_angle"));
	TurnNeckAction turnNeck = new TurnNeckAction(angle);
	//m_actionList.add(turnNeck);
    }

    /** Parsing Event that occurs when a turn action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Turn(ParsingEvent pe){
	float angle =Float.parseFloat(pe.get("direction"));
	TurnAction turn = new TurnAction(angle);
	m_actionList.add(turn);
    }

    /** Parsing Event that occurs when a hear action has been uttered
     *
     * @param pe The ParsingEvent
     *
     * @author Edgar Acosta
     *
     */

    public void Hear(ParsingEvent pe){
	String who=pe.get("who");
	String what=pe.get("what");
	if(who.equals("referee") && what.equals("time_over")){
	    CaseEvent ce = new CaseEvent(this);
	    for(CaseEventListener cel:CEListeners) cel.TimeOver(ce);
	}	    
    }

	/** Returns the Case portion of the pairing.
	 * 
	 * @return the Case portion of the pairing
	 * 
	 * @author Michael W. Floyd
	 * @since 0.4
	 */

	public Case getCase(){
		return this.m_case;
	}

	/** Returns the AgentAction portion of the pairing.
	 * 
	 * @return the AgentAction portion of the pairing
	 * 
	 * @author Michael W. Floyd
	 * @since 0.4
	 */

	public AgentAction getAction(){
		return this.m_action;
	}

	/** Stores the time it takes the Agent to select an
	 * AgentAction to perform.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public AgentAction senseEnvironment(Case c) {
		//check the parameters
		if(c == null){
			throw new IllegalArgumentException("Null Case given to senseEnvironment");
		}
		AgentInputs av = c.getInputs();
		
		long startTime = System.currentTimeMillis();
		AgentAction action = this.m_agent.senseEnvironment(av);
		long endTime = System.currentTimeMillis();
		
		this.m_totalTime += endTime - startTime;
		this.m_numInputs ++;
		
		return action;
	}

	/** Returns the mean execution time of the Agent being
	 * monitored (in milliseconds).
	 * 
	 * @return mean execution time
	 *
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public float getMeanExecutionTime(){
		//make sure we don't divide by zero
		if(this.m_numInputs == 0){
			return 0.0f;
		}
		return ((float)this.m_totalTime)/this.m_numInputs;
	}

        /** Returns a copy of this Agent Action
	 *
	 * @author Edgar Acosta
	 * @since 0.5
	 */

         public AgentAction copyThis(){
	     AgentAction newAgent = null;
	     
	     Class<? extends AgentAction> clazz = this.getClass();
	     
	     Constructor<? extends AgentAction> constructor;
	     
	     try {
		 constructor = clazz.getConstructor(clazz);
		 newAgent = constructor.newInstance(this);
	     }
	     catch (Exception e) {
		 e.printStackTrace();
		 System.exit(1);
	     }
	     
	     return newAgent;
	 }

	/** Returns the name of the action
	 * 
	 * @return The name of the actions
	 *
	 * @author Michael W. Floyd
	 * @since 0.1 
	 */

	public String getActionName(){
		return this.m_name;
	}

    /** Returns the current size of the casebase.
     * 
     * @return The current size of the case base
     * 
     * @author Michael W. Floyd
     * @since 0.1
     */

    public int getCasebaseSize(){
    	return this.m_casebase.size();
    }

        /** Returns a string representation of this object
	 *
	 * @author Edgar Acosta
	 * @since 0.5
	 */

         public String toString(){
	     String result=super.toString()+":";
	     result+=Float.toString(this.m_distance)+":";
	     result+=Float.toString(this.m_direction);
	     return result;
	 }

        /** Returns attribute value
	 *
	 * @param attrib the attribute name
	 *
	 * @author Edgar Acosta
	 * @since 0.5
	 */

        public String getAttrib(String attrib){
	    return "";
	}

    /** Adds a Case to the CaseBase
     * 
     * @param ca The Case to add to the CaseBase
     * 
     * @author Michael W. Floyd
     * @since 0.1
     */

    public void addCase(Case ca){
    	if(ca == null){
    		throw new IllegalArgumentException("Null Case added to CaseBase.");
    	}
		
    	this.m_casebase.add(ca);
    }

         /** Returns a copy of this object
	  *
	  * @author Edgar Acosta
	  * @since 0.5
	  */

         public Spatial2DObject copyOfThis(){
	     Spatial2DObject copy=new Spatial2DObject(this.getFeatureName());
	     copy.setDistance(this.m_distance);
	     copy.setDirection(this.m_direction);
	     return copy;
	 }

    /**
     * This returns the string representation of the AgentAction class
     * 
     * @author Caleb Chan
     * @since 0.5
     */

        public String toString(){
        	return m_name;	
        }

    /** Sets the list of Cases in the CaseBase
     * 
     * @author Michael W. Floyd
     * @since 0.1
     */

    public void setCaseList(List<Case> cbList){
    	//check params
    	if(cbList == null){
    		throw new IllegalArgumentException("Null paramater given to CaseBase constructor");
    	}
		
    	this.m_casebase = new ArrayList<Case>(cbList);
    }

	/** Set the distance to the feature.
	 * 
	 * @param dist Distance to the feature
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setDistance(float dist){
		this.m_distance = dist;
	}

	/** Sets the value of this feature.
	 * 
	 * @param value The value to set it to.
	 *
	 * @author Michael W. Floyd
	 * @since 0.5
	 *
	 */

	public void setValue(float value){
		this.m_value = value;
	}

	/** Set the direction to the feature.
	 * 
	 * @param dir Direction to the feature
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public void setDirection(float dir){
		this.m_direction = dir;
	}

	/** Returns the value of this feature.
	 * 
	 * @return the feature value
	 *
	 * @author Michael W. Floyd
	 * @since 0.5
	 *
	 */

	public float getValue(){
		return this.m_value;
	}

	/** Returns the AgentAction associated with the most similar Case.
	 * If the most similar Case has no associated action, null is returned.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public AgentAction selectAction(List<Case> nearestNeighbours) {
		//check parameters
		if(nearestNeighbours == null){
			throw new IllegalArgumentException("Null value given to ClosestNeighbourSelection");
		}
		if(nearestNeighbours.size() == 0){
			throw new IllegalArgumentException("ClosestNeighbourSelection requires at least 1 Case to be given.");
		}
		
		//get the first Case and its actions
		Case firstCase = nearestNeighbours.get(0);
		List<AgentAction> actions = firstCase.getActions();
		
		return this.m_actionEst.estimateAction(actions);
	}

	/** Returns the last AgentAction in the list. If there is no
	 * associated action, null is returned.
	 * 
	 * @see org.JIFSA.reasoning.actionselection.actionestimation.ActionEstimation
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public AgentAction estimateAction(List<AgentAction> possibilities) {
		//check parameters
		if(possibilities == null){
			throw new IllegalArgumentException("Null list given to LastActionEstimate.");
		}
		
		//if there are no associated actions, return null
		if(possibilities.size() == 0){
			return null;
		}
		
		//return the last item
		return possibilities.get(possibilities.size() -1);
	}

	/** The distance to the feature.
	 * 
	 * @return The distance to the feature
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getDistance(){
		return this.m_distance;
	}

	/** Returns the penalty value specified in the constructor.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 * 
	 */

	public float calculatePenalty(SensoryItem feat) {
		//sanity check, even though we don't use it, we still don't want null
		if(feat == null){
			throw new IllegalArgumentException("Null feature given to penalty function.");
		}
		
		return this.m_penalty;
	}

	/** Sets the filters that will be applied to each new Case the Agent
	 * encounters in the senseEnvironment method.
	 * 
	 * @param filters The filters to use
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public void setFilters(CaseFilter[] filters){
		for(int ii=0;ii<filters.length;ii++){
			if(filters[ii] == null){
				throw new IllegalArgumentException("Null CaseFilter given to agent.");
			}
		}
		
		this.m_filters = filters;
	}

	/** The direction to the feature.
	 * 
	 * @return The direction to the feature
	 * 
	 * @author Michael W. Floyd
	 * @since 0.2
	 */

	public float getDirection(){
		return this.m_direction;
	}

	/** Sets the feature weights to the given weights.
	 * 
	 * @param newWeights The weights to use
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public void setWeights(Weights newWeights){
		if(newWeights == null){
			throw new IllegalArgumentException("Null weights given to GlobalDistanceMeasure");
		}
		this.m_featureWeights = newWeights;
	}

	/** Used to change the CaseBase used by the Agent
	 * 
	 * @param cb the new CaseBase
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public void setCaseBase(CaseBase cb){
		if(cb == null){
			throw new IllegalArgumentException("Null CaseBase given to Agent.");
		}
		if(cb.getCasebaseSize() == 0){
			throw new IllegalArgumentException("Empty CaseBase given to Agent. At least one Case must be in CaseBase.");
		}
		
		this.m_caseBase = cb;
		
	}

	/** Gets the feature weights currently used by the global distance
	 * measure
	 * 
	 * @return The feature weights
	 * @since 0.3
	 */

	public Weights getWeights(){
		return this.m_featureWeights;
	}

	/** Based on the weights of each type of feature, a complete distance
	 * will be produced.
	 * 
	 * @param distances The distance of each type of feature
	 * @return The weighted distance
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	protected float weightedDistance(Map<String, Float> distances) {
		float totalDistance = 0.0f;
		
		//get a list of object types we have and go through each type
		List<String> objectTypes = new ArrayList<String>(distances.keySet());
		for(String currentType : objectTypes){
			float rawDistance = distances.get(currentType);
				
			//apply the weight
			float currentWeight = this.m_featureWeights.getWeight(currentType);
			totalDistance += rawDistance*currentWeight;
		}
		
		return totalDistance;
	}

	/** Sets the weight for the given type of item
	 * to the designated value. The weight value must
	 * be between 0.0 and 1.0 (inclusive).
	 * 
	 * @param itemName The name of the item type
	 * @param weight The weight for that item type
	 *
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public void setWeight(String itemName, float weight){
		//check parameters
		if(itemName == null){
			throw new IllegalArgumentException("Null parameter given to Weights object.");
		}
		if(weight < 0.0f || weight > 1.0f){
			throw new IllegalArgumentException("The weights must be between 0.0 and 1.0 (inclusive)");
		}
		
		//set the weight value
		this.m_weights.put(itemName, new Float(weight));
	}

	/** Returns the weight for the given type
	 * of item. If that weight has not been
	 * set using the setWeight function then
	 * the default weight value given by
	 * the constructor will be used.
	 * 
	 * @param itemName The type of item
	 * @return The weight of the item
	 *
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public float getWeight(String itemName){
		//check parameters
		if(itemName == null){
			throw new IllegalArgumentException("Null parameter given to Weights object.");
		}
		
		//get the associated weight
		Float weight = this.m_weights.get(itemName);
		
		//see if the weight has actually been set, otherwise use default
		if(weight == null){
			return this.m_defaultWeight;
		}
		return weight.floatValue();
	}

    /** Sets the table of sensory items
     *
     * @param a table of sensory times, a list of the per feature type
     *
     */

    public void setSensoryItems(Hashtable<String,List<SensoryItem>> items){
    	this.m_featuregroupTable=new Hashtable<String,List<SensoryItem>>(items);
    }

    /** Sets the AgentActions associated with this Case
     * 
     * @return The associated action in this Case
     *
     * @author Michael W. Floyd
     * @since 0.1
     */

    public void setActions(List<AgentAction> actions){
    	this.m_actions= new ArrayList<AgentAction>(actions);
    }

    /** Returns the AgentInputs associated with this Case
     * 
     * @return The associated inputs in this Case
     *
     * @author Michael W. Floyd
     * @since 0.1
     */

    public AgentInputs getInputs(){
    	return this.m_inputs;
    }

	/** Sets the sample size. Supplied values must
	 * be greater than zero. This determines how
	 * many Cases of each action type are put
	 * into the output CaseBase.
	 * 
	 * @param The currently set sample size.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public void setSampleSize(int sampleSize){
		if(sampleSize <= 0){
			throw new IllegalArgumentException("Invalid sample size given to RandomUnderSample.setSampleSize(int)");
		}
		this.m_maxNum = sampleSize;
	}

	/** Returns the currently set sample size.
	 * 
	 * @param The currently set sample size.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public int getSampleSize(){
		return this.m_maxNum;
	}

    /** Sets the AgentInputs associated with this Case
     * 
     * @return The associated inputs in this Case
     *
     * @author Michael W. Floyd
     * @since 0.1
     */

    public void setInputs(AgentInputs inputs){
    	this.m_inputs=inputs;
    }

    /** Checks to see if any features of a specific type exist
     * in the AgentInputs object.
     * 
     * @param featureName The name of the feature type of check for
     * 
     * @return true if at least one feature of that type is in the AgentInputs
     * 
     * @author Michael W. Floyd
     * @since 0.1
     * 
     */

    public boolean doesContain(String featureName){
    	//check parameters
    	if(featureName == null){
    		throw new IllegalArgumentException("SensoryItem name was null.");
    	}
		
    	//get the list of that type of feature
    	List<SensoryItem> l = this.m_featuregroupTable.get(featureName);
		
    	//if there is no entry in the feature table the HashMap will
    	//have returned null
    	if(l == null || l.size() == 0){
    		return false;
    	}
    	return true;
    }

    /** Returns the number of features in the AgentInputs
     * of a particular type.
     * 
     * @param featureName The name of the feature type
     * 
     * @return The number of features in the AgentInputs of a given type
     *
     * @author Michael W. Floyd
     * @since 0.1
     */

    public int getNumberSensoryItems(String featureName){
    	//check parameters
    	if(featureName == null){
    		throw new IllegalArgumentException("SensoryItem name was null.");
    	}
		
    	//get the list for that feature
    	List<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);
    	//if null then no features of that type exist
    	if(sensoryItemList == null){
    		return 0;
    	}
		return sensoryItemList.size();
    }

    /**
     * Returns a string representation of a case class
     * 
     * @return A string representation of the case class
     * 
     * @author Caleb Chan
     * @since 0.5
     */

    public String toString(){
    	String output = "Case : ";
    	output += "\n\tInputs : ";
    	output += "\n\t\t" + m_inputs.toString(m_inputs.getSensoryItemNames()); 
    	output += "\n\tActions : "; 
    	for(AgentAction a : m_actions){
    		output += "\n\t\t" + a.toString();
    	}  	
    	return output;
    }

    /** Returns the total number of features in the AgentInputs
     * 
     * @return The number of features in the AgentInputs
     *
     * @author Michael W. Floyd
     * @since 0.1
     */

    public int getNumberSensoryItems(){
    	//get the feature list for each type of feature
    	Collection<List<SensoryItem>> lists = this.m_featuregroupTable.values();
		
    	int featureCounter = 0;
		
    	for(List<SensoryItem> currentList : lists){
    		//ignore null lists, these occur when we remove a feature list
    		if(currentList != null){
    			featureCounter += currentList.size();
    		}
    	}
		
    	return featureCounter;
    }

	/** Resets the lists and best results so that a new weight search can
	 * be performed.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	private void resetLists(){
		this.m_best = null;
		this.m_evalBest = -1;
		this.m_statsBest = null;
		this.m_closed = new ArrayList<Weights>();
		this.m_open = new ArrayList<Weights>();
		this.m_evalOpen = new ArrayList<Float>();
		this.m_statsOpen = new ArrayList<StatisticsBundle>();
	}

    /** Adds a Case to the Cluster
     * 
     * @param c The Case to add to the Cluster
     * 
     * @author Michael W. Floyd
     * @since 0.5
     */

    public void addMember(Case c) {
	if(c == null){
	    throw new IllegalArgumentException("Null Case given to Cluster.addMember(Case c)");
	}
	this.m_members.add(c);
    }

    /** Removes all features of a specific type from the AgentVision
     * 
     * @param featureName The feature type to remove
     *
     * @author Michael W. Floyd
     * @since 0.1
     */

    public void removeSensoryItemType(String featureName){
    	//check parameters
    	if(featureName == null){
    		throw new IllegalArgumentException("SensoryItem name was null.");
    	}
		
    	//get the list for the specified feature
    	List<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);
		
    	//if it is null then the feature doesn't exist in the AgentVision
    	if(sensoryItemList != null){
    		//clear the list
    		sensoryItemList.clear();
    		//change the table entry to null  (meaning empty)
    		this.m_featuregroupTable.remove(featureName);
    	}
    }

	/** Used to get the identifier for the point
	 * 
	 * @return The identifier
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public String getID(){
		return this.m_id;
	}

	/** Calculates the error associated with the current clustering.
	 * 
	 * @param clusters The current clusters
	 * @param newCentroids The current centroids
	 * @return The error of this clustering
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	private double calculateError(List<List<VectorPoint>> clusters, VectorPoint[] newCentroids) {
		double total = 0;
		
		//go through each cluster
		for(int ii=0; ii<clusters.size(); ii++){
			List<VectorPoint> nextCluster = clusters.get(ii);
			VectorPoint centroid = newCentroids[ii];
			//go through each cluster member
			for(int jj=0; jj<nextCluster.size(); jj++){
				VectorPoint item = nextCluster.get(jj);
				total += item.euclideanDistance(centroid);
			}
		}
			
		return total;
	}

	/** Goes through the entire supplied CaseBase and removes
	 * any Cases that do not have an associated AgentAction.
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public CaseBase filter(CaseBase initialCB) {
		//check parameters
		if(initialCB == null){
			throw new IllegalArgumentException("Null CaseBase given to NoActionsFilter.");
		}
		
		CaseBase newCB = new CaseBase();
		
		//go through each Case in the initial CaseBase
		List<Case> allCases = initialCB.getCaseList();
		for(Case currentCase : allCases){
			//only add ones that have AgentActions
			if(currentCase.getActions().size() != 0){
				newCB.addCase(currentCase);
			}
		}
		
		return newCB;
	}

	/** Performs the sorting.
	 * 
	 * @param initialCB The initial case base
	 * @return The case base with sorted Spatial2DFeatures
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public CaseBase filter(CaseBase initialCB) {
		//check parameters
		if(initialCB == null){
			throw new IllegalArgumentException("Null case base given to FeatureDistancePresort.");
		}
		
		//Create the Case filter
		FeatureDistanceCasePresort fdcp = new FeatureDistanceCasePresort();
		
		//create the new CaseBase
		CaseBase sorted = new CaseBase();
		
		//go through each Case in the CaseBase
		List<Case> allCases = initialCB.getCaseList();
		for(Case currentCase : allCases){
			Case filteredCase = fdcp.filter(currentCase);
			sorted.addCase(filteredCase);
		}
		
		return sorted;
	}

	/** Adds a decision class, keeping consistency state.
	 *
	 * If decision class is the same used to initialize the class, the condition class is consistent.
	 *
	 * @params decClass a decision class
	 *
	 * @since 0.5
	 */

        public void add(AgentAction decClass){
            elements+=1;
            if(!Dclass.equals(decClass)){
                consistent = false;
            }
        }

	/** Computes the Euclidean distance between the point
	 * and another point
	 * 
	 * @param otherPoint The second point
	 * @return The distance between the points
	 *  
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public double euclideanDistance(VectorPoint otherPoint){
		//test the params
		if(otherPoint == null){
			throw new IllegalArgumentException("Null point given.");
		}
		float[] otherData = otherPoint.getPoint();
		if(otherData.length != this.m_point.length){
			throw new IllegalArgumentException("Euclidean distance cannot be calculated because vectors are of different lengths.");
		}
		
		double distance = 0;
		for(int ii=0; ii<this.m_point.length; ii++){
			distance += (this.m_point[ii] - otherData[ii])*(this.m_point[ii] - otherData[ii]);
		}
		
		distance = Math.sqrt(distance);
		return distance;
	}

	/** Sorts a list of Spatial2DObjects by their distance to the
	 * agent.
	 * 
	 * @param sensoryItemList A list of Spatial2DFeatures
	 *
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	private void sortByDistance(List<SensoryItem> sensoryItemList){
		
		//define a comparator for sorting a List of Features by distance
		Comparator<SensoryItem> comp = new Comparator<SensoryItem>(){
			 public int compare(SensoryItem f1, SensoryItem f2){
				 
				 Spatial2DObject sf1 = (Spatial2DObject)f1;
				 Spatial2DObject sf2 = (Spatial2DObject)f2;
				 
				 float dist1 = sf1.getDistance();
				 float dist2 = sf2.getDistance();
				 
				 if (dist1 == dist2){
					 return 0;
				 }else if(dist1 > dist2){
					 return 1;
				 }else{
					 return -1;
				 }
			 }
		};
		
		//sort the List based on our comparator we defined
		Collections.sort(sensoryItemList, comp);
	}

	/** Returns the size of the decision class. O if inconsistent.
	 *
	 * @since 0.5
	 */

        public int getCount(){
            if(consistent == true)
                return elements;
            return 0;
        }

	/**
	 * This will save a CaseBase object in the protocol buffer format
	 * 
	 * @param s A CaseBase object to be saved
	 * @return SensoryItemProtocol Returns the object that incases the CaseBase object for saving
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	private CaseBaseProtocol saveCaseProtocolBufferHelpper(CaseBase casebase){
		CaseBaseProtocol.Builder builder = CaseBaseProtocol.newBuilder();

		for(Case c : casebase.getCaseList()){
			builder.addMCasebase(saveCaseHelper(c));
		}

		return builder.build();
	}

	/**
	 * This will save a Case object in the protocol buffer format
	 * 
	 * @param s A Case object to be saved
	 * @return SensoryItemProtocol Returns the object that incases the Case object for saving
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	private CaseProtocol saveCaseHelper(Case cases){
		CaseProtocol.Builder caseBuilder = CaseProtocol.newBuilder();

		caseBuilder.setMInputs(saveAgentInputsHelper(cases.getInputs()));
		for(AgentAction a : cases.getActions()){
			caseBuilder.addMActions(saveAgentActionHelper(a));
		}
		return caseBuilder.build();
	}

	/** Returns the decision class. Null if inconsistent.
	 *
	 * @since 0.5
	 */

        public AgentAction getDclass(){
            if(consistent == true)
                return Dclass;
            return null;
        }

	/**
	 * This will save a AgentInputs object in the protocol buffer format
	 * 
	 * @param s A AgentInputs object to be saved
	 * @return SensoryItemProtocol Returns the object that incases the AgentInputs object for saving
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	private AgentInputsProtocol saveAgentInputsHelper(AgentInputs i){
		AgentInputsProtocol.Builder inputsBuilder = AgentInputsProtocol.newBuilder();

		for(String s : i.getSensoryItemNames()){
			AgentInputsProtocol.FeatureGroupTable.Builder featureBuilder = AgentInputsProtocol.FeatureGroupTable.newBuilder();
			featureBuilder.setFeature(s);
			for(SensoryItem si : i.getSensoryItems(s)){
				featureBuilder.addItem(saveSensoryItemHelper(si));
			}
			inputsBuilder.addMFeaturegroupTable(featureBuilder.build());
		}
		return inputsBuilder.build();
	}

	/** After a CaseBase has been processed this method
	 * will return the maximum occurrences, of a given sensory item
	 * type, in a Case.
	 * 
	 * @param item The name of the sensory item
	 * @return The maximum number of occurrences
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public int getMaximum(String item){
		if(item == null){
			throw new IllegalArgumentException("Null value given to SensoryItemDistribution function.");
		}
		
		Integer max = m_max.get(item);
		if(max == null){
			return 0;
		}
		return max.intValue();
	}

	/**
	 * This will save a SensoryItem object in the protocol buffer format
	 * 
	 * @param s A SensoryItem object to be saved
	 * @return SensoryItemProtocol Returns the object that incases the SensoryItem object for saving
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	private SensoryItemProtocol saveSensoryItemHelper(SensoryItem s){
		SensoryItemProtocol.Builder sensoryBuilder = SensoryItemProtocol.newBuilder();
		sensoryBuilder.setMFeatureName(s.getFeatureName());
		return sensoryBuilder.build();
	}

	/** After a CaseBase has been processed this method
	 * will return the minimum occurrences, of a given sensory item
	 * type, in a Case.
	 * 
	 * @param item The name of the sensory item
	 * @return The minimum number of occurrences
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public int getMinimum(String item){
		if(item == null){
			throw new IllegalArgumentException("Null value given to SensoryItemDistribution function.");
		}
		
		Integer min = m_min.get(item);
		if(min == null){
			return 0;
		}
		return min.intValue();
	}

	/**
	 * This will save an AgentAction object in the protocol buffer format
	 * 
	 * @param a An AgentAction object to be saved
	 * @return AgentActionProtocol Returns the object that incases the AgentAction object for saving
	 * 
	 * @author Caleb Chan
	 * @since 0.5
	 */

	private AgentActionProtocol saveAgentActionHelper(AgentAction a){
		AgentActionProtocol.Builder actionBuilder = AgentActionProtocol.newBuilder();

		actionBuilder.setMName(a.getActionName());
		return actionBuilder.build();
	}

	/** After a CaseBase has been processed this method
	 * will return the average occurrences, of a given sensory item
	 * type, in a Case.
	 * 
	 * @param item The name of the sensory item
	 * @return The average number of occurrences
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public float getMean(String item){
		if(item == null){
			throw new IllegalArgumentException("Null value given to SensoryItemDistribution function.");
		}
		
		Integer count = m_count.get(item);
		if(count == null || m_numCases == 0){
			return 0;
		}

		return (float)count/(float)m_numCases;
	}

    /** Agent Inputs getter
     *
     * @return the Agent Inputs
     *
     * @author Edgar Acosta
     *
     */

    public AgentInputs getAgentInputs(){
	return aInputs;
    }

    /** Team Name getter
     *
     * @return the Agent Team Name
     *
     * @author Edgar Acosta
     *
     */

    public String getTeamName(){
	return m_teamName;
    }

	/** Returns the name of the feature
	 * 
	 * @return The name of the feature
	 *
	 * @author Michael W. Floyd
	 * @since 0.1
	 */

	public String getFeatureName(){
		return this.m_featureName;
	}

        /** Returns a copy of this sensory item
	 *
	 * @author Edgar Acosta
	 * @since 0.5
	 */

        public SensoryItem copyOfThis(){
	    return new SensoryItem(this.getFeatureName());
	}

       /** returns the feature name
	*
	* @author Edgar Acosta
	* @since 0.5
	*/

       public String toString(){
	   return this.m_featureName;
       }

	/** Calculates the distance between two features. The distance calculation algorithm
	 * used must be set using the SensoryItem.setDistanceCalculation(DistanceCalculation) method
	 * or else an exception will be thrown.
	 * 
	 * @param f The other feature
	 * @return the distance betweent the two features
	 *
	 * @author Michael W. Floyd
	 * @since 0.3
	 *
	 */

	public float pairwiseDistance(SensoryItem f){
		//check the validity of parameters
		if(f == null){
			throw new IllegalArgumentException("A null feature was given.");
		}
		
		//make sure we have a distance calculation algorithm set
		if(SensoryItem.m_distanceCalculation == null){
			throw new IllegalStateException("The distance calculation algorithm has not yet been set.");
		}
		
		//if everything is fine, return the pairwise distance
		return SensoryItem.m_distanceCalculation.pairwiseDistance(this, f);
	}

	/** Calculates the distance penalty for the feature. This is
	 * usually used when a SensoryItem has no matching feature in another
	 * case (unequal number of features).
	 * 
	 * @return The penalty
	 * 
	 * @author Michael W. Floyd
	 * @since 0.3
	 */

	public float penaltyDistance(){
	
		//make sure we have a penalty calculation algorithm set
		if(SensoryItem.m_penaltyCalculation == null){
			throw new IllegalStateException("The penalty calculation algorithm has not yet been set.");
		}
		
		//if everything is fine, return the pairwise distance
		return SensoryItem.m_penaltyCalculation.calculatePenalty(this);
	}

	/** Returns an XML representation of the SensoryItem
	 * 
	 * @return The SensoryItem in XML format
	 * 
	 * @author Michael W. Floyd
	 * @since 0.5
	 */

	public String toXML(){
		String xml = "";
		
		xml += "<SensoryItem>";
		xml += "<FeatureName>";
		xml += this.m_featureName;
		xml += "</FeatureName>";
		xml += "</SensoryItem>";
		
		return xml;
	}

	/** Tests the method when no action of several types have been 
	 * logged and all match perfectly.
	 * 
	 * @author Michael W. Floyd
	 * @throws Exception 
	 * @since 0.3
	 */

	@Test
	public void getClassificationAccuracy_manyTypesPerfect() throws Exception{	
		Method addPair = addPairHack();
		
		//simulate the pairings
		addPair.invoke(this.dummysw, "oneAction", "oneAction");
		addPair.invoke(this.dummysw, "otherAction", "otherAction");
		addPair.invoke(this.dummysw, "otherAction", "otherAction");
		addPair.invoke(this.dummysw, "thirdAction", "thirdAction");
		addPair.invoke(this.dummysw, "thirdAction", "thirdAction");
		
		assertEquals(this.dummysw.getClassificationAccuracy(), 1.0f);
	}

    /**
     * process cascade save/update at the start of a flush to discover
     * any newly referenced entity that must be passed to saveOrUpdate(),
     * and also apply orphan delete
     */

    private void preFlushEntities() throws HibernateException {

        List list = IdentityMap.concurrentEntries(entityEntries);
        //safe from concurrent modification because of how entrySet() is implemented on IdentityMap
        int size = list.size();
        for ( int i=0; i<size; i++ ) {

            Map.Entry me = (Map.Entry) list.get(i);
            EntityEntry entry = (EntityEntry) me.getValue();
            Status status = entry.status;

            if ( status!=LOADING && status!=GONE && status!=DELETED ) {
                Object object = me.getKey();
                cascading++;
                try {
                    Cascades.cascade(this, entry.persister, object, Cascades.ACTION_SAVE_UPDATE, Cascades.CASCADE_ON_UPDATE);
                }
                finally {
                    cascading--;
                }
            }
        }

    }

	/** This method is just a hack so we can directly call our private
	 * method and avoid the high overhead of actually simulating these
	 * events. While this is fairly "dirty", it was done because testing
	 * time was limited, and a quick and dirty approach covered more code
	 * than the clean approach.
	 * 
	 * @return the addPair method that can be directly called.
	 * @throws Exception
	 */

	private Method addPairHack() throws Exception{
		
		Class<StatisticsWrapper> c = StatisticsWrapper.class;
		Method addPair = c.getDeclaredMethod("addPair", new Class[]{String.class, String.class});
		addPair.setAccessible(true);
		
		return addPair;
	}

    /** Checks whether the ParsedLine enclosed contains a value for
     * certain key.
     *
     * It is used to test for information about the event.
     *
     * @param paramName the key name
     * @return true if there is a value associated with the key.
     *
     * @author Edgar Acosta
     *
     */

    public boolean contains(String paramName){
	return line.contains(paramName);
    }

    /** Parses match options sent by the server
     *
     * @param message the option message
     * @param params a string containing the parameters of this message
     *
     * @author Edgar Acosta
     * @since 0.2
     *
     */

    private void parseOptions(String message, String params)
    { //parse an initialization info
	parsed.setSensor(message);
	parsed.setParam("params",params);
	parsed.setCycle(-1);
	ParsingEvent pe=new ParsingEvent(this,parsed);
	for(ParsingEventListener pel:PEListeners) pel.ServerParams(pe);
    }

    /** Parses errors sent by the server
     *
     * @param message the error message
     * @param params a string containing the parameters of this message
     *
     * @author Edgar Acosta
     * @since 0.2
     *
     */

    private void parseError(String message, String params)
    { //parse an error
	parsed.setSensor(message);
	parsed.setParam("error",params);
	parsed.setCycle(-2);
	ParsingEvent pe=new ParsingEvent(this,parsed);
	for(ParsingEventListener pel:PEListeners) pel.Error(pe);
    }

    /**
     * Initialize the flags of the CollectionEntry, including the
     * dirty check.
     */

    private void preFlushCollections() throws HibernateException {

        // Initialize dirty flags for arrays + collections with composite elements
        // and reset reached, doupdate, etc.

        List list = IdentityMap.entries(collectionEntries);
        int size = list.size();
        for ( int i=0; i<size; i++ ) {
            Map.Entry e = (Map.Entry) list.get(i);
           	( (CollectionEntry) e.getValue() ).preFlush( (PersistentCollection) e.getKey() );
        }
    }

    /**
     * Sets new page size for table model to display.
     * @param pageSize
     *        Number of records to display on
     *        one page.
     */

    public void setPageSize(int pageSize){
        this.pageSize = pageSize;
        maxPage = rowCount / this.pageSize;
        if (rowCount % pageSize > 0)
            maxPage++;
        currentPage = 0;
            gotoPage(0);
    }

    /**
     * Returns selected page sie of model.
     * @return
     *        Number of records that are currently displayed on page.
     */

    public int getPageSize(){
        return pageSize;
    }

    /**
     * Set the page of data to display in table.
     * @param pageNumber
     *        Zero-based number of page.
     */

    public void gotoPage(int pageNumber){
        if ((pageNumber < 0)  || (pageNumber > maxPage))
                throw new IndexOutOfBoundsException("Page number incorrect: got "+pageNumber+ "min 0, max "+maxPage);
        currentPage = pageNumber;
        index = pageSize * currentPage;

        length = ((rowCount - index) < pageSize) ? (rowCount - index): (pageSize);

        fireTableStructureChanged();

    }

    /**
     * Set the check values array.
     * @param checkValues
     *        Array containing correct values for cells in table.
     */

        public void setCheckValues(ArrayList<Map<K, V>> checkValues) {
             this.checkValues.clear();
             this.checkValues.addAll(checkValues);
        }

    /**
     * Display page previous to current.
     */

    public void gotoPrevPage(){
        gotoPage(currentPage--);
    }

    /**
     * Returns renderer for table cells depending on
     * it's loacation and status.
     */

    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        if (isSelected){
            setForeground(table.getSelectionForeground());
            setBackground(table.getSelectionBackground());
        }
        else{
            setForeground(table.getForeground());
            setBackground(table.getBackground());
        }
        boolean selected = (Boolean)value; //приводим значение к типу Boolean
        setSelected(selected); //изменяем вид чекбокса соответственно значению
        return this;
    }

    /**
     * Returns number of pages for current data array. Value is calculated from specified
     * page size and cannot be set by user.
     * @return
     *        Number of pages in table model.
     *         
     */

    public int getPageCount(){
        return maxPage;
    }

    /**
     * Gets number of the current page in model.
     * @return
     *        Zero-based number of currently displayed page.
     */

    public int getPageNumber(){
        return currentPage;
    }

    /**
     * Fills table model with data to display.
     * @param data
     *        Array of data to display in table.
     * @param columnNames
     *        Array holding column names for table.
     * @param pageSize
     *        New page size to use.
     */

    public void setData(String[][] data, String[] columnNames, int pageSize){
        this.data = data;
        this.columnNames = columnNames;
        this.isEnabled = new boolean[columnNames.length];
        colCount = data.length;
        if (colCount > 0)
            rowCount = data[0].length;
        setPageSize(pageSize);

    }

    /**
     * Simple warning handler.
     * @param e
     *        Parsing exception to handle.
     * @throws SAXException
     *         if SAX exception occurs.
     */

    public void warning(SAXParseException e) throws SAXException {
        String location = "Warning at [ "+e.getColumnNumber()+","+e.getLineNumber()+"]:";
        System.out.println(e.getMessage());
    }

       /**
        * Return number of columns in table model.
        * @return
        *        A number of columns in input data array.
        */

        public int getColumnCount() {
            return colCount;
        }

    /**
     * Switches validation check for column in table.
     * 
     * @param columnIndex
     *        Index of column in table.
     * @param state
     *        State of validation. True if validation is set, false otherwise.
     */

        private void changeFilterState(int columnIndex, boolean  state){
            if (state) {  // if check is enabled
                manager.updateData(columnIndex,data[columnIndex]); //update validator
                for (int i = 0; i < rowCount; i++) //corrects values for cells in columns
                    data[columnIndex][i] = manager.getValidValue(columnIndex,data[columnIndex][i]);
                fireTableDataChanged();
            }

        }

    /**
     * Returns validation status for first row( boolean value, enabled or disabled),
     * Otherwise returns value of data stored in cell.
     * @param rowIndex
     *        Index of the row to find.
     * @param columnIndex
     *        Index of the column to find.
     * @return
     *        Object stored in the cell.
     */

        public Object getValueAt(int rowIndex, int columnIndex) {
            if (rowIndex == 0)
                return isEnabled[columnIndex];
            else {
                rowIndex+=index;
                if (isEnabled[columnIndex])
                    return manager.getValidValue(columnIndex,data[columnIndex][rowIndex-1]);
                return data[columnIndex][rowIndex-1];
            }

            }

    /**
     * Adds validator object to column. If validation for column will be enabled,
     * this object will check if value is valid.
     * @param columnIndex
     *        Index of the column to assign validator. 
     * @param validator
     *        {@link ru.chsu.dupedetector.base.Validator Validator} object to assign.
     * @return
     *        True if validator assigned successfully, false otherwise.
     */

        public boolean addValidator(int columnIndex, Validator validator){
            if ((columnIndex >= 0 ) && (columnIndex <= columnNames.length -1)) {
                manager.addValidator(columnIndex,validator);
                return true;
            }

            else return false;
        }

    /**
     * Adds editor object to column. If value is incorrect it will be corrected by editor.
     *
     * @param columnName
     *        Name of the column to assign validator.
     * @param editor
     *        {@link ru.chsu.dupedetector.base.Editor Editor} object to assign.
     * @return
     *        True if editor assigned successfully, false otherwise.
     */

    public boolean addEditor(String columnName, Editor editor){
        return addEditor(findColumn(columnName),editor);
    }

    /**
     * Resize component for displaying specified maximum number.
     * @param maxNumber
     *        Maximum number to display.
     */

    public void resizeNumberPanel( int maxNumber){
        int digitCount = 3;
        while ((maxNumber = maxNumber/10) > 0)
            digitCount++;
        this.setMinimumDisplayDigits(digitCount);
    }

    /**
     * Gets validator object assigned for column.
     * @param columnIndex
     *        Index of column in table.
     * @return
     *        Validator object.
     */

    public Validator getValidator(int columnIndex){
        return manager.getValidator(columnIndex);
    }

    /** Copy used in createTransferable.
     * Keeps info about UserObject linked to the node.
     * @param node
     *        TreeNode to copy.
     *@return
     *        Copy of TreeNode.
     * */

    private DefaultMutableTreeNode copy(DefaultMutableTreeNode node) {
        return new DefaultMutableTreeNode(node.getUserObject());
    }

    /**
     * Refreshes table contents using specified charset, start line and splitting regular expression.
     */

    private void refreshData(){
        try {
            countLines();
            readData();
        } catch (IOException e) {
            e.printStackTrace();
        }
        JTableHeader header = owner.getTableHeader();
        owner.setTableHeader(new JTableHeader());
        fireTableStructureChanged();
        fireTableDataChanged();
        owner.setTableHeader(header);

    }

    /**
     * Open file and count lines in it.
     * @throws IOException
     *         if any I/O error occurs.
     */

    private void countLines() throws IOException {
        fileLineCount = 0;
        steamReader = new InputStreamReader(new FileInputStream(this.inputFile),this.charset);
        BufferedReader dataReader = new BufferedReader(steamReader);
        while ( dataReader.readLine() !=null)
            fileLineCount++;
        steamReader.close();
        dataReader.close();
    }

    /**
     * Sets new regular expression to split rows.
     * @param splitRegexp
     *        New regular expression to use.
     */

     public void setSplitRegexp(String splitRegexp) {
         this.splitRegexp = splitRegexp;
         refreshData();
     }

    /**
     * Getter method for split regular expression.
     * @return
     *        Regexp used to split lines of input file by this model.
     */

    public String getSplitRegexp() {
        return splitRegexp;
    }

    /**
     * Returns the row count.
     */

    public int getRowCount() {
        return map.size();
    }

    /**
     * Returns row count of the table
     * @return
     *        Number of lines read from input file.
     */

    public int getRowCount() {
        return fileLineCount - startLine;
    }

    /**
     * Returns the column count.
     */

    public int getColumnCount() {
        return 2;
    }

    /**
     * Returns column count of the table as
     * maximum column count for all rows.
     *
     */

    public int getColumnCount() {
         return fileColumnCount;
    }

    /**
     * Returns the value at.
     */

    public Object getValueAt(int row, int column) {
        Object[] entries=map.entrySet().toArray();
        Map.Entry entry=(Map.Entry)entries[row];
        if (column==0) {
            return entry.getKey();
        } else if (column==1) { // column==1
            return entry.getValue();
        } else {
            throw new IndexOutOfBoundsException(Integer.toString(column));
        }
    }

    /**
     * Returns the column name.
     */

    public String getColumnName(int column) {
        return columnNames[column];
    }

    /**
     * Sets the column names.
     */

    public void setColumnNames(String keyName, String valueName) {
        columnNames= new String[]{keyName, valueName};
    }

    /**
     * Returns the map.
     */

    public Map getMap() {
        return map;
    }

    /**
     * Get character which start the range.
     * @return
     *        First character in range
     *
     *
     */

    public char getMinChar() {
        return minChar;
    }

    /**
     * Returns length of the range.
     * @return
     *        Amount of characters in range.
     */

    public int getLength() {
        return length;
    }

    /**
     * Sets the map.
     */

    public void setMap(Map map) {
        this.map = map;
    }

    /**
     * Returns a reference to the current WizardModel for this Wizard component.
     * @return The current WizardModel for this Wizard component.
     */    

    public WizardModel getWizardModel() {
        return wizard.getModel();
    }

    /**
     * Override this method to provide functionality that will be performed just before
     * the panel is to be displayed.
     */    

    public void aboutToDisplayPanel() {

    }

    /**
     * Override this method to perform functionality when the panel itself is displayed.
     */    

    public void displayingPanel() {

    }

    /**
     * Override this method to perform functionality just before the panel is to be
     * hidden.
     */    

    public void aboutToHidePanel() {

    }    

    /**
     * Returns an instance of the JDialog that this class created. This is useful in
     * the event that you want to change any of the JDialog parameters manually.
     * @return The JDialog instance that this class created.
     */    

    public JDialog getDialog() {
        return wizardDialog;
    }

    /**
     * Returns the owner of the generated javax.swing.JDialog.
     * @return The owner (java.awt.Frame or java.awt.Dialog) of the javax.swing.JDialog generated
     * by this class.
     */    

    public Component getOwner() {
        return wizardDialog.getOwner();
    }

    /**
     * Sets DateFormat of input fields.
     * @param format
     *        New SimpleDateFormat to use.
     */

    public void setFormat(SimpleDateFormat format) {
        this.format = format;
    }

    /**
     * Reaction to mapping table change event. Preview window should be updated
     * to reflect mapping changes
     * @param e
     *        Tablee change event.
     */

    public void tableChanged(TableModelEvent e) {

        makeSample();
    }

    /**
     * Sets the title of the generated javax.swing.JDialog.
     * @param s The title of the dialog.
     */    

    public void setTitle(String s) {
        wizardDialog.setTitle(s);
    }

    /**
     * Makes new preview sample and displays it in browser TextArea.
     */

    private void makeSample(){
        panel.getFileBrowser().setText("");
        Map<String, String> fieldMap;
        fieldMap = model.getMap();
        String[] fields = fieldMap.values().toArray(new String[fieldMap.values().size()]); 
        builder.mapAttributes(columns, fields);
        builder.makeSample(data[0],sampleWriter);
        panel.getFileBrowser().setCaretPosition(0);
    }

    /**
     * Returns the current title of the generated dialog.
     * @return The String-based title of the generated dialog.
     */    

    public String getTitle() {
        return wizardDialog.getTitle();
    }

    /**
     * Fills the destination array from source array. If source is shorter
     * it will be copied to destination untill it filled completely.
     * @param source
     *        Source array to copy data.
     * @param dest
     *        Destination array where objects should be copied to.
     */

    private void  fillArrayLoop(Object[] source, Object[] dest){

        if  (source.length >= dest.length)
        System.arraycopy(source,0,dest,0,dest.length);
        else {
            System.arraycopy(source,0,dest,0,source.length);
            int length = source.length;
            int counter = 0;
            while (length < dest.length) {
                dest[length] = source[counter];
                counter++;
                length++;
                if (counter == source.length)
                    counter = 0;
            }
        }


    }

    /**
     * Sets the modality of the generated javax.swing.JDialog.
     * @param b the modality of the dialog
     */    

    public void setModal(boolean b) {
        wizardDialog.setModal(b);
    }

    /**
     * Check if file name is valid.
     * @param fileName
     *        Name of the file to check.
     */

    public void showButtons(String fileName){
        if (FileValidate.canWrite(fileName))  {
            getWizard().setNextFinishButtonEnabled(true);
            Core appCore = Core.getInstance();
            appCore.setOutputFile(new File(fileName));
            appCore.setOutputWriter(writer);

        }

        else
            getWizard().setNextFinishButtonEnabled(false);
    }

    /**
     * Returns the modality of the dialog.
     * @return A boolean indicating whether or not the generated javax.swing.JDialog is modal.
     */    

    public boolean isModal() {
        return wizardDialog.isModal();
    }

    /**
     * Convienence method that displays a modal wizard dialog and blocks until the dialog
     * has completed.
     * @return Indicates how the dialog was closed. Compare this value against the RETURN_CODE
     * constants at the beginning of the class.
     */    

    public int showModalDialog() {
        
     //   wizardDialog.setModalityType(Dialog.ModalityType.TOOLKIT_MODAL);
        wizardDialog.pack();
        wizardDialog.setModal(true);
        wizardDialog.setVisible(true);
        return returnCode;
    }

    /**
     * Returns the current model of the wizard dialog.
     * @return A WizardModel instance, which serves as the model for the wizard dialog.
     */    

    public WizardModel getModel() {
        return wizardModel;
    }

    /**
     * Getter for field containing output file name.
     * @return
     *       JTextArea used to keep output file name.
     */

    public JTextField getFileNameField(){
        return content.getFileNameField();
    }

    /**
     * Getter for preview text area component.
     * @return
     *        JTextArea used to make preview of .xml file.
     */

    public JTextArea getFileBrowser(){
        return content.getContentBrowser();
    }

    /**
     * Getter for mapping table.
     * @return
     *        Table containing mapping pairs of .xml attributes and MappingResult columns.
     */

    public JTable getContentTable(){
        return content.getMapTable();
    }

    /**
     * Getter for field containing output file name.
     * @return
     *       JTextArea used to keep output file name.
     */

    public JTextField getFileNameField() {
        return fileNameField;
    }

    /**
     * Content panel getter panel.
     * @return
     *        Dialog window containing all gui components.
     *        @see ru.chsu.writer.XMLwriter.gui.XMLWriterGUI
     */

    public XMLWriterGUI getContent(){
        return content;
    }

    /**
     * Getter for preview text area component.
     * @return
     *        JTextArea used to make preview of .xml file.
     */

    public JTextArea getContentBrowser() {
        return contentBrowser;
    }

    /**
     * Add a Component as a panel for the wizard dialog by registering its
     * WizardPanelDescriptor object. Each panel is identified by a unique Object-based
     * identifier (often a String), which can be used by the setCurrentPanel()
     * method to display the panel at runtime.
     * @param id An Object-based identifier used to identify the WizardPanelDescriptor object.
     * @param panel The WizardPanelDescriptor object which contains helpful information about the panel.
     */    

    public void registerWizardPanel(Object id, WizardPanelDescriptor panel) {
        
        //  Add the incoming panel to our JPanel display that is managed by
        //  the CardLayout layout manager.
        
        cardPanel.add(panel.getPanelComponent(), id);
        
        //  Set a callback to the current wizard.
        
        panel.setWizard(this);
        
        //  Place a reference to it in the model. 
        
        wizardModel.registerPanel(id, panel);
        
    }  

    /**
     * Mapping setup method. Every attribute in xml schema
     * is associated with column in mpping output.
     * @param columnNames
     *        Array containing column names from mapping output.
     * @param attributes
     *        Array containing names of columns that should be mapped on every .xml attribute.
     *
     */

    public void mapAttributes(String[] columnNames, String[] attributes) {
        indexesMap.clear();
        for (int i = 0; i < attributes.length; i++ ){
            String name = this.attributes[i];
            indexesMap.put(name,findIndex(attributes[i],columnNames));
        }
    }

    /**
     * Displays the panel identified by the object passed in. This is the same Object-based
     * identified used when registering the panel.
     * @param id The Object-based identifier of the panel to be displayed.
     */    

    public void setCurrentPanel(Object id) {

        //  Get the hashtable reference to the panel that should
        //  be displayed. If the identifier passed in is null, then close
        //  the dialog.
        
        if (id == null)
            close(ERROR_RETURN_CODE);
        
        WizardPanelDescriptor oldPanelDescriptor = wizardModel.getCurrentPanelDescriptor();
        if (oldPanelDescriptor != null)
            oldPanelDescriptor.aboutToHidePanel();
        
        wizardModel.setCurrentPanel(id);
        wizardModel.getCurrentPanelDescriptor().aboutToDisplayPanel();
        
        //  Show the panel in the dialog.
        
        cardLayout.show(cardPanel, (String)id);
        wizardModel.getCurrentPanelDescriptor().displayingPanel();        
        
        
    }

    /**
     * Clears generated user list.
     */

    public void reset(){
        users.clear();
    }

    /**
     * Generates record for one user only. It can be used to make preview of .xml file contents.
     * @param fields
     *        Row of mapping output to create sample.
     * @param out
     *        Output stream to marshall data.
     */

    public void makeSample(String[] fields, Writer out){
        UserList sampleList = new UserList();
        List<UserList.User> sample = sampleList.getUser();
        sample.add(createUser(fields));
        JAXBElement<UserList> sampleElement = new JAXBElement<UserList>(name,UserList.class,null,sampleList);
        JAXB.marshal(sampleElement,out);




    }

    /**
     * Opens file output streeam with given file name.
     * @param fileName
     *        String containing name of output file.
     * @throws IOException
     *         if any I/O error occurs.
     */

    public void openFile(String fileName) throws IOException {
        output = new FileOutputStream(fileName,false);


    }

    /**
     * Close file and close associated resources.
     * @throws IOException
     *         if any i/o error occurs.
     */

    public void close() throws IOException {
        output.close();
    }

    /**
     * Marshall mapping output to file.
     * @param result
     *        Mapping result as two-dimensional array of strings.
     * @throws IOException
     */

    public void writeData(MappingResult result) throws IOException {
        builder.reset();
        for (String[] row : result.getData()){
            builder.addUser(row);
        }
            builder.writeData(output);
    }

    /**
     * Retrieves the last return code set by the dialog.
     * @return An integer that identifies how the dialog was closed. See the *_RETURN_CODE
     * constants of this class for possible values.
     */    

    public int getReturnCode() {
        return returnCode;
    }

   /**
     * Mirrors the WizardModel method of the same name.
     * @return A boolean indicating if the button is enabled.
     */  

    public boolean getBackButtonEnabled() {
        return wizardModel.getBackButtonEnabled();
    }

    /**
     * If fileName is updated it must be validated
     * @param e
     *        Update event.
     */

    public void insertUpdate(DocumentEvent e) {
        showButtons(fileNameField.getText());

    }

    /**
     * If file name is changed it must be validated
     * @param e
     *        Remove event
     */

    public void removeUpdate(DocumentEvent e) {
        showButtons(fileNameField.getText());

    }

   /**
     * Mirrors the WizardModel method of the same name.
     * @param newValue The new enabled status of the button.
     */ 

    public void setBackButtonEnabled(boolean newValue) {
        wizardModel.setBackButtonEnabled(newValue);
    }

   /**
     * Mirrors the WizardModel method of the same name.
     * @return A boolean indicating if the button is enabled.
     */ 

    public boolean getNextFinishButtonEnabled() {
        return wizardModel.getNextFinishButtonEnabled();
    }

   /**
     * Mirrors the WizardModel method of the same name.
     * @param newValue The new enabled status of the button.
     */ 

    public void setNextFinishButtonEnabled(boolean newValue) {
        wizardModel.setNextFinishButtonEnabled(newValue);
    }

   /**
     * Mirrors the WizardModel method of the same name.
     * @return A boolean indicating if the button is enabled.
     */ 

    public boolean getCancelButtonEnabled() {
        return wizardModel.getCancelButtonEnabled();
    }

    /**
     * Mirrors the WizardModel method of the same name.
     * @param newValue The new enabled status of the button.
     */ 

    public void setCancelButtonEnabled(boolean newValue) {
        wizardModel.setCancelButtonEnabled(newValue);
    }

    /**
     * Dialog initialization method. Constructs organizational unit tree from mapping
     * result and draws it in JTree component.
     * @param result
     *        Mapping output result.
     */

    public void initDialog(MappingResult result){
        String[] columns = result.getColumns();
        String data[][] = result.getData();
        Set<String> ouNames = new HashSet<String>();
            for (String[] row : data){
              OUNode node = new OUNode(columns,row);
              String name = node.toString();
              if (!ouNames.contains(name))  {
                  root.add(new DefaultMutableTreeNode(node));
                  ouNames.add(name);
              }
            }
            availableFields.setModel(new DefaultComboBoxModel<String>(columns));
    }

    /**
     * Resets the tree creating only default root node.
     */

    public void clearTree(){
        OUNode rootNode = new OUNode(new String[]{"ou"},new String[]{"Domain Controllers"});
        root = new DefaultMutableTreeNode(rootNode);
    }

    /**
     * Opens file for output. Buffered writer is used for output.
     * @param fileName
     *        String containing name of output file.
     * @throws IOException
     */

    public void openFile(String fileName) throws IOException {
        writer = new BufferedWriter(new FileWriter(fileName, false));
    }

    /**
     * Close file and free all allocated resources
     * @throws IOException
     *         If any I|O error occured
     */

    public void close() throws IOException {
        writer.close();
    }

    /**
     * Generates LDIF script string from mapping output.
     * @param result
     *        MappingResult object containing mapping output data.
     * @return
     *        Generated LDIF script.
     */

    public String generateScript(MappingResult result){
        UserFactory factory = new UserFactory("dc=edo ,dc=chsu, dc=ru",
                Arrays.asList("cn","sn","userPrincipalName",
                        "userAccountControl","unicodePwd", "givenName"));
        factory.initFactory(result);
        StringBuilder script = new StringBuilder();
        for( String[] row : result.getData()){
            try {

                script.append(documentBuilder.createAddStatement(factory.createClass(row)));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return script.toString();
    }

    /**
     * Writes mapping result to an output LDIF file.
     * @param result
     *        Mapping result as two-dimensional array of strings.
     * @throws IOException
     *         if any I|o error happens.
     */

    public void writeData(MappingResult result) throws IOException {
       writer.write(generateScript(result));
    }

    /**
     * Stores indexes of user attributes columns in mapping output.
     * 
     * @param result
     *        Object holding all mapping output data.
     */

    public void initFactory(MappingResult result) {
        this.columns = result.getColumns();
        for (int i = 0; i < columns.length; i++){ //searches for dn-attributes
            int index =Arrays.binarySearch(dnAttributes,columns[i]); 
            if (index > -1)
                dnIndexes[index] = i; // stores found indexes
        }
        
    }

    /**
     * Generates attribute-values specification section for LDIFCLass object
     *
     * Attributes are written
     * {@code
     * attrval-spec             = AttributeDescription value-spec SEP
     * AttributeDescription     = AttributeType [";" options]
     * value-spec               = ":" (    FILL 0*1(SAFE-STRING) /
     * ":" FILL (BASE64-STRING) /
     * "<" FILL url)
     * }
     * @param object
     *        LDIFClass object which will be marshalled to output file.
     * @return
     *        generated section as a StringBuilder.
     */

    private StringBuilder makeAttributeDescription(LDIFClass object){
        StringBuilder builder = new StringBuilder();
        for (String key : object.keySet()) {
            String[] values = object.get(key);
            for (String value : values){
                builder.append(key);
                builder.append(":");
                builder.append(generateSafeString(value));
                builder.append(SEP);
            }
        }
        return builder;
    }

    /**
     * Creates LDIF user class from mapping output row.
     * @param data
     *        String array containing values of attributes from one row of mapping output.
     * @return
     *        new LDIF user class object
     */

    public LDIFClass createClass(String[] data) {
        LDIFClass result = new LDIFClass();
        result.setDN(makeDN(data)); //make and store DN
        result.put("objectclass","user"); //store object class

        for (int i = 0; i < columns.length; i++ )  //for all attributes in row
            if (attributeNames.contains(columns[i])) // if this attribute is an user attributes
              result.put(columns[i],data[i]); //store it
        return result;
    }

    /**
     * Creates ldif add statement for LDIFClass statement
     * {@code
     * ldif-change-record = dn-spec SEP *control changerecord
     * dn-spec = "dn:" (FILL distinguishedName /
     * ":" FILL base64-distinguishedName)
     * change-add = "add" SEP 1*attrval-spec
     * }
     * @param object
     *        LDIFClass object containing dn value and attributes specification.
     * @return
     *        Generated LDIF record for object.
     *
     */

    public StringBuilder createAddStatement(LDIFClass object) {
        StringBuilder builder = new StringBuilder();
        builder.append("dn:");
        builder.append(generateSafeString(object.getDN()));
        builder.append(SEP);
        builder.append("changetype:add");

        builder.append(SEP);
        builder.append(makeAttributeDescription(object));
        builder.append(SEP);
        return builder;
    }

    /**
     * Sets specified sheet name for output sheet in workbook
     * @param sheetName
     *        Name specified for the sheet
     */

    public void setSheetName(String sheetName) {
        this.sheetName = sheetName;
    }

    /**
     *  Setter for selectedColumns array
     * @param selectedColumns
     *        First array contains indexes of columns, that should be exported to output
     *        file. Second array contains column names.
     * @param columnNames
              Array containing column names data.
     */

    public void setSelectedColumns(int[] selectedColumns,String[] columnNames){
        this.selectedColumns = selectedColumns;
        this.columnNames = columnNames;
    }

    /**
     * Saves all modifications in the workbook and closes associated file.
     * @throws IOException
     *         if any I?o error occurs.
     */

    public void close() throws IOException {
        try {
            workbook.write();
            workbook.close();
        } catch (WriteException e) {
            throw new IOException(e);
        }
    }

    /**
     * Writes one row of values to the specified sheet in workbook.
     * Only values for selected columns will be written.
     * @param data
     *        Array of values
     * @throws IOException
     *         if I/O exception occured while this operation.
     */

    private void writeRow(String[] data) throws IOException {
        int colCounter = 0;
        for (int index : selectedColumns){// for all indexes of selectedColumns
            try {       // write values to sheet as text label
                sheet.addCell(new Label(colCounter,activeRow,data[index]));
                colCounter++; //increase column number
            } catch (WriteException e) {
                throw new IOException(e);
            }
        }

    }

    /**
     * Writes all mapping results to the .xls workshhet
     * @param result
     *        Mapping result as two-dimensional array of strings.
     * @throws IOException
     */

    public void writeData(MappingResult result) throws IOException {

        activeRow = 0;
        int colCounter = 0;
        String columnNames[] = result.getColumns(); // getting column names
        for ( int index : selectedColumns)
            try {  //writing selected column names
                sheet.addCell(new Label(colCounter,activeRow,columnNames[index]));
                colCounter++;
            } catch (WriteException e) {
                throw new IOException(e.getMessage(),e);
            }
        activeRow++;
        for (String[] row : result.getData()){//for all selected rows of mapping output
            writeRow(row); //write the row to worksheet
            activeRow++;
        }


    }

    /**
     * Getter for content holding object.
     * @return
     *        reference to object holding all GUI data.
     */

    public XLSWriterGUI getContent(){
        return content;
    }

    /**
     * Charset getter method.
     * @return
     *     Charset used for reading input file.
     */

    public Charset getCharset() {
        return charset;
    }

    /**
     * Charset setter method.
     * 
     * @param charset
     *        New charset to use.
     *        @see java.nio.charset.Charset
     */

     public void setCharset(Charset charset) {
        this.charset = charset;
    }

    /**
     * Getter for starting line number.
     * @return
     *        Zero based line number.
     */

     public int getStartLine() {
        return startLine;
    }

    /**
     * Sets new start line number of the file. All lines before this line will be skipped.
     * @param startLine
     *        New start line number.
     */

    public void setStartLine(int startLine) {
        if (startLine < 0)   //line number must be non-negative
            this.startLine = 0;
        else
          this.startLine = startLine;
    }

    /**
     * Refreshes preview when import settings are changed
     * @param e
     *        Change event to handle.
     */

    public void stateChanged(ChangeEvent e) {
        refreshFileContent();
    }

    /**
     * Refreshes preview when import settings are changed
     * @param e
     *        Action event to handle.
     */

    public void actionPerformed(ActionEvent e) {
        refreshFileContent();
    }

    /**
     * Sets split regexp for input file.
     * @param splitRegexp
     *          String new splitting regexp.
     */

    public void setSplitRegexp(String splitRegexp) {
        this.splitRegexp = splitRegexp;
    }

    /**
     * Sets names for attributes read from input file.
     * @param columns
     *          Array containing names of attributes.
     */

    public void setColumns(String[] columns) {
        this.columns = columns;
    }

    /**
     * Updates preview window where separator symbol is changed.
     * @param e
     *        ActionEvent to process.
     */

    public void actionPerformed(ActionEvent e) {
        readerPanel.getContent().updateSeparators();
    }

    /**
     * Skips all lines before start line.
     *
     * @throws FileNotFoundException
     *          if file not found.
     * @throws NoSuchElementException
     *          if file is empty.
     *
     */

    private void gotoStartLine() throws FileNotFoundException, NoSuchElementException {
        inputScanner = new Scanner(getFile(),charset.name());
                int lineCount = startLine;
        while (lineCount-- > 0)
                inputScanner.nextLine();
    }

    /**
     * Getter method for content panel.
     * @return
     *        Panel containing all gui components related to text reader setup.
     */

    public FileReaderGUI getReaderGUI() {
        return readerGUI;
    }

    /**
     * Getter for content panel.
     * @return
     *       Panel with all visual components for this wizard page.
     */

    public FileSeparator getContent() {
        return GUI;
    }

    /**
     * Returns JSpinner holding the starting line number of the input file.
     */

    public JSpinner getImportStringSpinner() {
        return importStringSpinner;
    }

    /**
     * Returns preview table.
     * @return
     *      JTable containing text file split into rows according to selected separator symbol.
     */

   public JTable getFiletable(){
       return GUI.getFileTable();
   }

    /**
     * Returns selected charset.
     * @return
     *        Returns charset object currently selected in charset combo box.
     */

    public Charset getCharset(){
        return (Charset) charsetComboBox.getSelectedItem();
    }

    /**
     * Returns file preview table.
     */

    public JTable getFileTable() {
        return fileTable;
    }

    /**
     * Returns input file associated with reader.
     * @return
     *        Input file.
     *        @see java.io.File
     */

    public File getFile() {
        return file;
    }

    /**
     * Sets checkbox action listner for all checkboxes on panel
     * @param a
     *         Action listener to set.
     */

    public void setCheckboxesActionListener(ActionListener a){
        for (Component component : separators.getComponents()) {
            if (component instanceof JCheckBox)
            {
                ((JCheckBox)component).addActionListener(a);
            }
        }
    }

    /**
     * Set the file used as input for reader.
     * @param file
     *        New input file.
     */

    public void setFile(File file) {
        this.file = file;
    }

    /**
     * Set the table model for preview JTable.
     * @param fileViewModel
     *        New table model to set.
     */

    public void setPreviewModel(TableModel fileViewModel) {
        fileTable.setModel(fileViewModel);
    }

    /**
     * Set selected worksheet to import data.
     * @param sheetIndex
     *        New  index of sheet. 
     */

    public void setWorkSheet(int sheetIndex){
        if (sheetIndex < sheetCount) {
            this.sheetIndex = sheetIndex;
            worksheet = workbook.getSheet(sheetIndex);
        }
    }

    /**
     * Returns the current index of sheet in workbook.
     * @return
     *        Index of selected sheet in the workbook.
     */

    public int getSheetIndex() {
        return sheetIndex;
    }

    /**
     * Returns panel containing all gui-components on this dialog ppage.
     * @return
     *        COntent panel.
     */

    public JPanel getContentPane() {
        return contentPane;
    }

    /**
     * Get the name of current sheet.
     * @return
     *        String containing sheet name.  
     */

    public String getSheetName(){
        return workbook.getSheet(sheetIndex).getName();
    }

    /**
     * Updates table model where selected separator is changed.
     */

    public void updateSeparators(){
        String result ="";
        for (Component component : separators.getComponents()) { // determine what checkboxes are checked
            boolean isSelected = (component instanceof JCheckBox) && ((JCheckBox)component).isSelected();
            if (isSelected)
                result += ((JCheckBox)component).getActionCommand(); //add corresponding regexp to result
        }
        if (result.length() > 0) //if some regexp is selected
            result ="["+result+"]"; // quote it
        else
            result =  "/.?/"; // otherwise use default value
        FileViewModel model = (FileViewModel) fileTable.getModel();
        model.setSplitRegexp(result);      //update model
        ColumnPacker.packColumns(fileTable, 3);  //pack table
    }

    /**
     * Return the number of sheets in workbook.
     * @return
     *        Number of sheets in opened workbook.
     * */

    public int getSheetCount(){
        return sheetCount;
    }

    /**
     * Set selected columns indexes.
     * @param selectedColumns
     *        Array containing selected columns indexes.
     * @param columnNames
     *        Names of columns to use for this columns.
     * @throws IndexOutOfBoundsException
     *         If column index is not within sheet column range.
     */

    public void setSelectedColumns(int[] selectedColumns, String[] columnNames) throws IndexOutOfBoundsException{
        this.selectedColumns = selectedColumns;
        int maxColumns = worksheet.getColumns();
        for (int selectedColumn : selectedColumns) {
            if ((selectedColumn < 0 ) || (selectedColumn >= maxColumns))
                throw new IndexOutOfBoundsException("Неверный индекс столбца "+selectedColumn+ " >= "+maxColumns);
        }
        this.columnNames = columnNames;

    }

    /**
     * Selects all the columns on sheet and get column names as headers
     * @throws IndexOutOfBoundsException
     *         If column index is not within sheet column range.
     */

    public void setSelectedColumns() throws IndexOutOfBoundsException{
        int maxColumns = worksheet.getColumns();
        this.selectedColumns = new int[maxColumns];
        this.columnNames = new String[selectedColumns.length];

        for (int i = 0; i < selectedColumns.length; i++) {
            selectedColumns[i] = i;
            columnNames[i] = worksheet.getCell(i,0).getContents();
        }
    }

    /**
     * Getter for preview table
     * @return
     *        JTable displaying .xls data.
     */

    public JTable getContentTable() {
        return contentTable;
    }

    /**
     * Getter for label containing sheet name.
     * @return
     *       JLabel component used to display sheet name.
     */

    public JLabel getSheetName() {
        return sheetName;
    }

    /**
     * Get spinner used to display selected sheet index.
     * @return
     *          JSpinner object used to change sheet index.
     */

    public JSpinner getSheetSpinner() {
        return sheetSpinner;
    }

    /**
     * Get content panel with all GUI - components.
     * @return
     *        Panel with all content related to Xls-reader.
     */

    public XLSReaderGUI getContent(){
        return content;
    }

    /**
     * Set number of sheet in workbook to display.
     * @param sheetNumber
     *        New sheet number.
     */

    public void setSheet(int sheetNumber){
        if (sheetNumber < sheetCount) { // check if number is valid
            workSheet = workbook.getSheet(sheetNumber); // change actual worksheet
            sheetIndex = sheetNumber;
            fireTableStructureChanged(); // fire table change events
            fireTableDataChanged();
        }
    }

    /**
     * Get name of selected worksheet.
     */

    public String getSheetName(){
        return workSheet.getName();
    }

    /**
     * Returns file displayed by the model.
     * @return
     *        File object describing input file.
     *        @see java.io.File
     */

    public File getFile() {
        return filename;
    }

    /**
     * Updates preview table when selected sheet is changed
     * @param e
     *        Change event to handle.
     */

    public void stateChanged(ChangeEvent e) {
        JSpinner source = (JSpinner)e.getSource();
        xlsModel.setSheet((Integer)source.getValue());  //update sheet
        panel.getContent().getSheetName().setText(xlsModel.getSheetName()); //update name
        JTableHeader header = new EditableTableHeader(contentTable.getColumnModel());
        contentTable.setTableHeader(header); //set up the header
        ColumnPacker.packColumns(contentTable, 3);
    }

    /**
     * Get rowCount from the worksheet.
     * @return
     *        Number of rows in current worksheet.
     */

    public int getRowCount() {
        return workSheet.getRows()-1;
    }

    /**
     * Action handler for line amount change. If number of lines on the page is changed
     * number of available pages is changed too.
     * @param e
     *        Aaction event to handle.
     */

    public void actionPerformed(ActionEvent e) {
        refreshPageCounter();
    }

    /**
     * Get colCount from worksheet.
     * @return
     *        Number of columns in current worksheet.
     */

    public int getColumnCount() {
        return workSheet.getColumns();
    }

    /**
     * Get value of specified cell in worksheet.
     * @param rowIndex
     *        Row for cell.
     * @param columnIndex
     *        Column for cell.
     * @return
     *        Cell value.
     */

    public Object getValueAt(int rowIndex, int columnIndex) {
        return workSheet.getCell(columnIndex, rowIndex+1).getContents();//not displaying the header row
    }

    /**
     * Refreshes table contents when page number is changed.
     * @param e
     *        JSpinner change event to handle.
     */

    public void stateChanged(ChangeEvent e) {
           int pageNumber = (Integer)recordSpinner.getValue() - 1; // get selected page number from event
           model.gotoPage(pageNumber);// change model state
    }

    /**
     * Updates available pages counter when number of records in table or
     * to display on one page is changed.
     *
     */

    private void refreshPageCounter(){

        int pageSize = panel.getContent().getRecordsPerPage();
        model.setPageSize(pageSize);
        int pageCount = model.getPageCount();
        recordSpinner.setModel(new SpinnerNumberModel(1,1,pageCount,1));
        panel.getContent().getAmount().setText(Integer.toString(pageCount));


    }

    /**
     * Changes the way how mapping output is stored in memory.
     *
     */

    private void reshapeData() {
        String[][] newArray;
        newArray = new String[linesCount][];
        for (int i = 0; i < newArray.length; i++){
            newArray[i] = new String[columns.length];
            for (int j = 0; j < columns.length; j++)
                newArray[i][j] = displayData[j][i];
        }
        displayData = newArray;
    }

    /**
     * Get content panel holding all gui elements on panel.
     * @return
     *        JPanel with all content.
     */

    public MappingSettings getContent() {
        return content;
    }

    /**
     * Searches for plugin class in list of available plugins.
     * @param mapperClass
     *        Mapper class to search.
     * @return
     *        Zero-based list index, -1 if class is not found.
     */

    private int findMapperIndex(Class mapperClass){
        ListModel<MapperDecorator> model = pluginsList.getModel();
        int length = model.getSize();
        for (int i = 0;i < length; i++ ){
            AttributeMapper current = model.getElementAt(i).getDelegate();
            if (current.getClass().equals(mapperClass))
                return i;

        }
        return -1;
    }

    /**
     * Getter for page amount label.
     * @return
     *        JLabel component used to display number of pages in table model.
     */

    public JLabel getAmount() {
        return amount;
    }

    /**
     * Get amount of records to display on one page.
     * @return
     *        Amount of records to display.
     */

    public Integer getRecordsPerPage() {
        return Integer.parseInt((String)recordsPerPage.getSelectedItem());
    }

    /**
     * Get combo box used to display records count.
     * @return
     *        JComboBox component used to display records count.
     */

    public JComboBox getRecordsComboBox(){
        return recordsPerPage;
    }

    /**
     * Getter for spinner component containing record number.
     * @return
     *        JSpinner used for record number display.
     */

    public JSpinner getRecordSpinner() {
        return recordSpinner;
    }

    /**
     * Preview JTable getter.
     * @return
     *       Returns JTable component used to display preview data.
     */

    public JTable getResultsTable() {
        return resultsTable;
    }

            /**
             * Selection handler for plugin list. Changes sekected plugin specific settings panel.
             * @param e
             *        Selection event to handle.
             */

            public void valueChanged(ListSelectionEvent e) {
                //retrieve dialog window for selected plugin from manager
                currentDialog = dialogManager.getDialog(pluginsList.getSelectedValue().getDelegate());
                if (currentDialog==null) { //if dialog window is not found
                    configPanel.removeAll();
                    configPanel.add(defaultPanel); //display default panel
                    configPanel.repaint();
                }
                else  {
                     configPanel.removeAll();   //otherwise display dialog for mapper
                     configPanel.add(currentDialog.getConfigPanel());
                     configPanel.repaint();
                }
                pack();
            }

    /**
     * Custom GUI components initialization procedure
     */

    private void createUIComponents() {

        recordSpinner = new JSpinner();
        resultsTable = new JTable();
        resultsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
    }

    /**
     * Set up available attributes list for plugins to use.
     * @param collection
     *        Collection of AttributeBean objects containing attribute info.
     */

    public void setAvailableAttributes(Collection<AttributeBean>collection){
        fieldList.removeAll();
        DefaultListModel<String> model = (DefaultListModel<String>) fieldList.getModel();
        for (AttributeBean bean : collection)
            model.addElement(bean.getName());
    }

    /**
     * Setup and shows add mapper dialog.
     * @param bean
     *        AttributeBean to display in add mapper dialog
     *
     */

    private void showAddDialog(AttributeBean bean){
        DefaultListModel<AttributeBean> model =
                (DefaultListModel<AttributeBean>) availableAttributesList.getModel();
       List<AttributeBean> list = Collections.list(model.elements());
       model = (DefaultListModel<AttributeBean>) usedAttributesList.getModel();
       list.addAll(Collections.list(model.elements()));

         addDialog.setAvailableAttributes(list);
         addDialog.setData(bean);

         addDialog.pack();
         addDialog.setVisible(true);
         addDialog.getData(bean);

    }

    /**
     * Creates new plugin object based on it's class.
     * @param mapperClass
     *        Actual class of the plugin.
     * @return
     *         New instance of plugin with default settings.
     * @throws PluginConfigurationException
     *         if such mapper class is not found.
     */

    public AttributeMapper createPlugin(Class<? extends AttributeMapper> mapperClass) throws PluginConfigurationException {
        boolean isFound = pluginsMap.values().contains(mapperClass);
        if (!isFound)
            throw new PluginConfigurationException(mapperClass) ;
        AttributeMapper result;
        try {
            result = mapperClass.newInstance();//инициализируем новый экземпляр
        } catch (InstantiationException e) {
            throw new PluginConfigurationException(mapperClass);
        } catch (IllegalAccessException e) {
             throw new PluginConfigurationException(mapperClass);
        }
        return result;
    }

    /**
     * Returns true if tree contains specified string value.
     * @param value
     *        value to search.
     * @return
     *        True if tree contains value, false otherwise.
     */

    public boolean contains(String value){
        return value.equals(data) || parent != null && parent.contains(value);
    }

    /**
     * Custom UI initialization procedure.
     */

    private void createUIComponents() {
        // TODO: place custom component creation code here
        availableAttributesList = new JList<AttributeBean>();
        usedAttributesList = new JList<AttributeBean>();

        availableAttributesList.setModel(new DefaultListModel<AttributeBean>());
        usedAttributesList.setModel(new DefaultListModel<AttributeBean>());
        addDialog = new AddMapper();
        addDialog.setModal(true);
        addDialog.setLocation(this.getX(),this.getY());
    }

    /**
     * Adds child to tree checking for cyclic dependence.
     * @param value
     *        Value to store in child node.
     * @throws DependencyException
     *         If value is already found in tree.
     */

    public void addChild(String value)throws DependencyException {
        if (!contains(value)){
            childs.add(new DependencyTree(this,value));
        } else throw new DependencyException("Циклическая зависимость для атрибута "+value);

    }

    /**
     * Adds array of values to tree.
     * @param values
     *        Values to add.
     * @throws DependencyException
     *         if value is found in tree.
     */

    public void addChilds(String[] values) throws DependencyException {
        for (String value : values) {
            addChild(value);
        }

    }

    /**
     * Checks if attribute is cyclic dependent form itself, e.g.
     * attribute that used for it's generation uses this attribute as base attribute.
     * @param attributeName
     *        Name of attribute to check.
     * @param parent
     *        Constructed Dependency tree for this attribute.
     *        @see ru.chsu.mapper.dependence.DependencyTree
     * @throws ru.chsu.mapper.dependence.DependencyException
     *         if attribute is self-dependent,
     */

    private void isCyclicDependent(String attributeName, ru.chsu.mapper.dependence.DependencyTree parent)throws ru.chsu.mapper.dependence.DependencyException {
            ru.chsu.mapper.dependence.DependencyTree tree = new ru.chsu.mapper.dependence.DependencyTree(parent,attributeName);
            AttributeBean attributeBean = config.get(attributeName);
            AttributeMapper plugin = attributeBean.getMapper();
            if (plugin != null){
                String[] dependencies = attributeBean.getMapper().getDependencies();
                tree.addChilds(dependencies);
                for (ru.chsu.mapper.dependence.DependencyTree child : tree.getChilds()) {
                    isCyclicDependent(child.getData(), tree);
                }
            }
    }

    /**
     * Checks all available attributes for cyclic dependency.
     * @param attributes
     *        Collection of attributes to check.
     * @throws ru.chsu.mapper.dependence.DependencyException
     *         if cyclic dependency is found.
     */

    public void checkDependencies(Collection<String> attributes) throws ru.chsu.mapper.dependence.DependencyException {
        for (String attribute : attributes) {
            isCyclicDependent(attribute,null);
        }
    }

    /**
     * Input attributes map setter.
     */

    public void setInputAttributes(Map<String, String> inputAttributes) {
        this.inputAttributes = inputAttributes;
    }

    /**
     * Configures mapper using specified file name.
     * @throws DependencyException
     *         If some cyclic dependency is found in configuration file.
     * @throws PluginConfigurationException
     *         If configuration file is invalid or cannot be read.
     *
     * @param configFileName
     *        Name of the file to use.
     */

    private void configureMappers(String configFileName) throws DependencyException, PluginConfigurationException{
        ConfigParser parser;
        try {
            parser = new ConfigParser(configFileName);
        } catch (IOException e) {
            throw new PluginConfigurationException("Error: configuration file cannot be read");
        } catch (ParserConfigurationException e) {
            throw new PluginConfigurationException("Error: configuration file structure is invalid");
        }
        try {
            config = parser.loadAttributes();
        } catch (PluginConfigurationException e) {
            e.printStackTrace();

        }
        checkDependencies(config.keySet());
    }

    /**
     * Sets specified mapper configuration to use for attribute.
     * @param field
     *        Name of attribute.
     * @param mapperBean
     *        Attribute bean describing attribute generation settings.
     */

    public void setMapper(String field, AttributeBean mapperBean){
        config.put(field, mapperBean);
    }

    /**
     * Replaces method parameters with TRMI stubs as needed. See {@link
     * trmi.Naming#getParameterStubIfNeeded(Object, Class)} for more details.
     */

    private void convertNonSerializableParams(Object[] params) {
        // Happens when the method is parameter-less
        if (params == null) {
            return;
        }

        for (int i = 0; i < params.length; i++) {
            params[i] = Naming.getParameterStubIfNeeded(params[i]);
        }
    }

    /**
     * add a collection we just loaded up (still needs initializing)
     */

    private void addUninitializedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {
        CollectionEntry ce = new CollectionEntry(persister, id, flushing);
        collection.setCollectionSnapshot(ce);
        addCollection(collection, ce, id);
    }

    /**
     * add a detached uninitialized collection
     */

    private void addUninitializedDetachedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {
        CollectionEntry ce = new CollectionEntry(persister, id);
        collection.setCollectionSnapshot(ce);
        addCollection(collection, ce, id);
    }

    /**
     * associate a holder with an array - called after loading array
     */

    public void addArrayHolder(ArrayHolder holder) {
        //TODO:refactor + make this method private
        arrayHolders.put( holder.getArray(), holder );
    }

	/**
	 *	DragSourceListener interface
	 *  @param e event
	 */

	public void dragDropEnd(DragSourceDropEvent e)	{}

	/**
	 *  KeyReleased Listener (nop)
	 * 	@param e event
	 */

	public void keyReleased(KeyEvent e) {}

    /**
     * Just in case user forgot to commit()/cancel() or close()
     */

    protected void finalize() throws Throwable {

        log.debug("running Session.finalize()");

        if (isCurrentTransaction) log.warn("afterTransactionCompletion() was never called");

        if (connection!=null) { //ie it was never disconnected

            //afterTransactionCompletion(false);

            if ( connection.isClosed() ) {
                log.warn("finalizing unclosed session with closed connection");
            }
            else {
                log.warn("unclosed connection, forgot to call close() on your session?");
                if (autoClose) connection.close();
                //TODO: Should I also call closeStatements() from here?
            }
        }
    }

    /**
     * Get the collection entry for a collection passed to filter,
     * which might be a collection wrapper, an array, or an unwrapped
     * collection. Return null if there is no entry.
     */

    private CollectionEntry getCollectionEntryOrNull(Object collection) {

        PersistentCollection coll;
        if (collection instanceof PersistentCollection) {
            coll = (PersistentCollection) collection;
            //if (collection==null) throw new TransientObjectException("Collection was not yet persistent");
        }
        else {
            coll = getArrayHolder(collection);
            if (coll==null) {
                //it might be an unwrapped collection reference!
                //try to find a wrapper (slowish)
                Iterator wrappers = IdentityMap.keyIterator(collectionEntries);
                while ( wrappers.hasNext() ) {
                    PersistentCollection pc = (PersistentCollection) wrappers.next();
                    if ( pc.isWrapper(collection) ) {
                        coll=pc;
                        break;
                    }
                }
            }
        }

        return (coll==null) ? null : getCollectionEntry(coll);

    }

    /**
     * remove any hard references to the entity that are held by the infrastructure
     * (references held by application or other persistant instances are okay)
     */

    public void evict(Object object) throws HibernateException {
        if (object instanceof HibernateProxy) {
            LazyInitializer li = HibernateProxyHelper.getLazyInitializer( (HibernateProxy) object );
            Serializable id = li.getIdentifier();
            ClassPersister persister = getClassPersister( li.getPersistentClass() );
            Key key = new Key(id, persister);
            proxiesByKey.remove(key);
            if ( !li.isUninitialized() ) {
                Object entity = removeEntity(key);
                if (entity!=null) {
                    EntityEntry e = removeEntry(entity);
                    doEvict(e.persister, entity);
                }
            }
        }
        else {
            EntityEntry e = removeEntry(object);
            if (e!=null) {
                removeEntity( new Key(e.id, e.persister) );
                doEvict(e.persister, object);
            }
        }
    }

    /**
     * Evict collections from the factory-level cache
     */

    private void evictCachedCollections(ClassPersister persister, Serializable id) throws HibernateException {
        evictCachedCollections( persister.getPropertyTypes(), id );
    }

	/**
	 * Default create method
	 * 
	 * @throws CreateException
	 * @ejb.create-method
	 */

	public void ejbCreate() throws CreateException {
		// TODO Auto-generated method stub
	}

    /**
     * This sets the codeset for this document
     *
     * @param codeset - String representation of codeset for this
     *                  document
     */

    public void setCodeset(String codeset) {
        this.codeset = codeset;
    }

    /** 
     * This gets the codeset for this document
     *
     * @return String the codeset for this document
     */

    public String getCodeset() {
        return codeset;
    }

    /**
     * This adds a stylesheet to the XML document.
     *
     * @param href - String reference to stylesheet
     * @param type - String type of stylesheet
     */

    public XMLDocument addStylesheet(String href, String type) {
        PI pi = new PI();
        pi.setTarget("xml-stylesheet")
          .addInstruction("href", href)
          .addInstruction("type", type);
        prolog.addElement(pi);
        
        return(this);
    }

    /**
     * This adds a stylesheet to the XML document, and assumes
     *   the default <code>text/xsl</code> type.
     *
     * @param href = String reference to stylesheet
     */

    public XMLDocument addStylesheet(String href) {
        return addStylesheet(href, "text/xsl");
    }

    /**
     * This adds the specified element to the prolog of the document
     *
     * @param element - Element to add
     */

    public XMLDocument addToProlog(ConcreteElement element) {
        prolog.addElement(element);
        return(this);
    }

    /**
     * This adds an element to the XML document.  If the
     *   document is empty, it sets the passed in element
     *   as the root element.
     *
     * @param element - XML Element to add
     * @return XMLDocument - modified document
     */

    public XMLDocument addElement(XML element) {
        if (content == null)
            content = element;
        else
            content.addElement(element);
            
        return(this);
    }

    /**
     * Write the document to the OutputStream
     *
     * @param out - OutputStream to write to
     */

    public void output(OutputStream out)
    {        
        /** 
         * FIXME: The other part of the version hack!
         *   Add the version declaration to the beginning of the document.
         */
        try {
            out.write(versionDecl.getBytes());
        } catch (Exception e) { }
        
        for (int i=0; i<prolog.size(); i++) {
            ConcreteElement e = (ConcreteElement)prolog.elementAt(i);
            e.output(out);
        }
         
        if (content != null)
            content.output(out);
    }

    /**
     * Add an additional instruction (which works like an XML
     *   attribute) to the PI
     *
     * @param name - Name of instruction (e.g. standalone)
     * @param value - value of instruction (e.g. "no")
     */

    public PI addInstruction(String name, String value) {
        addAttribute(name, value);
        return(this);
    }

    /**
     * Clone this document
     *
     * @return Object - cloned XMLDocument
     */

    public Object clone() {
        return content.clone();
    }

    /**
        this method actually performs the filtering.
    */

    public String process(String to_process)
    {   System.out.println("\nString to Process in StringFilter = "+to_process);
        String[] value = split(to_process);
        StringBuffer new_value = new StringBuffer();
        for(int x = 0; x < value.length; x++)
        {
            if(hasAttribute(value[x]))
                new_value.append((String)get(value[x]));
            else
                new_value.append(value[x]);
            if(x != value.length - 1)
                new_value.append(" ");
        }
        return(new_value.toString());
    }

	/**
	 * Creates an initially unselected toggle button
	 * without setting the text or image.
	 */

	public CToggleButton () {
		this(null, null, false);
	}

	/**
	 * Creates an unselected toggle button with the specified text.
	 *
	 * @param text  the string displayed on the toggle button
	 */

	public CToggleButton (String text) {
		this(text, null, false);
	}

	/**
	 * Creates a toggle button with the specified text
	 * and selection state.
	 *
	 * @param text  the string displayed on the toggle button
	 * @param selected  if true, the button is initially selected;
	 *                  otherwise, the button is initially unselected
	 */

	public CToggleButton (String text, boolean selected) {
		this(text, null, selected);
	}

	/**
	 * 	Constructor get TableNAme from Table
	 * 	@param AD_Table_ID Table_ID
	 */

	public MQuery (int AD_Table_ID)
	{	//	Use Client Context as r/o
		m_TableName = M_Table.getTableName (Env.getCtx(), AD_Table_ID);
	}	//	MQuery

	/** Null means no checks
	  */


	protected String checkOptions()	{ return null; }

    /**
     * This method initializes the provided baseimplementation 
     * of the model properly.<p>
     * This is not done in the constructor because there might
     * be cases where some base data is set in the constructor 
     * and must be present for properly working model getter methods.<p>
     * <b>MUST BE CALLED BY ANY SUBCLASS!</b>
     */

    public void initialize() {
    }

    /**
     * Implement to specify the height of the first row.
     * This value might be overwritten when setFirstRowHeight() is called.
     * @return Should return the height of the first row in the table.
     * @see #setFirstRowHeight(int);
     * @deprecated Implement getInitialRowHeight(0) instead!
     */

    public int getInitialFirstRowHeight() {
    	return -1;
    }

    /**
     * Sets the row height for the first row.
     * @deprecated Use setRowHeight(0, value) instead.
     */

    public void setFirstRowHeight(int value) {
        setRowHeight(0, value);
    }

    /**
     * Delegates the real content retrieval to the method
     * <code>doGetContentAt(int, int)</code>.
     * @see de.kupzog.ktable.KTableModel#getContentAt(int, int)
     */

    public Object getContentAt(int col, int row) {
        return doGetContentAt(col, row);
    }

    /**
     * Returns the tooltip for the given cell. <p>
     * Simply calls the method <code>doGetTooltipAt()</code>.
     * @see de.kupzog.ktable.KTableModel#getTooltipAt(int, int)
     */

    public String getTooltipAt(int col, int row) {
        return doGetTooltipAt(col, row);
    }

    /**
     * Returns the tooltip text for the given cell. Implement this
     * method rather than <code>getTooltipAt()</code>.
     * @param col The column index.
     * @param row The row index.
     * @return Returns the tooltip text for the cell. Default: None.
     */

    public String doGetTooltipAt(int col, int row) {
        return null;
    }

    /**
     * Delegates the real editor retrieval to the method
     * <code>doGetCellEditor(int, int)</code>.
     * @see de.kupzog.ktable.KTableModel#getCellEditor(int, int)
     */

    public KTableCellEditor getCellEditor(int col, int row) {
        return doGetCellEditor(col, row);
    }

    /**
     * Calls the method <code>doSetContentAt(int, int, Object)</code>
     * to actually set the content of a table cell to the model.
     * @see de.kupzog.ktable.KTableModel#setContentAt(int, int, java.lang.Object)
     */

    public void setContentAt(int col, int row, Object value) {
        doSetContentAt(col, row, value);
        for (int i = 0; i < modelChangeListeners.size(); i++) {
        	ModelChangeListener listener = (ModelChangeListener)modelChangeListeners.get(i);
        	listener.modelChanged(col, row, value);
        }
    }

    /**
     * Returns wether a given cell is fixed.
     * @param col The column index
     * @param row the row index
     * @return returns true if the cell is fixed, false otherwise. 
     */

    public boolean isFixedCell(int col, int row) {
        return col < getFixedColumnCount()
        || row < getFixedRowCount();
    }

	/**
	 * Implement In-Textfield navigation with the keys... 
	 * @see de.kupzog.ktable.KTableCellEditor#onTraverse(org.eclipse.swt.events.TraverseEvent)
	 */

	protected void onTraverse(TraverseEvent e) {
	    if (e.keyCode == SWT.ARROW_LEFT) {
	        if (m_Text.getCaretPosition()==0 && m_Text.getSelectionCount()==0)
	            super.onTraverse(e);
	        // handel the event within the text widget!
	    } else if (e.keyCode == SWT.ARROW_RIGHT) {
	        if (m_Text.getCaretPosition()==m_Text.getText().length() && m_Text.getSelectionCount()==0)
	            super.onTraverse(e);
	        // handle the event within the text widget!
	    } else
	        super.onTraverse(e);
	}

    /**
     * Checks wether the given horizontal alignment parameter is valid.
     * @param align The alignment to check
     * @return True if the alignment value is valid.
     */

    private boolean isValidHAlignment(int align) {
        if (align==SWTX.ALIGN_HORIZONTAL_CENTER || 
            align==SWTX.ALIGN_HORIZONTAL_LEFT  || 
            align==SWTX.ALIGN_HORIZONTAL_RIGHT)
            return true;
        return false;
    }

    /**
     * Checks wether the given vertical alignment parameter is valid.
     * @param align The alignment to check
     * @return True if the alignment value is valid.
     */

    private boolean isValidVAlignment(int align) {
        if (align==SWTX.ALIGN_VERTICAL_TOP || 
            align==SWTX.ALIGN_VERTICAL_CENTER  || 
            align==SWTX.ALIGN_VERTICAL_BOTTOM)
            return true;
        return false;
    }

	/**
	 * Called when the open-method returns.
	 */

	public void close(boolean save) {
		super.close(save);
		m_Dialog = null;
	}

    /** 
     * Calls doBelongsToCell to get the cell span.
     * Never overwrite this method, but implement doBelongsToCell().
     * @see de.kupzog.ktable.KTableModel#belongsToCell(int, int)
     */

    public Point belongsToCell(int col, int row) {
        return doBelongsToCell(col, row);
    }

	/**
	 * Sets the bounds of the dialog to the cell bounds.
	 * DEFAULT: Ignored. Set the required shell properties by
	 * overwriting the method <code>setupShellProperties(Shell)</code>.
	 */

	public void setBounds(Rectangle rect) {
	    // ignored.
	}

    /**
     * Ignored, since it is no longer in use. We use a dialog instead 
     * of a control!
     */

    protected Control createControl() {
        return null;
    }

    /**
     * Return (0,0) if cell should stay in its own area,
     * or return the cell that should overlap this cell.<br>
     * Overwrite this rather than belongsToCell()!<p>
     * Defaults to no spanning.  
     * @see de.kupzog.ktable.KTableModel#belongsToCell(int, int).
     */

    public Point doBelongsToCell(int col, int row) {
        return new Point(col, row);
    }

    /**
	 * Activates the editor at the given position.
	 * Instantly closes the editor and switch the boolean content value.
	 * @param row
	 * @param col
	 * @param rect
	 */

	public void open(KTable table, int col, int row, Rectangle rect) {
		m_Table = table;
		m_Model = table.getModel();
		m_Rect = rect;
		m_Row = row;
		m_Col = col;
		
		close(true);
		
		GC gc = new GC(m_Table);
		m_Table.updateCell(m_Col, m_Row);
		gc.dispose();
	}

	/**
	 * Simply switches the boolean value in the model!
	 */

	public void close(boolean save) {
	    if (save) {
	        Object o = m_Model.getContentAt(m_Col, m_Row);
	        if (!(o instanceof Boolean))
	            throw new ClassCastException("CheckboxCellEditor needs a Boolean content!");
	        
	        boolean newVal = !((Boolean)o).booleanValue();
	        
	        m_Model.setContentAt(m_Col, m_Row, new Boolean(newVal));
	    }
	    super.close(save);
	}

    /**
     * This implementation does nothing!
     * @see de.kupzog.ktable.KTableCellEditor#setContent(java.lang.Object)
     */

    public void setContent(Object content) {
    }

    /**
     * Maps the given row index that references a visible row, to one 
     * that is internally used in the tablemodel.<br>
     * This allows different tablemodels (such as the sorted table model) 
     * to rearrange rows flexibly. This visual rearrangement leads
     * to changed shown row indices, but using this method, the model-internal
     * row indices stay the same. 
     * @param shownRow The row index as displayed by the KTable.
     * @return Returns the row index as used in the model. This stays unchanged
     * even if the visual arrangement is changed (e.g. when sorting the talbe).
     */

    public int mapRowIndexToModel(int shownRow) {
        return shownRow;
    }

    /**
     * Sets the column index this comparator operates on.
     * @param column the column index to use.
     */

    public void setColumnToCompare(int column) {
        //if (row>=m_Model.getFixedRowCount())
        //    throw new IllegalArgumentException("An invalid column index was given!");
        
        m_ColIndex=column;
    }

    /**
     * Maps the given row index from a model-internal to one that references
     * visualized table rows. This is usually used to do something with the
     * KTable from within the tablemodel. 
     * @param modelRow The row index as used in the model.
     * @return Returns the row index as needed/used by the KTable to display the data.
     */

    public int mapRowIndexToTable(int modelRow) {
    	return modelRow;
    }

	/**
	 * Is called if a non-fixed cell is selected (gets the focus).
	 * @see KTable for an explanation of the term "fixed cells".
	 * @param col
	 * the column of the cell
	 * @param row
	 * the row of the cell
	 * @param statemask
	 * the modifier keys that where pressed when the selection happened.
	 */

	public void cellDoubleClicked(int col, int row, int statemask) {
	}

	/**
	 * Is called if a fixed cell is selected (is clicked).
	 * @see KTable for an explanation of the term "fixed cells".
	 * @param col
	 * the column of the cell
	 * @param row
	 * the row of the cell
	 * @param statemask
	 * the modifier keys that where pressed when the selection happened.
	 */

	public void fixedCellDoubleClicked(int col, int row, int statemask) {
	}

    /**
     * Sets the sorting direction.
     * @param direction The sort direction, either
     * SORT_NONE, SORT_UP or SORT_DOWN.
     */

    public void setSortDirection(int direction) {
    	 if (direction!=SORT_UP && direction!=SORT_DOWN && direction!=SORT_NONE)
             throw new IllegalArgumentException("Undefined sorting direction: "+direction);
         
    	 m_Direction = direction;
    }

	/**
	 * disposes the editor and its components
	 */

	public void dispose() {
		if (m_Control != null) {
			Control contr = m_Control;
			m_Control = null;
			contr.dispose();
		}
	}

    /**
     * Sets the tablemodel to work on.
     * @param model The <class>KTableSortedModel</class> to work with.
     */

    public void setModel(KTableSortedModel model) {
    	m_Model = model;
    }

	/**
	 * Deactivates the editor.
	 * @param save
	 * If true, the content is saved to the underlying table.
	 */

	public void close(boolean save) {
		m_Table.m_CellEditor = null;
		//m_Control.setVisible(false);
		GC gc = new GC(m_Table);
		m_Table.drawCell(gc, m_Col, m_Row);
		gc.dispose();
		this.dispose();
		m_Table.setFocus();
	}

    /**
     * Sorts the model elements so that the retrieval
     * methods by index (e.g. of type <code>method(int col, int row)</code>)
     * return the content ordered in the given direction.<p>
     * Note: To make the table reflect this sorting, it must be refreshed/redrawn!<p>
     * Note: Often it is desired that there is some visual sign of how the sorting is.
     * 
     * @param comparator The KTableSortComparator that knows how to sort the rows!
     */

    public void sort(KTableSortComparator comparator) {
        Collections.sort(rowMapping, comparator);
        
        m_Ordered = comparator.getSortDirection();
        
        if (m_Ordered==KTableSortComparator.SORT_NONE)
            setSortColumn(-1);
        else
            setSortColumn(comparator.getColumnToSortOn());
    }

	/**
	 * Returns true if the editor has the focus.
	 * @return boolean
	 */

	public boolean isFocused() {
		if (m_Control == null)
			return false;
		return m_Control.isFocusControl();
	}

	/**
	 * Sets the editor's position and size
	 * @param rect
	 */

	public void setBounds(Rectangle rect) {
		if (m_Control != null)
			m_Control.setBounds(rect);
	}

    /**
     * Overwrites the style bits with the given one.
     * @see getStyle() for accessing the style bits.
     * @param style The styles to AND with the current style bits.
     */

    public void setStyle(int style) {
        m_Style = style;
    }

    /**
     * Maps between the KTable row index and the model row index!<p>
     * Accesses the sorted model accordingly.
     * Delegates the real content retrieval to the method
     * <code>doGetContentAt(int, int)</code>.
     * @see de.kupzog.ktable.KTableModel#getContentAt(int, int)
     */

    public Object getContentAt(int col, int row) {
        row = mapRowIndexToModel(row);
        // now have to check if the mapped cell is spanned, and if it is, take the
        // cell that is responsible for the content of the big cell:
        Point valid = getValidCell(col, row);
        return doGetContentAt(valid.x, valid.y);
    }

    /**
     * Returns the tooltip for the given cell. <p>
     * Calls the method <code>doGetTooltipAt()</code> to retrieve
     * content.
     * @see de.kupzog.ktable.KTableModel#getTooltipAt(int, int)
     */

    public String getTooltipAt(int col, int row) {
        row = mapRowIndexToModel(row);
        Point valid = getValidCell(col, row);
        return doGetTooltipAt(valid.x, valid.y);
    }

    /**
     * Maps between the KTable row index and the model row index!<p>
     * Delegates the real editor retrieval to the method
     * <code>doGetCellEditor(int, int)</code>.
     * @see de.kupzog.ktable.KTableModel#getCellEditor(int, int)
     */

    public KTableCellEditor getCellEditor(int col, int row) {
        row = mapRowIndexToModel(row);
        // now have to check if the mapped cell is spanned, and if it is, take the
        // cell that is responsible for the content of the big cell:
        Point valid = getValidCell(col, row);
        return doGetCellEditor(valid.x, valid.y);
    }

    /**
     * Maps between the KTable row index and the model row index!<p>
     * Calls the method <code>doSetContentAt(int, int, Object)</code>
     * to actually set the content of a table cell to the model.
     * @see de.kupzog.ktable.KTableModel#setContentAt(int, int, java.lang.Object)
     */

    public void setContentAt(int col, int row, Object value) {
        row = mapRowIndexToModel(row);
        // now have to check if the mapped cell is spanned, and if it is, take the
        // cell that is responsible for the content of the big cell:
        Point valid = getValidCell(col, row);
        doSetContentAt(valid.x, valid.y, value);
    }

    /**
     * Maps between the KTable row index and the model row index!<p>
     * Calls the method <code>doGetCellRenderer(int, int)</code>
     * to retrieve the cell renderer for a cell.
     * @see de.kupzog.ktable.KTableModel#getCellRenderer(int, int)
     */

    public KTableCellRenderer getCellRenderer(int col, int row) {
        row = mapRowIndexToModel(row);
        Point valid = getValidCell(col, row);
        return doGetCellRenderer(valid.x, valid.y);
    }

    /** 
     * Sorting disables all cell spanning. The behavior is:
     * spanned cells are spittet, but all cells originally spanned
     * get the content of the spanned cell. 
     * @see de.kupzog.ktable.KTableModel#belongsToCell(int, int)
     */

    public Point belongsToCell(int col, int row) {
        if (getSortState() == KTableSortComparator.SORT_NONE)
            return doBelongsToCell(col, row);
        // if sorting is active, all cells get rendered seperately!
        return new Point(col, row);
    }

    /**
     * Draws the cell as a button. It is visibly clickable and contains a button text.
     * All line borders of the cell are overpainted - there will not be any border between buttons. 
     * @param gc The GC to use when painting.
     * @param rect The cell area as given by KTable. (contains 1px bottom & right offset)
     * @param text The text to paint on the button. 
     * @param pressed Wether the button should be painted as clicked/pressed or not. 
     */

    protected void drawCellButton(GC gc, Rectangle rect, String text, boolean pressed) {
        rect.height += 1;
        rect.width += 1;
        gc.setForeground(Display.getCurrent().getSystemColor(
                SWT.COLOR_LIST_FOREGROUND));
        if (pressed) {
            SWTX.drawButtonDown(gc, 
                    text, getAlignment(),
                    null, getAlignment(), rect);
        } else {
            SWTX.drawButtonUp(gc, 
                    text, getAlignment(),
                    null, getAlignment(), rect);
        }
    }

    /**
     * Mirrors the given image. Note that the returned image must be disposed after rendering!
     * @param source The source image. Gets disposed in this method.
     * @return Returns a new image with mirrored content. The caller is responsible for disposing this image!
     */

    private Image mirrorImage(Image source) {
        Rectangle bounds = source.getBounds();
        
        ImageData sourceData = source.getImageData();
        ImageData resultData = new ImageData(
                sourceData.height, sourceData.width, 
                sourceData.depth, sourceData.palette);
        for (int x = 0; x<bounds.width; x++)
            for (int y=0; y<bounds.height; y++)
                resultData.setPixel(y, resultData.height-x-1, sourceData.getPixel(x, y));
        source.dispose();
        return new Image(Display.getCurrent(), resultData);        
    }

	/**
	 * Is called if a non-fixed cell is selected (gets the focus). 
	 * @see KTable for an explanation of the term "fixed cells".
	 * @param col
	 * the column of the cell
	 * @param row
	 * the row of the cell
	 * @param statemask
	 * the modifier keys that where pressed when the selection happened.
	 */

	public void cellSelected(int col, int row, int statemask) {
	}

	/**
	 * Is called if a fixed cell is selected (is clicked). 
	 * @see KTable for an explanation of the term "fixed cells".
	 * @param col
	 * the column of the cell
	 * @param row
	 * the row of the cell
	 * @param statemask
	 * the modifier keys that where pressed when the selection happened.
	 */

	public void fixedCellSelected(int col, int row, int statemask) {
	}

    /**
     * Draws the default border by invoking the relevant method in BorderPainter.
     * <p>
     * Overwrite this method if you desire another border style.
     * @param gc The GC to use.
     * @param rect The cell bounds. Note that this method returns the new cell bounds
     * that exlude the border area.
     * @param vBorderColor The vertical border color.
     * @param hBorderColor The horizontal border color.
     * @return Returns the new bounds of the cell that should be filled with content.
     */

    protected Rectangle drawDefaultSolidCellLine(GC gc, Rectangle rect, Color vBorderColor, Color hBorderColor) {
        return BorderPainter.drawDefaultSolidCellLine(gc, rect, vBorderColor, hBorderColor);
    }

    /**
     * Sets the alignment of the cell content.
     * @param style The OR-ed alignment constants for
     * vertical and horizontal alignment as defined in
     * SWTX.
     * @see SWTX#ALIGN_HORIZONTAL_CENTER
     * @see SWTX#ALIGN_HORIZONTAL_LEFT
     * @see SWTX#ALIGN_HORIZONTAL_RIGHT
     * @see SWTX#ALIGN_VERTICAL_CENTER
     * @see SWTX#ALIGN_VERTICAL_TOP
     * @see SWTX#ALIGN_VERTICAL_BOTTOM
     */

    public void setAlignment(int style) {
        m_alignment = style;
    }

    /**
     * Set the foreground color used to paint text et al.
     * @param fgcolor The color or <code>null</code> to
     * reset to default (black). Note that also the default color can be set using <code>setDefaultForeground(Color)</code>
     * @see #setDefaultForeground(Color)
     */

    public void setForeground(Color fgcolor) {
        m_fgColor=fgcolor;
    }

    /**
     * Changes the default foreground color that will be used
     * when no other foreground color is set. 
     * (for example when <code>setForeground(null)</code> is called)
     * @param fgcolor The foreground color to use.
     * @see #setForeground(Color)
     */

    public void setDefaultForeground(Color fgcolor) {
        COLOR_TEXT = fgcolor;
    }

    /** 
     * Implement also cell spans so that it can be demonstrated how
     * the sorting algorithm works in this case: 
     * @see de.kupzog.ktable.KTableDefaultModel#doBelongsToCell(int, int)
     */

    public Point doBelongsToCell(int col, int row) {
        if ((col==2 || col==3)&& !isFixedCell(col, row)) {
            int newRow = row;
            if ((row-getFixedRowCount())%2==1)
                newRow--;
            return new Point(2, newRow);
        }
        return new Point(col,row);
    }

    /**
     * Set the background color that should be used when 
     * painting the cell background.<p>
     * If the <code>null</code> value is given, the default 
     * color will be used. The default color is settable using 
     * <code>setDefaultBacktround(Color)</code>
     * @param bgcolor The color or <code>null</code> to
     * reset to default.
     * @see #setDefaultBackground(Color)
     */

    public void setBackground(Color bgcolor) {
        m_bgColor=bgcolor;
    }

    /**
     * Changes the default background color that will be used when
     * no background color is set via setBackground().
     * @param bgcolor The color for the background.
     * @see #setBackground(Color)
     */

    public void setDefaultBackground(Color bgcolor) {
        COLOR_BACKGROUND = bgcolor;
    }

    /**
     * Sets the font the renderer will use for drawing
     * its content.
     * @param font The font to use. Be aware that
     * you must dispose fonts you have created.
     */

    public void setFont(Font font) {
        m_font = font;
    }

    /**
     * Applies the font style of the renderer to the
     * gc that will draw the content.<p>
     * <b>To be called by implementors</b>
     * @param gc The gc that will draw the 
     * renderers content.
     */

    protected void applyFont(GC gc) {
        m_GCfont = gc.getFont();
        if (m_font == null)
            m_font = Display.getCurrent().getSystemFont();
        if ((m_Style & SWT.BOLD) != 0 || (m_Style & SWT.ITALIC)!=0) {
            FontData[] fd = m_font.getFontData();
            int style = SWT.NONE;
            if ((m_Style & SWT.BOLD)!=0)
                style |= SWT.BOLD;
            if ((m_Style & SWT.ITALIC)!=0)
                style |= SWT.ITALIC;
            
            for (int i=0; i<fd.length; i++)
                fd[i].setStyle(style);
            m_TMPfont = new Font(Display.getCurrent(), fd);
            gc.setFont(m_TMPfont);
        }  else
            gc.setFont(m_font);
    }

    /**
     * Resets the given GC's font parameters to the
     * original state.
     * @param gc The gc to draw with.
     */

    protected void resetFont(GC gc) {
        if (m_TMPfont!=null) {
            m_TMPfont.dispose();
            m_TMPfont = null;
        }
            
        gc.setFont(m_GCfont);
    }

	/**
	 * Return the collection of tasks
	 */

	public Vector getTasks() {
		return tasks;
	}

	/**
	 * Add a new task to the collection of tasks
	 */

	public void addTask() {
		ExampleTask task = new ExampleTask("New task");
		tasks.add(tasks.size(), task);
		Iterator iterator = taskChangeListeners.iterator();
		while (iterator.hasNext())
			((ITaskChangeListener) iterator.next()).taskAdded(task);
	}

	/**
	 * Set the 'completed' property
	 * 
	 * @param b
	 */

	public void setCompleted(boolean b) {
		completed = b;
	}

	/**
	 * Set the 'description' property
	 * 
	 * @param string
	 */

	public void setDescription(String string) {
		description = string;
	}

	/**
	 * Set the 'owner' property
	 * 
	 * @param string
	 */

	public void setOwner(String string) {
		owner = string;
	}

	/**
	 * Set the 'percentComplete' property
	 * 
	 * @param i
	 */

	public void setPercentComplete(int i) {
		percentComplete = i;
	}

	/**
	 * This method initializes sashForm	
	 *
	 */

	private void createSashForm() {
		GridData gridData = new org.eclipse.swt.layout.GridData();
		gridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = true;
		gridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;
		sashForm = new SashForm(top, SWT.NONE);
		sashForm.setOrientation(org.eclipse.swt.SWT.VERTICAL);
		sashForm.setLayoutData(gridData);
		createTopComposite();
		createBottomComposite();
	}

	/**
	 * This method initializes trifonTextModelExample	
	 * 	
	 * @return net.comap.table.example.viewmodel.TrifonTextModelExample	
	 */

	private TrifonTextModelExample getTrifonTextModelExample() {
		if (trifonTextModelExample == null) {
			trifonTextModelExample = new TrifonTextModelExample();
		}
		return trifonTextModelExample;
	}

	/**
	 * This method initializes topComposite	
	 *
	 */

	private void createTopComposite() {
		topComposite = new Composite(sashForm, SWT.NONE);
		topComposite.setLayout(new GridLayout());
		createKTable();
	}

	/**
	 * This method initializes bottomComposite	
	 *
	 */

	private void createBottomComposite() {
		bottomComposite = new Composite(sashForm, SWT.NONE);
	}

	/**
	 * This method initializes composite	
	 *
	 */

	private void createComposite() {
		composite = new Composite(tabFolder, SWT.NONE);
		buttonOne = new Button(composite, SWT.NONE);
		buttonOne.setBounds(new org.eclipse.swt.graphics.Rectangle(5,5,12,23));
		buttonOne.setText("Button One");
	}

	/**
	 * This method initializes kTable	
	 *
	 */

	private void createKTable() {
		GridData gridData1 = new org.eclipse.swt.layout.GridData();
		gridData1.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;
		gridData1.grabExcessHorizontalSpace = true;
		gridData1.grabExcessVerticalSpace = true;
		gridData1.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;
		kTable = new KTable(topComposite, SWT.NONE);
		kTable.setLayoutData(gridData1);
		
		kTable.setModel(model);
	}

	/**
	 * This method initializes composite1	
	 *
	 */

	private void createComposite1() {
		compositeTwo = new Composite(tabFolder, SWT.NONE);
		createKTable();
	}

	/**
	 * This method initializes kTable	
	 *
	 */

	private void createKTable() {
		kTable = new KTable(compositeTwo, SWT.V_SCROLL | SWT.H_SCROLL 
				| SWTX.FILL_WITH_LASTCOL
				| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important

		kTable.setModel(getTrifonTextModelExample());
		kTable.setBounds(new org.eclipse.swt.graphics.Rectangle(115,15,77,23));
		
	}

	/**
	 * This method initializes bottomCTabFolder	
	 *
	 */

	private void createBottomCTabFolder() {
		bottomTabFolder = new TabFolder(sashForm, SWT.NONE);
		
		tabItemOne = new TabItem(bottomTabFolder, SWT.NONE);
		tabItemOne.setText("Text Table");
		
		Composite comp1 = new Composite(bottomTabFolder, SWT.NONE);
		tabItemOne.setControl(comp1);
		comp1.setLayout(new FillLayout());
		tabOneKTable = new KTable(comp1, SWT.V_SCROLL | SWT.H_SCROLL 
				| SWTX.FILL_WITH_LASTCOL
				| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important
		
	}

	/**
	 * Check if this user is surveyant.
	 * 
	 * @return true, if surveyant
	 */

	public boolean isSurveyant() {
		return this.level == OutlawUser.LEVEL_NOBODY;
	}

	/**
	 * Liefert die Nachbedingung zu dieser Content-Gruppe.
	 * 
	 * @return Condition
	 * @hibernate.many-to-one
	 */

	public Condition getPostCondition() {
		return this.postCondition;
	}

	/**
	 * Set the content of this container.
	 * 
	 * @param list the content
	 */

	public void setContent(List<PersistentObject> list) {
		this.content = list;
	}

	/**
	 * This method initializes tabFolder	
	 *
	 */

	private void createTabFolder() {
		GridData gridData = new org.eclipse.swt.layout.GridData();
		gridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;
		gridData.grabExcessHorizontalSpace = true;
		gridData.grabExcessVerticalSpace = true;
		gridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;
		tabFolder = new TabFolder(top, SWT.NONE);
		tabFolder.setLayoutData(gridData);
	}

	/**
	 * Get the filename of this image.
	 * 
	 * @return die URL
	 * @hibernate.property not-null="true"
	 */

	public String getFilename() {
		return this.filename;
	}

	/**
	 * Set the filename.
	 * 
	 * @param string the filename
	 */

	public void setFilename(final String string) {
		this.filename = string;
	}

	/**
	 * Set the image.
	 * 
	 * @param image the image
	 */

	public void setImage(byte[] data) {
		this.data = data;
	}

	/**
	 * Cehck if this user is "user".
	 * 
	 * @return true, if user
	 */

	public boolean isUser() {
		return this.level == OutlawUser.LEVEL_USER;
	}

	/**
	 * Check if this user is admin.
	 * 
	 * @return true, if admin
	 */

	public boolean isAdmin() {
		return this.level == OutlawUser.LEVEL_ADMIN;
	}

	/**
	 * Get the text.
	 * 
	 * @return the text
	 * @hibernate.property type="text"
	 */

	public String getText() {
		return this.text;
	}

	/**
	 * Get the layout.
	 * 
	 * @return the layout
	 * @hibernate.property
	 */

	public int getLayout() {
		return this.layout;
	}

	/**
	 * Set the text.
	 * 
	 * @param string the text
	 */

	public void setText(final String string) {
		this.text = string;
	}

	/**
	 * Set the layout.
	 * 
	 * @param theLayout the layout
	 */

	public void setLayout(final int theLayout) {
		this.layout = theLayout;
	}

	/**
	 * Get abstract of this text. If the text is more than 120 characters long, the first and last 60 chars concatenated
	 * with "..." are returned.
	 * 
	 * @return abstract
	 */

	public String getTextPreview() {
		String retVal;

		if (this.text.length() > 120) {
			retVal = this.text.substring(0, 60);
			retVal += "...";
			retVal += this.text.substring(this.text.length() - 60 - 1, this.text.length() - 1);
		} else {
			retVal = this.text;
		}

		return retVal;
	}

	/**
	 * Get the creation date.
	 * 
	 * @return the date
	 * @hibernate.property column="TAN_CDATE" not-null="true"
	 */

	public Date getCdate() {
		return this.cdate;
	}

	/**
	 * Get the end date.
	 * 
	 * @return the date
	 * @hibernate.property column="TAN_EDATE"
	 */

	public Date getEdate() {
		return this.edate;
	}

	/**
	 * Get the start date.
	 * 
	 * @return the start date
	 * @hibernate.property column="TAN_SDATE"
	 */

	public Date getSdate() {
		return this.sdate;
	}

	/**
	 * Get the state.
	 * 
	 * @return the state
	 * @hibernate.property column="TAN_STATUS" not-null="true"
	 */

	public int getState() {
		return this.state;
	}

	/**
	 * Get the survey.
	 * 
	 * @return the survey
	 * @hibernate.many-to-one column="TAN_SURVEY_ID" not-null="true"
	 */

	public Survey getSurvey() {
		return this.survey;
	}

	/**
	 * Set the creation date.
	 * 
	 * @param date the date
	 */

	public void setCdate(final Date date) {
		this.cdate = date;
	}

	/**
	 * Set the end date.
	 * 
	 * @param date the date
	 */

	public void setEdate(final Date date) {
		this.edate = date;
	}

	/**
	 * Set the start date.
	 * 
	 * @param date the date
	 */

	public void setSdate(final Date date) {
		this.sdate = date;
	}

	/**
	 * Set the state.
	 * 
	 * @param state the tate
	 */

	public void setState(final int theState) {
		this.state = theState;
	}

	/**
	 * Set the survey.
	 * 
	 * @param theSurvey the survey
	 */

	public void setSurvey(final Survey theSurvey) {
		this.survey = theSurvey;
	}

	/**
	 * Liefert das Layout des Fragetextes.
	 * 
	 * @return das Layout
	 * @hibernate.property
	 */

	public int getQuestionLayout() {
		return this.questionLayout;
	}

	/**
	 * Liefert das Layout der Antwortm&ouml;glichkeiten.
	 * 
	 * @return das Layout
	 * @hibernate.property
	 */

	public int getAnswerLayout() {
		return this.answerLayout;
	}

    /**
     * <p>Compares this {@link InternalGroupPrincipal} to the provided group principal
     * and check if they are equal.</p>
     * return Whether the {@link InternalGroupPrincipal} are equal.
     */

    public boolean equals(Object object)
    {  
        if (!(object instanceof InternalGroupPrincipal))
            return false;

        InternalGroupPrincipal r = (InternalGroupPrincipal) object;
        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));
        return isEqual;
    }

    /**
     * <p>Compares this {@link InternalRolePrincipal} to the provided role principal
     * and check if they are equal.</p>
     * return Whether the {@link InternalRolePrincipal} are equal.
     */

    public boolean equals(Object object)
    {  
        if (!(object instanceof InternalRolePrincipal))
            return false;

        InternalRolePrincipal r = (InternalRolePrincipal) object;
        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));
        return isEqual;
    }

    /**
     * <p>Compares this {@link InternalUserPrincipal} to the provided user principal
     * and check if they are equal.</p>
     * return Whether the {@link InternalUserPrincipal} are equal.
     */

    public boolean equals(Object object)
    {  
        if (!(object instanceof InternalUserPrincipal))
            return false;

        InternalUserPrincipal r = (InternalUserPrincipal) object;
        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));
        return isEqual;
    }

    /**
     * <p>Compares this {@link InternalCredential} to the provided credential
     * and check if they are equal.</p>
     * return Whether the {@link InternalCredential} are equal.
     */

    public boolean equals(Object object)
    {  
        if (!(object instanceof InternalCredential))
            return false;

        InternalCredential c = (InternalCredential) object;
        boolean isEqual = ((c.getValue().equals(this.getValue())) && (c.getType() == this.getType()) && ((null == c.getClassname()) || (c.getClassname().equals(this.getClassname()))));
        return isEqual;
    }

    /**
     * For this implementation, always returns "/"
     */

    public String getSystemRoot()
    {        
        return "/";
    }

    /**
     * Forward the <code>retrieveOptions</code> call to the target
     * <code>ChainedOption</code> if the <code>refreshProperty</code> property
     * on the target command is true.
     * 
     * @param command
     *            Command object to use when extracting values that the
     *            <code>ChainedOption</code> depends on.
     * @param context
     *            may contain any context that might be interesting for
     *            retreiving valid options. E.g. a
     *            <code>HttpServletRequest</code> object can be supplied as
     *            context for a Strategy to perform filtering based on user
     *            access.
     * 
     * @return the result of retrieveOptions on the target ChainedOption if we are
     *         to forward, an empty <code>LinkedList</code> otherwise.
     * 
     * @see net.sf.chainedoptions.ChainedOption#retrieveOptions(java.lang.Object, java.lang.Object)
     */

    public List retrieveOptions(Object command, Object context) {
        if (getRefreshPropertyAsBoolean(command)) {
            return chainedOption.retrieveOptions(command, context);
        } else {
            return new LinkedList();
        }
    }

    /**
     * Create a <code>LabelValueBean</code> with name and value as the
     * supplied String.
     * 
     * @param object
     *            <code>String</code> to convert.
     * @return a new <code>LabelValueBean</code>
     * @throws ClassCastException
     *             if the supplied <code>object</code> is not a
     *             <code>String</code>.
     */

    protected LabelValueBean convertBean(Object object) {
        String string = (String) object;
        return new LabelValueBean(string, string);
    }

    /**
     * Do nothing, just return the supplied list.
     * 
     * @param options
     *            the list to return.
     * @param context
     *            ignored for this implementation.
     * @return the supplied list, unmodified.
     */

    public List adjustAndSort(List options, Object context) {
        return options;
    }

    /**
     * Forward the <code>updateValue</code> call to the target
     * <code>ChainedOption</code if the <code>refreshProperty</code> property on the target command is true.
     * @param command
     *            The command object that may be updated.
     * @param options
     *            A list of {@link LabelValueBean}objects to choose from.
     * @param context
     *            may contain any context that might be interesting for
     *            retreiving valid options. E.g. a
     *            <code>HttpServletRequest</code> object can be supplied as
     *            context for a Strategy to perform filtering based on user
     *            access.
     * 
     * @see net.sf.chainedoptions.ChainedOption#updateValue(java.lang.Object, java.util.List, java.lang.Object)
     */

    public void updateValue(Object command, List options, Object context) {
        if (getRefreshPropertyAsBoolean(command)) {
            chainedOption.updateValue(command, options, context);
        }
    }

    /**
     * Returns the value of the first item in the list.
     * 
     * @param options
     *            the list of options.
     * @param context
     *            ignored for this implementation.
     * @return the value of the first item in the List if the List is not empty,
     *         empty String otherwise.
     */

    public String getDefaultValue(List options, Object context) {
        if (options.size() > 0) {
            LabelValueBean bean = (LabelValueBean) options.get(0);
            return bean.getValue();
        } else {
            return "";
        }
    }

    /**
     * Extra items are items that signify special values, like ANY, EMPTY,
     * NOCHANGE etc.
     * 
     * @param extraItems
     *            The extra items to set as a list of LabelValueBean objects.
     */

    public void setExtraItems(List extraItems) {
        this.extraItems = extraItems;
    }

    /**
     * Forward the call to the target <code>ChainedOption</code>
     * 
     * @return the result from the target ChainedOption.
     */

    public String getOptionsKey() {
        return chainedOption.getOptionsKey();
    }

    /**
     * Set the <code>ChainedOption</code> that this decorator wraps.
     * 
     * @param chainedOption
     *            the <code>ChainedOption</code> to forward calls to.
     */

    public void setChainedOption(ChainedOption chainedOption) {
        this.chainedOption = chainedOption;
    }

    /**
     * Set the name of the property to inspect on the <code>command</code>
     * object to determine whether {@link #retrieveOptions(Object, Object)}and
     * {@link #updateValue(Object, List, Object)}should forward the call to the
     * target <code>ChainedOption</code>.
     * 
     * @param refreshProperty
     *            name of the property.
     */

    public void setRefreshProperty(String refreshProperty) {
        this.refreshProperty = refreshProperty;
    }

    /**
     * Set the options to display in this OptionValue. Needs to be a list of
     * LabelValueBeans.
     * 
     * @param options
     */

    public void setOptions(List options) {
        this.options = options;
    }

    /**
     * Just sort the options for this implementation.
     * 
     * @param options
     *            the options to sort.
     * @param context
     *            ignored for this implementation.
     * 
     * @return a new Sorted list containing the options.
     */

    public List adjustAndSort(List options, Object context) {
        LinkedList result = new LinkedList();
        result.addAll(options);
        Collections.sort(result);
        return result;
    }

    /**
     * Default implementation that loops through the supplied list of beans and
     * calls {@link #convertBean(Object)}on each one of them.
     * 
     * @param beans
     *            list of beans of any kind.
     * @return a new List containing the corresponding
     *         <code>LabelValueBean</code> objects.
     */

    public List convert(List beans) {
        List retval = new ArrayList(beans.size());
        for (Iterator iter = beans.iterator(); iter.hasNext();) {
            LabelValueBean bean = convertBean(iter.next());
            retval.add(bean);
        }

        return retval;
    }

    /**
     * Iterate through the collection of <code>ChainedOption</code> objects and
     * call <code>retrieveOptions</code> and <code>updateValue</code>. Put
     * the option Lists in the map with keys retrieved from the ChainedOption
     * objects.
     * 
     * @param model
     *            the map to store option Lists in.
     * @param command
     *            the command to operate on.
     * @param context
     *            the context.
     */

    public void referenceData(Map model, Object command, Object context) {
        for (Iterator iter = chainedOptions.iterator(); iter.hasNext();) {
            ChainedOption chainedOption = (ChainedOption) iter.next();
            List options = chainedOption.retrieveOptions(command, context);
            model.put(chainedOption.getOptionsKey(), options);
            chainedOption.updateValue(command, options, context);
        }
    }

    /**
     * Forward the call to the target <code>ChainedOption</code>.
     * 
     * @param command
     *            the <code>command</code> to operate on.
     * @return the value returned from the target <code>ChainedOption</code>.
     */

    public ChainedOptionStrategy getStrategy(Object command) {
        return chainedOption.getStrategy(command);
    }

    /**
     * Default implementation of <code>updateValue</code>, which loops
     * through the list of available options and compares them to the current
     * value of the managed attribute in the <code>command</code> object.
     * <p />
     * If the selected value is present in the list, no modifications are done
     * in the <code>command</code>, otherwise a default value is retrieved by
     * calling {@link ChainedOptionStrategy#getDefaultValue(List, Object)}, and
     * the <code>commandProperty</code> in the <code>command</code> is set
     * to this value.
     * 
     * @param command
     *            the object which will possibly be updated with a new object.
     * @param options
     *            the list of options with which the managed value in the
     *            <code>command</code> will be compared.
     * @param context
     *            a context that will be supplied to the
     *            <code>ChainedOptionStrategy</code> for selecting an
     *            appropriate default value.
     * @see ChainedOptionStrategy#getDefaultValue(List, Object)
     */

    public void updateValue(Object command, List options, Object context) {
        String selectedValue = getProperty(command, getCommandProperty());

        for (Iterator iter = options.iterator(); iter.hasNext();) {
            if (matches((LabelValueBean) iter.next(), selectedValue)) {
                return;
            }
        }

        setProperty(command, getCommandProperty(), getStrategy(command)
                .getDefaultValue(options, context));
    }

    /**
     * Utility method that matches the value of the given <code>bean</code>
     * with the specified <code>value</code>.
     * 
     * @param bean
     *            The {@link LabelValueBean}to match the value against.
     * @param value
     *            The value to match.
     * @return <code>true</code> if the values match.
     */

    protected boolean matches(LabelValueBean bean, String value) {
        if (value == null) {
            return false;
        }
        String beanValue = ((LabelValueBean) bean).getValue();
        return StringUtils.equals(beanValue, value);
    }

    /**
     * Template method that subclasses may implement to ensure proper
     * initialization. This method is called after all properties has been set.
     */

    protected void initChainedOption() {
    }

    /**
     * Utility method that sets a named property on a given object.
     * 
     * @param bean
     *            The object to set the property on.
     * @param propertyName
     *            The name of the property to set.
     * @param value
     *            The value that the property will be set to.
     */

    protected void setProperty(Object bean, String propertyName, Object value) {
        BeanWrapper commandWrapper = new BeanWrapperImpl(bean);
        commandWrapper.setPropertyValue(new PropertyValue(propertyName, value));
    }

    /**
     * Set the property on the target <code>command</code> object managed by
     * this instance.
     * 
     * @param commandProperty
     *            The commandProperty to set.
     */

    public void setCommandProperty(String commandProperty) {
        this.commandProperty = commandProperty;
    }

    /**
     * Set the key that should identify the option list managed by this
     * instance.
     * 
     * @param optionsKey
     *            The optionsKey to set.
     */

    public void setOptionsKey(String optionsKey) {
        this.optionsKey = optionsKey;
    }

    /**
     * Set the <code>BeanConverter</code> that should be used for translating
     * to LabelValueBeans.
     * 
     * @param converter
     *            The converter to set.
     */

    public void setConverter(BeanConverter converter) {
        this.converter = converter;
    }

    /**
     * Tests that matches is called with an object contained in the supplied
     * list, and that when matches returns <code>true</code>, no
     * modifications are made to the command.
     */

    public void testUpdateValue_valueExists() {
        SomeCommand someCommand = new SomeCommand();
        someCommand.setRegion("EU");

        final LabelValueBean expected = new LabelValueBean("a", "b");
        AbstractChainedOption tested = new AbstractChainedOption() {

            public List retrieveOptions(Object command, Object context) {
                return null;
            }

            protected boolean matches(LabelValueBean bean, String value) {
                assertSame(expected, bean);
                return true;
            }

            public ChainedOptionStrategy getStrategy(Object command) {
                return strategyMock;
            }
        };

        tested.setCommandProperty("region");

        tested.updateValue(someCommand, Collections.singletonList(expected),
                null);

        assertEquals("EU", someCommand.getRegion());
    }

    /**
     * Override this if the implementation has several strategies.
     * 
     * @return this implementation returns the <code>defaultStrategy</code>.
     */

    public ChainedOptionStrategy getStrategy(Object command) {
        return defaultStrategy;
    }

    /**
     * Set the default strategy to use.
     * 
     * @param defaultStrategy
     *            the default strategy to set.
     */

    public void setDefaultStrategy(ChainedOptionStrategy defaultStrategy) {
        this.defaultStrategy = defaultStrategy;
    }

    /**
     * At startup create and show the main frame of the application.
     */

    @Override protected void startup() {
        show(new VisualJBusinessView(this));
    }

    /**
     * This method is to initialize the specified window by injecting resources.
     * Windows shown in our application come fully initialized from the GUI
     * builder, so this additional configuration is not needed.
     */

    @Override protected void configureWindow(java.awt.Window root) {
    }

    /**
     * Returns project's database.
     * @return The database of the project.
     * @see com.jb.project.Database
     */

    public Database getDatabase() {
        return this.database;
    }

    /**
     * Sets project's database.
     * @param database The database of the project.
     * @see com.jb.project.Database
     */

    public void setDatabase(Database database) {
        this.database = database;
    }

    /**
     * Returns the table object (among the choosen tables) referenced by name.
     * @param name The table name as a String.
     * @return the table object, or null if no table named name is found in
     * choosen tables list.
     * @see com.jb.project.Table
     * @see com.jb.project.Database
     */

     public Table getChoosenTableByName(String name) {
        Table table = null, target = null;
        Tables choosenTables = getDatabase().getChoosenTables();
        for (int i = 0; i < choosenTables.getSize(); i++) {
            target = (Table) choosenTables.getElementAt(i);
            if (target.getName().equalsIgnoreCase(name)) {
                return target;
            }
        }
        return table;
    }

    /**
     * There are the so called head-lines relationship.
     * This can be used in code generation, as in JSF page generation.
     * given a 1 to many relationship between two tables, instead of
     * visually implement it by a menu (combo, etc) in the many side,
     * This is meant to be visually represented by a set of data from
     * a object (head) followed by a dataTable of objects (lines).
     * @param table
     * @return the table object (among choosen tables) with name equals
     * to registered head for the HLS relationship. Returns null case
     * thre is no head registered of if there is no table with the name.
     * @see com.jb.project.Table
     * @see com.jb.project.Database
     */

     public Table getChoosenTableHlsHead(Table table) {
        Table target = null;
        if (table.getHlsHead().equals("")) {
            // there is no head
            return (Table) null;
        }
        Tables choosenTables = getDatabase().getChoosenTables();
        for (int i = 0; i < choosenTables.getSize(); i++) {
            target = (Table) choosenTables.getElementAt(i);
            if (target.getName().equalsIgnoreCase(table.getHlsHead())) {
                // head found
                return target;
            }
        }
        return (Table) null;
    }

    /**
     * There are the so called head-lines relationship.
     * This can be used in code generation, as in JSF page generation.
     * given a 1 to many relationship between two tables, instead of
     * visually implement it by a menu (combo, etc) in the many side,
     * This is meant to be visually represented by a set of data from
     * a object (head) followed by a dataTable of objects (lines).
     * @param table
     * @return the table object (among choosen tables) with name equals
     * to registered lines for the HLS relationship. Returns null case
     * there is no lines table registered of if there is no table
     * with that name.
     * @see com.jb.project.Table
     * @see com.jb.project.Database
     */

    public Table getChoosenTableHlsLines(Table table) {
        Table target = null;
        if (table.getHlsLines().equals("")) {
            // there is no lines
            return (Table) null;
        }
        Tables choosenTables = getDatabase().getChoosenTables();
        for (int i = 0; i < choosenTables.getSize(); i++) {
            target = (Table) choosenTables.getElementAt(i);
            if (target.getName().equalsIgnoreCase(table.getHlsLines())) {
                // lines found
                return target;
            }
        }
        return (Table) null;
    }

    /**
     * Returns the object table with name equals to the foreign table name
     * registered in a table column object field fkTable.
     * @param column the column object of the table that is a foreign key.
     * @return the table object with name equals to the foreign table name,
     * or null if not found among the choosen tables of the project database.
     * @see com.jb.project.Column
     * @see com.jb.project.Table
     * @see com.jb.project.Database
     */

    public Table getColumnFkTable(Column column) {
        Table target = null;
        if (column.getFkTable().equals("")) {
            // there is no fkTable
            return (Table) null;
        }
        Tables choosenTables = getDatabase().getChoosenTables();
        for (int i = 0; i < choosenTables.getSize(); i++) {
            target = (Table) choosenTables.getElementAt(i);
            if (target.getName().equalsIgnoreCase(column.getFkTable())) {
                // fkTable found
                return target;
            }
        }
        return (Table) null;
    }

    /**
     * Get the value of securityPath
     *
     * @return the value of securityPath
     */

    public String getSecurityPath() {
        return securityPath;
    }

    /**
     * Set the value of securityPath
     *
     * @param securityPath new value of securityPath
     */

    public void setSecurityPath(String securityPath) {
        securityPath = securityPath.toLowerCase().trim();
        if(!securityPath.equals("")) {
            //securityPath.replaceAll("\\", "/");
            securityPath.replaceAll(".", "/");
            securityPath.replaceAll(" ", "");
            if(securityPath.startsWith("/")) {
                securityPath = securityPath.substring(1);
            }
            if(!securityPath.endsWith("/")) {
                securityPath = securityPath + "/";
            }
        }
        this.securityPath = securityPath;
    }

    /**
     * Returns the area that is occupied by the given cell. Does not
     * take into account any cell span.
     * @param col
     * @param row
     * @return Rectangle
     */

    protected Rectangle getCellRectIgnoreSpan(int col, int row) {
        return getCellRectIgnoreSpan(col, row, getColumnLeft(col) + 1);
    }

    /**
     * Get the value of tableName
     *
     * @return the value of tableName
     */

    public String getTableName() {
        return tableName;
    }

    /**
     * Get the value of menuVJB
     *
     * @return the value of menuVJB
     */

    public MenuVJB getMenuVJB() {
        return menuVJB;
    }

    /**
     * Set the value of tableName
     *
     * @param tableName new value of tableName
     */

    public void setTableName(String tableName) {
        this.tableName = tableName;
    }

    /**
     * Set the value of menuVJB
     *
     * @param menuVJB new value of menuVJB
     */

    public void setMenuVJB(MenuVJB menuVJB) {
        this.menuVJB = menuVJB;
    }

    /**
     * Get the value of titleOfMenuOfItemsVJB
     *
     * @return the value of titleOfMenuOfItemsVJB
     */

    public String getTitleOfMenuOfItemsVJB() {
        return titleOfMenuOfItemsVJB;
    }

    /**
     * Set the value of titleOfMenuOfItemsVJB
     *
     * @param titleOfMenuOfItemsVJB new value of titleOfMenuOfItemsVJB
     */

    public void setTitleOfMenuOfItemsVJB(String titleOfMenuOfItemsVJB) {
        this.titleOfMenuOfItemsVJB = titleOfMenuOfItemsVJB;
    }

    /**
     * Get the value of menuOfItemsSetted
     *
     * @return the value of menuOfItemsSetted
     */

    public boolean isMenuOfItemsSetted() {
        return menuOfItemsSetted;
    }

    /**
     * Set the value of menuOfItemsSetted
     *
     * @param menuOfItemsSetted new value of menuOfItemsSetted
     */

    public void setMenuOfItemsSetted(boolean menuOfItemsSetted) {
        this.menuOfItemsSetted = menuOfItemsSetted;
    }

    /**
     * Get the value of menuBarVJB
     *
     * @return the value of menuBarVJB
     */

    public MenuBarVJB getMenuBarVJB() {
        return menuBarVJB;
    }

    /**
     * Set the value of menuBarVJB
     *
     * @param menuBarVJB new value of menuBarVJB
     */

    public void setMenuBarVJB(MenuBarVJB menuBarVJB) {
        this.menuBarVJB = menuBarVJB;
    }

    /**
     * Get the value of addNewMenuBar
     *
     * @return the value of addNewMenuBar
     */

    public boolean isAddNewMenuBar() {
        return addNewMenuBar;
    }

    /**
     * Set the value of addNewMenuBar
     *
     * @param addNewMenuBar new value of addNewMenuBar
     */

    public void setAddNewMenuBar(boolean addNewMenuBar) {
        this.addNewMenuBar = addNewMenuBar;
    }

    /**
     * Get the value of selectedTable
     *
     * @return the value of selectedTable
     */

    public Table getSelectedTable() {
        return selectedTable;
    }

    /**
     * Get the value of menuOfBarVJB
     *
     * @return the value of menuOfBarVJB
     */

    public MenuOfBarVJB getMenuOfBarVJB() {
        return menuOfBarVJB;
    }

    /**
     * Set the value of selectedTable
     *
     * @param selectedTable new value of selectedTable
     */

    public void setSelectedTable(Table selectedTable) {
        this.selectedTable = selectedTable;
    }

    /**
     * Set the value of menuOfBarVJB
     *
     * @param menuOfBarVJB new value of menuOfBarVJB
     */

    public void setMenuOfBarVJB(MenuOfBarVJB menuOfBarVJB) {
        this.menuOfBarVJB = menuOfBarVJB;
    }

    /**
     * Get the value of targetClassSelected
     *
     * @return the value of targetClassSelected
     */

    public boolean isTargetClassSelected() {
        return targetClassSelected;
    }

    /**
     * Set the value of targetClassSelected
     *
     * @param targetClassSelected new value of targetClassSelected
     */

    public void setTargetClassSelected(boolean targetClassSelected) {
        this.targetClassSelected = targetClassSelected;
    }

    /**
     * Get the value of menuTitle
     *
     * @return the value of menuTitle
     */

    public String getMenuTitle() {
        return menuTitle;
    }

    /**
     * Set the value of menuTitle
     *
     * @param menuTitle new value of menuTitle
     */

    public void setMenuTitle(String menuTitle) {
        this.menuTitle = menuTitle;
    }

    /**
     * Get the value of menuVJBType
     *
     * @return the value of menuVJBType
     */

    public int getMenuVJBType() {
        return menuVJBType;
    }

    /**
     * Set the value of menuVJBType
     *
     * @param menuVJBType new value of menuVJBType
     */

    public void setMenuVJBType(int menuVJBType) {
        this.menuVJBType = menuVJBType;
    }

    /**
     * Get the value of createNewMenuBar
     *
     * @return the value of createNewMenuBar
     */

    public boolean isCreateNewMenuBar() {
        return createNewMenuBar;
    }

    /**
     * Get the value of selected
     *
     * @return the value of selected
     */

    public boolean isSelected() {
        return selected;
    }

    /**
     * Set the value of createNewMenuBar
     *
     * @param createNewMenuBar new value of createNewMenuBar
     */

    public void setCreateNewMenuBar(boolean createNewMenuBar) {
        this.createNewMenuBar = createNewMenuBar;
    }

    /**
     * Set the value of selected
     *
     * @param selected new value of selected
     */

    public void setSelected(boolean selected) {
        this.selected = selected;
    }

    /**
     * Get the value of menuBarVJBName
     *
     * @return the value of menuBarVJBName
     */

    public String getMenuBarVJBName() {
        return menuBarVJBName;
    }

    /**
     * Set the value of menuBarVJBName
     *
     * @param menuBarVJBName new value of menuBarVJBName
     */

    public void setMenuBarVJBName(String menuBarVJBName) {
        this.menuBarVJBName = menuBarVJBName;
    }

    /**
     * Set the value of menuItemVJBList
     *
     * @param menuItemVJBList new value of menuItemVJBList
     */

    public void setMenuItemVJBList(ArrayList<MenuItemVJB> menuItemVJBList) {
        this.menuItemVJBList = menuItemVJBList;
    }

    /**
     * Set the value of menuVJBList
     *
     * @param menuVJBList new value of menuVJBList
     */

    public void setMenuVJBList(ArrayList<MenuVJB> menuVJBList) {
        this.menuVJBList = menuVJBList;
    }

    /**
     * Set the value of menusBarVJB
     *
     * @param menusBarVJB new value of menusBarVJB
     */

    public void setMenusBarVJB(ArrayList<MenuBarVJB> menusBarVJB) {
        this.menusBarVJB = menusBarVJB;
    }

    /** Convenience method to test whether drop location is valid
    @param destination The destination path 
    @param dropper The path for the node to be dropped
    @return null if no problems, otherwise an explanation
     */

    private String testDropTarget(TreePath destination, TreePath dropper) {
        //Typical Tests for dropping

        //Test 1.
        boolean destinationPathIsNull = destination == null;
        if (destinationPathIsNull) {
            return "Invalid drop location.";
        }

        //Test 2.
        MenuNode node = (MenuNode) destination.getLastPathComponent();
        if (!node.getAllowsChildren()) {
            return "This node does not allow children";
        }

        if (destination.equals(dropper)) {
            return "Destination cannot be same as source";
        }

        //Test 3.
        if (dropper.isDescendant(destination)) {
            return "Destination node cannot be a descendant.";
        }

        //Test 4.
        if (dropper.getParentPath().equals(destination)) {
            return "Destination node cannot be a parent.";
        }

        return null;
    }

    /**
     * Redraws the the cells only in the given area.
     * 
     * @param cellsToRedraw
     *            Defines the area to redraw. The rectangles elements are not
     *            pixels but cell numbers.
     */

    public void redraw(Rectangle cellsToRedraw) {
        checkWidget();
        redraw(cellsToRedraw.x, cellsToRedraw.y, cellsToRedraw.width,
                cellsToRedraw.height);
    }

    /**
     * Call when a manual redraw on a cell should be performed.
     * In case headers should be updated to reflect a focus change, this is performed.
     * @param gc
     * @param col
     * @param row
     */

    protected void drawCell(GC gc, int col, int row) {
        
        drawCell(gc, col, row, getCellRect(col, row));
        
        Rectangle oldClip = gc.getClipping();
        gc.setClipping(getClientArea());
        if ((getStyle() & SWTX.MARK_FOCUS_HEADERS)==SWTX.MARK_FOCUS_HEADERS) {
            if (row>=m_TopRow) {
                for (int i=0; i<m_Model.getFixedHeaderColumnCount(); i++)
                    drawCell(gc, i, row, getCellRect(i, row));
                for (int i=0; i<m_Model.getFixedHeaderRowCount(); i++)
                    drawCell(gc, col, i, getCellRect(col, i));
            }
        }
        gc.setClipping(oldClip);
    }

    /**
     * Get the value of dateMask
     *
     * @return the value of dateMask
     */

    public String getDateMask() {
        return dateMask;
    }

    /**
     * Set the value of dateMask
     *
     * @param dateMask new value of dateMask
     */

    public void setDateMask(String dateMask) {
        this.dateMask = dateMask;
    }

    /**
     * Interface method to update the content of a cell.<p>
     * Don't forget to map the row index if a sorted model is used.
     * @param col The column index
     * @param row The row index.
     * @see KTableSortedModel#mapRowIndexToTable(int)
     */

    public void updateCell(int col, int row) {
        checkWidget();
        if ((row < 0) || (row >= m_Model.getRowCount()) || 
            (col < 0) || (col >= m_Model.getColumnCount()))
            return;

        // be sure it is a valid cell if cells span 
        Point valid = getValidCell(col, row);
        // update it:
        GC gc = new GC(this);
        drawCell(gc, valid.x, valid.y);
        gc.dispose();
    }

    /**
     * Get the value of selectedPanel
     *
     * @return the value of selectedPanel
     */

    public JPanel getSelectedPanel() {
        return selectedPanel;
    }

    /**
     * Set the value of selectedPanel
     *
     * @param selectedPanel new value of selectedPanel
     */

    public void setSelectedPanel(JPanel selectedPanel) {
        this.selectedPanel = selectedPanel;
    }

    /**
     * At startup create and show the main frame of the application.
     */

    @Override protected void startup() {
        show(new HotdogView(this));
    }

    /**
     * Check if any table row is selected.
     *
     * @return true if a row is selected, otherwise false.
     */

    public boolean isUfRecordSelected() {
        return ufTable.getSelectedRow() != -1;
    }

    /**
     * Get the value of saveFired
     *
     * @return the value of saveFired
     */

    public boolean isSaveFired() {
        return saveFired;
    }

    /**
     * Set the value of saveFired
     *
     * @param saveFired new value of saveFired
     */

    public void setSaveFired(boolean saveFired) {
        this.saveFired = saveFired;
    }

    /**
     * Get the value of currentRecord
     *
     * @return the value of currentRecord
     */

    public Cliente getCurrentRecord() {
        return currentRecord;
    }

    /**
     * Set the value of currentRecord
     *
     * @param currentRecord new value of currentRecord
     */

    public void setCurrentRecord(Cliente currentRecord) {
        Cliente oldRecord = this.currentRecord;
        this.currentRecord = currentRecord;
        propertyChangeSupport.firePropertyChange("currentRecord",
                oldRecord, currentRecord);
    }

    /**
     * Check if any table row is selected.
     *
     * @return true if a row is selected, otherwise false.
     */

    public boolean isCidadeRecordSelected() {
        return cidadeTable.getSelectedRow() != -1;
    }

    /**
     * Sets the default cursor to the given cursor. This instance is saved
     * internally and displayed whenever no linecursor or resizecursor is shown.
     * <p>
     * The difference to setCursor is that this cursor will be preserved over
     * action cursor changes.
     * 
     * @param cursor
     *            The cursor to use, or <code>null</code> if the OS default
     *            cursor should be used.
     * @param size_below_hotspot The number of pixels that are needed to paint the 
     * 	      cursor below and right of the cursor hotspot (that is the actual location the cursor
     *        is pointing to).<p>
     *        NOTE that this is just there to allow better positioning of tooltips.
     * 	      Currently SWT does not provide an API to get the size of the cursor. So
     *        these values are taken to calculate the position of the tooltip. The
     *        the tooltip is placed pt.x pixels left and pt.y pixels below the mouse location.<br>
     *        If you don't know the size of the cursor (for example you use a default one), set 
     *        <code>null</code> or <code>new Point(-1, -1)</code>. 
     */

    public void setDefaultCursor(Cursor cursor, Point size_below_hotspot) {
        checkWidget();
        if (m_defaultCursor != null)
            m_defaultCursor.dispose();
        m_defaultCursor = cursor;
        m_defaultCursorSize = size_below_hotspot;
        setCursor(cursor);
    }

    /**
     * Get the value of currentRecord
     *
     * @return the value of currentRecord
     */

    public Animal getCurrentRecord() {
        return currentRecord;
    }

    /**
     * Set the value of currentRecord
     *
     * @param currentRecord new value of currentRecord
     */

    public void setCurrentRecord(Animal currentRecord) {
        Animal oldRecord = this.currentRecord;
        this.currentRecord = currentRecord;
        propertyChangeSupport.firePropertyChange("currentRecord",
                oldRecord, currentRecord);
    }

    /**
     * Get the value of currentRecord
     *
     * @return the value of currentRecord
     */

    public Hospedagem getCurrentRecord() {
        return currentRecord;
    }

    /**
     * Set the value of currentRecord
     *
     * @param currentRecord new value of currentRecord
     */

    public void setCurrentRecord(Hospedagem currentRecord) {
        Hospedagem oldRecord = this.currentRecord;
        this.currentRecord = currentRecord;
        propertyChangeSupport.firePropertyChange("currentRecord",
                oldRecord, currentRecord);
        if(this.currentRecord == null) {
            Logger.getLogger(this.getClass().getName()).
                warning("this.current record is null!");
        }
        Logger.getLogger(this.getClass().getName()).
                info("setCurrentRecord method, diaria value : " + this.currentRecord.getDiaria());
    }

    /**
     * Check if any table row is selected.
     *
     * @return true if a row is selected, otherwise false.
     */

    public boolean isAnimalRecordSelected() {
        return animalTable.getSelectedRow() != -1;
    }

    /**
     * Get the value of currentRecord
     *
     * @return the value of currentRecord
     */

    public Cidade getCurrentRecord() {
        return currentRecord;
    }

    /**
     * Set the value of currentRecord
     *
     * @param currentRecord new value of currentRecord
     */

    public void setCurrentRecord(Cidade currentRecord) {
        Cidade oldRecord = this.currentRecord;
        this.currentRecord = currentRecord;
        propertyChangeSupport.firePropertyChange("currentRecord",
                oldRecord, currentRecord);
    }

    /**
     * Check if any table row is selected.
     *
     * @return true if a row is selected, otherwise false.
     */

    public boolean isClienteRecordSelected() {
        return clienteTable.getSelectedRow() != -1;
    }

    /**
     * Check if any table row is selected.
     *
     * @return true if a row is selected, otherwise false.
     */

    public boolean isHospedagemRecordSelected() {
        return hospedagemTable.getSelectedRow() != -1;
    }

    /**
     * Get the value of desconto
     *
     * @return the value of desconto
     */

    public Double getDesconto() {
        return desconto;
    }

    /**
     * Set the value of desconto
     *
     * @param desconto new value of desconto
     */

    public void setDesconto(Double desconto) {
        this.desconto = desconto;
    }

    /**
     * Get the value of diaria
     *
     * @return the value of diaria
     */

    public Double getDiaria() {
        return diaria;
    }

    /**
     * Set the value of diaria
     *
     * @param diaria new value of diaria
     */

    public void setDiaria(Double diaria) {
        this.diaria = diaria;
    }

    /**
     * Get the value of fim
     *
     * @return the value of fim
     */

    public Date getFim() {
        return fim;
    }

    /**
     * Set the value of fim
     *
     * @param fim new value of fim
     */

    public void setFim(Date fim) {
        this.fim = fim;
    }

    /**
     * Get the value of inicio
     *
     * @return the value of inicio
     */

    public Date getInicio() {
        return inicio;
    }

    /**
     * Set the value of inicio
     *
     * @param inicio new value of inicio
     */

    public void setInicio(Date inicio) {
        this.inicio = inicio;
    }

    /**
     * Get the value of animal
     *
     * @return the value of animal
     */

    public Animal getAnimal() {
        return animal;
    }

    /**
     * Set the value of animal
     *
     * @param animal new value of animal
     */

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    /**
     * Checks for the event location in table coordinates within the region covered
     * by the columns beginning by startCol and ending by endCol.
     * @param span Set to true if for spanning cells we just want to have the left-upper-most cell.
     */

    protected Point checkIfMatchesInColumns(int startRow, int endRow, int startCol, int endCol, Point toFind, boolean span) {
        
        for (int row = startRow; row < endRow; row++) {
            for (int col = startCol; col < endCol; col++) {
                
                Rectangle rect = getCellRectIgnoreSpan(col, row);
                // take into account the 1px right and bottom border
                rect.width+=1;
                rect.height+=1;
                if (rect.contains(toFind))
                    if (span)
                    // take into account the spanning when reporting a match:
                        return getValidCell(col, row);
                    else
                        return new Point(col, row);
            }
        }
        return null;
    }

    /**
     * Set the value of players
     *
     * @param players new value of players
     */

    public void setPlayers(ArrayList<PlayerThread> players) {
        this.players = players;
    }

    /**
     * Get the value of type
     *
     * @return the value of type
     */

    public int getType() {
        return type;
    }

    /**
     * Set the value of type
     *
     * @param type new value of type
     */

    public void setType(int type) {
        this.type = type;
    }

    /**
     * Get the value of playerName
     *
     * @return the value of playerName
     */

    public String getPlayerName() {
        return playerName;
    }

    /**
     * Set the value of playerName
     *
     * @param playerName new value of playerName
     */

    public void setPlayerName(String playerName) {
        this.playerName = playerName;
    }

    /**
     * Get the value of serverPort
     *
     * @return the value of serverPort
     */

    public Integer getServerPort() {
        return serverPort;
    }

    /**
     * Set the value of serverPort
     *
     * @param serverPort new value of serverPort
     */

    public void setServerPort(Integer serverPort) {
        this.serverPort = serverPort;
    }

    /**
     * Get the value of serverIP
     *
     * @return the value of serverIP
     */

    public String getServerIP() {
        return serverIP;
    }

    /**
     * Set the value of serverIP
     *
     * @param serverIP new value of serverIP
     */

    public void setServerIP(String serverIP) {
        this.serverIP = serverIP;
    }

    /**
     * Get the value of keyframeController
     *
     * @return the value of keyframeController
     */

    public KeyframeController getKeyframeController() {
        return keyframeController;
    }

    /**
     * Set the value of keyframeController
     *
     * @param keyframeController new value of keyframeController
     */

    public void setKeyframeController(KeyframeController keyframeController) {
        this.keyframeController = keyframeController;
    }

    /**
     * Get the value of node
     *
     * @return the value of node
     */

    public Node getNode() {
        return node;
    }

    /**
     * Set the value of node
     *
     * @param node new value of node
     */

    public void setNode(Node node) {
        this.node = node;
    }

    /**
     * Set the value of modelAnimationsList
     *
     * @param modelAnimationsList new value of modelAnimationsList
     */

    public void setModelAnimationsList(List<ModelAnimation> modelAnimationsList) {
        this.modelAnimationsList = modelAnimationsList;
    }

    /**
     * Get the value of baseAnimation
     *
     * @return the value of baseAnimation
     */

    public ModelAnimation getBaseAnimation() {
        return baseAnimation;
    }

    /**
     * Set the value of baseAnimation
     *
     * @param baseAnimation new value of baseAnimation
     */

    public void setBaseAnimation(ModelAnimation baseAnimation) {
        this.baseAnimation = baseAnimation;
    }

    /**
     * Get the value of runAnimation
     *
     * @return the value of runAnimation
     */

    public ModelAnimation getRunAnimation() {
        return runAnimation;
    }

    /**
     * Set the value of runAnimation
     *
     * @param runAnimation new value of runAnimation
     */

    public void setRunAnimation(ModelAnimation runAnimation) {
        this.runAnimation = runAnimation;
    }

    /**
     * create our custom input handler.
     *
     */

    private void buildInput() {
        input = new ChaseDoomHandler(player.getNode(), properties.getRenderer());
        mouse = new RelativeMouse("Mouse Input");
        mouse.registerWithInputHandler(input);
	mouse.setCullMode(Spatial.CULL_ALWAYS);
        URL cursorFile = null;
        try {
            cursorFile = new File("model", "cursor1.png").toURI().toURL();
        } catch (MalformedURLException ex) {
            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);
        }
        MouseInput.get().setHardwareCursor(cursorFile);
    }

    /**
     * Get the value of beginFrame
     *
     * @return the value of beginFrame
     */

    public int getBeginFrame() {
        return beginFrame;
    }

    /**
     * Set the value of beginFrame
     *
     * @param beginFrame new value of beginFrame
     */

    public void setBeginFrame(int beginFrame) {
        this.beginFrame = beginFrame;
    }

    /**
     * Get the value of endFrame
     *
     * @return the value of endFrame
     */

    public int getEndFrame() {
        return endFrame;
    }

    /**
     * Set the value of endFrame
     *
     * @param endFrame new value of endFrame
     */

    public void setEndFrame(int endFrame) {
        this.endFrame = endFrame;
    }

    /**
     * Get the value of animating
     *
     * @return the value of animating
     */

    public boolean isAnimating() {
        return animating;
    }

    /**
     * Set the value of animating
     *
     * @param animating new value of animating
     */

    public void setAnimating(boolean animating) {
        this.animating = animating;
    }

    /**
     * Set the value of keys
     *
     * @param keys new value of keys
     */

    public void setKeys(List<Integer> keys) {
        if (this.getKeys().size()>0) {
            this.getKeys().clear();
        }
        this.getKeys().addAll(keys);
    }

    /**
     * True if the text is to be displayed during rendering.
     *
     * @return True if the text should be displayed.
     */

    public boolean isEnabled() {

        return enabled;
    }

    /**
     * Sets whether we should cull the text during rendering.
     *
     * @param enabled True if the text should be displayed.
     */

    public void setEnabled(boolean enabled) {

        this.enabled = enabled;

        if (enabled) {
            setCullMode(CULL_DYNAMIC);
        } else {
            setCullMode(CULL_ALWAYS);
        }
    }

    /**
     * Sets the colour of the text.
     *
     * @param color The colour of the text.
     */

    public void setColor(ColorRGBA color) {

        this.color = color;

        text2D.setTextColor(color);
    }

    /**
     * Sets the offset from the target to display text at.
     *
     * @param offset The offset from the target to display text.
     */

    public void setOffset(Vector3f offset) {

        this.offset = offset;
    }

    /**
     * Sets the text to display.
     *
     * @param text The text string to display.
     */

    public void setText(String text) {

        text2D.setText(text);
    }

    /**
     * Sets the horizontal alignment of text to the target.
     *
     * @param align The horizontal alignment of text.
     */

    public void setHorizontalAlignment(int align) {

        if (align == HA_LEFT) {
            alignOffset = 0;
        } else if (align == HA_CENTER) {
            alignOffset = (text2D.getWidth() / 2) * -1;
        } else if (align == HA_RIGHT) {
            alignOffset = text2D.getWidth() * -1;
        }

        alignOffset = alignOffset * getLocalScale().x;
    }

    /**
     * Sets the vertical alignment of text to the target.
     *
     * @param valign The vertical alignment of text.
     */

    public void setVerticalAlignment(int valign) {

        if (valign == VA_TOP) {
            valignOffset = 0;
        } else if (valign == VA_MIDDLE) {
            valignOffset = (text2D.getHeight() / 2) * -1;
        } else if (valign == VA_BOTTOM) {
            valignOffset = text2D.getHeight() * -1;
        }

        valignOffset = valignOffset * getLocalScale().y;
    }

    /**
     * Get the value of editorOutcomeSave
     *
     * @return the value of editorOutcomeSave
     */

    public boolean isEditorOutcomeSave() {
        return editorOutcomeSave;
    }

    /**
     * Set the value of editorOutcomeSave
     *
     * @param editorOutcomeSave new value of editorOutcomeSave
     */

    public void setEditorOutcomeSave(boolean editorOutcomeSave) {
        this.editorOutcomeSave = editorOutcomeSave;
    }

    /**
     * Sets the global tooltip for the whole table.<br>
     * Note that this is only shown if the cell has no tooltip set.
     * For tooltips on cell level (that overwrite this value), look
     * for the method <code>getTooltipText()</code>.
     * @see de.kupzog.ktable.KTableModel#getTooltipAt(int, int)
     * @see de.kupzog.ktable.KTable#getToolTipText()
     * @param tooltip The global tooltip for the table.
     */

    public void setToolTipText(String tooltip) {
        m_nativTooltip = tooltip;
    }

    /**
     * Returns the global tooltip for the whole table.<br>
     * Note that this is not shown when there is a non-empty tooltip
     * for the cell.
     * @see de.kupzog.ktable.KTable#setToolTipText(String)
     * @see de.kupzog.ktable.KTableModel#getTooltipAt(int, int)
     */

    public String getToolTipText() {
        return m_nativTooltip;
    }

    /**
     * This method activated the cell editor on the current focus cell, if the
     * table model allows cell editing for this cell.
     */

    public void openEditorInFocus(KTableCellEditor cellEditor) {
        checkWidget();
        //m_CellEditor = m_Model.getCellEditor(m_FocusCol, m_FocusRow);
        m_CellEditor = cellEditor; //@Trifon
        if (m_CellEditor != null) {
            scrollToFocus();
            Rectangle r = getCellRect(m_FocusCol, m_FocusRow);
            m_CellEditor.open(this, m_FocusCol, m_FocusRow, r);
        }
    }

    /**
     * Scrolls the table so that the given cell is top left.
     * @param col The column index.
     * @param row The row index.
     */

    public void scroll(int col, int row) {
        if (col<0 || col>=m_Model.getColumnCount() ||
            row<0 || row>=m_Model.getRowCount())
            return;
        
        m_TopRow = row;
        m_LeftColumn=col;
        redraw();
    }

    /**
     * Adds a listener that is notified when a cell is selected.
     * 
     * This can happen either by a click on the cell or by arrow keys. Note that
     * the listener is not called for each cell that the user selects in one
     * action using Shift+Click. To get all these cells use the listener and
     * getCellSelecion() or getRowSelection().
     * 
     * @param listener
     */

    public void addCellSelectionListener(KTableCellSelectionListener listener) {
        cellSelectionListeners.add(listener);
    }

    /**
     * Adds a listener that is notified when a cell is resized.
     * This happens when the mouse button is released after a resizing.
     * @param listener
     */

    public void addCellResizeListener(KTableCellResizeListener listener) {
        cellResizeListeners.add(listener);
    }

    /**
     * Adds a listener that is notified when a cell is doubleClicked.
     *
     * @param listener
     */

    public void addCellDoubleClickListener(KTableCellDoubleClickListener listener) {
        cellDoubleClickListeners.add(listener);
    }

    /**
     * Removes the listener if present. 
     * Returns true, if found and removed from the list of listeners.
     */

    public boolean removeCellSelectionListener(KTableCellSelectionListener listener) {
        return cellSelectionListeners.remove(listener);
    }

    /**
     * Removes the listener if present. 
     * Returns true, if found and removed from the list of listeners.
     */

    public boolean removeCellResizeListener(KTableCellResizeListener listener) {
        return cellResizeListeners.remove(listener);
    }

    /**
     * Removes the listener if present.
     * Returns true, if found and removed from the list of listeners.
     */

    public boolean removeDoubleClickListener(KTableCellDoubleClickListener listener) {
        return cellDoubleClickListeners.remove(listener);
    }

  /** first record is 1 */

  public void gotoRecord(int pos) {
    curRecordIndex = pos;
    int rowNb = curRecordIndex-1+firstRowIndex;
    getCaller().trace.trace("Moving to record #"+pos+" (row #"+rowNb+")");
    if(rowNb<firstRowIndex || rowNb>lastRowIndex)
      curRow = null;
    else
      curRow = curSheet.getRow(rowNb);
  }

  /** First column is 1 */

  public Value getColumn(int i) throws ExecuteException {
    if(i<1 || i>sheetLabels.length)
      throw new ExecuteException("Cell #"+i+" is out of range");
    if(curRow==null) return NullValue.NULL;
    getCaller().trace.trace("Getting column #"+i);
    return getCellValue((short)(i-1));
    // getCellType: CELL_TYPE_STRING, CELL_TYPE_NUMERIC, CELL_TYPE_FORMULA, CELL_TYPE_BOOLEAN, CELL_TYPE_ERROR
    //    return cell.getNumericCellValue();
  }

    /**
     * Returns true if in "Full Selection Mode". 
     * Mode is determined by style bits in the constructor or 
     * by <code>setStyle()</code>. (style: SWT.FULL_SELECTION)
     * @return boolean
     */

    public boolean isRowSelectMode() {
        return (getStyle() & SWT.FULL_SELECTION) == SWT.FULL_SELECTION;
    }

    /**
     * Returns true if in "Multi Selection Mode".
     * Mode is determined by style bits in the constructor (SWT.MULTI)
     * or by <code>getStyle()</code>.
     */

    public boolean isMultiSelectMode() {
        return (getStyle() & SWT.MULTI) == SWT.MULTI;
    }

  /** there is no way to know if numeric cells with generic format
   * are reals or integers... this method returns true if the first
   * 100 rows do not include reals (or dates) */ 

  protected boolean first100AreInteger(short col) {
    int i = firstRowIndex;
    HSSFRow row;
    while((row=curSheet.getRow(i++))!=null && i<100) {
      HSSFCell cell = row.getCell(col);
      if(cell!=null) {
	if(cell.getCellType()==HSSFCell.CELL_TYPE_NUMERIC)
        try {
          float val = (float)cell.getNumericCellValue();
          if(val!=(float)((int)val)) return false;
	} catch (NumberFormatException exc) {return false;}
      }
    }
    return true;
  }

  /** Parse next element.
   * @return the element read, null otherwise
   */

  public ASTXMLObject nextXML() throws ExecuteException {
    currentChildIndex++;
    if(currentChildIndex<(bufStart+buffer.size()))
      return (ASTXMLObject) buffer.get(currentChildIndex+bufStart);
    else 
      try{return parseXML();}
      catch (XMLException exc) {
        if(onerror==null) throw exc;
        else {
          onerror.executeWithExc(exc,
              "Caught XML exception while parsing "+fileName);
          return null;
        }
      }
  }

  /** Initialise parser and loads document header */

  public void initParser() throws ExecuteException {
    bufStart = -1;
    buffer.removeAllElements();
    getCaller().trace.debug("*** Parsing "+fileName+" header...");
    FileReader fileReader;
    // TBD: set encoding
    try {fileReader = new FileReader(fileName);}
    catch (FileNotFoundException exc) {
      throw new ExecuteException("File not found: "+fileName);}
    parser = new Parser(fileReader);
    // parse header
    try {
      boolean allowDSQL = allowDSQL();
      root = parser.XMLHeader(allowDSQL,allowDSQL);
      // TBD: detect empty document, i.e. <doc/>
    } catch (ParseException exc) {
      throw new XMLException(fileName,exc);
    } catch (TokenMgrError exc) {
      throw new XMLException(fileName,exc);
    }
  }

  /** In a string context, a TableResults returns the first
   * column of the first row of its first result */

  public String getString() throws ExecuteException {
    if(getColumnCount()==0) return null;
    if(currentRecord()>1) reset();
    if(currentRecord()==0) 
      if(!nextRecord()) return null;
    return getColumnString(1);
  }

  /** needed by TableResult.setPrimaryKeys 
   * @return index of label column in table */

  protected int findColumn(String label) throws ExecuteException {
    Integer i = (Integer) columnLabels.get(label);
    if(i!=null) return i.intValue();
    else throw new ExecuteException("No column "+label+" in results");
  }

    /**
     * Clears the current selection (in all selection modes).
     */

    public void clearSelection() {
        checkWidget();
        clearSelectionWithoutRedraw();
        m_FocusCol = -1;
        m_FocusRow = -1;
        if (isMultiSelectMode())
            redraw();
    }

    /**
     * Works in both modes: Cell and Row Selection.
     * Has no redraw functionality!<p>
     * 
     * Returns true, if added to selection.
     */

    protected boolean toggleSelection(int col, int row) {

        if (isMultiSelectMode()) {
            Object o;
            if (isRowSelectMode()) {
                o = new Integer(row);
            } else {
                o = new Point(col, row);
            }
            if (m_Selection.get(o) != null) {
                m_Selection.remove(o);
                return false;
            } else {
                m_Selection.put(o, o);
                return true;
            }
        }
        return false;
    }

    /**
     * Works in both modes: Cell and Row Selection.
     * Has no redraw functionality!
     */

    protected void addToSelectionWithoutRedraw(int col, int row) {
        if (isMultiSelectMode()) {
            if (isRowSelectMode()) {
                Integer o = new Integer(row);
                m_Selection.put(o, o);
            } else {
                Point o = new Point(col, row);
                m_Selection.put(o, o);
            }
        }
    }

    /**
     * Selects the given cell. If scroll is true, 
     * it scrolls to show this cell if neccessary.
     * In Row Selection Mode, the given row is selected
     * and a scroll to the given column is done.
     * Does nothing if the cell does not exist. <p>
     * Note that if you use a sorted model, don't forget to map the row index!
     * @param col
     * @param row
     * @param scroll
     */

    public void setSelection(int col, int row, boolean scroll) {
        checkWidget();
        if (col < m_Model.getColumnCount()
                && col >= m_Model.getFixedHeaderColumnCount()
                && row < m_Model.getRowCount()
                && row >= m_Model.getFixedHeaderRowCount()) {
            focusCell(col, row, 0);
            if (scroll) {
                scrollToFocus();
            }
        }
    }

  /** needed by TableResult.setPrimaryKeys */

  protected int findColumn(String label) throws ExecuteException {
    if(cachedLabels!=null && cachedLabels.get(label)!=null)
      return ((Integer)cachedLabels.get(label)).intValue();
    else {
      if(rs==null) // not sure this can ever happen 
        throw new ExecuteException("No SQL results");
      try {return rs.findColumn(label);}
      catch (SQLException exc) {throw new ExecuteException(
        "Column "+label+" does not exist in results");}
    }
  }

    /**
     * Returns true, if the given cell is selected.
     * Works also in Row Selection Mode.
     * @param col the column index.
     * @param row the row index.
     * @return boolean Returns true if the given cell is selected.
     */

    public boolean isCellSelected(int col, int row) {
        checkWidget();
        Point v = getValidCell(col, row);
        col = v.x;
        row = v.y;
        if (!isMultiSelectMode()) {
            if (isRowSelectMode())
                return (row == m_FocusRow);
            return (col == m_FocusCol && row == m_FocusRow);
        }

        if (isRowSelectMode())
            return (m_Selection.get(new Integer(row)) != null);
        else
            return (m_Selection.get(new Point(col, row)) != null);
    }

    /**
     * Returns true, if the given row is selected.
     * Returns always false if not in Row Selection Mode!<p>
     * If you use a sorted model, don't forget to map the row index first.
     * @param row The row index as seen by the KTable.
     * @return boolean returns true if the row is selected at the moment.
     */

    public boolean isRowSelected(int row) {
        return (m_Selection.get(new Integer(row)) != null);
    }

  /** Access an object's field */

  public Object getField(String name) throws ExecuteException {
    if(name.equals("start")) return new IntValue(start);
    if(name.equals("end")) return new IntValue(end);
    return super.getField(name);
  }

    /**
     * Internal helper method to determine wether the cell at the 
     * given position is to be highlighted because it is a header cell
     * that corresponds to a selected cell.
     * @param col The column index
     * @param row The row index
     * @return true if the cell should be highlighted.
     */

    private boolean highlightSelectedRowCol(int col, int row) {
        if (!isHighlightSelectionInHeader() || !isHeaderCell(col, row))
            return false;
        
        Point[] sel = getCellSelection();
        if (sel!=null) {
            for (int i=0; i<sel.length; i++) {
                if (sel[i].x == col || sel[i].y == row) 
                    return true;
                Point valid = getValidCell(sel[i].x, row);
                if (valid.x == col) return true;
                valid = getValidCell(col, sel[i].y);
                if (valid.y == row) return true;
            }
        }
        return false;
    }

    /**
     * Sets the table model.
     * The table model provides data to the table.
     * @see de.kupzog.ktable.KTableModel for more information.
     * @param model The KTableModel instance that provides the table with all 
     * necessary data!
     */

    public void setModel(KTableModel model) {
        checkWidget();
        m_Model = model;
        m_FocusCol = -1;
        m_FocusRow = -1;
        clearSelectionWithoutRedraw();
        
        // implement autoscrolling if needed:
        if ((getStyle() & SWTX.AUTO_SCROLL) == SWTX.AUTO_SCROLL)
            updateScrollbarVisibility();
        
        redraw();
        // TODO add KTable as listener to KModel...
        if (m_Model != null) {
        	System.out.println("KTable added as listener to KTableModel...");
        	m_Model.addModelChangeListener(this);
        }
    }

    /**
     * returns the current table model
     * @return KTableModel 
     */

    public KTableModel getModel() {
        return m_Model;
    }

  /** general typecast method */

  public Object getType(Class cl) throws ExecuteException {
    if(cl==String.class) return getString();
    if(cl==Boolean.class) return new Boolean(getBoolean());
    if(cl==Integer.class) return new Integer(getInt());
    if(cl==Float.class) return new Float(getFloat());
    if(cl==RecordHolder.class) return getRecordHolder();
    if(cl==XmlElement.class) return getXmlElement();
    if(cl==ASTXMLObject.class) return getASTXML();
    throw new ExecuteException("Cannot convert "+this.toString()+
			       " to "+cl);
  }

  /** return the object class; some scalars return the 
   * primitive class (eg Integer.TYPE, rather than Integer.getClass() */

  public Class getObjectClass() {
    return getClass();
  }

  /** Access an object's field */

  public Object getField(String name) throws ExecuteException {
    try {
      return getValue(getClass().getField(name).get(this));
    } catch (NoSuchFieldException exc) {
      StringBuffer available = new StringBuffer("Valid fields are: ");
      boolean first = true;
      for (Enumeration e=getFieldsEnumeration(); e.hasMoreElements();) {
        available.append((first?"":",")+e.nextElement());
        first = false;
      }
      throw new ExecuteException("Field '"+name+"' does not exist. "
                               +(first?"No fields defined.":available.toString()));
    } catch (IllegalAccessException exc) {
      throw new ExecuteException("Field '"+name+"' cannot be accessed",exc);
    }
  }

  /** Subclasses may override this method to add their own fields */

  public Enumeration getFieldsEnumeration() {
    Field[] fields = getClass().getFields();
    Vector v = new Vector();
    for(int i=0; i<fields.length; i++) v.add(fields[i].getName());
    return Collections.enumeration(v);
  }

  /** Access an object's field */

  public Object getField(String name) throws ExecuteException {
    return getColumn(name);
  }

    /**
     * Helper method to quickly get the number of fixed columns.
     * @return
     */

    protected int getFixedColumnCount() {
        return m_Model.getFixedHeaderColumnCount()+m_Model.getFixedSelectableColumnCount();
    }

  /** This class can't reset its position, but subclasses may */

  public void reset() throws ExecuteException {
      if(currentIndex==0) return;
      else throw new ExecuteException("Unable to reset enumerator value");
  }

    /**
     * Helper method to quickly get the number of fixed rows.
     * @return
     */

    protected int getFixedRowCount() {
        return m_Model.getFixedHeaderRowCount()+m_Model.getFixedSelectableRowCount();
    }

  /** Creates highlights around all occurrences of pattern in textComp 
   * code inspired from The Java Developers Almanac 1.4 */

  public void highlight(String pattern) {
    // First remove all old highlights
    try {
      Highlighter hilite = getHighlighter();
      Document doc = getDocument();
      String text = doc.getText(0, doc.getLength());
      int pos = 0;
      // Search for pattern
      while ((pos = text.indexOf(pattern, pos)) >= 0) {
	// Create highlighter using private painter and apply around pattern
	hilite.addHighlight(pos, pos+pattern.length(), findHighlightPainter);
	pos += pattern.length();
      }
    } catch (BadLocationException e) {
    }
  }

  /** Removes only our private highlights 
   * code inspired from The Java Developers Almanac 1.4 */

  public void removeHighlights() {
    Highlighter hilite = getHighlighter();
    Highlighter.Highlight[] hilites = hilite.getHighlights();  
    for (int i=0; i<hilites.length; i++) {
      if (hilites[i].getPainter() == findHighlightPainter) {
	hilite.removeHighlight(hilites[i]);
      }
    }
  }

  /** checks if file needs to be saved and aborts if user
   * asks to save it and then cancels */

  public boolean abortOpen() {
    if(unsavedEdits()) {
      // bring up save dialog
      int i=gui.chooseYesNoCancel("Save changes to "+
			      (fileName==null?"buffer":fileName)+
			      "?","Unsaved");
      if(i==JOptionPane.CANCEL_OPTION) return true;
      if(i==JOptionPane.YES_OPTION) {
	if(fileName!=null) saveFile(fileName);
	else if(!saveDialog()) return true;
      }
    }
    return false;
  }

  /** If invoked through a {@link net.sourceforge.dsql.gui.DSQLInterface}, 
   * add this value in a tab */

  public void addStackValue(Value v) {
    if(getGui()!=null) getGui().addReturnValue(v);
  }

  /** Add an entry in the connection vector and returns the connection object 
  */

  protected ConnectStmt openConnection() throws ExecuteException {
    try {
      if(driverClass!=null) Class.forName(driverClass);
      getCaller().trace.sql("Connecting to "+conurl);
      Connection con = 
        DriverManager.getConnection(conurl,userName.getUserName(),
        	                    password.getPassword());
      ConnectStmt conStmt = new ConnectStmt(con);
      SQLconns.addElement(conStmt);
      setMetadata();
      return conStmt;
    } catch (ClassNotFoundException exc) {
      throw new ExecuteException("Unable to use driver "+getDriverId()+
        ": class "+driverClass+" could not be found.");
    } catch (SQLException exc) {
      throw new ExecuteException("Unable to establish connection to '"+
        getId()+"': "+exc.getMessage(),exc);
    }
  }

  /**
   * Instruct the thread to stop masking.
   */

   public void stopMasking() {
      this.stop = true;
   }

    /**
     * Returns true, if at least one of the two enumerations has more
     * elements.
     */

    public boolean hasMoreElements() {
        if (hasMore)
            hasChecked = hasMore = e1.hasMoreElements();
        return hasMore ? true : e2.hasMoreElements();
    }

    /**
     * Returns the next element.  This returns the next element of the
     * first enumeration, if it has more elements, otherwise the next
     * element of the second enumeration.
     */

    public Object nextElement() {
        if (hasMore && !hasChecked)
            hasMore = e1.hasMoreElements();
	hasChecked = false;
        return hasMore ? e1.nextElement() : e2.nextElement();
    }

  /** operators priority: * /, + - ||, = lt gt, AND OR */

  protected int priority() {
    return Integer.MAX_VALUE;
  }

  /** Adds a variable to the current context */

  public void addVariable(Variable var) {
    ((Hashtable)vars.elementAt(vars.size()-1)).put(var.getName(),var);
    getCaller().trace.debug("Added "+var+" to the current variable context");
  }

  /** Sets a variable: in the closest context if it exists, or adds
   * otherwise */

  public void setVariable(String name, Value value) throws ExecuteException {
    Variable var;
    try { var = getVariable(name); }
    catch (VarNotSetException exc) { 
      var = new Variable(name);
      addVariable(var); 
    }
    var.setValue(value);
  }

  /** This returns only the static text; to evaluate
   * DSQL code or variables, call executeXML().getXMLText() */

  public String getXMLText() throws ExecuteException {
    String r = "";
    // TBD: should start from attributes?
    for(int i=0; i<jjtGetNumChildren(); i++)
      if(children[i] instanceof ASTXMLObject &&
         !(children[i] instanceof ASTXMLAttribute))
        r = r+((ASTXMLObject)children[i]).getXMLText();
    return r;
  }

  /** called by EditArea */

  public void updateCursorPos(int line, int col) {
    caretPos.setText(""+line+":"+col);
  }

  /** Execute a Node
   * @throws ExecuteException If an error occurs during execution,
   * the exception is set with this Node so that a line number
   * can be displayed along with the error message
   */

  public Value executeWithCatch() throws ExecuteException {
    if(getCaller().hasRequestToStop()) 
      throw new StopException();
    try {return execute();}
    catch (ExecuteException exc) {
      if(exc.getNode()==null) exc.setNode(this); 
      throw exc;
    }
  }

  /** This object is always the result of an execution; so do nothing... */

  public ASTXMLObject executeXML() {
    return this;
  }

   /**
    * Searches dataset for an identical food. 
    * @param f a food to search for
    * @return the identical food if found
    */

   public Food findIdenticalFood(Food f) {
      Iterator iter = map.values().iterator();
      while (iter.hasNext()) {
         FoodProxy food = (FoodProxy)iter.next();
         if (food.getDescription().equals(f.getDescription())) {
            if (food.getFood().equals(f)) {
               return food.getFood();
            }
         }
      }
      return null;
   }

   /**
    * Cap the string at a max length,
    * @return
    */

   private String fixString(String str) {
      //return "<html><div align=\"center\">" + str + "</div></html>";
      if (str.length() > 53) {
         return str.substring(0, 50)+"...";
      } else {
         return str;
      }
   }

   /**
    * Creates the pre-defined biomarkers and flushes to disk
    */

   private void createFile() {
      for (Iterator iter = Biomarker.createPredefinedBiomarkers().iterator(); iter.hasNext();) {
         Biomarker biomarker = (Biomarker) iter.next();
         addBiomarker(biomarker);
      }
      save();
   }

   /**
    * Creates a dataset, consisting of two series of monthly data.
    *
    * @return The dataset.
    */

   private void createDataset() {
      actualData = new TimeSeries(metricName, Day.class);
      dataset = new TimeSeriesCollection();
      getData();
      dataset.addSeries(actualData);
   }

   /**
    * Compares two metrics by date for sorting.
    */

   public int compareTo(Object object) {
      return date.compareTo(((Metric)object).getDate());
   }

   /**
    * Add the nutrients in the given table to our total
    * 
    * @param toAdd
    *            the nutrients ratios to add
    * @param weight
    *            multiplier for the amount in the added nutrients
    */

   public void addFood(NutrientTable toAdd, double weight) {
      for (int i = 0; i < nutrients.length; i++) {
         nutrients[i] += toAdd.getAmount(i) * weight;
      }
   }

    /**
     * Update the existing food information
     */

    public void update() {
       UserManager.getCurrentUser().getFoodHistory().update(this);
        //lds.changeServingAmount(this);
    }

   /**
    * Find a matching measure by name in this food
    * 
    * @param measureName
    */

   public void setMeasure(String measureName) {
      if (food == null) return;
      List measures = getFoodProxy().getFood().getMeasures();
      for (int i=0; i<measures.size(); i++) {
         Measure m = (Measure)measures.get(i);
         if (m.getDescription().equals(measureName)) {
            setMeasure(m);
            return;
         }
      }
      // if nothing found, default to GRAMS
      setMeasure(Measure.GRAM);
   }

   /**
    * Get a textual description of the food.
    * 
    * @return this Food's description.
    */

   public String getDescription() {
      return description;
   }

   /**
    * Set the measure to display weights for a particular food.
    */

   public void setFood(Food f) {
      measures.setModel(new DefaultComboBoxModel(f.getMeasures().toArray()));
      curMeasure = Measure.GRAM;
      fireChangeEvent();
   }

   /**
    * Update this Food's description.  The <code>Food</code> 
    * implementation must be associated with a writeable datasource.
    * 
    * @param text The new description.
    */

   public void setDescription(String text) {
      description = text;
      setDirty(true);
   }

   /**
    * Set the weight to display
    * @param w the type of measure
    * @param mult the multiplier for that measure
    */

   public void setMeasure(Measure w, double mult) {
     // measures.setSelectedItem(w);
      for (int i=0; i<measures.getItemCount(); i++) {
         Measure m = (Measure)measures.getItemAt(i);
         if (m.equals(w)) {
            measures.setSelectedIndex(i);
            break;
         }
      }
      multiplier.setValue(mult);
      fireChangeEvent();
   }

   /**
    * Retrieve a List of <code>Measure</code>s for this Food.
    * 
    * @return all <code>Measure</code>s associated with this Food.
    public */

   public List getMeasures() {
      if (measures == null) {
         measures = new ArrayList();
         measures.add(Measure.GRAM);
      }
      return measures;
   }

   /**
    * Update the widget after a weight change has occurred.
    * Called when weight menu is changed or edited
    */

   public void updateMeasure() {
      Measure w = getSelectedMeasure();     
      if (linked) {
         double mult = w.getAmount();
         if (curMeasure != null) {
            double grams = curMeasure.getGrams() * multiplier.getValue();
            mult = grams/w.getGrams();
         }
         multiplier.setValue(mult);
      }
      setFocus();
      curMeasure = w;
      fireChangeEvent();
   }      

   /**
    * Get the multiplier for the current weight and mult settings.
    * @return a multiple of the standard nutrient value (x per 100g)
    */

   public double getMultiplier() {
      return getGrams() / 100.0;
   }

   /**
    * Replace the list of <code>Measure</code>s for this food.  The <code>Food</code> 
    * implementation must be associated with a writeable datasource.
    * 
    * @param measures A list of <code>Measure</code> objects that will completely
    * replace the ones currently in existence for this <code>Food</code>.
    */

   public void setMeasures(List measures) {
      this.measures = measures;
      setDirty(true);
   }

   /**
    * Get the number of grams in this measure
    * @return the number of grams in this state
    */

   public double getGrams() {
      Measure w = getSelectedMeasure();
      if (w != null) {
         return multiplier.getValue() * w.getGrams();// * (1.0/w.getAmount()); 
      }
      return 0;
   }

   /**
    * See if the food has a value set for the given nutrient
    * 
    * @param ni the <code>NutrientInfo</code> to look up.
    * @return true if a value exists in this food
    */

   public boolean hasDataFor(NutrientInfo ni) {
        if (ni == null) return false;
        return getNutrients().dataExists(ni.getIndex());         
    }

   /**
    * Get the amount of a nutrient provided by this Food.
    * 
    * @param ni the <code>NutrientInfo</code> to look up.
    * @return the amount of the requested nutrient per unit.
    */

   public double getNutrientAmount(NutrientInfo ni) {
        if (ni == null) return 0;
        return getNutrients().getAmount(ni.getIndex());         
    }

   /**
    * Set the amount of a nutrient provided by this Food.  The <code>Food</code> 
    * implementation must be associated with a writeable datasource.
    * 
    * @param ni the Nutrient to modify.
    * @param val the amount of the Nutrient per unit.
    */

   public void setNutrientAmount(NutrientInfo ni, double val) {
      getNutrients().setAmount(ni.getIndex(), val);        
      setDirty(true);
   }

   /**
    * Add a list of servings to the daily listing
    * Ugly because this table and model listens to the parent, which is 
    * backwards from normal patterns...
    * @param list
    */

   public void addServings(Serving[] list) {
      addServingsToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());
   }

   /**
    * Called if the weight menu state is changed
    */

   public void itemStateChanged(ItemEvent e) {
      updateMeasure();
   }

   /**
    * Called when the text field is set
    */

   public void actionPerformed(ActionEvent e) {
      fireChangeEvent();
      fireActionEvent();
      //Toolkit.getDefaultToolkit().beep();
   }

   /**
    * Retrieve a key for this food uniquely identifying both its datasource
    * and its own unique ID in the DS.  The general contract of this method is that
    * if f1.getSourceUID().equals(f2.getSourceUID()) then f1 and f2 both come from
    * the same DS, and refer to the same item in that DS.
    * @return A UID for this food.
    */

   public String getSourceUID() {
      return sourceUID;
   }

   /**
    * Called when the text field is edited
    */

   public void keyReleased(KeyEvent e) {
      //System.out.println("keyReleased: " + e);
      fireChangeEvent();
   }

   /**
    * Directly set the sourceUID of a food to that of another one.
    * @param uid The <code>Food</code> whose sourceUID will be used.
    */

   public void setSourceUID(String uid) {
      sourceUID = uid;
      setDirty(true);
   }

   /**
    * If linked, changing a weight will update the multiplier
    * to keep the grams constant. Otherwise, the multiplier is left unchanged.
    * 
    * @return true if the multiplier is linked to the weight
    */

   public boolean isLinked() {
      return linked;
   }

   /**
    * Set the comment on this food.  <code>null</code> values will result in the comment being set
    * to the empty string.
    * 
    * @param comment The comment.
    */

   public void setComment(String comment) {
      this.comment = comment;
      setDirty(true);
   }

   /**
    * If linked, changing a weight will update the multiplier
    * to keep the grams constant. Otherwise, the multiplier 
    * is left unchanged.
    */

   public void setLinked(boolean linked) {
      this.linked = linked;
   }

   /**
    * Get the commment on this food.  This value is guaranteed not to be <code>null</code>.
    * 
    * @return the comment.
    */

   public String getComment() {
      return comment;
   }

   /**
    * See if the food data is identical 
    * 
    * @param f to compare against
    * @return true if the two foods contain the same food data (description, nutrients, and measures)
    */

   public boolean equals(Food f) {
      if (!f.getDescription().equals(getDescription())) return false;
      List nutrients = NutrientInfo.getGlobalList();
      for (int i=0; i<nutrients.size(); i++) {
         NutrientInfo ni = (NutrientInfo)nutrients.get(i);
         if (f.getNutrientAmount(ni) != getNutrientAmount(ni)) {
            return false;
         }
      }
      return true;
   }

   /**
    * Allows custom rendering for a row and column. Can just return c, if no
    * changes to default are desired.
    * @param c the component used for rendering the cell
    * @param row the row to render
    * @param col the column to render
    * @return a custom rendering component
    */

   public Component customRender(Component c, PrettyTable table, int row, int col) {
      Serving s = getServing(row);
      if (s != null) {
         if (s.getFoodProxy().isDeprecated()) {
            c.setForeground(Color.LIGHT_GRAY);               
         } else if (col == 0) {
            c.setForeground(s.getFoodProxy().getSource().getDisplayColor());               
         } else {
            c.setForeground(Color.BLACK);
         }
      }
      return c;
   }

   /**
    * Set the comboBox table cell editor to the currently
    * selected measure list
    * @param serving the selected serving
    */

   private void setMeasureBox(Serving s) {
      if (s != null) {
         measureBox.removeAllItems();
         List measures = s.getFood().getMeasures();
         for (int i=0; i<measures.size(); i++) {
            measureBox.addItem(measures.get(i));
         }
         measureBox.setSelectedItem(s.getMeasure());
      }
   }

   /**
    * Copy changes to original and save.
    */

   public void updateOriginal() {
      original.copy(food);
      original.update();
   }

    /**
     * Get the standard amount of this measure. Example: 1.0 Servings, 0.5 Cups,
     * 2.0 Tablespoons
     * 
     * @return the multiplier for this measure
     */

    public double getAmount() {
        return amount;
    }

    /**
     * Set the standard amount of this measure
     * 
     * @param amount
     *            a multiplier
     */

    public void setAmount(double amount) {
        this.amount = amount;
    }

    /**
     * Set the english name of this measure type
     */

    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * Get the number of grams in this measure
     * 
     * @return the number of grams in the measure
     */

    public double getGrams() {
        return grams;
    }

    /**
     * Set the number of grams in this measure
     */

    public void setGrams(double grams) {
        this.grams = grams;
    }

   /**
    * Does a very simple print-out of the recipe.
    */

   public void doPrint() {
      try {         
         MessageFormat headerFormat = new MessageFormat(getTitle());
         MessageFormat footerFormat = new MessageFormat("- {0} -");
         getTable().print(JTable.PrintMode.FIT_WIDTH, headerFormat, footerFormat);          
      } catch (PrinterException e) {
         e.printStackTrace();
         JOptionPane.showMessageDialog(this, e.getMessage());
      }
   }     

   /**
    * Walk through all of the servings and tally up the 
    * nutrient values for the entire meal.
    */

   private void recomputeNutrients() {
      double total = getTotalGrams();
      
      Iterator iter = NutrientInfo.getGlobalList().iterator();
      while (iter.hasNext()) {
         NutrientInfo ni = (NutrientInfo)iter.next();
         setNutrientAmount(ni, getAmount(ni, total));
      }
      
      recomputeFactors();
      
      boolean found = false;
      List list = getMeasures();      
      for (int i=0; i<list.size(); i++) {
         Measure m = (Measure)list.get(i);
         if (m.getDescription().equals("full recipe")) {
            m.setGrams(total);
            found = true;
         }
      }
      if (!found) {
         getMeasures().add( new Measure(1.0, "full recipe", total) );
      }
      //update();
   }

   /**
    * Get the nutrient amount by walking through all of the servings
    * and calculating the total amount.
    */

   private double getAmount(NutrientInfo ni, double totalGrams) {
      double total = 0;
      for (Iterator iter = getServings().iterator(); iter.hasNext();) {
         Serving serving = (Serving) iter.next();
         if (serving.getFood() != null) {
            double weight = (serving.getGrams()/totalGrams);
            total += weight * serving.getFood().getNutrientAmount(ni);
         }
      }
      return total;
   }

   /**
    * Copy changes to original and save.
    */

   public void updateOriginal() {
      ((Recipe)original).copy(getRecipe());
      original.update();
   }

   /**
    * Check if the data available for this nutrient is generally incomplete.
    */

   public boolean isSparseData() {
      return sparse;
   }

   /**
    * Get the last user that used CRON-o-meter.
    */

   public User getLastUser() {
      User user = getUser(getLastUsername());
      if (user == null) {
         user = getUserList().get(0);
      }
      return user;
   }

   /**
    * Add a new user to Cronometer via the UI.
    * @param parentWindow allow a popup to set the user settings
    * @return the user that was just added.
    */

   public void addUser(JComponent parentWindow) {
      User user = new User(new Settings(Settings.TAG_USER));
      setCurrentUser(user);
      addUser(user);
      user.doFirstRun(parentWindow);
      settings.save();
   }

   /**
    * Add a new user to Cronometer
    * @param user the user to add.
    */

   public void addUser(User user) {
      userList.add(user);
      settings.save();
   }

   /**
    * Find the User with the given username
    * @param username the name of the user
    * @return User the Object that relates to the given name.  Null if the User is not found.
    */

   public User getUser(String username) {
      return getUser(getUserList(), username);
   }

   /**
    * Delete a user from Cronometer.
    * @param user the user Object to delete.
    */

   public void deleteUser(User user) {
      userList.remove(user);
      deleteFiles(user);
      if (currentUser == user) {
         // Make sure we select a new currentUser, find the first active user
         setCurrentUser(getUserList().get(0));
      }
      settings.save();
   }

   /**
    * Delete all the settings file related to this user.
    * @param user
    */

   public void deleteFiles(User user) {
      File userDir = getUserDirectory(user);
      if (userDir.exists()) {
         int i;
         for (i=0; i<userFileList.length; i++) {
            File userFile = new File(userDir.getAbsolutePath(), userFileList[i]);
            if (userFile.exists()) {
               if (!userFile.delete()) {
                  Logger.error("Unable to delete the file: " + userFile.getAbsolutePath());
               }
            }
         }
         if (!userDir.delete()) {
            Logger.error("Unable to delete the folder: " + userDir.getAbsolutePath());
         }
      }
   }

   /**
    * Delete the user with the given <code>username</code>
    * @param username the name of the user
    * @return true if the delete was succesful
    */

   public boolean deleteUser(String username) {
      User user = getUser(username);
      if (userExists(username)) {
         deleteUser(user);
         return true;
      }
      return false;
   }

   /**
    * Search for a user and set that user as the current user.  
    * @param username the name of the user
    * @return true if the operation was successful
    */

   public boolean setCurrentUser(String username) {
      User user = getUser(username);
      if (user != null) {
         setCurrentUser(user);
         return true;
      } else {
         return false;
      }
   }

   /**
    * A rough estimate of the user's age, close enough for our purposes.
    */

   public int getAge() {
      if (null != getBirthDate()) {
         return getAge(getBirthDate());
      }
      return 0;
   }

   /** 
    * Delete the user selected in the userListModel
    * @param row the row item to delete
    */

   private void deleteSelectedUser(int row) {
      String username = (String)userListModel.get(row);
      
      if ( ! isOkToDeleteUser()) {
         return;
      }
      
      if (userListModel.size() == 1) {
         Logger.error("Not allowed to delete last user.");
         return;
      }
      if (!userMan.deleteUser(username)) {
         Logger.error("Unable to delete user.");
         return;
      }
      userListModel.remove(row);
      selectCurrentUser();
      setDirty(true);
   }

   /**
    * Select the default user in the list. This is not the current user.
    */

   public void selectDefaultUser() {
      userList.setSelectedValue(UserManager.selectOtherUser().getUsername(), true);   
   }

   /**
    * Select the current user in the list.
    *
    */

   public void selectCurrentUser() {
      userList.setSelectedValue(UserManager.getCurrentUser().getUsername(), true);   
      if (userListModel.getSize() == 1) {
         delBtn.setEnabled(false);
      }
   }

   /**
    * Look through all nutrients and see what overall percentage of the targets
    * are completed.
    */

   public double getTargetCompletion(boolean average) {
      double total = 0;
      double value = 0;
      double valueFull = 0; 
      
      Iterator iter = getNutrientList().iterator();
      while (iter.hasNext()) {
         NutrientInfo ni = (NutrientInfo)iter.next();
         Target target = UserManager.getCurrentUser().getTarget(ni);
         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {
            double amount = getNutrientTable().getAmount(ni);
            valueFull += amount/target.getMin();
            if (amount < target.getMin()) {
               value += amount/target.getMin();
            } else {
               value++;
            }
            total++;
         }
      }
      if (average) {
         return valueFull/total;
      } else {
         return value / total;
      }
   }

   /**
    * Initialise the User specific data sources.
    */

   public void initUserData() {
      getFoodHistory();
      getNotesHistory();
      getBiometricsHistory();
   }

   /**
    * Ensure all data is saved to backing stores.
    */

   public void saveUserData() {
      getFoodHistory().save();
      getBiometricsHistory().save();
      getNotesHistory().save();
      getExerciseHistory().save();
   }

   /**
    * Look through all nutrients and see what overall percentage of the targets
    * are completed.
    */

   public double getTargetCompletion(List servings, List nutrients, int days, boolean average) {
      double total = 0;
      double value = 0;
      double valueFull = 0; 
      
      Iterator iter = nutrients.iterator();
      while (iter.hasNext()) {
         NutrientInfo ni = (NutrientInfo)iter.next();
         Target target = UserManager.getCurrentUser().getTarget(ni);
         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {
            double amount = getAmount(servings, ni) / (double) days;
            valueFull += amount/target.getMin();
            if (amount < target.getMin()) {
               value += amount/target.getMin();
            } else {
               value++;
            }
            total++;
         }
      }
      if (average) {
         return valueFull / total;
      } else {
         return value / total;
      }
   }

   /** 
    * Invoked when the text area loses the keyboard focus.
    * This will not be invoked when the user clicks on the next/previous day button.
    */

   public void focusLost(FocusEvent e) {
      if (curDate != null) {
         saveCurrentNote(); 
      }
   }

   /**
    * Allows custom rendering for a row and column. Can just return c, if no
    * changes to default are desired.
    * @param c the component used for rendering the cell
    * @param row the row to render
    * @param col the column to render
    * @return a custom rendering component
    */

   public Component customRender(Component c, PrettyTable table, int row, int col) {
      Exercise s = getExercise(row);
      if (s != null) {
         c.setForeground(Color.BLACK);
      }
      return c;
   }

   /**
    * Depending on the selected source, a different database will be searched
    */

   public void doDBSearch() {
      Object sel = getSourceBox().getSelectedItem();
      if (sel instanceof FoodDataSource) {
         doDBSearch((FoodDataSource)sel);
      } else {
         doDBSearch(null);
      }
   }

   /**
    * Show window normally
    */

   public void restoreWindow() {
      setVisible(true);
      setExtendedState(Frame.NORMAL);
      toFront();
   }

   /**
    * Set the current date to today
    */

   public void goToToday() {
      setDate(new Date(System.currentTimeMillis()), false);
   }

   /**
    * Copies the foods from the previous day into this day.
    */

   private void copyPreviousDay() {
//      if (isOkToAddServings(curDate)) {
	   Date previousDay = new Date(curDate.getTime() - ONE_DAY);
      UserManager.getCurrentUser().getFoodHistory().copyConsumedOn(previousDay, curDate);
	   notifyObservers();
//      }
   }

      /**
       * Allows custom rendering for a row and column. Can just return c, if no
       * changes to default are desired.
       * @param c the component used for rendering the cell
       * @param row the row to render
       * @param col the column to render
       * @return a custom rendering component
       */

      public Component customRender(Component c, PrettyTable table, int row, int col) {
         FoodProxy f = getSearchHit(row).getFoodProxy();
         if (f != null) {
            if (col == 0) {
               c.setForeground(f.getSource().getDisplayColor());
               if (f.isDeprecated()) {
                  c.setForeground(Color.LIGHT_GRAY);
               }
            }
         }
         return c;
      }

   /**
    * Update the existing food information
    */

   public void update() {
      UserManager.getCurrentUser().getExerciseHistory().update(this);
   }

   /**
    * Add a list of servings to the daily listing
    * Ugly because this table and model listens to the parent, which is 
    * backwards from normal patterns...
    * @param list
    */

   public void addExercises(Exercise[] list) {
      addExercisesToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());
   }

   /**
    * Set the current date being displayed by this daily summary
    */

   public void setDate(Date d, boolean userChanged) {
      curDate = d;      
      // getDateTitle().setDate(curDate);
      getDateTitle().setText(df.format(curDate));
      validate();
      getBioMarkersPanel().setDate(d);
      getServingTable().setTitle(df.format(curDate));
      if (!userChanged) {
         getNotesEditor().saveCurrentNote(); 
      }
      getNotesEditor().setDate(d);
      asked = false;
      refreshTime();
      notifyObservers();
   }

   /** 
    * Reload the history file.
    *
    */

   public void reload() {
      load();
   }

   /**
    * Allows custom rendering for a row and column. Can just return c, if no
    * changes to default are desired.
    * @param c the component used for rendering the cell
    * @param row the row to render
    * @param col the column to render
    * @return a custom rendering component
    */

   public Component customRender(Component c, PrettyTable table, int row, int col) {
      //Record entry = getUserEntry(row);
      return c;
   } 

   /**
    * Add a list of entries to the daily listing
    * Ugly because this table and model listens to the parent, which is 
    * backwards from normal patterns...
    * @param list
    */

   public void addEntries(Record[] list) {
      for (int i=0; i<list.length; i++) {
         add(list[i].copy());
      }
   }

    /**
     * Removes the specified component from the layout.
     * @param comp the component to be removed
     */

    public void removeLayoutComponent(Component comp) {
        compTable.remove(comp);
    }

    /** 
     * Calculates the minimum size dimensions for the specified 
     * panel given the components in the specified parent container.
     * @param parent the component to be laid out
     * @see #preferredLayoutSize
     */

    public Dimension minimumLayoutSize(Container parent) {
    	int ncomponents = parent.getComponentCount();
		if (ncomponents == 0) return new Dimension(1,1);
		Rectangle totalRect = new Rectangle(0,0,1,1);
		for ( int i = 0; i < ncomponents; i++ ) {
			Component c = parent.getComponent(i);
			SpazPosition lp = (SpazPosition)compTable.get(c);
         Rectangle rect = lp.getMinRectangle();
         if ( rect != null ) 
         	totalRect = totalRect.union(rect); 

		}
		return new Dimension(totalRect.width,totalRect.height);
    }

    /**
     * Adds the specified component to the layout, using the specified
     * constraint object.
     * @param comp the component to be added
     * @param constraints  where/how the component is added to the layout.
     */

    public void addLayoutComponent(Component comp, Object constraints) {
        if (constraints instanceof SpazPosition) {
            SpazPosition cons = (SpazPosition)constraints;
            setConstraints(comp, cons);
        } else if (constraints != null) {
            throw new IllegalArgumentException(
                "cannot add to layout: constraint must be a SpazPostion");
        }
    }

    /** 
     * Returns the maximum size of this component.
     * @see java.awt.Component#getMinimumSize()
     * @see java.awt.Component#getPreferredSize()
     * @see LayoutManager
     */

    public Dimension maximumLayoutSize(Container target) {
        return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);
    }

    /**
     * Returns the alignment along the x axis.  This specifies how
     * the component would like to be aligned relative to other 
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     */

    public float getLayoutAlignmentX(Container target) {
        return 0.5f;
    }

    /**
     * Returns the alignment along the y axis.  This specifies how
     * the component would like to be aligned relative to other 
     * components.  The value should be a number between 0 and 1
     * where 0 represents alignment along the origin, 1 is aligned
     * the furthest away from the origin, 0.5 is centered, etc.
     */

    public float getLayoutAlignmentY(Container target) {
        return 0.5f;
    }

    /**
     * Invalidates the layout, indicating that if the layout manager
     * has cached information it should be discarded.
     */

    public void invalidateLayout(Container target) {
        // Do nothing
    }

   /**
    * Allows custom rendering for a row and column. Can just return c, if no
    * changes to default are desired.
    * @param c the component used for rendering the cell
    * @param row the row to render
    * @param col the column to render
    * @return a custom rendering component
    */

   public Component customRender(Component c, PrettyTable table, int row, int col) {
      return c;
   }

   /**
    * Show window normally
    */

   public void showWindow() {
      setVisible(true); 
      toFront();
   }

   /**
    * Set to launch hyperlinks in external system browser, or in internal
    * window instead.
    * 
    * @param val true if external browser should load links.
    */

   public void setExternal(boolean val) {
      external = val;
   }

   /**
    * Create a new instance of a class in this jar file.
    * Must have a basic constructor with no arguments.
    * 
    * @param name the class name to instantiate
    * 
    * @return an Object created from the given class
    */

   public Object newInstance(String name) {
      try {
         Class c = this.loadClass(name, true);
         return c.newInstance();
      } catch (Exception e) {
         e.printStackTrace();
      }
      return null;
   }

   /**
    * Get a count of the bytes read by this stream.
    * @return the number of bytes read by this stream.
    */

   public long getBytesRead() {
      return bytesRetrieved;
   }

   /**
    * Returns the key of the setting that was changed.
    *
    * @return  The key of the setting that was changed.
    */

   public String getKey() {
      return key;
   }

   /**
    * Returns the new value for the setting.
    *
    * @return  The new value for the setting, or <tt>null</tt> if the
    *          setting was removed.
    */

   public String getNewValue() {
      return newValue;
   }

   /**
    * Retrieve the <code>cols</code> from the <code>SQLInsert</code>
    * @return Returns the cols.
    */

   public SQLColumnSet getColumns() {
      return cols;
   }

    /**
     * Added a WHERE constraint to the SELECT command.
     * 
     * @param name
     *            the field to constrain
     * @param val
     *            the value this field must equal as a constraint
     */

    public void addWhere(String name, Object val) {
        addWhere(name, EQ, val);
    }

    /**
     * Added a WHERE constraint to the SELECT command.
     * 
     * @param name
     *            the field to constrain
     * @param val
     *            the value this field must be like
     */

    public void addWhereLike(String name, String val) {
        where.add("upper(" + name + ") like '"
                + escape(val.toString()).toUpperCase() + "' ");
    }

    /**
     * Add an item to select
     * 
     * @param field
     *            a valid SQL selection item
     */

    public void addSelection(String field) {
        items.add(field);
    }

    /**
     * Execute the query and return the results.
     */

    protected ResultSet doExecuteQuery(Connection con) throws SQLException {
        Statement stmt = con.createStatement();
        String query = this.getQueryString();
        if (Logger.isDebugEnabled()) {
           Logger.debug("executeQuery() - Statement to be executed: " + query);
        }

        results = stmt.executeQuery(query);
        return results;
    }

   /**
    * Set if this will format output with newlines or not
    */

   public void setPrintNewLines(boolean b) {
      printNewLines  = b;
      Iterator iter = children.iterator();
      while (iter.hasNext()) {
         ((XMLNode)iter.next()).setPrintNewLines(b);
      }
   }

   /**
    * Generate the SQL string for an UPDATE command.
    */

   protected String getQueryString() {
      StringBuffer sb = new StringBuffer();
      sb.append("UPDATE ");
      sb.append(getTableName());
      sb.append(" SET ");
      List names = cols.getNames();
      List terms = cols.getValues();
      for (int i=0; i<names.size(); i++) {         
         Object name = names.get(i);
         Object term = terms.get(i);
         if (term == null) {
            term = "NULL"; 
         }
         sb.append(name.toString());
         sb.append(" = '");
         sb.append(escape(term.toString()));
         sb.append("' ");
         if (i < names.size() - 1) {
            sb.append(", ");
         }
      }
      sb.append(getWhere());
      return sb.toString();
   }

   /**
    * Generate the SQL string for an DELETE command.
    */

   protected String getQueryString() {
      StringBuffer sb = new StringBuffer();
      sb.append("DELETE FROM ");
      sb.append(getTableName());
      sb.append(getWhere());
      return sb.toString();
   }

   /**
    * Sets the horizontal gap between components.
    */

   public void setHgap(int hgap) {
       this.hgap = hgap;
   }

   /**
    * Gets the vertical gap between components.
    */

   public int getVgap() {
       return vgap;
   }

   /**
    * Sets the vertical gap between components.
    */

   public void setVgap(int vgap) {
       this.vgap = vgap;
   }

   /**
    * Removes the specified component from the layout. Not used by
    * this class.
    * @param comp the component to remove
    * @see       java.awt.Container#removeAll
    */

   public void removeLayoutComponent(Component comp) {
      constraints.remove(comp);
   }

    /**
     * Setting an endpoint from the outside is only meaningful for unit tests.
     *
     * @param endPoint An endpoint
     * @return This distributor
     */

    public DistributorMO setEndPoint(Location endPoint) {
        this.endPoint = endPoint;
        return this;
    }

    /** Remove all nodes except the root node. */

    public void menuVJBTreeClear() {
        menuSetDMT.removeAllChildren();
        menuVJBTreeModel.reload();
    }

    /** Remove the currently selected node. */

    public void menuVJBTreeRemoveCurrentNode() {
        TreePath currentSelection = menuVJBTree.getSelectionPath();
        if (currentSelection != null) {
            DefaultMutableTreeNode currentNode = 
                    (DefaultMutableTreeNode)
                    (currentSelection.getLastPathComponent());
            MutableTreeNode parent = 
                    (MutableTreeNode)(currentNode.getParent());
            if (parent != null) {
                menuVJBTreeModel.removeNodeFromParent(currentNode);
                return;
            }
        } 
        // Either there was no selection, or the root was selected.
    }

    /** Add child to the currently selected node. */

    public DefaultMutableTreeNode menuVJBTreeAddObject(Object child) {
        DefaultMutableTreeNode parentNode = null;
        TreePath parentPath = menuVJBTree.getSelectionPath();
        if (parentPath == null) {
            parentNode = menuSetDMT;
        } else {
            parentNode = (DefaultMutableTreeNode)
                 (parentPath.getLastPathComponent());
        }
        return menuVJBTreeAddObject(parentNode, child, true);
    }

    /**
     * This method is only useful for unit testing.
     *
     * @param tickTock A time abstraction
     * @return A deadline
     */

    public TimeLimit timeLimit(TickTock tickTock) {
        return new TimeLimit(this, tickTock);
    }

    /**
     * Return an approximation of this interval, using an optional, preferred unit.
     * For instance, 42,345,543 microseconds will approximate to 42,345 milliseconds,
     * if {@link java.util.concurrent.TimeUnit#MILLISECONDS} is used.
     *
     * @param unit A unit
     * @return Approximation using that unit
     */

    public TimeSpan approximate(TimeUnit unit) {
        long nanos = nanoTime();
        long tenths = (long)Math.floor(Math.log10(nanos));
        for (int i = 0; ; i++) {
            int exp = (i + 1) * 3;
            if (tenths < exp || i == 3 || unit == UNITS[i]) {
                long div = (long)Math.pow(10, exp - 3);
                long time = nanos / div;
                return new TimeSpan(time, UNITS[i]);
            }
        }
    }

    /**
     * Returns a readable approximation of this time span.  For instance, instead of being
     * billions of nanoseconds, it will be a number of seconds.  Example: 42,345,543 microseconds
     * will approximate to 42 seconds.  In other words, it will gravitate towards a unit
     * that makes it more approximate, but suits the size of the time span.
     *
     * @return Approximate time span
     */

    public TimeSpan approximate() {
        return approximate(null);
    }

    /**
     * True iff the result is wrapped, in a {@link Holder}.
     */

    public boolean isWrapped() {
        return this.wrappedValue != null;
    }

    /**
     * The toString of the value.
     */

    public Object getValueString() {
        return this.valueString;
    }

    /**
     * The holder object if wrapped, otherwise the object itself.
     */

    public Object getTypedValue() {
        return this.typedValue;
    }

    /**
     * The class object of the result.  Will not be serialized.
     */

    public Class getType() {
        return this.type;
    }

    /**
     * The name of the class of the result.
     */

    public String getTypeName() {
        return this.typeName;
    }

    /**
     * True iff the result was a primitive value.
     */

    public boolean isPrimitive() {
        return this.primitive;
    }

    /**
     * The throwable of a failed result.  Will not be serialized.
     */

    public Throwable getThrowable() {
        return this.throwable;
    }

    /**
     * Returns the string value of this tree node
     */

    protected void writeToBuffer(StringBuffer buffer, int x, boolean indent) {
        buffer.append(this.getType().getLeft());
        for (int i = 0; i < this.nodes.length; i++) {
            this.nodes[i].writeToBuffer(buffer, x + 2, true);
            if (i < (this.nodes.length - 1)) {
                buffer.append(" ");
            }
        }
        buffer.append(this.getType().getRight());
    }

    /**
     * The time taken to evaluate the result, in milliseconds.
     */

    public long getEvalTime() {
        return this.evalTime;
    }

    /**
     * True iff the result was not a failure.
     */

    public boolean isOK() {
        return this.throwableType == null;
    }

    /**
     * Returns the string value of the content
     *
     */

    protected void writeToBuffer(StringBuffer buffer, int x, boolean i) {
        String string = this.isContentString()
            ? "\"" + this.getContent() + "\""
            : (this.isContentHolder()
               ? ((Holder)this.getContent()).toValueString()
               : String.valueOf(this.getContent()));
        buffer.append(string);
    }

    /**
     * Evaluates the content of this leaf in the given environment.  Iff
     * content is a symbol, look it up in the context
     *
     * @param context The context to evaluate in
     * @return The value of the content
     * @exception EvaluationException Thrown iff something bad happens
     */

    public Object evaluate(Context context) {
        if (this.isContentSymbol()) {
            Object value = context.lookup(this.getSymbolContent());
            if (value == null) {
                value = Reflector.get().resolveLeafNode(context, this);
                if (value == null) {
                    throw new EvaluationException
                        ("Unknown symbol or type " + this.getSymbolContent());
                }
            }
            return value;
        } else {
            return this.getContent();
        }
    }

    /**
     * Adds nodes for the declared (if known) and actual (if not null) class
     */

    private void addClassNodes() {
        if (getRealObject() != null) {
            ClassNode actualClass = new ClassNode(this,
                                                  getRealObject().getClass(),
                                                  "Actual class");
            addChild(actualClass);
        }
        if (getDeclaredClass() != null) {
            ClassNode declaredClass = new ClassNode(this,
                                                    getDeclaredClass(),
                                                    "Declared class");
            addChild(declaredClass);
        }
    }

    /**
     * Adds nodes for each field of each (super)class
     */

    private void addFieldListNodes() {
        for (Class clazz = getActualClass();
             clazz != null;
             clazz = clazz.getSuperclass()) {
            addFieldList(clazz);
        }
    }

    /**
     * Test of the mod method.
     */

    public void testMod() {
        assertEquals("Module failed",
                     DataHolderFactory.holder(5),
                     DataHolderFactory.holder(20).mod(DataHolderFactory.holder(15)));
    }

    /**
     * Test of the mul method.
     */

    public void testMul() {
        assertEquals("Multiplication failed",
                     DataHolderFactory.holder(20),
                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));
        assertEquals("Multiplicatio failed",
                     DataHolderFactory.holder(20),
                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));
        assertEquals("Multiplication failed",
                     DataHolderFactory.holder(20),
                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));
        assertEquals("Multiplication failed",
                     DataHolderFactory.holder(20),
                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));
    }

    /**
     * Test of the div method.
     */

    public void testDiv() {
        assertEquals("Division failed",
                     DataHolderFactory.holder(100),
                     DataHolderFactory.holder(20).mul(DataHolderFactory.holder(5)));
        assertEquals("Division failed",
                     DataHolderFactory.holder(100),
                     DataHolderFactory.holder(20.0).mul(DataHolderFactory.holder(5.0)));
    }

    /**
     * Test of the sub method.
     */

    public void testSub() {
        assertEquals("Subtraction failed",
                     DataHolderFactory.holder(4),
                     DataHolderFactory.holder(20).sub(DataHolderFactory.holder(16)));
        assertEquals("Subtraction failed",
                     DataHolderFactory.holder(4),
                     DataHolderFactory.holder(20.0).sub(DataHolderFactory.holder(16.0)));
    }

    /**
     * Test of the add method.
     */

    public void testAdd() {
        assertEquals("Addition failed",
                     DataHolderFactory.holder(20),
                     DataHolderFactory.holder(12).add(DataHolderFactory.holder(8)));
        assertEquals("Addition failed",
                     DataHolderFactory.holder(20),
                     DataHolderFactory.holder(12.0).add(DataHolderFactory.holder(8.0)));
    }

    /**
     * Set up common stuff for all test methods.
     * This method is called immediately before each test method is called
     */

    public void setUp() {
    }

    /**
     * Tear down common stuff for all test methods.
     * This method is called immediately after each test method is called
     */

    public void tearDown() {
    }

	/**
	 * Populate the entry fields with the values stored in the editDVD
	 */

	private void populateFields() {
		fields = editDVD.getFields();
		//We also need to add any extra fields that may have been added later
		fields = Field.addMissingFields(fields);
		updateTabel();
		if(editDVD.getPoster() == null) {
			poster.setIcon(new ImageIcon(getClass().getResource("/org/dvdcatalog/dvdc/images/poster.png")));
		}
		else {
			poster.setIcon(new ImageIcon(editDVD.getPoster()));
		}
	}

	/**
	 * Store the entered information into the editDVD object
	 *
	 * @throws RuntimeException If there is invalid data.
	 */

	private void saveFields() throws RuntimeException {
		editDVD.setFields(fields);
	}

	/**
	 * This method is called to determine the rendered that will be used
	 * for each column.  If the column doesn't have data in it yet this
	 * function will fall back on the String's render so the table will not
	 * have an exception.
	 */

	public Class getColumnClass(int c) {
		try {
            return super.getColumnClass (c);
		} catch (NullPointerException e) {
			return String.class;
		}
	}

	/**
	 * Sets the data to be displayed in the table
	 *
	 * @param v the data to be displayed in the table
	 */

	public void setData(Vector v) {
		data = v;
		fireTableDataChanged();
	}

	/**
	 * Create the Save, Cancel, Previous, and Next buttons and adds them
	 * to a pane using the flow layout.
	 *
	 * @return pane containing the buttons
	 */

	private Component createButtons() {
		JPanel buttonPane = new JPanel();
		buttonPane.setLayout(new GridLayout(1, 3));

		previousButton.addActionListener(this);
		buttonPane.add(previousButton);

		nextButton.addActionListener(this);
		buttonPane.add(nextButton);

		saveButton.addActionListener(this);
		saveButton.setEnabled(false);
		buttonPane.add(saveButton);

		return buttonPane;
	}

	/**
	 *  This method should be called wehn a user wants the image
	 *
	 * @return    The poster which is an ImageIcon 
	 */

	public BufferedImage getPoster() {
		return poster;
	}

	/**
	 *  This is called when the new thread starts to run.
	 */

	public void run() {
		if(info != null) {
			info.setBar(bar);
			info.start();
		}
		else if(imdbSearch != null) {
			imdbSearch.start();
		}
	}

	/**
	 *  Sets the title attribute of the ImdbInfo object
	 *
	 * @param  title  The new title value
	 */

	public void setTitle(String title) {
		this.title = title;
	}

	/**
	 *  As seen below. Makes a CardLayout and the diffrent cards are added.
	 *
	 * @return    the pane that holds the components
	 */

	private Component createInputComponents() {
		cards = new JPanel(new CardLayout());
		cards.add(createCard1(), "INPUT");
		cards.add(createCard2(), "SEARCHING");
		cards.add(createCard3(), "LIST");
		cards.add(createCard4(), "RETRIEVING");
		cards.add(createCard5(), "INFO");
		return cards;
	}

	/**
	 *  Gets the director attribute of the imdbInfo object
	 *
	 * @return    The director value
	 */

	public String getDirector() {
		return director;
	}

	/**
	 *  Card nr 1. This card is for entering the movie to search for.
	 *
	 * @return    a JPanel which will be card nr 1
	 */

	private Component createCard1() {
		JPanel p = new JPanel();
		p.setAlignmentX(0.5f);
		p.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
		JLabel l = new JLabel("Movie Title: ");
		imdbSearch = new JTextField(20);
        imdbSearch.addActionListener (this);

		p.add(l);
		p.add(imdbSearch);

		JPanel toReturn = new JPanel();
		toReturn.setLayout(new BoxLayout(toReturn, BoxLayout.PAGE_AXIS));
		toReturn.add(createTopTitle("Enter a movietitle to search for", "Step 1 of 5"));
		toReturn.add(p);

		return toReturn;
	}

	/**
	 *  Gets the genre attribute of the imdbInfo object
	 *
	 * @return    The genre value
	 */

	public String getGenre() {
		return genre;
	}

	/**
	 *  Gets the tagline attribute of the imdbInfo object
	 *
	 * @return    The tagline value
	 */

	public String getTagline() {
		return tagline;
	}

	/**
	 *  Gets the plot attribute of the imdbInfo object
	 *
	 * @return    The plot value
	 */

	public String getPlot() {
		return plot;
	}

	/**
	 *  Gets the rating attribute of the imdbInfo object
	 *
	 * @return    The rating value
	 */

	public String getRating() {
		return rating;
	}

	/**
	 * This method is called to determine the rendered that will be used
	 * for each column.  If the column doesn't have data in it yet this
	 * function will fall back on the String's render so the table will not
	 * have an exception.
	 */

	public Class getColumnClass(int c) {
		try {
			return getValueAt(0, c).getClass();
		} catch (NullPointerException e) {
			return String.class;
		}
	}

	/**
	 *  Gets the posterUrl attribute of the imdbInfo object
	 *
	 * @return    The posterUrl value
	 */

	public String getPosterUrl() {
		return posterUrl;
	}

	/**
	 * Sets the data to be displayed in the table
	 *
	 * @param v the data to be displayed in the table
	 */

	public void setData(Vector v) {
        if (v instanceof SortedVector) data = v;
        else {
            data.clear ();

            for (int i = 0; i < v.size (); i++)
                data.add (v.get (i));
        }
		fireTableDataChanged();
	}

    /**
     * Add the ability to sort by column to a table.
     *
     * @param table the table to add the MouseListeners
     */

    public void addMouseListenerToTableHeader (final JTable table) {
        final MouseAdapter adapter = new MouseAdapter () {
            public void mouseClicked (final MouseEvent e) {
                final TableColumnModel columnModel = table.getColumnModel ();
                final int x = columnModel.getColumnIndexAtX (e.getX ());
                final int col = table.convertColumnIndexToModel (x);

                if(e.getClickCount () == 1 && col != -1) {
                    ((SortedVector)data).sortBy (col);
                    fireTableDataChanged ();
                }
            }
        };
        table.getTableHeader ().addMouseListener (adapter);
    }

	/**
	 *  Gets the address attribute of the ImdbInfo object
	 *
	 * @return    The address value
	 */

	public String getAddress() {
		return address;
	}

    /**
     * Compares two object arrays at column <i>col</i>.
     *
     * @param o1 first array
     * @param o2 second array
     *
     * @return the result of the string comparison
     *
     * @throws ClassCastException if either o1 or o2 are not object arrays (Object[])
     */

    public int compare (final Object o1, final Object o2) {
        final Object[] a = (Object[])o1, b = (Object[])o2;

        return ((String)a[col]).compareTo (b[col]);
    }

    /**
     * Compares this comparator with another comparator
     *
     * @returns true if column numbers are equal, false otherwise
     */

    public boolean equals (final Object o) {
        return o instanceof ColumnComparator && ((ColumnComparator)o).col == col;
    }

	/**
	 *  Creates the buttons at the buttom.
	 *
	 * @return    a JPanel with buttons
	 */

	private Component createButtons() {
		JPanel buttonPane = new JPanel();
		buttonPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		buttonPane.setLayout(new FlowLayout());

		backButton.addActionListener(this);
		backButton.setEnabled(false);
		buttonPane.add(backButton);

		nextButton.addActionListener(this);
		buttonPane.add(nextButton);

		skipButton.addActionListener(this);
		buttonPane.add(skipButton);

		cancelButton.addActionListener(this);
		buttonPane.add(cancelButton);

		return buttonPane;
	}

    /**
     * Inserts an element to the list in sorted order.
     *
     * @param o the object to insert
     *
     * @return true if inserted, false if insertion failed
     *
     * @throws ClassCastException if any non-Object array is encountered
     */

    public boolean add (final Object o) {
        final ColumnComparator cc = new ColumnComparator (col);

        for (int i = 0; i < size (); i++) {
            final int res = cc.compare (get (i), o) * (ascending ? 1 : -1);
            if (res > 0) {
                add (i, o);
                return true;
            }
        }
        return super.add (o);
    }

    /**
     * Sorts a column or toggles sort direction.
     *
     * @param col the column number to sort by
     *
     * @throws ClassCastException if any non-Object array is encountered
     * @throws ArrayIndexOutOfBoundsException if (col < 0 || col > number_of_columns)
     */

    public void sortBy (final int col) {
        if (this.col == col || isSorted (col)) reverse ();
        else {
            this.col = col;
            ascending = true;
            if (size () > 1) Collections.sort (this, new ColumnComparator (col));
        }
    }

    /**
     * Reverses the direction of the array.
     */

    public void reverse () {
        ascending = !ascending;
        final int lastIdx = size () - 1;

        for (int i = 0; i < lastIdx; i++)
            add (i, remove (lastIdx));
    }

	/**
	 * Create a FlowLayout pane to hold the new, edit, and delete buttons.
	 * @return a pane containing the buttons
	 */

	private Component createButtons() {
		JPanel buttonPane = new JPanel();
		buttonPane.setLayout(new FlowLayout());

		newButton.setName("new");
		buttonPane.add(newButton);
		editButton.setName("edit");
		editButton.setEnabled(false);
		buttonPane.add(editButton);
		deleteButton.setName("delete");
		deleteButton.setEnabled(false);
		buttonPane.add(deleteButton);

		return buttonPane;
	}

	/**
	 * Create a table for the DVDs with single selection mode so only one
	 * DVD can be selected at a time.
	 *
	 * @return a table
	 */

	private JTable createTable() {
		DVDTableModel dvdModel = new DVDTableModel();
		//dvdModel.setData(dvdCollection);
		JTable table = new JTable(dvdModel);
		table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        dvdModel.addMouseListenerToTableHeader (table);

		return table;
	}

	/**
	 * Converts a vector of DVDs into a vector of arrays for the table
	 *
	 * @param v Vector of DVDs
	 */

	public void updateTableData(Vector v) {
		DVDTableModel model = (DVDTableModel) dvdTable.getModel();
		Vector data = new Vector();
		Iterator i = v.iterator();

		while (i.hasNext()) {
			DVD dvd = (DVD) i.next();
			data.add(dvd.toArray());
		}

		model.setData(data);
	}

	/**
	 * Enable the edit and delete buttons.  This is called when a row on the
	 * table is selected.
	 */

	public void enableEditDeleteButtons() {
		editButton.setEnabled(true);
		deleteButton.setEnabled(true);
	}

	/**
	 * This method keeps track of which row in the table is selected.
	 */

	public void valueChanged(ListSelectionEvent e) {
        //Ignore extra messages.
        if (e.getValueIsAdjusting()) return;

        ListSelectionModel lsm = (ListSelectionModel)e.getSource();
        if (lsm.isSelectionEmpty()) {
            //no rows are selected
        	mainFrame.disableEditDeleteButtons();
        	selectedRow = -1;

        } else {
        	// a row has been selected
             selectedRow = lsm.getMinSelectionIndex();
             mainFrame.enableEditDeleteButtons();
        }

	}

	/**
	 * Disable the edit and delete buttons.  This is called when a row on the
	 * table is not selected.
	 */

	public void disableEditDeleteButtons() {
		editButton.setEnabled(false);
		deleteButton.setEnabled(false);
	}

	/**
	 *  Set if the Type should be permanent. For now there is no restricion
	 *  just a boolean holder.
	 */

	public void setPermanentType() {
		permanent = true;
	}

	/**
	 *  For each field that is created a type is saved in a Vector. The purpose 
	 *  is to avoid the user to reAdd a new type every time he/she adds a DVD.
	 *  This method is called every time a change in the type String is made.
	 */

	private void collectTypes() {
		boolean foundNewType = true;
		Iterator i = types.iterator();
		while (i.hasNext()) {
			String t = (String) i.next();
			if(t.equalsIgnoreCase(type)) {
				foundNewType = false;
				break;
			}
		}
		if(foundNewType) {
			Log.print(3, "New type found, added to the list: " + type);
			types.add(type);
		}
	}

	/**
	 * This method will open the edit window when an item is double
	 * clicked on the table.
	 */

	public void mouseClicked(MouseEvent e){
		if (e.getClickCount() == 2){
			DVD dvd = (DVD)dvdCollection.get(selectedRow);
			openEditWindow(dvd);
		}
	}

	/**
	 *  This message is called when the fetching of data is done.
	 */

	public void nextPage(ImdbInfo[] imdbAddresses) {
		CardLayout cl = (CardLayout) (cards.getLayout());
		cl.next(cards);
		cardNr++;

		String[] moviesFound = new String[imdbAddresses.length];
		for(int i = 0; i < imdbAddresses.length; i++) {
			moviesFound[i] = imdbAddresses[i].getTitle();
		}

        //Arrays.sort (moviesFound, new RelevanceComparator (imdbSearch.getText ()));

		list.setListData(moviesFound);

		this.imdbAddresses = imdbAddresses;

		backButton.setEnabled(true);
		nextButton.setEnabled(true);
	}

	/**
	 *  Compares two DVDs based on their titles.
	 *
	 * @param  o  Description of the Parameter
	 * @return    a negative integer, zero, or a positive integer as this DVD title
	 *      is less than, equal to, or greater than the specified DVD title; zero
	 *      if the provided object is not a DVD object.
	 */

	public int compareTo(Object o) {
		if (o instanceof DVD) {
			DVD d = (DVD) o;
			Field f = (Field) fields.get(0);
			Field f2 = (Field) d.getFields().get(0);
			return f.getValue().compareTo(f2.getValue());
		} else {
			return 0;
		}
	}

	/**
	 *  If the data is from imdb.com
	 *
	 * @param  wiz  The new fromWizard value
	 */

	public void setFromWizard(boolean wiz) {
		wizard = wiz;
	}

	/**
	 *  Return true if the data is from imdb.com
	 *
	 * @return    The fromImdb value
	 */

	public boolean isFromWizard() {
		return wizard;
	}

	/**
	 * This method will be called from the edit window once it is closed. It
	 * will allow the user to use the main window.
	 */

	public void enableMainWindow() {
		mainFrame.setEnabled(true);
		mainFrame.setVisible(true);
	}

	/**
	 * Sort the DVD collection and update the table data
	 */

	public void dvdDataUpdated() {
		Collections.sort(dvdCollection);
		mainFrame.updateTableData(dvdCollection);
	}

	/**
	 * Add a DVD to the collection.  This method is called by the edit window
	 * when a new DVD is saved.
	 * @param d DVD to add to the collection
	 */

	public void addDVD(DVD d) {
		dvdCollection.add(d);
	}

	/**
	 * This method informs the edit window if there is a DVD after the
	 * one currently being edited.
	 *
	 * @return true or false if there is a DVD after the currectly selected one
	 */

	public boolean hasNextDVD() {
		return (selectedRow < dvdCollection.size()-1);
	}

	/**
	 * This method informs the edit window if there is a DVD before the
	 * one currently being edited.
	 *
	 * @return true or false if there is a DVD before the currectly selected one
	 */

	public boolean hasPreviousDVD() {
		return (selectedRow > 0);
	}

    /**
     * decrease the intensity value in all scopes.
     */

    public void next() {
        Event e = new Event();
        e.type = Event.NEXT;
        e.time = System.currentTimeMillis() + delay;
        queue.add(e);
    }

    /**
     * "poke" a channel, causing it's intensity value to be set to the max.
     * @param channel
     */

    public void poke(int channel) {
        Event e = new Event();
        e.type = Event.POKE;
        e.channel = channel;
        e.time = System.currentTimeMillis() + delay;
        queue.add(e);
    }

    /**
     * get the character representing the current intencity value of a channel.
     * @param channel
     * @return
     */

    public char getChannel(int channel) {
        synchronized (scopes) {
            return levels[(int)scopes[channel]];
        }
    }

    /**
     * get a string representation of the scopes.
     * @return
     */

    public String getAllChannels() {
        StringBuffer sb = new StringBuffer();
        for (int n = 0; n < scopes.length; n++) {
            sb.append(getChannel(n));
        }
        return sb.toString();
    }

    /**
     * get the value of the initial relative volume of a track.
     * @param track
     * @return
     */

    public double getInitialVolume(int track) {
    	return initialTrackVolume[track];
    }

    /**
     * utility method for finding the number of tracks (channels) in the module. Note that this
     * isn't reliable if you've managed to construct a module that has a different number of
     * tracks per pattern. That's pretty unlikely though... It also doesn't work unless you
     * have atleast one pattern.
     * @return
     */

    public int getTrackCount() {
        return getPatternAtPos(0).getTrackCount();
    }

    /**
     * loads a list from a LineNumberReader. Each line contains the name of a module.
     *
     * @param lnr
     * @throws IOException
     */

    private void loadList(LineNumberReader lnr) throws IOException {
        position = -1;
        list = new ArrayList<String>();
        String line = null;
        while ((line = lnr.readLine()) != null) {
            line = line.trim();
            File file = new File(line);
            if (file.exists() && file.isFile())
                list.add(line);
        }
    }

    /**
     * removes the current module from the playlist
     */

    public void remove() {
        list.remove(position);
    }

    /**
     * create a player thread for playing the
     * @param module
     * @return
     */

    private PlayerThread createPlayerThread(Module module) {
        Player player = new Player();
        try {
            player.init(
                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),
                INTERPOLATE);
            player.load(module);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        PlayerThread playerthread = new PlayerThread(player);
        playerthread.pause(true);
        return playerthread;
    }

    /**
     * load the <code>nextModule</code>'th file in the file list.
     * @param nextModule
     * @return
     */

    private Module loadModule(int nextModule) {
        int mc = fileList.size();
        while (nextModule <= 0) nextModule += mc;
        try {
            theUrl = new URL(protocol, host, port, fileList.get((nextModule + mc) % mc));
            return ModuleLoader.getModuleLoader(theUrl).getModule();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * create a player thread for playing the
     * @param module
     * @return
     */

    private ThreadedPlayer createPlayer(Module module) {
        ThreadedPlayer player = new ThreadedPlayer();
        try {
            player.init(
                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),
                INTERPOLATE);
            player.load(module);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        player.pause(true);
        return player;
    }

        /**
         * make the player thread die as soon as possible.
         */

        public void quit() {
            run = false;
        }

    /**
     * tell the playlist to save itself to the current playlist file
     * @throws IOException
     */

    public void savePlayList() throws IOException {
        savePlayList(new File(playListFile),playList);
        Logger.debug("Saved playlist: " + playListFile);
    }

    /**
     * start playing the module
     */

    public void start() {
        running = true;
        t = new Thread(this);
        t.start();
    }

    /**
     * stop playing the module and the player thread
     */

    public void stop() {
        running = false;
    }

    /**
     * check if the player thread is still running
     * @return
     */

    public boolean isRunning() {
        return running;
    }

    /**
     * pause the player thread
     * @param pause
     */

    public void pause(boolean pause) {
        paused = pause;
    }

    /**
     * check if the module is paused
     * @return
     */

    public boolean isPaused() {
        return paused;
    }

    /**
     * check if an error has occured while playing
     * @return
     */

    public boolean hasFailed() {
        return error;
    }

    /**
     * if an error occured while playing, use this to get the error cause
     * @return
     */

    public Throwable getFailiureCause() {
        return errorCause;
    }

        /**
         * sets if this track should be muted
         *
         * @param mute if true: mute, if false: unmute
         */

        public void setMute(boolean mute) {
            this.mute = mute;
        }

    /**
     * initialize the player
     *
     * @param output
     * @return true if initialization was successful
     */

    public boolean init(Output output, boolean interpolate) {
        out = output;
        lowLevelMixerClass = interpolate ? InterpolatingMixer.class : FastMixer.class;
        return true;
    }

    /**
     * Load a module from a file
     *
     * @param fileName the file name of the module
     * @return true if loading was successful, false else
     */

    public boolean load(String fileName) throws InvalidFormatException, IOException {
        ModuleLoader ml = ModuleLoader.getModuleLoader(new File(fileName));
        Module module = ml.getModule();
        return load(module);
    }

    /**
     * Load a module
     * @param module the module to load
     * @return true if loading was successful, false else
     */

    public boolean load(Module module) {
        int tracks = module.getPatternAtPos(0).getTrackCount();

        Mixer mixer = new DefaultMixer(out, lowLevelMixerClass, tracks);

        ms = new ModuleState(module, mixer);

        // do some mixer initialization...
        mixer.setAmplification(getDefaultAmplification());

        return out.open();
    }

    /**
     * play a tick of the the module
     *
     * @return true if the module is still playing, false if the module is finished.
     */

    public boolean play() throws PlayerException {
        return ms.play();
    }

    /**
     * get the state of the module. The ModuleState can be used for
     * finding information about the playing module and for manipulating how the
     * module should be played
     *
     * @return the state of the playing module
     */

    public ModuleState getModuleState() {
        return ms;
    }

    /**
     * get the current module;
     * @return
     */

    public Module getModule() {
        return getModuleState().getModule();
    }

    /**
     * get the default amplification. The default amplification is calculated using the following
     * formula: <code>#tracks / 4</code>. This should maintain a reasonable volume when playing
     * modules with many channels while avoiding clipping in most cases. Note that for 4channel mods
     * this will result in an amplification of 1.
     * @return
     */

    public double getDefaultAmplification() {
        return getModuleState().getModule().getPatternAtPos(0).getTrackCount() / 4.0;
    }

    /**
     * this will try to write all the indicated data whitout ever giving up...
     * Either all the data is written or it will loop for ever.
     *
     * @param data
     * @param ofs
     * @param len
     */

    private void writeData(byte[] data, int ofs, int len) {
        int count = 0;
        int written = 0;
        while (written < len) {
            written += sdl.write(data, ofs + written, len - written);

            // take a litle break if we couldn't write everything in 100
            // tries...
            count++;
            if (count >= 100) {
                try { Thread.sleep(10); } catch (InterruptedException e) { }
                count = 0;
            }
        }
    }

	/**
	 * Returns a service object injected by Spring
	 * @return
	 */

	protected CatalogInquiry getCatalogService(){
		return catalogService;
	}

	/**
	 * Returns a service object injected by Spring
	 * @return
	 */

	protected AccountManagement getAccountService(){
		return accountService;
	}

	/**
	 * Returns a service object injected by Spring
	 * @return
	 */

	protected OrderEntry getOrderService(){
		return orderService;
	}

    /**
     * Shutdown all the loaded services
     */

    public void shutdownServices() {
	if(services==null) return;

        for(Iterator it = services.iterator();
            it.hasNext();){
               MPPlugin serv = (MPPlugin)it.next();
	       // Shutdown service
	       serv.shutdown();
	}

	services = null;
    }

    /** Returns a string of the location. */

    private String getLocationString(SAXParseException ex) {
	StringBuffer str = new StringBuffer();

	String systemId = ex.getSystemId();
	if (systemId != null) {
	    int index = systemId.lastIndexOf('/');
	    if (index != -1) 
		systemId = systemId.substring(index + 1);
	    str.append(systemId);
	}
	str.append(':');
	str.append(ex.getLineNumber());
	str.append(':');
	str.append(ex.getColumnNumber());

	return str.toString();

    } // getLocationString(SAXParseException):String

    /**
     * Get the Password value.
     * @return the Password value.
     */

    public String getPassword() {
        return password;
    }

  /**
   * Called on the event dispatching thread (not on the worker thread)
   * after the <code>construct</code> method has returned.
   */

  public void finished() {
    workers.removeElement(this);
    workersStart.remove(this);
  }

    /**
     * Set the Password value.
     * @param newPassword The new Password value.
     */

    public void setPassword(String newPassword) {
        this.password = newPassword;
    }

  /**
   * A new method that interrupts the worker thread.  Call this method
   * to force the worker to abort what it's doing.
   */

  public void interrupt() {
    Thread t = threadVar.get();
    if (t != null) {
      t.interrupt();
    }
    threadVar.clear();
  }

    /**
     * Get the Userid value.
     * @return the Userid value.
     */

    public String getUserid() {
        return userid;
    }

  /**
   * Return the value created by the <code>construct</code> method.  
   * Returns null if either the constructing thread or
   * the current thread was interrupted before a value was produced.
   * 
   * @return the value created by the <code>construct</code> method
   */

  public Object get() {
    while (true) {  
      Thread t = threadVar.get();
      if (t == null) {
	return getValue();
      }
      try {
	t.join();
      }
      catch (InterruptedException e) {
	Thread.currentThread().interrupt(); // propagate
	return null;
      }
    }
  }

    /**
     * Set the Userid value.
     * @param newUserid The new Userid value.
     */

    public void setUserid(String newUserid) {
        this.userid = newUserid;
    }

  /**
   * Start the worker
   */

  public void start(){
    startThread.start();
  }

    /**
     * Get the ConnectUrl value.
     * @return the ConnectUrl value.
     */

    public String getConnectUrl() {
        return connectUrl;
    }

    /**
     * Set the ConnectUrl value.
     * @param newConnectUrl The new ConnectUrl value.
     */

    public void setConnectUrl(String newConnectUrl) {
        this.connectUrl = newConnectUrl;
    }

    /**
     * Get the JdbcDriver value.
     * @return the JdbcDriver value.
     */

    public String getJdbcDriver() {
        return jdbcDriver;
    }

    /**
     * Set the JdbcDriver value.
     * @param newJdbcDriver The new JdbcDriver value.
     */

    public void setJdbcDriver(String newJdbcDriver) {
        this.jdbcDriver = newJdbcDriver;
    }

    /**
     * Getter for property doPopup.
     * @return Value of property doPopup.
     */

    public boolean isDoPopup() {
        
        return this.doPopup;
    }

    /**
     * Setter for property doPopup.
     * @param doPopup New value of property doPopup.
     */

    public void setDoPopup(boolean doPopup) {
        this.doPopup = doPopup;
    }

    /**
     * Translates Xml Document from CDA to CLIPS format.
     * 
     * @param inputDocument
     *            String representation of the input XML document.
     * @return File representation of the translated document.
     */

    public File translateDocument(String inputDocument) throws Exception {

        try {
            documentTree = FileUtils.getInstance().stringToDocument(
                    inputDocument);
        } catch (Exception e) {
            throw e;
        }

        result = new StringBuffer();
        result.append("(deffacts patientSummary");
        result.append("\n");
        buildResult(documentTree.getFirstChild(), "");
        result.append("\n");
        result.append(")");
        File f = null;
        try {
            f = this.createFileFromStr(result.toString());
        } catch (Exception e) {
            throw e;
        }
        return f;

    }

    /**
     * Converts a String to a File
     * 
     * @param str
     *            String representation of the input XML document translated
     *            into CLIPS format.
     * @return File representation of the String.
     */

    private File createFileFromStr(String str) throws Exception {
        File file = new File("fileForIE.clp");
        FileWriter fileWriter;
        try {
            fileWriter = new FileWriter(file);
            BufferedWriter out = new BufferedWriter(fileWriter);
            out.write(str);
            out.close();
        } catch (IOException e) {
            throw e;
        }
        return file;
    }

    /**
     * Returns the Results document creation time in the appropriate CDA format
     *
     * @return String representation of the document creation time
     *
     */

    private String getCurrentTime() {

        Date now = new Date();
        SimpleDateFormat df1 = new SimpleDateFormat("yyyyMMdd");

        return df1.format(now);
    }

    /**
     * Returns the Results document code
     *
     * @return String representation of the document code
     *
     */

    private String generateDocCode() {
        // TO DO: come up with document code generation mechanism
        return "111";
    }

    /**
     * Returns the Results document code system
     *
     * @return String representation of the document code system
     *
     */

    private String generateDocCodeSystem() {
        // come up with document code generation mechanism
        return "111";
    }

    /**
     * Registers IDocImport interface instance with the TransController
     * component.
     * 
     * @param iDocumentImport
     *            Instance of the DocImpEx component refered to by the
     *            IDocumentImport interface
     */

    private void registerIDocImport(IDocumentImport iDocumentImport) {
        this.iDocumentImport = iDocumentImport;

    }

    /**
     * Registers IDocExport interface instance with the TransController
     * component.
     * 
     * @param iDocumentExport
     *            Instance of the DocImpEx component refered to by the
     *            IDocumentExport interface
     */

    private void registerIDocExport(IDocumentExport iDocumentExport) {
        this.iDocumentExport = iDocumentExport;

    }

    /**
     * Registers IInference interface instance with the TransController
     * component.
     * 
     * @param iInference
     *            Instance of the InferenceEngine component refered to by the
     *            IInference interface
     */

    private void registerIInference(IInference iInference) {
        this.iInference = iInference;

    }

    /**
     * Registers IAuditLog interface instance with the TransController
     * component.
     * 
     * @param iAuditLog
     *            Instance of the ConfigManager component refered to by the
     *            IAuditLog interface
     */

    private void registerIAuditLog(IAuditLog iAuditLog) {
        this.iAuditLog = iAuditLog;

    }

    /**
     * Returns <tt>true</tt> if the iteration has more elements. (In other
     * words, returns <tt>true</tt> if <tt>next</tt> would return an element
     * rather than throwing an exception.)
     * 
     * @return <tt>true</tt> if the iterator has more elements.
     */

    public boolean hasNext() {
        return (position < length);
    }

    /** Get a scalar type for the given name. */

    public PrimitiveType primitive(String name) {
        return new PrimitiveType(this, name);
    }

    /** Get a scalar type for the name represented by a token. */

    public PrimitiveType primitive(Token token) {
        return primitive(token.getText());
    }

    /** Get a scalar type for the name represented by a symbol. */

    public PrimitiveType primitive(Symbol symbol) {
        return primitive(symbol.toString());
    }

    /** Apply the analysis to a list of child nodes. */

    protected void visit(List nodes) {
        Iterator iNodes = nodes.iterator();
        while (iNodes.hasNext())
            ((Node) iNodes.next()).apply(this);
    }

    /** Apply the analysis to a child node. */

    protected void visit(Node node) {
        node.apply(this);
    }

    /** Report a warning message. */

    protected void warning(String msg) {
        logger.warning(msg);
        // _errOut.println(msg);
    }

    /** Are there any errors? */

    public boolean hasErrors() {
        return _errors;
    }

    /**
     * This method provides a String representation of a document with clinical
     * recommendations based on patient-specific data.
     *
     * @param patientSummary
     *            String representation of the CDA Patient Summary document that
     *            is received by the EGADSS Service
     * @return String representation of the Results CDA document that contains
     *         clinical results from EGADSS. (the recommendations and requests
     *         for additional patient information if applicable)
     */

    public String getRecommendations(String patientSummary) {

        helper = new SimpleWebServiceHelper();
        String result = null;
        try {
            result = helper.getRecommendations(patientSummary);
        } catch (EgadssException ex) {
            logger.log(Level.SEVERE, ex.toString(), ex);
        }
        return result;

    }

    /** Creates and initializes instances of other EGADSS components. */

    private void startSystem() throws Exception {
        try {
            this.createComponents();

            this.initializeComponents();
            log.info("EGADSS SYSTEM HAS BEEN STARTED");

        } catch (Exception e) {
            throw e;
        }

    }

    /**
     * velocityClinicalGuideline
     *
     * @return String
     */

    public String velocityClinicalGuideline()throws EgadssException {
        if(!initialized)
    throw new EgadssException("Configuration must be initialized before fields can be accessed");
        return this.velocityClinicalGuideline;
    }

    /**
     * Tests the DocumentValidator.validateDocument method of the DocImpEx
     * componenet
     */

    public void testValidateDocumentCase1() {
        try {

            if (documentValidator.validateDocument(FileUtils.getInstance()
                    .filetoString(
                            new File(Configuration.getInstance()
                                    .testPatientXmlUri())), Configuration
                    .getInstance().patientSummarySchemaUri())) {
                assertTrue(true);
            } else
                assertTrue(false);
        } catch (Exception e) {

            logger.log(Level.WARNING, "Case 1 Exception in DocumentValidator.validateDocument method: "
                            + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.getInfo method of the DocImpEx componenet
     */

    public void testGetInfo() {
        try {
            String componentInfo = iConfig.getInfo();
            logger.fine("Returned Component info: " + componentInfo);
            logger.fine("Testing of getInfo method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Exception in testing getInfo method: "
                    + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.initialize method of the DocImpEx componenet
     */

    public void testInitialize() {
        try {
            iConfig.initialize(docImpExCompMap);
            assertTrue(true);
            logger.fine("Testing of initialize method was successful");
        } catch (Exception e) {
            logger
                    .log(Level.WARNING,
                            "Exception in testing initialize method: "
                                    + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.terminate method of the DocImpEx componenet
     */

    public void testTerminate() {
        // try{
        // iConfig.terminate();
        // logger.fine("Testing of terminate method was successful");
        // assertTrue(true);
        // }
        // catch(Exception e){
        // logger.log(Level.WARNING, "Exception in testing initialize method:
        // "+e.getMessage(), e);
        // }
    }

    /**
     * Tests the IDocumentImport.importDocument method of the DocImpEx
     * componenet
     */

    public void testImportDocument() {
        try {

            iDocumentImport.importDocument(xmlDocumentStr);
            logger.fine("Testing of importDocument method was successful");
            assertTrue(true);
        } catch (Exception e) {
            assertTrue(false);
            logger.log(Level.WARNING, "Exception in testing importDocument: "
                    + e.getMessage(), e);
        }

    }

    /**
     * Tests the IDocumentExport.exportDocument method of the DocImpEx
     * componenet
     */

    public void testExportDocument() {

        try {
            outputFromIeFile = new File(Configuration.getInstance()
                    .patientResultInstancesClpUri());
            iDocumentImport.importDocument(xmlDocumentStr);
            iDocumentExport.exportDocument(outputFromIeFile);
            logger.fine("Testing of exportDocument method was successful");
            assertTrue(true);
        } catch (Exception e) {
            assertTrue(false);
            logger.log(Level.WARNING, "Exception in testing exportDocument: "
                    + e.getMessage(), e);
        }

    }

    /**
     * Tests the IConfig.getInfo method of the TransController componenet
     */

    public void testGetInfo() {
        try {
            String componentInfo = iConfigTransController.getInfo();
            logger.fine("Returned Component info: " + componentInfo);
            logger.fine("Testing of getInfo method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Exception in testing getInfo method: "
                    + e.getMessage(), e);
        }
    }

    /**
     * Tests the IConfig.initialize method of the TransController componenet
     */

    public void testInitialize() {
        try {
            iConfigTransController.initialize(transControllerCompMap);
            assertTrue(true);
            logger.fine("Testing of initialize method was successful");
        } catch (Exception e) {
            logger
                    .log(Level.WARNING,
                            "Exception in testing initialize method: "
                                    + e.getMessage(), e);
        }
    }

    /**
     * Tests the XPathPreprocessor.parseKnowledgeModuleForXPath method.
     */

    public void testParseKnowledgeModuleForXPath() {
        try {

            preprocessor.parseKnowledgeModuleForXPath(knowledgeModuleFile);
            logger.fine("Testing of parseKnowledgeModuleForXPath method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.WARNING, "Exception in testing preprocessXPath: "
                    + e.getMessage(), e);
            assertTrue(false);

        }

    }

    /**
     * Tests the IConfig.terminate method of the TransController componenet
     */

    public void testTerminate() {
        // try{
        // iConfigTransController.terminate();
        // assertTrue(true);
        // }
        // catch(Exception e){
        // }
    }

    /**
     * Tests the ITrans.getRecommendations method of the TransController
     * componenet
     */

    // public void testGetRecommendations() {
    //
    // this.testInitialize();
    //		
    // //assert knowledge module into InferenceEngine
    // try{
    // ie.assertKnowledgeModule(testGuideline, "Immunizations");
    // }catch(Exception e){
    // assertTrue(false);
    // }
    //		
    // try{
    //			
    //			
    // resultsDocument=iTrans.getRecommendations(inputDocument);
    //			
    // assertTrue(true);
    // }
    // catch(Exception e){
    // assertTrue(false);
    // }
    // }

    /**
     * Tests the IConfig.getInfo method of the DataStorage componenet
     */

    public void testGetInfo() {
        try {
            String componentInfo = iConfigDataStorage.getInfo();
            logger.fine("Returned Component info: " + componentInfo);
            logger.info("Testing of getInfo method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.INFO, "Exception in testing getInfo method: "
                    + e.getMessage(), e);
        }
    }

    /**
     * Tests the IConfig.initialize method of the DataStorage componenet
     */

    public void testInitialize() {
        try {
            iConfigDataStorage.initialize(dataStorageComMap);
            assertTrue(true);
            logger.info("Testing of initialize method was successful");
        } catch (Exception e) {
            logger.log(Level.INFO, "Exception in testing initialize method: "
                    + e.getMessage(), e);
        }
    }

    /**
     * Tests the IAuditLog.writeLogEntry method of the ConfigManager componenet
     */

    public void testWriteLogEntry() {
        try {
            iAuditLog.writeLogEntry(logEntry);
            logger.info("Testing of writeLogEntry method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.INFO,
                    "Exception in testing writeLogEntry method: "
                            + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.terminate method of the DataStorage componenet
     */

    public void testTerminate() {
        // try{
        // docImpEx.terminate();
        // assertTrue(true);
        // }
        // catch(Exception e){
        // }
    }

    /**
     * Tests the IAudit.generateAuditReport method of the ConfigManager
     * componenet
     */

    public void testGenerateAuditReport() {
        try {
            report = iAudit.generateAuditReport();
            if (!(report == null)) {
                logger.fine("Audit report string: " + report);
                logger
                        .info("Testing of generateAuditReport method was successful");
                assertTrue(true);
            } else {
                assertTrue(false);
            }
        } catch (Exception e) {
            logger.log(Level.INFO,
                    "Exception in testing generateAuditReport method: "
                            + e.getMessage(), e);
            assertTrue(false);
        }

    }

    /**
     * Tests the IAudit.setAuditingMode and IAudit.getAuditingMode methods of
     * the ConfigManager componenet
     */

    public void testSetAndGetAuditingMode() {
        try {
            iAudit.setAuditingMode("privacy mode");
            if ((iAudit.getAuditingMode()).equals("privacy mode")) {
                logger
                        .info("Testing of setAuditingMode and getAuditingMode methods was successful");
                assertTrue(true);
            } else {
                assertTrue(false);
            }
        } catch (Exception e) {
            logger.log(Level.INFO,
                    "Exception in testing setAuditingMode method: "
                            + e.getMessage(), e);
            assertTrue(false);
        }

    }

    /**
     * Tests the ISysConfig.shutSystemDown method of the ConfigManager
     * componenet
     */

    public void testShutSystemDown() {
        // TO DO: figure out how to test methods that terminate the
        // application...

        

    }

    /**
     * Tests the ISysConfig.viewSystemConfig method of the ConfigManager
     * componenet
     */

    public void testViewSystemConfig() {
        try {
            config = iSysConfig.viewSystemConfig();
            logger.fine("Config string: " + config);
            logger.info("Testing of viewSystemConfig method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.INFO,
                    "Exception in testing viewSystemConfig method: "
                            + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.getInfo method of the ConfigManager componenet
     */

    public void testGetInfo() {
        try {
            String componentInfo = iConfigConfigManager.getInfo();
            logger.fine("Returned Component info: " + componentInfo);
            logger.info("Testing of getInfo method was successful");
            assertTrue(true);
        } catch (Exception e) {
            logger.log(Level.INFO, "Exception in testing getInfo method: "
                    + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.initialize method of the ConfigManager componenet
     */

    public void testInitialize() {
        try {
            iConfigConfigManager.initialize(configManagerCompMap);
            assertTrue(true);
            logger.info("Testing of initialize method was successful");
        } catch (Exception e) {
            logger.log(Level.INFO, "Exception in testing initialize method: "
                    + e.getMessage(), e);
            assertTrue(false);
        }
    }

    /**
     * Tests the IConfig.terminate method of the ConfigManager componenet
     */

    public void testTerminate() {
        // try{
        // iConfigConfigManager.terminate();
        // assertTrue(true);
        // }
        // catch(Exception e){
        // assertTrue(false);
        // }
    }

	/**
	 * This method is called when the plug-in is stopped
	 */

	public void stop(BundleContext context) throws Exception {
		super.stop(context);
	}

    /**
     * trace utility of server
     */

    public void trace(boolean onoff) {
      try {
        serverControl.trace(onoff);
      } catch (Exception e) {
          e.printStackTrace();
        }
    }

    /**
     * Shutdown the NetworkServer
     */

    public void shutdown() {
        try {
            serverControl.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

	/**
	 * Start Derby Network server
	 * 
	 */

    public void start() {
        try {
			serverControl.start(pw);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

	 /**
	  *	gets a database connection
	  * If the dbUrl is trying to connect to the Derby NetNsSampleWork server using JCC
	  * then the jcc driver must be already loaded before calling this method,
	  * else there will be an error
	  * return jcc connection if no error, else null
	  */

	 public Connection getConnection(String dbUrl, Properties properties) {
		 Connection conn = null;
		 try {
			pw.println("[NsSampleWork] Thread id - "+thread_id + "; requests database connection, dbUrl ="+dbUrl);
			conn = DriverManager.getConnection(dbUrl, properties);
		  } catch (Exception e) {
			 System.out.println("[NsSampleWork] Thread id - "+ thread_id + "; failed to get database connection. Exception thrown:");
			 e.printStackTrace();
		    }
		  return conn;
	 }

	 /**
	  * set the connection to this isolation level
	  */

	 public void setIsolationLevel(Connection conn, int level) {
		 try {
			conn.setTransactionIsolation(level);
		 } catch (Exception e) {
			 pw.println("[NsSampleWork] Thread id - "+ thread_id +"; setIsolationLevel failed. Exception thrown: ");
			 e.printStackTrace();
		   }
	 }

	/**
	 * Return the length of the binary stream which was calculated when
	 * EXTDTAObject was created.
	 * 
	 * @return the length of the stream once converted to an InputStream
	 */

	public long length() throws SQLException {
		return dataLength;
		
	}

	/**
	 * Return chaining bit for current DSS.
	 */

	protected byte getCurrChainState() {

		if (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)
			return DssConstants.DSS_NOCHAIN;

		if (dssIsChainedWithSameID)
			return DssConstants.DSSCHAIN_SAME_ID;

		return DssConstants.DSSCHAIN;

	}

	/**
	 * End DSS header by writing the length in the length location
	 * and setting the chain bit.
	 */

	protected void endDss() {
		endDss(true);
	}

	/**
	 * Looks at chaining info for previous DSS written, and use
	 * that to figure out what the correlation id for the current
	 * DSS should be.  Return that correlation id.
	 */

	private int getCorrelationID() {

		int cId;
		if (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {
			if (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)
			// then we have to use the last correlation id we sent.
				cId = previousCorrId;
			else
			// get correlation id as normal.
				cId = nextCorrelationID++;
		}
		else {
		// must be the case that this is the first DSS we're
		// writing for this connection (because we haven't
		// called "endDss" yet).  So, get the corr id as
		// normal.
			cId = nextCorrelationID++;
		}

		return cId;

	}

	/**
	 * get an HTML labelled message from the resource bundle file, according to
	 * the given key.
	 */

	public String getHtmlLabelledMessageInstance(LocalizedResource localUtil, String key, String id) {

		if (id == null)
			id = "";

		return ("<label for='" + id + "'>" + localUtil.getTextMessage(key) +
			"</label>");

	}

	/**
	 * Print the received string as a header.
	 * @param str The string to be printed as a header.
	 */

	private void printAsContentHeader(String str) {

		out.println("<a name=\"navskip\"></a><h2>" + str + "</h2>");
		return;

	}

	/**
	 * If the received string has one or more single quotes
	 * in it, replace each one with the HTML escape-code
	 * for a single quote (apostrophe) so that the string 
	 * can be properly displayed on a submit button.
	 * @param str The string in which we want to escape
	 *  single quotes.
	 */

	private String escapeSingleQuotes(String str) {

		if ((str == null) || (str.indexOf("'") < 0))
			return str;

		char [] cA = str.toCharArray();

		// Worst (and extremely unlikely) case is every 
		// character is a single quote, which means the
		// escaped string would need to be 4 times as long.
		char [] result = new char[4*cA.length];

		int j = 0;
		for (int i = 0; i < cA.length; i++) {

			if (cA[i] == '\'') {
				result[j++] = '&';
				result[j++] = '#';
				result[j++] = '3';
				result[j++] = '9';
			}
			else
				result[j++] = cA[i];

		}

		return new String(result, 0, j);

	}

	/**
	 * Build preformatted SQLException text 
	 * for severe exceptions or SQLExceptions that are not EmbedSQLExceptions.
	 * Just send the message text localized to the server locale.
	 * 
	 * @param se  SQLException for which to build SQLERRMC
	 * @return preformated message text 
	 * 			with messages separted by SQLERRMC_PREFORMATED_MESSAGE_DELIMITER
	 * 
	 */

	private String  buildPreformattedSqlerrmc(SQLException se) {
		if (se == null)
			return "";
		
		StringBuffer sb = new StringBuffer(); 
		 // String buffer to build up message
		do {
			sb.append(se.getLocalizedMessage());
			se = se.getNextException();
			if (se != null)
				sb.append(SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER + 
						"SQLSTATE: " + se.getSQLState());
		} while (se != null);			
		return sb.toString();		
	}

	/**
	 * Build Tokenized SQLERRMC to just send the tokenized arguments to the client.
	 * for a Derby SQLException
	 * Message argument tokens are separated by SQLERRMC_TOKEN_DELIMITER 
	 * Multiple messages are separated by SQLERRMC_MESSAGE_DELIMITER
	 * 
	 *                 ...
	 * @param se   SQLException to print
	 * 
	 */

	private String buildTokenizedSqlerrmc(EmbedSQLException se) {
		
		String sqlerrmc = "";
		do {
			String messageId = se.getMessageId();
			// arguments are variable part of a message
			Object[] args = se.getArguments();
			for (int i = 0; args != null &&  i < args.length; i++)
				sqlerrmc += args[i] + SQLERRMC_TOKEN_DELIMITER;
			sqlerrmc += messageId;
			se = (EmbedSQLException) se.getNextException();
			if (se != null)
			{
				sqlerrmc += SQLERRMC_MESSAGE_DELIMITER + se.getSQLState() + ":";				
			}
		} while (se != null);
		return sqlerrmc;
	}

	/**
	 * Finalize the current DSS chain and send it if
	 * needed.
	 */

	private void finalizeChain() throws DRDAProtocolException {

		writer.finalizeChain(reader.getCurrChainState(), getOutputStream());
		return;

	}

    /**
     * Obtain the current transaction timeout value set for this XAResource instance. If
     * <CODE>XAResource.setTransactionTimeout</CODE> was not use prior to invoking this method, the return value is the
     * default timeout set for the resource manager; otherwise, the value used in the previous
     * <CODE>setTransactionTimeout</CODE> call is returned.
     *
     * @return the transaction timeout value in seconds.
     *
     * @throws XAException An error has occurred. Possible exception values are XAER_RMERR, XAER_RMFAIL.
     */

    public int getTransactionTimeout() throws XAException {
        if (conn_.agent_.loggingEnabled()) {
            conn_.agent_.logWriter_.traceEntry(this, "getTransactionTimeout");
        }
        exceptionsOnXA = null;
        if (conn_.isPhysicalConnClosed()) {
            connectionClosedFailure();
        }

        if (conn_.agent_.loggingEnabled()) {
            conn_.agent_.logWriter_.traceExit(this, "getTransactionTimeout", 0);
        }
        return 0; // we don't support transaction timeout
    }

    /**
     * <P>Set the current transaction timeout value for this <CODE>XAResource</CODE> instance. This value overwrites the
     * default transaction timeout value in the resource manager. The newly assigned timeout value is effective for the
     * life of this <CODE>XAResource</CODE> instance unless a new value is set.<P>
     *
     * @param the transaction timeout value in seconds.
     *
     * @throws XAException An error has occurred. Possible exception values are XAER_RMERR, XAER_RMFAIL, or XAER_INVAL.
     */

    public boolean setTransactionTimeout(int seconds) throws XAException {
        if (conn_.agent_.loggingEnabled()) {
            conn_.agent_.logWriter_.traceExit(this, "setTransactionTimeout", false);
        }
        exceptionsOnXA = null;
        return false; // we don't support transaction timeout in our layer.
        /* int rc = xaSetTransTimeOut(seconds);
           if (rc != XAResource.XA_OK)
             throwXAException(rc); */
    }

    /**
     * What's a column's table's catalog name?
     *
     * @param column the first column is 1, the second is 2, ...
     *
     * @return column name or "" if not applicable.
     *
     * @throws SQLException thrown on failure
     */

    public String getCatalogName(int column) throws SqlException {
        checkForClosedStatement();
        checkForValidColumnIndex(column);
        return "";
    }

    /**
     * Store the Packagename and consistency token information This is called from Section.setPKGNAMCBytes
     *
     * @param b                    bytearray that has the PKGNAMC information to be stored
     * @param resultSetHoldability depending on the holdability store it in the correct byte array packagename and
     *                             consistency token information for when holdability is set to HOLD_CURSORS_OVER_COMMIT
     *                             is stored in holdPKGNAMCBytes and in noHoldPKGNAMCBytes when holdability is set to
     *                             CLOSE_CURSORS_AT_COMMIT
     */

    public void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {
        if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
            agent_.sectionManager_.holdPKGNAMCBytes = b;
        } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {
            agent_.sectionManager_.noHoldPKGNAMCBytes = b;
        }
    }

   /**
    * 	Return true if the physical connection is still open.
    * 	Might be logically closed but available for reuse.
    *   @return true if physical connection still open
    */

    public boolean isPhysicalConnClosed() {
    return !open_ && !availableForReuse_; 
   }

    /**
     * Store the Packagename and consistency token information for reuse. Case 1: if it is generated section, just store
     * the byte array in PKGNAMCBytes Case 2: for not a generated section, information is stored in the correct byte
     * array depending on the holdability in SectionManager
     */

    public void setPKGNAMCBytes(byte[] b) {
        if (isGenerated) {
            PKGNAMCBytes = b;
        } else {
            agent_.sectionManager_.setPKGNAMCBytes(b, resultSetHoldability_);
        }
    }

    /**
     * Performs the privileged action of System.getProperties()
     */

    public Object run() {
        this.systemProperties_ = System.getProperties();
        return this.systemProperties_;
    }

    /**
     * Attempt to establish a database connection in a non-pooling, non-distributed environment.
     *
     * @return a Connection to the database
     *
     * @throws java.sql.SQLException if a database-access error occurs.
     */

    public Connection getConnection() throws SQLException {
        return getConnection(user, password);
    }

    /**
     * Attempt to establish a database connection in a non-pooling, non-distributed environment.
     *
     * @param user     the database user on whose behalf the Connection is being made
     * @param password the user's password
     *
     * @return a Connection to the database
     *
     * @throws java.sql.SQLException if a database-access error occurs.
     */

    public Connection getConnection(String user, String password) throws SQLException {
        // Jdbc 2 connections will write driver trace info on a
        // datasource-wide basis using the jdbc 2 data source log writer.
        // This log writer may be narrowed to the connection-level
        // This log writer will be passed to the agent constructor.

        LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection("_sds");
        updateDataSourceValues(tokenizeAttributes(connectionAttributes, null));
        return new NetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false);
    }

	/**
		Run once per-iteration to run the actual test.
		@exception T_Fail the test failed in some way.
	*/

	protected void runTestSet() throws T_Fail {

		// Set up the expected error handling
		try {
			
			S001();
			S002();
			S003();
			S004();
			S005();
			S007();
			S008();

			M001();
			M002();
			M003();
			M004();
			

		} catch (StandardException se) {

			throw T_Fail.exceptionFail(se);

		}
	}

	/**
		Put the object into the No Identity state. 

		<BR> MT - single thread required - Method must only be called be cache manager
		and the cache manager will guarantee only one thread can be calling it.

	*/

	public void clearIdentity() {
		keyValue = null;
	}

	/**
		Get the identity of this object.

		<BR> MT - thread safe.

	*/

	public Object getIdentity() {
		return keyValue;
	}

	/** 
		Qualififier is assumed to be null.
	@see Lockable#lockEvent
	*/

	public void lockEvent(Latch lockInfo) {
        if (SanityManager.DEBUG)
            SanityManager.ASSERT(lockInfo.getQualifier() == null);

		latch = lockInfo;

		count++;
	}

	/** 
		Qualififier is assumed to be null.
	@see Lockable#unlockEvent
	*/

	public void unlockEvent(Latch lockInfo) {
        if (SanityManager.DEBUG)
            SanityManager.ASSERT(lockInfo.getQualifier() == null);
		
		count--;
        if (SanityManager.DEBUG)
            SanityManager.ASSERT(count >= 0);
		latch = null;
	}

	/**
		Returns true of the object is dirty. Will only be called when the object is unkept.

		<BR> MT - thread safe 

	*/

	public boolean isDirty() {
		synchronized (this) {
			return isDirty;
		}
	}

	/**
	  Get the name of the protocol for the module to test.
	  This is the 'factory.MODULE' variable.
	  
	  'moduleName' to the name of the module to test. 

	  @param testConfiguration the configuration for this test.
	  */

	protected String getModuleToTestProtocolName() {
		return org.apache.derby.iapi.reference.Module.CacheFactory;
	}

	/**
		A call to findCached() that is expected to return nothing.
		@exception StandardException  Standard Derby Error policy
		@exception T_Fail Something was found.
	*/

	protected void t_findCachedFail(CacheManager cm, Object key) throws StandardException, T_Fail {
		Cacheable entry = cm.findCached(key);
		if (entry != null) {
			throw T_Fail.testFailMsg("found cached item unexpectedly");
		}
	}

	/**
		A call to findCached() that is expected to find something.
		@exception StandardException  Standard Derby Error policy
		@exception T_Fail Nothing was found.
	*/

	protected Cacheable t_findCachedSucceed(CacheManager cm, Object key) throws StandardException, T_Fail {
		Cacheable entry = cm.findCached(key);
		if (entry == null) {
			throw T_Fail.testFailMsg("expected item to be in cache");
		}

		if (!entry.getIdentity().equals(key))
			throw T_Fail.testFailMsg("item returned does not match key");
		return entry;
	}

	/**
		A call to find() that is expected to return nothing.

		@exception T_Fail Something was found.
		@exception StandardException  Standard Derby Error policy
	*/

	protected void t_findFail(CacheManager cm, Object key) throws T_Fail, StandardException {
		Cacheable entry = cm.find(key);
		if (entry != null) {
			throw T_Fail.testFailMsg("found item unexpectedly");
		}
	}

	/**
		A call to findCached() that is expected to find something.

		@exception T_Fail Nothing was found.
		@exception StandardException  Standard Derby Error policy
	*/

	protected Cacheable t_findSucceed(CacheManager cm, Object key) throws T_Fail, StandardException {
		Cacheable entry = cm.find(key);
		if (entry == null) {
			throw T_Fail.testFailMsg("expected item to be found");
		}
		if (!entry.getIdentity().equals(key))
			throw T_Fail.testFailMsg("item returned does not match key");

		return entry;
	}

	/**
	  Emit a message indicating why the test failed.

	  RESOLVE: Should this be localized?

	  @param msg the message.
	  @return false
	*/

	protected boolean FAIL(String msg) {
		out.println("[" + Thread.currentThread().getName() + "] FAIL - " + msg);
		return false;
	}

	/**
	  Emit a message saying the test passed.
	  You may use this to emit messages indicating individual test cases
	  within a unit test passed.

	  <P>RESOLVE:Localize this.
	  @param test the test which passed.
	  @return true
	  */

	protected boolean PASS(String testName) {
		out.println("[" + Thread.currentThread().getName() + "] Pass - "+shortModuleToTestName +" " + testName);
		return true;
	}

	/**
		Emit a message during a unit test run, indent the message
		to allow the PASS/FAIL messages to stand out.
	*/

	public void REPORT(String msg) {
		out.println("[" + Thread.currentThread().getName() + "]     " + msg);
	}

	/**
	 * T_MultiThreadedIteration method
	 *
	 * @exception T_Fail Unexpected behaviour from the API
	 */

	protected void joinSetupTest() throws T_Fail {

		T_Fail.T_ASSERT(factory != null, "raw store factory not setup ");
		T_Fail.T_ASSERT(contextService != null, "Context service not setup ");
		T_Fail.T_ASSERT(commonContainer != -1, "common container not setup ");

		t_util = new T_Util(factory, lf, contextService);

	}

	/**
		Get the last page in a container.
		Always returns a valid page or null if there is no page in the container.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	public Page t_getLastPage(ContainerHandle c) throws T_Fail, StandardException {

		Page page = c.getFirstPage();
		if (page != null)
		{
			Page nextPage;
			while((nextPage = c.getNextPage(page.getPageNumber())) != null)
			{
				page.unlatch();
				page = nextPage;
			}
		}

		return page;
	}

	/**
		Get a specific page in a container.
		Always returns a valid page.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	public Page t_getPage(ContainerHandle c, long pageNumber) throws T_Fail, StandardException {

		Page page = c.getPage(pageNumber);
		if (page == null)
			throw T_Fail.testFailMsg("fail to get page " + pageNumber + " from container " + c);

		if (page.getPageNumber() != pageNumber)
			throw T_Fail.testFailMsg("page expected to have page number " +
				pageNumber + ", has " + page.getPageNumber() + " Container " + c);

		return page;
	}

	/**
		Add a page to a container.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	public Page t_addPage(ContainerHandle c) throws T_Fail, StandardException {

		Page page = c.addPage();

		if (page == null)
			throw T_Fail.testFailMsg("addPage() returned null");

		return page;
	}

	/**
		Lazy people's random file generator:
		Generate a random file with specified name and file size

		@exception T_Fail Record handle returned is null.
	*/

	public void t_genRandomFile(String fileName, String mode, int size) throws T_Fail {

		RandomAccessFile iFile = null;
		try {
			iFile = new RandomAccessFile(fileName, mode);
			for (int i = 0; i < size; i++){
				byte b = (byte) (i & 0xff);
				b = (byte) (((b >= ' ') && (b <= '~')) ? b : ' ');
				iFile.write(b);
			}
			iFile.close();
		} catch (FileNotFoundException fnfe) {
			throw T_Fail.testFailMsg("cannot create new file");
		} catch (IOException ioe) {
			throw T_Fail.testFailMsg("io error, test failed");
		}

	}

	/**
	  getValidColumns describes the DataValueDescriptor[] returned by all calls
      to the getNextRowFromRowSource() call. 
	*/

	public FormatableBitSet getValidColumns() {
		return validColumns;
	} 

	/**
		needsRowLocation returns true iff this the row source expects the
		drainer of the row source to call rowLocation after getting a row from
		getNextRowFromRowSource.

		@return true iff this row source expects some row location to be
		returned 
		@see #rowLocation
	 */

	public boolean needsRowLocation() {
		return false;
	}

	/**
		rowLocation  is not implemented here
	 */

	public void rowLocation(RowLocation rl) {

		rl = null;
	}

	/**
	  run the test

	  @exception T_Fail Unexpected behaviour from the API
	*/

	protected void runTestSet() throws T_Fail {

		// get a utility helper

		ContextManager cm1 = contextService.newContextManager();
		contextService.setCurrentContextManager(cm1);

		try {

			runCostEstimationTests();
			runAllocationTests();

		} catch (StandardException se) {

			cm1.cleanupOnError(se);
			throw T_Fail.exceptionFail(se);
		}
		finally {

			contextService.resetCurrentContextManager(cm1);
		}
	}

	/**
	 * T_MultiThreadedIteration method
	 *
	 * @exception T_Fail Unexpected behaviour from the API
	 */

	protected void joinSetupTest() throws T_Fail {

		T_Fail.T_ASSERT(factory != null, "raw store factory not setup ");
		T_Fail.T_ASSERT(lf != null, "Lock factory not setup ");
		T_Fail.T_ASSERT(contextService != null, "Context service not setup ");

		testRollback = testRollbackProperty;

	}

	/**
		T000 - ensure a transaction starts out idle.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	protected void T000() throws T_Fail, StandardException {

		Transaction t1 = t_util.t_startTransaction();

		t1.close();


		t1 = t_util.t_startInternalTransaction();

		t1.close();

		t1 = t_util.t_startTransaction();
		Transaction ti = t_util.t_startInternalTransaction();

		ti.close();

		t1.close();

		PASS("T000");
	}

	/**
		T001 - start and commit an empty transaction.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	protected void T001() throws T_Fail, StandardException {

		Transaction t1 = t_util.t_startTransaction();

		t_util.t_commit(t1);

		t1.close();

		PASS("T001");
	}

	/**
		T002 - start and abort an empty transaction.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	protected void T002() throws T_Fail, StandardException {

		Transaction t1 = t_util.t_startTransaction();

		t_util.t_abort(t1);

		t1.close();

		PASS("T002");
	}

	/**
		T003 - start and commit an empty transaction and then ensure
		that the transaction remains open for another commit.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	protected void T003() throws T_Fail, StandardException {

		Transaction t1 = t_util.t_startTransaction();

		t_util.t_commit(t1);

		t_util.t_commit(t1);
		t_util.t_abort(t1);

		t1.close();

		PASS("T003");
	}

	/**
		T004 - start and abort an empty transaction and then ensure
		that the transaction remains open for a commit and another abort.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	protected void T004() throws T_Fail, StandardException {

		Transaction t1 = t_util.t_startTransaction();

		t_util.t_abort(t1);

		t_util.t_commit(t1);

		t_util.t_abort(t1);

		t1.close();

		PASS("T004");
	}

	/**
		C010 - Create a container within a transaction, commit and the re-open
		the container twice.

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation

	*/

	protected void C010(int segment) throws T_Fail, StandardException {

		Transaction t = t_util.t_startTransaction();

		long cid = t_util.t_addContainer(t, segment);

		t_util.t_commit(t);
	
		ContainerHandle c1, c2;

		c1 = t_util.t_openContainer(t, segment, cid, true);
		c1 = t_util.t_openContainer(t, segment, cid, true);
		t_util.t_dropContainer(t, segment, cid);	// cleanup


		t_util.t_commit(t);
		t.close();

		PASS("C010");

	}

	/**
		C011 - Create a container withina transaction, commit and the re-open
		the container in update and non-update mode.
		
		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation

	*/

	protected void C011() throws T_Fail, StandardException {

		Transaction t = t_util.t_startTransaction();

		long cid = t_util.t_addContainer(t, 0);

		t_util.t_commit(t);
	
		ContainerHandle c1, c2;

		c1 = t_util.t_openContainer(t, 0, cid, false);
		c1 = t_util.t_openContainer(t, 0, cid, true);

		t_util.t_dropContainer(t, 0, cid);	// cleanup

		t_util.t_commit(t);
		t.close();
		PASS("C011");

	}

	/**
		Create a statement with modified State.
	*/

	protected Statement createFloatStatementForStateChecking(Connection conn) throws SQLException {
		Statement s = internalCreateFloatStatementForStateChecking(conn);
		s.setCursorName("StokeNewington");
		s.setFetchDirection(ResultSet.FETCH_REVERSE);
		s.setFetchSize(444);
		s.setMaxFieldSize(713);
		s.setMaxRows(19);

		showStatementState("Create ", s);
		return s;
	}

      /**
	   *  Print the expected Exception's details if the SQLException SQLState
	   * matches the expected SQLState. Otherwise fail
	   *
	   * @param se  SQLException that was thrown by the test
	   * @param expectedSQLState  The SQLState that we expect. 
	   *
	   **/

	static private void expectedException (SQLException se, String expectedSQLState) {
           if( se.getSQLState() != null && (se.getSQLState().equals(expectedSQLState))) { 
                System.out.println("PASS -- expected exception");
                while (se != null) {
                    System.out.println("SQLSTATE("+se.getSQLState()+"): "+se.getMessage());
                    se = se.getNextException();
                }
            } else {
	        System.out.println("FAIL--Unexpected SQLException: " +
							   "SQLSTATE(" +se.getSQLState() + ")" +
							   se.getMessage());
	        se.printStackTrace(System.out);
	    }
	}

     /**
       * We are here because we got an exception when did not expect one.
       * Hence printing the message and stack trace here.
       **/

     static private void unexpectedSQLException(SQLException se) {
	 System.out.println("FAIL -- Unexpected Exception: "+ 
						"SQLSTATE(" +se.getSQLState() +")" +
						se.getMessage());
	 se.printStackTrace(System.out);
     }

	/**
	 * Dump the values in the received result set to output.
	 */

	protected void dumpRS(ResultSet rs) throws SQLException {
		dumpRS(IGNORE_PROC_ID, rs);
	}

	/**
	 * Create a connect based on the test arguments passed in.
	 */

	protected Connection createConnection(String[] args) throws Exception {

		Connection con;

		// use the ij utility to read the property file and
		// make the initial connection.
		ij.getPropertyArg(args);
		con = ij.startJBMS();
		//con.setAutoCommit(true); // make sure it is true
		con.setAutoCommit(false);

		return con;

	}

	/**
		Unlatch an  object.

		<BR>
		MT - thread safe

		@see LockFactory#unlatch
	*/

	public void unlatch(Latch heldLatch) {
		lockTable.unlock(heldLatch, 1);
	}

	/**	
		Set the potentially granted flag, returns true if the
		flag changed its state.

		MT - single thread required
	*/

	protected boolean setPotentiallyGranted() {
		if (!potentiallyGranted) {
			potentiallyGranted = true;
			return true;
		}
		return false;
	}

	/**	
		Clear the potentially granted flag.

		MT - single thread required
	*/

	protected void clearPotentiallyGranted() {
		potentiallyGranted = false;
	}

	/**
		We can return ourselves here because our identity
		is immutable and what we returned will not be accessed
		as a Lock, so the count cannot be changed.
	*/

	public Control shallowClone() {
		return this;
	}

	/**
		Unlock a group of objects. 

		<BR>
		MT - thread safe

		@param group handle of group that objects were locked with.
		If group is	null then this call is equivilent to unlockAll().

		@see LockFactory#unlockGroup
	*/

	public void unlockGroup(Object compatabilitySpace, Object group) {

		if (SanityManager.DEBUG) {
			if (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {
				D_LockControl.debugLock("Lock Unlock Group: ", compatabilitySpace, group);
			}
		}

		LockSpace ls = (LockSpace) get(compatabilitySpace);
		if (ls == null)
			return;

		ls.unlockGroup(lockTable, group);
	}

	/**
		Returns true if locks by anyone are blocking anyone else
	*/

	public boolean anyoneBlocked() {
		return lockTable.anyoneBlocked();
	}

	/**
		Return true if locks are held in this group and this space.

		<BR>
		MT - thread safe

		@param group handle of group that objects were locked with.

		@see LockFactory#areLocksHeld
	*/

	public boolean areLocksHeld(Object compatabilitySpace, Object group) {

		LockSpace ls = (LockSpace) get(compatabilitySpace);
		if (ls == null)
			return false;

		// there is a window where someone could remove the LockSpace from the 
        // spaces Hashtable, since we do not hold the spaces' monitor. This is 
        // Ok as the LockSpace will have no locks and this method will 
        // correctly return false.

		return ls.areLocksHeld(group);
	}

	/**
		Return true if locks are held in this space
		
		<BR>
		MT - thread safe

		@see LockFactory#areLocksHeld
	*/

	public boolean areLocksHeld(Object compatabilitySpace) {
		LockSpace ls = (LockSpace) get(compatabilitySpace);
		if (ls == null)
			return false;
		return !ls.isEmpty();
	}

	/**
		Clear a limit set by setLimit.
	*/

	public void clearLimit(Object compatabilitySpace, Object group) {
		LockSpace ls = (LockSpace) get(compatabilitySpace);
		if (ls == null)
			return;

		ls.clearLimit(group);
	}

	/**
		Return the first lock in the wait line, null if the
		line is empty.
	*/

	public ActiveLock firstWaiter() {
		if ((waiting == null) || waiting.isEmpty())
			return null;
		return (ActiveLock) waiting.get(0);
	}

	/**
		Return the lockable object controlled by me.
	*/

	public Lockable getLockable() {
		return ref;
	}

	/**
		Add the waiters of this lock into this Dictionary object.
		<BR>
		Each waiting thread gets two entries in the hashtable
		<OL>
		<LI>key=compatibility space - value=ActiveLock
		<LI>key=ActiveLock - value={LockControl for first waiter|ActiveLock of previosue waiter}
		</OL>
	*/

	public void addWaiters(Dictionary waiters) {
		
		if ((waiting == null) || waiting.isEmpty())
			return;

		Object previous = this;
		for (ListIterator li = waiting.listIterator(); li.hasNext(); ) {

			ActiveLock waitingLock = ((ActiveLock) li.next());

			Object waiter = waitingLock.getCompatabilitySpace();

			waiters.put(waiter, waitingLock);
			waiters.put(waitingLock, previous);
			previous = waitingLock;
		}
	}

	/**
	 * Remove and return the first lock request from a list of waiters.
	 *
	 * @param waiting	The list of waiters to pop from
	 * @param ls		The LockSet
	 *
	 * @return	The removed lock request
	 */

	private Object popFrontWaiter(List waiting, LockSet ls) {
		// Maintain count of waiters
		ls.oneLessWaiter();

		// Remove and return the first lock request
		return waiting.remove(0);
	}

    /**
     * cpArray helps built the output string (outputRow).
     * @param toCp the String to be copied into outputRow
     * @param start the start place
     * @param end the end place
     */

    private void cpArray( String toCp, int start, int end )
    {   // build a field in the output string
        int i = 0;
        int totalAllowWrite = end - start;

        if( toCp != null )
        {
            for( ; i < toCp.length() ; i++ )
            {
                if( (totalAllowWrite-i) == 0 )
                    break;

                outputRow[ i + start ] = toCp.charAt(i);
            }
        }
        for( ; i + start != end; i++ )
            outputRow[ i + start ] = ' ';

        outputRow[ end ] = SEPARATOR;
    }

	/**
		Notify the class manager that the classpath has been modified.

		@exception StandardException thrown on error
	*/

	public void notifyModifyClasspath(String classpath) throws StandardException {

		if (applicationLoader != null) {
			applicationLoader.modifyClasspath(classpath);
		}
	}

	/**
		Get a stream directly from a ZipFile.
		In this case we can safely return the stream directly.
		It's a new stream set up by the zip code to read just
		the contents of this entry.
	*/

	private InputStream getRawStream(ZipFile zip, String name) {

		try {
			ZipEntry ze = zip.getEntry(name);
			if (ze == null)
				return null;

			return zip.getInputStream(ze);
		} catch (IOException ioe) {
			return null;
		}
	}

	/**
		Get a stream from a zip file that is itself a stream.
		Here we need to get the size of the zip entry and
		put a limiting stream around it. Otherwise the
		caller would end up reading the entire zip file!
	*/

	private InputStream getRawStream(InputStream in, String name) { 

		ZipInputStream zipIn = null;
		try {
			zipIn = new ZipInputStream(in);

			ZipEntry ze;
			while ((ze = jf.getNextEntry(zipIn)) != null) {

				if (ze.getName().equals(name)) {
					LimitInputStream lis = new LimitInputStream(zipIn);
					lis.setLimit((int) ze.getSize());
					return lis;
				}
			}

			zipIn.close();

		} catch (IOException ioe) {
			if (zipIn != null) {
				try {
					zipIn.close();
				} catch (IOException ioe2) {
				}
			}
		}
		return null;
	}

	/**
		Make the stream; note that service properties override
		application and system properties.

	 */

	private HeaderPrintWriter makeStream() {

		// get the header
		PrintWriterGetHeader header = makeHeader();
		HeaderPrintWriter hpw = makeHPW(header);

		// If hpw == null then no properties were specified for the stream
		// so use/create the default stream.
		if (hpw == null)
			hpw = createDefaultStream(header);
		return hpw;
	}

	/**
		Return a new header object.
	*/

	private PrintWriterGetHeader makeHeader() {

		return new BasicGetLogHeader(true, true, (String) null);
	}

	/**
		create a HeaderPrintWriter based on the header.
		Will still need to determine the target type.
	 */

	private HeaderPrintWriter makeHPW(PrintWriterGetHeader header) {

		// the type of target is based on which property is used
		// to set it. choices are file, method, field, stream

		String target = PropertyUtil.
                   getSystemProperty(Property.ERRORLOG_FILE_PROPERTY);
		if (target!=null)
			return makeFileHPW(target, header);

		target = PropertyUtil.
                   getSystemProperty(Property.ERRORLOG_METHOD_PROPERTY);
		if (target!=null) 
			return makeMethodHPW(target, header);

		target = PropertyUtil.
                   getSystemProperty(Property.ERRORLOG_FIELD_PROPERTY);
		if (target!=null) 
			return makeFieldHPW(target, header);

		return null;
	}

	/**
		Used when no configuration information exists for a stream.
	*/

	private HeaderPrintWriter createDefaultStream(PrintWriterGetHeader header) {
		return makeFileHPW("derby.log", header);
	}

	/**
		Used when creating a stream creates an error.
	*/

	private HeaderPrintWriter useDefaultStream(PrintWriterGetHeader header) {

		return new BasicHeaderPrintWriter(System.err, header, false, "System.err");
	}

	/**
		Keep the cached object after a search.

	*/

	public void keepAfterSearch() {
		keepCount++;
		setUsed(true);
	}

	/**
		Get the cached object.
	*/

	public Cacheable getEntry() {
		return entry;
	}

	/**
		Clean all objects in the cache.
	*/

	public void cleanAll() throws StandardException {
		stat.cleanAll++;
		cleanCache((Matchable) null);
	}

	/**
		Clean all objects that match a partial key.
	*/

	public void clean(Matchable partialKey) throws StandardException {

		cleanCache(partialKey);
	}

	/**
		MT - synchronization provided by caller

		@exception StandardException Standard Cloudscape error policy.
	*/

	public void shutdown() throws StandardException {

		if (cleaner != null) {
			cleaner.unsubscribe(myClientNumber);
			cleaner = null;
		}

		synchronized (this) {
			active = false;
		}

		ageOut();
		cleanAll();
		ageOut();
	}

	/**	
		Put the key-value pair in the Properties set and
		mark this set as modified.

		@see Hashtable#put
	*/

	public Object put(Object key, Object value) {
		Object ref = defaults.put(key, value);
		if (!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX))
			update();
		return ref;
	}

	/**	
		Remove the key-value pair from the Properties set and
		mark this set as modified.

		@see Hashtable#remove
	*/

	public Object remove(Object key) {
		Object ref = defaults.remove(key);
		if ((ref != null) &&
			(!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX)))
			update();
		return ref;
	}

	/**
		Shut down a service that was started by this Monitor. Will
		cause the stop() method to be called on each loaded module.
	*/

	public void shutdown(Object serviceModule) {
		if (serviceModule == null)
			return;

		TopService ts = findTopService(serviceModule);
		if (ts == null)
			return;

		// shutdown() returns false if the service is already being shutdown
		boolean removeService = true;
		try {
			removeService = ts.shutdown();
		} finally {
			synchronized (this) {
				if (removeService) {
					boolean found = services.removeElement(ts);
					if (SanityManager.DEBUG) {
						SanityManager.ASSERT(found, "service was not found " + serviceModule);
					}
				}
			}
		}
	}

	/**
		Return the name of the service that the passed in module lives in.
	*/

	public String getServiceName(Object serviceModule) {

		TopService ts = findTopService(serviceModule);

		if (ts == null)
			return null;

		return ts.getServiceType().getUserServiceName(ts.getKey().getIdentifier());
	}

	/**
		Clear an item's identity. Item must be 
		unkept and valid. This is called for
		dirty items from the discard code.

		Caller must hold the cache synchronization.

        @return the amount by which this shrinks the cache.
	*/

	protected long removeIdentity(CachedItem item) {

        long shrink = 1;
        
		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(!item.isKept(), "item is kept");
			SanityManager.ASSERT(item.isValid(), "item is not valid");

		}

        if( useByteCount)
            shrink = ((SizedCacheable) item.getEntry()).getSize();
		remove(item.getEntry().getIdentity());				
		item.setValidState(false);
        validItemCount--;
		item.getEntry().clearIdentity();
        if( useByteCount)
        {
            shrink -= ((SizedCacheable) item.getEntry()).getSize();
            currentByteCount -= shrink;
        }
        return shrink;
	}

	/**
		Return the PersistentService object for a service.
		Will return null if the service does not exist.
	*/

	public PersistentService getServiceType(Object serviceModule) {
		TopService ts = findTopService(serviceModule);

		if (ts == null)
			return null;

		return ts.getServiceType();
	}

	/**
		Should only be called if reportOn is true
		apart from report/Exception().
	*/

	protected void report(String message)	{

		PrintWriter tpw = getTempWriter();

		if (tpw != null)
			tpw.println(message);

		if (systemStreams != null)
			systemStreams.stream().printlnWithHeader(message);
	}

	/**
		Boot all the service providers, ie. any module that implemented
		PersistentService. Upon entry to this call is the hashtable has
		PersistentService objects that have been created but not booted.
	*/

	protected void bootServiceProviders() {

		if (serviceProviders == null) {
			return;
		}

		for (Enumeration e = serviceProviders.keys(); e.hasMoreElements(); ) {

			String serviceType = (String) e.nextElement();
			Object provider = serviceProviders.get(serviceType);

			// see if this provider can live in this environment
			if (!BaseMonitor.canSupport(provider, (Properties) null)) {
				serviceProviders.remove(serviceType);
				continue;
			}
		}
	}

	/**
		Boot all persistent services that can be located at run time.

		<BR>
		This method enumerates through all the service providers that
		are active and calls bootPersistentServices(PersistentService)
		to boot all the services that that provider knows about.
	*/

	protected void bootPersistentServices() {
		for (Enumeration e = new ProviderEnumeration( applicationProperties); ; ) {

			PersistentService provider = (PersistentService) e.nextElement();
			bootProviderServices(provider);
		}

	}

	/** Get the current PC */

	public int getRelativePC() {
		return cout.size() - codeOffset;
	}

	/**
	 * add a field to this class. Fields cannot
	 * be initialized here, they must be initialized
	 * in the static initializer code (static fields)
	 * or in the constructors.
	 * <p>
	 * static fields also added to this list,
	 * with the modifier set appropriately.
	 */

	public LocalField addField(String javaType, String name, int modifiers) {

		Type type = factory.type(javaType);
		// put it into the class holder right away.
		ClassMember field = classHold.addMember(name, type.vmName(), modifiers);
		int cpi = classHold.addFieldReference(field);

		return new BCLocalField(type, cpi);
	}

	/**
	 * Return the logical name of the method. The current
	 * myEntry refers to the sub method we are currently
	 * overflowing to. Those sub-methods are hidden from any caller.
	 */

	public String getName() {
		return myName;
	}

	/**
	 * a throwable can be added to the end of
	 * the list of thrownExceptions.
	 */

	public void addThrownException(String exceptionClass) {
		
		// cannot add exceptions after code generation has started.
		// Allowing this would cause the method overflow/split to
		// break as the top-level method would not have the exception
		// added in the sub method.
		if (SanityManager.DEBUG)
		{
			if (myCode.getRelativePC() != 0)
				SanityManager.THROWASSERT("Adding exception after code generation " + exceptionClass
						+ " to method " + getName());
		}

		if (thrownExceptions == null)
			thrownExceptions = new Vector();
		thrownExceptions.addElement(exceptionClass);
	}

	/**
	 * when the method has had all of its parameters
	 * and thrown exceptions defined, and its statement
 	 * block has been completed, it can be completed and
	 * its class file information generated.
	 * <p>
	 * further alterations of the method will not be
	 * reflected in the code generated for it.
	 */

	public void complete() {
		// write exceptions attribute info
		writeExceptions();
		
		// get the code attribute to put itself into the class
		// provide the final header information needed
		myCode.complete(modClass, myEntry, maxStack, currentVarNum);
	}

	/**
	Return the UUID factory for this system.  Returns null
	if there isn't one.
	@see com.ibm.db2j.system.System
	*/

	public UUIDFactory getUUIDFactory()	{

		return uuidFactory;
	}

	/**
		Get the locale from the ContextManager and then find the bundle
		based upon that locale.
	*/

	public ResourceBundle getBundle(String messageId) {
		ContextManager cm;
		try {
			cm = ContextService.getFactory().getCurrentContextManager();
		} catch (ShutdownException se) {
			cm = null;
		}

		if (cm != null) {
			return MessageService.getBundleForLocale(cm.getMessageLocale(), messageId);
		}
		return null;
	}

	/**
		Push the contents of the described static field onto the stack.		
	*/

	public void getStaticField(String declaringClass, String fieldName, String fieldType) {
		getField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);
	}

	/**
	 * Set the field but don't duplicate its value so
	 * nothing is left on the stack after this call.
	 */

	public void setField(LocalField field) {
		BCLocalField lf = (BCLocalField) field;
		Type lt = lf.type;

		putField(lf.type, lf.cpi, false);

		if (stackDepth == 0)
			overflowMethodCheck();
	}

	/**
		Upon entry the top word(s) on the stack is
		the value to be put into the field. Ie.
		we have
		<PRE>
		word
		</PRE>

		Before the call we need 
		<PRE>
		word
		this
		word
		</PRE>
		word2,word1 -> word2, word1, word2

		So that we are left with word after the put.

	*/

	public void putField(LocalField field) {
		BCLocalField lf = (BCLocalField) field;
		Type lt = lf.type;

		putField(lf.type, lf.cpi, true);
	}

	/**
		Start this module. We need a read/write version of the class utilities

		@exception StandardException standard cloudscape policy
	 */

	public void boot(boolean create, Properties properties) throws StandardException {

		CacheFactory cf =
			(CacheFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);

		/*
		** The initial and maximum cache sizes are based on experiments
		** that I did with some of the language tests.  I found that
		** the size quickly grew to about 40, then continued to grow
		** slowly after that.
		**
		**			-	Jeff
		*/
		vmTypeIdCache =
			cf.newCacheManager(
				this,
				"VMTypeIdCache",
				64,
				256);
	}

	/**
		Stop this module.  In this case, nothing needs to be done.
	 */

	public void stop() {
	}

	/**
		Open a temp table several times with different modes and ensure the
		correct behaviour (most severe open wins).

		@exception T_Fail Unexpected behaviour from the API
		@exception StandardException Unexpected exception from the implementation
	*/

	protected void TC004all() throws StandardException, T_Fail {
		int[] modes = {
			0,
			ContainerHandle.MODE_DROP_ON_COMMIT,
			ContainerHandle.MODE_TRUNCATE_ON_COMMIT
		};

		for (int m1 = 0; m1 < modes.length; m1++) {
			for (int m2 = 0; m2 < modes.length; m2++) {
				for (int m3 = 0; m3 < modes.length; m3++) {

					TC004(m1, m2, m3, false, false);
					TC004(m1, m2, m3, false, true);
					TC004(m1, m2, m3, true, false);
					TC004(m1, m2, m3, true, false);
				}
			}

		}
	}

  /** Gets the resultset meta data
 	* @exception	SQLException if there is an error
	*/

  public ResultSetMetaData getMetaData() {
    return importResultSetMetaData;
  }

  /** gets the next row
 	* @exception	SQLException if there is an error
	*/

  public int getRow() throws SQLException {
    return (importReadData.getCurrentRowNumber());
  }

  /** closes the resultset
 	* @exception	SQLException if there is an error
	*/

  public void close() throws SQLException {
    try {
		if(importReadData!=null)
			importReadData.closeStream();
    } catch (Exception ex) {
		throw LoadError.unexpectedError(ex);
    }
  }

	/** virtual method from the abstract class
	 * @exception	Exception on error
	 */

	protected ImportReadData getImportReadData() throws Exception {
		return new ImportReadData(inputFileName, controlFileReader);
	}

  /**if columndefinition is true, ignore first row. The way to do that is to just
  *  look for the record separator
 	* @exception	Exception if there is an error
	*/

  protected void ignoreFirstRow() throws Exception {
    readNextToken(recordSeparator, 0, recordSeparatorLength, true);
  }

  /**close the input data file
 	* @exception	Exception if there is an error
	*/

  public void closeStream() throws Exception {
    if (streamOpenForReading) {
       bufferedReader.close();
       streamOpenForReading = false;
    }
  }

  /**returns the number of the current row
  */

  public int getCurrentRowNumber() {
    return lineNumber;
  }

	/**
	 * position is 1-based.
	 * @see ResultDescription#getColumnDescriptor
	 */

	public ResultColumnDescriptor getColumnDescriptor(int position) {
		return columns[position-1];
	}

	/**
		Is the database active (open).
	*/

	public boolean isActive() {
		return active;
	}

	/**
	 * Get the formatID which corresponds to this class.
	   Map to the 5.0 version identifier so that 5.0 will understand
	   this object when we write it out in soft upgrade mode.
	   CS 5.0 will de-serialize it correctly.
	   When we are writing out a 5.1 version number we write out
	   the 5.1 version just to ensure no problems.
	   
	 *
	 *	@return	the formatID of this class
	 */

	public	int	getTypeFormatId()	{
		return majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?
			StoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;
	}

	/**
	 * Return the savepoint level when the table was dropped
	 */

	public void setDroppedInSavepointLevel(int droppededInSavepointLevel) {
    this.droppededInSavepointLevel = droppededInSavepointLevel;
  }

	/**
	 * Get the PreparedStatement that is associated with this Cacheable
	 */

	public GenericPreparedStatement getPreparedStatement() {
		return ps;
	}

	/**
	 * Resets the savepoint to the current spot if it is
	 * set, otherwise, noop.  Used when a commit is
	 * done on a nested connection.
	 *
	 * @see StatementContext#resetSavePoint
	 * @exception StandardException Thrown on error
	 */

	public void resetSavePoint() throws StandardException {
		if (SanityManager.DEBUG)
		{
			if (SanityManager.DEBUG_ON("traceSavepoints"))
			{
				SanityManager.DEBUG_PRINT(
					"GenericStatementContext.resetSavePoint()",
					internalSavePointName);
			}
		}
			
		if (inUse && setSavePoint)
		{		
			// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller
			if ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }
			// stage buffer management
		}
	}

	/**
	 * Indicate that, in the event of a statement-level exception,
	 * this context is NOT the last one that needs to be rolled
	 * back--rather, it is nested within some other statement
	 * context, and that other context needs to be rolled back,
	 * too.
	*/

	public void setParentRollback() {
		rollbackParentContext = true;
	}

	/**
		Set to indicate statement is system code.
		For example a system procedure, view, function etc.
	*/

	public void setSystemCode() {
		isSystemCode = true;
	}

	/**
		Return true if this statement is system code.
	*/

	public boolean getSystemCode() {
		return isSystemCode;
	}

	/**
		Get the ExecutionFactory to use with this language connection
	 */

	public ExecutionFactory	getExecutionFactory() {
		return ef;
	}

	/**
		Get the OptimizerFactory to use with this language connection
	 */

	public OptimizerFactory	getOptimizerFactory() {
		return of;
	}

	/**
		Get the TypeCompilerFactory to use with this language connection
	 */

	public TypeCompilerFactory getTypeCompilerFactory() {
		return tcf;
	}

	/**
		Get the DataValueFactory to use with this language connection
	 */

	public DataValueFactory		getDataValueFactory() {
		return dvf;
	}

	/**
		this implementation will not support caching of statements.
	 */

	public boolean canSupport(Properties startParams) {

		return Monitor.isDesiredType( startParams, EngineType.STANDALONE_DB);
	}

	/**
	 * Start-up method for this instance of the language factory.
	 * This service is expected to be started and accessed relative 
	 * to a database.
	 *
	 * @param startParams	The start-up parameters (ignored in this case)

       @exception StandardException Thrown if module cannot be booted.
	 *
	 */

	public void boot(boolean create, Properties startParams) throws StandardException 
	{		
		LanguageConnectionFactory lcf = (LanguageConnectionFactory)  Monitor.findServiceModule(this, LanguageConnectionFactory.MODULE);
		PropertyFactory pf = lcf.getPropertyFactory();
		if (pf != null)
			pf.addPropertySetNotification(new LanguageDbPropertySetter());

		emptySet = new GenericParameterValueSet(null, 0, false);
	}

	/**
	 * Add the activation to those known about by this connection.
	 */

	public void addActivation(Activation a) {
		acts.addElement(a);

		if (SanityManager.DEBUG) {

			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {

				if (acts.size() > 20)
					System.out.println("memoryLeakTrace:GenericLanguageContext:activations " + acts.size());
			}
		}
	}

	/**
	 * removes a dependency for a given provider. assumes
	 * that the dependent removal is being dealt with elsewhere.
	 * Won't assume that the dependent only appears once in the list.
	 */

	protected void clearProviderDependency(UUID p, Dependency d) {
		List deps = (List) providers.get(p);

		if (deps == null)
			return;

		deps.remove(d);

		if (deps.size() == 0)
			providers.remove(p);
	}

	/**
		return the provider's key for this dependency.
		@return the provider' key for this dependency
	 */

	public UUID getProviderKey() {
		return provider.getObjectID();
	}

	/**
		return the provider for this dependency.
		@return the provider for this dependency
	 */

	public Provider getProvider() {
		return provider;
	}

	/**
		return the dependent for this dependency.
		@return the dependent for this dependency
	 */

	public Dependent getDependent() {
		return dependent;
	}

	/**
		Check that there are not output parameters defined
		by the parameter set. If there are unknown parameter
		types they are forced to input types. i.e. Cloudscape static method
		calls with parameters that are array.

		@return true if a declared Java Procedure INOUT or OUT parameter is in the set, false otherwise.
	*/

	public boolean checkNoDeclaredOutputParameters() {

		boolean hasDeclaredOutputParameter = false;
		for (int i=0; i<parms.length; i++) {

			GenericParameter gp = parms[i];

			switch (gp.parameterMode) {
			case JDBC30Translation.PARAMETER_MODE_IN:
				break;
			case JDBC30Translation.PARAMETER_MODE_IN_OUT:
			case JDBC30Translation.PARAMETER_MODE_OUT:
				hasDeclaredOutputParameter = true;
				break;
			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
				gp.parameterMode = JDBC30Translation.PARAMETER_MODE_IN;
				break;
			}
		}
		return hasDeclaredOutputParameter;
	}

	/**
		Get a column from the list
	
		@param position	The column to get from the list
	 */

	public OrderByColumn getOrderByColumn(int position) {
		if (SanityManager.DEBUG)
		SanityManager.ASSERT(position >=0 && position < size());
		return (OrderByColumn) elementAt(position);
	}

	/**
		Print the list.
	
		@param depth		The depth at which to indent the sub-nodes
	 */

	public void printSubNodes(int depth) {

		if (SanityManager.DEBUG) 
		{
			for (int index = 0; index < size(); index++)
			{
				( (OrderByColumn) (elementAt(index)) ).treePrint(depth);
			}
		}
	}

	/**
	 * Return the number of activations known for this connection.
	 * Note that some of these activations may not be in use
	 * (when a prepared statement is finalized, its activations
	 * are marked as unused and later closed and removed on
	 * the next commit/rollback).
	 */

	public int getActivationCount() {
		return acts.size();
	}

	/**
	 * See if a given cursor is available for use.
	 * if so return its activation. Returns null if not found.
	 * For use in execution.
	 *
	 * @return the activation for the given cursor, null
	 *	if none was found.
	 */

	public CursorActivation lookupCursorActivation(String cursorName) {

		int size = acts.size();
		if (size > 0)
		{
			for (int i = 0; i < size; i++) {
				 Activation a = (Activation) acts.elementAt(i);

				 if (!a.isInUse())
				 {
					continue;
				 }



				String executingCursorName = a.getCursorName();

				 if (cursorName.equals(executingCursorName)) {

					ResultSet rs = a.getResultSet();
					if (rs == null)
						continue;

					 // if the result set is closed, the the cursor doesn't exist
					 if (rs.isClosed()) {					
						continue;
					 }

				 	return (CursorActivation)a;
				 }
			}
		}
		return null;
	}

	/**
	 * null operators are defined on DataValueDescriptor.
	 * Overrides method in UnaryOperatorNode for code generation purposes.
	 */

	public String getReceiverInterfaceName() {
	    return ClassName.DataValueDescriptor;
	}

 /** Get the data value factory to use with this language connection
		context.
	 */

	public DataValueFactory getDataValueFactory() {
		return dataFactory;
	}

	/**
		Get the language factory to use with this language connection
		context.
	 */

	public LanguageFactory getLanguageFactory() {
		return langFactory;
	}

	/**
		Get the language connection factory to use with this language connection
		context.
	 */

	public LanguageConnectionFactory getLanguageConnectionFactory() {
		return connFactory;
	}

	/**
		Empty as much of the cache as possible. It is not guaranteed
		that the cache is empty after this call, as statements may be kept
		by currently executing queries, activations that are about to be garbage
		collected.
	*/

	public void emptyCache() {
		/* We know prepared statements don't become dirty
		** statementCache.cleanAll(); 
		*/
		if (statementCache != null)
			statementCache.ageOut(); 
	}

    /**
	  *	Reports how many statement levels deep we are.
	  *
	  *	@return	a statement level >= OUTERMOST_STATEMENT
	  */

	public	int		getStatementDepth()
	{ return statementDepth; }

	/**
		Finish the data dictionary transaction, if any.

		@exception StandardException	Thrown on error
	 */

	private void finishDDTransaction() throws StandardException {

		/* Was the data dictionary put into write mode? */
		if (ddWriteMode) {
			DataDictionary dd = getDataDictionary();

			/* Tell the data dictionary that the transaction is finished */
			dd.transactionFinished();

			/* The data dictionary isn't in write mode any more */
			ddWriteMode = false;
		}
	}

	/**
	 * Convert this object to a String.  See comments in QueryTreeNode.java
	 * for how this should be done for tree printing.
	 *
	 * @return	This object as a String
	 */

	public String toString() {
		if (SanityManager.DEBUG) {
			return expression.toString();
		} else {
			return "";
		}
	}

	/**
	 * Mark the column as descending order
	 */

	public void setDescending() {
		ascending = false;
	}

	/**
	 * Get the column order.  Overrides 
	 * OrderedColumn.isAscending.
	 *
	 * @return true if ascending, false if descending
	 */

	public boolean isAscending() {
		return ascending;
	}

	/**
	 * This is a length operator node.  Overrides this method
	 * in UnaryOperatorNode for code generation purposes.
	 */

	public String getReceiverInterfaceName() {
	    return ClassName.ConcatableDataValue;
	}

	/**
	 * Determine the type the binary method is called on.
	 * By default, based on the receiver.
	 *
	 * Override in nodes that use methods on super-interfaces of
	 * the receiver's interface, such as comparisons.
	 *
	 * @exception StandardException		Thrown on error
	 */

	public String getReceiverInterfaceName() throws StandardException {
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(receiver!=null,"can't get receiver interface name until receiver is set");
		}

		return receiver.getTypeCompiler().interfaceName();
	}

	/**
	 * Initializer for a ExtractOperatorNode
	 *
	 * @param field		The field to extract
	 * @param operand	The operand
	 */

	public void init(Object field, Object operand) {
		extractField = ((Integer) field).intValue();
		super.init( operand,
					"EXTRACT "+fieldName[extractField],
					fieldMethod[extractField] );
	}

	/**
	  *	Get the package name that this generated class lives in
	  *
	  *	@return	package name
	  */

    public	String	getPackageName()
	{	return	CodeGeneration.GENERATED_PACKAGE_PREFIX; }

	/**
		The base class for activations is BaseActivation
	 */

	public String getBaseClassName() {
	    return ClassName.BaseActivation;
	}

	/**
	 * This is a length operator node.  Overrides this method
	 * in UnaryOperatorNode for code generation purposes.
	 */

	public String getReceiverInterfaceName() {
	    return ClassName.StringDataValue;
	}

	/**
	 * Return the length
	 *
	 * @return	The length of the value this node represents
	 *
	 * @exception StandardException		Thrown on error
	 */

	//public int	getLength() throws StandardException {
	//	return TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;
	//}

	/**
	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
	 * how tree printing is supposed to work.
	 *
	 * @param depth		The depth of this node in the tree
	 */

	public void printSubNodes(int depth) {
		if (SanityManager.DEBUG) {
			super.printSubNodes(depth);

			printLabel(depth, "cursor: ");
		}
	}

	/**
	 * Convert this object to a String.  See comments in QueryTreeNode.java
	 * for how this should be done for tree printing.
	 *
	 * @return	This object as a String
	 */

	public String toString() {
		if (SanityManager.DEBUG) {
			return "preparedStatement: " +
		    	(preStmt == null? "no prepared statement yet\n" :
			 	preStmt.toString() + "\n")+
				cursorName + "\n" +
				super.toString();
		} else {
			return "";
		}
	}

	/**
		Check to see if a database has been upgraded to the required
		level in order to use a language feature. 

		@param majorVersion Data Dictionary major version
		@param feature Non-null to throw an error, null to return the state of the version match.

		@return True if the database has been upgraded to the required level, false otherwise.
	*/

	public boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {

		if (requiredMajorVersion == DataDictionary.DD_VERSION_CURRENT) {
			requiredMajorVersion = softwareVersion.majorVersionNumber;
		}

		return dictionaryVersion.checkVersion(requiredMajorVersion, feature);
	}

	/**
	 * Determine the type the binary method is called on.
	 * By default, based on the receiver.
	 *
	 * Override in nodes that use methods on super-interfaces of
	 * the receiver's interface, such as comparisons.
	 *
	 * @exception StandardException		Thrown on error
	 */

	public String getReceiverInterfaceName() throws StandardException {
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(operand!=null,
								"cannot get interface without operand");
		}

		if (operatorType != -1)
			return receiverInterfaceType;
		
		return operand.getTypeCompiler().interfaceName();
	}

	/**
	 * The execute method returns a result set that will evaluate the
	 * statement this activation class is the compiled form of.
	 * REVISIT: do we need to give the caller the ability to touch it
	 * directly, or could we wrap the alterations to it in this class?
	 */

	public MethodBuilder getExecuteMethod() {
		return executeMethod;
	}

	/**
	 * Activations might have need of internal functions
	 * that are not used by the result sets, but by other
	 * activation functions. Thus, we make it possible
	 * for functions to be generated directly as well
	 * as through the newExprFun interface.  newExprFun
	 * should be used when a static field pointing to the
	 * expression function is needed.
	 * <p>
	 * The generated function will generally have a generated name
	 * that can be viewed through the MethodBuilder interface.
	 * This name is generated to ensure uniqueness from other
	 * function names in the activation class. If you pass in a function
	 * name, think carefully about whether it will collide with other names.
	 *
	 * @param exprName	Name of function. Usually null, which causes us to
	 *					generate a unique name.
	 * @param returnType the return type of the function
	 * @param modifiers the modifiers on the function
	 *
	 * @see #newExprFun
	 */

	public MethodBuilder newGeneratedFun(String returnType, int modifiers) {

		return newGeneratedFun(returnType, modifiers,
							   (String[]) null);
	}

	/**
		Push an expression that is a GeneratedMethod reference to the
		passed in method. aka. a "function pointer".
	*/

	public void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {

		mb.pushThis(); // instance
		mb.push(exprMethod.getName()); // arg
		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,
				"getMethod",
				ClassName.GeneratedMethod,
				1
				);
	}

	/**
	 * Start a user expression.  The difference between a normal expression
	 * (returned by newExprFun)
	 * and a user expression is that a user expression catches all exceptions
	 * (because we don't want random exceptions thrown from user methods to
	 * propagate to the rest of the system.
	 *
	 * @param functionName	Name to give to the function. If null, we'll generate a
	 *						unique name.
	 * @param returnType	A String telling the return type from the expression
	 *
	 * @return	A new MethodBuilder
	 */

	public MethodBuilder newUserExprFun() {

		MethodBuilder mb = newExprFun();
		mb.addThrownException("java.lang.Exception");
		return mb;
	}

	/**
		This utility method returns an expression for CURRENT_DATE.
		Get the expression this way, because the activation needs to 
		generate support information for CURRENT_DATE,
		that would otherwise be painful to create manually.
	 */

	public void getCurrentDateExpression(MethodBuilder mb) {
		// do any needed setup
		LocalField lf = getCurrentSetup();

		// generated Java:
		//	  this.cdt.getCurrentDate();
		mb.getField(lf);
		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentDate", "java.sql.Date", 0);
	}

	/**
		This utility method returns an expression for CURRENT_TIME.
		Get the expression this way, because the activation needs to 
		generate support information for CURRENT_TIME,
		that would otherwise be painful to create manually.
	 */

	public void getCurrentTimeExpression(MethodBuilder mb) {
		// do any needed setup
		LocalField lf = getCurrentSetup();

		// generated Java:
		//	  this.cdt.getCurrentTime();
		mb.getField(lf);
		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, "getCurrentTime", "java.sql.Time", 0);
	}

	/**
		This utility method generates an expression for CURRENT_TIMESTAMP.
		Get the expression this way, because the activation needs to 
		generate support information for CURRENT_TIMESTAMP,
		that would otherwise be painful to create manually.
	 */

	public void getCurrentTimestampExpression(MethodBuilder mb) {
		// do any needed setup
		LocalField lf = getCurrentSetup();

		// generated Java:
		//	  this.cdt.getCurrentTimestamp();
		mb.getField(lf);
		mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,
			"getCurrentTimestamp", "java.sql.Timestamp", 0);
	}

	/**
		This utility method returns the resultSetClosed method reference that the
		activation wants called when a result set closes, to let it clean up.
		This will be null if none was needed.

		REMIND: because ObjectManager returns exceptions on its invoke() method
		and close() is not supposed to return exceptions, we may want to
		move this to be something done on open() instead of on close().
		Otherwise, we have to do try/catch/THROWASSERT in the close code,
		which looks unfriendly.
	 */

	public void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {
		if (resultSetClosedMethod != null)
			pushMethodReference(mb, resultSetClosedMethod);
		else
			mb.pushNull(ClassName.GeneratedMethod);
	}

	/**
	 * Generate a reference to the row array that
	 * all activations use.
	 * 
	 * @param eb the expression block
	 *
	 * @return expression
	 */

	//private void pushRowArrayReference(MethodBuilder mb)
	//{ 		
		// PUSHCOMPILE - cache
	//	mb.pushThis();
	//	mb.getField(ClassName.BaseActivation, "row", ClassName.ExecRow + "[]");
	//}

	/**
	 * Take the generated class, and turn it into an
	 * actual class.
	 * <p> This method assumes, does not check, that
	 * the class and its parts are all complete.
 	 *
	 * @param savedBytes place to save generated bytes.
	 *	if null, it is ignored
	 * @exception StandardException thrown when exception occurs
	 */

	public GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {
		if (gc != null) return gc;

		if (savedBytes != null)
		{
			ByteArray classBytecode = cb.getClassBytecode();

			// note: be sure to set the length since
			// the class builder allocates the byte array
			// in big chunks
			savedBytes.setBytes(classBytecode.getArray());
			savedBytes.setLength(classBytecode.getLength());
		}

	    gc =  cb.getGeneratedClass();

		return gc; // !! yippee !! here it is...
	}

	/**
	 * Get a "this" expression declared as an Activation.
	 * This is the commonly used type of the this expression.
	 *
	 */

	public void pushThisAsActivation(MethodBuilder mb) {
		// PUSHCOMPILER - WASCACHED
		mb.pushThis();
		mb.upCast(ClassName.Activation);
	}

	/**
		Generate a Null data value.
		Nothing is required on the stack, a SQL null data value
		is pushed.
	*/

	public void generateNull(MethodBuilder mb, TypeCompiler tc) {
		pushDataValueFactory(mb);
		mb.pushNull(tc.interfaceName());
		tc.generateNull(mb);
	}

	/**
		Generate a Null data value.
		The express value is required on the stack and will be popped, a SQL null data value
		is pushed.
	*/

	public void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {
		pushDataValueFactory(mb);
		mb.swap(); // need the dvf as the instance
		mb.cast(tc.interfaceName());
		tc.generateNull(mb);
	}

	/**
		Generate a data value.
		The value is to be set in the SQL data value is required
		on the stack and will be popped, a SQL data value
		is pushed.
	*/

	public void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {
		pushDataValueFactory(mb);
		mb.swap(); // need the dvf as the instance
		tc.generateDataValue(mb, field);
	}

	/**
	 * Returns the current SQL text string that is being parsed.
	 *
	 * @return	Current SQL text string.
	 *
	 */

	public	String		getSQLtext()
	{	return	SQLtext; }

	/**
	  *	Get the NodeFactory for this context
	  *
	  *	@return	The NodeFactory for this context.
	  */

	public	NodeFactory	getNodeFactory()
	{	return lcf.getNodeFactory(); }

	/**
		Add a compile time warning.
	*/

	public void addWarning(SQLWarning warning) {
		if (warnings == null)
			warnings = warning;
		else
			warnings.setNextWarning(warning);
	}

	/**
		Get the chain of compile time warnings.
	*/

	public SQLWarning getWarnings() {
		return warnings;
	}

	/**
		Check the reliability type of this java value.

	    @exception StandardException		Thrown on error

		@see org.apache.derby.iapi.sql.compile.CompilerContext
	*/

	public void checkReliability(ValueNode sqlNode) throws StandardException {
        sqlNode.checkReliability( 
                CompilerContext.FUNCTION_CALL_ILLEGAL,
                SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF
                );
	}

	/**
		Set the activation for a single execution.

		@see Activation#setSingleExecution
	*/

	public void setSingleExecution() {
		ac.setSingleExecution();
	}

	/**
		Is the activation set up for a single execution.

		@see Activation#isSingleExecution
	*/

	public boolean isSingleExecution() {
		return ac.isSingleExecution();
	}

	/**
		Get the number of subqueries in the entire query.
		@return int	 The number of subqueries in the entire query.
	 */

	public int getNumSubqueries() {
		return ac.getNumSubqueries();
	}

	/**
	 * Gets information from its source. We might want
	 * to have this take a CursorResultSet in its constructor some day,
	 * instead of doing a cast here?
	 *
	 * @see CursorResultSet
	 *
	 * @return the row location of the current cursor row.
	 * @exception StandardException thrown on failure.
	 */

	public RowLocation getRowLocation() throws StandardException {
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(source instanceof CursorResultSet, "source not instance of CursorResultSet");
		return ( (CursorResultSet)source ).getRowLocation();
	}

	/**
     * open a scan on the table. scan parameters are evaluated
     * at each open, so there is probably some way of altering
     * their values...
	 *
	 * @exception StandardException thrown on failure to open
     */

	public void	openCore() throws StandardException {
		if (SanityManager.DEBUG)
	    	SanityManager.ASSERT( ! isOpen, "CurrentOfResultSet already open");

		// get the cursor
		getCursor();

		next = false;
	    isOpen = true;
	}

	/**
	 * This result set has its row location from
	 * the last fetch done. If it is closed,
	 * a null is returned.
	 *
	 * @see CursorResultSet
	 *
	 * @return the row location of the current row.
	 * @exception StandardException thrown on failure to get row location
	 */

	public RowLocation getRowLocation()  {
		return rowLocation;
	}

	/**
	 * Gets information from its source. We might want
	 * to have this take a CursorResultSet in its constructor some day,
	 * instead of doing a cast here?
	 *
	 * @see CursorResultSet
	 *
	 * @return the row location of the current cursor row.
	 * @exception StandardException thrown on failure.
	 */

	public RowLocation getRowLocation() throws StandardException {
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not CursorResultSet");
		return ( (CursorResultSet)source ).getRowLocation();
	}

	/**
	 * A join is combining rows from two sources, so it has no
	 * single row location to return; just return a null.
	 *
	 * @see CursorResultSet
	 *
	 * @return the row location of the current cursor row.
	 */

	public RowLocation getRowLocation() {
		if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("Join used in positioned update/delete");
		return null;
	}

	/**
	 * A join is combining rows from two sources, so it 
	 * should never be used in a positioned update or delete.
	 *
	 * @see CursorResultSet
	 *
	 * @return a null value.
	 */

	public ExecRow getCurrentRow() {
		if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("Join used in positioned update/delete");
		return null;
	}

	/**
		Report if closed.
	 */

	public boolean	isClosed() {
	    return ( ! isOpen );
	}

	/**
     * Returns the description of the table's rows
	 */

	public ResultDescription getResultDescription() {
	    return resultDescription;
	}

    /**
	  *	Reports whether these constants are up-to-date. This returns true
	  *	for homogenous Cloudscape/Cloudsync. For the Plugin, this may
	  *	return false;
	  *
	  *	@return	true if these constants are up-to-date
	  *			false otherwise
	  */

	public	boolean	upToDate()
	{ return true; }

	/**
     * Returns the description of the table's rows
	 */

	public ResultDescription getResultDescription() {
	    return activation.getResultDescription();
	}

	/**
		Return my cursor name for JDBC. Can be null.
	*/

	public String getCursorName() {

		String cursorName = activation.getCursorName();
		if ((cursorName == null) && isForUpdate()) {

			activation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());

			cursorName = activation.getCursorName();
		}

		return cursorName;
	}

	/**
	 * This is not operating against a stored table,
	 * so it has no row location to report.
	 *
	 * @see CursorResultSet
	 *
	 * @return a null.
	 */

	public RowLocation getRowLocation() {
		if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
		return null;
	}

	/**
	 * This is not used in positioned update and delete,
	 * so just return a null.
	 *
	 * @see CursorResultSet
	 *
	 * @return a null.
	 */

	public ExecRow getCurrentRow() {
		if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("RowResultSet used in positioned update/delete");
		return null;
	}

	/**
	 * reopen this ResultSet.
	 *
	 * @exception StandardException thrown if cursor finished.
	 */

	public void	reopenCore() throws StandardException {
		TransactionController		tc;

		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(isOpen,
					"HashScanResultSet already open");
		}

		beginTime = getCurrentTimeMillis();

		resetProbeVariables();

		numOpens++;
		openTime += getElapsedMillis(beginTime);
	}

	/**
		Just report that it is always closed.
		RESOLVE: if we don't report that we are closed,
		then we will wind up with a dependency problem when
		we send an invalidateFor on our own Statement.  It
		will call lcc.verifyNoOpenResultSets(), which is really
		supposed to be verify that there are no read only
		result sets that are open.
	 */

	public boolean isClosed() {
		return isClosed;
		//return true;
	}

	/**
		Return the cursor name, null in this case.

		@see ResultSet#getCursorName
	*/

	public String getCursorName() {
		return null;
	}

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_ROW_RS);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_PR);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_UPDATE);
  }

	/**
	 * Get the objects to be displayed when this tree object is expanded.
	 * <P>
	 * The objects returned can be of any type, including addtional Inspectables.
   *
	 * @return java.util.Vector	A vector of objects.
	 */

  public Vector getChildren(){
    return new Vector();
  }

	/**
   * Return the time for all operations performed by this node, and the children
   * of this node.  The times included open, next, and close.
	 *
	 */

  public long getTotalTime(){
    //The method below is the original calculation.  However, the constructor
    //time was found to be inaccurate, and was therefore removed from the calculation.
	  //return constructorTime + openTime + nextTime + closeTime;
	  return openTime + nextTime + closeTime;
  }

	/**
   * Return the time for all operations performed by the children of this node.
	 *
	 */

  public long getChildrenTime(){
    long childrenTime = 0;
    java.util.Enumeration e = getChildren().elements();
    while (e.hasMoreElements()){
      childrenTime = childrenTime + ((RealBasicNoPutResultSetStatistics)e.nextElement()).getTotalTime();
    }
    return childrenTime;
  }

	/**
   * Return the time for all operations performed by this node, but not the
   * time for the children of this node.
	 *
	 */

  public long getNodeTime(){
    return getTotalTime() - getChildrenTime();
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
	return MessageService.getTextMessage(
				indexName == null ?
				SQLState.RTS_TABLE_SCAN :
				SQLState.RTS_INDEX_SCAN);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_HASH_SCAN);
  }

	/**
	 * Get the objects to be displayed when this tree object is expanded.
	 * <P>
	 * The objects returned can be of any type, including addtional Inspectables.
   *
	 * @return java.util.Vector	A vector of objects.
	 */

  public Vector getChildren(){
    Vector children = new Vector();
    children.addElement(sourceResultSetStatistics);
    return children;
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_DELETE_VTI);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_IRTBR);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_SORT);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_VTI);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_INSERT_VTI);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_MATERIALIZED_RS);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_DISTINCT_SCALAR_AGG);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_SCROLL_INSENSITIVE_RS);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_NORMALIZE_RS);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_GROUPED_AGG);
  }

		/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_JOIN);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_INSERT);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_ONCE_RS);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_UNION);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
	// NOTE: Not internationalizing because "CURRENT OF" are keywords.
    return "Current Of";
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_ANY_RS);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_DELETE_CASCADE);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_DELETE);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_HASH_TABLE);
  }

	/**
   * Format for display, a name for this node.
	 *
	 */

  public String getNodeName(){
    return MessageService.getTextMessage(SQLState.RTS_SCALAR_AGG);
  }

	/**
	 * Get the objects to be displayed when this tree object is expanded.
	 * <P>
	 * The objects returned can be of any type, including addtional Inspectables.
   *
	 * @return java.util.Vector	A vector of objects.
	 */

  public Vector getChildren(){
    Vector children = new Vector();
    children.addElement(topResultSetStatistics);
    return children;
  }

	/**
     * Returns the description of the first source.
     * Assumes the compiler ensured both sources
     * had the same description.
	 */

	public ResultDescription getResultDescription() {
	    return source1.getResultDescription();
	}

	/**
		A union has a single underlying row at a time, although
		from one of several sources.
	
		@see CursorResultSet
	 
		@return the row location of the current cursor row.
		@exception StandardException thrown on failure
	 */

	public RowLocation getRowLocation() throws StandardException {
	    switch (whichSource) {
	        case 1 : 
				if (SanityManager.DEBUG)
					SanityManager.ASSERT(source1 instanceof CursorResultSet, "source not CursorResultSet");
				return ((CursorResultSet)source1).getRowLocation();
	        case 2 : 
				if (SanityManager.DEBUG)
					SanityManager.ASSERT(source2 instanceof CursorResultSet, "source2 not CursorResultSet");
				return ((CursorResultSet)source2).getRowLocation();
	        default: 
				if (SanityManager.DEBUG)
					SanityManager.THROWASSERT( "Bad source number in union" );
	            return null;
	    }
	}

	/**
		This is called prior to each execution of the statement, to
		ensure that it starts over with a new current datetime value.
	 */

	public void forget() {
		currentDatetime = null;
		currentDate = null;
		currentTime = null;
		currentTimestamp = null;
	}

	/**
	 * Mark the ResultSet as the topmost one in the ResultSet tree.
	 * Useful for closing down the ResultSet on an error.
	 *
	 * @return Nothing.
	 */

	public void markAsTopResultSet()
	{ }

	/**
     * If open and not returned yet, returns the row
     * after plugging the parameters into the expressions.
	 *
	 * @exception StandardException thrown on failure.
     */

	public ExecRow	getNextRowCore() throws StandardException {

		currentRow = null;
		beginTime = getCurrentTimeMillis();
		if (isOpen) 
		{
			if (!next) 
			{
	            next = true;
				if (currentRow == null)
				{
					if (cachedRow != null)
					{
						currentRow = cachedRow;
					}
					else if (row != null)
					{
						currentRow = (ExecRow) row.invoke(activation);
						if (canCacheRow)
						{
							cachedRow = currentRow;
						}
					}
				}
				rowsReturned++;
			}
			setCurrentRow(currentRow);

			nextTime += getElapsedMillis(beginTime);
	    }
	    return currentRow;
	}

	/**
	  *	Get the name of the table that these column live in.
	  *
	  *	@return	referenced table name
	  */

	public String getReferencedTableName()
	{ return tableName; }

	/**
	  *	Get the referential Action for an Update.
	  *
	  *	@return	referential Action for update
	  */

	public int getReferentialActionUpdateRule()
	{ return raUpdateRule; }

	/**
	  *	Get the referential Action for a Delete.
	  *
	  *	@return	referential Action Delete rule
	  */

	public int getReferentialActionDeleteRule()
	{ return raDeleteRule; }

	/**
		A generated class can create its own closeActivationAction
		method to invoke special logic when the activation is closed.
	*/

	protected void closeActivationAction() throws Exception {
		// no code to be added here as generated code
		// will not call super.closeActivationAction()
	}

	/**
		Find out if the activation closed or not.
		@return true if the prepared statement has been closed.
	 */

	public boolean isClosed() {
		return closed;
	}

	/**
		Set this Activation for a single execution.

		@see Activation#setSingleExecution
	*/

	public void setSingleExecution() {
		singleExecution = true;
	}

	/**
		Returns true if this Activation is only going to be used for
		one execution.

		@see Activation#isSingleExecution
	*/

	public boolean isSingleExecution() {
		return singleExecution;
	}

	/**
		Get the number of subqueries in the entire query.
		@return int	 The number of subqueries in the entire query.
	 */

	public int getNumSubqueries() {
		return numSubqueries;
	}

	/**
	  get the cursor name.  For something that isn't
	  a cursor, this is used as a string name of the
	  result set for messages from things like the
	  dependency manager.
	  <p>
	  Activations that do support cursors will override
	  this.	
	*/

	public String getCursorName() {

		return isCursorActivation() ? cursorName : null;
	}

	/**
		Used in the execute method of activations for
		generating the result sets that they concatenate together.
	 */

	public ResultSetFactory getResultSetFactory() {
		return rsFactory;
	}

	/**
		Used in activations for generating rows.
	 */

	public ExecutionFactory getExecutionFactory() {
		return exFactory;
	}

	/**
		Used in CurrentOfResultSet to get to the target result set
		for a cursor. Overridden by activations generated for
		updatable cursors.  Those activations capture the target
		result set in a field in their execute() method, and then
		return the value of that field in their version of this method.

		@return null.
	 */

	public CursorResultSet getTargetResultSet() {
		if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("Must be overridden to be used.");
		return null;
	}

	/**
		Used in CurrentOfResultSet to get to the cursor result set
		for a cursor.  Overridden by activations generated for
		updatable cursors.  Those activations capture the cursor
		result set in a field in their execute() method, and then
		return the value of that field in their version of this method.

		@return null
	 */

	public CursorResultSet getCursorResultSet() {
		if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("Must be overridden to be used.");
		return null;
	}

	/**
		Various activation methods need to disallow their
		invocation if the activation is closed. This lets them
		check and throw without generating alot of code.
		<p>
		The code to write to generate the call to this is approximately:
		<verbatim>
			// jf is a JavaFactory
			CallableExpression ce = jf.newMethodCall(
				jf.thisExpression(),
				BaseActivation.CLASS_NAME,
				"throwIfClosed",
				"void",
				acb.exprArray(jf.newStringLiteral(...some literal here...)));

			//mb is a MethodBuilder
			mb.addStatement(jf.newStatement(ce));
		</verbatim>
		The java code to write to call this is:
		<verbatim>
			this.throwIfClosed(...some literal here...);
		</verbatim>
		In both cases, "...some literal here..." gets replaced with
		an expression of type String that evaluates to the name
		of the operation that is being checked, like "execute" or
		"reset".

		@exception StandardException thrown if closed
	 */

	public void throwIfClosed(String op) throws StandardException {
		if (closed)
			throw StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);
	}

	/**
	 * reopen this ResultSet.
	 *
	 * @exception StandardException thrown if cursor finished.
	 */

	public void	reopenCore() throws StandardException {
		TransactionController		tc;

		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(isOpen,
					"IndexRowToBaseRowResultSet already open");
		}

		beginTime = getCurrentTimeMillis();

		source.reopenCore();

		numOpens++;
		openTime += getElapsedMillis(beginTime);
	}

	/**
	 * Return the RowLocation of the base row.
	 *
	 * @see CursorResultSet
	 *
	 * @return the row location of the current cursor row.
	 * @exception StandardException thrown on failure.
	 */

	public RowLocation getRowLocation() throws StandardException {
		return baseRowLocation;
	}

	/**
	 * Used to get a proxy for the current connection.
	 *
	 * @exception SQLException		Thrown on failure to get connection
	 */

	public Connection getCurrentConnection() throws SQLException {

		ConnectionContext cc = 
			(ConnectionContext) cm.getContext(ConnectionContext.CONTEXT_ID);

		return cc.getNestedConnection(true);
	}	

	/**
		Real implementations of this method are provided by a generated class.
	*/

	public int getMaxDynamicResults() {
		return 0;
	}

	/**
		Check that all of the dependent's dependencies are valid.

		@return true if the dependent is currently valid
	 */

	public boolean isValid() {
		return isValid;
	}

	/**
	 * the update mode of the cursor
	 *
	 * @return	The update mode of the cursor
	 */

	public int	getUpdateMode() {
		return updateMode;
	}

    /**
     * A driver may convert the JDBC sql grammar into its system's
     * native SQL grammar prior to sending it; nativeSQL returns the
     * native form of the statement that the driver would have sent.
     *
     * @param sql a SQL statement that may contain one or more '?'
     * parameter placeholders
     * @return the native form of this statement
     */

    public String nativeSQL(String sql) {
		// we don't massage the strings at all, so this is easy:
		return sql;
	}

    /**
     * If a connection is in auto-commit mode, then all its SQL
     * statements will be executed and committed as individual
     * transactions.  Otherwise, its SQL statements are grouped into
     * transactions that are terminated by either commit() or
     * rollback().  By default, new connections are in auto-commit
     * mode.
     *
     * The commit occurs when the statement completes or the next
     * execute occurs, whichever comes first. In the case of
     * statements returning a ResultSet, the statement completes when
     * the last row of the ResultSet has been retrieved or the
     * ResultSet has been closed. In advanced cases, a single
     * statement may return multiple results as well as output
     * parameter values. Here the commit occurs when all results and
     * output param values have been retrieved.
     *
     * @param autoCommit true enables auto-commit; false disables
     * auto-commit.  
     * @exception SQLException if a database-access error occurs.
     */

	public void setAutoCommit(boolean autoCommit) throws SQLException {

		// Is this a nested connection
		if (rootConnection != this) {
			if (autoCommit)
				throw newSQLException(SQLState.NO_AUTO_COMMIT_ON);
		}

		if (this.autoCommit != autoCommit)
			commit();

		this.autoCommit = autoCommit;
	}

    /**
     * Get the current auto-commit state.
     *
     * @return Current state of auto-commit mode.
     * @see #setAutoCommit 
     */

    public boolean getAutoCommit() {
		return autoCommit;
	}

    /**
     * Commit makes all changes made since the previous
     * commit/rollback permanent and releases any database locks
     * currently held by the Connection. This method should only be
     * used when auto commit has been disabled.
     *
     * @exception SQLException if a database-access error occurs.
     * @see #setAutoCommit 
     */

    public void commit() throws SQLException {
		synchronized (getConnectionSynchronization())
		{
			/*
			** Note that the context stack is
			** needed even for rollback & commit
			*/
            setupContextStack();

			try
			{
		    	getTR().commit();
			}
            catch (Throwable t)
			{
				throw handleException(t);
			}
			finally 
			{
				restoreContextStack();
			}

			needCommit = false;
		}
	}

    /**
     * Rollback drops all changes made since the previous
     * commit/rollback and releases any database locks currently held
     * by the Connection. This method should only be used when auto
     * commit has been disabled.
     *
     * @exception SQLException if a database-access error occurs.
     * @see #setAutoCommit 
     */

    public void rollback() throws SQLException {

		synchronized (getConnectionSynchronization())
		{
			/*
			** Note that the context stack is
			** needed even for rollback & commit
			*/
            setupContextStack();
			try
			{
		    	getTR().rollback();
			} catch (Throwable t) {
				throw handleException(t);
			}
			finally 
			{
				restoreContextStack();
			}
			needCommit = false;
		} 
	}

    /**
     * In some cases, it is desirable to immediately release a
     * Connection's database and JDBC resources instead of waiting for
     * them to be automatically released; the close method provides this
     * immediate release. 
     *
     * <P><B>Note:</B> A Connection is automatically closed when it is
     * garbage collected. Certain fatal errors also result in a closed
     * Connection.
     *
     * @exception SQLException if a database-access error occurs.
     */

    public void close() throws SQLException {
		// JDK 1.4 javadoc indicates close on a closed connection is a no-op
		if (isClosed())
		   	return;


		if (rootConnection == this)
		{
			/* Throw error to match DB2/JDBC if a tran is pending in non-autocommit mode */
			if (!autoCommit && !transactionIsIdle()) {
				throw newSQLException(SQLState.LANG_INVALID_TRANSACTION_STATE);
			}

			close(exceptionClose);
		}
		else
			setInactive(); // nested connection
	}

    /**
     * A Connection's database is able to provide information
     * describing its tables, its supported SQL grammar, its stored
     * procedures, the capabilities of this connection, etc. This
     * information is made available through a DatabaseMetaData
     * object.
     *
     * @return a DatabaseMetaData object for this Connection 
     * @exception SQLException if a database-access error occurs.
     */

    public DatabaseMetaData getMetaData() throws SQLException {
		if (isClosed())
			throw Util.noCurrentConnection();

		if (dbMetadata == null) {

 			// There is a case where dbname can be null.
			// Replication client of this method does not have a
			// JDBC connection; therefore dbname is null and this
			// is expected.
			//
			dbMetadata = factory.newEmbedDatabaseMetaData(this, getTR().getUrl());
		}
		return dbMetadata;
	}

    /**
     * A sub-space of this Connection's database may be selected by setting a
     * catalog name. If the driver does not support catalogs it will
     * silently ignore this request.
     *
     * @exception SQLException if a database-access error occurs.
     */

    public void setCatalog(String catalog) throws SQLException {
		// silently ignoring this request like the javadoc said.
		return;
	}

    /**
     * Return the Connection's current catalog name.
     *
     * @return the current catalog name or null
     * @exception SQLException if a database-access error occurs.
     */

	public String getCatalog() throws SQLException {
		// we do not have support for Catalog, just return null as
		// the JDBC specs mentions then.
		return null;
	}

	/**
	 * if auto commit is on, remember that we need to commit
	 * the current statement.
	 */

    protected void needCommit() {
		if (!needCommit) needCommit = true;
	}

	/**
		JDBC states that a Statement is closed when garbage collected.

		@exception Throwable Allows any exception to be thrown during finalize
	*/

	protected void finalize() throws Throwable {
		super.finalize();

		/*
		** We mark the activation as not being used and
	 	** that is it.  We rely on the connection to sweep
		** through the activations to find the ones that
		** aren't in use, and to close them.  We cannot
	 	** do a activation.close() here because there are
		** synchronized methods under close that cannot
		** be called during finalization.
		*/
		if (activation != null) 
		{
			activation.markUnused();
		}
	}

	/**
		Additional close to close our activation.

		@exception SQLException	thrown on failure
	 */

	protected void closeActions() throws SQLException {

		//we release the resource for preparedStatement
		preparedStatement = null;

		try{
			setupContextStack();
		} catch (SQLException se) {
			//we may have already committed the transaction in which case
			//setupContextStack will fail, the close should just return
			return;
		}
		try
		{
		    activation.close();
			activation = null;
		} catch (Throwable t)
		{
			throw handleException(t);
		} finally {
		    restoreContextStack();
		}
	}

    /**
     * Set a parameter to SQL NULL.
     *
     * <P><B>Note:</B> You must specify the parameter's SQL type.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param sqlType SQL type code defined by java.sql.Types
	 * @exception SQLException thrown on failure.
     */

    public void setNull(int parameterIndex, int sqlType) throws SQLException {

		checkStatus();

		int jdbcTypeId = getParameterJDBCType(parameterIndex);
		
		if (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {

			throw dataTypeConversion(parameterIndex, Util.typeName(sqlType));
		}
		
		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setToNull();
		} catch (StandardException t) {
			throw EmbedResultSet.noStateChangeException(t);
		}

	}

    /**
     * Set a parameter to a Java boolean value.  According to the JDBC API spec,
	 * the driver converts this to a SQL BIT value when it sends it to the
	 * database. But we don't have to do this, since the database engine
	 * supports a boolean type.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setBoolean(int parameterIndex, boolean x) throws SQLException {
		
		checkStatus();
		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (StandardException t) {
			throw EmbedResultSet.noStateChangeException(t);
		}
	}

    /**
     * Set a parameter to a Java byte value.  The driver converts this
     * to a SQL TINYINT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setByte(int parameterIndex, byte x) throws SQLException {

		checkStatus();
		try {

			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}
	}

    /**
     * Set a parameter to a Java short value.  The driver converts this
     * to a SQL SMALLINT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setShort(int parameterIndex, short x) throws SQLException {

		checkStatus();
		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}
	}

    /**
     * Set a parameter to a Java int value.  The driver converts this
     * to a SQL INTEGER value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setInt(int parameterIndex, int x) throws SQLException {
		checkStatus();

		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}
	}

    /**
     * Set a parameter to a Java long value.  The driver converts this
     * to a SQL BIGINT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setLong(int parameterIndex, long x) throws SQLException {
		checkStatus();
		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}

	}

    /**
     * Set a parameter to a Java float value.  The driver converts this
     * to a SQL FLOAT value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setFloat(int parameterIndex, float x) throws SQLException {
		checkStatus();
		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}

	}

    /**
     * Set a parameter to a Java double value.  The driver converts this
     * to a SQL DOUBLE value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setDouble(int parameterIndex, double x) throws SQLException {
		checkStatus();

		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}

	}

    /**
     * Set a parameter to a Java String value.  The driver converts this
     * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
     * size relative to the driver's limits on VARCHARs) when it sends
     * it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setString(int parameterIndex, String x) throws SQLException {
		checkStatus();		
		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}
	}

	/**
		Reset the connection before it is returned from a PooledConnection
		to a new application request (wrapped by a BrokeredConnection).
		Examples of reset covered here is dropping session temporary tables
		and reseting IDENTITY_VAL_LOCAL.
		Most JDBC level reset is handled by calling standard java.sql.Connection
		methods from EmbedPooledConnection.
	 */

	public void resetFromPool() throws SQLException {
		synchronized (getConnectionSynchronization())
		{
			setupContextStack();
			try {
				getLanguageConnection().resetFromPool();
			} catch (StandardException t) {
				throw handleException(t);
			}
			finally
			{
				restoreContextStack();
			}
		}
	}

    /**
     * Set a parameter to a Java array of bytes.  The driver converts
     * this to a SQL VARBINARY or LONGVARBINARY (depending on the
     * argument's size relative to the driver's limits on VARBINARYs)
     * when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value 
	 * @exception SQLException thrown on failure.
     */

    public void setBytes(int parameterIndex, byte x[]) throws SQLException {
		checkStatus();

		try {
			/* JDBC is one-based, DBMS is zero-based */
			getParms().getParameterForSet(parameterIndex - 1).setValue(x);

		} catch (Throwable t) {
			throw EmbedResultSet.noStateChangeException(t);
		}

	}

    /**
     * Set a parameter to a java.sql.Date value.  The driver converts this
     * to a SQL DATE value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setDate(int parameterIndex, Date x) throws SQLException {
        setDate( parameterIndex, x, (Calendar) null);
	}

    /**
     * Set a parameter to a java.sql.Time value.  The driver converts this
     * to a SQL TIME value when it sends it to the database.
     *
     * @param parameterIndex the first parameter is 1, the second is 2, ...
     * @param x the parameter value
	 * @exception SQLException thrown on failure.
     */

    public void setTime(int parameterIndex, Time x) throws SQLException {
        setTime( parameterIndex, x, (Calendar) null);
	}

    /**
     * <P>In general, parameter values remain in force for repeated use of a
     * Statement. Setting a parameter value automatically clears its
     * previous value.  However, in some cases it is useful to immediately
     * release the resources used by the current parameter values; this can
     * be done by calling clearParameters.
	 * @exception SQLException thrown on failure.
     */

    public void clearParameters() throws SQLException {
		checkStatus();

		ParameterValueSet pvs = getParms();
		if (pvs != null)
			pvs.clearParameters();
	}

    /**
     * What's the number of columns in the ResultSet?
     *
     * @return the number
     */

	public int getColumnCount()	{
		return columnInfo == null ? 0 : columnInfo.length;
	}

    /**
     * Is the column automatically numbered, thus read-only?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     *
     */

	public boolean isAutoIncrement(int column) throws SQLException	{

		ResultColumnDescriptor rcd = columnInfo[column - 1];
		return rcd.isAutoincrement();
	}

    /**
     * Does a column's case matter?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isCaseSensitive(int column) throws SQLException	{
	  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));
	}

    /**
     * Can the column be used in a where clause?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isSearchable(int column) throws SQLException	{
		validColumnNumber(column);

		// we have no restrictions yet, so this is always true
		// might eventually be false for e.g. extra-long columns?
		return true;
	}

    /**
     * Is the column a cash value?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isCurrency(int column) throws SQLException	{

		return DataTypeUtilities.isCurrency(getColumnTypeDescriptor(column));
	}

    /**
     * Can you put a NULL in this column?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return columnNoNulls, columnNullable or columnNullableUnknown
	 * @exception SQLException thrown on failure
     */

	public int isNullable(int column) throws SQLException	{
		return DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));
	}

    /**
     * Is the column a signed number?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isSigned(int column) throws SQLException	{
		return DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));
	}

    /**
     * What's the column's normal max width in chars?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return max width
	 * @exception SQLException thrown on failure
     */

	public int getColumnDisplaySize(int column) throws SQLException	{
		return DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));
	}

    /**
     * What's the suggested column title for use in printouts and
     * displays?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public String getColumnLabel(int column) throws SQLException {
		ResultColumnDescriptor cd = columnInfo[column - 1];
		String s = cd.getName();

		// we could get fancier than this, but it's simple
    	return (s==null? "Column"+Integer.toString(column) : s);
	}

    /**
     * What's a column's name?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return column name
	 * @exception SQLException thrown on failure
     */

	public String getColumnName(int column) throws SQLException	{
		ResultColumnDescriptor cd = columnInfo[column - 1];
		String s = cd.getName();
		// database returns null when no column name to differentiate from empty name
    	return (s==null? "" : s);

	}

    /**
     * What's a column's table's schema?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return schema name or "" if not applicable
	 * @exception SQLException thrown on failure
     */

	public String getSchemaName(int column) throws SQLException	{
		ResultColumnDescriptor cd = columnInfo[column - 1];

		String s = cd.getSourceSchemaName();
		// database returns null when no schema name to differentiate from empty name
		return (s==null? "" : s);
	}

    /**
     * What's a column's number of decimal digits?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return precision
	 * @exception SQLException thrown on failure
     */

	public int getPrecision(int column) throws SQLException	{
		return DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));
	}

    /**
     * What's a column's number of digits to right of the decimal point?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return scale
	 * @exception SQLException thrown on failure
     */

	public int getScale(int column) throws SQLException	{
		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
		// REMIND -- check it is valid to ask for scale
		return dtd.getScale();
	}

    /**
     * What's a column's table name?
     *
     * @return table name or "" if not applicable
	 * @exception SQLException thrown on failure
     */

	public String getTableName(int column) throws SQLException {
		ResultColumnDescriptor cd = columnInfo[column - 1];
		String s = cd.getSourceTableName();

		// database returns null when no table name to differentiate from empty name
		return (s==null? "" : s);
	}

    /**
     * What's a column's table's catalog name?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return column name or "" if not applicable.
	 * @exception SQLException thrown on failure
     */

	public String getCatalogName(int column) throws SQLException {
		validColumnNumber(column);
		return "";
	}

    /**
     * What's a column's SQL type?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return SQL type
     * @see Types
	 * @exception SQLException thrown on failure
     */

	public int getColumnType(int column) throws SQLException {
		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
		return dtd.getTypeId().getJDBCTypeId();
	}

	/**
		Override Throwable's toString() to avoid the class name
		appearing in the message. 
	*/

	public String toString() {
		return "SQL Warning: " + getMessage();
	}

    /**
     * What's a column's data source specific type name?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return type name
	 * @exception SQLException thrown on failure
     */

	public String getColumnTypeName(int column) throws SQLException	{
		DataTypeDescriptor dtd = getColumnTypeDescriptor(column);
		return dtd.getTypeId().getSQLTypeName();
	}

    /**
     * Is a column definitely not writable?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isReadOnly(int column) throws SQLException {
		validColumnNumber(column);

		// we just don't know if it is a base table column or not
		return false;
	}

    /**
     * Is it possible for a write on the column to succeed?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isWritable(int column) throws SQLException {
		validColumnNumber(column);
		return columnInfo[column - 1].updatableByCursor();
	}

    /**
     * Will a write on the column definitely succeed?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if so
	 * @exception SQLException thrown on failure
     */

	public boolean isDefinitelyWritable(int column) throws SQLException	{
		validColumnNumber(column);

		// we just don't know if it is a base table column or not
		return false;
	}

	/**
		JDBC states that a ResultSet is closed when garbage collected.
		We simply mark the activation as unused. Some later use
		of the connection will clean everything up.

		@exception Throwable Allows any exception to be thrown during finalize
	*/

	protected void finalize() throws Throwable {
		super.finalize();

		if (finalizeActivation != null) {
			finalizeActivation.markUnused();
		}		
	}

    /**
     * The maxFieldSize limit (in bytes) is the maximum amount of data
     * returned for any column value; it only applies to BINARY,
     * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
     * columns.  If the limit is exceeded, the excess data is silently
     * discarded.
     *
     * @return the current max column size limit; zero means unlimited
	 * @exception SQLException thrown on failure.
     */

	public int getMaxFieldSize() throws SQLException {
		checkStatus();

        return MaxFieldSize;
	}

    /**
     * If escape scanning is on (the default) the driver will do
     * escape substitution before sending the SQL to the database.
     *
     * @param enable true to enable; false to disable
	 * @exception SQLException thrown on failure.
     */

	public void setEscapeProcessing(boolean enable) throws SQLException	{
		checkStatus();
        // Nothing to do in our server , just ignore it.

	}

    /**
     * The queryTimeout limit is the number of seconds the driver will
     * wait for a Statement to execute. If the limit is exceeded a
     * SQLException is thrown.
     *
     * @return the current query timeout limit in seconds; zero means unlimited
	 * @exception SQLException thrown on failure.
     */

	public int getQueryTimeout() throws SQLException {
        // Currently Cloudscape does not support any sort of timeout, so always
        // return 0, which means that timeout is unlimited.
        return(0);
	}

    /**
     * The queryTimeout limit is the number of seconds the driver will
     * wait for a Statement to execute. If the limit is exceeded a
     * SQLException is thrown.
     *
     * @param seconds the new query timeout limit in seconds; zero means unlimited
	 * @exception SQLException thrown on failure.
     */

	public void setQueryTimeout(int seconds) throws SQLException {
		if (seconds != 0)
			throw Util.notImplemented("setQueryTimeout");
	}

    /**
     * Cancel can be used by one thread to cancel a statement that
     * is being executed by another thread.
	 * @exception SQLException thrown on failure.
     */

	public void cancel() throws SQLException {
		throw Util.notImplemented("cancel");
	}

    /**
     * The first warning reported by calls on this Statement is
     * returned.  A Statment's execute methods clear its SQLWarning
     * chain. Subsequent Statement warnings will be chained to this
     * SQLWarning.
     *
     * <p>The warning chain is automatically cleared each time
     * a statement is (re)executed.
     *
     * <P><B>Note:</B> If you are processing a ResultSet then any
     * warnings associated with ResultSet reads will be chained on the
     * ResultSet object.
     *
     * @return the first SQLWarning or null
	 * @exception SQLException thrown on failure.
     */

	public SQLWarning getWarnings() throws SQLException	{
		checkStatus();
		return warnings;
	}

    /**
     * After this call getWarnings returns null until a new warning is
     * reported for this Statement.
	 * @exception SQLException thrown on failure.
     */

	public void clearWarnings() throws SQLException	{
		checkStatus();
		warnings = null;
	}

    /**
     * setCursorName defines the SQL cursor name that will be used by
     * subsequent Statement execute methods. This name can then be
     * used in SQL positioned update/delete statements to identify the
     * current row in the ResultSet generated by this statement.  If
     * the database doesn't support positioned update/delete, this
     * method is a noop.
     *
     * <P><B>Note:</B> By definition, positioned update/delete
     * execution must be done by a different Statement than the one
     * which generated the ResultSet being used for positioning. Also,
     * cursor names must be unique within a Connection.
     *
     * @param name the new cursor name.
     */

	public void setCursorName(String name) throws SQLException {
		checkStatus();
		cursorName = name;
	}

    /**
     * The number, types and properties of a ResultSet's columns
     * are provided by the getMetaData method.
     *
     * @return the description of a ResultSet's columns
	 * @exception SQLException thrown on failure.
     */

    public ResultSetMetaData getMetaData() throws SQLException {

	  checkIfClosed("getMetaData");	// checking result set closure does not depend
								// on the underlying connection.  Do this
								// outside of the connection synchronization.

	  synchronized (getConnectionSynchronization()) {


		if (rMetaData == null) {
			// cache this object and keep returning it
			rMetaData = newEmbedResultSetMetaData(resultDescription);
		}
		return rMetaData;
	  }
	}

	/**
		Execute a single element of the batch. Overridden by EmbedPreparedStatement
	*/

	protected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
		return execute((String)batchElement, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);
	}

	/**
		Transfer my batch of Statements to a newly created Statement.
	*/

	public void transferBatch(EmbedStatement other) throws SQLException {
		
		synchronized (getConnectionSynchronization()) {
			other.batchStatements = batchStatements;
			batchStatements = null;
		}
	}

	/**
		Print the stack trace of the wrapped java exception or this
		exception if there is none.

		@see Throwable#printStackTrace
	*/

	public void printStackTrace() {
		Throwable je = getJavaException();
		if (je != null)
			je.printStackTrace();
		else
			super.printStackTrace();
	}

	/**
		Print the stack trace of the wrapped java exception or this
		exception if there is none.

		@see Throwable#printStackTrace
	*/

	public void printStackTrace(PrintStream s) {
		Throwable je = getJavaException();
		if (je != null)
			je.printStackTrace(s);
		else
			super.printStackTrace(s);
	}

	/**
		Print the stack trace of the wrapped java exception or this
		exception if there is none.

		@see Throwable#printStackTrace
	*/

	public void printStackTrace(PrintWriter s) {
		Throwable je = getJavaException();
		if (je != null)
			je.printStackTrace(s);
		else
			super.printStackTrace(s);
	}

	/**
		Override Throwables toString() to avoid the class name
		appearing in the message.
	*/

	public String toString() {
		return "SQL Exception: " + getMessage();
	}

	/**
	 * Returns a property if it was set at the database or
	 * system level. Treated as SERVICE property by default.
	 *
	 * @return a property string value.
	 **/

	public String getProperty(String key) {

		String propertyValue = null;
		TransactionController tc = null;

		try {

		  if (store != null)
          {
            tc = store.getTransaction(
                ContextService.getFactory().getCurrentContextManager());
          }

		  propertyValue =
			PropertyUtil.getServiceProperty(tc,
											key,
											(String) null);
		  if (tc != null) {
			tc.commit();
			tc = null;
		  }

		} catch (StandardException se) {
			// Do nothing and just return
		}

		return propertyValue;
	}

	/**
	 *  Check if we should activate this authentication service.
	 */

	public boolean canSupport(Properties properties) {

		if (!requireAuthentication(properties))
			return false;

		//
		// We check 2 System/Database properties:
		//
		//
		// - if derby.authentication.provider is set to 'BUILTIN'.
		//
		// and in that case we are the authentication service that should
		// be run.
		//

		String authenticationProvider = PropertyUtil.getPropertyFromSet(
					properties,
					org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);

		if ( (authenticationProvider != null) &&
			 (authenticationProvider.length() != 0) &&
			 (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,
				  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))
			return false;
		else
			return true;	// Yep, we're on!
	}

	/**
	 *  Check if we should activate the JNDI authentication service.
	 */

	public boolean canSupport(Properties properties) {

		if (!requireAuthentication(properties))
			return false;

		//
		// we check 2 things:
		//
		// - if derby.connection.requireAuthentication system
		//   property is set to true.
		// - if derby.authentication.provider is set to one
		// of the JNDI scheme we support (i.e. LDAP).
		//

		authenticationProvider = PropertyUtil.getPropertyFromSet(
					properties,
						org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);

		 if ( (authenticationProvider != null) &&
			   (StringUtil.SQLEqualsIgnoreCase(authenticationProvider,
				  	org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))
			return true;

		return false;
	}

	/**
	 * Construct the initial JNDI directory context environment Properties
	 * object. We retrieve JNDI environment properties that the user may
	 * have set at the database level.
	 *
	 **/

	private void setInitDirContextEnv(Properties dbProps) {

		//
		// We retrieve JNDI properties set at the database level	
		// if any.
		//
		initDirContextEnv = new Properties();

		for (Enumeration keys = dbProps.propertyNames(); keys.hasMoreElements(); ) {

			String key = (String) keys.nextElement();

			if (key.startsWith("java.naming.")) {
				initDirContextEnv.put(key, dbProps.getProperty(key));
			}
		}
	}

	/**
	 *  Check if we should activate this authentication service.
	 */

	public boolean canSupport(Properties properties) {

		return !requireAuthentication(properties);
	}

	/**
		Read from the wrapped stream prepending the intial bytes if needed.
	*/

	public int read() throws IOException {

		if (dummyBytes != 0) {
			dummyBytes--;
			return 0;
		}

		int ret = super.read();

		if (ret < 0)
			checkSufficientData();

		return ret;
	}

	/**
		Read from the wrapped stream prepending the intial bytes if needed.
	*/

	public int read(byte b[], int off, int len) throws IOException {

		int dlen = dummyBytes;

		if (dlen != 0) {
			if (len < dlen)
				dlen = len;
			for (int i = 0; i < dlen; i++) {
				b[off+i] = 0;
			}
			dummyBytes -= dlen;

			off += dlen;
			len -= dlen;
		}

		int realRead = super.read(b, off, len);

		if (realRead < 0)
		{
			if (dlen != 0)
				return dlen;

			checkSufficientData();

			return realRead;
		}

		return dlen + realRead;
	}

    /**
     * Can all the procedures returned by getProcedures be called by the
     * current user?
     *
     * @return true if so
     */

	public boolean allProceduresAreCallable() {
		return true;
	}

    /**
     * Can all the tables returned by getTable be SELECTed by the
     * current user?
     *
     * @return true if so
     */

	public boolean allTablesAreSelectable() {
		return true;
	}

    /**
     * What's our user name as known to the database?
     *
     * @return our database user name
     */

	public String getUserName() {
		return (getEmbedConnection().getTR().getUserName());
	}

    /**
     * Is the database in read-only mode?
     *
     * @return true if so
     */

	public boolean isReadOnly() {
		return getLanguageConnectionContext().getDatabase().isReadOnly();
	}

    /**
     * Are NULL values sorted high?
     *
     * @return true if so
     */

	public boolean nullsAreSortedHigh() {
		return true;
	}

    /**
     * Are NULL values sorted low?
     *
     * @return true if so
     */

	public boolean nullsAreSortedLow() {
		return false;
	}

    /**
     * Are NULL values sorted at the start regardless of sort order?
     *
     * @return true if so
     */

	public boolean nullsAreSortedAtStart() {
		return false;
	}

    /**
     * Are NULL values sorted at the end regardless of sort order?
     *
     * @return true if so
     */

	public boolean nullsAreSortedAtEnd() {
		return false;
	}

    /**
     * What's the name of this database product?
     *
     * @return database product name
     */

	public String getDatabaseProductName() {
		return Monitor.getMonitor().getEngineVersion().getProductName();
	}

    /**
     * What's the version of this database product?
     *
     * @return database version
     */

	public String getDatabaseProductVersion() {
		ProductVersionHolder myPVH = Monitor.getMonitor().getEngineVersion();

		return myPVH.getVersionBuildString(false);
	}

    /**
     * What's the name of this JDBC driver?
     *
     * @return JDBC driver name
     */

	public String getDriverName() {
		return "Apache Derby Embedded JDBC Driver";
	}

    /**
     * What's the version of this JDBC driver?
     *
     * @return JDBC driver version
     */

	public String getDriverVersion()  {
		return getDatabaseProductVersion();
	}

    /**
     * What's this JDBC driver's major version number?
     *
     * @return JDBC driver major version
     */

	public int getDriverMajorVersion() {
		return getEmbedConnection().getLocalDriver().getMajorVersion();
	}

    /**
     * What's this JDBC driver's minor version number?
     *
     * @return JDBC driver minor version number
     */

	public int getDriverMinorVersion() {
		return getEmbedConnection().getLocalDriver().getMinorVersion();
	}

    /**
     * Does the database store tables in a local file?
     *
     * @return true if so
     */

	public boolean usesLocalFiles() {
		return true;
	}

    /**
     * Does the database use a file for each table?
     *
     * @return true if the database uses a local file for each table
     */

	public boolean usesLocalFilePerTable() {
		return true;
	}

    /**
     * Does the database treat mixed case unquoted SQL identifiers as
     * case sensitive and as a result store them in mixed case?
     *
     * A JDBC-Compliant driver will always return false.
     *
     * @return true if so
     */

	public boolean supportsMixedCaseIdentifiers() {
		return false;
	}

    /**
     * Does the database treat mixed case unquoted SQL identifiers as
     * case insensitive and store them in upper case?
     *
     * @return true if so
     */

	public boolean storesUpperCaseIdentifiers() {
		return true;
	}

    /**
     * Does the database treat mixed case unquoted SQL identifiers as
     * case insensitive and store them in lower case?
     *
     * @return true if so
     */

	public boolean storesLowerCaseIdentifiers() {
		return false;
	}

    /**
     * Does the database treat mixed case unquoted SQL identifiers as
     * case insensitive and store them in mixed case?
     *
     * @return true if so
     */

	public boolean storesMixedCaseIdentifiers() {
		return false;
	}

    /**
     * Does the database treat mixed case quoted SQL identifiers as
     * case sensitive and as a result store them in mixed case?
     *
     * A JDBC-Compliant driver will always return true.
     *
     * @return true if so
     */

	public boolean supportsMixedCaseQuotedIdentifiers() {
		return true;
	}

    /**
     * Does the database treat mixed case quoted SQL identifiers as
     * case insensitive and store them in upper case?
     *
     * @return true if so
     */

	public boolean storesUpperCaseQuotedIdentifiers() {
		return false;
	}

    /**
     * Does the database treat mixed case quoted SQL identifiers as
     * case insensitive and store them in lower case?
     *
     * @return true if so
     */

	public boolean storesLowerCaseQuotedIdentifiers() {
		return false;
	}

    /**
     * Does the database treat mixed case quoted SQL identifiers as
     * case insensitive and store them in mixed case?
     *
     * @return true if so
     */

	public boolean storesMixedCaseQuotedIdentifiers() {
		return true;
	}

    /**
     * What's the string used to quote SQL identifiers?
     * This returns a space " " if identifier quoting isn't supported.
     *
     * A JDBC-Compliant driver always uses a double quote character.
     *
     * @return the quoting string
     */

	public String getIdentifierQuoteString() {
		return "\"";
	}

    /**
     * Get a comma separated list of all a database's SQL keywords
     * that are NOT also SQL92 keywords.
	includes reserved and non-reserved keywords.

     * @return the list
     */

	public String getSQLKeywords() {
		return "ALIAS,BIGINT,BOOLEAN,CALL,CLASS,COPY,DB2J_DEBUG,EXECUTE,EXPLAIN,FILE,FILTER,"
			+  "GETCURRENTCONNECTION,INDEX,INSTANCEOF,METHOD,NEW,OFF,PROPERTIES,PUBLICATION,RECOMPILE,"
			+  "REFRESH,RENAME,RUNTIMESTATISTICS,STATEMENT,STATISTICS,TIMING,WAIT";
	}

    /**
     * Get a comma separated list of math functions.
	getNumericFunctions lists "math functions" -- so built-in operators and
	things like EXTRACT are not included.
	FIXME: find a way to reference method aliases known to be "numeric"
    *
     * @return the list
     */

	public String getNumericFunctions() {
		return "ABS,SQRT";
	}

    /**
     * Get a comma separated list of string functions.
		REMIND, when they show up, something like this might appear here:
		FIXME: find a way to reference method aliases known to be "string"
     * @return the list
     */

	public String getStringFunctions() {
		return "LENGTH,LOWER,LTRIM,RTRIM,SUBSTR,SUBSTRING,UPPER";
	}

    /**
     * Get a comma separated list of system functions.
		FIXME: find a way to reference system functions on Database when/if
		they are registered as aliases or include the Database object too.
     * @return the list
     */

	public String getSystemFunctions()  {
		return "CURRENT_USER,getCurrentConnection,runTimeStatistics,SESSION_USER,USER,CURRENT SCHEMA";
	}

    /**
     * Get a comma separated list of time and date functions.
		not sure if this includes these built-ins or not, but here they are.
		FIXME: find a way to reference method aliases known to be "date/time"
     * @return the list
     */

	public String getTimeDateFunctions() {
		return "CURDATE,CURTIME,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,EXTRACT";
	}

    /**
     * This is the string that can be used to escape '_' or '%' in
     * the string pattern style catalog search parameters.
        we have no default escape value, so = is the end of the next line
     * <P>The '_' character represents any single character.
     * <P>The '%' character represents any sequence of zero or
     * more characters.
     * @return the string used to escape wildcard characters
     */

	public String getSearchStringEscape()  {
		return "";
	}

    /**
     * Get all the "extra" characters that can be used in unquoted
     * identifier names (those beyond a-z, A-Z, 0-9 and _).
     *
     * @return the string containing the extra characters
     */

	public String getExtraNameCharacters()  {
		return "";
	}

    /**
     * Is "ALTER TABLE" with add column supported?
     *
     * @return true if so
     */

	public boolean supportsAlterTableWithAddColumn() {
		return true;
	}

    /**
     * Is "ALTER TABLE" with drop column supported?
     *
     * @return true if so
     */

	public boolean supportsAlterTableWithDropColumn() {
		return true;
	}

    /**
     * Is column aliasing supported?
     *
     * <P>If so, the SQL AS clause can be used to provide names for
     * computed columns or to provide alias names for columns as
     * required.
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsColumnAliasing() {
		return true;
	}

    /**
     * Are concatenations between NULL and non-NULL values NULL?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean nullPlusNonNullIsNull()  {
		return true;
	}

    /**
     * Is the CONVERT function between SQL types supported?
     *
     * @return true if so
     */

	public boolean supportsConvert() {
		return true;
	}

    /**
     * Is CONVERT between the given SQL types supported?
     *
     * @param fromType the type to convert from
     * @param toType the type to convert to
     * @return true if so
     * @see Types
     */

	public boolean supportsConvert(int fromType, int toType) {
		/*
		 * at the moment we don't support CONVERT at all, so we take the easy
		 * way out.  Eventually we need to figure out how to handle this
		 * cleanly.
		 */
		return false;
	}

    /**
     * Are table correlation names supported?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsTableCorrelationNames()  {
		return true;
	}

    /**
     * If table correlation names are supported, are they restricted
     * to be different from the names of the tables?
     *
     * @return true if so
     */

	public boolean supportsDifferentTableCorrelationNames() {
		return true;
	}

    /**
     * Are expressions in "ORDER BY" lists supported?
     *
     * @return true if so
     */

	public boolean supportsExpressionsInOrderBy() {
		return false;
	}

    /**
     * Can an "ORDER BY" clause use columns not in the SELECT?
     *
     * @return true if so
     */

	public boolean supportsOrderByUnrelated() {
		return false;
	}

    /**
     * Is some form of "GROUP BY" clause supported?
     *
     * @return true if so
     */

	public boolean supportsGroupBy() {
		return true;
	}

    /**
     * Can a "GROUP BY" clause use columns not in the SELECT?
     *
     * @return true if so
     */

	public boolean supportsGroupByUnrelated()  {
		return true;
	}

    /**
     * Can a "GROUP BY" clause add columns not in the SELECT
     * provided it specifies all the columns in the SELECT?
     *
     * @return true if so
     */

	public boolean supportsGroupByBeyondSelect() {
		return true;
	}

    /**
     * Is the escape character in "LIKE" clauses supported?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsLikeEscapeClause() {
		return true;
	}

    /**
     * Are multiple ResultSets from a single execute supported?
     *
     * @return true if so
     */

	public boolean supportsMultipleResultSets()  {
		return true;
	}

    /**
     * Can we have multiple transactions open at once (on different
     * connections)?
     *
     * @return true if so
     */

	public boolean supportsMultipleTransactions() {
		return true;
	}

    /**
     * Can columns be defined as non-nullable?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsNonNullableColumns()  {
		return true;
	}

    /**
     * Is the ODBC Minimum SQL grammar supported?
     *
     * All JDBC-Compliant drivers must return true.
     *
     * @return true if so
     */

	public boolean supportsMinimumSQLGrammar() {
		return true;
	}

    /**
     * Is the ODBC Core SQL grammar supported?
     *
     * @return true if so
     */

	public boolean supportsCoreSQLGrammar() {
		return false;
	}

    /**
     * Is the ODBC Extended SQL grammar supported?
     *
     * @return true if so
     */

	public boolean supportsExtendedSQLGrammar() {
		return false;
	}

    /**
     * Is the ANSI92 entry level SQL grammar supported?
     *
     * All JDBC-Compliant drivers must return true.
     *
     * @return true if so
     */

	public boolean supportsANSI92EntryLevelSQL() {
		return false;
	}

    /**
     * Is the ANSI92 intermediate SQL grammar supported?
     *
     * @return true if so
	 * 
     */

	public boolean supportsANSI92IntermediateSQL() {
		return false;
	}

    /**
     * Is the ANSI92 full SQL grammar supported?
     *
     * @return true if so
	 * 
     */

	public boolean supportsANSI92FullSQL() {
		return false;
	}

    /**
     * Is the SQL Integrity Enhancement Facility supported?
     *
     * @return true if so
	 * 
     */

	public boolean supportsIntegrityEnhancementFacility() {
		return false;
	}

    /**
     * Is some form of outer join supported?
     *
     * @return true if so
	 * 
     */

	public boolean supportsOuterJoins() {
		return true;
	}

    /**
     * Are full nested outer joins supported?
     *
     * @return true if so
	 * 
     */

	public boolean supportsFullOuterJoins()  {
		return false;
	}

    /**
     * Is there limited support for outer joins?  (This will be true
     * if supportFullOuterJoins is true.)
     *
     * @return true if so
	 * 
     */

	public boolean supportsLimitedOuterJoins() {
		return true;
	}

    /**
     * What's the database vendor's preferred term for "schema"?
     *
     * @return the vendor term
	 * 
     */

	public String getSchemaTerm() {
		return "SCHEMA";
	}

    /**
     * What's the database vendor's preferred term for "procedure"?
     *
     * @return the vendor term
	 * 
     */

	public String getProcedureTerm() {
		return "PROCEDURE";
	}

    /**
     * What's the database vendor's preferred term for "catalog"?
     *
     * @return the vendor term
	 * 
     */

	public String getCatalogTerm() {
		return "CATALOG";
	}

    /**
     * Does a catalog appear at the start of a qualified table name?
     * (Otherwise it appears at the end)
     *
     * @return true if it appears at the start
	 * 
     */

	public boolean isCatalogAtStart() {
		return false;
	}

    /**
     * What's the separator between catalog and table name?
     *
     * @return the separator string
	 * 
     */

	public String getCatalogSeparator() {
		return "";
	}

    /**
     * Can a schema name be used in a data manipulation statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsSchemasInDataManipulation() {
		return true;
	}

    /**
     * Can a schema name be used in a procedure call statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsSchemasInProcedureCalls() {
		return true;
	}

    /**
     * Can a schema name be used in a table definition statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsSchemasInTableDefinitions() {
		return true;
	}

    /**
     * Can a schema name be used in an index definition statement?
     *
     * @return true if so
     */

	public boolean supportsSchemasInIndexDefinitions() {
		return true;
	}

    /**
     * Can a schema name be used in a privilege definition statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsSchemasInPrivilegeDefinitions() {
		return true;
	}

    /**
     * Can a catalog name be used in a data manipulation statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsCatalogsInDataManipulation() {
		return false;
	}

    /**
     * Can a catalog name be used in a procedure call statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsCatalogsInProcedureCalls() {
		return false;
	}

    /**
     * Can a catalog name be used in a table definition statement?
     *
     * @return true if so
	 * 
     */

	public boolean supportsCatalogsInTableDefinitions() {
		return false;
	}

    /**
     * Can a catalog name be used in an index definition statement?
     *
     * @return true if so
     */

	public boolean supportsCatalogsInIndexDefinitions() {
		return false;
	}

    /**
     * Can a catalog name be used in a privilege definition statement?
     *
     * @return true if so
     */

	public boolean supportsCatalogsInPrivilegeDefinitions() {
		return false;
	}

    /**
     * Is positioned DELETE supported?
     *
     * @return true if so
     */

	public boolean supportsPositionedDelete() {
		return true;
	}

    /**
     * Is positioned UPDATE supported?
     *
     * @return true if so
     */

	public boolean supportsPositionedUpdate() {
		return true;
	}

    /**
     * Is SELECT for UPDATE supported?
     *
     * @return true if so
     */

	public boolean supportsSelectForUpdate() {
		return true;
	}

    /**
     * Are stored procedure calls using the stored procedure escape
     * syntax supported?
     *
     * @return true if so
     */

	public boolean supportsStoredProcedures() {
		return true;
	}

    /**
     * Are subqueries in comparison expressions supported?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsSubqueriesInComparisons() {
		return true;
	}

    /**
     * Are subqueries in 'exists' expressions supported?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsSubqueriesInExists() {
		return true;
	}

    /**
     * Are subqueries in 'in' statements supported?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsSubqueriesInIns() {
		return true;
	}

    /**
     * Are correlated subqueries supported?
     *
     * A JDBC-Compliant driver always returns true.
     *
     * @return true if so
     */

	public boolean supportsCorrelatedSubqueries() {
		return true;
	}

    /**
     * Is SQL UNION supported?
     *
     * @return true if so
     */

	public boolean supportsUnion() {
		return true;
	}

    /**
     * Is SQL UNION ALL supported?
     *
     * @return true if so
     */

	public boolean supportsUnionAll() {
		return true;
	}

    /**
     * Can cursors remain open across rollbacks?
     *
     * @return true if cursors always remain open; false if they might not remain open
     */

	public boolean supportsOpenCursorsAcrossRollback() {
		return false;
	}

    /**
     * Can statements remain open across commits?
     *
     * @return true if statements always remain open; false if they might not remain open
     */

	public boolean supportsOpenStatementsAcrossCommit() {
		return true;
	}

    /**
     * Can statements remain open across rollbacks?
     *
     * @return true if statements always remain open; false if they might not remain open
     */

	public boolean supportsOpenStatementsAcrossRollback() {
		return false;
	}

    /**
     * How many hex characters can you have in an inline binary literal?
     *
     * @return max literal length
     */

	public int getMaxBinaryLiteralLength() {
		return 0;
	}

    /**
     * What's the max length for a character literal?
     *
     * @return max literal length
     */

	public int getMaxCharLiteralLength() {
		return 0;
	}

    /**
     * What's the limit on column name length?
     *
     * @return max literal length
     */

	public int getMaxColumnNameLength() {
		return Limits.MAX_IDENTIFIER_LENGTH;
	}

    /**
     * What's the maximum number of columns in a "GROUP BY" clause?
     *
     * @return max number of columns
     */

	public int getMaxColumnsInGroupBy() {
		return 0;
	}

    /**
     * What's the maximum number of columns allowed in an index?
     *
     * @return max columns
     */

	public int getMaxColumnsInIndex() {
		return 0;
	}

    /**
     * What's the maximum number of columns in an "ORDER BY" clause?
     *
     * @return max columns
     */

	public int getMaxColumnsInOrderBy() {
		return 0;
	}

    /**
     * What's the maximum number of columns in a "SELECT" list?
     *
     * we don't have a limit...
     *
     * @return max columns
     */

	public int getMaxColumnsInSelect() {
		return 0;
	}

    /**
     * What's the maximum number of columns in a table?
     *
     * @return max columns
     */

	public int getMaxColumnsInTable()  {
		return 0;
	}

    /**
     * How many active connections can we have at a time to this database?
     *
     * @return max connections
     */

	public int getMaxConnections() {
		return 0;
	}

    /**
     * What's the maximum cursor name length?
     *
     * @return max cursor name length in bytes
     */

	public int getMaxCursorNameLength() {
		return Limits.MAX_IDENTIFIER_LENGTH;
	}

    /**
     * What's the maximum length of an index (in bytes)?
     *
     * @return max index length in bytes
     */

	public int getMaxIndexLength() {
		return 0;
	}

    /**
     * What's the maximum length allowed for a schema name?
     *
     * @return max name length in bytes
     */

	public int getMaxSchemaNameLength()  {
		return Limits.MAX_IDENTIFIER_LENGTH;
	}

    /**
     * What's the maximum length of a procedure name?
     *
     * @return max name length in bytes
     */

	public int getMaxProcedureNameLength() {
		return Limits.MAX_IDENTIFIER_LENGTH;
	}

    /**
     * What's the maximum length of a catalog name?
     *
     * @return max name length in bytes
     */

	public int getMaxCatalogNameLength()  {
		return 0;
	}

    /**
     * What's the maximum length of a single row?
     *
     * @return max row size in bytes
     */

	public int getMaxRowSize() {
		return 0;
	}

    /**
     * Did getMaxRowSize() include LONGVARCHAR and LONGVARBINARY
     * blobs?
     *
     * @return true if so
     */

	public boolean doesMaxRowSizeIncludeBlobs() {
		return true;
	}

    /**
     * What's the maximum length of a SQL statement?
     *
     * @return max length in bytes
     */

	public int getMaxStatementLength() {
		return 0;
	}

    /**
     * How many active statements can we have open at one time to this
     * database?
     *
     * @return the maximum
     */

	public int getMaxStatements() {
		return 0;
	}

    /**
     * What's the maximum length of a table name?
     *
     * @return max name length in bytes
     */

	public int getMaxTableNameLength() {
		return Limits.MAX_IDENTIFIER_LENGTH;
	}

    /**
     * What's the maximum number of tables in a SELECT?
     *
     * @return the maximum
     */

	public int getMaxTablesInSelect() {
		return 0;
	}

    /**
     * What's the maximum length of a user name?
     *
     * @return max name length  in bytes
     */

	public int getMaxUserNameLength() {
		return Limits.DB2_MAX_USERID_LENGTH;
	}

    /**
     * What's the database's default transaction isolation level?  The
     * values are defined in java.sql.Connection.
     *
     * @return the default isolation level
     * @see Connection
     */

	public int getDefaultTransactionIsolation() {
		return java.sql.Connection.TRANSACTION_READ_COMMITTED;
	}

    /**
     * Are transactions supported? If not, commit is a noop and the
     * isolation level is TRANSACTION_NONE.
     *
     * @return true if transactions are supported
     */

	public boolean supportsTransactions()  {
		return true;
	}

    /**
     * Are both data definition and data manipulation statements
     * within a transaction supported?
     *
     * @return true if so
     */

	public boolean supportsDataDefinitionAndDataManipulationTransactions() {
			 return true;
	}

    /**
     * Does a data definition statement within a transaction force the
     * transaction to commit?
     *
     * @return true if so
	 * 
     */

	public boolean dataDefinitionCausesTransactionCommit() {
		return false;
	}

    /**
     * Is a data definition statement within a transaction ignored?
     *
     * @return true if so
	 * 
     */

	public boolean dataDefinitionIgnoredInTransactions(){
		return false;
	}

    /**
     * Get the schema names available in this database.  The results
     * are ordered by schema name.
     *
     * <P>The schema column is:
     *  <OL>
     *	<LI><B>TABLE_SCHEM</B> String => schema name
     *  </OL>
     *
     * @return ResultSet - each row has a single String column that is a
     * schema name
	 * @exception SQLException thrown on failure.
     */

	public ResultSet getSchemas() throws SQLException {
		return getSimpleQuery("getSchemas");
	}

    /**
     * Get the catalog names available in this database.  The results
     * are ordered by catalog name.
     *
     * <P>The catalog column is:
     *  <OL>
     *	<LI><B>TABLE_CAT</B> String => catalog name
     *  </OL>
     *
     * @return ResultSet - each row has a single String column that is a
     * catalog name
	 * @exception SQLException thrown on failure.
     */

	public ResultSet getCatalogs() throws SQLException {
		return getSimpleQuery("getCatalogs");
	}

    /**
     * Get the table types available in this database.  The results
     * are ordered by table type.
     *
     * <P>The table type is:
     *  <OL>
     *	<LI><B>TABLE_TYPE</B> String => table type.  Typical types are "TABLE",
     *			"VIEW",	"SYSTEM TABLE", "GLOBAL TEMPORARY",
     *			"LOCAL TEMPORARY", "ALIAS", "SYNONYM".
     *  </OL>
     *
     * @return ResultSet - each row has a single String column that is a
     * table type
	 * @exception SQLException thrown on failure.
     */

	public ResultSet getTableTypes() throws SQLException {
		return getSimpleQuery("getTableTypes");
	}

    /**
     * Get a description of all the standard SQL types supported by
     * this database. They are ordered by DATA_TYPE and then by how
     * closely the data type maps to the corresponding JDBC SQL type.
     *
     * <P>Each type description has the following columns:
     *  <OL>
     *	<LI><B>TYPE_NAME</B> String => Type name
     *	<LI><B>DATA_TYPE</B> short => SQL data type from java.sql.Types
     *	<LI><B>PRECISION</B> int => maximum precision
     *	<LI><B>LITERAL_PREFIX</B> String => prefix used to quote a literal
     *      (may be null)
     *	<LI><B>LITERAL_SUFFIX</B> String => suffix used to quote a literal
            (may be null)
     *	<LI><B>CREATE_PARAMS</B> String => parameters used in creating
     *      the type (may be null)
     *	<LI><B>NULLABLE</B> short => can you use NULL for this type?
     *      <UL>
     *      <LI> typeNoNulls - does not allow NULL values
     *      <LI> typeNullable - allows NULL values
     *      <LI> typeNullableUnknown - nullability unknown
     *      </UL>
     *	<LI><B>CASE_SENSITIVE</B> boolean=> is it case sensitive?
     *	<LI><B>SEARCHABLE</B> short => can you use "WHERE" based on this type:
     *      <UL>
     *      <LI> typePredNone - No support
     *      <LI> typePredChar - Only supported with WHERE .. LIKE
     *      <LI> typePredBasic - Supported except for WHERE .. LIKE
     *      <LI> typeSearchable - Supported for all WHERE ..
     *      </UL>
     *	<LI><B>UNSIGNED_ATTRIBUTE</B> boolean => is it unsigned?
     *	<LI><B>FIXED_PREC_SCALE</B> boolean => can it be a money value?
     *	<LI><B>AUTO_INCREMENT</B> boolean => can it be used for an
     *      auto-increment value?
     *	<LI><B>LOCAL_TYPE_NAME</B> String => localized version of type name
     *      (may be null)
     *	<LI><B>MINIMUM_SCALE</B> short => minimum scale supported
     *	<LI><B>MAXIMUM_SCALE</B> short => maximum scale supported
     *	<LI><B>SQL_DATA_TYPE</B> int => unused
     *	<LI><B>SQL_DATETIME_SUB</B> int => unused
     *	<LI><B>NUM_PREC_RADIX</B> int => usually 2 or 10
     *  </OL>
     *
     * @return ResultSet - each row is a SQL type description
	 * @exception SQLException thrown on failure.
     */

	public ResultSet getTypeInfo() throws SQLException {
		return getSimpleQuery("getTypeInfo");
	}

	/**
	 * Get a description of all the standard SQL types supported by
	 * this database. They are ordered by DATA_TYPE and then by how
	 * closely the data type maps to the corresponding JDBC SQL type.
	 * Same as getTypeInfo above, except that the result set will
	 * conform to ODBC specifications.
	 */

	public ResultSet getTypeInfoForODBC() throws SQLException {
		return getSimpleQuery("odbc_getTypeInfo");
	}

	/**
		Reset the cache statistics for the specified cache
	*/

	public void resetCacheStats(String cacheName) {
		getRawStoreXact().resetCacheStats(cacheName);
	}

	/**
	Store the stored representation of the column value in the stream.
	It might be easier to simply store the properties - which would certainly
	make upgrading easier.*/

	public void writeExternal_v36(ObjectOutput out) throws IOException {
		super.writeExternal(out);
		out.writeLong(baseConglomerateId);
		out.writeInt(rowLocationColumn);
	}

	/** Get the id of the column to be qualified. **/

	public int getColumnId() {
		return columnId;
	}

	/**
	 * Get the value that the column is to be compared to.
	 *
	 * @exception StandardException		Thrown on error
	 */

	public DataValueDescriptor getOrderable() {
		return value;
	}

	/** Get the operator to use in the comparison. 
     *
     *  @see DataValueDescriptor#compare
     **/

	public int getOperator() {
		return DataValueDescriptor.ORDER_OP_EQUALS;

	}

	/** 
     *  Determine if the result from the compare operation is to be negated.  
     *  <p>
     *  If true then only rows which fail the compare operation will qualify.
     *
     *  @see DataValueDescriptor#compare
     **/

	public boolean negateCompareResult() {
		return false;
	}

	/** Get the getOrderedNulls argument to use in the comparison.
     *  
     *  @see DataValueDescriptor#compare
     **/

    public boolean getUnknownRV() {
		return false;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_CHECKSUM;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_CHECKPOINT;
	}

	/**
		These following methods are only intended to be called by an
		implementation of a log factory. All other uses of this object should
		only see it as a log instant.
	*/

	public long getValueAsLong() {
		return makeLogInstantAsLong(fileNumber, filePosition);
	}

	/**
	 * Read this in.
	 * @exception IOException error reading from log stream
	 * @exception ClassNotFoundException corrupted log stream
	 */

	public void readExternal(ObjectInput oi) throws IOException, ClassNotFoundException {
		fileNumber = CompressedNumber.readLong(oi);
		filePosition = CompressedNumber.readLong(oi);
	}

	/**
	 * Write this out.
	 * @exception IOException error writing to log stream
	 */

	public void writeExternal(ObjectOutput oo) throws IOException {
		CompressedNumber.writeLong(oo,fileNumber);
		CompressedNumber.writeLong(oo,filePosition);
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.FILE_STREAM_LOG_FILE;
	}

	/**
		Get my record id.

		<BR>
		MT - thread safe

		@see RecordHandle#getId
	*/

	public int	getId() {
		return recordId;
	}

	/**
		Is a caller that holds a lock compatible with themselves?
        <p>
        Row locks held in the same transaction are always compatible with
        themselves.

		<BR>
		MT - Single thread required (methods of Lockable)

		@see org.apache.derby.iapi.services.locks.Lockable#lockerAlwaysCompatible
	*/	 

	public boolean lockerAlwaysCompatible() {
		return true;
	}

	/**
		Implement value equality.
		<BR>
		MT - Thread safe
	*/

	public boolean equals(Object ref) {

		if (!(ref instanceof RecordId))
			return false;

		RecordId other = (RecordId) ref;

		return ((recordId == other.recordId)
			&& pageId.equals(other.pageId));
	}

	/**
		Return a hashcode based on value.
		<BR>
		MT - thread safe
	*/

	public int hashCode() {

		return (int) recordId ^ pageId.hashCode();
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_INVALIDATE_PAGE;
	}

	/**
		remove the stream container

		@exception StandardException Standard Cloudscape error policy		
		@see StreamContainerHandle#removeContainer
	 */

	public void removeContainer() throws StandardException {
		container.removeContainer();
	}

	/**
		MT- not needed
	*/

	public Logger getLogger() {

		if (ReadOnlyDB)
			return null;
		else
			return new FileLogger(this);
	}

	/**
		get the container key for the stream container
	 */

	public ContainerKey getId() {
		return identity;
	}

	/**
		Attach me to a container. If this method returns false then
		I cannot be used anymore, and any reference to me must be discarded.

		@exception StandardException Standard Cloudscape error policy
	*/

	public boolean useContainer() throws StandardException {

		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(!active);
			SanityManager.ASSERT(container != null);
		}

		// always set forUpdate to false
		if (!container.use(this)) {
			container = null;
			return false;
		}

		active = true;

		// watch transaction and close ourseleves just before it completes.
        if (!hold)
        {
            xact.addObserver(this);
            xact.addObserver(new DropOnCommit(identity, true));
        }

		return true;
	}

	/**
		Add a page to the container, if flag == ContainerHandle.ADD_PAGE_BULK,
		tell the container about it.

		The page returned will be observing me.

		@see BaseContainer#addPage
		@see ContainerHandle#addPage
		@exception StandardException Standard Cloudscape error policy
	*/

	public Page addPage(int flag) throws StandardException {

		if ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)
		{
			// start preallocating immediatelly, don't wait for the
			// preallocation threshold to be crossed.  Don't go wild and
			// preallocate a bunch of pages either, use preAllocate for that. 
			container.clearPreallocThreshold();
		}

		return addPage();
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_UPDATE;
	}

	/**
		Return the last column of the row this operation logged
	*/

	public int getNextStartColumn() {
		return nextColumn;
	}

	/**
		Set container's identity
		@exception StandardException Standard Cloudscape error policy
	*/

	public Cacheable setIdentity(Object key) throws StandardException {

		ContainerKey newIdentity = (ContainerKey) key;

		// if this is an open for a temp container then return an object of that type
		if (newIdentity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT) {

			TempRAFContainer tmpContainer = new TempRAFContainer(dataFactory);
			return tmpContainer.setIdent(newIdentity);
		}

		return setIdent(newIdentity);
	}

	/**
		flush the cache to ensure all of my pages are written to disk

		@exception StandardException Standard Cloudscape error policy
	*/

	protected void flushAll() throws StandardException {

		pageCache.clean(identity);

		// now clean myself which will sync all my pages.
		clean(false);
	}

	/**
		Has the page or its header been modified or about to be modified.
		See comment on class header on meaning of isDirty and preDirty bits.

		@see Cacheable#isDirty
	*/

	public boolean isDirty() {

		synchronized (this) {
			return isDirty || preDirty;
		}
	}

	/**
		Has the page or its header been modified.
		See comment on class header on meaning of isDirty and preDirty bits.
	*/

	public boolean isActuallyDirty() {

		synchronized (this) {
			return isDirty;
		}
		
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_REMOVE_FILE;
	}

	/**
		Create a new container, all references to identity must be through the
		passed in identity, this object will no identity until after this method returns.
	*/

	protected void createContainer(ContainerKey newIdentity) throws StandardException {
		// RESOLVE - probably should throw an error ...
	}

	/**
		Read the page at the positioned offset.
		This default implementation, opens the stream and skips to the offset
		and then reads the data into pageData.
	*/

	protected void readPositionedPage(long pageOffset, byte[] pageData) throws IOException {


		InputStream is = null;
		try {
			// no need to synchronize as each caller gets a new stream
			is = getInputStream();

			InputStreamUtil.skipBytes(is, pageOffset);

			InputStreamUtil.readFully(is, pageData, 0, pageSize);

			is.close();
			is = null;
		} finally {
			if (is != null) {
				try {is.close();} catch (IOException ioe) {}
			}
		}
	}

	/**
	  Get an input stream for re-reading the remembered bytes.
	  */

	public InputStream getReplayStream() throws IOException {
		bh.startReading();
		recording = false;
		return new ByteHolderInputStream(bh);
	}

	/**
	  Get the byteHolder.
	  */

	public ByteHolder getByteHolder() throws IOException {
		return bh;
	}

	/**
	  Clear all the remembered bytes. This stream will
	  remember any bytes read after this call.
	  @exception IOException thrown on an io error clearing backing
	             storage.
	  */

	public void clear() throws IOException {
		bh.clear();
		recording = true;
	}

	/**
	  Set the InputStream from which this reads.

	  <P>Please note this does not clear remembered
	  bytes.
	 */

	public void setInput(InputStream in) {
		this.in = in;
	}

	/**
	  Return true iff this RememberBytesInputStream is
	  in recording mode.
	  */

	public boolean recording() {
		return recording;
	}

	/**
	  Return the number of bytes remains in the byteHolder
	  for reading, without setting the write/read mode.
	  */

	public int available() throws IOException {
		// may not have set reading to be true, then,
		// we are getting available in negative numbers.
		int remainingBytes = bh.available();
		remainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;
		return remainingBytes;
	}

	/**
	  remove the remaining bytes in the byteHolder to the beginning
	  set the position to start recording just after these bytes.
	  returns how many bytes was transfered to the beginning.
	  */

	public int shiftToFront() throws IOException {
		int bytesShifted = bh.shiftToFront();
		return bytesShifted;
	}

	/**	
		OK to hand object outside to cache.. 
	*/

	public Object getIdentity() {
		return identity;
	}

	/**
		Unlatch the page.
		@see Page#unlatch
	*/

	public void unlatch() {
		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(isLatched());
		}

	   releaseExclusive();
	}

	/**
		Is another request compatible, no never.
		<BR> MT - single thread required (methods of Lockable)
		@see Lockable#requestCompatible
	*/

	public boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {
		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(owner != null, "Should only be called when locked");
		}

		return false;
	}

	/**
		Is another request compatible, no never.
		<BR> MT - single thread required (methods of Lockable)
		@see Lockable#requestCompatible
	*/

	public boolean lockerAlwaysCompatible() {
		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(owner != null, "Should only be called when locked");
		}

		return false;
	}

	/**
		Unlatch me, only to be called from lock manager.
		<BR> MT - single thread required (methods of Lockable)

		@see Lockable#requestCompatible
	*/

	public void unlockEvent(Latch lockInfo) {
		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(owner != null, "Should only be called when locked");
		}

		synchronized (this) {

			if (SanityManager.DEBUG) {
				if (nestedLatch != 0)
					SanityManager.THROWASSERT("nestedLatch is non-zero on unlockEvent - value = " + nestedLatch);
			}

			owner.deleteObserver(this);
			owner = null;
			myLatch = null;
			if (inClean)
				notifyAll();
		}
	}

	/**
		Get the Page identifer

		<BR> MT - RESOLVE
	*/

	public PageKey getPageId() {
		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(identity != null);
		}

		return identity;
	}

	/**
		Release the exclusive latch on the page.
		<BR>
		MT - latched
	*/

	protected void releaseExclusive() /* throws StandardException */ {

		if (SanityManager.DEBUG) {
            if (!isLatched())
            {
                SanityManager.THROWASSERT(
                    "releaseExclusive failed, nestedLatch = " + nestedLatch);
            }
		}

		if (nestedLatch > 0) {
			nestedLatch--;
			return;
		}

		RawTransaction t = owner.getTransaction();
		t.getLockFactory().unlatch(myLatch);
	}

	/**
		Mark the record at the passed in slot as deleted.

		return code comes from StoredRecordHeader class:
			return	1, if delete status from not deleted to deleted
			return -1, if delete status from deleted to not deleted
			return  0, if status unchanged.
		<BR>
		<B>Any sub-class must call this method when deleting a record.</B>

		<BR>
		MT - latched

		@exception StandardException Standard Cloudscape error policy
		@exception IOException IO error accessing page
	*/

	public int setDeleteStatus(int slot, boolean delete) throws StandardException, IOException {

		if (SanityManager.DEBUG) {
			// latch check performed in checkSlotOnPage
			checkSlotOnPage(slot);;
		}

		return (getHeaderAtSlot(slot).setDeleted(delete));
	}

	/**
		Find the slot for the record with the passed in identifier.

		<BR>
		This method returns the record regardless of its deleted status.
        <BR>
        The "slotHint" argument is a hint about what slot the record id might
        be in.  Callers may save the last slot where the record was across
        latch/unlatches to the page, and then pass that slot back as a hint - 
        if the page has not shuffled slots since the last reference then the
        hint will succeed and a linear search is saved.  If the caller has
        no idea where it may be, then FIRST_SLOT_NUMBER is passed in and a
        linear search is performed.
		<BR>
		MT - latched

        @param recordId  record id of the record to search for.
        @param slotHint "hint" about which slot the record might be in.
		
	*/

	public int findRecordById(int recordId, int slotHint) {

		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(isLatched());
		}

		if (slotHint == FIRST_SLOT_NUMBER)
			slotHint = recordId - RecordHandle.FIRST_RECORD_ID;

		int	maxSlot = recordCount();

       if ((slotHint > FIRST_SLOT_NUMBER)        &&
            (slotHint < maxSlot)                   && 
            (recordId == getHeaderAtSlot(slotHint).getId())) {
            return(slotHint);
        } else {
            for (int slot = FIRST_SLOT_NUMBER; slot < maxSlot; slot++) {
				if (recordId == getHeaderAtSlot(slot).getId()) {
                    return slot;
				}
            }
        }

		return -1;
	}

	/**
		Discontinue use of this container. Note that the unlockContainer
		call made from this method may not release any locks. The container
		lock may be held until the end of the transaction.

	*/

	protected void letGo(BaseContainerHandle handle) {

		RawTransaction t = handle.getTransaction();

		handle.getLockingPolicy().unlockContainer(t, handle);
	}

	/**
		Set the container's dropped state
	*/

	protected void setDroppedState(boolean isDropped) {
		this.isDropped = isDropped;
	}

	/**
		Called when the transaction is about to complete.

		@see java.util.Observer#update
	*/

	public void update(Observable obj, Object arg) {
		if (SanityManager.DEBUG) {
			if (arg == null)
				SanityManager.THROWASSERT("still on observr list " + this);
		}

		if (arg.equals(RawTransaction.COMMIT) || arg.equals(RawTransaction.ABORT)) {

			RawTransaction xact = (RawTransaction) obj;

			try {
				if (this.isStreamContainer)
					xact.dropStreamContainer(identity.getSegmentId(), identity.getContainerId());
				else
					xact.dropContainer(identity);
			} catch (StandardException se) {
				xact.setObserverException(se);
			}

			obj.deleteObserver(this);
		}
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_SET_RESERVED_SPACE;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_CHAIN_ALLOC_PAGE;
	}

	/**
		Really this is just a convience routine for callers that might not
		have access to a log factory.
	*/

	public StandardException markCorrupt(StandardException originalError) {
		boolean firsttime = !isCorrupt;

		isCorrupt = true;
		if (getLogFactory() != null)
			getLogFactory().markCorrupt(originalError);

		// if firsttime markCorrupt is called, release the JBMS lock so user
		// can move the database if so desired.
		if (firsttime)
		{
			// get rid of everything from the cache without first cleaning them
			if (pageCache != null)
				pageCache.discard(null);

			if (containerCache != null)
				containerCache.discard(null);

			// don't read in any more pages 
			pageCache = null;
			containerCache = null;

			releaseJBMSLockOnDB();
		}

		return originalError;
	}

	/**
		Get the root directory of the data storage area. Is always guaranteed to be an absolute path.
	*/

	public String getRootDirectory() {
		return dataDirectory;
	}

	/**
		Does this factory support this service type.
	*/

	private boolean handleServiceType( Properties startParams, String type) {
        try
        {
            PersistentService ps = Monitor.getMonitor().getServiceProvider( startParams, type);
            return ps != null && ps.hasStorageFactory();
        }
        catch( StandardException se){ return false;}
	}

	/**
		Called after recovery is performed.

		@exception StandardException Standard Cloudscape Error Policy
	*/

	public void postRecovery() throws StandardException {

		// hook up the cache cleaner daemon after recovery is finished
		DaemonService daemon = rawStoreFactory.getDaemon();

		if (daemon == null)
			return;

		containerCache.useDaemonService(daemon);

		pageCache.useDaemonService(daemon);
		if (postRecoveryRemovedFiles != null) {

            synchronized( this)
            {
                actionCode = POST_RECOVERY_REMOVE_ACTION;
                try
                {
                    AccessController.doPrivileged( this);
                }
                catch( PrivilegedActionException pae){} // POST_RECOVERY_REMOVE does not throw an exception
            }
			postRecoveryRemovedFiles = null;
		}
	}

	/**
		Is the store read-only.
	*/

	public boolean isReadOnly() {
		// return what the baseDataFileFactory thinks
		return readOnly;
	}

/**
 * <A NAME="methodCallParameterList">methodCallParameterList</A>
*/

  final public void methodCallParameterList(Vector parameterList) throws ParseException, StandardException {
    jj_consume_token(LEFT_PAREN);
    if (jj_2_30(1)) {
      methodParameter(parameterList);
      label_17:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[145] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        methodParameter(parameterList);
      }
    } else {
      ;
    }
    jj_consume_token(RIGHT_PAREN);
  }

	/**
		The container is kept by the find() in File.openContainer. 
	*/

	protected void letGo(BaseContainerHandle handle) {
		super.letGo(handle);

		containerCache.release(this);
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_COMPRESS_SPACE;
	}

	/**
		Discontinue use of this container. Note that the unlockContainer
		call made from this method may not release any locks. The container
		lock may be held until the end of the transaction.

	*/

	protected void letGo(BaseContainerHandle handle) {

		inUseCount--;
		super.letGo(handle);
	}

	/**
		Returns true if only a single handle is connected to this container.
	*/

	public boolean isSingleUser() {
		return inUseCount == 1;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_UPDATE_FIELD;
	}

	/**
		An equals method that returns true if the other obejct
		is a sub-class of this, and the container identities
		are equal *and* it is the same class as this.
		<BR>
		This allows mutiple additions of value equality
		obejcts to the observer list while only retaining one.
	*/

	public boolean equals(Object other) {
		if (other instanceof ContainerActionOnCommit) {
			if (!identity.equals(((ContainerActionOnCommit) other).identity))
				return false;

			// the class of the types must match as well
			return getClass().equals(other.getClass());
		}
		return false;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.RAW_STORE_GLOBAL_XACT_ID_NEW;
	}

	/**
		Reset the cache statistics for the specified cache
	*/

	public void resetCacheStats(String cacheName)  {
		getDataFactory().resetCacheStats(cacheName);
	}

	/**
		Return true if any transaction is currently blocked, even if not by
		this transaction.

	 */

	public boolean anyoneBlocked() {
		return getLockFactory().anyoneBlocked();
	}

	/**
		Set my transaction identifier.
	*/

	public void setTransactionId(GlobalTransactionId extid, TransactionId localid) {

		if (SanityManager.DEBUG) {

			//SanityManager.ASSERT(myGlobalId == null, "my globalId is not null");
            if (!(state == IDLE || state == Xact.ACTIVE || 
                  (state== CLOSED && justCreated)))
            {
                SanityManager.THROWASSERT(
                    "my state is not idle nor active " + state);
            }
		}

		myGlobalId = extid;
		myId = localid;

		if (SanityManager.DEBUG)
		{
			if (SanityManager.DEBUG_ON("XATrace") && extid != null)
            {
				SanityManager.DEBUG(
                    "XATrace","setting xid: " + myId + " " + myGlobalId 
							   + " state " + state + " " + this);

                SanityManager.showTrace(new Throwable());
                // Thread.dumpStack();
            }
		}

	}

	/**
		Get the Logger object used to write log records to the transaction log.
	*/

	private void getLogger() {

		logger = logFactory.getLogger();
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.LOGOP_BEGIN_XACT;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;
	}

	/**
		Get the LockFactory to use with this store.
	*/

	public LockFactory getLockFactory() {
		return lockFactory;
	}

	/**
		Really this is just a convience routine for callers that might not
		have access to a log factory.
	*/

	public StandardException markCorrupt(StandardException originalError) {
		logFactory.markCorrupt(originalError);
		return originalError;
	}

	/**
		Return my format identifier.
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.RAW_STORE_XACT_ID;
	}

	/**
	  We use this RawStore for all databases.
	  */

	public boolean canSupport(Properties startParams) {
		return true;
	}

	/**
		Is the store read-only.
		@see RawStoreFactory#isReadOnly
	*/

	public boolean isReadOnly() {
		return dataFactory.isReadOnly();
	}

	/**
		All columns in TransactionTable VTI are of String type.
		@see java.sql.ResultSet#getString
	 */

	public String getString(int columnNumber)
	{		
		String val = (String)currentRow.get(columnInfo[columnNumber-1].getName());
		wasNull = (val == null);

		return  val;
	}

    /**
     * Is the column automatically numbered, and thus read-only?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if the column is automatically numbered
     * @exception SQLException if a database-access error occurs.
     */

	public boolean isAutoIncrement(int column) throws SQLException {
		throw new SQLException("isAutoIncrement");
	}

    /**
     * Does a column's case matter?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if the column is case-sensitive
     * @exception SQLException if a database-access error occurs.
     */

	public boolean isCaseSensitive(int column) throws SQLException {
		throw new SQLException("isCaseSensitive");
	}

    /**
     * Can the column be used in a WHERE clause?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if the column is searchable
     * @exception SQLException if a database-access error occurs.
     */

	public boolean isSearchable(int column) throws SQLException{
		throw new SQLException("isSearchable");
	}

    /**
     * Is the column a cash value?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if the column is a cash value
     * @exception SQLException if a database-access error occurs.
     */

	public boolean isCurrency(int column) throws SQLException{
		throw new SQLException("isCurrency");
	}

    /**
     * Can you put a NULL in this column?		
     *
     * @param column the first column is 1, the second is 2, ...
     * @return columnNoNulls, columnNullable or columnNullableUnknown
     * @exception SQLException if a database-access error occurs.
     */

	public int isNullable(int column) throws SQLException{
		throw new SQLException("isNullable");
	}

    /**
     * Is the column a signed number?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if the column is a signed number
     * @exception SQLException if a database-access error occurs.
     */

	public boolean isSigned(int column) throws SQLException {
		throw new SQLException("isSigned");
	}

    /**
     * What's the column's normal maximum width in chars?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return the column's maximum width
     * @exception SQLException if a database-access error occurs.
     */

	public  int getColumnDisplaySize(int column) throws SQLException {
		throw new SQLException("getColumnDisplaySize");
	}

    /**
     * What's the suggested column title for use in printouts and
     * displays?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return the column's title
     * @exception SQLException if a database-access error occurs.
     */

	public String getColumnLabel(int column) throws SQLException {
		throw new SQLException("getColumnLabel");
	}

    /**
     * What's a column's name?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return column name
     * @exception SQLException if a database-access error occurs.
     */

	public String getColumnName(int column) throws SQLException {
		throw new SQLException("getColumnName");
	}

    /**
     * What's a column's table's schema?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return schema name or "" if not applicable
     * @exception SQLException if a database-access error occurs.
     */

	public  String getSchemaName(int column) throws SQLException {
		throw new SQLException("getSchemaName");
	}

    /**
     * How many decimal digits are in the column?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return the column's precision
     * @exception SQLException if a database-access error occurs.
     */

	public int getPrecision(int column) throws SQLException {
		throw new SQLException("getPrecision");
	}

    /**
     * What's a column's number of digits to the right of the decimal point?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return the column's scale
     * @exception SQLException if a database-access error occurs.
     */

	public  int getScale(int column) throws SQLException {
		throw new SQLException("getScale");
	}

    /**
     * What's a column's table name? 
     *
	 * @param column the first column is 1, the second is 2, ...
     * @return the column's table name or "" if not applicable
     * @exception SQLException if a database-access error occurs.
     */

	public  String getTableName(int column) throws SQLException {
		throw new SQLException("getTableName");
	}

    /**
     * What's a column's table's catalog name?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return the column's table's catalog name or "" if not applicable.
     * @exception SQLException if a database-access error occurs.
     */

	public String getCatalogName(int column) throws SQLException {
		throw new SQLException("getCatalogName");
	}

    /**
     * What's a column's data source specific type name?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return the column's type name
     * @exception SQLException if a database-access error occurs.
     */

	public  String getColumnTypeName(int column) throws SQLException {
		throw new SQLException("getColumnTypeName");
	}

    /**
     * Is a column definitely not writable?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true - vti's are read only
	 *         false - column is not read-only
     * @exception SQLException if a database-access error occurs.
     */

	public  boolean isReadOnly(int column) throws SQLException {
		return true;
	}

    /**
     * Is it possible for a write on the column to succeed?
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if column is possibly writable
     * @exception SQLException if a database-access error occurs.
     */

	public  boolean isWritable(int column) throws SQLException {
		return false;
	}

    /**
     * Will a write on the column definitely succeed?	
     *
     * @param column the first column is 1, the second is 2, ...
     * @return true if column is definitely writable
     * @exception SQLException if a database-access error occurs.
     */

	public boolean isDefinitelyWritable(int column) throws SQLException {
		return false;
	}

	/**
	 * Returns the fully-qualified name of the Java class whose instances
	 * are manufactured if the method <code>ResultSet.<!-- -->getObject</code>
	 * is called to retrieve a value from the column. JDBC 2.0.
	 *
	 * @exception SQLException if a database-access error occurs
	 */

	public String getColumnClassName(int column) throws SQLException {
		throw new SQLException("getColumnClassName");
	}

	/**
		Skip a field header and its data on the given stream.
		
		@exception IOException corrupt stream
	*/

	public void skipField(ObjectInput in) throws IOException {


		int fieldStatus = StoredFieldHeader.readStatus(in);
		int fieldDataLength = StoredFieldHeader.readFieldDataLength(in, fieldStatus, slotFieldSize);

		if (fieldDataLength != 0) {
			in.skipBytes(fieldDataLength);
		}
	}

	/**
		In this case the Listeners are *not* notified. JDBC 3.0 spec section 11.4
	*/

	protected void closeCurrentConnectionHandle() throws SQLException {
		if (currentConnectionHandle != null)
		{
			Vector tmpEventListener = eventListener;
			eventListener = null;

			try {
				currentConnectionHandle.close();
			} finally {
				eventListener = tmpEventListener;
			}

			currentConnectionHandle = null;
		}
	}

	/**
		Notify the control class that a SQLException was thrown
		during a call on one of the brokered connection's methods.
	*/

	public void notifyException(SQLException sqle) {
		this.notifyError(sqle);
	}

	/**
		Are held cursors allowed.
	*/

	public void checkHoldCursors(int holdability) throws SQLException {
	}

	/**
		Allow control over creating a Savepoint (JDBC 3.0)
	*/

	public void checkSavepoint() throws SQLException {
	}

	/**
		Allow control over calling rollback.
	*/

	public void checkRollback() throws SQLException {
	}

	/**
		Allow control over calling commit.
	*/

	public void checkCommit() throws SQLException {
	}

	/**
		Close called on BrokeredConnection. If this call
		returns true then getRealConnection().close() will be called.

		Don't close the underlying real connection as
		it is pooled.
	*/

	public boolean closingConnection() throws SQLException {
		notifyClose();
		currentConnectionHandle = null;
		return false;
	}

	/**
		No need to wrap statements for PooledConnections.
	*/

	public Statement wrapStatement(Statement s) throws SQLException {
		return s;
	}

	/**
		No need to wrap statements for PooledConnections.
	*/

	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
		return ps;
	}

	/**
		No need to wrap statements for PooledConnections.
	*/

	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
		return cs;
	}

	/**
	 * Gets the maximum time in seconds that this data source can wait while
	 * attempting to connect to a database. A value of zero means that the
	 * timeout is the default system timeout if there is one; otherwise it means
	 * that there is no timeout. When a data source object is created, the login
	 * timeout is initially zero.
	 * 
	 * @return the data source login time limit
	 * @exception SQLException
	 *                if a database access error occurs.
	 */

	public int getLoginTimeout() throws SQLException {
		return loginTimeout;
	}

	/**
	 * Sets the maximum time in seconds that this data source will wait while
	 * attempting to connect to a database. A value of zero specifies that the
	 * timeout is the default system timeout if there is one; otherwise it
	 * specifies that there is no timeout. When a data source object is created,
	 * the login timeout is initially zero.
	 * <P>
	 * Cloudscape ignores this property.
	 * 
	 * @param seconds
	 *            the data source login time limit
	 * @exception SQLException
	 *                if a database access error occurs.
	 */

	public void setLoginTimeout(int seconds) throws SQLException {
		loginTimeout = seconds;
	}

	/**
	 * Get the log writer for this data source.
	 * 
	 * <p>
	 * The log writer is a character output stream to which all logging and
	 * tracing messages for this data source object instance will be printed.
	 * This includes messages printed by the methods of this object, messages
	 * printed by methods of other objects manufactured by this object, and so
	 * on. Messages printed to a data source specific log writer are not printed
	 * to the log writer associated with the java.sql.Drivermanager class. When
	 * a data source object is created the log writer is initially null, in
	 * other words, logging is disabled.
	 * 
	 * @return the log writer for this data source, null if disabled
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */

	public PrintWriter getLogWriter() throws SQLException {
		return printer;
	}

	/**
	 * Set the log writer for this data source.
	 * 
	 * <p>
	 * The log writer is a character output stream to which all logging and
	 * tracing messages for this data source object instance will be printed.
	 * This includes messages printed by the methods of this object, messages
	 * printed by methods of other objects manufactured by this object, and so
	 * on. Messages printed to a data source specific log writer are not printed
	 * to the log writer associated with the java.sql.Drivermanager class. When
	 * a data source object is created the log writer is initially null, in
	 * other words, logging is disabled.
	 * 
	 * @param out
	 *            the new log writer; to disable, set to null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */

	public void setLogWriter(PrintWriter out) throws SQLException {
		printer = out;
	}

	/**
		Accept anything that starts with <CODE>jdbc:derby:</CODE>.
		@exception SQLException if a database-access error occurs.
    @see java.sql.Driver
	*/

	public boolean acceptsURL(String url) throws SQLException {
		return getRegisteredDriver().acceptsURL(url);
	}

    /**
     * Returns the driver's major version number. 
     @see java.sql.Driver
     */

	public int getMajorVersion() {
		try {
			return (getRegisteredDriver().getMajorVersion());
		}
		catch (SQLException se) {
			return 0;
		}
	}

    /**
     * Returns the driver's minor version number.
     @see java.sql.Driver
     */

	public int getMinorVersion() {
		try {
			return (getRegisteredDriver().getMinorVersion());
		}
		catch (SQLException se) {
			return 0;
		}
	}

  /**
   * Report whether the Driver is a genuine JDBC COMPLIANT (tm) driver.
     @see java.sql.Driver
   */

	public boolean jdbcCompliant() {
		try {
			return (getRegisteredDriver().jdbcCompliant());
		}
		catch (SQLException se) {
			return false;
		}
	}

	/**
		Can cursors be held across commits.
	*/

	public void checkHoldCursors(int holdability) throws SQLException {
		xaConnection.checkHoldCursors(holdability);
	}

	/**
		Allow control over setting auto commit mode.
	*/

	public void checkAutoCommit(boolean autoCommit) throws SQLException {
		if (autoCommit && (currentXid != null))
			throw Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);

		super.checkAutoCommit(autoCommit);
	}

	/**
		Are held cursors allowed.
	*/

	public void checkHoldCursors(int holdability) throws SQLException {

		if (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {		
			if (currentXid != null)
				throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
		}

		super.checkHoldCursors(holdability);
	}

	/**
		Allow control over creating a Savepoint (JDBC 3.0)
	*/

	public void checkSavepoint() throws SQLException {

		if (currentXid != null)
			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);

		super.checkSavepoint();
	}

	/**
		Allow control over calling rollback.
	*/

	public void checkRollback() throws SQLException {

		if (currentXid != null)
			throw Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);

		super.checkRollback();
	}

	/**
		Allow control over calling commit.
	*/

	public void checkCommit() throws SQLException {

		if (currentXid != null)
			throw Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);

		super.checkCommit();
	}

	/**
		Wrap and control a Statement
	*/

	public Statement wrapStatement(Statement s) throws SQLException {
		XAStatementControl sc = new XAStatementControl(this, s);
		return sc.applicationStatement;
	}

	/**
		Wrap and control a PreparedStatement
	*/

	public PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {
		XAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);
		return (PreparedStatement) sc.applicationStatement;
	}

	/**
		Wrap and control a PreparedStatement
	*/

	public CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {
		XAStatementControl sc = new XAStatementControl(this, cs, sql);
		return (CallableStatement) sc.applicationStatement;
	}

	/**
		Get the error code for an error given a type. The value of
		the property messageId.type will be returned, e.g.
		deadlock.sqlstate.
	*/

	public String getErrorProperty(String type) {
		return getErrorProperty(getMessageId(), type);
	}

	/**
		Don't print the class name in the toString() method.
	*/

	public String toString() {
		String msg = getMessage();

		return "ERROR " + getSQLState() + ": " + msg;
	}

	/**
	 * Convert the object representation of the class into
	 * its class file format.
	 * @exception IOException error writing the class
	 */

	public ByteArray getFileFormat() throws IOException {

		int classFileSize = 4 + (10 * 2);
		classFileSize += cptEstimatedSize;

		if (interfaces != null)
			classFileSize += (interfaces.length * 2);

		if (field_info != null)
			classFileSize += field_info.classFileSize();

		if (method_info != null)
			classFileSize += method_info.classFileSize();

		if (attribute_info != null)
			classFileSize += attribute_info.classFileSize();

	
		ClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);

		put(cfo);

		return new ByteArray(cfo.getData(), 0, cfo.size());

	}

	/**
		Generic add entry to constant pool. Includes the logic
		for an entry to occupy more than one slot (e.g. long).

		@return The number of slots occupied by the entry.
.
	*/

	protected int addEntry(Object key, ConstantPoolEntry item) {

		item.setIndex(cptEntries.size());
		if (key != null)
			cptHashTable.put(key, item);
		cptEntries.addElement(item);

		cptEstimatedSize += item.classFileSize();

		if (item.doubleSlot()) {
			cptEntries.addElement(null);
			return 2;
		} else {
			return 1;
		}
	}

	/**
		Add an entry, but only if it doesn't exist.

		@return the constant pool index of the added
		or existing item.
	*/

	private int addDirectEntry(ConstantPoolEntry item) {
		ConstantPoolEntry existingItem = findMatchingEntry(item);
		if (existingItem != null) {
			item = existingItem;
			//foundCount++;
		}
		else {
			addEntry(item.getKey(), item);
		}
		return item.getIndex();
	}

	/**
		Add an index reference.
	*/

	private int addIndexReference(int tag, int i1, int i2) {

		// search for the item using the pre-allocated object 
		searchIndex.set(tag, i1, i2);

		ConstantPoolEntry item = findMatchingEntry(searchIndex);

		if (item == null) {
			item = new CONSTANT_Index_info(tag, i1, i2);
			addEntry(item.getKey(), item);
		}

		return item.getIndex();
	}

	/**
		Add a class entry to the pool.
	*/

	public int addClassReference(String fullyQualifiedName) {
		if (ClassHolder.isExternalClassName(fullyQualifiedName)) {
			fullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
			// System.out.println("addClassReference " + fullyQualifiedName);
		}

		int name_index = addUtf8Entry(fullyQualifiedName).getIndex();

		return addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);
	}

	/**
		Add a name and type entry
	*/

	private int addNameAndType(String name, String descriptor) {
		int nameIndex = addUtf8Entry(name).getIndex();

		int descriptorIndex = addUtf8Entry(descriptor).getIndex();

		return addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);
	}

	/**
		Add a UTF8 into the pool and return the index to it.
	*/

	private CONSTANT_Utf8_info addUtf8Entry(String value) {

		CONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);

		if (item == null) {

			item = new CONSTANT_Utf8_info(value);
			addEntry(value, item);
		}
		return item;
	}

	/**
		Add an extra UTF8 into the pool 
	*/

	private CONSTANT_Utf8_info addExtraUtf8(String value) {

		CONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);
		addEntry(null, item);

		return item;
	}

	/**
		Add a string entry
	*/

	private int addString(String value) {
		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
		int valueIndex = sutf.setAsString();
		if (valueIndex == 0) {
			// string is already being used as code
			valueIndex = addExtraUtf8(value).getIndex();
			sutf.setAlternative(valueIndex);
		}

		return addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);
	}

	/**
		Add a string entry
	*/

	private int addCodeUtf8(String value) {
		CONSTANT_Utf8_info sutf = addUtf8Entry(value);
		int index = sutf.setAsCode();
		if (index == 0) {
			// code string is already being used as string
			CONSTANT_Utf8_info eutf = addExtraUtf8(value);
			eutf.setAsCode(); // ensure the replace will happen
			index = eutf.getIndex();
			sutf.setAlternative(index);
		}

		return index;
	}

	/**
		Find a class descriptor (section 4.4.1) and return its
		index, returns -1 if not found.
	*/

	public int findClass(String fullyQualifiedName) {
		String internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);
		int utf_index = findUtf8(internalName);
		if (utf_index < 0)
			return -1;

		return findIndexIndex(VMDescriptor.CONSTANT_Class,
			utf_index, 0);
	}

	/**
		Find a name and type descriptor (section 4.4.6) and
		return it's index. 
        <p>
        returns -1 if not found.
	*/

	public int findNameAndType(String name, String descriptor) {

		int name_index = findUtf8(name);
		if (name_index < 0)
			return -1;
		int descriptor_index = findUtf8(descriptor);
		if (descriptor_index < 0)
			return -1;

		return findIndexIndex(VMDescriptor.CONSTANT_NameAndType,
			name_index, descriptor_index);
	}

	/**
		A helper to build a type description based on a Java class
		and an array arity.

		If descriptor is true create a descriptor according to
		section 4.3.2 of the vm spec. If false create a class name
		according to sections 4.3.2 and 4.4.1 of the vm spec.
	
	 */

	static private String makeDesc (String className, int arity, boolean descriptor) {

		if (!descriptor && (arity == 0)) {
			return className.replace('.','/');
		}

		StringBuffer desc = new StringBuffer(arity+2+className.length());

		for (int i=0;i<arity;i++)
			desc.append(VMDescriptor.C_ARRAY);

		desc.append(VMDescriptor.C_CLASS);

		desc.append(className.replace('.','/'));

		desc.append(VMDescriptor.C_ENDCLASS);

		return desc.toString();
	}

	/**
		Check to see if we have been interrupted. If we have then
		a ShutdownException will be thrown. This will be either the
		one passed to interrupt or a generic one if some outside
		source interrupted the thread.
	*/

	private void checkInterrupt() {
		if (shutdown) {
			// system must have changed underneath us
			throw new ShutdownException();
		}
	}

	/**
		Set the locale for this context.
	*/

	public void setLocaleFinder(LocaleFinder finder) {
		this.finder = finder;
	}

	/**
	 * Get current Context Manager
	 * @return ContextManager current Context Manager
	 */

	public ContextManager getCurrentContextManager() {

		Thread me = Thread.currentThread();

		Object list = threadContextList.get();

		if (list instanceof ContextManager) {
			
			ContextManager cm = (ContextManager) list;
			if (cm.activeThread == me)
				return cm;
			return null;
		}

		if (list == null)
			return null;

		java.util.Stack stack = (java.util.Stack) list;
		return (ContextManager) (stack.peek());


	//	if (list == null)
	//		return null;

		/*		Thread me = Thread.currentThread();
		
		synchronized (this) {
			for (Iterator i = allContexts.iterator(); i.hasNext(); ) {

				ContextManager cm = (ContextManager) i.next();
				if (cm.activeThread == me)
					return cm;
			}
		}
		//OLDreturn (ContextManager) get(me);
		return null;
*/	}

	/**
	 * The DEBUG_PRINT calls provides a convenient way to print debug
	 * information to the db2j.LOG file,  The message includes a header
	 *<p>
	 *	DEBUG <flag> OUTPUT: 
	 * before the message
	 *<p>
	 * If the debugStream stream cannot be found, the message is printed to
	 * System.out.
	 *
	 */

	static public void DEBUG_PRINT(String flag, String message) {
		java.io.PrintWriter debugStream = GET_DEBUG_STREAM();

		debugStream.println("DEBUG "+flag+" OUTPUT: " + message);
		debugStream.flush();
	}

	/**
		Get count of bytes written to the stream since the last
		reset() call.
	*/

	public int getCount() {
		return count;
	}

	/**
		Set a limit at which an exception will be thrown. This allows callers
		to count the number of bytes up to some point, without having to complete
		the count. E.g. a caller may only want to see if some object will write out
		over 4096 bytes, without waiting for all 200,000 bytes of the object to be written.
		<BR>
		If the passed in limit is 0 or negative then the stream will count bytes without
		throwing an exception.

		@see EOFException
	*/

	public void setLimit(int limit) {

		count = 0;

		this.limit = limit;

		return;
	}

	/**
		Add 1 to the count.

		@see OutputStream#write
	*/

	public  void write(int b) throws IOException {
		
		if ((limit >= 0) && ((count + 1) > limit)) {
			throw new EOFException();
		}

		out.write(b);
		count++;
	}

	/**
		Add len to the count, discard the data.

		@see OutputStream#write
	*/

	public void write(byte b[], int off, int len) throws IOException {

		if ((limit >= 0) && ((count + len) > limit)) {
			throw new EOFException();
		}

		out.write(b, off, len);
		count += len;
	}

	/**
		Set the array of bytes to be read.
	*/

	public void setData(byte[] data) {
		pageData = data;
		clearLimit();
	}

	/**
		A setLimit which also sets the position to be offset.

		@exception IOException limit is out of range 
	*/

	public int setLimit(int offset, int length) throws IOException {

		if ((offset < 0) || (length < 0)) {
			start = end = position = 0;
			throw new EOFException();
		}

		start = offset;
		end = offset + length;

		if (end > pageData.length) {
			start = end = position = 0;
			throw new EOFException();
		}

		position = start;

		return length;
	}

	/**
		Discard the data.

		@see OutputStream#write
	*/

	public  void write(int b)  {
	}

	/**
		Discard the data.

		@see OutputStream#write
	*/

	public void write(byte b[]) {
	}

	/**
		Discard the data.

		@see OutputStream#write
	*/

	public void write(byte b[], int off, int len)  {
	}

	/**
		Shrink the buffer left by the amount given. Ie.
		bytes from 0 to amountToShrinkBy are thrown away
	*/

	public void discardLeft(int amountToShrinkBy) {

		System.arraycopy(buf, amountToShrinkBy, buf, 0,
			used - amountToShrinkBy);

		position -= amountToShrinkBy;
		used -= amountToShrinkBy;
	}

	/**
		Set the limit of the stream that can be read. After this
		call up to and including length bytes can be read from or skipped in
		the stream. Any attempt to read more than length bytes will
		result in an EOFException

		@return The value of length.
		@exception IOException IOException from some underlying stream
		@exception EOFException The set limit would exceed
		the available data in the stream.
	*/

	public void setLimit(int length) {
		remainingBytes = length;
		limitInPlace = true;
		return;
	}

	/**
		Clear any limit set by setLimit. After this call no limit checking
		will be made on any read until a setLimit()) call is made.

		@return the number of bytes within the limit that have not been read.
		-1 if no limit was set.
	*/

	public int clearLimit() {
		int leftOver = remainingBytes;
		limitInPlace = false;
		remainingBytes = -1;
		return leftOver;
	}

	/**
		Clear the defaults from this Properties set.
		This sets the default field to null and thus
		breaks any link with the Properties set that
		was the default.
	*/

	public void clearDefaults() {
		defaults = null;
	}

	/**
	** Get the length in bits
	**
	** @return The length in bits for this value
	**
	** NOTE: could possibly be changed to a long.  As is
	** we are restricted to 2^(31-3) -> 256meg instead
	** of 2^31 (Integer.MAX_VALUE) like other datatypes
	** (or 2 gig).  If it is ever changed to a long
	** be sure to change read/writeExternal which write
	** out the length in bits.
	*/

	public int getLength() {
		return lengthAsBits;
	}

	/**
		return whether the field has exceeded the max threshold for this page
		it compares the fieldSize with the largest possible field for this page
	*/

	private boolean isLong(int fieldSize, int overflowThreshold) {

		if (SanityManager.DEBUG) {
			if (overflowThreshold == 0) 
				SanityManager.THROWASSERT("overflowThreshold cannot be 0");
		}

		// if a field size is over the threshold, then it becomes a long column
		int maxThresholdSize = maxFieldSize * overflowThreshold / 100;
		return (fieldSize > maxThresholdSize);
	}

	/**
		Is method/constructor T more or equally specific than method U.

		See the Java Language Specification section 15.11.2.2.
	*/

	private boolean isMethodMoreSpecificOrEqual(Member T, Member U, boolean[] isParam) {

		Class[] TC;
		Class[] UC;

		if (T instanceof Method) {
			if (!classConvertableFromTo(T.getDeclaringClass(), U.getDeclaringClass(), true))
				return false;

			TC = ((Method) T).getParameterTypes();
			UC = ((Method) U).getParameterTypes();
		} else {
			TC = ((Constructor) T).getParameterTypes();
			UC = ((Constructor) U).getParameterTypes();
		}

		return signatureConvertableFromTo(TC, null, UC, isParam, true);
	}

	/**
	  Return true if this is a alpha product.
	  */

	public boolean isAlpha() {
		return	   (majorVersion >= 5)
				&& (minorVersion > 2)
				&& ((maintVersion / MAINT_ENCODING) == 0);
	}

    /**
     * Return the build number as an integer if possible,
     * mapping from the SVN number.
     * nnnnn -> returns nnnnn
     * nnnnnM -> returns -nnnnn indicates a modified code base
     * nnnnn:mmmmm -> returns -nnnnn
     * anything else -> returns -1
    */

    public int getBuildNumberAsInt(){
    	if (buildNumber == null)
    	    return -1;
    	boolean dubiousCode = false;
    	int offset = buildNumber.indexOf('M');
    	if (offset == -1)
    	    offset = buildNumber.indexOf(':');
    	else
    	    dubiousCode = true;
    	if (offset == -1)
    		offset = buildNumber.length();
        else
            dubiousCode = true;
    	
    	try {
    		int bnai = Integer.parseInt(buildNumber.substring(0, offset));
    		if (dubiousCode)
    		    bnai = -bnai;
    		return bnai;
    	} catch (NumberFormatException nfe) 
     	{
     		return -1;
    	}
    }

	/**
		Return the feature version string, ie. major.minor. (e.g. 5.2)
	*/

	public String getSimpleVersionString() {

		return ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());
	}

	/**
		Value equality for byte arrays.
	*/

	public boolean equals(Object other) {
		if (other instanceof ByteArray) {
			ByteArray ob = (ByteArray) other;
			return ByteArray.equals(array, offset, length, ob.array, ob.offset, ob.length);
		}
		return false;
	}

	/**
	 * Is this column to have autoincremented value always ?
	 */

	public boolean isAutoincAlways(){
		return (columnDefaultInfo == null) && isAutoincrement();
	}

	/**
		Sync up the state of the underlying connection
		with the state of this new handle.
	*/

	public void syncState() throws SQLException {
		Connection conn = getRealConnection();

		stateIsolationLevel = conn.getTransactionIsolation();
		stateReadOnly = conn.isReadOnly();
		stateAutoCommit = conn.getAutoCommit();
		// jdk13 does not have Connection.getHoldability method and hence using
		// reflection to cover both jdk13 and higher jdks
		try {
			Method sh = conn.getClass().getMethod("getHoldability", null);
			stateHoldability = ((Integer)sh.invoke(conn, null)).intValue();
		} catch( Exception e)
		{
			throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
		}       
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_DATE_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_LONGINT_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_TIMESTAMP_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_CHAR_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_REF_ID;
	}  

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_BOOLEAN_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_LONGVARCHAR_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_INTEGER_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_NATIONAL_VARCHAR_ID;
	}

	/**
		Set this value into a ResultSet for a subsequent ResultSet.insertRow
		or ResultSet.updateRow. This method will only be called for non-null values.

		@exception SQLException thrown by the ResultSet object
		@exception StandardException thrown by me accessing my value.
	*/

	public void setInto(ResultSet rs, int position) throws SQLException, StandardException {
		rs.updateObject(position, getObject());
	}

	/**
	 * Each built-in type in JSQL has a precedence.  This precedence determines
	 * how to do type promotion when using binary operators.  For example, float
	 * has a higher precedence than int, so when adding an int to a float, the
	 * result type is float.
	 *
	 * The precedence for some types is arbitrary.  For example, it doesn't
	 * matter what the precedence of the boolean type is, since it can't be
	 * mixed with other types.  But the precedence for the number types is
	 * critical.  The SQL standard requires that exact numeric types be
	 * promoted to approximate numeric when one operator uses both.  Also,
	 * the precedence is arranged so that one will not lose precision when
	 * promoting a type.
	 *
	 * @return		The precedence of this type.
	 */

	public int					typePrecedence() {
		return -1;
	}

        /**
                Return my format identifier.

                @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
        */

        public int getTypeFormatId() {
                return StoredFormatIds.SQL_NCLOB_ID;
        }

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_REAL_ID;
	}

	/**
		Get a Null for this type.
	*/

	public DataValueDescriptor getNull() {
		return typeId.getNull();
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_SMALLINT_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_NATIONAL_CHAR_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_DOUBLE_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_CLOB_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_TIME_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_VARCHAR_ID;
	}

	/**
	 * Compare two non-null NumberDataValues using DECIMAL arithmetic.
	 */

	protected int typeCompare(DataValueDescriptor arg) throws StandardException {
		
		BigIntegerDecimal obid = getBID(arg);
		
		// need to align scales to perform comparisions
		int tscale = getDecimalValueScale();
		int oscale = obid.getDecimalValueScale();
	
		BigInteger tbi = new BigInteger(data2c);
		BigInteger obi = new BigInteger(obid.data2c);
		
		if (tscale < oscale)
			tbi = BigIntegerDecimal.rescale(tbi, oscale - tscale);
		else if (oscale < tscale)
			obi = BigIntegerDecimal.rescale(obi, tscale - oscale);
	
		return tbi.compareTo(obi);
	}

	/**
	 * Negate the number.
	 * @see org.apache.derby.iapi.types.NumberDataValue#minus(org.apache.derby.iapi.types.NumberDataValue)
	 */

	public NumberDataValue minus(NumberDataValue result) throws StandardException {
		
		if (result == null)
			result = (NumberDataValue) getNewNull();

		if (isNull())
			result.setToNull();
		else
		{
			BinaryDecimal rbd = (BinaryDecimal) result;
			
			BigInteger bi = new BigInteger(data2c);
			// scale remains unchanged.
			rbd.data2c = bi.negate().toByteArray();
			rbd.sqlScale = sqlScale;
		
		}
			
		return result;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_NATIONAL_LONGVARCHAR_ID;
	}

	/**
		Return my format identifier.

		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
	*/

	public int getTypeFormatId() {
		return StoredFormatIds.SQL_USERTYPE_ID_V3;
	}

	/**
		Return my identifier within the segment
	*/

	public long getContainerId() {
		return containerId;
	}

        /**
         * Is this type StreamStorable?
         *
         * @return      true if this type has variable length.
         */

        public boolean  streamStorable() {
                return isStringTypeId() || isBitTypeId();
        }

	/**
		Check to see if a logical operation is allowed by this transaction, 
        throws a TransactionExceotion if it isn't. This implementation allows
		logical operations. Transactions that need to disallow logical 
        operations should hide this method.

		@exception StandardException Standard Cloudscape error policy,
	*/

	public void checkLogicalOperationOk() throws StandardException {
	}

	/**
		Return true if this transaction should be rolled back first
		in recovery. This implementation returns false. Transactions that
		need to rollback first during recovery should hide this method.
	*/

	public boolean recoveryRollbackFirst() {
		return false;
	}

	/**
		Allow an Observer to indicate an exception to the transaction that
		is raised in its update() method.
	*/

	public void setObserverException(StandardException se) {
		if (observerException == null)
			observerException = se;
	}

	/**
		Allow my users to notigy my observers.
	*/

	public void notifyObservers(Object arg) {
		if (countObservers() != 0) {
			setChanged();
			super.notifyObservers(arg);
		}
	}

    /**
     * format_id not expected to be used in field documentation.
     * @return false
     */

    public boolean inField() {
        return false;
    }

    /**
     * format_id not expected to be used in constructor documentation.
     * @return false
     */

    public boolean inConstructor() {
        return false;
    }

    /**
     * format_id not expected to be used in method documentation.
     * @return false
     */

    public boolean inMethod() {
        return false;
    }

    /**
     * format_id can be used in overview documentation.
     * @return true
     */

    public boolean inOverview() {
        return true;
    }

    /**
     * format_id can be used in package documentation.
     * @return true
     */

    public boolean inPackage() {
        return true;
    }

    /**
     * format_id can be used in type documentation.
     * @return true
     */

    public boolean inType() {
        return true;
    }

    /**
     * format_id is not an inline tag.
     * @return false
     */

    public boolean isInlineTag() {
        return false;
    }

    /**
     * Embed the contents of the format_id tag as a row
     * in the disk format table.
     * @param tag The tag to embed to the disk format the table.
     */

    public String toString(Tag tag) {
        return "\n<dt><table cellpadding=2 cellspacing=2><tr><td>" + ROWNAME + "</td>"
               + "<td>" + tag.text() + "</td></tr>\n";
    }

    /**
     * Embed multiple format_id tags as cells in the disk format table.
     * @param tags An array of tags to add to the disk format table.
     */

    public String toString(Tag[] tags) {
        if (tags.length == 0) {
            return null;
        }
        String result = "<table cellpadding=2 cellspacing=2><tr><td>" + ROWNAME + "</td><td>" ;
        for (int i = 0; i < tags.length; i++) {
            if (i > 0) {
                result += "";
            }
            result += tags[i].text() + "</td></tr>";
        }
        return result + "\n";
    }

    /**
     * Embed the contents of the upgrade tag as a row
     * in the disk format table.
     * @param tag The tag to embed to the disk format the table.
     */

    public String toString(Tag tag) {
        return "<tr><td>" + ROWNAME + "</td>"
               + "<td>" + tag.text() + "</td></tr>\n";
    }

    /**
     * Embed multiple upgrade tags as cells in the disk format table.
     * @param tags An array of tags to add to the disk format table.
     */

    public String toString(Tag[] tags) {
        if (tags.length == 0) {
            return null;
        }
        String result = "<tr><td>" + ROWNAME + "</td><td>";
        for (int i = 0; i < tags.length; i++) {
            if (i > 0) {
                result += "";
            }
            result += tags[i].text() + "</td></tr>";
        }
        return result + "\n";
    }

    /**
     * Embed the contents of the disk_layout tag as a row
     * in the disk format table. Close the table.
     * @param tag The tag to embed to the disk format the table.
     */

    public String toString(Tag tag) {
        return "<tr><td>" + ROWNAME + "</td>"
               + "<td>" + tag.text() + "</td></tr></table>\n";
    }

    /**
     * Embed multiple disk_layout tags as cells in the disk format table.
     * Close the table.
     * @param tags An array of tags to add to the disk format table.
     */

    public String toString(Tag[] tags) {
        if (tags.length == 0) {
            return null;
        }
        String result = "<tr><td>" + ROWNAME + "</td><td>" ;
        for (int i = 0; i < tags.length; i++) {
            if (i > 0) {
                result += "";
            }
            result += tags[i].text() + "</td></tr>";
        }
        return result + "</table></dt>\n";
    }

	/**
	 * stack trace dumper
	 */

	private void doTrace(Throwable t) {
		if (util.getSystemProperty("ij.exceptionTrace") != null) {
			t.printStackTrace(out);
		}
		out.flush();
	}

	/**
		Reinit is used to redirect the finder to another stream.
		The previous stream should not have been in a PEEK state.

		@param s the input stream for reading statements from.
	 */

	public void ReInit(Reader s) { 
	    try {
			source.close();
		} catch (IOException ioe) {
			// just be quiet if it is already gone
		}
		source = s;
		state = IN_STATEMENT;
		atEOF = false;
		peekEOF = false;
		peeked = false;
	}

	/**
		Determine if the given character is considered whitespace

		@param c the character to consider
		@return true if the character is whitespace
	 */

	private boolean whiteSpace(char c) {
		return (c == SPACE ||
		    	c == TAB ||
		    	c == RETURN ||
		    	c == NEWLINE ||
		    	c == FORMFEED);
	}

	/**
		Advance the stream to the end of the string.
		Assumes the opening delimiter of the string has been read.
		This handles the SQL ability to put the delimiter within
		the string by doubling it, by reading those as two strings
		sitting next to one another.  I.e, 'Mary''s lamb' is read
		by this class as two strings, 'Mary' and 's lamb'.
		<p>
		The delimiter of the string is expected to be repeated at
		its other end. If the other flavor of delimiter occurs within
		the string, it is just a normal character within it.
		<p>
		All characters except the delimiter are permitted within the
		string. If EOF is hit before the closing delimiter is found,
		the end of the string is assumed. Parsers using this parser
		will detect the error in that case and return appropriate messages.

		@param stringDelimiter the starting and ending character
			for the string being read.
	 */

	private void readString(char stringDelimiter) {
		state = IN_STRING;
		do {
			char nextChar = readChar();

			if (atEOF()) {
				state = END_OF_INPUT;
				return;
			}

			if (nextChar == stringDelimiter) {
				// we've reached the end of the string
				state = IN_STATEMENT;
				return;
			}

			// still in string
		} while (state == IN_STRING); // could be while true...
	}

	/**
		return the next character in the source stream and
		append it to the statement buffer.

		@return the next character in the source stream.
	 */

	private char readChar() {
		if (!peeked) peekChar();

		peeked = false;
		atEOF = peekEOF;

		if (!atEOF) statement.append(peekChar);

		return peekChar;
	}

	/**
		return the next character in the source stream, without
		advancing.

		@return the next character in the source stream.
	 */

	private char peekChar() {
		peeked = true;
		char c = '\00';

		try {
		    int cInt;

			// REMIND: this is assuming a flat ascii source file.
			// will need to beef it up at some future point to
			// understand whether the stream is ascii or something else.
			cInt = source.read();
			peekEOF = (cInt == -1);
			if (!peekEOF) c = (char)cInt;
		} catch (IOException ie) {
			throw ijException.iOException(ie);
		}

		peekChar = c;
		return c;
	}

	/**
		ij is started with "-p[r] file OtherArgs";
		the file contains properties to control the driver and database
		used to run ij, and can provide additional system properties.
		<p>
		getPropertyArg will look at the args and take out a "-p <file>" pair,
		reading the file into the system properties.
		<p>
		If there was a -p without a following <file>, no action is taken.

		@exception IOException thrown if file not found

		@param args	the argument list to consider.
		@return true if a property item was found and loaded.
	 */

	static public boolean getPropertyArg(String[] args) throws IOException {
		String n;
		InputStream in1;
		Properties p;

		if ((n = getArg("-p", args))!= null){
			in1 = new FileInputStream(n);
			in1 = new BufferedInputStream(in1);
		}
		else if ((n = getArg("-pr", args)) != null) {
			in1 = getResourceAsStream(n);
			if (in1 == null) throw ijException.resourceNotFound();
		}
		else
			return false;

		p = System.getProperties();

		// Trim off excess whitespace in property file, if any, and
		// then load those properties into 'p'.
		util.loadWithTrimmedValues(in1, p);

		return true;
	}

	/**
	  Return the name of the ij command file or null if none is
	  specified. The command file may be proceeded with -f flag on
	  the command line. Alternatively, the command file may be 
	  specified without a -f flag. In this case we assume the first
	  unknown argument is the command file.

	  <P>
	  This should only be called after calling invalidArgs.

	  <p>
	  If there is no such argument, a null is returned.

	  @param args	the argument list to consider.
	  @return the name of the first argument not preceded by "-p",
	  null if none found.
	  
	  @exception IOException thrown if file not found
	 */

	static public String getFileArg(String[] args) throws IOException {
		String fileName;
		int fLocn;
		boolean foundP = false;

		if (args == null) return null;
		if ((fileName=getArg("-f",args))!=null) return fileName;
		//
		//The first unknown arg is the file
		for (int ix=0; ix < args.length; ix++)
			if(args[ix].equals("-f")  ||
			   args[ix].equals("-fr") ||
			   args[ix].equals("-ca")  ||
			   args[ix].equals("-car")  ||
			   args[ix].equals("-p")  ||
			   args[ix].equals("-pr"))
				ix++; //skip the parameter to these args
			else
				return args[ix];
		return null;
	}

	/**
	  Return the name of a resource containing input commands or
	  null iff none has been specified.
	  */

 	static public String getInputResourceNameArg(String[] args) {
		return getArg("-fr", args);
	}

	/**
		Utility interface that defaults driver and database to null.

		@return a connection to the defaultURL if possible; null if not.
		@exception SQLException on failure to connect.
		@exception ClassNotFoundException on failure to load driver.
		@exception InstantiationException on failure to load driver.
		@exception IllegalAccessException on failure to load driver.
	 */

    static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {
		return startJBMS(null,null);
	}

/**
 * ProtocolStatement is PROTOCOL 'JDBC protocol' where
 * the protocol is used to prefix any connect request that
 * cannot find a driver.  We will take a stab at loading
 * a driver as each protocol comes in -- we only know about
 * two.
 */

  final public ijResult ProtocolStatement() throws ParseException, SQLException {
        Token t;
        String n = null;
    jj_consume_token(PROTOCOL);
    t = jj_consume_token(STRING);
    if (jj_2_56(2)) {
      jj_consume_token(AS);
      n = identifier();
    } else {
      ;
    }
                installProtocol(n, stringValue(t.image));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

	/**
	 * init method - will init the class to support a locale and
	 * codeset based on the derby.ui.locale and derby.ui.codeset
	 * properties if exists or using the default values from the JVM.
	 */

	static public boolean init() {
		return (LocalizedResource.getInstance() != null);
	}

	/**
		Print information about the exception to the given PrintWriter.
		For non-SQLExceptions, does a stack trace. For SQLExceptions,
		print a standard error message and walk the list, if any.

		@param out the place to write to
		@param e the exception to display
	 */

	static public void ShowException(PrintWriter out, Throwable e) {
		if (e == null) return;

		if (e instanceof SQLException)
			ShowSQLException(out, (SQLException)e);
		else
			e.printStackTrace(out);
	}

	/**
		Print information about the SQL exception to the given PrintWriter.
		Walk the list of exceptions, if any.

		@param out the place to write to
		@param e the exception to display
	 */

	static public void ShowSQLException(PrintWriter out, SQLException e) {
		String errorCode;

		if (Boolean.getBoolean("ij.showErrorCode")) {
			errorCode = LocalizedResource.getMessage("UT_Error0", LocalizedResource.getNumber(e.getErrorCode()));
		}
		else {
			errorCode = "";
		}

		while (e!=null) {
			String p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst"));
			String p2 = mapNull(e.getMessage(),LocalizedResource.getMessage("UT_NoMessa"));
			out.println(LocalizedResource.getMessage("UT_Error012", p1, p2,errorCode));
			doTrace(out, e);
			e=e.getNextException();
		}
	}

	/**
		Print information about the SQL warnings for the connection
		to the given PrintWriter.
		Walks the list of exceptions, if any.

		@param out the place to write to
		@param theConnection the connection that may have warnings.
	 */

	static public void ShowWarnings(PrintWriter out, Connection theConnection) {
	    try {
		// GET CONNECTION WARNINGS
		SQLWarning warning = null;

		if (theConnection != null) {
			ShowWarnings(out, theConnection.getWarnings());
		}

		if (theConnection != null) {
			theConnection.clearWarnings();
		}
	    } catch (SQLException e) {
			ShowSQLException(out, e);
	    }
	} // ShowWarnings

	/**
		Print information about the SQL warnings for the ResultSet
		to the given PrintWriter.
		Walk the list of exceptions, if any.
	
		@param out the place to write to
		@param rs the ResultSet that may have warnings on it
	 */

	static public void ShowWarnings(PrintWriter out, ResultSet rs) {
	    try {
		// GET RESULTSET WARNINGS
		SQLWarning warning = null;

		if (rs != null) {
			ShowWarnings(out, rs.getWarnings());
		}

		if (rs != null) {
			rs.clearWarnings();
		}
	    } catch (SQLException e) {
			ShowSQLException(out, e);
	    }
	} // ShowResultSetWarnings

/**
 * SetConnectionStatement is SET CONNECTION ident
 * <p>
 * Moves to the named session, if it exists. If it doesn't
 * exist, remains on the current session and returns an error.
 */

  final public ijResult SetConnectionStatement() throws ParseException, SQLException {
        String t;
    jj_consume_token(SET);
    jj_consume_token(CONNECTION);
    t = identifier();
                if (!currentConnEnv.haveSession(t)) {
                        {if (true) throw ijException.noSuchConnection(t);}
                }
                currentConnEnv.setCurrentSession(t);
                theConnection = currentConnEnv.getConnection();
                {if (true) return new ijConnectionResult(theConnection);}
    throw new Error("Missing return statement in function");
  }

/**
	Shows the current connections for the current environment.
 */

  final public ijResult ShowConnectionsStatement() throws ParseException, SQLException {
    jj_consume_token(SHOW);
    jj_consume_token(CONNECTIONS);
                {if (true) return showConnectionsMethod(false);}
    throw new Error("Missing return statement in function");
  }

	/**
		Map the string to the value if it is null.

		@param s the string to test for null
		@param nullValue the value to use if s is null

		@return if s is non-null, s; else nullValue.
	 */

	static public String mapNull(String s, String nullValue) {
		if (s==null) return nullValue;
		return s;
	}

	/**
		If the property ij.exceptionTrace is true, display the stack
		trace to the print stream. Otherwise, do nothing.

		@param out the output stream to write to
		@param e the exception to display
	 */

	static public void doTrace(PrintWriter out, Exception e) {
		if (Boolean.getBoolean("ij.exceptionTrace")) {
			e.printStackTrace(out);
		    out.flush();
		}
	}

/**
 * CommitStatement is simply COMMIT.
 * It commits the current transation.
 */

  final public ijResult CommitStatement() throws ParseException, SQLException {
    jj_consume_token(COMMIT);
    if (jj_2_67(2)) {
      jj_consume_token(WORK);
    } else {
      ;
    }
                haveConnection();
                theConnection.commit();
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * RollbackStatement is simply ROLLBACK.
 * It undoes the current transation.
 */

  final public ijResult RollbackStatement() throws ParseException, SQLException {
    jj_consume_token(ROLLBACK);
    if (jj_2_68(2)) {
      jj_consume_token(WORK);
    } else {
      ;
    }
                haveConnection();
                theConnection.rollback();
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /** Shuts down everything nicely
     */

    public void shutdown() {
	try{
	    for(int i=0;i<sockets.size();i++) {
		(datain.get(i)).close();
		(dataout.get(i)).close();
		(sockets.get(i)).close();
		System.out.println("Socket closed");
	    } // end for
	} // end try
	catch(IOException e) {
	    System.out.println("Problem shutting down");
	    System.out.println(e);
	} // end catch
    } // end shutdown

    /** Adds a socket to the sockets ArrayList
     * @param IP the IP address of the socket
     */

    public boolean addServer(String IP) {
	try {
	    sockets.add(new Socket(IP,port));
	} // end try
	catch(IOException e) {
	    System.out.println("Unable to connect to "+IP+":"+port);
	    System.out.println(e);
	    return false;
	}// end catch
	return true;
    } // end addServer(String)

    /** Attaches data streams to a socket
     * @param index index into the arraylist for where the data streams go
     */

    public void addDataStreams(int index) {
	try {
	    dataout.add(new DataOutputStream((sockets.get(index)).getOutputStream()));
	    datain.add(new DataInputStream((sockets.get(index)).getInputStream()));
	} // end try
	catch(IOException e) {
	    System.out.println("Problem creating data streams");
	    System.out.println("**** ADD CODE TO PROPERLY CLOSE STUFF HERE ****");
	    System.out.println(e);
	} // end catch
    } // end addDataStreams(int)

    /** Writes out a bad command message
     * @param rcv string that was received
     * @param exp string that was expected
     */

    public void badCommand(String rcv, String exp) {
	System.out.println("Received \"" + rcv + "\"");
	System.out.println("Expected \"" + exp + "\"");
    } // end badCommand(String,String)

    /** Finds out what OS we are running
     * @return 0=linux 1=windows 2=other
     */

    public int checkOS() {
	if(System.getProperty("os.name").toLowerCase().contains("linux")) {
	    return 0;
	} // end if linux
	if(System.getProperty("os.name").toLowerCase().contains("windows")) {
	    return 1;
	}
	return 2;
    } // end checkOS()

    /** Waits for a client to connect
     * @return true if recycle, false if shutdown
     */

    public boolean lookForConnection() {
	/* Wait for client to connect */
	CSocket = null;
	try {
	    CSocket = SSocket.accept();
	    System.out.println("CONNECTION ACCEPTED");
	} // end try
	catch(IOException e) {
	    System.out.println("Unable to accept connection");
	    System.out.println(e);
	    return false;
	} // end catch

	/* Add the data streams */
	try {
	    din = new DataInputStream(CSocket.getInputStream());
	    dout = new DataOutputStream(CSocket.getOutputStream());
	    return true;
	} // end try
	catch(IOException e) {
	    System.out.println("Problem with Data Streams");
	    System.out.println(e);
	    return false;
	} // end catch
    } // end lookForConnection()

    /** Shuts down everything nicely
     */

    public void closeConnection() {
	try {
	    din.close();
	    dout.close();
	    CSocket.close();
	    System.out.println("CSocket Closed");
	} // end try
	catch(IOException e) {
	    System.out.println("Problem closing connection");
	    System.out.println(e);
	} // end catch
    } // end shutdown

    /**
     * Gets the value of the point property.
     * 
     * @return
     *     possible object is
     *     {@link PointType }
     *     
     */

    public PointType getPoint() {
        return point;
    }

    /**
     * Sets the value of the point property.
     * 
     * @param value
     *     allowed object is
     *     {@link PointType }
     *     
     */

    public void setPoint(PointType value) {
        this.point = value;
    }

    /**
     * Gets the value of the pos property.
     * 
     * @return
     *     possible object is
     *     {@link Pos }
     *     
     */

    public Pos getPos() {
        return pos;
    }

    /**
     * Sets the value of the pos property.
     * 
     * @param value
     *     allowed object is
     *     {@link Pos }
     *     
     */

    public void setPos(Pos value) {
        this.pos = value;
    }

    /**
     * Sets the value of the pointMembers property.
     * 
     * @param pointMembers
     *     allowed object is
     *     {@link PointMember }
     *     
     */

    public void setPointMembers(List<PointMember> pointMembers) {
        this.pointMembers = pointMembers;
    }

    /**
     * Gets the value of the srsName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getSrsName() {
        return srsName;
    }

    /**
     * Sets the value of the srsName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setSrsName(String value) {
        this.srsName = value;
    }

    /**
     * Sets the value of the _Geometry property.
     * 
     * @param value
     *     allowed object is
     *     {@link JAXBElement }{@code <}{@link LinearRingType }{@code >}
     *     {@link JAXBElement }{@code <}{@link MultiSurfaceType }{@code >}
     *     {@link JAXBElement }{@code <}{@link MultiCurveType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractGeometricAggregateType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractCurveType }{@code >}
     *     {@link JAXBElement }{@code <}{@link LineStringType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractGeometryType }{@code >}
     *     {@link JAXBElement }{@code <}{@link PolygonType }{@code >}
     *     {@link JAXBElement }{@code <}{@link SurfaceType }{@code >}
     *     {@link JAXBElement }{@code <}{@link MultiPointType }{@code >}
     *     {@link JAXBElement }{@code <}{@link CurveType }{@code >}
     *     {@link JAXBElement }{@code <}{@link PointType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractSurfaceType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractGeometricPrimitiveType }{@code >}
     *     
     */

    public void set_Geometry(JAXBElement<? extends AbstractGeometryType> value) {
        this.geometry = ((JAXBElement<? extends AbstractGeometryType> ) value);
    }

    /**
     * Gets the value of the multiCurve property.
     * 
     * @return
     *     possible object is
     *     {@link MultiCurveType }
     *     
     */

    public MultiCurveType getMultiCurve() {
        return multiCurve;
    }

    /**
     * Sets the value of the multiCurve property.
     * 
     * @param value
     *     allowed object is
     *     {@link MultiCurveType }
     *     
     */

    public void setMultiCurve(MultiCurveType value) {
        this.multiCurve = value;
    }

    /**
     * Gets the value of the exterior property.
     * 
     * @return
     *     possible object is
     *     {@link AbstractRingPropertyType }
     *     
     */

    public AbstractRingPropertyType getExterior() {
        return exterior;
    }

    /**
     * Sets the value of the exterior property.
     * 
     * @param value
     *     allowed object is
     *     {@link AbstractRingPropertyType }
     *     
     */

    public void setExterior(AbstractRingPropertyType value) {
        this.exterior = value;
    }

    /**
     * Gets the value of the interpolation property.
     * 
     * @return
     *     possible object is
     *     {@link SurfaceInterpolationType }
     *     
     */

    public SurfaceInterpolationType getInterpolation() {
        if (interpolation == null) {
            return SurfaceInterpolationType.PLANAR;
        } else {
            return interpolation;
        }
    }

    /**
     * Sets the value of the interpolation property.
     * 
     * @param value
     *     allowed object is
     *     {@link SurfaceInterpolationType }
     *     
     */

    public void setInterpolation(SurfaceInterpolationType value) {
        this.interpolation = value;
    }

    /**
     * Sets the value of the interiors property.
     * 
     * @param interiors
     *     allowed object is
     *     {@link AbstractRingPropertyType }
     *     
     */

    public void setInteriors(List<AbstractRingPropertyType> interiors) {
        this.interiors = interiors;
    }

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setValue(String value) {
        this.value = value;
    }

    /**
     * Gets the value of the codeSpace property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCodeSpace() {
        return codeSpace;
    }

    /**
     * Sets the value of the codeSpace property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCodeSpace(String value) {
        this.codeSpace = value;
    }

    /**
     * Create an instance of {@link BoundedBy }
     * 
     */

    public BoundedBy createBoundedBy() {
        return new BoundedBy();
    }

    /**
     * Create an instance of {@link LineStringSegmentType }
     * 
     */

    public LineStringSegmentType createLineStringSegmentType() {
        return new LineStringSegmentType();
    }

    /**
     * Create an instance of {@link MultiPointType }
     * 
     */

    public MultiPointType createMultiPointType() {
        return new MultiPointType();
    }

    /**
     * Create an instance of {@link Segments }
     * 
     */

    public Segments createSegments() {
        return new Segments();
    }

    /**
     * Create an instance of {@link MultiSurfacePropertyType }
     * 
     */

    public MultiSurfacePropertyType createMultiSurfacePropertyType() {
        return new MultiSurfacePropertyType();
    }

    /**
     * Create an instance of {@link PolygonPatchType }
     * 
     */

    public PolygonPatchType createPolygonPatchType() {
        return new PolygonPatchType();
    }

    /**
     * Create an instance of {@link GeometryPropertyType }
     * 
     */

    public GeometryPropertyType createGeometryPropertyType() {
        return new GeometryPropertyType();
    }

    /**
     * Create an instance of {@link MeasureType }
     * 
     */

    public MeasureType createMeasureType() {
        return new MeasureType();
    }

    /**
     * Create an instance of {@link PointType }
     * 
     */

    public PointType createPointType() {
        return new PointType();
    }

    /**
     * Create an instance of {@link PolygonType }
     * 
     */

    public PolygonType createPolygonType() {
        return new PolygonType();
    }

    /**
     * Create an instance of {@link CurveType }
     * 
     */

    public CurveType createCurveType() {
        return new CurveType();
    }

    /**
     * Create an instance of {@link PosList }
     * 
     */

    public PosList createPosList() {
        return new PosList();
    }

    /**
     * Create an instance of {@link AbstractRingPropertyType }
     * 
     */

    public AbstractRingPropertyType createAbstractRingPropertyType() {
        return new AbstractRingPropertyType();
    }

    /**
     * Create an instance of {@link PointMember }
     * 
     */

    public PointMember createPointMember() {
        return new PointMember();
    }

    /**
     * Create an instance of {@link LineStringType }
     * 
     */

    public LineStringType createLineStringType() {
        return new LineStringType();
    }

    /**
     * Create an instance of {@link MultiCurvePropertyType }
     * 
     */

    public MultiCurvePropertyType createMultiCurvePropertyType() {
        return new MultiCurvePropertyType();
    }

    /**
     * Create an instance of {@link MultiSurfaceType }
     * 
     */

    public MultiSurfaceType createMultiSurfaceType() {
        return new MultiSurfaceType();
    }

    /**
     * Create an instance of {@link ReferenceType }
     * 
     */

    public ReferenceType createReferenceType() {
        return new ReferenceType();
    }

    /**
     * Create an instance of {@link Patches }
     * 
     */

    public Patches createPatches() {
        return new Patches();
    }

    /**
     * Create an instance of {@link MultiPointPropertyType }
     * 
     */

    public MultiPointPropertyType createMultiPointPropertyType() {
        return new MultiPointPropertyType();
    }

    /**
     * Create an instance of {@link MultiGeometryPropertyType }
     * 
     */

    public MultiGeometryPropertyType createMultiGeometryPropertyType() {
        return new MultiGeometryPropertyType();
    }

    /**
     * Create an instance of {@link MultiCurveType }
     * 
     */

    public MultiCurveType createMultiCurveType() {
        return new MultiCurveType();
    }

    /**
     * Create an instance of {@link Pos }
     * 
     */

    public Pos createPos() {
        return new Pos();
    }

    /**
     * Create an instance of {@link SurfaceMember }
     * 
     */

    public SurfaceMember createSurfaceMember() {
        return new SurfaceMember();
    }

    /**
     * Create an instance of {@link SurfaceType }
     * 
     */

    public SurfaceType createSurfaceType() {
        return new SurfaceType();
    }

    /**
     * Create an instance of {@link LinearRingType }
     * 
     */

    public LinearRingType createLinearRingType() {
        return new LinearRingType();
    }

    /**
     * Create an instance of {@link AbstractFeatureBaseType }
     * 
     */

    public AbstractFeatureBaseType createAbstractFeatureBaseType() {
        return new AbstractFeatureBaseType();
    }

    /**
     * Create an instance of {@link AbstractSurfaceType }
     * 
     */

    public AbstractSurfaceType createAbstractSurfaceType() {
        return new AbstractSurfaceType();
    }

    /**
     * Create an instance of {@link Envelope }
     * 
     */

    public Envelope createEnvelope() {
        return new Envelope();
    }

    /**
     * Create an instance of {@link Name }
     * 
     */

    public Name createName() {
        return new Name();
    }

    /**
     * Create an instance of {@link CurveMember }
     * 
     */

    public CurveMember createCurveMember() {
        return new CurveMember();
    }

/**
 * Hack to get the grammar to leave a
 * EXECUTE STATEMENT <stmt> alone.  Short
 * circuit the ij EXECUTE built in.
 */

  final public ijResult JBMSPreparedStatementExec() throws ParseException, SQLException {
        Token s = null;
    jj_consume_token(EXECUTE);
    jj_consume_token(STATEMENT);
    s = jj_consume_token(STRING);
                {if (true) return executeImmediate(stringValue(s.image));}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getType() {
        if (type == null) {
            return "simple";
        } else {
            return type;
        }
    }

    /**
     * Sets the value of the type property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setType(String value) {
        this.type = value;
    }

    /**
     * Gets the value of the href property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getHref() {
        return href;
    }

    /**
     * Sets the value of the href property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setHref(String value) {
        this.href = value;
    }

    /**
     * Gets the value of the role property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getRole() {
        return role;
    }

    /**
     * Sets the value of the role property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setRole(String value) {
        this.role = value;
    }

    /**
     * Gets the value of the arcrole property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getArcrole() {
        return arcrole;
    }

    /**
     * Sets the value of the arcrole property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setArcrole(String value) {
        this.arcrole = value;
    }

    /**
     * Sets the value of the title property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setTitle(String value) {
        this.title = value;
    }

/**
 * Hack to get the grammar to leave a
 * EXECUTE PROCEDURE <procSpec> alone.  Short
 * circuit the ij EXECUTE built in so that
 * we can deploy ij against Foundation2000.
 */

  final public ijResult F2KExecuteProcedure() throws ParseException, SQLException {
        Token s = null;
    jj_consume_token(EXECUTE);
    jj_consume_token(PROCEDURE);
    s = jj_consume_token(STRING);
                haveConnection();

                Statement       aStatement = theConnection.createStatement();
                String          text = "execute procedure " + s;

                aStatement.execute( text );

                {if (true) return new ijStatementResult( aStatement,true );}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the show property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getShow() {
        return show;
    }

    /**
     * Sets the value of the show property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setShow(String value) {
        this.show = value;
    }

    /**
     * Gets the value of the actuate property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getActuate() {
        return actuate;
    }

    /**
     * Sets the value of the actuate property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setActuate(String value) {
        this.actuate = value;
    }

    /**
     * Gets the value of the multiSurface property.
     * 
     * @return
     *     possible object is
     *     {@link MultiSurfaceType }
     *     
     */

    public MultiSurfaceType getMultiSurface() {
        return multiSurface;
    }

    /**
     * Sets the value of the multiSurface property.
     * 
     * @param value
     *     allowed object is
     *     {@link MultiSurfaceType }
     *     
     */

    public void setMultiSurface(MultiSurfaceType value) {
        this.multiSurface = value;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setDescription(String value) {
        this.description = value;
    }

/**
 * Async: like execute immediate, without using,
 * but runs the statement in a separate thread, against
 * the current connection.
 * <p>
 * Syntax:
 *   ASYNC asyncName statementSource 
 *
 *	 statementSource is a string containing SQL-J text.
 */

  final public ijResult AsyncStatement() throws ParseException, SQLException {
        Token s = null;
        String n = null;
    jj_consume_token(ASYNC);
    n = identifier();
    s = jj_consume_token(STRING);
            {if (true) return executeAsync(stringValue(s.image), n);}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setId(String value) {
        this.id = value;
    }

    /**
     * Sets the value of the _GeometricAggregate property.
     * 
     * @param value
     *     allowed object is
     *     {@link JAXBElement }{@code <}{@link MultiCurveType }{@code >}
     *     {@link JAXBElement }{@code <}{@link MultiSurfaceType }{@code >}
     *     {@link JAXBElement }{@code <}{@link MultiPointType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractGeometricAggregateType }{@code >}
     *     
     */

    public void set_GeometricAggregate(JAXBElement<? extends AbstractGeometricAggregateType> value) {
        this.geometricAggregate = ((JAXBElement<? extends AbstractGeometricAggregateType> ) value);
    }

/**
 * Wait for: the second half of Async, waits for completion
 * if needed and then supplies the result.  Only execute is done,
 * not row fetching.
 * <p>
 * Syntax:
 *   WAIT FOR asyncName 
 *
 *	 asyncName is a name used in an ASYNC statement previously
 */

  final public ijResult WaitForStatement() throws ParseException, SQLException {
        Token s = null;
        String n = null;
    jj_consume_token(WAIT);
    jj_consume_token(FOR);
    n = identifier();
                AsyncStatement as = currentConnEnv.getSession().getAsyncStatement(n);
                if (as == null) {if (true) throw ijException.noSuchAsyncStatement(n);}
                try {
                    as.join(); // we wait for it to finish.
                } catch (InterruptedException ie) {
                        {if (true) throw ijException.waitInterrupted(ie);}
                }
                {if (true) return as.getResult();}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the multiPoint property.
     * 
     * @return
     *     possible object is
     *     {@link MultiPointType }
     *     
     */

    public MultiPointType getMultiPoint() {
        return multiPoint;
    }

/**
 * RemoveStatement is REMOVE identifier. It identifies
 * a previously prepared statement.  We would prefer a DROP
 * syntax, but SQL-J is using that word and I want to point out
 * that special processing will be needed to give that parser
 * this parser's input for unrecognized text.
 */

  final public ijResult RemoveStatement() throws ParseException, SQLException {
        String i;
        PreparedStatement ps;
    jj_consume_token(REMOVE);
    i = identifier();
                haveConnection();
                Session s = currentConnEnv.getSession();
                ps = (PreparedStatement) s.getPreparedStatement(i);
                JDBCDisplayUtil.checkNotNull(ps,"prepared statement "+i);
                ps.close();
                s.removePreparedStatement(i);

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the multiPoint property.
     * 
     * @param value
     *     allowed object is
     *     {@link MultiPointType }
     *     
     */

    public void setMultiPoint(MultiPointType value) {
        this.multiPoint = value;
    }

    /**
     * Sets the value of the segments property.
     * 
     * @param value
     *     allowed object is
     *     {@link Segments }
     *     
     */

    public void setSegments(Segments value) {
        this.segments = value;
    }

    /**
     * Sets the value of the _Surface property.
     * 
     * @param value
     *     allowed object is
     *     {@link JAXBElement }{@code <}{@link PolygonType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractSurfaceType }{@code >}
     *     {@link JAXBElement }{@code <}{@link SurfaceType }{@code >}
     *     
     */

    public void set_Surface(JAXBElement<? extends AbstractSurfaceType> value) {
        this.surface = ((JAXBElement<? extends AbstractSurfaceType> ) value);
    }

    /**
     * Gets the value of the envelope property.
     * 
     * @return
     *     possible object is
     *     {@link Envelope }
     *     
     */

    public Envelope getEnvelope() {
        return envelope;
    }

    /**
     * Sets the value of the envelope property.
     * 
     * @param value
     *     allowed object is
     *     {@link Envelope }
     *     
     */

    public void setEnvelope(Envelope value) {
        this.envelope = value;
    }

    /**
     * Sets the value of the _SurfacePatches property.
     * 
     * @param surfacePatches
     *     allowed object is
     *     {@link JAXBElement }{@code <}{@link AbstractSurfacePatchType }{@code >}
     *     {@link JAXBElement }{@code <}{@link PolygonPatchType }{@code >}
     *     
     */

    public void set_SurfacePatches(List<JAXBElement<? extends AbstractSurfacePatchType>> surfacePatches) {
        this.surfacePatches = surfacePatches;
    }

/**
 * Autocommit lets you control this aspect of the connection.
 * REMIND: should have a general way to set all connection attributes,
 * this is a shortcut for immediate needs.
 * <p>
 * Syntax:
 *   AUTOCOMMIT [ ON | OFF ] ;
 */

  final public ijResult AutocommitStatement() throws ParseException, SQLException {
        Token on=null;
    jj_consume_token(AUTOCOMMIT);
    if (jj_2_87(2)) {
      on = jj_consume_token(ON);
    } else if (jj_2_88(2)) {
      jj_consume_token(OFF);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                haveConnection();
                // REMIND: want to warn if unchanged?
                theConnection.setAutoCommit((on==null?false:true));

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the boundedBy property.
     * 
     * @return
     *     possible object is
     *     {@link BoundedBy }
     *     
     */

    public BoundedBy getBoundedBy() {
        return boundedBy;
    }

    /**
     * Sets the value of the boundedBy property.
     * 
     * @param value
     *     allowed object is
     *     {@link BoundedBy }
     *     
     */

    public void setBoundedBy(BoundedBy value) {
        this.boundedBy = value;
    }

    /**
     * Sets the value of the patches property.
     * 
     * @param value
     *     allowed object is
     *     {@link Patches }
     *     
     */

    public void setPatches(Patches value) {
        this.patches = value;
    }

    /**
     * Sets the value of the _Curve property.
     * 
     * @param value
     *     allowed object is
     *     {@link JAXBElement }{@code <}{@link CurveType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractCurveType }{@code >}
     *     {@link JAXBElement }{@code <}{@link LineStringType }{@code >}
     *     
     */

    public void set_Curve(JAXBElement<? extends AbstractCurveType> value) {
        this.curve = ((JAXBElement<? extends AbstractCurveType> ) value);
    }

/**
 * By default, holdability is set to true for Connection objects. This syntax NOHOLDFORCONNECTION lets you set it to close cursors at commit.
 * Syntax:
 *   NOHOLDFORCONNECTION ;
 */

  final public ijResult NoHoldForConnectionStatement() throws ParseException, SQLException {
        Token on=null;
    jj_consume_token(NOHOLDFORCONNECTION);
                haveConnection();
                theConnection = utilInstance.setHoldability(theConnection, JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the posList property.
     * 
     * @return
     *     possible object is
     *     {@link PosList }
     *     
     */

    public PosList getPosList() {
        return posList;
    }

    /**
     * Sets the value of the posList property.
     * 
     * @param value
     *     allowed object is
     *     {@link PosList }
     *     
     */

    public void setPosList(PosList value) {
        this.posList = value;
    }

    /**
     * Gets the value of the interpolation property.
     * 
     * @return
     *     possible object is
     *     {@link CurveInterpolationType }
     *     
     */

    public CurveInterpolationType getInterpolation() {
        if (interpolation == null) {
            return CurveInterpolationType.LINEAR;
        } else {
            return interpolation;
        }
    }

    /**
     * Sets the value of the interpolation property.
     * 
     * @param value
     *     allowed object is
     *     {@link CurveInterpolationType }
     *     
     */

    public void setInterpolation(CurveInterpolationType value) {
        this.interpolation = value;
    }

/**
 * Localizeddisplay controls locale sensitive data representayion
 * <p>
 * Syntax:
 *   LOCALIZEDDISPLAY [ ON | OFF ] ;
 */

  final public ijResult LocalizedDisplay() throws ParseException {
        Token on=null;
    jj_consume_token(LOCALIZEDDISPLAY);
    if (jj_2_89(2)) {
      on = jj_consume_token(ON);
    } else if (jj_2_90(2)) {
      jj_consume_token(OFF);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                LocalizedResource.enableLocalization((on==null?false:true));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the surfaceMembers property.
     * 
     * @param surfaceMembers
     *     allowed object is
     *     {@link SurfaceMember }
     *     
     */

    public void setSurfaceMembers(List<SurfaceMember> surfaceMembers) {
        this.surfaceMembers = surfaceMembers;
    }

/**
 * ReadOnly lets you control this aspect of the connection.
 * REMIND: should have a general way to set all connection attributes,
 * this is a shortcut for immediate needs.
 * <p>
 * Syntax:
 *   READONLY [ ON | OFF ] ;
 */

  final public ijResult ReadOnlyStatement() throws ParseException, SQLException {
        Token on=null;
    jj_consume_token(READONLY);
    if (jj_2_91(2)) {
      on = jj_consume_token(ON);
    } else if (jj_2_92(2)) {
      jj_consume_token(OFF);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                haveConnection();
                theConnection.setReadOnly((on==null?false:true));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the curveMembers property.
     * 
     * @param curveMembers
     *     allowed object is
     *     {@link CurveMember }
     *     
     */

    public void setCurveMembers(List<CurveMember> curveMembers) {
        this.curveMembers = curveMembers;
    }

    /**
     * Gets the value of the value property.
     * 
     */

    public double getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     */

    public void setValue(double value) {
        this.value = value;
    }

    /**
     * Gets the value of the uom property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getUom() {
        return uom;
    }

    /**
     * Sets the value of the uom property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setUom(String value) {
        this.uom = value;
    }

/**
 * Elapsedtime on causes ij to dump out the elapsed time it takes
 * to run a user statement at the end of that statement.
 * <p>
 * Syntax:
 *   ELAPSEDTIME [ ON | OFF ] ;
 */

  final public ijResult ElapsedTimeStatement() throws ParseException {
        Token on=null;
    jj_consume_token(ELAPSEDTIME);
    if (jj_2_93(2)) {
      on = jj_consume_token(ON);
    } else if (jj_2_94(2)) {
      jj_consume_token(OFF);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
                elapsedTime = (on != null);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the lowerCorner property.
     * 
     * @return
     *     possible object is
     *     {@link Pos }
     *     
     */

    public Pos getLowerCorner() {
        return lowerCorner;
    }

    /**
     * Sets the value of the lowerCorner property.
     * 
     * @param value
     *     allowed object is
     *     {@link Pos }
     *     
     */

    public void setLowerCorner(Pos value) {
        this.lowerCorner = value;
    }

/**
 * MaximumDisplayWidth EXACT_NUMERIC changes the maximum display width for
 * java.lang.String to the specified EXACT_NUMERIC.
 * This is only used by the console view.
 * <p>
 * Syntax:
 *   MAXIMUMDISPLAYWIDTH INTEGER ;
 */

  final public ijResult MaximumDisplayWidthStatement() throws ParseException {
        int       maxWidth;
    jj_consume_token(MAXIMUMDISPLAYWIDTH);
    maxWidth = intValue();
                JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the upperCorner property.
     * 
     * @return
     *     possible object is
     *     {@link Pos }
     *     
     */

    public Pos getUpperCorner() {
        return upperCorner;
    }

    /**
     * Sets the value of the upperCorner property.
     * 
     * @param value
     *     allowed object is
     *     {@link Pos }
     *     
     */

    public void setUpperCorner(Pos value) {
        this.upperCorner = value;
    }

    /**
     * Gets the value of the linearRing property.
     * 
     * @return
     *     possible object is
     *     {@link LinearRingType }
     *     
     */

    public LinearRingType getLinearRing() {
        return linearRing;
    }

    /**
     * Sets the value of the linearRing property.
     * 
     * @param value
     *     allowed object is
     *     {@link LinearRingType }
     *     
     */

    public void setLinearRing(LinearRingType value) {
        this.linearRing = value;
    }

    /**
     * Sets the value of the _CurveSegments property.
     * 
     * @param curveSegments
     *     allowed object is
     *     {@link JAXBElement }{@code <}{@link LineStringSegmentType }{@code >}
     *     {@link JAXBElement }{@code <}{@link AbstractCurveSegmentType }{@code >}
     *     
     */

    public void set_CurveSegments(List<JAXBElement<? extends AbstractCurveSegmentType>> curveSegments) {
        this.curveSegments = curveSegments;
    }

	/**
	 * Apply a given remark to a value
	 */

	public void applyRemark(TridasValue value) {
		TridasRemark remark = asTridasRemark();

		// first, remove any remarks
		removeRemarkFromValue(remark, value);
		
		// add the remark
		value.getRemarks().add(remark);
	}

	/**
	 * Check if a remark is set on a given value
	 */

	public boolean isRemarkSet(TridasValue value) {
		TridasRemark remark = asTridasRemark();
		
		for(TridasRemark aRemark : value.getRemarks()) {	
			if(RemarkEquals.remarksEqual(remark, aRemark)) {
				// must test for special 'disabled override'
				if(aRemark.isSetInheritedCount() && aRemark.getInheritedCount() < 0)
					return false;
				
				return true;
			}
		}
		
		return false;
	}

	/**
	 * Check if a remark is inherited
	 */

	public boolean isRemarkInherited(TridasValue value) {
		TridasRemark remark = asTridasRemark();
		
		for(TridasRemark aRemark : value.getRemarks()) {	
			if(RemarkEquals.remarksEqual(remark, aRemark)) {
				// get the inherited count from the remark associated with the value
				return (aRemark.isSetInheritedCount() && aRemark.getInheritedCount() > 0) ? true : false;
			}
		}
		
		return false;
	}

	/**
	 * Force override a remark from a given value
	 */

	public void overrideRemark(TridasValue value) {
		TridasRemark source = asTridasRemark();
		
		// create a copy of the remark, as we're going to be modifying it
		TridasRemark remark = (TridasRemark) source.createCopy();
		source.copyTo(remark);

		// first, remove any remarks
		removeRemarkFromValue(remark, value);
		
		// flag the new remark as disabled
		remark.setInheritedCount(-1);
		
		// add the remark
		value.getRemarks().add(remark);
	}

	/**
	 * Remove a remark
	 */

	public void removeRemark(TridasValue value) {
		removeRemarkFromValue(asTridasRemark(), value);
	}

	/**
	 * Remove all TridasRemarks 'remark' from the given value
	 * @param remark
	 * @param value
	 */

	protected void removeRemarkFromValue(TridasRemark remark, TridasValue value) {
		ListIterator<TridasRemark> remarkIterator = value.getRemarks().listIterator();
		
		while(remarkIterator.hasNext()) {
			TridasRemark aRemark = remarkIterator.next();
			
			if(RemarkEquals.remarksEqual(remark, aRemark))
				remarkIterator.remove();
		}
	}

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setName(String value) {
        this.name = value;
    }

    /**
     * Gets the value of the isActive property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */

    public boolean isIsActive() {
        return isActive;
    }

    /**
     * Sets the value of the isActive property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */

    public void setIsActive(boolean value) {
        this.isActive = value;
    }

    /**
     * Sets the value of the measurementVariables property.
     * 
     * @param measurementVariables
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setMeasurementVariables(List<ControlledVoc> measurementVariables) {
        this.measurementVariables = measurementVariables;
    }

    /**
     * Sets the value of the elementShapes property.
     * 
     * @param elementShapes
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setElementShapes(List<ControlledVoc> elementShapes) {
        this.elementShapes = elementShapes;
    }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getType() {
        return type;
    }

    /**
     * Gets the value of the object property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getObject() {
        return object;
    }

    /**
     * Sets the value of the object property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setObject(String value) {
        this.object = value;
    }

    /**
     * Sets the value of the datingTypes property.
     * 
     * @param datingTypes
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setDatingTypes(List<ControlledVoc> datingTypes) {
        this.datingTypes = datingTypes;
    }

    /**
     * Sets the value of the coverageTemporals property.
     * 
     * @param coverageTemporals
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setCoverageTemporals(List<ControlledVoc> coverageTemporals) {
        this.coverageTemporals = coverageTemporals;
    }

    /**
     * Create an instance of {@link WSISapwoodDictionary }
     * 
     */

    public WSISapwoodDictionary createWSISapwoodDictionary() {
        return new WSISapwoodDictionary();
    }

    /**
     * Create an instance of {@link WSIParam }
     * 
     */

    public WSIParam createWSIParam() {
        return new WSIParam();
    }

    /**
     * Create an instance of {@link WSIBox }
     * 
     */

    public WSIBox createWSIBox() {
        return new WSIBox();
    }

    /**
     * Create an instance of {@link WSIRequest }
     * 
     */

    public WSIRequest createWSIRequest() {
        return new WSIRequest();
    }

    /**
     * Create an instance of {@link WSISearchParams }
     * 
     */

    public WSISearchParams createWSISearchParams() {
        return new WSISearchParams();
    }

    /**
     * Create an instance of {@link WSIRegionDictionary }
     * 
     */

    public WSIRegionDictionary createWSIRegionDictionary() {
        return new WSIRegionDictionary();
    }

    /**
     * Create an instance of {@link WSISecurityUserDictionary }
     * 
     */

    public WSISecurityUserDictionary createWSISecurityUserDictionary() {
        return new WSISecurityUserDictionary();
    }

/**
	Haven't included: ASYNC, !, EXPECT
	Don't include: XA_*
 **/

  final public ijResult HelpStatement() throws ParseException {
    jj_consume_token(HELP);
                Vector v = new Vector();

                StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage("IJ_HelpText"), "\n");
                while (st.hasMoreTokens()) {
                    v.addElement(st.nextToken());
                }

                {if (true) return new ijVectorResult(v,null);}
    throw new Error("Missing return statement in function");
  }

    /**
     * Create an instance of {@link WSIHeartwoodDictionary }
     * 
     */

    public WSIHeartwoodDictionary createWSIHeartwoodDictionary() {
        return new WSIHeartwoodDictionary();
    }

    /**
     * Create an instance of {@link WSIRootElement }
     * 
     */

    public WSIRootElement createWSIRootElement() {
        return new WSIRootElement();
    }

    /**
     * Create an instance of {@link WSINonce }
     * 
     */

    public WSINonce createWSINonce() {
        return new WSINonce();
    }

    /**
     * Create an instance of {@link WSIMessage }
     * 
     */

    public WSIMessage createWSIMessage() {
        return new WSIMessage();
    }

    /**
     * Create an instance of {@link WSIBoxDictionary }
     * 
     */

    public WSIBoxDictionary createWSIBoxDictionary() {
        return new WSIBoxDictionary();
    }

    /**
     * Create an instance of {@link WSIElementAuthenticityDictionary }
     * 
     */

    public WSIElementAuthenticityDictionary createWSIElementAuthenticityDictionary() {
        return new WSIElementAuthenticityDictionary();
    }

    /**
     * Create an instance of {@link WSIEntity }
     * 
     */

    public WSIEntity createWSIEntity() {
        return new WSIEntity();
    }

    /**
     * Create an instance of {@link WSIHelp }
     * 
     */

    public WSIHelp createWSIHelp() {
        return new WSIHelp();
    }

    /**
     * Create an instance of {@link WSIHeader }
     * 
     */

    public WSIHeader createWSIHeader() {
        return new WSIHeader();
    }

    /**
     * Create an instance of {@link WSILocationTypeDictionary }
     * 
     */

    public WSILocationTypeDictionary createWSILocationTypeDictionary() {
        return new WSILocationTypeDictionary();
    }

    /**
     * Create an instance of {@link WSIAuthenticate }
     * 
     */

    public WSIAuthenticate createWSIAuthenticate() {
        return new WSIAuthenticate();
    }

    /**
     * Create an instance of {@link WSIElementTypeDictionary }
     * 
     */

    public WSIElementTypeDictionary createWSIElementTypeDictionary() {
        return new WSIElementTypeDictionary();
    }

    /**
     * Create an instance of {@link WSILink }
     * 
     */

    public WSILink createWSILink() {
        return new WSILink();
    }

    /**
     * Create an instance of {@link WSISampleTypeDictionary }
     * 
     */

    public WSISampleTypeDictionary createWSISampleTypeDictionary() {
        return new WSISampleTypeDictionary();
    }

    /**
     * Create an instance of {@link WSIElementShapeDictionary }
     * 
     */

    public WSIElementShapeDictionary createWSIElementShapeDictionary() {
        return new WSIElementShapeDictionary();
    }

    /**
     * Create an instance of {@link WSIReadingNoteDictionary }
     * 
     */

    public WSIReadingNoteDictionary createWSIReadingNoteDictionary() {
        return new WSIReadingNoteDictionary();
    }

    /**
     * Create an instance of {@link WSIDatingTypeDictionary }
     * 
     */

    public WSIDatingTypeDictionary createWSIDatingTypeDictionary() {
        return new WSIDatingTypeDictionary();
    }

    /**
     * Create an instance of {@link WSICoverageTemporalFoundationDictionary }
     * 
     */

    public WSICoverageTemporalFoundationDictionary createWSICoverageTemporalFoundationDictionary() {
        return new WSICoverageTemporalFoundationDictionary();
    }

    /**
     * Create an instance of {@link WSITaxonDictionary }
     * 
     */

    public WSITaxonDictionary createWSITaxonDictionary() {
        return new WSITaxonDictionary();
    }

    /**
     * Create an instance of {@link WSIContent }
     * 
     */

    public WSIContent createWSIContent() {
        return new WSIContent();
    }

    /**
     * Create an instance of {@link WSIMeasurementVariableDictionary }
     * 
     */

    public WSIMeasurementVariableDictionary createWSIMeasurementVariableDictionary() {
        return new WSIMeasurementVariableDictionary();
    }

    /**
     * Create an instance of {@link WSIObjectTypeDictionary }
     * 
     */

    public WSIObjectTypeDictionary createWSIObjectTypeDictionary() {
        return new WSIObjectTypeDictionary();
    }

    /**
     * Create an instance of {@link SecurityGroup }
     * 
     */

    public SecurityGroup createSecurityGroup() {
        return new SecurityGroup();
    }

    /**
     * Create an instance of {@link WSICoverageTemporalDictionary }
     * 
     */

    public WSICoverageTemporalDictionary createWSICoverageTemporalDictionary() {
        return new WSICoverageTemporalDictionary();
    }

    /**
     * Create an instance of {@link SecurityUser }
     * 
     */

    public SecurityUser createSecurityUser() {
        return new SecurityUser();
    }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link EntityType }
     *     
     */

    public EntityType getType() {
        return type;
    }

    /**
     * Sets the value of the type property.
     * 
     * @param value
     *     allowed object is
     *     {@link EntityType }
     *     
     */

    public void setType(EntityType value) {
        this.type = value;
    }

    /**
     * Sets the value of the sqlsAndObjectsAndElements property.
     * 
     * @param sqlsAndObjectsAndElements
     *     allowed object is
     *     {@link WSISampleTypeDictionary }
     *     {@link WSICoverageTemporalFoundationDictionary }
     *     {@link WSIElementAuthenticityDictionary }
     *     {@link WSIHeartwoodDictionary }
     *     {@link WSIRegionDictionary }
     *     {@link WSICoverageTemporalDictionary }
     *     {@link TridasSample }
     *     {@link WSIElementTypeDictionary }
     *     {@link WSIReadingNoteDictionary }
     *     {@link WSIBoxDictionary }
     *     {@link WSIMeasurementVariableDictionary }
     *     {@link WSIDatingTypeDictionary }
     *     {@link WSISapwoodDictionary }
     *     {@link WSITaxonDictionary }
     *     {@link TridasRadius }
     *     {@link WSISecurityUserDictionary }
     *     {@link SecurityUser }
     *     {@link TridasElement }
     *     {@link TridasObject }
     *     {@link WSILocationTypeDictionary }
     *     {@link WSIBox }
     *     {@link WSIObjectTypeDictionary }
     *     {@link Object }
     *     {@link TridasMeasurementSeries }
     *     {@link WSIElementShapeDictionary }
     *     {@link TridasDerivedSeries }
     *     
     */

    public void setSqlsAndObjectsAndElements(List<Object> sqlsAndObjectsAndElements) {
        this.sqlsAndObjectsAndElements = sqlsAndObjectsAndElements;
    }

    /**
     * Gets the value of the identifier property.
     * 
     * @return
     *     possible object is
     *     {@link TridasIdentifier }
     *     
     */

    public TridasIdentifier getIdentifier() {
        return identifier;
    }

    /**
     * Sets the value of the identifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasIdentifier }
     *     
     */

    public void setIdentifier(TridasIdentifier value) {
        this.identifier = value;
    }

    /**
     * Gets the value of the createdTimestamp property.
     * 
     * @return
     *     possible object is
     *     {@link DateTime }
     *     
     */

    public DateTime getCreatedTimestamp() {
        return createdTimestamp;
    }

    /**
     * Sets the value of the createdTimestamp property.
     * 
     * @param value
     *     allowed object is
     *     {@link DateTime }
     *     
     */

    public void setCreatedTimestamp(DateTime value) {
        this.createdTimestamp = value;
    }

    /**
     * Gets the value of the lastModifiedTimestamp property.
     * 
     * @return
     *     possible object is
     *     {@link DateTime }
     *     
     */

    public DateTime getLastModifiedTimestamp() {
        return lastModifiedTimestamp;
    }

    /**
     * Sets the value of the lastModifiedTimestamp property.
     * 
     * @param value
     *     allowed object is
     *     {@link DateTime }
     *     
     */

    public void setLastModifiedTimestamp(DateTime value) {
        this.lastModifiedTimestamp = value;
    }

    /**
     * Gets the value of the comments property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getComments() {
        return comments;
    }

    /**
     * Sets the value of the comments property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setComments(String value) {
        this.comments = value;
    }

    /**
     * Gets the value of the trackingLocation property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getTrackingLocation() {
        return trackingLocation;
    }

    /**
     * Sets the value of the trackingLocation property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setTrackingLocation(String value) {
        this.trackingLocation = value;
    }

    /**
     * Gets the value of the curationLocation property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCurationLocation() {
        return curationLocation;
    }

    /**
     * Sets the value of the curationLocation property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCurationLocation(String value) {
        this.curationLocation = value;
    }

    /**
     * Gets the value of the sampleCount property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getSampleCount() {
        return sampleCount;
    }

    /**
     * Sets the value of the sampleCount property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setSampleCount(Integer value) {
        this.sampleCount = value;
    }

    /**
     * Sets the value of the samples property.
     * 
     * @param samples
     *     allowed object is
     *     {@link TridasSample }
     *     
     */

    public void setSamples(List<TridasSample> samples) {
        this.samples = samples;
    }

    /**
     * Sets the value of the elementTypes property.
     * 
     * @param elementTypes
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setElementTypes(List<ControlledVoc> elementTypes) {
        this.elementTypes = elementTypes;
    }

    /**
     * Sets the value of the regions property.
     * 
     * @param regions
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setRegions(List<ControlledVoc> regions) {
        this.regions = regions;
    }

    /**
     * Sets the value of the dictionaries property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIRequest.Dictionaries }
     *     
     */

    public void setDictionaries(WSIRequest.Dictionaries value) {
        this.dictionaries = value;
    }

/**
 * XA_DataSourceStatement is XA_DataSource 'dbname' ( create | shutdown )
 * We new'ed an instance of XADataSource as the current DataSource and set its
 * database name to dbname.
 */

  final public ijResult XA_DataSourceStatement() throws ParseException, SQLException {
        Token dbname = null;
        Token shut = null;
        String create = null;
    jj_consume_token(XA_DATASOURCE);
    dbname = jj_consume_token(STRING);
    if (jj_2_105(2)) {
      if (jj_2_103(2)) {
        shut = jj_consume_token(SHUTDOWN);
      } else if (jj_2_104(2)) {
        create = identifier();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
                xahelper.XADataSourceStatement(this, dbname, shut, create);

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_ConnectStatement is XA_CONNECT (<AS> connid)
 * make a XAConnection using the currentXADataSource and make that XAConnection
 * the current XAConnection.  If connid is given, then associate connid with
 * the XAConnection.  This connid is not th xid.
 */

  final public ijResult XA_ConnectStatement() throws ParseException, SQLException {
        Token userT = null;
        Token passwordT = null;
        String n = null;
    jj_consume_token(XA_CONNECT);
    if (jj_2_106(2)) {
      jj_consume_token(USER);
      userT = jj_consume_token(STRING);
    } else {
      ;
    }
    if (jj_2_107(2)) {
      jj_consume_token(PASSWORD);
      passwordT = jj_consume_token(STRING);
    } else {
      ;
    }
    if (jj_2_108(2)) {
      jj_consume_token(AS);
      n = identifier();
    } else {
      ;
    }
                xahelper.XAConnectStatement(this, userT, passwordT, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_DisconnectStatement is XA_DISCONNECT [xaconnid = identifier()]
 * disconnect the current XAConnection 
 * If xaconnid is given, then disconnect XAConnection with xaconnid (xaconnid
 *	not implemented).
 * 
 */

  final public ijResult XA_DisconnectStatement() throws ParseException, SQLException {
        String n = null;
    jj_consume_token(XA_DISCONNECT);
    if (jj_2_109(2)) {
      n = identifier();
    } else {
      ;
    }
                xahelper.XADisconnectStatement(this, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_CommitStatement is XA_COMMIT [ XA_1PHASE | XA_2PHASE ] xid
 * commits a global transaction xid
 */

  final public ijResult XA_CommitStatement() throws ParseException, SQLException {
        Token onePhase=null;
        Token twoPhase=null;
        int xid = 0;
    jj_consume_token(XA_COMMIT);
    if (jj_2_110(2)) {
      onePhase = jj_consume_token(XA_1PHASE);
    } else if (jj_2_111(2)) {
      twoPhase = jj_consume_token(XA_2PHASE);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    xid = intValue();
                xahelper.CommitStatement(this, onePhase, twoPhase, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_EndStatement is XA_END [ XA_SUSPEND | XA_SUCCESS | XA_FAIL] xid
 * dissociates a transaction from the current XAConnection or end an already
 * suspended one
 */

  final public ijResult XA_EndStatement() throws ParseException, SQLException {
        int flag = 0;
        int xid = 0;
    jj_consume_token(XA_END);
    flag = xatmflag();
    xid = intValue();
                xahelper.EndStatement(this, flag, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the authenticate property.
     * 
     * @return
     *     possible object is
     *     {@link WSIAuthenticate }
     *     
     */

    public WSIAuthenticate getAuthenticate() {
        return authenticate;
    }

/**
 * XA_ForgetStatement is XA_FORGET xid
 * forgets about a heuristically completed transaction
 */

  final public ijResult XA_ForgetStatement() throws ParseException, SQLException {
        int xid = 0;
    jj_consume_token(XA_FORGET);
    xid = intValue();
                xahelper.ForgetStatement(this, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the authenticate property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIAuthenticate }
     *     
     */

    public void setAuthenticate(WSIAuthenticate value) {
        this.authenticate = value;
    }

    /**
     * Gets the value of the searchParams property.
     * 
     * @return
     *     possible object is
     *     {@link WSISearchParams }
     *     
     */

    public WSISearchParams getSearchParams() {
        return searchParams;
    }

    /**
     * Sets the value of the searchParams property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSISearchParams }
     *     
     */

    public void setSearchParams(WSISearchParams value) {
        this.searchParams = value;
    }

/**
 * XA_GetConnectionStatement is XA_GETCONNECTION
 * it gets a Connection from the currentXAConnection and uses that as the
 * current connection 
 */

  final public ijResult XA_GetConnectionStatement() throws ParseException, SQLException {
        String n = "XA";
    jj_consume_token(XA_GETCONNECTION);
    if (jj_2_112(2)) {
      jj_consume_token(AS);
      n = identifier();
    } else {
      ;
    }
                theConnection = xahelper.XAGetConnectionStatement(this, n);
                currentConnEnv.addSession(theConnection, n);

                {if (true) return new ijConnectionResult(theConnection);}
    throw new Error("Missing return statement in function");
  }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link CorinaRequestType }
     *     
     */

    public CorinaRequestType getType() {
        return type;
    }

    /**
     * Sets the value of the type property.
     * 
     * @param value
     *     allowed object is
     *     {@link CorinaRequestType }
     *     
     */

    public void setType(CorinaRequestType value) {
        this.type = value;
    }

    /**
     * Gets the value of the format property.
     * 
     * @return
     *     possible object is
     *     {@link CorinaRequestFormat }
     *     
     */

    public CorinaRequestFormat getFormat() {
        return format;
    }

    /**
     * Sets the value of the format property.
     * 
     * @param value
     *     allowed object is
     *     {@link CorinaRequestFormat }
     *     
     */

    public void setFormat(CorinaRequestFormat value) {
        this.format = value;
    }

    /**
     * Gets the value of the parentEntityID property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getParentEntityID() {
        return parentEntityID;
    }

    /**
     * Sets the value of the parentEntityID property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setParentEntityID(String value) {
        this.parentEntityID = value;
    }

/**
 * XA_RecoverStatement is XA_RECOVER flag
 * displays the list of prepared transactions
 */

  final public ijResult XA_RecoverStatement() throws ParseException, SQLException {
        int flag = 0;
    jj_consume_token(XA_RECOVER);
    flag = xatmflag();
                {if (true) return xahelper.RecoverStatement(this, flag);}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the projects property.
     * 
     * @param projects
     *     allowed object is
     *     {@link TridasProject }
     *     
     */

    public void setProjects(List<TridasProject> projects) {
        this.projects = projects;
    }

    /**
     * Sets the value of the objects property.
     * 
     * @param objects
     *     allowed object is
     *     {@link TridasObject }
     *     
     */

    public void setObjects(List<TridasObject> objects) {
        this.objects = objects;
    }

    /**
     * Sets the value of the elements property.
     * 
     * @param elements
     *     allowed object is
     *     {@link TridasElement }
     *     
     */

    public void setElements(List<TridasElement> elements) {
        this.elements = elements;
    }

/**
 * XA_RollbackStatement is XA_Rollback xid
 * rolls back a global transaction
 */

  final public ijResult XA_RollbackStatement() throws ParseException, SQLException {
        int xid = 0;
    jj_consume_token(XA_ROLLBACK);
    xid = intValue();
                xahelper.RollbackStatement(this, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the radiuses property.
     * 
     * @param radiuses
     *     allowed object is
     *     {@link TridasRadius }
     *     
     */

    public void setRadiuses(List<TridasRadius> radiuses) {
        this.radiuses = radiuses;
    }

    /**
     * Sets the value of the measurementSeries property.
     * 
     * @param measurementSeries
     *     allowed object is
     *     {@link TridasMeasurementSeries }
     *     
     */

    public void setMeasurementSeries(List<TridasMeasurementSeries> measurementSeries) {
        this.measurementSeries = measurementSeries;
    }

/**
 * XA_StartStatement is XA_START [ XA_NOFLAGS | XA_JOIN | XA_RESUME ] xid
 * start or associates a transaction with the current XAConnection
 */

  final public ijResult XA_StartStatement() throws ParseException, SQLException {
        int flag = 0;
        int xid = 0;
    jj_consume_token(XA_START);
    flag = xatmflag();
    xid = intValue();
                xahelper.StartStatement(this, flag, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the derivedSeries property.
     * 
     * @param derivedSeries
     *     allowed object is
     *     {@link TridasDerivedSeries }
     *     
     */

    public void setDerivedSeries(List<TridasDerivedSeries> derivedSeries) {
        this.derivedSeries = derivedSeries;
    }

    /**
     * Sets the value of the users property.
     * 
     * @param users
     *     allowed object is
     *     {@link SecurityUser }
     *     
     */

    public void setUsers(List<SecurityUser> users) {
        this.users = users;
    }

    /**
     * Sets the value of the boxes property.
     * 
     * @param boxes
     *     allowed object is
     *     {@link WSIBox }
     *     
     */

    public void setBoxes(List<WSIBox> boxes) {
        this.boxes = boxes;
    }

    /**
     * Sets the value of the entities property.
     * 
     * @param entities
     *     allowed object is
     *     {@link WSIEntity }
     *     
     */

    public void setEntities(List<WSIEntity> entities) {
        this.entities = entities;
    }

/**
 * CP_DataSourceStatement is
 *	CP_DataSource 'dbname' [ <PROTOCOL> 'protocol' ]
 *		- get a connection pool data source whose database name is
 *		dbname and make that DataSource the current CPDataSource.  
 *		If <PROTOCOL> is specified, the DataSource may be
 *		remote.
 */

  final public ijResult CP_DataSourceStatement() throws ParseException, SQLException {
        Token dbname = null;
        Token protocol = null;
    jj_consume_token(CP_DATASOURCE);
    dbname = jj_consume_token(STRING);
    if (jj_2_125(2)) {
      jj_consume_token(PROTOCOL);
      protocol = jj_consume_token(STRING);
    } else {
      ;
    }
                xahelper.CPDataSourceStatement(this, dbname, protocol);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * CP_ConnectStatement is
 *	<CP_CONNECT>	[ <USER> 'user' ]
 *			[ <PASSWORD> 'password' ]
 *			[ <AS> cpconnid ]
 * make a PooledConnection using the current CPDataSource and
 * make that PooledConnection the current PooledConnection.
 * If cpconnid is given, then associate cpconnid with the
 * PooledConnection. (cpconnid not implemented).
 */

  final public ijResult CP_ConnectStatement() throws ParseException, SQLException {
        Token userT = null;
        Token passwordT = null;
        String n = null;
    jj_consume_token(CP_CONNECT);
    if (jj_2_126(2)) {
      jj_consume_token(USER);
      userT = jj_consume_token(STRING);
    } else {
      ;
    }
    if (jj_2_127(2)) {
      jj_consume_token(PASSWORD);
      passwordT = jj_consume_token(STRING);
    } else {
      ;
    }
    if (jj_2_128(2)) {
      jj_consume_token(AS);
      n = identifier();
    } else {
      ;
    }
                xahelper.CPConnectStatement(this, userT, passwordT, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * CP_GetConnectionStatement is
 *	<CP_GETCONNECTION> [ <AS> connid ]
 * get a Connection object from the current PooledConnection.
 * If connid is given, the associate connid with the connection.
 * (connid not implemented)
 */

  final public ijResult CP_GetConnectionStatement() throws ParseException, SQLException {
        String n = "Pooled";
    jj_consume_token(CP_GETCONNECTION);
    if (jj_2_129(2)) {
      jj_consume_token(AS);
      n = identifier();
    } else {
      ;
    }
                theConnection = xahelper.CPGetConnectionStatement(this, n);
                currentConnEnv.addSession(theConnection, n);
                {if (true) return new ijConnectionResult(theConnection);}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the taxons property.
     * 
     * @param taxons
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setTaxons(List<ControlledVoc> taxons) {
        this.taxons = taxons;
    }

/**
 * CP_DisconnectStatement is
 *	<CP_DISCONNECT> [ cpconnid = identifier() ]
 * disconnect a PooledConnection.  If cpconnid is given, then
 * disconnect the PooledConnection with the given cpconnid. 
 * (cpconnid not implemented)
 */

  final public ijResult CP_DisconnectStatement() throws ParseException, SQLException {
        String n = null;
    jj_consume_token(CP_DISCONNECT);
    if (jj_2_130(2)) {
      n = identifier();
    } else {
      ;
    }
                xahelper.CPDisconnectStatement(this, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

    /**
     * Sets the value of the objectTypes property.
     * 
     * @param objectTypes
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setObjectTypes(List<ControlledVoc> objectTypes) {
        this.objectTypes = objectTypes;
    }

    /**
     * Sets the value of the remarks property.
     * 
     * @param remarks
     *     allowed object is
     *     {@link TridasRemark }
     *     
     */

    public void setRemarks(List<TridasRemark> remarks) {
        this.remarks = remarks;
    }

    /**
     * Sets the value of the locationTypes property.
     * 
     * @param locationTypes
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setLocationTypes(List<ControlledVoc> locationTypes) {
        this.locationTypes = locationTypes;
    }

    /**
     * Sets the value of the sapwoods property.
     * 
     * @param sapwoods
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setSapwoods(List<ControlledVoc> sapwoods) {
        this.sapwoods = sapwoods;
    }

    /**
     * Gets the value of the code property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getCode() {
        return code;
    }

    /**
     * Sets the value of the code property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCode(Integer value) {
        this.code = value;
    }

    /**
     * Sets the value of the content property.
     * 
     * @param content
     *     allowed object is
     *     {@link Element }
     *     {@link String }
     *     
     */

    public void setContent(List<Object> content) {
        this.content = content;
    }

    /**
     * Sets the value of the heartwoods property.
     * 
     * @param heartwoods
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setHeartwoods(List<ControlledVoc> heartwoods) {
        this.heartwoods = heartwoods;
    }

    /**
     * Sets the value of the memberOf property.
     * 
     * @param value
     *     allowed object is
     *     {@link SecurityUser.MemberOf }
     *     
     */

    public void setMemberOf(SecurityUser.MemberOf value) {
        this.memberOf = value;
    }

    /**
     * Gets the value of the username property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getUsername() {
        return username;
    }

    /**
     * Sets the value of the username property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setUsername(String value) {
        this.username = value;
    }

    /**
     * Gets the value of the firstName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getFirstName() {
        return firstName;
    }

    /**
     * Sets the value of the firstName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setFirstName(String value) {
        this.firstName = value;
    }

    /**
     * Gets the value of the lastName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getLastName() {
        return lastName;
    }

    /**
     * Sets the value of the lastName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setLastName(String value) {
        this.lastName = value;
    }

    /**
     * Sets the value of the password property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setPassword(String value) {
        this.password = value;
    }

        /**
         * Sets the value of the securityGroups property.
         * 
         * @param securityGroups
         *     allowed object is
         *     {@link SecurityGroup }
         *     
         */

        public void setSecurityGroups(List<SecurityGroup> securityGroups) {
            this.securityGroups = securityGroups;
        }

    /**
     * Sets the value of the user property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIHeader.User }
     *     
     */

    public void setUser(WSIHeader.User value) {
        this.user = value;
    }

    /**
     * Gets the value of the wsVersion property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getWsVersion() {
        return wsVersion;
    }

    /**
     * Sets the value of the wsVersion property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setWsVersion(String value) {
        this.wsVersion = value;
    }

    /**
     * Gets the value of the clientVersion property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getClientVersion() {
        return clientVersion;
    }

    /**
     * Sets the value of the clientVersion property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setClientVersion(String value) {
        this.clientVersion = value;
    }

    /**
     * Gets the value of the requestDate property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */

    public XMLGregorianCalendar getRequestDate() {
        return requestDate;
    }

    /**
     * Sets the value of the requestDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */

    public void setRequestDate(XMLGregorianCalendar value) {
        this.requestDate = value;
    }

    /**
     * Sets the value of the queryTime property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIHeader.QueryTime }
     *     
     */

    public void setQueryTime(WSIHeader.QueryTime value) {
        this.queryTime = value;
    }

    /**
     * Gets the value of the requestUrl property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getRequestUrl() {
        return requestUrl;
    }

    /**
     * Sets the value of the requestUrl property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setRequestUrl(String value) {
        this.requestUrl = value;
    }

    /**
     * Gets the value of the requestType property.
     * 
     * @return
     *     possible object is
     *     {@link CorinaRequestType }
     *     
     */

    public CorinaRequestType getRequestType() {
        return requestType;
    }

    /**
     * Sets the value of the requestType property.
     * 
     * @param value
     *     allowed object is
     *     {@link CorinaRequestType }
     *     
     */

    public void setRequestType(CorinaRequestType value) {
        this.requestType = value;
    }

    /**
     * Gets the value of the status property.
     * 
     * @return
     *     possible object is
     *     {@link CorinaRequestStatus }
     *     
     */

    public CorinaRequestStatus getStatus() {
        return status;
    }

    /**
     * Sets the value of the status property.
     * 
     * @param value
     *     allowed object is
     *     {@link CorinaRequestStatus }
     *     
     */

    public void setStatus(CorinaRequestStatus value) {
        this.status = value;
    }

    /**
     * Gets the value of the nonce property.
     * 
     * @return
     *     possible object is
     *     {@link WSINonce }
     *     
     */

    public WSINonce getNonce() {
        return nonce;
    }

    /**
     * Sets the value of the nonce property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSINonce }
     *     
     */

    public void setNonce(WSINonce value) {
        this.nonce = value;
    }

    /**
     * Sets the value of the messages property.
     * 
     * @param messages
     *     allowed object is
     *     {@link WSIMessage }
     *     
     */

    public void setMessages(List<WSIMessage> messages) {
        this.messages = messages;
    }

    /**
     * Sets the value of the timings property.
     * 
     * @param timings
     *     allowed object is
     *     {@link WSIHeader.Timing }
     *     
     */

    public void setTimings(List<WSIHeader.Timing> timings) {
        this.timings = timings;
    }

        /**
         * Gets the value of the unit property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

        public String getUnit() {
            return unit;
        }

        /**
         * Sets the value of the unit property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

        public void setUnit(String value) {
            this.unit = value;
        }

        /**
         * Gets the value of the label property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

        public String getLabel() {
            return label;
        }

        /**
         * Sets the value of the label property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

        public void setLabel(String value) {
            this.label = value;
        }

        /**
         * Gets the value of the firstname property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

        public String getFirstname() {
            return firstname;
        }

        /**
         * Sets the value of the firstname property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

        public void setFirstname(String value) {
            this.firstname = value;
        }

        /**
         * Gets the value of the lastname property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

        public String getLastname() {
            return lastname;
        }

        /**
         * Sets the value of the lastname property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

        public void setLastname(String value) {
            this.lastname = value;
        }

    /**
     * Sets the value of the coverageTemporalFoundations property.
     * 
     * @param coverageTemporalFoundations
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setCoverageTemporalFoundations(List<ControlledVoc> coverageTemporalFoundations) {
        this.coverageTemporalFoundations = coverageTemporalFoundations;
    }

    /**
     * Sets the value of the elementAuthenticities property.
     * 
     * @param elementAuthenticities
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setElementAuthenticities(List<ControlledVoc> elementAuthenticities) {
        this.elementAuthenticities = elementAuthenticities;
    }

    /**
     * Gets the value of the seq property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getSeq() {
        return seq;
    }

    /**
     * Sets the value of the seq property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setSeq(String value) {
        this.seq = value;
    }

    /**
     * Gets the value of the name property.
     * 
     * @return
     *     possible object is
     *     {@link SearchParameterName }
     *     
     */

    public SearchParameterName getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link SearchParameterName }
     *     
     */

    public void setName(SearchParameterName value) {
        this.name = value;
    }

    /**
     * Gets the value of the operator property.
     * 
     * @return
     *     possible object is
     *     {@link SearchOperator }
     *     
     */

    public SearchOperator getOperator() {
        return operator;
    }

    /**
     * Sets the value of the operator property.
     * 
     * @param value
     *     allowed object is
     *     {@link SearchOperator }
     *     
     */

    public void setOperator(SearchOperator value) {
        this.operator = value;
    }

    /**
     * Gets the value of the header property.
     * 
     * @return
     *     possible object is
     *     {@link WSIHeader }
     *     
     */

    public WSIHeader getHeader() {
        return header;
    }

    /**
     * Sets the value of the header property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIHeader }
     *     
     */

    public void setHeader(WSIHeader value) {
        this.header = value;
    }

    /**
     * Gets the value of the help property.
     * 
     * @return
     *     possible object is
     *     {@link WSIHelp }
     *     
     */

    public WSIHelp getHelp() {
        return help;
    }

    /**
     * Sets the value of the help property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIHelp }
     *     
     */

    public void setHelp(WSIHelp value) {
        this.help = value;
    }

    /**
     * Gets the value of the content property.
     * 
     * @return
     *     possible object is
     *     {@link WSIContent }
     *     
     */

    public WSIContent getContent() {
        return content;
    }

    /**
     * Sets the value of the content property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIContent }
     *     
     */

    public void setContent(WSIContent value) {
        this.content = value;
    }

    /**
     * Gets the value of the request property.
     * 
     * @return
     *     possible object is
     *     {@link WSIRequest }
     *     
     */

    public WSIRequest getRequest() {
        return request;
    }

    /**
     * Sets the value of the request property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSIRequest }
     *     
     */

    public void setRequest(WSIRequest value) {
        this.request = value;
    }

    /**
     * Gets the value of the any property.
     * 
     * @return
     *     possible object is
     *     {@link Object }
     *     
     */

    public Object getAny() {
        return any;
    }

    /**
     * Sets the value of the any property.
     * 
     * @param value
     *     allowed object is
     *     {@link Object }
     *     
     */

    public void setAny(Object value) {
        this.any = value;
    }

    /**
     * Sets the value of the all property.
     * 
     * @param value
     *     allowed object is
     *     {@link WSISearchParams.All }
     *     
     */

    public void setAll(WSISearchParams.All value) {
        this.all = value;
    }

    /**
     * Gets the value of the returnObject property.
     * 
     * @return
     *     possible object is
     *     {@link SearchReturnObject }
     *     
     */

    public SearchReturnObject getReturnObject() {
        return returnObject;
    }

    /**
     * Sets the value of the returnObject property.
     * 
     * @param value
     *     allowed object is
     *     {@link SearchReturnObject }
     *     
     */

    public void setReturnObject(SearchReturnObject value) {
        this.returnObject = value;
    }

    /**
     * Gets the value of the limit property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getLimit() {
        return limit;
    }

    /**
     * Sets the value of the limit property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setLimit(Integer value) {
        this.limit = value;
    }

    /**
     * Gets the value of the skip property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getSkip() {
        return skip;
    }

    /**
     * Sets the value of the skip property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setSkip(Integer value) {
        this.skip = value;
    }

    /**
     * Gets the value of the includeChildren property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */

    public boolean isIncludeChildren() {
        return includeChildren;
    }

    /**
     * Sets the value of the includeChildren property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */

    public void setIncludeChildren(boolean value) {
        this.includeChildren = value;
    }

    /**
     * Sets the value of the params property.
     * 
     * @param params
     *     allowed object is
     *     {@link WSIParam }
     *     
     */

    public void setParams(List<WSIParam> params) {
        this.params = params;
    }

    /**
     * Sets the value of the sampleTypes property.
     * 
     * @param sampleTypes
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setSampleTypes(List<ControlledVoc> sampleTypes) {
        this.sampleTypes = sampleTypes;
    }

    /**
     * Gets the value of the cnonce property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCnonce() {
        return cnonce;
    }

    /**
     * Sets the value of the cnonce property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCnonce(String value) {
        this.cnonce = value;
    }

    /**
     * Gets the value of the snonce property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getSnonce() {
        return snonce;
    }

    /**
     * Sets the value of the snonce property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setSnonce(String value) {
        this.snonce = value;
    }

    /**
     * Gets the value of the hash property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getHash() {
        return hash;
    }

    /**
     * Sets the value of the hash property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setHash(String value) {
        this.hash = value;
    }

    /**
        Get the key for the preference which was changed.
        
        @return the key of the pref which was changed
    */

    public String getPref() {
	return pref;
    }

	/**
	 * Effectively removes this preference
	 */

	public void clear() {
		set(null);
	}

	/** 
	 * Sets the preference to the given value
	 * @param value
	 */

	public void set(T value) {
		
		// special case for nulls (unset)
		if(value == null) {
			App.prefs.setPref(prefName, null);
			return;
		}
		
		switch(underlyingType) {
		case STRING:
			App.prefs.setPref(prefName, (String) value);
			break;
			
		case COLOR:
			App.prefs.setColorPref(prefName, (Color) value);
			break;
			
		case DIMENSION:
			App.prefs.setDimensionPref(prefName, (Dimension) value);
			break;
			
		case BOOLEAN:
			App.prefs.setBooleanPref(prefName, (Boolean) value);
			break;

		case INTEGER:
			App.prefs.setIntPref(prefName, (Integer) value);
			break;
			
		case FONT:
			App.prefs.setFontPref(prefName, (Font) value);
			break;
		}
	}

	/**
	 * Get the value of this preference
	 * @return the value of this preference, or its default
	 */

	public T get() {
		return get(defaultValue);
	}

	/**
	 * Set the value of this preference
	 * @param value
	 */

	public void setValue(OBJTYPE value) {
		// same value? ignore it
		if(prefValue == value)
			return;
		
		// they equal the same thing? ignore it
		if(prefValue != null && prefValue.equals(value))
			return;
		
		valueModified = true;
		prefValue = value;
		
		if(autocommit)
			commit();
	}

	/**
	 * Get the value of the pref referenced by this wrapper
	 * @return
	 */

	public OBJTYPE getValue() {
		return (OBJTYPE) prefValue;
	}

    /**
       This method always throws UnsupportedOperationException.  It's
       not implemented, and don't even think about implementing it
       yourself!  It encourages being lazy and bypassing Year's
       methods to just deal with ints.  And that defeats the whole
       purpose of having Years.  So I'll just disallow it.  You don't
       need it anyway.  If you really need the int for some reason I
       can't imagine, you can always do
       <code>Integer.parseInt(y.toString())</code>.  That way you know
       you're doing it to get the int, and not for imagined
       performance or convenience reasons.

       @return never returns
       @exception UnsupportedOperationException always!
    */

    public int intValue() {
        // i pity th' fool who tries to use intvalue!
        throw new UnsupportedOperationException();
    }

    /**
       Return true, iff this is year 1.  (This actually comes up
       fairly often.)

       @return true iff this is year 1
    */

    public boolean isYearOne() {
        return (y == 1);
    }

    /**
       Adds (or subtracts, for negative values) some number of years,
       and generates a new Year object.

       @param dy the number of years to add (subtract)
       @see #diff
    */

    public Year add(int dy) {
        // copy, and convert to zys
        int r = y;
        if (r < 0)
            r++;

        // add dy
        r += dy;

        // convert back, and return
        if (r <= 0)
            r--;
        return Years.valueOf(r);
    }

    /**
       Calculate the number of years difference between two years.
       That is, there are this many years difference between
       <code>this</code> and <code>y2</code>; if they are equal, this
       number is zero.

       @param y2 the year to subtract
       @return the number of years difference between
       <code>this</code> and <code>y2</code>
       @see #add
    */

    public int diff(Year y2) {
        // copy, and convert to zys
        int i1 = y;
        if (i1 < 0)
            i1++;

        int i2 = y2.y;
        if (i2 < 0)
            i2++;

        // subtract, and return
        return i1 - i2;
    }

    /**
       Computes <code>this</code> modulo <code>m</code>.  Always
       gives a positive result, even for negative numbers, so it is
       suitable for computing a grid position for a span of years.

       @param m base for modulo
       @return the year modulo <code>m</code>
    */

    public int mod(int m) {
        int r = y % m;
        if (r < 0)
            r += m;
        return r;
    }

    /**
       Determines what row this year would be, if years were in a
       grid 10 wide, with the left column years ending in zero.  Row
       0 is years 1 through 9.

       @return this year's row
       @see #column
    */

    public int row() {
        int z = y / 10;
        if (y<0 && y%10!=0)
            z--;
        return z;
    }

    /**
       Determines what column this year would be, if years were in a
       grid 10 wide, with the left column years ending in zero.

       Works for BC years, also:
       <table border="1" cellspacing="0">
	   <tr><th>column()</th><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
	        <td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr>
	   <tr><th rowspan="3">Year</th><td>-10</td><td>-9</td><td>-8</td><td>-7</td><td>-6</td>
	        <td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td></tr>
	   <tr><td> </td><td>1</td><td>2</td><td>3</td><td>4</td>
	        <td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr>
	   <tr><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td>
	        <td>15</td><td>16</td><td>17</td><td>18</td><td>19</td></tr>
       </table>

       @return this year's column
       @see #row
    */

    public int column() {
        return mod(10);
    }

    /**
       Compares this and <code>o</code>.

       @see java.lang.Comparable
       @param o2 Object to compare
       @return >0, =0, or <0 if this is greater-than, equal-to, or less-than o
       @throws ClassCastException if o is not a Year
    */

    public int compareTo(Year o2) {
        return this.y - o2.y;
    }

    /**
       Return the default extension for files of this type.  All of
       the files I've seen end with ".out", so that's what I'll use.

       @return the string ".out"
    */

    public String getDefaultExtension() {
	return ".out";
    }

	/**
	 * Quickly check to see if it's an XML document
	 * @param r
	 * @throws IOException
	 */

	private void quickVerify(BufferedReader r) throws IOException {
		r.mark(4096);

		String firstLine = r.readLine();
		if(firstLine == null || !firstLine.startsWith("<?xml"))
			throw new WrongFiletypeException();
		
		r.reset();
	}

    /**
       Throw a WrongFiletypeException; spreadsheet format is
       write-only.

       (This should never get called.)

       @return never returns
       @exception WrongFiletypeException every time
    */

    public Sample load(BufferedReader r) throws IOException {
        throw new WrongFiletypeException();
    }

    /**
       Return the extension ".TXT".  I don't know what format
       spreadsheets normally expect, but it's just a text file, so
       I'll use this for now.

       @return the string ".TXT"
    */

    public String getDefaultExtension() {
	return ".txt";
    }

	/**
	 * If we've selected something, enable or disable the 'remeasure' button
	 */

	private void checkRemeasurable() {
		// enable if it's a valid index into both datasets!
		Year y = dv1.getSelectedYear();
		int col = dv1.myTable.getSelectedColumn();
		int idx = y.diff(s1.getStart());
		btnRemeasure.setEnabled(col > 0 && col < 11 && idx >= 0 && idx < s1.getData().size() && idx < s2.getData().size());		
	}

	/**
	 * Apply a redate directly to the sample
	 * @param dating
	 */

	private void performRedateInPlace(TridasDating dating) {
		sample.postEdit(Redate.redate(sample, range, dating));
	}

        /**
         * Set the row and column without firing the listener
         * @param row
         * @param col
         */

        public void setSelection(int row, int col) {
            if(row == -1)
            	row = lastRow;
            if(col == -1)
            	col = lastCol;

            if(row < 0 || row >= table.getRowCount())
            	return;
            
            if(col < 0 || col > table.getColumnCount())
            	return;
            
            lastRow = row;
        	table.setRowSelectionInterval(row, row);
        	
        	lastCol = col;
        	table.setColumnSelectionInterval(col, col);
        	
        	doReconciliation();
        	scrollToVisible(table, row, col);
        }

	/**
	 * Set up our button behaviors
	 */

	private void initButtons() {
		// cancel == close
		cancel = Builder.makeButton("general.cancel");
		cancel.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				dispose();
			}
		});

		// ok == apply
		ok = Builder.makeButton("general.ok");
		ok.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				// nothing to do?
				if (r.equals(s.getRange())) {
					dispose();
					return;
				}

				if(applyTruncation())
					dispose();
			}
		});
	}

	/**
	 * update "after:" text with resultant range.
	 */

	private void updateResult() {
		String rangeAndSpan;
		if (r == null) {
			rangeAndSpan = I18n.getText("error");
			cellModifier.updateRange(s.getRange());
		}
		else {
			rangeAndSpan = r + " (n=" + r.span() + ")";
			cellModifier.updateRange(r);
		}

		result.setText(I18n.getText("truncate.afterTruncating") + ": " + rangeAndSpan);
	}

    /**
       Return the height of this line: 18 points.

       @param g the Graphics object
       @return the height: 18 points
    */

    public int height(Graphics g) {
        return height;
    }

    /**
       Return the latitude, in degrees.
        
       @return the latitude, in degrees
    */

    public float getLatitudeAsDegrees() {
        return latitude / 3600f;
    }

	/** Set the font to use for the lines generated by this factory.
	 @param f the font to use */

	public void setFont(Font f) {
		this.font = f;
	}

    /**
       Return the longitude, in degrees.

       @return the longitude, in degrees
    */

    public float getLongitudeAsDegrees() {
        return longitude / 3600f;
    }

    /**
       Set the latitude, in degrees.

       @param degrees the new latitude, in degrees
    */

    public void setLatitudeAsDegrees(float degrees) {
        int seconds = Math.round(degrees * 3600);
        if (seconds < MIN_LATITUDE)
            seconds = MIN_LATITUDE;
        else if (seconds > MAX_LATITUDE)
            seconds = MAX_LATITUDE;
        this.latitude = seconds;
    }

    /**
       Set the longitude, in degrees.

       @param degrees the new longitude, in degrees
    */

    public void setLongitudeAsDegrees(float degrees) {
        int seconds = Math.round(degrees * 3600);

        // need to make sure the longitude is between -180 and 179 degrees.
        // 180 degrees, for example, gets sent back down to -180.
        // if i were doing degrees, i'd add 180, mod 360, sub 180.
        // so just do that in seconds.
        seconds += 180 * 3600;
        seconds %= 360 * 3600;
        if (seconds <= 0)
            seconds += 180 * 3600;
        else
            seconds -= 180 * 3600;
        
        this.longitude = seconds;
    }

    /**
       Get the latitude, in seconds.

       @return the latitude, in seconds
    */

    public int getLatitudeAsSeconds() {
        return latitude;
    }

    /**
       Get the longitude, in seconds.

       @return the longitude, in seconds
    */

    public int getLongitudeAsSeconds() {
        return longitude;
    }

    /**
       Set the latitude, in seconds.

       @param seconds the new latitude, in seconds
    */

    public void setLatitudeAsSeconds(int seconds) {
        if (seconds < MIN_LATITUDE)
            seconds = MIN_LATITUDE;
        else if (seconds > MAX_LATITUDE)
            seconds = MAX_LATITUDE;
        this.latitude = seconds;
    }

    /**
       Set the longitude, in seconds.

       @param seconds the new longitude, in seconds
    */

    public void setLongitudeAsSeconds(int seconds) {
        // make sure longitude is between -180 and 179 degrees.
        // see setLongitudeAsDegrees().
        seconds += 180 * 3600;
        seconds %= 360 * 3600;
        if (seconds <= 0)
            seconds += 180 * 3600;
        else
            seconds -= 180 * 3600;

        // PERF: make sure these are computed at compile-time, not run-time.

        // FIXME: extract method normalizeLongitude() (lat, too, while you're at it)

        this.longitude = seconds;
    }

    /**
     * This method checks if a String contains only numbers
     */

    public boolean containsOnlyNumbers(String str) {
        
        //It can't contain only numbers if it's null or empty...
        if (str == null || str.length() == 0)
            return false;
        
        for (int i = 0; i < str.length(); i++) {

            //If we find a non-digit character we return false.
            if (!Character.isDigit(str.charAt(i)))
                return false;
        }
        
        return true;
    }

	/**
	 * Ask our parent to repaint
	 */

	protected void repaintParent() {
		if(listener != null)
			listener.cellModifierChanged(this);
	}

	/** Return the row count.  For the Data tab of a Sample (i.e., not
	 Weiserjahre), it adds an extra row if the last datum is a -9
	 year, thus ensuring that there's always one blank after the
	 end for user editing.
	 @return the number of displayable rows */

	public int getRowCount() {
		// these need to be updated when the user inserts/deletes
		countRows();

		// compute num rows
		int n = row_max - row_min + 1;

		// always give a blank space for more data entry; if the last year
		// is the last year of this decade, we'll need another decade
		if (s.getRange().getEnd().column() == 9)
			n++;

		return n;
	}

	/** Return the column count.  This is always 12: the decade, 10
	 columns of data, and the histogram cell
	 @return the number of columns, 12 */

	public int getColumnCount() {
		return 12;
	}

	/**
	 * Lazily-load this icon
	 * 
	 * @param iconName
	 * @return the icon, or null if iconName was null
	 */

	private Icon lazyLoadIcon(String iconName) {
		if(iconName == null)
			return null;
		
		Icon icon = lazyIconMap.get(iconName);
		if(icon == null) {
			// lazy-load the icon
			icon = Builder.getIcon(iconName, 16);
			lazyIconMap.put(iconName, icon);
		}
		
		return icon;		
	}

	/**
	 * Get an icon for this tridas remark
	 * @param remark
	 * @return the icon, lazily loaded, or null
	 */

	private Icon getTridasIcon(NormalTridasRemark remark) {
		return lazyLoadIcon(Remarks.getTridasRemarkIcons().get(remark));
	}

	/**
	 * Get an icon for this Corina remark (text)
	 * @param remark
	 * @return the icon, lazily loaded, or null
	 */

	private Icon getCorinaIcon(String remark) {
		return lazyLoadIcon(Remarks.getCorinaRemarkIcons().get(remark));
	}

		/**
		 * Given the TridasObject, populate our internal structure
		 * @param obj
		 */

		private void populateFromObject(TridasObject obj) {
			List<TridasObject> flatObjects = new ArrayList<TridasObject>();

			// start out with the toplevel object
			flatObjects.add(obj);
			
			// if it has children, keep traversing
			while(obj.isSetObjects()) {
				obj = obj.getObjects().get(0);
				flatObjects.add(obj);
			}
		
			object = obj;
			objectArray = flatObjects.toArray(new TridasObject[0]);
			
			if(!object.isSetElements())
				return;
			
			element = object.getElements().get(0);
			
			if(!element.isSetSamples())
				return;
			
			sample = element.getSamples().get(0);
			
			box = loadBoxFromSample(sample);
		}

	/** Return the Year of the currently selected cell.
	 @return the selected Year */

	public Year getSelectedYear() {
		return ((DecadalModel) myModel).getYear(myTable.getSelectedRow(),
				myTable.getSelectedColumn());
	}

	/**
	 * Lazily-load this icon
	 * 
	 * @param iconName
	 * @return the icon, or null if iconName was null
	 */

	private Image lazyLoadIcon(String iconName) {
		if(iconName == null)
			return null;
		
		Image icon = lazyIconMap.get(iconName);
		if(icon == null) {
			// lazy-load the icon
			icon = Builder.getITextImageIcon(iconName);

			lazyIconMap.put(iconName, icon);
		}
		
		return icon;		
	}

	/**
	 * Get an icon for this tridas remark
	 * @param remark
	 * @return the icon, lazily loaded, or null
	 */

	private Image getTridasIcon(NormalTridasRemark remark) {
		return lazyLoadIcon(Remarks.getTridasRemarkIcons().get(remark));
	}

	/**
	 * Get an icon for this Corina remark (text)
	 * @param remark
	 * @return the icon, lazily loaded, or null
	 */

	private Image getCorinaIcon(String remark) {
		
		String iconName = Remarks.getCorinaRemarkIcons().get(remark);
		
		return lazyLoadIcon(iconName);
	}

	/**
	 * Add a cell modifier to the table and repaint
	 * @param modifier
	 */

	public void addCellModifier(TableCellModifier modifier) {
		myCellRenderer.addModifier(modifier);
		
		// repaint the table on notification
		modifier.setListener(new TableCellModifierListener() {
			public void cellModifierChanged(TableCellModifier modifier) {
				myTable.repaint();
			}
		});
		
		// repaint now, to be safe
		myTable.repaint();
	}

	/**
	 * Remove a cell modifier from the table and repaint
	 * @param modifier
	 */

	public void removeCellModifier(TableCellModifier modifier) {
		myCellRenderer.removeModifier(modifier);
		modifier.setListener(null);
		myTable.repaint();
	}

	/**
	 * When using heavyweight components, we have to make sure menus extend over them!
	 */

	private void makeMenusHeavyweight() {
		JMenuBar menus = getJMenuBar();
		
		for(int i = 0; i < menus.getMenuCount(); i++)
			menus.getMenu(i).getPopupMenu().setLightWeightPopupEnabled(false);
	}

	/**
	 * Set a server query property for loading
	 * 
	 * @param propertyName
	 * @param value
	 */

	public void setLoadProperty(String propertyName, Object value) {
		if(loadProperties == null)
			loadProperties = new HashMap<String, Object>();
		
		loadProperties.put(propertyName, value);
	}

	/**
	 * Set a server query property for saving
	 * 
	 * @param propertyName
	 * @param value
	 */

	public void setSaveProperty(String propertyName, Object value) {
		if(saveProperties == null)
			saveProperties = new HashMap<String, Object>();
		
		saveProperties.put(propertyName, value);
	}

	/**
	 * Get the sampleDataView
	 * @return The SampleDataVeiw I am holding
	 */

	public SampleDataView getSampleDataView() {
		return dataView;
	}

	/**
	 * Returns null if meta[key] doesn't exist, otherwise calls the object's tostring method
	 * @param key
	 * @return
	 */

	public String getMetaString(String key) {
		Object o = meta.get(key);
		
		return (o == null) ? null : o.toString();
	}

	/**
	 * Create a default set of TridasValues
	 * - 1/100th mm
	 * - Ring widths
	 * 
	 * @return a representative TridasValues object
	 */

	private TridasValues createEmptyRingWidths() {
		TridasValues values = new TridasValues();
		
		// set default units
		TridasUnit units = new TridasUnit();		
		units.setNormalTridas(NormalTridasUnit.HUNDREDTH_MM);
		values.setUnit(units);
		
		// set as ring widths
		TridasVariable variable = new TridasVariable();
		variable.setNormalTridas(NormalTridasVariable.RING_WIDTH);
		values.setVariable(variable);

		// populate the list of values (empty)
		values.getValues();
		
		return values;
	}	

	/**
	 * Create a default set of TridasValues
	 * - 1/100th mm
	 * - Ring widths
	 * 
	 * @return a representative TridasValues object
	 */

	private TridasValues createEmptyWeiserjahre() {
		TridasValues values = new TridasValues();
		
		values.setUnitless(new TridasUnitless());
		
		// set as Weiserjahre
		values.setVariable(WEISERJAHRE_VARIABLE);

		// populate the list of values (empty)
		values.getValues();
		
		return values;
	}	

	/** Get the type of sample */

	public SampleType getSampleType() {
		return sampleType;
	}

	/** Set the type of sample */

	public void setSampleType(SampleType sampleType) {
		this.sampleType = sampleType;
	}

	/**
	 * Get the attached series
	 * @return The attached series
	 */

	public ITridasSeries getSeries() {
		return series;
	}

	/**
	 * Attach a different series
	 * @param series
	 */

	public void setSeries(ITridasSeries series) {
		this.series = series;

		// update our sample type to reflect what's going on
		if(series instanceof ITridasDerivedSeries) {
			if(!sampleType.isDerived())
				sampleType = SampleType.UNKNOWN_DERIVED;
		}
		else if(sampleType.isDerived())
			sampleType = SampleType.UNKNOWN;
	}

	/**
	 * Shortcut for getRemarksForYear(values, year)
	 * Uses RING_WIDTH variable
	 * 
	 * @param y the year
	 * @return a TridasValue for the given year
	 */

	public TridasValue getValueForYear(Year y) {
		return getValueForYear(tridasValuesMap.get(NormalTridasVariable.RING_WIDTH), y);
	}

	/** Get the metadata interface */

	public CorinaMetadata meta() {
		if(metadata == null)
			metadata = new BaseSampleMetadata(this);
		
		return metadata;
	}

	/**
	 * Get the display title of this sample
	 * Generally, this is the lab code
	 * 
	 * For a menubar title, use toString()
	 * 
	 * @return a String, probably lab code
	 */

	public String getDisplayTitle() {
		return getMeta("title", String.class);
	}	

	/**
	 * Get a TridasValue for a given year
	 * 
	 * @param values
	 * @param y
	 * @return a TridasValue for the given year
	 */

	public TridasValue getValueForYear(TridasValues values, Year y) {
		Range range = getRange();

		if(!range.contains(y))
			throw new IndexOutOfBoundsException();
		
		int idx = y.diff(range.getStart());
		return values.getValues().get(idx);		
	}

	/**
	 * Get the associated tridas identifier
	 */

	public TridasIdentifier getIdentifier() {
		return (series != null) ? series.getIdentifier() : null;
	}

	/** Clear the modified flag. */

	public void clearModified() {
		modified = false;
	}

	/**
	 * Gets the name of the element
	 * For a FileElement, returns the full path name
	 * @return
	 */

	public String getName() {
		return loader.getName();
	}

	/**
	 * Gets the short name of the element
	 * For a FileElement, returns the file's base name
	 */

	public String getShortName() {
		return loader.getShortName();
	}

	/**
	 * Compares names of one element against another
	 */

	public int compareTo(Element o) {
		if(o == this)
			return 0;
		
		return o.getName().compareTo(getName());
	}

	/**
	 Load this Element.  Returns this Element in a Sample object.

	 @return the Sample referenced by this Element
	 @exception IOException if an IOException occurred while trying
	 to load it; this can also be the subclasses
	 FileNotFoundException
	 */

	public Sample load() throws IOException {
		Sample s = Files.load(filename);

		if(s==null) return null;
		
		s.setLoader(this);
		
		// lazily-load this...?
		type = s.getSampleType();
		
		// we loaded it, so tell our open menu...
		// Don't do this here, it affects imports!
		//OpenRecent.sampleOpened(this);
		
		return s;
	}

	/** Count the total number of rings.  If this is a raw sample,
	 returns the length.  If this is a summed sample, returns the
	 sum of the count List.
	 @return the total number of rings in this sample */

	public int countRings() {
		// it's not a sum, so the number of rings is just the length
		// (if (null count) (length data) ...
		List<Number> data = getData();
		
		if (!hasCount())
			return data.size();

		List<Integer> count = getCount();

		// it's a sum, so the number of rings is the sum of the number
		// of measurements for each year
		// ... (apply '+ count))
		int n = 0, size = count.size();
		for (int i = 0; i < size; i++)
			n += count.get(i);
		return n;
	}

	/**
	 Return this Element's filename, with
	 <code>corina.dir.data</code> replaced by an "?", if it's in a
	 subfolder of that.  (Otherwise, returns the absolute filename.)

	 @return the filename, with ?'s
	 */

	public String getRelativeFilename() {
		// no basename or folder? return relative path...
		if(basename == null || folder == null)
			return filename;
		
		return "?" + folder + ":" + basename;
	}

	/**
	 * Get the sample type we represent
	 */

	public SampleType getSampleType() {
		return type;
	}

	/**
	 * Copy an entire elementlist, preserving activeMap
	 * @param src
	 */

	public void addAll(ElementList src) {
		for(Element e : src) {
			add(e);
			if(src.activeMap.containsKey(e))
				activeMap.put(e, src.activeMap.get(e));
		}
	}

	/**
	 * Shortcut method: returns a list of only active elements
	 * @return
	 */

	public ElementList toActiveList() {
		ElementList activeList = new ElementList();
		
		for(Element e : this)
			if(isActive(e))
				activeList.add(e);
		
		return activeList;
	}

	/** Return the default scale factor for graphing.
	 @return scale factor of 1.0, or 0.1 for indexed files */

	public float getScale() {
		return (isIndexed() ? 0.1f : 1.0f);
	}

	/** Return the start date for a graph.
	 @return start date of data to graph */

	public Year getStart() {
		return getRange().getStart();
	}

	/** 
	 * Return true if the sample is absolutely dated, else false.
	 * @return true if the sample is absolutely dated 
	 */

	public boolean isAbsolutelyDated() {
		ITridasSeries series = getSeries();
		
		// no interpretation or no dating -> Relative dating
		if(!series.isSetInterpretation() || !series.getInterpretation().isSetDating())
			return false;
		
		switch(series.getInterpretation().getDating().getType()) {
		case ABSOLUTE:
		case DATED___WITH___UNCERTAINTY:
		case RADIOCARBON:
			return true;
			
		case RELATIVE:
			return false;
			
		default:
			new Bug(new IllegalArgumentException("Dating type " + 
					series.getInterpretation().getDating() + " not supported"));
			return false;
		}
	}

	/** Return true if the sample is indexed, else false.
	 @return true if the sample is indexed */

	public boolean isIndexed() {
		switch(super.getSampleType()) {
		case INDEX:
			return true; // nice and easy

		// we don't know? guess. and save our guess.
		case UNKNOWN:
			String type = (String) getMeta("format");
			if (type != null && Character.toUpperCase(type.charAt(0)) == 'I') {
				setSampleType(SampleType.INDEX);
				return true;
			}
			return false;
			
		default:
			return false;
		}
	}

	/** Return true if the file was modified since last save.
	 @return if the sample has been modified */

	public boolean isModified() {
		return modified;
	}

	/** <p>Return true if the sample is summed, else false.  Here
	 "summed" is defined as:</p>
	 <ul>
	 <li>has a list of elements, or
	 <li>has count data
	 </ul>
	 @return true if the sample is summed */

	public boolean isSummed() {
		switch(super.getSampleType()) {
		case SUM:
			return true; // nice and easy

		// we don't know? guess.
		// why is this "or?"
		case UNKNOWN: {
			if (elements != null || hasCount()) {
				setSampleType(SampleType.SUM);
				return true;
			}
			return false;
		}
			
		default:
			return false;
		}
	}

	/**
	 * Note that getCount() will return a list that has all ones
	 * when hasCount() can return false
	 * @return true if counts exist
	 */

	public boolean hasCount() {
		return ringwidths.hasCount();
	}

	/** Set the modified flag. */

	public void setModified() {
		modified = true;
	}

	/** Return a short version of the sample's title (without range info).
	 @return the "title" tag from meta */

	public String toSimpleString() {
		String name = getDisplayTitle();
		if (isModified()) // not aqua-ish, but how to do it the real way?
			name = "* " + name;
		return name;
	}

  /** 
   * Indicate the progress of the operation being monitored.
   * If the specified value is >= the maximum, the progress
   * meter is closed. 
   * @param value an int specifying the current value, between the
   *        maximum and minimum specified for this component
   * @see #setMinimum
   * @see #setMaximum
   * @see #close
   */

  public void setProgress(int value) {
    v = value;
    if (value >= max) {
      close();
    } else if (value >= lastDisp + reportDelta) {
      lastDisp = value;
      if (popped) {
        notifyStateChanged();
      } else {
        long T = System.currentTimeMillis();
        long dT = (int)(T-T0);
        if (dT >= millisToDecideToPopup) {
          int predictedCompletionTime;
          if (value > min) {
            predictedCompletionTime = (int)(dT *
                                            (max - min) /
                                            (value - min));
          } else {
            predictedCompletionTime = millisToPopup;
          }
          if (predictedCompletionTime >= millisToPopup) {
            popped = true;
            notifyDisplay();
          }
        }
      }
    }
  }

  /**
   * Indicate that the operation is complete.  This happens automatically
   * when the value set by setProgress is >= max, but it may be called
   * earlier if the operation ends early.
   */

  public void close() {
    if (!popped) return;
    popped = false;
    notifyClosed();
  }

  /**
   * Returns the minimum value -- the lower end of the progress value.
   * @return an int representing the minimum value
   * @see #setMinimum
   */

  public int getMinimum() {
    return min;
  }

  /**
   * Specifies the minimum value.
   * @param m an int specifying the minimum value
   * @see #getMinimum
   */

  public void setMinimum(int m) {
    min = m;
  }

  /**
   * Returns the maximum value -- the higher end of the progress value.
   * @return an int representing the maximum value
   * @see #setMaximum
   */

  public int getMaximum() {
    return max;
  }

  /**
   * Specifies the maximum value.
   * @param m an int specifying the maximum value
   * @see #getMaximum
   */

  public void setMaximum(int m) {
    max = m;
  }

  /**
   * Specifies the amount of time to wait before deciding whether or
   * not to notify listeners that they should display.
   * @param millisToDecideToPopup an int specifying the time to wait,
   *        in milliseconds
   * @see #getMillisToDecideToPopup
   */

  public void setMillisToDecideToPopup(int millisToDecideToPopup) {
    this.millisToDecideToPopup = millisToDecideToPopup;
  }

  /**
   * Returns the amount of time this object waits before deciding whether
   * or not to notify listeners to display.
   * @see #setMillisToDecideToPopup
   */

  public int getMillisToDecideToPopup() {
    return millisToDecideToPopup;
  }

  /**
   * Specifies the amount of time it will take for listeners to be notified
   * to display. (If the predicted time remaining is less than this time, then
   * listeners won't be notified to display)
   * @param millisToPopup  an int specifying the time in milliseconds
   * @see #getMillisToPopup
   */

  public void setMillisToPopup(int millisToPopup) {
    this.millisToPopup = millisToPopup;
  }

  /**
   * Returns the amount of time it will take before listeners are notified
   * to display.
   * @see #setMillisToPopup
   */

  public int getMillisToPopup() {
    return millisToPopup;
  }

  /**
   * Specifies the additional note that is displayed along with the
   * progress message.
   * @param note a String specifying the note to display
   * @see #getNote
   */

  public void setNote(String note) {
    this.note = note;
    if (popped) {
      notifyStateChanged();
    }
  }

  /**
   * Returns the additional note that is displayed along with the
   * progress message.
   * @return a String specifying the note to display
   * @see #setNote
   */

  public String getNote() {
    return note;
  }

	/**
	 * Set a new sort column. This is the index number to match of the headers.
	 * The null value is allowed.
	 * 
	 * @param sortColumn
	 *            the number of the new column which is used for sorting
	 */

	public void setSortColumn(Integer sortColumn) {
		if (sortColumn != null)
			this.sortColumn = sortColumn;
		else
			this.sortColumn = -1;
	}

	/**
	 * Tell the renderer whether this sort is forward or reverse. If it's
	 * reversed, the triangle is drawn upside-down.
	 * 
	 * @param reversed
	 *            is the sort a reverse-sort?
	 */

	public void setReversed(boolean reversed) {
		this.reversed = reversed;
	}

	/**
	 * Is this sort column reversed?
	 * @return
	 */

	public boolean isReversed() {
		return reversed;
	}

    /**
       Add the "Labels" menuitem.
    */

    protected void addLabelMenu() {
    	
    	JMenu labelmenu = Builder.makeMenu("menus.admin.labels", "label.png");

    	
    	JMenuItem boxlabel = Builder.makeMenuItem("menus.admin.boxlabels",
                "edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.boxLabelDialog()", "box.png");
        labelmenu.add(boxlabel);
    	
        JMenuItem samplelabel = Builder.makeMenuItem("menus.admin.samplelabels",
                "edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.sampleLabelDialog()", "sample.png");
        labelmenu.add(samplelabel);   
        add(labelmenu);
    }

    /**
    Add the "Reports" menuitem.
    */

	 protected void addReportsMenu() {
	 	
	 	JMenu reportmenu = Builder.makeMenu("menus.admin.reports", "prosheet.png");
	 	
	 	
	    JMenuItem prosheet = Builder.makeMenuItem("menus.admin.prosheet",
	            "edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.proSheetPrintingDialog()", "prosheet.png");
	    reportmenu.add(prosheet); 
	 	add(reportmenu);
	 }

	 /**
	 Add the "User and groups" menuitem.
	*/

	protected void addUserGroupMenu() {
		
	  	JMenuItem usergroup = Builder.makeMenuItem("menus.admin.usersandgroups",
	            "edu.cornell.dendro.corina.admin.UserGroupAdmin.main()", "edit_group.png");
	
		usergroup.setEnabled(true);
		add(usergroup);
	}

	 /**
	 Add the "Curation" menuitem.
	*/

	protected void addCurationMenu() {
		
	 	JMenu curationmenu = Builder.makeMenu("menus.admin.curation", "curation.png");
	 	
	 	
	    JMenuItem findsample = Builder.makeMenuItem("menus.admin.findsample",
	            "edu.cornell.dendro.corina.admin.SampleCuration.showDialog()", "findsample.png");
	    curationmenu.add(findsample); 
	    
	    
	    JMenuItem inventory = Builder.makeMenuItem("menus.admin.inventory",
	            "edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.proSheetPrintingDialog()");
	    inventory.setEnabled(false);
	    curationmenu.add(inventory); 
	    
	 	add(curationmenu);
	}

    /**
       Add the "Corina Help" menuitem.
    */

    protected void addHelpMenu() {
    	
	// See if we have access to mozilla libs
	try {
		// this loads the DLL...
		Class.forName("org.mozilla.browser");
	}
	catch (Exception e) {
		// driver not installed...
		System.out.println("No mozilla - no help");
		System.out.println(e.toString());
		return;
	}
	catch (Error e) {
		// native interface not installed...
		System.out.println("No mozilla - no help");
		System.out.println(e.toString());
		return;
	}
	
	// Mozilla present so add help menu
	add(Builder.makeMenuItem("menus.help.corina_help",
				 "edu.cornell.dendro.corina.gui.HelpWiki.showHelp()", "help.png"));
    }

    /**
       Add the "System Properties..." menuitem.
    */

    protected void addSystemInfoMenu() {
        add(Builder.makeMenuItem("menus.help.system_info",
                                 "edu.cornell.dendro.corina.util.PropertiesWindow.showPropertiesWindow()", "system.png"));
    }

    /**
       Add the "About Corina..." menuitem.
    */

    protected void addAboutMenu() {
      JMenuItem menuitem = Builder.makeMenuItem("menus.about");
      menuitem.setAction(ABOUT_ACTION);
      add(menuitem);
    }

    /**
     * Returns the upper value in the range.
     */

    public int getUpperValue() {
        return getValue() + getExtent();
    }

    /**
     * Sets the upper value in the range.
     */

    public void setUpperValue(int value) {
        // Compute new extent.
        int lowerValue = getValue();
        int newExtent = Math.min(Math.max(0, value - lowerValue), getMaximum() - lowerValue);
        
        // Set extent to set upper value.
        setExtent(newExtent);
    }

    /**
     * Paints the thumb for the lower value using the specified graphics object.
     */

    private void paintLowerThumb(Graphics g) {
        Rectangle knobBounds = thumbRect;
        int w = knobBounds.width;
        int h = knobBounds.height;      
        
        // Create graphics copy.
        Graphics2D g2d = (Graphics2D) g.create();

        // Create default thumb shape.
        Shape thumbShape = createThumbShape(w - 1, h - 1);

        // Draw thumb.
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
            RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.translate(knobBounds.x, knobBounds.y);

        g2d.setColor(Color.GRAY);
        g2d.fill(thumbShape);

        g2d.setColor(Color.GRAY);
        g2d.draw(thumbShape);
        
        // Dispose graphics.
        g2d.dispose();
    }

    /**
     * Paints the thumb for the upper value using the specified graphics object.
     */

    private void paintUpperThumb(Graphics g) {
        Rectangle knobBounds = upperThumbRect;
        int w = knobBounds.width;
        int h = knobBounds.height;      
        
        // Create graphics copy.
        Graphics2D g2d = (Graphics2D) g.create();

        // Create default thumb shape.
        Shape thumbShape = createThumbShape(w - 1, h - 1);

        // Draw thumb.
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
            RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.translate(knobBounds.x, knobBounds.y);

        g2d.setColor(Color.GRAY);
        g2d.fill(thumbShape);

        g2d.setColor(Color.GRAY);
        g2d.draw(thumbShape);

        // Dispose graphics.
        g2d.dispose();
    }

    /**
     * Returns a Shape representing a thumb.
     */

    private Shape createThumbShape(int width, int height) {
        // Use circular shape.
        Ellipse2D shape = new Ellipse2D.Double(0, 0, width, height);
        return shape;
    }

    /** 
     * Sets the location of the upper thumb, and repaints the slider.  This is
     * called when the upper thumb is dragged to repaint the slider.  The
     * <code>setThumbLocation()</code> method performs the same task for the
     * lower thumb.
     */

    private void setUpperThumbLocation(int x, int y) {
        Rectangle upperUnionRect = new Rectangle();
        upperUnionRect.setBounds(upperThumbRect);

        upperThumbRect.setLocation(x, y);

        SwingUtilities.computeUnion(upperThumbRect.x, upperThumbRect.y, upperThumbRect.width, upperThumbRect.height, upperUnionRect);
        slider.repaint(upperUnionRect.x, upperUnionRect.y, upperUnionRect.width, upperUnionRect.height);
    }

	/**
	 * Check if an event changed our validity, and if it did, notify
	 */

	private void checkValid() {
		boolean isValid = isDataValid();
		
		if(valid == isValid)
			return;
		
		boolean oldValid = valid;
		valid = isValid;
		
		// change background color and repaint accordingly
		setBackground(valid ? validColor : invalidColor);
		repaint();

		properties.firePropertyChange(PARAMETER_VALID_PROPERTY, oldValid, valid);		
	}

	/**
	 * Get the search parameter name
	 * @return The enum value, or null if not selected
	 */

	public SearchParameterName getParameterName() {
		Object o = cboSearchField.getSelectedItem();
		
		if(o instanceof SearchParameterName)
			return (SearchParameterName) o;
		
		return null;
	}

	/**
	 * Get the search operator
	 * @return the enum value
	 */

	public SearchOperator getOperator() {
		return (SearchOperator) cboSearchOperator.getSelectedItem();
	}

	/**
	 * Get the search value
	 * @return the search value, or null if it is empty
	 */

	public String getValue() {
		String value = txtSearchText.getText();
		
		return (value.length() > 0) ? value : null;
	}

	/**
	 * Add a listener for searchproperty changes
	 * @param listener
	 */

	public void addSearchParameterPropertyChangeListener(PropertyChangeListener listener) {
		properties.addPropertyChangeListener(listener);
	}

	/**
	 * Remove a listener for search property changes
	 * @param listener
	 */

	public void removeSearchParameterPropertyChangeListener(PropertyChangeListener listener) {
		properties.removePropertyChangeListener(listener);
	}

	/**
	 * Used if we're actually doing a login!
	 * @param nonce
	 */

	public void setNonce(String nonce, String seq) {
		serverNonce = nonce;
		serverNonceSeq = seq;
	}

    /**
     * Initilize components of the gui
     */

    protected void doInitComponents(){
    	// Dynamic components
	    btnAdd = new javax.swing.JButton();
	    btnRemove = new javax.swing.JButton();
	    tblAvailMeas = new javax.swing.JTable();
	    tblChosenMeas = new javax.swing.JTable();
	    // Standard components
    	initComponents();
    	
    	// Hide ribbon 
	    panelRibbon.setVisible(false);
	    
	    // Hide preview button
	    btnPreview.setVisible(false);

	    // Make sure components are using I18n
        internationalizeComponents();
         
    }

    /**
     * Play a beep.  Useful for when a barcode has been scanned.
     */

    public void playBarcodeBeep(){
		AudioClip beep;
		try {	
			// play this to indicate measuring is on...
			beep = Applet.newAudioClip(getClass().getClassLoader().getResource("edu/cornell/dendro/corina_resources/Sounds/checkout.wav"));
			if(beep != null)
				beep.play();
		} catch (Exception ae) { 
			System.out.println("Failed to play sound");
			System.out.println(ae.getMessage());
			}
		
    }

    /**
     * Setup the search panel
     * 
     */

    private void setupSearch() {
    	searchPanel = new SearchPanel(new SearchSupport());
    	this.browseSearchPane.setComponentAt(1, searchPanel);
    }

	/**
	 * Rebuild our panel: relayout everything
	 */

	private void rebuild() {
		// delete the layout
		panel.removeAll();

		GridBagConstraints c = new GridBagConstraints();
		
		c.gridx = 0;
		c.gridy = 0;
		c.ipady = 4;
		
		// now, add everything to our layout
		for(SearchParameterPanel searchPanel : parameters) {
			panel.add(searchPanel, c);
			c.gridy++;
		}
		
		c.anchor = GridBagConstraints.LINE_START;
		panel.add(addButton, c);
		
		// revalidate our panel, we changed the layout
		panel.revalidate();		
	}

	/**
	 * Rebuild a search parameter list, and search if need be
	 */

	private void rebuildQuery() {
		SearchParameters search = new SearchParameters(SearchReturnObject.MEASUREMENT_SERIES);

		// don't include children
		search.setIncludeChildren(false);
		
		for(SearchParameterPanel searchPanel : parameters) {
			if(!searchPanel.isDataValid())
				return;
			
			search.addSearchConstraint(searchPanel.getParameterName(), searchPanel.getOperator(), 
					searchPanel.getValue());
		}
		
		// empty search? don't change anything...
		if(!search.isSetParams())
			return;
		
		startSearch(search);
	}

	/**
	 * Force a re-sort
	 */

	public void reSort() {
		// nothing to sort by :(
		if(lastSortedCol < 0)
			return;
		
		int col = lastSortedCol;
		boolean reverse = headerRenderer.isReversed();
		
		lastSortedCol = -1;
		sortOnColumn(col, reverse);
	}

	/**
	 * Force a sort...
	 * @param col the column to sort on
	 * @param reverse force reverse
	 */

	public void sortOnColumn(int col, boolean reverse) {
		if(col == lastSortedCol) {
			Collections.reverse(model.getElements());
			headerRenderer.setReversed(!headerRenderer.isReversed());
		}
		else {
			Collections.sort(model.getElements(), new ElementListTableColumnComparator(model, col));
			
			headerRenderer.setSortColumn(col);
			headerRenderer.setReversed(false);
			
			lastSortedCol = col;
			
			if(reverse)
				Collections.reverse(model.getElements());
		}
	
		
		// notify the model and repaint the header
		model.fireTableDataChanged();
		table.getTableHeader().repaint();
		
	}

    /**
        Return the minimum size required to lay out these components in
        the parent.

        @param the parent to lay out
        @return the minimum layout size
    */

    public Dimension minimumLayoutSize(Container parent) {
        return getLayoutSize(parent, false);
    }

    /**
        Return the preferred size required to lay out these components
        in the parent.

        @param the parent to lay out
        @return the preferred layout size
    */

    public Dimension preferredLayoutSize(Container parent) {
        return getLayoutSize(parent, true);
    }

    /**
        Optional, and not implemented.
    */

    public void addLayoutComponent(String name, Component comp) {
        // do nothing
    }

    /**
        Optional, and not implemented.
    */

    public void removeLayoutComponent(Component comp) {
        // do nothing
    }

	/**
	 * Convenience method: Force a JTextField to auto-capitalize 
	 * and not allow any whitespace chars
	 * @param field
	 */

	protected void setCapsNoWhitespace(JTextField field) {
		field.addKeyListener(new KeyAdapter() {
			public void keyTyped(KeyEvent ke) {
				char k = ke.getKeyChar();
				
				// don't allow any whitespace
				if(Character.isWhitespace(k)) {
					ke.consume(); // om nom nom nom!
					return;
				}
				
				// force uppercase
				ke.setKeyChar(Character.toUpperCase(k));
			}
		});
	}

	/**
	 * Convenience function: makes a JTextField select all
	 * when it receives focus
	 * @param field
	 */

	protected void setSelectAllOnFocus(JTextField field) {
		final JTextField glue = field;
		
		field.addFocusListener(new FocusAdapter() {
			public void focusGained(FocusEvent fe) {
				glue.selectAll();
			}
		});
	}

	/**
	 * Set a component's maximum height to its preferred height
	 * @param comp
	 */

	private void setMaxHeight(Component comp) {
		Dimension d = comp.getPreferredSize();
		comp.setMaximumSize(new Dimension(Short.MAX_VALUE, d.height));
	}

	/**
	 * Sets the background color of the field depending on its
	 * valid/invalid status
	 * @param field
	 * @param isGood
	 */

	protected void colorField(JComponent field, boolean isValid) {
		if(isValid) {
			field.setBackground(UIManager.getLookAndFeelDefaults().getColor("TextField.background"));
		} else {
			field.setBackground(new Color(255, 255, 200));
		}
	}

    /**
     * Called right before we're about to be made visible, 
     * so we can perhaps do some last minute updates?
     */

    public void preVisibleNotify() {
		// finally, if we have any defaults, apply them to our editor panel
		Object o;
		if((o = wizardParent.getDefaultsForClass(contentClass)) != null) {
			setDefaultSelectionFrom((OBJT) o); // apply them to our combobox, perhaps?
			myPanel.setDefaultsFrom((OBJT) o); // and fill in our editor pane
		}
    }

    /**
     * Get the selected object in this panel
     * DON'T CALL BEFORE verifyAndSelectNextPanel()!!!
     * @return
     */

    public OBJT getPanelObject() {
    	Object selection = cboExistingList.getSelectedItem();
    	
    	if(selection == null)
    		throw new IllegalStateException("GetPanelObject() has no object?");
    	
    	if(!selection.getClass().equals(contentClass)) {
    		throw new IllegalStateException("GetPanelObject() not content class, instead it's " + selection.getClass().toString());
    	}
    	
    	return (OBJT) selection;
    }

    /**
     * Called right before we're about to be made visible
     */

    public void preVisibleNotify() {
		// if we have any defaults, apply them
		Object o;
		if((o = parent.getDefaultsForClass(contentClass)) != null) 
			setDefaultsFrom((Sample) o);
    }

    /**
     * is our form in a completely valid state?
     */

    private void checkEverythingValid() {
    	if(btnExisting.isSelected()) {
    		checkComboValid();
    		
    		if(ourFormValidated)
    			setPanelValid(true);
    		else
    			setPanelValid(false);
    	}
    	else if(btnNew.isSelected()) {    		
    		if(childFormValidated)
    			setPanelValid(true);
    		else
    			setPanelValid(false);
    	}
    }

    /**
     * check to see if our combobox is valid or not
     */

    private void checkComboValid() {
		// do we have a valid selection in the combo box?
		Object obj = cboExistingList.getSelectedItem();
		if(obj != null && obj.getClass().equals(contentClass))
			ourFormValidated = true;
		else
			ourFormValidated = false;
    }

    /**
     * Is the panel valid (e.g., can we move to the next panel?)
     * @return
     */

    public boolean isPanelValid() {
    	return panelValid;
    }

    /**
     * called when our child panel's validity state changes
     */

	public void notifyChildFormStateChanged() {
		childFormValidated = myPanel.isFormValidated();
		
		checkEverythingValid();
	}

    /**
     * adds an element to the list
     * @param e
     */

    public void addElement(Element e) {
		if(!selectedElements.contains(e))
			selectedElements.add(e);
		else
			return;
	
		chosenSorter.reSort();
		
		// tell the table it's changed!
		((ElementListTableModel)tblChosenMeas.getModel()).fireTableDataChanged();

		// verify a selected element
		if(selectedElements.size() > minimumSelectedElements)
			btnOk.setEnabled(true);
		else
			btnOk.setEnabled(false);    	
    }

	/**
	 * Set the new object to create
	 * @param obj
	 */

	protected void setNewObject(OBJT obj) {
		this.newObject = obj;
	}

    /**
     * Does nothing for the final panel
     */

    public TridasEntityBase getPanelObject() {
    	return null;
    }

	/**
	 * Populate our dialog using any necessary information from our parent dialog
	 */

	public void populate() {
		
	}

    /**
     * Remove the element from all lists that I have
     * @param e
     */

    public void deleteElement(Element e) {
   		deleteElementFromModel(e, ((ElementListTableModel)tblChosenMeas.getModel()));
   		deleteElementFromModel(e, ((ElementListTableModel)tblAvailMeas.getModel()));    	
    }

	/**
	 * Populate our dialog using the supplied prefix
	 */

	public void populate(String parentPrefix) {
		
	}

	/**
	 * Query our webservice to create this object
	 * 
	 * @param resource
	 * @returns true if success
	 */

	protected boolean createOrUpdateObject(IntermediateResource resource) {
		PrototypeLoadDialog dlg = new PrototypeLoadDialog(resource);
		
		// start our query (remotely)
		resource.query();		
		
		dlg.setVisible(true);
		
		if(!dlg.isSuccessful()) {
			JOptionPane.showMessageDialog(this, "Could not create: " + dlg.getFailException(), 
					"Failed to create", JOptionPane.ERROR_MESSAGE);
		}
		else				
			succeeded = true;

		return succeeded;
	}

	/**
	 * Did we succeed in creating a new webdb object?
	 * @return
	 */

	public boolean didSucceed() {
		return succeeded;
	}

	/**
	 * Makes this JTextField call our validateButtons() method
	 * every time its contents change.
	 * 
	 * @param field
	 */

	protected void setFieldValidateButtons(JTextField field) {
		field.getDocument().addDocumentListener(new DocumentListener() {
			public void changedUpdate(DocumentEvent e) {
				// hello stupid bug.. this isn't used on JTextFields for some awful reason
			}

			public void removeUpdate(DocumentEvent e) {
				validateForm();
			}

			public void insertUpdate(DocumentEvent e) {
				validateForm();
			}
		});
	}

	/**
	 * Return the value of our name field, if any
	 * @return our name field or null
	 */

	public String getLocalName() {
		return null;
	}

	/**
	 * Save our changes to the db
	 */

	public void commit() {
		System.out.println("Commit not yet implemented :(");
	}

	/**
	 * Called to notify the wizard our 'ok' state has changed
	 */

	protected void notifyWizard() {
		if(wizardToNotify != null)
			wizardToNotify.notifyChildFormStateChanged();
	}

    /**
     * Is this element in the selected list?
     * @param e
     * @return true if the selected elements table contains this element
     */

    public boolean isSelectedElement(Element e) {
    	return selectedElements.contains(e);
    }

	/**
	 * Causes the dialog to update the resource given instead of
	 * creating a new resource.
	 * 
	 * @param obj
	 */

	public void setUpdateObject(OBJT obj) {
		if(obj instanceof TridasEntityBase) {
			if(((TridasEntityBase) obj).isNew())
				throw new IllegalArgumentException("Trying to create an update dialog for a new resource!");
		}
		
		updatingObject = obj;
	}

	/**
	 * Steal the identify of our updating object, if it's set
	 * @param obj
	 */

	protected void assimilateUpdateObject(OBJT obj) {
		if(updatingObject == null)
			return;
		
		((TridasEntityBase) obj).assimilateIntermediateObject((TridasEntityBase) updatingObject);
	}

	/**
	 * Intended to be overridden by a function that enables/disables buttons.
	 * Called by anything that has been added with setFieldValidateButtons
	 */

	protected void validateForm() {
		
	}

    /**
     * How many elements need to be selected before we allow continuing?
     * (defaults to 1, increase for sums?)
     * @param value
     */

    public void setMinimumSelectedElements(int value) {
    	minimumSelectedElements = value;
    }

    /**
     * Selects the site indicated by "code"
     * No effect if code is invalid
     * @param code
     */

    public void selectSiteByCode(String code) {
    	TridasObjectEx site = App.tridasObjects.findObjectBySiteCode(code);
    	
    	if(site != null)
    		lstSites.setSelectedValue(site, true);
    }

    /**
     * Get the JPanel that comprises space between invert...OK
     * Not initialized; must be laid out manually
     * @return
     */

    public JPanel getExtraButtonPanel() {
    	return extraButtonPanel;
    }

    /**
     * Return a default object for this class, if one exists
     */

    public Object getDefaultsForClass(Class<?> clazz) {
    	return defaultsMap.get(clazz);
    }

		/**
		 * Show the search label (or not...)
		 * @param shouldShow
		 * @param hasProgress
		 */

		private void showSearchLabel(boolean shouldShow) {
			if (shouldShow == false) {
				searchInfoLabel.setVisible(false);
				getLayeredPane().remove(searchInfoLabel);
				getLayeredPane().validate();
				return;
			}

			Point workPt = workArea.getLocation();
			workPt = SwingUtilities.convertPoint(workArea, workPt, null);
			searchInfoLabel.setBounds(workPt.x, workPt.y, workArea.getWidth(), 100);
			searchInfoLabel.setVisible(true);

			getLayeredPane().add(searchInfoLabel,
					new Integer(JLayeredPane.POPUP_LAYER - 1), 0);
			getLayeredPane().validate();
		}

	/**
	 * Get the name of the series
	 * @return The name of the series
	 */

	public String getSeriesName() {
		return seriesName.getText();
	}

	/**
	 * Check if the fields exist; show a dialog and focus if they don't.
	 * 
	 * @param valuesRequired
	 * @return true if the values are satisfied, false otherwise
	 */

	public boolean testAndComplainRequired(EnumSet<Fields> valuesRequired) {
		if(valuesRequired.contains(Fields.NAME) && !hasSeriesName()) {
			complain(I18n.getText("general.seriesCode"));
			seriesName.requestFocusInWindow();
			return false;
		}

		if(valuesRequired.contains(Fields.VERSION) && !hasVersion()) {
			complain(I18n.getText("general.version"));
			versionName.requestFocusInWindow();
			return false;
		}

		if(valuesRequired.contains(Fields.JUSTIFICATION) && !hasJustification()) {
			complain(I18n.getText("general.justification"));
			justification.requestFocusInWindow();
			return false;
		}

		return true;
	}

	/**
	 * Perform this action
	 * 
	 * @param source
	 */

	public void perform(Object source) {
		ActionEvent ae = new ActionEvent(source == null ? this : source,
				ActionEvent.ACTION_PERFORMED,
				(String) getValue(Action.ACTION_COMMAND_KEY));
		actionPerformed(ae);
	}

	/** Called when our selection state changes */

	protected void selectionStateChanged(boolean newSelectedState) {
		// by default, we don't care :)
	}

	/**
	 * Associate a toggleable button with this action's internal toggle state
	 * 
	 * @param button the button to associate with
	 * @param defaultValue the default boolean value, or null if we should try to automatically figure this out
	 */

	public void connectToggleableButton(AbstractButton button, Boolean defaultValue) {
		if(buttonAdapters == null)
			buttonAdapters = new ArrayList<ButtonSelectionActionAdapter>();
		
		buttonAdapters.add(new ButtonSelectionActionAdapter(button, defaultValue));
	}

	/**
	 * Associate a toggleable button with this action's internal toggle state
	 * (Guess defaults!)
	 * @param button
	 */

	public void connectToggleableButton(AbstractButton button) {
		connectToggleableButton(button, null);
	}

	/**
	 * Set the type of crossdate to display (e.g., TScore.class, RScore.class)
	 * @param clazz
	 */

	public void setScoreClass(Class<?> clazz) {
		shownCrossdateClass = clazz;

		// update the cross
		if(pairing != null)  {			
			cross = pairing.getCrossForClass(clazz);
			if(cross != null)
				updateTable();
		}
		
		fireTableDataChanged();
	}

    /**
     * Show an open dialog as a child of a frame
     * @param parent
     * @param preexistingElements
     */

    private ElementList showOpenDialog(Frame parent, boolean modal, ElementList preexistingElements) {
    	DBBrowser dbb = new DBBrowser(parent, modal, true) {
			@Override
			protected boolean finish() {
				return (loadAllElements() && super.finish());
			}
		};
		
		return doOpenDialog(dbb, preexistingElements);
    }

	/**
	 * Get the number of items in the fullest bucket.
	 * 
	 * @return the number of items in the fullest bucket
	 */

	public int getFullestBucket() {
		// computed lazily; -1 means "not computed"
		// (because no bucket can contain -1 things, of course)
		if (fullest == -1) {
			for (int i = 0; i < buckets.length; i++)
				fullest = Math.max(fullest, buckets[i]);
		}
		return fullest;
	}

	/**
	 * Get the number of buckets. This is a compile-time constant.
	 * 
	 * @see Histogram#NUMBER_OF_BUCKETS
	 * @return the number of buckets
	 */

	public int getNumberOfBuckets() {
		return buckets.length;
	}

	/**
	 * Get the range spanned by a bucket. This is returned as a string, in the
	 * format "a - b". The ends of the span are formatted in the provided
	 * format.
	 * 
	 * @param bucket
	 *            which bucket to look at
	 * @return the range spanned by that bucket, as a string "a - b"
	 */

	public String getBucketRange(int bucket) {
		// build memo, if necessary
		if (memo == null)
			memo = new String[buckets.length];

		// compute result for cache, if necessary
		if (memo[bucket] == null) {
			boolean isInfty = (hasInfty && bucket == buckets.length - 1);
			float a = low + step * bucket;
			float b = (isInfty ? Float.POSITIVE_INFINITY : low + step
					* (bucket + 1));
			memo[bucket] = format.format(a) + " - " + format.format(b);
			// "-" should really be "\u2014",
			// but my printer can't handle that yet,
			// so yours likely can't, either. :-(
		}

		// return it
		return memo[bucket];
	}

	/**
	 * Gets the minimum value in a bucket
	 * 
	 * @param bucket
	 * @return
	 */

	public float getBucketMin(int bucket) {
		return low + step * bucket;
	}

	/**
	 * Get the number of items in a bucket.
	 * 
	 * @param bucket
	 *            which bucket to look at
	 * @return the number of items in that bucket
	 */

	public int getBucketItems(int bucket) {
		return buckets[bucket];
	}

	/** Return a prettier name for this cross: "T-Score".
	 @return the name of this cross, "T-Score" */

	public String getName() {
		return I18n.getText("statistics.tscore");
	}

	/** A format string for T-scores.
	 @return a format string for T-scores */

	public String getFormat() {
		return App.prefs.getPref("corina.cross.tscore.format", "0.00");
	}

	/**
	 * Given the row and column, get a pairing.
	 * 
	 * @param row
	 * @param col
	 * @return
	 * @throws ArrayIndexOutOfBoundsException
	 */

	public Pairing getPairing(int row, int col) throws NoSuchPairingException {
		Pairing pairing = pairings.get(keyForRowCol(row, col));
		
		if(pairing == null)
			throw new NoSuchPairingException(row, col);
		
		return pairing;
	}

	/**
	 * Find a pairing of the two given samples
	 * 
	 * This can be time consuming with a huge amount of pairs...
	 * 
	 * @param s1
	 * @param s2
	 * @return the pairing, or null if not found
	 */

	private Pairing findPairing(Pairing pairing) {
		for(Pairing p : pairings.values())
			if(p.equals(pairing))
				return p;
		
		return null;
	}

	/**
	   Returns a list of all fixed samples.

	   @return all fixed samples of this sequence
	 */

	public ElementList getAllFixed() {
		return fixed; // FIXME: exposes internal representation!
	}

	/**
	   Returns a list of all moving samples.

	   @return all moving samples of this sequence
	 */

	public ElementList getAllMoving() {
		return moving; // FIXME: exposes internal representation!
	}

	/**
	   Return a new crossdate of the current pairing.

	   @exception IOException if one of the samples needed to make
	   this crossdate could not be loaded
	   @exception IllegalArgumentException if one of the algorithms
	   used by this Sequence isn't a valid crossdate (i.e.,
	   Cross.makeCross() throws an exception)
	 */

	public Cross makeCross() throws IOException, IllegalArgumentException {
		return Cross.makeCross(algorithms[crossNr], getFixed(), getMoving());
		// (PERF: this is inefficient for the d-score, but not
		// horrible.  the i/o problem is much worse than the extra
		// computation time.)
	}

	/**
	   Sets the algorithms to use for this sequence.  The format is an
	   array of Strings containing (fully-qualified) names of classes
	   which subclass corina.cross.Cross.  The order used is the order
	   they'll be presented to the user.

	   @param algorithms the new algorithms to use
	 */

	public void setAlgorithms(String algorithms[]) {
		// make copy
		int n = algorithms.length;
		this.algorithms = new String[n];
		for (int i = 0; i < n; i++)
			this.algorithms[i] = algorithms[i];
	}

	/**
	   Go to the next pairing.  If already at the end, does nothing.
	 */

	public void nextPairing() {
		if (crossNr < algorithms.length - 1) {
			crossNr++;
		} else if (pairingNr < pairings.size() - 1) {
			pairingNr++;
			crossNr = 0;
		}
	}

	/**
	   Go to the previous pairing.  If already at the beginning, does
	   nothing.
	 */

	public void prevPairing() {
		if (crossNr > 0) {
			crossNr--;
		} else if (pairingNr > 0) {
			pairingNr--;
			crossNr = algorithms.length - 1;
		}
	}

	/**
	   Is the current pairing the first pairing?

	   @return true, if this is the first pairing
	 */

	public boolean isFirst() {
		return (pairingNr == 0 && crossNr == 0);
	}

	/**
	   Is the current pairing the last pairing?

	   @return true, if this is the last pairing
	 */

	public boolean isLast() {
		return (pairingNr == pairings.size() - 1 && crossNr == algorithms.length - 1);
	}

	/**
	 Make a printable object for this crossdating grid.

	 @return a Printable for this Grid
	 */

	public Pageable print(PageFormat pageFormat) {
		return grid.makeHardcopy(pageFormat);
	}

    /** Get notified when the graph changes */

	public void graphChanged(GrapherEvent evt) {
		if(evt.getEventType() == GrapherEvent.Type.XOFFSET_CHANGED) {
			if(graphSamples.size() == 2)
				status.setMovingRange(graphSamples.get(1).getRange());
		}
	}

	/**
	 Make a printable object for this crossdating table.

	 @return a Printable for this Table
	 */

	public Printable print() {
		return table.print();
	}

    /**
       Change the view to a different crossdate.

       @param crossdate the new crossdate to view
    */

    public void setCrossdate(Cross crossdate) {
	this.crossdate = crossdate;

	updateTable();
    }

	/**
	 The number of samples in this Grid.  Add one to this value to
	 get the number of cells high or wide the grid is.

	 @return the number of samples in this Grid
	 */

	public int size() {
		return num;
	}

	/**
	 Get a Cell from the grid.

	 @param row the row
	 @param column the column
	 @return the cell at (row, column)
	 */

	public Cell getCell(int row, int column) {
		// (cells are immutable, so this is safe.)
		return cell[row][column];
	}

	/**
	 Get the error that occurred while computing the grid.  The
	 run() method in Runnable can't throw any exceptions, so we just
	 store them here for later use.

	 @return an Exception, if one occurred, else null
	 */

	public Exception getError() {
		return error;
	}

	/**
	 A short preview for file dialogs.  Displays "Crossdating Grid",
	 and lists the first few elements.

	 @return a preview component for this grid
	 */

	public Preview getPreview() {
		return new GridPreview(this);
	}

  /**
   * Make a new graph (in a new window) from the selected crossdate.
   */

  public void graphSelectedCrossdate() {
    // get the row
    int row = table.getSelectedRow();

    // get the year (== end-date of moving sample)
    HighScore score = (HighScore) crossdate.getHighScores().getScores().get(row);
    Year y = score.movingRange.getEnd();

    // new cross at this offset
    new GraphWindow(crossdate, y);
  }

    /**
       Make a new graph (in a new window) from the selected crossdate.
    */

    public void graphSelectedCrossdate() {
	// get the (row,col) of the click
	int row = table.getSelectedRow();
	int col = table.getSelectedColumn();

	// get the year (== end-date of moving sample)
	Year y = ((ScoresTableModel) table.getModel()).getYear(row, col);

	// blank spot (TODO: better to just look for empty cell?)
	if (!crossdate.getRange().contains(y))
	    return;
	if (col == 0)
	    return;
	if ((row + crossdate.getRange().getStart().row() == 0) && (col == 1))
	    return;

	// new graph at this place
	new GraphWindow(crossdate, y);
    }

	/**
	 * Get the score at this row, col
	 * 
	 * @param row
	 * @param col
	 * @return
	 */

	public Float getScoreAt(int row, int col) {
		// for the year column
		if (col == 0) {
			return null;
		} else {
			// check for year zero
			if ((row + row_min == 0) && (col == 1))
				return null;
			
			Year year = getYear(row, col);

			if (cross.getRange().contains(year))
				return cross.getScore(year);
			else
				return null;
		}
	}

	/**
	 * Given the cell at row, col, give a range for
	 * the secondary sample that produced that score
	 * 
	 * @param row
	 * @param col
	 * @return
	 */

	public Range getSecondaryRangeForCell(int row, int col) {
		if(col == 0)
			return null; // nothing in this column
		
		// check for year zero
		if ((row + row_min == 0) && (col == 1))
			return null;

		// I think the logic behind this makes sense... but it makes my head hurt
		Year year = getYear(row, col);
		// essentially, redate the moving's end to the year in this row,col
		return cross.getMoving().getRange().redateEndTo(year);
	}

	/**
	 * Gets a redated sample, given a cell
	 * 
	 * @param row
	 * @param col
	 * @return
	 */

	public Sample getSecondaryForCell(int row, int col) {
		Range newRange = getSecondaryRangeForCell(row, col);
		
		if(newRange == null)
			return null;
		
		Sample redate = new Sample();
		
		Sample.copy(pairing.getSecondary(), redate);
		redate.setRange(newRange);
		
		return redate;
	}

	/**
	 * Get the overlap, given a range already
	 * 
	 * @param newRange
	 * @return
	 */

	public Integer getOverlapAt(Range newRange) {
		return (newRange == null) ? null : newRange.overlap(cross.getFixed().getRange());		
	}

	/** Return a prettier name for this cross: "R-Value".
	 @return the name of this cross, "R-Value" */

	public String getName() {
		return I18n.getText("statistics.rvalue");
	}

	/** A format string for R-values.
	 @return a format string for R-values */

	public String getFormat() {
		return App.prefs.getPref("corina.cross.rvalue.format", "0.00");
	}

	/** Compute the mean of an array of floats.
	 @param array the array of floats to average
	 @return the average (arithmetic mean) of the given array */

	private float mean(float array[]) {
		// (/ (reduce '+ array) (length array))
		float s = 0.0f;
		for (int i = 0; i < array.length; i++)
			s += array[i];
		return s / array.length;

		// what if array.length==0? -- only happens if one sample has no data (possible?)
	}

	/**
	 * Get a crossdate score.
	 * 
	 * Used only inside cross implementation by other crosses
	 * 
	 * @param index
	 *            the index of the score to get
	 * @return the score at that index
	 */

	protected float getScore(int index) {
		return data[index];
	}

	/**
	 * Get a crossdate score.
	 * 
	 * TODO -- (what if you want data.length? use getRange().span().)
	 * 
	 * @param year
	 *            the end year of the moving sample
	 * @return the score at that position
	 */

	public float getScore(Year year) {
		int index = year.diff(range.getStart());
		return data[index];
	}

	/**
	 * Get a crossdate score signifigance.
	 * 
	 * @param year
	 *            the end year of the moving sample
	 * @return the score signifigance at that position
	 */

	public int getScoreSignifigance(Year year) {
		int index = year.diff(range.getStart());
		return signifigance[index];
	}

	/**
	 * Returns the fixed sample.
	 * 
	 * @return the fixed sample
	 */

	public Sample getFixed() {
		return fixed;
	}

	/**
	 * Returns the moving sample.
	 * 
	 * @return the moving sample
	 */

	public Sample getMoving() {
		return moving;
	}

	/**
	 * Is the run finished?
	 * 
	 * @return true, if the crossdate is finished being run
	 */

	public boolean isFinished() {
		return finished;
	}

	/**
	 * Crossdate preamble: any setup that needs to be done before the main loop
	 * to compute individual scores.
	 * 
	 * ----deprecated the preamble was always kind of silly
	 * Not really - it's nice to separate this stuff!
	 */

	protected void preamble() {
		// nothing need be done by default

		// DELETE ME!
	}

	/**
	 * Returns the redated (secondary) sample for the specific row
	 * 
	 * @param row
	 * @return
	 */

	public Sample getSecondaryForRow(int row) {
		if(row < 0 || row > getRowCount())
			return null;

		Sample redate = new Sample();

		Sample.copy(pairing.getSecondary(), redate);
		redate.setRange(scores.get(row).range);
		
		return redate;
	}

	/**
	 * Returns the redated (secondary) sample range for the specific row
	 * 
	 * @param row
	 * @return
	 */

	public Range getSecondaryRangeForRow(int row) {
		if(row < 0 || row > getRowCount())
			return null;

		return new Range(scores.get(row).range.getStart(), scores.get(row).range.getEnd());
	}	

    /**
       Save a sample into the database.  This operation is atomic.

       @param sample the sample to save
       @exception SQLException if an SQL exception occurs
    */

    public void save(Sample sample) throws SQLException {
	connection.setAutoCommit(false);

	saveSample(sample);

	connection.commit();
	connection.setAutoCommit(true);
    }

    /**
       Import all files from a folder into the database.  All files in
       sub-folders will be imported, as well.  Non-dendro files are
       ignored.  The entire import is atomic.

       @param folder the folder to import
       @exception SQLException if there is an SQL exception while
       importing data
    */

    public void dump(String folder) throws SQLException {
	// connection.setAutoCommit(false);

	File f = new File(folder);

	if (f.isDirectory()) {
	    importFolder(f);
	} else {
	    importFile(f);
	}

	// connection.commit();
	// connection.setAutoCommit(true);
    }

    /**
     * Format this XML as pretty or not
     * Returns self, so you can do:
     *    new XMLBody(in).setPretty(true)...
     * @param pretty
     * @return
     */

    public XMLBody setPretty(boolean pretty) {
    	this.pretty = pretty;
    	
    	return this;
    }

	/**
	 * Get the current pageFormat
	 * @return the pageFormat
	 */

	public PageFormat getPageFormat() {
		return pageFormat;
	}

	/**
	 * Change the associated page format
	 * @param pageFormat
	 */

	public void setPageFormat(PageFormat pageFormat) {
		this.pageFormat = pageFormat;
	}

	/**
	 * Shortcut method for changing page orientation
	 * Works the same as calling getPageFormat().setOrientation(orientation)
	 * @see PageFormat#setOrientation(int)
	 * @param orientation one of PageFormat.LANDSCAPE, PageFormat.PORTRIAT, PageFormat.REVERSE_LANDSCAPE, etc
	 */

	public void setPageOrientation(int orientation) {
		pageFormat.setOrientation(orientation);
	}

	/**
	 * Actually print the PDF
	 * @throws PrinterException
	 */

	public void print(boolean showDialog) throws PrinterException {
		if(!showDialog || printJob.printDialog()) {
			// set the minimum margins for this paper (java defaults to 1"... wtf?)
			pageFormat = minimumMarginsFormat(pageFormat);
			
			printJob.print();
		}
	}

    /** Watch for mouse-pressed popup events.  Mac systems generate
	popup events on mouse-down.
	@param e the mouse-pressed event
    */

    @Override
	public void mousePressed(MouseEvent e) { // mac
	maybeShowPopup(e);
    }

    /** Watch for mouse-released popup events.  Windows systems
	generate popup events on mouse-up, because Windows supports
	what is perhaps the weirdest and most counterintuitive user
	interaction ever conceived: the
	right-click-drag-release-select-from-menu.
	@param e the mouse-released event
    */

    @Override
	public void mouseReleased(MouseEvent e) { // win32
	maybeShowPopup(e);
    }

    /**
       Called when a popup mouse event is generated.  Implement this
       method to do what you want on popup events.

       <p>The default behavior is:</p>
       <ul>
         <li>if a JTable was clicked on, and the row that was clicked
         on was not selected, select it (and deselect the rows that
         were selected)

	 <li>show the popup here (assuming it's non-null)
       </ul>

       <p>Remember, you can get the position of the click with
       e.getX() and e.getY(), and the component that was clicked on
       with e.getComponent().</p>

       @param e the popup mouse event
    */

    public void showPopup(MouseEvent e) {
	// if table, and this row not selected, select this row
	if (e.getSource() instanceof JTable) {
	    JTable table = (JTable) e.getSource();
	    int row = table.rowAtPoint(e.getPoint());
	    if (row!=-1 && !table.isRowSelected(row))
		table.setRowSelectionInterval(row, row);
	}

	// show popup
	if (popup != null)
	    popup.show(e.getComponent(), e.getX(), e.getY());
    }

    /**
       A "document changed" update occured.  Calls update().
       @param e the document event
    */

    public void changedUpdate(DocumentEvent e) {
	update(e);
    }

    /**
       A "document insert" update occured.  Calls update().
       @param e the document event
    */

    public void insertUpdate(DocumentEvent e) {
	update(e);
    }

    /**
       A "document remove" update occured.  Calls update().
       @param e the document event
    */

    public void removeUpdate(DocumentEvent e) {
	update(e);
    }

	/**
	 * Convenience method to recreate a list without making a new one
	 * @param c
	 */

	public void replaceContents(Collection<? extends E> c) {
		if(!isEmpty())
			clear();
		addAll(c);
	}

	/**
	 * Return a sanitized filename
	 * @return
	 */

	public String getFilename() {
		String fn = (String) s.getMeta("filename");
		ArrayList<String> segments = new ArrayList<String>();
		File f = new File(fn);
		int depth = 0;
		
		fn = f.getName();
		do {
			segments.add(fn);
			
			f = f.getParentFile();
			fn = f.getName();
			depth++;
		} while((fn.length() == 3 || fn.equalsIgnoreCase("forest") || depth == 1) && fn.toLowerCase().indexOf("data") == -1);
		
		StringBuffer sb = new StringBuffer();
		for(int i = segments.size() - 1; i >= 0; i--) {
			if(sb.length() != 0)
				sb.append(File.separator);
			sb.append(segments.get(i));
		}
		
		return sb.toString();
	}

	/**
	 * Output the XML document to a string
	 */

	public String toString() {
		try {
			Transformer xformer = TransformerFactory.newInstance().newTransformer();
			DOMSource source = new DOMSource(domElement);
			StringWriter sw = new StringWriter();
			StreamResult result = new StreamResult(sw);
			
			xformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, showXmlDeclaration ? "no" : "yes");
			xformer.setOutputProperty(OutputKeys.INDENT, pretty ? "yes" : "no");
			
			xformer.transform(source, result);
			
			return sw.toString();
		} catch (Exception e) {
			return "<error: " + e.getMessage() + " >";
		}
	}

	/**
	 * Implementation of the ListModel interface
	 */

	public Object getElementAt(int index) {
		return this.get(index);
	}

	/**
	 * Implementation of the ListModel interface
	 */

	public int getSize() {
		return this.size();
	}

	/**
	 * Implementation of the method in the ListModel interface
	 * @param listener ListDataListener
	 */

	public void addListDataListener(ListDataListener listener) {
		if (listDataListeners == null) {
			listDataListeners = new ArrayList<ListDataListener>();
		}
		if (!listDataListeners.contains(listener)) {
			listDataListeners.add(listener);
		}
	}

	/**
	 * Implementation of the method in the ListModel interface
	 * @param listener ListDataListener
	 */

	public void removeListDataListener(ListDataListener listener) {
		if (listDataListeners != null) {
			listDataListeners.remove(listener);
		}
	}

	/**
	 * Return the type of bug and message for this bug report
	 */

	public String toString() {
		return bug.toString();
	}

    /**
       The compare method used by Comparator.  Simply calls
<pre>
   return compare((String) o1, (String) o2);
</pre>

       @param o1 the first string to compare
       @param o2 the second string to compare
       @return the result of their comparison
    */

    public int compare(Object o1, Object o2) {
	return compare((String) o1, (String) o2);
    }

    /** Write a portion of a character array, except <code>'\r'</code>
	characters.
	@param cbuf the character array to read from
	@param off the offset into the array to start reading
	@param len the number of characters to read out of the array */

    @Override
	public void write(char[] cbuf, int off, int len) {        
        for (int i=off; i<off+len; i++) {
            char c = cbuf[i];
            if (c != '\r')
                super.write(c);
        }
    }

    /**
     * Is the given log level currently enabled?
     *
     * @param logLevel is this level enabled?
     */

    protected boolean isLevelEnabled(int logLevel) {
        // log level are numerically ordered so can use simple numeric
        // comparison
        return (logLevel >= currentLogLevel);
    }

    /**
     * <p> Log a message with debug log level.</p>
     */

    public void debug(Object message) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_DEBUG)) {
            log(SimpleLog.LOG_LEVEL_DEBUG, message, null);
        }
    }

    /**
     * <p> Log an error with debug log level.</p>
     */

    public void debug(Object message, Throwable t) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_DEBUG)) {
            log(SimpleLog.LOG_LEVEL_DEBUG, message, t);
        }
    }

	/**
	 * Get the starting year of this range.
	 * 
	 * @return the starting year
	 */

	public Year getStart() {
		return start;
	}

	/**
	 * Get the ending year of this range.
	 * 
	 * @return the ending year
	 */

	public Year getEnd() {
		return end;
	}

    /**
     * <p> Log a message with debug log level.</p>
     */

    public void trace(Object message) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_TRACE)) {
            log(SimpleLog.LOG_LEVEL_TRACE, message, null);
        }
    }

	/**
	 * Set the starting year of the range, and adjust the ending year to
	 * maintain the same length.
	 * 
	 * @param y
	 *            new starting year for the range
	 * @see #redateEndTo
	 */

	public Range redateStartTo(Year y) {
		return redateBy(y.diff(start));
	}

	/**
	 * Redate a range by a certain number of years. Usually, you'll use
	 * redateStartTo() or redateEndTo(), which are more convenient.
	 * 
	 * @param dy
	 *            the number of years to shift this range by
	 */

	public Range redateBy(int dy) {
		return new Range(start.add(dy), end.add(dy));
	}

    /**
     * <p> Log an error with debug log level.</p>
     */

    public void trace(Object message, Throwable t) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_TRACE)) {
            log(SimpleLog.LOG_LEVEL_TRACE, message, t);
        }
    }

	/**
	 * Return the number of years spanned by this range. For example, the range
	 * 1001 - 1005 spans 5 years.
	 * 
	 * @return the span of this range (difference between start and end,
	 *         inclusive)
	 */

	public int span() {
		return end.diff(start) + 1;
	}

    /**
     * <p> Log a message with info log level.</p>
     */

    public void info(Object message) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {
            log(SimpleLog.LOG_LEVEL_INFO,message,null);
        }
    }

	/**
	 * Compute the number of rows this Range will take to display, assuming rows
	 * are marked off as the row() method does.
	 * 
	 * @return the number of rows this range spans
	 */

	public int rows() {
		return getEnd().row() - getStart().row() + 1;
	}

    /**
     * <p> Log an error with info log level.</p>
     */

    public void info(Object message, Throwable t) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {
            log(SimpleLog.LOG_LEVEL_INFO, message, t);
        }
    }

	/**
	 * Return a string representation of the range, including the span, like
	 * "(1001 - 1036, n=36)".
	 * 
	 * @return a string representation of the range, including span
	 */

	public String toStringWithSpan() {
		return "(" + start + " - " + end + ", n=" + span() + ")";
		// use \u2014 EM DASH?
	}

    /**
     * <p> Log a message with warn log level.</p>
     */

    public void warn(Object message) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_WARN)) {
            log(SimpleLog.LOG_LEVEL_WARN, message, null);
        }
    }

	/**
	 * Return true if (and only if) the given year is inside the range,
	 * inclusive.
	 * 
	 * @param y
	 *            year to check
	 * @return true if <code>y</code> is in the range, else false
	 */

	public boolean contains(Year y) {
		return (start.compareTo(y) <= 0) && (y.compareTo(end) <= 0);
	}

	/**
	 * Return true if (and only if) the given range is completely inside the
	 * range, inclusive.
	 * 
	 * @param r
	 *            range to check
	 * @return true if <code>r</code> is entirely in the range, else false
	 */

	public boolean contains(Range r) {
		return contains(r.start) && contains(r.end);
	}

    /**
     * <p> Log an error with warn log level.</p>
     */

    public void warn(Object message, Throwable t) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_WARN)) {
            log(SimpleLog.LOG_LEVEL_WARN, message, t);
        }
    }

	/**
	 * Return true, iff this year is the start of a row. (Year 1 is considered
	 * the start of that row.)
	 * 
	 * @return true, iff this year is the start of a row
	 */

	public boolean startOfRow(Year y) {
		return y.equals(start) || y.column() == 0 || y.isYearOne();
	}

	/**
	 * Return true, iff this year is the end of a row.
	 * 
	 * @return true, iff this year is the end of a row
	 */

	public boolean endOfRow(Year y) {
		return y.equals(end) || y.column() == 9;
	}

    /**
     * <p> Log a message with error log level.</p>
     */

    public void error(Object message) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_ERROR)) {
            log(SimpleLog.LOG_LEVEL_ERROR, message, null);
        }
    }

	/**
	 * Return the number of years overlap between this range and the given
	 * range.
	 * 
	 * @param r
	 *            range to compare
	 * @return number of years overlap
	 */

	public int overlap(Range r) {
		return intersection(r).span();
	}

	/**
	 * The intersection of this range with r. If they don't overlap, returns an
	 * empty range (1 - -1).
	 * 
	 * @see #union
	 * @param r
	 *            the range to intersect with this range
	 * @return the intersection of this and r
	 */

	public Range intersection(Range r) {
		return new Range(Year.max(start, r.start), Year.min(end, r.end));
	}

	/**
	 * The union of this range with r. Since there is no concept of
	 * "range with a gap" in Corina, it assumes they overlap.
	 * 
	 * @see #intersection
	 * @param r
	 *            the range to union with this range
	 * @return the union of this and r
	 */

	public Range union(Range r) {
		return new Range(Year.min(start, r.start), Year.max(end, r.end));
	}

    /**
     * <p> Log an error with error log level.</p>
     */

    public void error(Object message, Throwable t) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_ERROR)) {
            log(SimpleLog.LOG_LEVEL_ERROR, message, t);
        }
    }

    /**
     * <p> Log a message with fatal log level.</p>
     */

    public void fatal(Object message) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_FATAL)) {
            log(SimpleLog.LOG_LEVEL_FATAL, message, null);
        }
    }

	/**
	 * Compares this and o, for placing in fallback order. Fallback order sorts
	 * ranges by their ending year, latest to earliest, and then by their
	 * length, longest to shortest. (This is usually what people want when
	 * looking at bargraphs.)
	 * 
	 * @param o
	 *            Object to compare
	 * @return >0, ==0, or <0 if this is greater-than, equal-to, or less-than o
	 * @throws ClassCastException
	 *             if o is not a Range
	 */

	public int compareTo(Range r2) {

		int c1 = end.compareTo(r2.end);
		if (c1 != 0)
			return c1;

		// negative, because fallback puts longest samples first
		int c2 = -start.compareTo(r2.start);
		return c2;
	}

    /**
     * <p> Log an error with fatal log level.</p>
     */

    public void fatal(Object message, Throwable t) {

        if (isLevelEnabled(SimpleLog.LOG_LEVEL_FATAL)) {
            log(SimpleLog.LOG_LEVEL_FATAL, message, t);
        }
    }

        /**
         * Method added by PHIL. [Thanks, PHIL. -Rob]
         * This pads the buffer without closing the stream.
         * @throws java.io.IOException  if there's an error.
         */

        public void flushBase64() throws java.io.IOException  {
            if( position > 0 ) {
                if( encode ) {
                    out.write( encode3to4( b4, buffer, position, options ) );
                    position = 0;
                }   // end if: encoding
                else {
                    throw new java.io.IOException( "Base64 input not properly padded." );
                }   // end else: decoding
            }   // end if: buffer partially full

        }   // end flush

        /**
         * Suspends encoding of the stream.
         * May be helpful if you need to embed a piece of
         * base64-encoded data in a stream.
         *
         * @throws java.io.IOException  if there's an error flushing
         * @since 1.5.1
         */

        public void suspendEncoding() throws java.io.IOException  {
            flushBase64();
            this.suspendEncoding = true;
        }   // end suspendEncoding

        /**
         * Resumes encoding of the stream.
         * May be helpful if you need to embed a piece of
         * base64-encoded data in a stream.
         *
         * @since 1.5.1
         */

        public void resumeEncoding() {
            this.suspendEncoding = false;
        }   // end resumeEncoding

	/**
	 * Save a single sample.
	 * Pops up a dialog box asking for the file name to save to, exports to the type 
	 * passed in 'format' (ie, corina.Formats.Tucson)
	 * 
	 * @param exportee the sample to export
	 * @return The full path of the exported file name, or null if not saved
	 */

	public String saveSingleSample(Sample exportee, String format) {
		
		// use the default title...		
		String title = I18n.getText("export") + " " + exportee.getDisplayTitle();
		
		return saveSingleSample(exportee, format, title);
	}

	/**
	 * Save a list of samples in packed format.
	 * Pops up a dialog box asking for the file name to save to, exports to the type chosen in the
	 * visible popup menu.
	 * 
	 * @param exportee the sample to export
	 * @return the full path of the saved packed sample, or null if not saved
	 */

	public String savePackedSample(List slist, String format) {
		return savePackedSample(slist, format, I18n.getText("export"));
	}

	/**
	 * Saves multiple samples.
	 * Pops up a dialog box asking for a folder to save to;
	 * files are dumped in to this folder with a default extension added, ie:
	 * ACM123.PIK becomes ACM123.PIK.TUC
	 * 
	 * @param slist a List of samples
	 * @return a List of saved file names, or null if not saved.
	 */

	public List saveMultiSample(List slist, String format) {
		return saveMultiSample(slist, format, "Choose an Export Folder");
	}

	/**
	 * Same as calling scaleToFitHeight(1)
	 */

	public void scaleToFitHeight() {
		scaleToFitHeight(1);
	}

	/**
	 * Set this as the default
	 */

	public void setDefault() {
		GraphPrefs.PLOT_AGENT.set(this);
	}

	/**
	 * Get the internationalization tag for this plot agent
	 * @return "agent_xxx"
	 */

	public String getI18nTag() 
	{		
		if(this.toString().equals(PlotAgent.SEMILOG.toString())) return "graph.agent_semilog";
		else if (this.toString().equals(PlotAgent.STANDARD.toString()))	return "graph.agent_standard";
		else if (this.toString().equals(PlotAgent.TOOTHED.toString())) return "graph.agent_toothed";
		else return null;
		
	}

    /**
     * Set the plotting agent
     * @param agent
     */

    public void setAgent(PlotAgent agent) { 
    	if(canChangeAgent)
    		graphAgent = agent; 
    }

    /**
     * Set the highlighted state of this graph
     * @param highlighted
     */

    public void setHighlighted(boolean highlighted) {
    	this.highlighted = highlighted;
    }

    /**
     * Is this graph mouseover highlighted
     * @return true on highlgiht
     */

    public boolean isHighlighted() {
    	return highlighted;
    }

    /**
     * Get the plotter
     * @return The plotter used to graph this
     */

    public CorinaGraphPlotter getPlotter() {
    	return graphAgent.getPlotter();
    }

	/**
	 * Acquire a printing version of this graphInfo
	 * 
	 * @return a GraphInfo copy for printing
	 */

	public GraphInfo getPrinter() {
		return new GraphInfo(this, true);
	}

	/**
	 * Reset graph colors to their default values
	 */

	public void resetColors() {
		if (!printing) {
			backgroundColor = GraphPrefs.BACKGROUND.get();
			foreColor = GraphPrefs.FOREGROUND.get();
			majorLineColor = GraphPrefs.MAJOR_LINE.get();
			minorLineColor = ColorUtils.blend(majorLineColor, backgroundColor);
			midLineColor = ColorUtils.blend(majorLineColor, minorLineColor);
		} else {
			backgroundColor = GraphPrefs.BACKGROUND_PRINT.get();
			foreColor = GraphPrefs.FOREGROUND_PRINT.get();
			majorLineColor = GraphPrefs.MAJOR_LINE_PRINT.get();
			minorLineColor = ColorUtils.blend(majorLineColor, backgroundColor);
			midLineColor = ColorUtils.blend(majorLineColor, minorLineColor);			
		}
	}

	/**
	 * Get the associated graph
	 * @return a Graph structure
	 */

	public Graph getGraph() {
		return graph;
	}

	/**
	 * Get the event type
	 * @return a GrapherEvent.Type
	 */

	public Type getEventType() {
		return eventType;
	}

	/**
	 * Get the graph height (via the panel, or the printHeight if printing)
	 * @param panel
	 * @return the height, in pixels
	 */

	public int getGraphHeight(JPanel panel) {
		return printing ? this.printHeight : panel.getHeight();
	}

    /** Run all the indexes. */

    private void compute() {
        // i put this in run(), so it could be threaded, but is it worth it?
        // -- for 100yr sample x 10 indexes, 900mhz athlon: 30-40ms.
        // so no, it's probably not worth it.
        // TODO: put this in the constructor.
        for (int i=0; i<indexes.size(); i++)
            (indexes.get(i)).run();
    }

	/**
	 * Apply an index directly to a sample, not using a server...
	 * @param index
	 */

	private void legacyApplyIndex(Index index) {
		index.apply();

		// undo (index implements undoable)
		sample.postEdit(index);

		// also: clear filename, set modified
		sample.setModified();
		sample.removeMeta("filename"); // BUG: this should be in
										// Index.apply()
		// (otherwise undo doesn't put the filename back)

		// tell editor, and close
		sample.fireSampleDataChanged();
		sample.fireSampleMetadataChanged();		
	}

	/**
	   Return the name of this index in a user-readable format.  This
	   abstract class returns the name of the instantiated class (like
	   "CubicSpline")

	   @return the name of this index
	 */

	public String getName() {
		String tag = ixFunction.getI18nTag();
		String trailer = ixFunction.getI18nTagTrailer();
		
		if(trailer == null)
			return I18n.getText(tag);
		
		return MessageFormat.format(I18n.getText(tag),
				new Object[] { trailer });
		/*
		String fqdn = getClass().getName();
		int dotIndex = fqdn.lastIndexOf(".");
		return fqdn.substring(dotIndex + 1);
		*/
	}

	/**
	 * Method to determine if this field is a list (ie, combobox)
	 * 
	 * @return true if this field contains a list of values, 
	 * false if it is free-editable (ie, a text field)
	 */

	public boolean isList() {
		return hasSetValues;
	}

	/**
	 * Update the master list
	 * @param masterList a new list, can't be null
	 */

	public void setMasterList(List<? extends Number> masterList) {
		if(masterList == null)
			throw new NullPointerException();
		
		this.masterList = masterList;
	}

	/**
	 * Resets the internal values list
	 * @param in
	 */

	public void setData(List<Number> in) {
		data = (in != null) ? new HookableNumericArrayList<Number>(this, in)
				: new HookableNumericArrayList<Number>(this);
		values.clear();

		for (int i = 0, len = values.size(); i < len; i++) {
			TridasValue value = new TridasValue();

			value.setValue(data.get(i).toString());
			//value.setIndex(Integer.toString(i));

			values.add(value);
		}

		if (usesCounts) {
			count.setMasterList(data);
			checkCountsValid();

			if (countsValid)
				copyOverCounts();
		}
	}

	/**
	 * Resets the internal count list
	 * @param in
	 */

	public void setCount(List<Integer> in) {
		if(!usesCounts) {
			if(in == null || in.isEmpty())
				return;
			
			for(int i = 0, len = in.size(); i < len; i++) {
				Integer v = in.get(i);
				
				if(v != null && v != 1) 
					throw new IllegalArgumentException("Counts contains a non-trival count");
			}
			
			return;
		}
		
		count = (in != null) ? new HookableCountArrayList(this, in, data)
				: new HookableCountArrayList(this, data);
		checkCountsValid();
		
		if(countsValid)
			copyOverCounts();
		else
			clearCounts();
	}

	/** 
	 * Get the actual underlying size of the count list
	 * (size() is overridden to match the master list)
	 * @return the actual size
	 */

	protected int actualSize() {
		return super.size();
	}

	/**
	 * Get the actual underlying empty status
	 * @return true if no count exists, false otherwise
	 */

	protected boolean actualIsEmpty() {
		return super.isEmpty();
	}

	/**
	 * Get the WJ string for this index
	 * Does no range checking
	 * @param index
	 * @return A weiserjahre value in "incr/decr" form
	 */

	private String wjForIndex(int index) {
		return incr.get(index) + "/" + decr.get(index);
	}

	/**
	 * Recursively add all objects to the list
	 * Deals with the object tree being n-deep
	 * @param obj
	 * @param view
	 */

	private void recursiveAdd(TridasObjectEx obj, ListViews view) {
		view.allObjects.add(obj);
		view.bySiteCode.put(obj.getLabCode(), obj);
		
		if(obj.hasChildren()) {
			for(TridasObjectEx child : ListUtil.subListOfType(obj.getObjects(), TridasObjectEx.class))
				recursiveAdd(child, view);
		}
	}

	/**
	 * Find a tridas object by site code
	 * 
	 * @param siteCode
	 * @return a tridas object
	 */

	public TridasObjectEx findObjectBySiteCode(String siteCode) {
		synchronized(data) {
			return data.bySiteCode.get(siteCode);
		}
	}

	/**
	 * Gets a key for this parent object
	 * @param parentObject
	 * @return
	 */

	private String getKey(ITridas parentObject) {
		XmlRootElement root = parentObject.getClass().getAnnotation(XmlRootElement.class);
		TridasIdentifier identifier = parentObject.getIdentifier();
			
		if(root != null)
			return root.name() + ":" + identifier.toString();
		else
			return parentObject.getClass().getName() + ":" + identifier.toString();
	}

	/**
	 * Replace a property by identity (==).
	 *  
	 * @param oldProp the property to replace
	 * @param newProp the property to replace it with
	 */

	public void replaceChildProperty(TridasEntityProperty oldProp, TridasEntityProperty newProp) {
		int nProps = childProperties.size();
		for(int i = 0; i < nProps; i++) {
			if(childProperties.get(i) == oldProp)
				childProperties.set(i, newProp);
		}
	}

	/**
	 * Remove the geometry
	 */

	private void selectNull() {
		TridasLocationGeometry oldGeometry = geometry;
		label.setValue(null);
		geometry = null;
		
		firePropertyChange(oldGeometry, geometry);
	}

	/**
	 * Pop up a dialog and select a new geometry
	 */

	private void selectGeometry() {
		TridasLocationGeometry oldGeometry = geometry;
		LocationGeometry dialog = new LocationGeometry();
		
		// show the dialog...
		dialog.showDialog(SwingUtilities.getWindowAncestor(editor), geometry);
		
		// cancelled...
		if(!dialog.hasResults())
			return;
		
		geometry = dialog.getGeometry();
		label.setValue(geometry);
		firePropertyChange(oldGeometry, geometry);
	}

	/**
	 * Does this class represent an enum property?
	 * If true, getEnumType() can be called
	 * @return true if this class represents an enum property
	 */

	public boolean representsEnumType() {
		return clazz.isEnum();
	}

	/**
	 * Set the type of the class
	 * 
	 * Checks to see if we have dictionary mappings and
	 * other annotations.
	 * 
	 * @param clazz
	 * @param field
	 */

	public void setType(Class<?> clazz, Field field) {
		this.clazz = clazz;		
	}

	/**
	 * Writes the value of the Property to the given object. It uses reflection
	 * and looks for a method starting with "set" followed by the capitalized
	 * Property name and with one parameter with the same type as the Property.
	 */

	public void writeToObject(Object object) {
		try {
			Method method = BeanUtils.getWriteMethod(object.getClass(),
					getName(), getType());
			if (method != null) {
				method.invoke(object, new Object[] { getExternalTranslatedValue(getValue()) });
			}
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Translate the value for external representation
	 * (how it's supposed to be represented in the object)
	 * @return
	 */

	protected Object getExternalTranslatedValue(Object value) {
		return value;
	}

	/**
	 * Remove the popup from the screen
	 * @param resetFilter remove a filter, if true
	 */

	private void cleanupPopup(boolean resetFilter) {
		if(isPopupShowing) {
			searchPanel.setVisible(false);
			isPopupShowing = false;
		}
		
		if(resetFilter) {
			filter.setFilterText("");
			model.setFilter(filter);
		}
	}

	/**
	 * Translate the value for internal representation
	 * (This is what we display in our property table)
	 * @param value
	 * @return
	 */

	protected Object getInternalTranslatedValue(Object value) {
		return value;
	}

	/**
	 * Get the information in this dialog as represented by a TridasLocationGeometry
	 * @return a geometry
	 * @throws IllegalStateException if the dialog hasn't been used properly
	 */

	public TridasLocationGeometry getGeometry() {
		if(!hasResults)
			throw new IllegalStateException();
		
		TridasLocationGeometry geometry = new TridasLocationGeometry();
		PointType point = new PointType();
		geometry.setPoint(point);
		
		// TODO: Actually implement detecting this and putting in the right standards
		point.setSrsName("EPSG:4326");
		
		Pos pos = new Pos();
		point.setPos(pos);
		
		pos.getValues().add(Double.valueOf(spnDDLong.getValue().toString()));
		pos.getValues().add(Double.valueOf(spnDDLat.getValue().toString()));
		
		return geometry;
	}

	/**
	 * Called when the text in the search field changes
	 */

	private void searchFieldChanged() {
		filter.setFilterText(searchField.getText());
		model.setFilter(filter);
	}

	/**
	 * Change the message when the graph is empty
	 * @param emptyGraphText
	 */

	public void setEmptyGraphText(String emptyGraphText) {
		this.emptyGraphText = emptyGraphText;
	}

	/**
	 * Paint a "Nothing to graph" when there's nothing available
	 * @param g
	 */

	private void paintNoGraphs(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;

		Composite oldComposite = g2.getComposite();
		Font oldFont = g2.getFont();
		
		g2.setColor(Color.blue.darker());
		g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.4f));
		g2.setFont(g2.getFont().deriveFont(72.0f));
		
		int width = g2.getFontMetrics().stringWidth(emptyGraphText);
		
		float x = (float)((getWidth() / 2) - (width / 2)); 
		float y = (float)(getHeight() / 2);

		g2.drawString(emptyGraphText, x, y);
		
		g2.setComposite(oldComposite);
		g2.setFont(oldFont);
	}

	/** 
	 * Clear the list of site codes
	 */

	public void clearSites() {
		this.siteCodes.clear();
		this.siteTitles.clear();
	}

	/** Scale an icon down to 20x20 */

	private ImageIcon scaleIcon20x20(ImageIcon icon) {
		return new ImageIcon(icon.getImage().getScaledInstance(20, 20, Image.SCALE_SMOOTH));
	}

	/**
	 * Compare two string values, but try them as integers
	 * 
	 * @param o1
	 * @param o2
	 * @return -1, 0, or 1, if o1 is less than, equal to, or greater than o2
	 */

	private int compare(String o1, String o2) {
		// nicely handle nulls
		if (o1 == null && o2 == null)
			return 0;

		// nulls go last
		if (o1 == null)
			return 1;
		if (o2 == null)
			return -1;

		Integer i1 = null, i2 = null;
		try {
			i1 = Integer.valueOf(o1);
		} catch (NumberFormatException nfe) {
		}
		
		try {
			i2 = Integer.valueOf(o2);
		} catch (NumberFormatException nfe) {
		}

		// both strings, string compare!
		if (i1 == null && i2 == null)
			return o1.compareToIgnoreCase(o2);

		// strings go last
		if (i1 == null)
			return 1;
		if (i2 == null)
			return -1;

		// flat out integers!
		return i1.compareTo(i2);
	}

	/**
	 * Determines if this is a top level object (has no parent)
	 * @return true if this is a top level object
	 */

	public boolean isTopLevelObject() {
		return (parentObject == null);
	}

	/**
	 * Get the parent object
	 * @return The parent object, or null if it doesn't exist
	 */

	public TridasObjectEx getParent() {
		return parentObject;
	}

	/**
	 * Determines if this has any children
	 * @return true of there are any sub-object children
	 */

	public boolean hasChildren() {
		return isSetObjects();
	}

	/**
	 * Does this object have a lab code?
	 * @return true if getLabCode would return a valid labcode
	 */

	public boolean hasLabCode() {
		return (labCode != null);
	}

	/**
	 * Sets the graph plot agent for all non-density graphs
	 * Must call update(true) for graphs to be redrawn
	 * @param agent
	 */

	public void setPlotAgent(PlotAgent agent) {
		this.plotAgent = agent;
	}

	/**
	 * Get a text representation of this site
	 * @return A string in the form of '[CODE] title'
	 */

	public String toTitleString() {
		if(labCode == null || labCode.equals(title))
			return title;
		
		return "[" + labCode + "] " + title;
	}

	/**
	 * Preprocess the query response
	 * 
	 * Use this to check for things such as validity, login errors, etc, 
	 * and handle them appropriately. The default implementation always
	 * returns success.
	 * 
	 * If a failure occurs, throw a descriptive ResourceException. 
	 * Returning FAILURE just throws a generic ResourceException.
	 * 
	 * @param object
	 * @return a PreprocessResult
	 * @throws ResourceException 
	 * @throws UserCancelledException 
	 * @see PreprocessResult for stuff
	 */

	protected PreprocessResult preprocessQuery(INTYPE object) throws ResourceException, UserCancelledException {
		return PreprocessResult.SUCCESS;
	}

	/**
	 * Internal method: called when the query succeeds
	 * 
	 * @param object
	 */

	private void doQuerySucceeded(INTYPE object) {
		try {
			// Call our (potentially overridden) querySucceeded method
			querySucceeded(object);
		} finally {
			// Notify listeners that everything went well
			// no matter what!
			fireResourceEvent(new ResourceEvent(this, ResourceEvent.RESOURCE_QUERY_COMPLETE, object));
		}
	}

	/**
	 * Called by either button press to update the UI state
	 */

	private void chooseOrCancelUIUpdate() {
		// disable/enable editing
		editEntity.setEnabled(!changingTop);
		topChooser.setEnabled(changingTop);
		changeButton.setText(changingTop ? OK_STATE : CHANGE_STATE);
		cancelChangeButton.setVisible(changingTop);		
	}

	/**
	 * Internal method: called when the query fails
	 * 
	 * @param e the exception of failure!
	 */

	private void doQueryFailed(Exception e) {
		try {
			// Call our (potentially overridden) queryFailed method
			queryFailed(e);
		} finally {	
			// Notify listeners that our query failed
			// No matter what!
			fireResourceEvent(new ResourceEvent(this, ResourceEvent.RESOURCE_QUERY_FAILED, e));
		}
	}

	/**
	 * Called if processQueryResult returns true
	 * 
	 * @param object The successful in object
	 */

	protected void querySucceeded(INTYPE object) {
	}

	/**
	 * Called when the 'Change' button is pressed
	 * Activates the combo box, allowing for changes
	 */

	private void changeButtonPressed() {
		
		// Make sure we populate our combobox with everything from the server
		populateComboAndSelect(true);
		
		if(topChooser.getSelectedItem() == EntityListComboBox.NEW_ITEM)
			propertiesTable.setPreviewText(I18n.getText("general.choose").toUpperCase());
		else
			propertiesTable.setPreviewText(I18n.getText("general.preview").toUpperCase());
		propertiesTable.setPreviewing(true);
		
		// we're starting to change...
		changingTop = true;

		chooseOrCancelUIUpdate();
	}

	/**
	 * In this function, handle any failure condition.
	 * This is only called if processQueryResult() is not called.
	 */

	protected void queryFailed(Exception e) {
		System.err.println("Failed to query resource " + resourceName);
		e.printStackTrace();
		
		if(e instanceof ResourceException && e.getCause() != null) {
			System.err.println("Caused by:");
			e.getCause().printStackTrace();
		}
	}

	/**
	 * This procedure simply starts a new thread and calls queryWait
	 */

	public void query() {
		queryThread = new Thread() {
			@Override
			public void run() {
				queryWait();
				
				queryThread = null;
			}
		};
		
		queryThread.start();
	}

	/**
	 * Populate any parameters in a newly created entity
	 * @param type the current EditType
	 * @param entity the corresponding entity
	 */

	protected void populateNewEntity(EditType type, ITridas entity) {
		entity.setTitle("New " + type.displayTitle);
	}

	/**
	 * Associate an owner window with this resource (can be null)
	 * @param window
	 */

	public void setOwnerWindow(Window window) {
		this.ownerWindow = window;
	}

	/**
	 * Get the associated owner window (can be null)
	 * @return
	 */

	public Window getOwnerWindow() {
		return this.ownerWindow;
	}

	/**
	 * Whether the graph should scroll vertically
	 * Defaults to false
	 * 
	 * @param useVerticalScrollbar
	 */

	public void setUseVerticalScrollbar(boolean useVerticalScrollbar) {
		this.useVerticalScrollbar = useVerticalScrollbar;
	}

	/**
	 * Set a property to the given value
	 * @param propertyName
	 * @param value
	 */

	public void setProperty(String propertyName, Object value) {
		// lazy-create properties
		if(properties == null) 
			properties = new HashMap<String, Object>();
		
		properties.put(propertyName, value);
	}

	/**
	 * Add all the properties in the given map
	 * @param newProperties
	 */

	public void setProperties(Map<String, ? extends Object> newProperties) {
		// lazy-create properties
		if(properties == null) 
			properties = new HashMap<String, Object>();
		
		properties.putAll(newProperties);
	}

	/**
	 * Check to see if this property is set
	 * @param propertyName
	 * @return true if this property exists, false otherwise
	 */

	public boolean hasProperty(String propertyName) {
		if(properties == null)
			return false;
		
		return properties.containsKey(propertyName);
	}

	/**
	 * Set the schema to validate against
	 * @param schema the schema, or null for no validation
	 */

	public void setValidateSchema(Schema schema) {
		this.validateSchema = schema;
	}

	/**
	 * Set the type associated with this result
	 * @param associatedResult
	 */

	protected void setAssociatedResult(T associatedResult) {
		this.associatedResult = associatedResult;
	}

	/**
	 * Get the type associated with this result
	 * @return
	 */

	public T getAssociatedResult() {
		if(associatedResult == null)
			throw new IllegalStateException("getAssociatedResult() has a null result");
		
		return associatedResult;
	}

	/**
	 * Sort a list of ITridas objects
	 * 
	 * @param list
	 */

	private void sortList(List<? extends ITridas> list) {
		// Sort list intelligently
		TridasComparator numSorter = new TridasComparator(TridasComparator.Type.TITLES, 
				TridasComparator.NullBehavior.NULLS_LAST, 
				TridasComparator.CompareBehavior.AS_NUMBERS_THEN_STRINGS);
		
		Collections.sort(list, numSorter);		
	}

	/**
	 * Get the numeric code associated with this error
	 * 
	 * @return The code associated with this error
	 */

	public int getNumericCode() {
		return numericCode;
	}

	/**
	 * Gets the entity we're submitting to the server
	 * for create or update.
	 * <p>
	 * Used by SeriesResource to handle version changes. 
	 * 
	 * @return the create or update entity, or null if it isn't present
	 */

	protected ITridas getCreateOrUpdateEntity() {
		return createOrUpdateEntity;
	}

	/**
	 * Checks to see if the entity is in the given list
	 * 
	 * @param entity
	 * @param list
	 * @return The entity in the list (may be another instance) or null
	 */

	private ITridas entityInList(ITridas entity, List<?> list) {
		for(Object o : list) {
			if(o instanceof ITridas) {
				ITridas otherEntity = (ITridas) o;
				
				if(matchEntities(entity, otherEntity))
					return otherEntity;
			}
		}
		
		return null;
	}

	/**
	 * Retrieve the server's nonce
	 * @return
	 */

	public String getServerNonce() {
		return srvNonce;
	}

	/**
	 * Retrieve the server's nonce sequence
	 * @return
	 */

	public String getServerNonceSeq() {
		return seq;
	}

	/**
	 * Compute an md5 hash of this string
	 * 
	 * @param in
	 * @return an md5 hash, in string format
	 */

	private String md5(String in) {
		try {
			MessageDigest digest = MessageDigest.getInstance("MD5");
			
			digest.update(in.getBytes());
			
			return StringUtils.bytesToHex(digest.digest());
		} catch (Exception e) {
			new Bug(e);
			return "<error>";
		}	
	}

	/**
	 * Find a sample in our results that matches this identifier
	 * 
	 * @param identifier
	 * @return a sample, or null
	 */

	public Sample getSample(TridasIdentifier identifier) {
		for(BaseSample bs : getAssociatedResult()) {
			if(bs.getSeries().getIdentifier().equals(identifier)) {
				if(!(bs instanceof Sample))
					throw new IllegalStateException("Found identifier but no sample??");
				
				return (Sample) bs;
			}
		}
		
		return null;
	}

	/**
	 * DANGER: do not use this during the processing of a query
	 * 
	 * @param queryType the queryType to set
	 */

	protected void setQueryType(CorinaRequestType queryType) {
		this.queryType = queryType;
	}

	/**
	 * Populate the combo box with a list
	 * @param goRemote ensure we have remote stuff in the list
	 */

	private void populateComboAndSelect(boolean goRemote) {
		// get the list of stuff that goes in the box
		List<? extends ITridas> entityList = getEntityList(goRemote);
		
		topChooser.setList(entityList);

		// select what we already have, if it exists
		ITridas selectedEntity = currentMode.getEntity(s);
		
		// otherwise, try to choose something nicely
		if(selectedEntity == null)
			selectedEntity = suggestSelectedEntity(currentMode, entityList);
		
		selectInCombo(selectedEntity);		
	}

	/**
	 * Concatenate the contents of a WSIMessage
	 * 
	 * @param msg
	 * @return
	 */

	private String WSIMessageAsString(WSIMessage msg) {
		StringBuffer sb = new StringBuffer();

		for (Object o : msg.getContent()) {
			if (o instanceof String)
				sb.append((String) o);
			else if (o instanceof org.w3c.dom.Element) {
				sb.append(new DomToString((org.w3c.dom.Element) o, false));
			}
		}

		return sb.toString();
	}

	/**
	 * Set to true to return all objects of type 'returnObject'
	 * Useful to search for all sites, for instance
	 * @param all
	 */

	public void addSearchForAll() {
		if(hasConstraints || hasAllConstraint)
			throw new IllegalArgumentException("Cannot have both search constraints and all constraint/multiple all constraints");
		this.setAll(new All());
		asText += "[all]";
		hasAllConstraint = true;
	}

	/**
	 * Marshall the object to disk...
	 * 
	 * @param obj
	 */

	private void save(Object obj) {
		if(myResource == null)
			return;
		
		try {
			Marshaller marshaller = getJAXBContext().createMarshaller();
			NamespacePrefixMapper nspm = getNamespacePrefixMapper();

			marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
			if (nspm != null)
				marshaller.setProperty("com.sun.xml.bind.namespacePrefixMapper", nspm);
			
			marshaller.marshal(obj, getCacheFile());
		} catch (JAXBException e) {
			System.err.println("Couldn't save cache for "
					+ myResource.getResourceName() + ": " + e.getMessage());
		}
	}

	/**
	 * Populate this cookie store from an Apache cookie store
	 * @param cs
	 */

	public void fromCookieStore(CookieStore cs) {
		boolean storeChanged = false;
		
		for(Cookie c : cs.getCookies()) {
			String hv = hashCookie(c);
			WSCookieWrapper cw = cookies.get(hv);
			
			// cookie already exists and is unchanged
			if(cw != null && cw.equals(c))
				continue;

			// (re-)wrap a cookie
			cookies.put(hv, new WSCookieWrapper(c));
			storeChanged = true;
			
			System.out.println("New Cookie: " + hv);
		}
		
		if(storeChanged) {
			WSCookieStoreHandler.save(this);
		}
	}	

	/**
	 * Suggest a selection for the given mode
	 * 
	 * @param mode the mode
	 * @param list a list of acceptable options for the mode
	 * @return null to choose 'new', a member of the list, or really any ITridas derived thing
	 */

	protected ITridas suggestSelectedEntity(EditType mode, List<? extends ITridas> list) {
		if(list.size() == 1)
			return list.get(0);
		
		return null;
	}

	/**
	 * The important part of this: query the server. This is a blocking call.
	 * 
	 * @return A DOM document
	 * @throws IOException
	 */

	public INTYPE query() throws IOException {
		return doRequest();
	}

	/**
	 * Quick and dirty debug: gets a stack trace
	 * @return
	 */

	private String getStackTrace() {
		PureStringWriter sw = new PureStringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Throwable().printStackTrace(pw);
		return sw.toString();
	}

	/**
	 * Gets the schema object that we use for validation
	 * 
	 * @return the schema object, or null for no validation
	 */

	protected Schema getValidationSchema() {
		return null;
	}

	/**
	 * Get the JAXB context for this accessor
	 * 
	 * @return the jaxb context
	 * @throws JAXBException
	 */

	protected JAXBContext getJAXBContext() throws JAXBException {
		return JAXBContext.newInstance();
	}

	/**
	 * Disable buttons below, enable buttons above
	 * @param type
	 */

	private void disableBelowEnableAbove(EditType type) {
		boolean enabled = true;
		
		for(EditType t : EditType.values()) {
			t.enableAssociatedButton(enabled);
			
			if(t == type)
				enabled = false;
		}
	}

	/**
	 * Get a namespace prefix mapper for this instance
	 * @return
	 */

	protected NamespacePrefixMapper getNamespacePrefixMapper() {
		return null;
	}

	/**
	 * Set the object to use as an output request
	 * 
	 * @param reqObj
	 */

	public void setRequestObject(OUTTYPE reqObj) {
		this.sendingObject = reqObj;
	}

	/**
	 * Creates a button to the button panel
	 * @param type
	 * @return
	 */

	private AbstractButton addButton(final EditType type) {
 		Action action = new AbstractAction(type.getTitle(), type.getIcon()) {
			public void actionPerformed(ActionEvent e) {				
				buttonAction(type);
			}
		};
		
		JToggleButton button = new JToggleButton(action);
		type.associateButton(button);
		
		return button;
	}

	/**
	 * Meant to be overridden:
	 * 
	 * @param parentPreferredDimensions JPanel's idea of what our size should be
	 * @param scrollExtentDimensions our parent JScrollPane viewport's size
	 * @return our preferred dimensions
	 */

	public Dimension getPreferredSize(Dimension parentPreferredDimensions, Dimension scrollExtentDimensions) {
		parentPreferredDimensions.height = scrollExtentDimensions.height;
		
		return parentPreferredDimensions;		
	}

	/** Return the folder the browser is currently viewing.
	 @return the folder currently being browsed */

	public String getFolder() {
		return folder;
	}

		/** 
		 * Get an entity from the sample
		 * 
		 * @param s
		 * @return
		 */

		public ITridas getEntity(Sample s) {
			if(this == DERIVED_SERIES || this == MEASUREMENT_SERIES)
				return s.getSeries();
			
			return s.getMeta(metadataTag, ITridas.class);
		}

		/**
		 * Called when the status of the horizontal scrollbar chaged
		 */

		public void horizontalScrollbarStatusChanged() {
			ensureScrollerExists();
			
			if (!gInfo.isShowBaselines())
				scroller.getHorizontalScrollBar().removeAdjustmentListener(this);
			else
				scroller.getHorizontalScrollBar().addAdjustmentListener(this);			
		}

		/**
		 * Associate a button with this type
		 * @param button
		 */

		public void associateButton(AbstractButton button) {
			associatedButton = button;
		}

		/**
		 * Get the associated button
		 * @return
		 */

		public AbstractButton getButton() {
			return associatedButton;
		}

		/**
		 * Called when the status of the vertical axis changed
		 */

		public void verticalAxisStatusChanged() {
			ensureScrollerExists();

			if (gInfo.isShowVertAxis()) {
				vertaxis = new Axis(gInfo, PlotAgent.getDefault().getAxisType(), GrapherPanel.this);
				scroller.setRowHeaderView(vertaxis);
			} else {
				scroller.setRowHeaderView(null);
			}			
		}

		/**
		 * Enable or disable the associated button
		 * Has no effect on series
		 * @param enabled
		 */

		public void enableAssociatedButton(boolean enabled) {
			if(this == DERIVED_SERIES || this == MEASUREMENT_SERIES || this == BOX)
				return;
			
			if(associatedButton != null) {
				associatedButton.setEnabled(enabled);
			}
		}

		/**
		 * Called when our underlying property changes
		 */

		public void propertyChanged() {
			hasChanged = true;
		}

	/**
	 * Add a grapher listener to this graph
	 * @param listener
	 */

	public void addGrapherListener(GrapherListener listener) {
		grapherListeners.add(GrapherListener.class, listener);
	}

	/**
	 * Remove a grapher listener from this graph
	 * @param listener
	 */

	public void removeGrapherListner(GrapherListener listener) {
		grapherListeners.remove(GrapherListener.class, listener);
	}

    /**
        Return the currently selected folder.

        @return the selected folder
    */

    public File getFolder() {
        // note: it's immutable, so this is safe.
        return folder;
    }

    /**
        Get the top-level folder of this popup.

        @return the top-level folder of this popup
    */

    public File getTopLevel() {
        // note: it's immutable, so this is safe.
        return toplevel;
    }

    /**
        Add a new listener.

        @param listener the listener to add
    */

    public void addChangeListener(ChangeListener listener) {
        if (!listeners.contains(listener))
            listeners.add(listener);
    }

    /**
        Remove a listener.

        @param listener the listener to remove
    */

    public void removeChangeListener(ChangeListener listener) {
        listeners.remove(listener);
    }

		/**
		 * Gets the previous EditType in the order
		 * @return
		 */

		public EditType previous() {
			switch(this) {
			case ELEMENT:
				return OBJECT;
			case SAMPLE:
				return ELEMENT;
			case RADIUS:
				return SAMPLE;
			case MEASUREMENT_SERIES:
				return RADIUS;
			default:
				return null;
			}
		}

		/**
		 * Gets the next EditType in the order
		 * @return
		 */

		public EditType next() {
			switch(this) {
			case OBJECT:
				return ELEMENT;
			case ELEMENT:
				return SAMPLE;
			case SAMPLE:
				return RADIUS;
			default:
				return null;
			}
		}

	/**
	 * Called when someone changes something on our property list
	 */

	public void propertyChange(PropertyChangeEvent evt) {
		Object n;
		if(evt.getOldValue() == null && (n = evt.getNewValue()) != null && n.toString().equals(""))
			return;
		
		if(currentMode == null)
			throw new IllegalStateException("Property changed with null mode??");

		currentMode.propertyChanged();
	}

    /**
        Set a new sort column.  This is the text string to
        match of the headers.  The null value is not allowed.

        @param sortColumn the name of the new column which
        is used for sorting
    */

    public void setSortColumn(String sortColumn) {
        if (sortColumn == null)
            throw new NullPointerException();
    
        this.sortColumn = sortColumn;
    }

    /** Add a "New Folder" menuitem. */

    protected void addNewFolderMenuItem() {
        JMenuItem newFolder = Builder.makeMenuItem("new_folder", /*WRITEME:*/false);
         // TODO: create new folder
         // TODO: select it, and start editing its name inline (need renaming first!)
         // -- what if i'm not displaying folders in the browser?  dialog?  no, edit on top ... what if it's a popup?
         // TODO: undoable, as long as nothing has been created/moved inside it
        // -- in which case moving/creating something inside it is undoable, and then this is undoable.
        add(newFolder);
    }

    /** Add a "Page Setup..." menuitem. */

    protected void addPageSetupMenuItem() {
        JMenuItem setup = Builder.makeMenuItem("page_setup...");
        setup.addActionListener(new AbstractAction() { // REFACTOR: this taken verbatim from XMenubar
            public void actionPerformed(ActionEvent ae) {
                // make printer job, if none exists yet
                if (printJob == null)
                    printJob = PrinterJob.getPrinterJob();

                // get page format
                pageFormat = printJob.pageDialog(pageFormat);
            }
        });
        add(setup);
    }

	/**
	 * This function actually does the SQL Insert work...
	 * Trust that our newVMeasurementID contains no ' chars?
	 */

	public void batchAddStatements(Statement s, String newVMeasurementResultID) throws SQLException {
		String header = "INSERT into tblVMeasurementReadingResult (VMeasurementResultID,RelYear,Reading) VALUES ('";
		int truncateLength = header.length();
		StringBuffer b = new StringBuffer(header);		
		
		int len = output.size();
		for(int i = 0; i < len; i++) {
			b.setLength(truncateLength);
			
			b.append(newVMeasurementResultID);
			b.append("',");
			b.append(relYear.get(i));
			b.append(',');
			b.append(output.get(i).intValue());
			b.append(")");
			s.addBatch(b.toString());
		}
	}

	/**
	 * Closes all prepared statements.
	 * @throws SQLException
	 */

	public void cleanup() throws SQLException {
		Iterator<String> i = queries.keySet().iterator();
		
		while(i.hasNext()) {
			StatementQueryHolder sq = queries.get(i.next());
			if(sq != null)
				sq.cleanup();
		}
	}

	/**
	 Return the one selected row.  If more than one row is selected,
	 usually this is the last row the user clicked on, and has a white
	 outline or something like that around it - but you shouldn't
	 expect just one row when there's actually more than one.  If
	 nothing is selected, an exception is thrown.

	 @return the selected row
	 @exception NoSuchElementException if nothing is selected
	 */

	public Row getSelectedRow() throws NoSuchElementException {
		int selection = table.getSelectedRow();
		if (selection != -1)
			return (Row) visibleFiles.get(selection);
		else
			throw new NoSuchElementException();
	}

	/**
	 * Starts the recursive process that gets the VMeasurementResult UUID
	 * 
	 * Why a routine for 'safe' cleanup? Well, cleanup works under the native pl/java driver,
	 * but doesn't work under the postgresql jdbc driver. Thus making testing a nightmare!
	 * 
	 * @param VMeasurementID
	 * @param safe true if we should attempt to rollback on failure
	 * @throws SQLException
	 */

	private void acquireVMeasurementResult(UUID VMeasurementID, boolean safe) throws SQLException {
		if(safe) {
			// If we have an error, clean up any mess we made, but pass along the exception.
			Savepoint beforeCreation = dbq.getConnection().setSavepoint();
			
			try {
				result = recursiveGetVMeasurementResult(VMeasurementID, null, null, 0);
			} catch (SQLException sql) {
				dbq.getConnection().rollback(beforeCreation);
				throw sql;
			} finally {
				dbq.getConnection().releaseSavepoint(beforeCreation);
			}					
		}
		else
			result = recursiveGetVMeasurementResult(VMeasurementID, null, null, 0);
	}

	/**
	 Return an Iterator that emits all of the selected Rows.
	 @return an Iterator that goes throw all of the selected Rows
	 */

	public Iterator getSelectedRows() {
		return new Iterator() {
			int rows[] = table.getSelectedRows();

			int i = 0;

			public boolean hasNext() {
				return (i < rows.length);
			}

			public Object next() throws NoSuchElementException {
				if (i < rows.length)
					return visibleFiles.get(i++);
				else
					throw new NoSuchElementException();
			}

			public void remove() {
				throw new UnsupportedOperationException();
			}
		};
	}

	/**
	 * Compute and populate our output variable. Results available via getOutput()
	 * 
	 * In our base class, we do some sanity checking.
	 * We cannot index twice, as some things rely on being set up properly first. This could be fixed,
	 * but seems unnecessary.
	 */

	public void doIndex() {
		System.out.println("Starting index function " + getI18nTag());
		if(input == null)
			throw new IllegalArgumentException("Index function has not been properly initilaized");
		if(alreadyIndexed)
			throw new IllegalArgumentException("Index function has already been run");
		else
			alreadyIndexed = true;
		
		index();
	}

    /**
     * Gets the value of the addressLine1 property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getAddressLine1() {
        return addressLine1;
    }

    /**
     * Sets the value of the addressLine1 property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAddressLine1(String value) {
        this.addressLine1 = value;
    }

    /**
     * Gets the value of the addressLine2 property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getAddressLine2() {
        return addressLine2;
    }

    /**
     * Sets the value of the addressLine2 property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAddressLine2(String value) {
        this.addressLine2 = value;
    }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link ControlledVoc }
     *     
     */

    public ControlledVoc getType() {
        return type;
    }

    /**
     * Gets the value of the cityOrTown property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCityOrTown() {
        return cityOrTown;
    }

    /**
     * Sets the value of the type property.
     * 
     * @param value
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setType(ControlledVoc value) {
        this.type = value;
    }

    /**
     * Sets the value of the cityOrTown property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCityOrTown(String value) {
        this.cityOrTown = value;
    }

    /**
     * Gets the value of the stateProvinceRegion property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getStateProvinceRegion() {
        return stateProvinceRegion;
    }

    /**
     * Sets the value of the stateProvinceRegion property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setStateProvinceRegion(String value) {
        this.stateProvinceRegion = value;
    }

    /**
     * Gets the value of the postalCode property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getPostalCode() {
        return postalCode;
    }

    /**
     * Sets the value of the postalCode property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setPostalCode(String value) {
        this.postalCode = value;
    }

    /**
     * Gets the value of the country property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCountry() {
        return country;
    }

    /**
     * Sets the value of the country property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCountry(String value) {
        this.country = value;
    }

    /**
     * Gets the value of the linkSeries property.
     * 
     * @return
     *     possible object is
     *     {@link SeriesLinksWithPreferred }
     *     
     */

    public SeriesLinksWithPreferred getLinkSeries() {
        return linkSeries;
    }

    /**
     * Sets the value of the linkSeries property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesLinksWithPreferred }
     *     
     */

    public void setLinkSeries(SeriesLinksWithPreferred value) {
        this.linkSeries = value;
    }

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */

    public XMLGregorianCalendar getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */

    public void setValue(XMLGregorianCalendar value) {
        this.value = value;
    }

    /**
     * Gets the value of the taxon property.
     * 
     * @return
     *     possible object is
     *     {@link ControlledVoc }
     *     
     */

    public ControlledVoc getTaxon() {
        return taxon;
    }

    /**
     * Gets the value of the certainty property.
     * 
     * @return
     *     possible object is
     *     {@link Certainty }
     *     
     */

    public Certainty getCertainty() {
        return certainty;
    }

    /**
     * Sets the value of the certainty property.
     * 
     * @param value
     *     allowed object is
     *     {@link Certainty }
     *     
     */

    public void setCertainty(Certainty value) {
        this.certainty = value;
    }

    /**
     * Sets the value of the taxon property.
     * 
     * @param value
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setTaxon(ControlledVoc value) {
        this.taxon = value;
    }

    /**
     * Gets the value of the shape property.
     * 
     * @return
     *     possible object is
     *     {@link TridasShape }
     *     
     */

    public TridasShape getShape() {
        return shape;
    }

    /**
     * Sets the value of the shape property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasShape }
     *     
     */

    public void setShape(TridasShape value) {
        this.shape = value;
    }

    /**
     * Gets the value of the normalTridas property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasRemark }
     *     
     */

    public NormalTridasRemark getNormalTridas() {
        return normalTridas;
    }

    /**
     * Sets the value of the normalTridas property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasRemark }
     *     
     */

    public void setNormalTridas(NormalTridasRemark value) {
        this.normalTridas = value;
    }

    /**
     * Gets the value of the inheritedCount property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getInheritedCount() {
        return inheritedCount;
    }

    /**
     * Gets the value of the dimensions property.
     * 
     * @return
     *     possible object is
     *     {@link TridasDimensions }
     *     
     */

    public TridasDimensions getDimensions() {
        return dimensions;
    }

    /**
     * Sets the value of the inheritedCount property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setInheritedCount(Integer value) {
        this.inheritedCount = value;
    }

    /**
     * Sets the value of the dimensions property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasDimensions }
     *     
     */

    public void setDimensions(TridasDimensions value) {
        this.dimensions = value;
    }

    /**
     * Gets the value of the authenticity property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getAuthenticity() {
        return authenticity;
    }

    /**
     * Sets the value of the authenticity property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAuthenticity(String value) {
        this.authenticity = value;
    }

    /**
     * Gets the value of the type property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasDatingType }
     *     
     */

    public NormalTridasDatingType getType() {
        return type;
    }

    /**
     * Sets the value of the type property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasDatingType }
     *     
     */

    public void setType(NormalTridasDatingType value) {
        this.type = value;
    }

    /**
     * Gets the value of the location property.
     * 
     * @return
     *     possible object is
     *     {@link TridasLocation }
     *     
     */

    public TridasLocation getLocation() {
        return location;
    }

    /**
     * Sets the value of the location property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasLocation }
     *     
     */

    public void setLocation(TridasLocation value) {
        this.location = value;
    }

    /**
     * Gets the value of the processing property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getProcessing() {
        return processing;
    }

    /**
     * Sets the value of the processing property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setProcessing(String value) {
        this.processing = value;
    }

    /**
     * Gets the value of the marks property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getMarks() {
        return marks;
    }

    /**
     * Sets the value of the marks property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setMarks(String value) {
        this.marks = value;
    }

    /**
     * Gets the value of the altitude property.
     * 
     * @return
     *     possible object is
     *     {@link Double }
     *     
     */

    public Double getAltitude() {
        return altitude;
    }

    /**
     * Sets the value of the altitude property.
     * 
     * @param value
     *     allowed object is
     *     {@link Double }
     *     
     */

    public void setAltitude(Double value) {
        this.altitude = value;
    }

    /**
     * Gets the value of the slope property.
     * 
     * @return
     *     possible object is
     *     {@link TridasSlope }
     *     
     */

    public TridasSlope getSlope() {
        return slope;
    }

    /**
     * Sets the value of the slope property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasSlope }
     *     
     */

    public void setSlope(TridasSlope value) {
        this.slope = value;
    }

    /**
     * Gets the value of the normalTridas property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasVariable }
     *     
     */

    public NormalTridasVariable getNormalTridas() {
        return normalTridas;
    }

    /**
     * Sets the value of the normalTridas property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasVariable }
     *     
     */

    public void setNormalTridas(NormalTridasVariable value) {
        this.normalTridas = value;
    }

    /**
     * Gets the value of the soil property.
     * 
     * @return
     *     possible object is
     *     {@link TridasSoil }
     *     
     */

    public TridasSoil getSoil() {
        return soil;
    }

    /**
     * Sets the value of the soil property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasSoil }
     *     
     */

    public void setSoil(TridasSoil value) {
        this.soil = value;
    }

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */

    public BigInteger getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */

    public void setValue(BigInteger value) {
        this.value = value;
    }

    /**
     * Gets the value of the bedrock property.
     * 
     * @return
     *     possible object is
     *     {@link TridasBedrock }
     *     
     */

    public TridasBedrock getBedrock() {
        return bedrock;
    }

    /**
     * Gets the value of the suffix property.
     * 
     * @return
     *     possible object is
     *     {@link DatingSuffix }
     *     
     */

    public DatingSuffix getSuffix() {
        return suffix;
    }

    /**
     * Sets the value of the bedrock property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasBedrock }
     *     
     */

    public void setBedrock(TridasBedrock value) {
        this.bedrock = value;
    }

    /**
     * Sets the value of the suffix property.
     * 
     * @param value
     *     allowed object is
     *     {@link DatingSuffix }
     *     
     */

    public void setSuffix(DatingSuffix value) {
        this.suffix = value;
    }

    /**
     * Gets the value of the dating property.
     * 
     * @return
     *     possible object is
     *     {@link TridasDating }
     *     
     */

    public TridasDating getDating() {
        return dating;
    }

    /**
     * Sets the value of the dating property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasDating }
     *     
     */

    public void setDating(TridasDating value) {
        this.dating = value;
    }

    /**
     * Gets the value of the firstYear property.
     * 
     * @return
     *     possible object is
     *     {@link Year }
     *     
     */

    public Year getFirstYear() {
        return firstYear;
    }

    /**
     * Sets the value of the firstYear property.
     * 
     * @param value
     *     allowed object is
     *     {@link Year }
     *     
     */

    public void setFirstYear(Year value) {
        this.firstYear = value;
    }

    /**
     * Gets the value of the lastYear property.
     * 
     * @return
     *     possible object is
     *     {@link Year }
     *     
     */

    public Year getLastYear() {
        return lastYear;
    }

    /**
     * Sets the value of the lastYear property.
     * 
     * @param value
     *     allowed object is
     *     {@link Year }
     *     
     */

    public void setLastYear(Year value) {
        this.lastYear = value;
    }

    /**
     * Sets the value of the files property.
     * 
     * @param files
     *     allowed object is
     *     {@link TridasFile }
     *     
     */

    public void setFiles(List<TridasFile> files) {
        this.files = files;
    }

    /**
     * Gets the value of the datingReference property.
     * 
     * @return
     *     possible object is
     *     {@link TridasDatingReference }
     *     
     */

    public TridasDatingReference getDatingReference() {
        return datingReference;
    }

    /**
     * Sets the value of the datingReference property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasDatingReference }
     *     
     */

    public void setDatingReference(TridasDatingReference value) {
        this.datingReference = value;
    }

    /**
     * Sets the value of the genericFields property.
     * 
     * @param genericFields
     *     allowed object is
     *     {@link TridasGenericField }
     *     
     */

    public void setGenericFields(List<TridasGenericField> genericFields) {
        this.genericFields = genericFields;
    }

    /**
     * Gets the value of the pithYear property.
     * 
     * @return
     *     possible object is
     *     {@link Year }
     *     
     */

    public Year getPithYear() {
        return pithYear;
    }

    /**
     * Sets the value of the pithYear property.
     * 
     * @param value
     *     allowed object is
     *     {@link Year }
     *     
     */

    public void setPithYear(Year value) {
        this.pithYear = value;
    }

    /**
     * Gets the value of the deathYear property.
     * 
     * @return
     *     possible object is
     *     {@link Year }
     *     
     */

    public Year getDeathYear() {
        return deathYear;
    }

    /**
     * Sets the value of the deathYear property.
     * 
     * @param value
     *     allowed object is
     *     {@link Year }
     *     
     */

    public void setDeathYear(Year value) {
        this.deathYear = value;
    }

    /**
     * Gets the value of the provenance property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getProvenance() {
        return provenance;
    }

    /**
     * Sets the value of the provenance property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setProvenance(String value) {
        this.provenance = value;
    }

    /**
     * Sets the value of the statFoundations property.
     * 
     * @param statFoundations
     *     allowed object is
     *     {@link TridasStatFoundation }
     *     
     */

    public void setStatFoundations(List<TridasStatFoundation> statFoundations) {
        this.statFoundations = statFoundations;
    }

    /**
     * Gets the value of the statValue property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getStatValue() {
        return statValue;
    }

    /**
     * Sets the value of the statValue property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setStatValue(BigDecimal value) {
        this.statValue = value;
    }

    /**
     * Gets the value of the significanceLevel property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getSignificanceLevel() {
        return significanceLevel;
    }

    /**
     * Sets the value of the significanceLevel property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setSignificanceLevel(BigDecimal value) {
        this.significanceLevel = value;
    }

    /**
     * Gets the value of the usedSoftware property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getUsedSoftware() {
        return usedSoftware;
    }

    /**
     * Sets the value of the usedSoftware property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setUsedSoftware(String value) {
        this.usedSoftware = value;
    }

    /**
     * Gets the value of the category property.
     * 
     * @return
     *     possible object is
     *     {@link TridasCategory }
     *     
     */

    public TridasCategory getCategory() {
        return category;
    }

    /**
     * Gets the value of the measuringDate property.
     * 
     * @return
     *     possible object is
     *     {@link Date }
     *     
     */

    public Date getMeasuringDate() {
        return measuringDate;
    }

    /**
     * Sets the value of the measuringDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link Date }
     *     
     */

    public void setMeasuringDate(Date value) {
        this.measuringDate = value;
    }

    /**
     * Sets the value of the category property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasCategory }
     *     
     */

    public void setCategory(TridasCategory value) {
        this.category = value;
    }

    /**
     * Gets the value of the derivationDate property.
     * 
     * @return
     *     possible object is
     *     {@link Date }
     *     
     */

    public Date getDerivationDate() {
        return derivationDate;
    }

    /**
     * Gets the value of the investigator property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getInvestigator() {
        return investigator;
    }

    /**
     * Sets the value of the derivationDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link Date }
     *     
     */

    public void setDerivationDate(Date value) {
        this.derivationDate = value;
    }

    /**
     * Sets the value of the investigator property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setInvestigator(String value) {
        this.investigator = value;
    }

    /**
     * Gets the value of the woodCompleteness property.
     * 
     * @return
     *     possible object is
     *     {@link TridasWoodCompleteness }
     *     
     */

    public TridasWoodCompleteness getWoodCompleteness() {
        return woodCompleteness;
    }

    /**
     * Gets the value of the period property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getPeriod() {
        return period;
    }

    /**
     * Sets the value of the woodCompleteness property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasWoodCompleteness }
     *     
     */

    public void setWoodCompleteness(TridasWoodCompleteness value) {
        this.woodCompleteness = value;
    }

    /**
     * Sets the value of the period property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setPeriod(String value) {
        this.period = value;
    }

    /**
     * Gets the value of the analyst property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getAnalyst() {
        return analyst;
    }

    /**
     * Gets the value of the requestDate property.
     * 
     * @return
     *     possible object is
     *     {@link Date }
     *     
     */

    public Date getRequestDate() {
        return requestDate;
    }

    /**
     * Sets the value of the analyst property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAnalyst(String value) {
        this.analyst = value;
    }

    /**
     * Sets the value of the requestDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link Date }
     *     
     */

    public void setRequestDate(Date value) {
        this.requestDate = value;
    }

    /**
     * Gets the value of the dendrochronologist property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getDendrochronologist() {
        return dendrochronologist;
    }

    /**
     * Gets the value of the commissioner property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCommissioner() {
        return commissioner;
    }

    /**
     * Sets the value of the dendrochronologist property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setDendrochronologist(String value) {
        this.dendrochronologist = value;
    }

    /**
     * Sets the value of the commissioner property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCommissioner(String value) {
        this.commissioner = value;
    }

    /**
     * Gets the value of the measuringMethod property.
     * 
     * @return
     *     possible object is
     *     {@link TridasMeasuringMethod }
     *     
     */

    public TridasMeasuringMethod getMeasuringMethod() {
        return measuringMethod;
    }

    /**
     * Sets the value of the measuringMethod property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasMeasuringMethod }
     *     
     */

    public void setMeasuringMethod(TridasMeasuringMethod value) {
        this.measuringMethod = value;
    }

    /**
     * Gets the value of the linkSeries property.
     * 
     * @return
     *     possible object is
     *     {@link SeriesLinks }
     *     
     */

    public SeriesLinks getLinkSeries() {
        return linkSeries;
    }

    /**
     * Sets the value of the linkSeries property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesLinks }
     *     
     */

    public void setLinkSeries(SeriesLinks value) {
        this.linkSeries = value;
    }

    /**
     * Gets the value of the objective property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getObjective() {
        return objective;
    }

    /**
     * Sets the value of the objective property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setObjective(String value) {
        this.objective = value;
    }

    /**
     * Sets the value of the types property.
     * 
     * @param types
     *     allowed object is
     *     {@link ControlledVoc }
     *     
     */

    public void setTypes(List<ControlledVoc> types) {
        this.types = types;
    }

    /**
     * Gets the value of the standardizingMethod property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getStandardizingMethod() {
        return standardizingMethod;
    }

    /**
     * Sets the value of the standardizingMethod property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setStandardizingMethod(String value) {
        this.standardizingMethod = value;
    }

    /**
     * Sets the value of the laboratories property.
     * 
     * @param laboratories
     *     allowed object is
     *     {@link TridasLaboratory }
     *     
     */

    public void setLaboratories(List<TridasLaboratory> laboratories) {
        this.laboratories = laboratories;
    }

    /**
     * Sets the value of the references property.
     * 
     * @param references
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setReferences(List<String> references) {
        this.references = references;
    }

    /**
     * Gets the value of the author property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getAuthor() {
        return author;
    }

    /**
     * Sets the value of the researches property.
     * 
     * @param researches
     *     allowed object is
     *     {@link TridasResearch }
     *     
     */

    public void setResearches(List<TridasResearch> researches) {
        this.researches = researches;
    }

    /**
     * Sets the value of the author property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAuthor(String value) {
        this.author = value;
    }

    /**
     * Gets the value of the version property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getVersion() {
        return version;
    }

    /**
     * Sets the value of the version property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setVersion(String value) {
        this.version = value;
    }

    /**
     * Gets the value of the interpretationUnsolved property.
     * 
     * @return
     *     possible object is
     *     {@link TridasInterpretationUnsolved }
     *     
     */

    public TridasInterpretationUnsolved getInterpretationUnsolved() {
        return interpretationUnsolved;
    }

    /**
     * Sets the value of the interpretationUnsolved property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasInterpretationUnsolved }
     *     
     */

    public void setInterpretationUnsolved(TridasInterpretationUnsolved value) {
        this.interpretationUnsolved = value;
    }

    /**
     * Gets the value of the interpretation property.
     * 
     * @return
     *     possible object is
     *     {@link TridasInterpretation }
     *     
     */

    public TridasInterpretation getInterpretation() {
        return interpretation;
    }

    /**
     * Sets the value of the interpretation property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasInterpretation }
     *     
     */

    public void setInterpretation(TridasInterpretation value) {
        this.interpretation = value;
    }

    /**
     * Create an instance of {@link TridasIdentifier }
     * 
     */

    public TridasIdentifier createTridasIdentifier() {
        return new TridasIdentifier();
    }

    /**
     * Create an instance of {@link TridasFile }
     * 
     */

    public TridasFile createTridasFile() {
        return new TridasFile();
    }

    /**
     * Create an instance of {@link SeriesLink }
     * 
     */

    public SeriesLink createSeriesLink() {
        return new SeriesLink();
    }

    /**
     * Gets the value of the missingHeartwoodRingsToPith property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getMissingHeartwoodRingsToPith() {
        return missingHeartwoodRingsToPith;
    }

    /**
     * Create an instance of {@link TridasCoverage }
     * 
     */

    public TridasCoverage createTridasCoverage() {
        return new TridasCoverage();
    }

    /**
     * Sets the value of the missingHeartwoodRingsToPith property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setMissingHeartwoodRingsToPith(Integer value) {
        this.missingHeartwoodRingsToPith = value;
    }

    /**
     * Gets the value of the missingHeartwoodRingsToPithFoundation property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getMissingHeartwoodRingsToPithFoundation() {
        return missingHeartwoodRingsToPithFoundation;
    }

    /**
     * Sets the value of the missingHeartwoodRingsToPithFoundation property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setMissingHeartwoodRingsToPithFoundation(String value) {
        this.missingHeartwoodRingsToPithFoundation = value;
    }

    /**
     * Create an instance of {@link TridasSlope }
     * 
     */

    public TridasSlope createTridasSlope() {
        return new TridasSlope();
    }

    /**
     * Gets the value of the presence property.
     * 
     * @return
     *     possible object is
     *     {@link ComplexPresenceAbsence }
     *     
     */

    public ComplexPresenceAbsence getPresence() {
        return presence;
    }

    /**
     * Sets the value of the presence property.
     * 
     * @param value
     *     allowed object is
     *     {@link ComplexPresenceAbsence }
     *     
     */

    public void setPresence(ComplexPresenceAbsence value) {
        this.presence = value;
    }

    /**
     * Create an instance of {@link TridasPith }
     * 
     */

    public TridasPith createTridasPith() {
        return new TridasPith();
    }

    /**
     * Create an instance of {@link ControlledVoc }
     * 
     */

    public ControlledVoc createControlledVoc() {
        return new ControlledVoc();
    }

    /**
     * Create an instance of {@link TridasVocabulary }
     * 
     */

    public TridasVocabulary createTridasVocabulary() {
        return new TridasVocabulary();
    }

    /**
     * Gets the value of the content property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getContent() {
        return content;
    }

    /**
     * Sets the value of the content property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setContent(String value) {
        this.content = value;
    }

    /**
     * Gets the value of the presence property.
     * 
     * @return
     *     possible object is
     *     {@link PresenceAbsence }
     *     
     */

    public PresenceAbsence getPresence() {
        return presence;
    }

    /**
     * Sets the value of the presence property.
     * 
     * @param value
     *     allowed object is
     *     {@link PresenceAbsence }
     *     
     */

    public void setPresence(PresenceAbsence value) {
        this.presence = value;
    }

    /**
     * Create an instance of {@link TridasElement }
     * 
     */

    public TridasElement createTridasElement() {
        return new TridasElement();
    }

    /**
     * Create an instance of {@link TridasBedrock }
     * 
     */

    public TridasBedrock createTridasBedrock() {
        return new TridasBedrock();
    }

    /**
     * Create an instance of {@link TridasLaboratory }
     * 
     */

    public TridasLaboratory createTridasLaboratory() {
        return new TridasLaboratory();
    }

    /**
     * Sets the value of the values property.
     * 
     * @param values
     *     allowed object is
     *     {@link TridasValues }
     *     
     */

    public void setValues(List<TridasValues> values) {
        this.values = values;
    }

    /**
     * Create an instance of {@link TridasProject }
     * 
     */

    public TridasProject createTridasProject() {
        return new TridasProject();
    }

    /**
     * Create an instance of {@link TridasSoil }
     * 
     */

    public TridasSoil createTridasSoil() {
        return new TridasSoil();
    }

    /**
     * Create an instance of {@link TridasLastRingUnderBark }
     * 
     */

    public TridasLastRingUnderBark createTridasLastRingUnderBark() {
        return new TridasLastRingUnderBark();
    }

    /**
     * Create an instance of {@link TridasHeartwood }
     * 
     */

    public TridasHeartwood createTridasHeartwood() {
        return new TridasHeartwood();
    }

    /**
     * Create an instance of {@link TridasValues }
     * 
     */

    public TridasValues createTridasValues() {
        return new TridasValues();
    }

    /**
     * Create an instance of {@link TridasDerivedSeries }
     * 
     */

    public TridasDerivedSeries createTridasDerivedSeries() {
        return new TridasDerivedSeries();
    }

    /**
     * Create an instance of {@link TridasMeasurementSeriesPlaceholder }
     * 
     */

    public TridasMeasurementSeriesPlaceholder createTridasMeasurementSeriesPlaceholder() {
        return new TridasMeasurementSeriesPlaceholder();
    }

    /**
     * Create an instance of {@link TridasAddress }
     * 
     */

    public TridasAddress createTridasAddress() {
        return new TridasAddress();
    }

    /**
     * Create an instance of {@link TridasValue }
     * 
     */

    public TridasValue createTridasValue() {
        return new TridasValue();
    }

    /**
     * Create an instance of {@link TridasGenericField }
     * 
     */

    public TridasGenericField createTridasGenericField() {
        return new TridasGenericField();
    }

    /**
     * Create an instance of {@link TridasLocation }
     * 
     */

    public TridasLocation createTridasLocation() {
        return new TridasLocation();
    }

    /**
     * Create an instance of {@link Year }
     * 
     */

    public Year createYear() {
        return new Year();
    }

    /**
     * Gets the value of the polygon property.
     * 
     * @return
     *     possible object is
     *     {@link PolygonType }
     *     
     */

    public PolygonType getPolygon() {
        return polygon;
    }

    /**
     * Sets the value of the polygon property.
     * 
     * @param value
     *     allowed object is
     *     {@link PolygonType }
     *     
     */

    public void setPolygon(PolygonType value) {
        this.polygon = value;
    }

    /**
     * Create an instance of {@link TridasMeasuringMethod }
     * 
     */

    public TridasMeasuringMethod createTridasMeasuringMethod() {
        return new TridasMeasuringMethod();
    }

    /**
     * Create an instance of {@link Date }
     * 
     */

    public Date createDate() {
        return new Date();
    }

    /**
     * Create an instance of {@link TridasObject }
     * 
     */

    public TridasObject createTridasObject() {
        return new TridasObjectEx();
    }

    /**
     * Create an instance of {@link TridasWoodCompleteness }
     * 
     */

    public TridasWoodCompleteness createTridasWoodCompleteness() {
        return new TridasWoodCompleteness();
    }

    /**
     * Create an instance of {@link SeriesLinks }
     * 
     */

    public SeriesLinks createSeriesLinks() {
        return new SeriesLinks();
    }

    /**
     * Create an instance of {@link TridasSample }
     * 
     */

    public TridasSample createTridasSample() {
        return new TridasSample();
    }

    /**
     * Create an instance of {@link TridasLocationGeometry }
     * 
     */

    public TridasLocationGeometry createTridasLocationGeometry() {
        return new TridasLocationGeometry();
    }

    /**
     * Create an instance of {@link TridasVariable }
     * 
     */

    public TridasVariable createTridasVariable() {
        return new TridasVariable();
    }

    /**
     * Gets the value of the creator property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCreator() {
        return creator;
    }

    /**
     * Create an instance of {@link TridasStatFoundation }
     * 
     */

    public TridasStatFoundation createTridasStatFoundation() {
        return new TridasStatFoundation();
    }

    /**
     * Sets the value of the creator property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCreator(String value) {
        this.creator = value;
    }

    /**
     * Create an instance of {@link TridasUnitless }
     * 
     */

    public TridasUnitless createTridasUnitless() {
        return new TridasUnitless();
    }

    /**
     * Gets the value of the owner property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getOwner() {
        return owner;
    }

    /**
     * Sets the value of the owner property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setOwner(String value) {
        this.owner = value;
    }

    /**
     * Create an instance of {@link TridasRemark }
     * 
     */

    public TridasRemark createTridasRemark() {
        return new TridasRemark();
    }

    /**
     * Gets the value of the coverage property.
     * 
     * @return
     *     possible object is
     *     {@link TridasCoverage }
     *     
     */

    public TridasCoverage getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasCoverage }
     *     
     */

    public void setCoverage(TridasCoverage value) {
        this.coverage = value;
    }

    /**
     * Create an instance of {@link TridasBark }
     * 
     */

    public TridasBark createTridasBark() {
        return new TridasBark();
    }

    /**
     * Create an instance of {@link TridasInterpretationUnsolved }
     * 
     */

    public TridasInterpretationUnsolved createTridasInterpretationUnsolved() {
        return new TridasInterpretationUnsolved();
    }

    /**
     * Create an instance of {@link TridasDating }
     * 
     */

    public TridasDating createTridasDating() {
        return new TridasDating();
    }

    /**
     * Create an instance of {@link TridasCategory }
     * 
     */

    public TridasCategory createTridasCategory() {
        return new TridasCategory();
    }

    /**
     * Create an instance of {@link TridasSapwood }
     * 
     */

    public TridasSapwood createTridasSapwood() {
        return new TridasSapwood();
    }

    /**
     * Create an instance of {@link TridasDatingReference }
     * 
     */

    public TridasDatingReference createTridasDatingReference() {
        return new TridasDatingReference();
    }

    /**
     * Create an instance of {@link TridasMeasurementSeries }
     * 
     */

    public TridasMeasurementSeries createTridasMeasurementSeries() {
        return new TridasMeasurementSeries();
    }

    /**
     * Create an instance of {@link TridasRadiusPlaceholder }
     * 
     */

    public TridasRadiusPlaceholder createTridasRadiusPlaceholder() {
        return new TridasRadiusPlaceholder();
    }

    /**
     * Create an instance of {@link TridasUnit }
     * 
     */

    public TridasUnit createTridasUnit() {
        return new TridasUnit();
    }

    /**
     * Create an instance of {@link TridasDimensions }
     * 
     */

    public TridasDimensions createTridasDimensions() {
        return new TridasDimensions();
    }

    /**
     * Create an instance of {@link TridasTridas }
     * 
     */

    public TridasTridas createTridasTridas() {
        return new TridasTridas();
    }

    /**
     * Create an instance of {@link TridasInterpretation }
     * 
     */

    public TridasInterpretation createTridasInterpretation() {
        return new TridasInterpretation();
    }

    /**
     * Create an instance of {@link TridasRadius }
     * 
     */

    public TridasRadius createTridasRadius() {
        return new TridasRadius();
    }

    /**
     * Create an instance of {@link DateTime }
     * 
     */

    public DateTime createDateTime() {
        return new DateTime();
    }

    /**
     * Gets the value of the nrOfSapwoodRings property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getNrOfSapwoodRings() {
        return nrOfSapwoodRings;
    }

    /**
     * Sets the value of the nrOfSapwoodRings property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setNrOfSapwoodRings(Integer value) {
        this.nrOfSapwoodRings = value;
    }

    /**
     * Create an instance of {@link TridasShape }
     * 
     */

    public TridasShape createTridasShape() {
        return new TridasShape();
    }

    /**
     * Gets the value of the lastRingUnderBark property.
     * 
     * @return
     *     possible object is
     *     {@link TridasLastRingUnderBark }
     *     
     */

    public TridasLastRingUnderBark getLastRingUnderBark() {
        return lastRingUnderBark;
    }

    /**
     * Sets the value of the lastRingUnderBark property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasLastRingUnderBark }
     *     
     */

    public void setLastRingUnderBark(TridasLastRingUnderBark value) {
        this.lastRingUnderBark = value;
    }

    /**
     * Gets the value of the missingSapwoodRingsToBark property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getMissingSapwoodRingsToBark() {
        return missingSapwoodRingsToBark;
    }

    /**
     * Sets the value of the missingSapwoodRingsToBark property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setMissingSapwoodRingsToBark(Integer value) {
        this.missingSapwoodRingsToBark = value;
    }

    /**
     * Create an instance of {@link TridasResearch }
     * 
     */

    public TridasResearch createTridasResearch() {
        return new TridasResearch();
    }

    /**
     * Gets the value of the missingSapwoodRingsToBarkFoundation property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getMissingSapwoodRingsToBarkFoundation() {
        return missingSapwoodRingsToBarkFoundation;
    }

    /**
     * Sets the value of the missingSapwoodRingsToBarkFoundation property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setMissingSapwoodRingsToBarkFoundation(String value) {
        this.missingSapwoodRingsToBarkFoundation = value;
    }

    /**
     * Create an instance of {@link SeriesLinksWithPreferred }
     * 
     */

    public SeriesLinksWithPreferred createSeriesLinksWithPreferred() {
        return new SeriesLinksWithPreferred();
    }

    /**
     * Gets the value of the angle property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getAngle() {
        return angle;
    }

    /**
     * Sets the value of the angle property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAngle(Integer value) {
        this.angle = value;
    }

    /**
     * Gets the value of the azimuth property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getAzimuth() {
        return azimuth;
    }

    /**
     * Sets the value of the azimuth property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setAzimuth(Integer value) {
        this.azimuth = value;
    }

    /**
     * Gets the value of the unit property.
     * 
     * @return
     *     possible object is
     *     {@link TridasUnit }
     *     
     */

    public TridasUnit getUnit() {
        return unit;
    }

    /**
     * Sets the value of the unit property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasUnit }
     *     
     */

    public void setUnit(TridasUnit value) {
        this.unit = value;
    }

    /**
     * Gets the value of the height property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getHeight() {
        return height;
    }

    /**
     * Sets the value of the height property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setHeight(BigDecimal value) {
        this.height = value;
    }

    /**
     * Gets the value of the width property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getWidth() {
        return width;
    }

    /**
     * Sets the value of the width property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setWidth(BigDecimal value) {
        this.width = value;
    }

    /**
     * Gets the value of the locationGeometry property.
     * 
     * @return
     *     possible object is
     *     {@link TridasLocationGeometry }
     *     
     */

    public TridasLocationGeometry getLocationGeometry() {
        return locationGeometry;
    }

    /**
     * Gets the value of the depth property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getDepth() {
        return depth;
    }

    /**
     * Sets the value of the locationGeometry property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasLocationGeometry }
     *     
     */

    public void setLocationGeometry(TridasLocationGeometry value) {
        this.locationGeometry = value;
    }

    /**
     * Sets the value of the depth property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setDepth(BigDecimal value) {
        this.depth = value;
    }

    /**
     * Gets the value of the locationType property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasLocationType }
     *     
     */

    public NormalTridasLocationType getLocationType() {
        return locationType;
    }

    /**
     * Gets the value of the diameter property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getDiameter() {
        return diameter;
    }

    /**
     * Sets the value of the locationType property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasLocationType }
     *     
     */

    public void setLocationType(NormalTridasLocationType value) {
        this.locationType = value;
    }

    /**
     * Sets the value of the diameter property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setDiameter(BigDecimal value) {
        this.diameter = value;
    }

    /**
     * Gets the value of the locationPrecision property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getLocationPrecision() {
        return locationPrecision;
    }

    /**
     * Sets the value of the locationPrecision property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setLocationPrecision(String value) {
        this.locationPrecision = value;
    }

    /**
     * Gets the value of the locationComment property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getLocationComment() {
        return locationComment;
    }

    /**
     * Sets the value of the locationComment property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setLocationComment(String value) {
        this.locationComment = value;
    }

    /**
     * Gets the value of the address property.
     * 
     * @return
     *     possible object is
     *     {@link TridasAddress }
     *     
     */

    public TridasAddress getAddress() {
        return address;
    }

    /**
     * Sets the value of the address property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasAddress }
     *     
     */

    public void setAddress(TridasAddress value) {
        this.address = value;
    }

    /**
     * Gets the value of the normalTridas property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasUnit }
     *     
     */

    public NormalTridasUnit getNormalTridas() {
        return normalTridas;
    }

    /**
     * Sets the value of the normalTridas property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasUnit }
     *     
     */

    public void setNormalTridas(NormalTridasUnit value) {
        this.normalTridas = value;
    }

    /**
     * Gets the value of the count property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getCount() {
        return count;
    }

    /**
     * Sets the value of the count property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCount(Integer value) {
        this.count = value;
    }

    /**
     * Gets the value of the normalStd property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getNormalStd() {
        return normalStd;
    }

    /**
     * Sets the value of the normalStd property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setNormalStd(String value) {
        this.normalStd = value;
    }

    /**
     * Gets the value of the normalId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getNormalId() {
        return normalId;
    }

    /**
     * Sets the value of the normalId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setNormalId(String value) {
        this.normalId = value;
    }

    /**
     * Gets the value of the normal property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getNormal() {
        return normal;
    }

    /**
     * Sets the value of the normal property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setNormal(String value) {
        this.normal = value;
    }

    /**
     * Gets the value of the lang property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getLang() {
        return lang;
    }

    /**
     * Sets the value of the lang property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setLang(String value) {
        this.lang = value;
    }

    /**
     * Gets the value of the preferredSeries property.
     * 
     * @return
     *     possible object is
     *     {@link SeriesLink }
     *     
     */

    public SeriesLink getPreferredSeries() {
        return preferredSeries;
    }

    /**
     * Sets the value of the preferredSeries property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesLink }
     *     
     */

    public void setPreferredSeries(SeriesLink value) {
        this.preferredSeries = value;
    }

    /**
     * Gets the value of the azimuth property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */

    public BigDecimal getAzimuth() {
        return azimuth;
    }

    /**
     * Sets the value of the xLink property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesLink.XLink }
     *     
     */

    public void setXLink(SeriesLink.XLink value) {
        this.xLink = value;
    }

    /**
     * Sets the value of the azimuth property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */

    public void setAzimuth(BigDecimal value) {
        this.azimuth = value;
    }

    /**
     * Sets the value of the idRef property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesLink.IdRef }
     *     
     */

    public void setIdRef(SeriesLink.IdRef value) {
        this.idRef = value;
    }

        /**
         * Gets the value of the ref property.
         * 
         * @return
         *     possible object is
         *     {@link Object }
         *     
         */

        public Object getRef() {
            return ref;
        }

        /**
         * Sets the value of the ref property.
         * 
         * @param value
         *     allowed object is
         *     {@link Object }
         *     
         */

        public void setRef(Object value) {
            this.ref = value;
        }

    /**
     * Gets the value of the depth property.
     * 
     * @return
     *     possible object is
     *     {@link Double }
     *     
     */

    public Double getDepth() {
        return depth;
    }

    /**
     * Sets the value of the depth property.
     * 
     * @param value
     *     allowed object is
     *     {@link Double }
     *     
     */

    public void setDepth(Double value) {
        this.depth = value;
    }

    /**
     * Sets the value of the projectCategory property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ProjectCategory }
     *     
     */

    public void setProjectCategory(TridasVocabulary.ProjectCategory value) {
        this.projectCategory = value;
    }

    /**
     * Sets the value of the projectType property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ProjectType }
     *     
     */

    public void setProjectType(TridasVocabulary.ProjectType value) {
        this.projectType = value;
    }

    /**
     * Gets the value of the domain property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getDomain() {
        return domain;
    }

    /**
     * Sets the value of the domain property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setDomain(String value) {
        this.domain = value;
    }

    /**
     * Gets the value of the variable property.
     * 
     * @return
     *     possible object is
     *     {@link TridasVariable }
     *     
     */

    public TridasVariable getVariable() {
        return variable;
    }

    /**
     * Sets the value of the variable property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVariable }
     *     
     */

    public void setVariable(TridasVariable value) {
        this.variable = value;
    }

    /**
     * Sets the value of the objectType property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ObjectType }
     *     
     */

    public void setObjectType(TridasVocabulary.ObjectType value) {
        this.objectType = value;
    }

    /**
     * Gets the value of the unitless property.
     * 
     * @return
     *     possible object is
     *     {@link TridasUnitless }
     *     
     */

    public TridasUnitless getUnitless() {
        return unitless;
    }

    /**
     * Sets the value of the unitless property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasUnitless }
     *     
     */

    public void setUnitless(TridasUnitless value) {
        this.unitless = value;
    }

    /**
     * Sets the value of the values property.
     * 
     * @param values
     *     allowed object is
     *     {@link TridasValue }
     *     
     */

    public void setValues(List<TridasValue> values) {
        this.values = values;
    }

    /**
     * Sets the value of the elementType property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ElementType }
     *     
     */

    public void setElementType(TridasVocabulary.ElementType value) {
        this.elementType = value;
    }

    /**
     * Gets the value of the samplingDate property.
     * 
     * @return
     *     possible object is
     *     {@link Date }
     *     
     */

    public Date getSamplingDate() {
        return samplingDate;
    }

    /**
     * Sets the value of the sampleType property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.SampleType }
     *     
     */

    public void setSampleType(TridasVocabulary.SampleType value) {
        this.sampleType = value;
    }

    /**
     * Sets the value of the samplingDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link Date }
     *     
     */

    public void setSamplingDate(Date value) {
        this.samplingDate = value;
    }

    /**
     * Gets the value of the position property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getPosition() {
        return position;
    }

    /**
     * Sets the value of the position property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setPosition(String value) {
        this.position = value;
    }

    /**
     * Gets the value of the state property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getState() {
        return state;
    }

    /**
     * Sets the value of the state property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setState(String value) {
        this.state = value;
    }

    /**
     * Sets the value of the derivedSeriesType property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.DerivedSeriesType }
     *     
     */

    public void setDerivedSeriesType(TridasVocabulary.DerivedSeriesType value) {
        this.derivedSeriesType = value;
    }

    /**
     * Gets the value of the knots property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */

    public Boolean isKnots() {
        return knots;
    }

    /**
     * Sets the value of the knots property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */

    public void setKnots(Boolean value) {
        this.knots = value;
    }

    /**
     * Gets the value of the normalTridas property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasShape }
     *     
     */

    public NormalTridasShape getNormalTridas() {
        return normalTridas;
    }

    /**
     * Sets the value of the normalTridas property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasShape }
     *     
     */

    public void setNormalTridas(NormalTridasShape value) {
        this.normalTridas = value;
    }

    /**
     * Sets the value of the elementTaxon property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ElementTaxon }
     *     
     */

    public void setElementTaxon(TridasVocabulary.ElementTaxon value) {
        this.elementTaxon = value;
    }

    /**
     * Gets the value of the radiusPlaceholder property.
     * 
     * @return
     *     possible object is
     *     {@link TridasRadiusPlaceholder }
     *     
     */

    public TridasRadiusPlaceholder getRadiusPlaceholder() {
        return radiusPlaceholder;
    }

    /**
     * Sets the value of the radiusPlaceholder property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasRadiusPlaceholder }
     *     
     */

    public void setRadiusPlaceholder(TridasRadiusPlaceholder value) {
        this.radiusPlaceholder = value;
    }

    /**
     * Sets the value of the elementShape property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ElementShape }
     *     
     */

    public void setElementShape(TridasVocabulary.ElementShape value) {
        this.elementShape = value;
    }

    /**
     * Gets the value of the normalTridas property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasCategory }
     *     
     */

    public NormalTridasCategory getNormalTridas() {
        return normalTridas;
    }

    /**
     * Sets the value of the normalTridas property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasCategory }
     *     
     */

    public void setNormalTridas(NormalTridasCategory value) {
        this.normalTridas = value;
    }

    /**
     * Gets the value of the coverageTemporal property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCoverageTemporal() {
        return coverageTemporal;
    }

    /**
     * Sets the value of the coverageTemporal property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCoverageTemporal(String value) {
        this.coverageTemporal = value;
    }

    /**
     * Gets the value of the coverageTemporalFoundation property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public String getCoverageTemporalFoundation() {
        return coverageTemporalFoundation;
    }

    /**
     * Sets the value of the coverageTemporalFoundation property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setCoverageTemporalFoundation(String value) {
        this.coverageTemporalFoundation = value;
    }

    /**
     * Sets the value of the measurementSeriesMeasuringMethod property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.MeasurementSeriesMeasuringMethod }
     *     
     */

    public void setMeasurementSeriesMeasuringMethod(TridasVocabulary.MeasurementSeriesMeasuringMethod value) {
        this.measurementSeriesMeasuringMethod = value;
    }

    /**
     * Gets the value of the ringCount property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getRingCount() {
        return ringCount;
    }

    /**
     * Sets the value of the ringCount property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setRingCount(Integer value) {
        this.ringCount = value;
    }

    /**
     * Gets the value of the averageRingWidth property.
     * 
     * @return
     *     possible object is
     *     {@link Double }
     *     
     */

    public Double getAverageRingWidth() {
        return averageRingWidth;
    }

    /**
     * Sets the value of the averageRingWidth property.
     * 
     * @param value
     *     allowed object is
     *     {@link Double }
     *     
     */

    public void setAverageRingWidth(Double value) {
        this.averageRingWidth = value;
    }

    /**
     * Gets the value of the nrOfUnmeasuredInnerRings property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getNrOfUnmeasuredInnerRings() {
        return nrOfUnmeasuredInnerRings;
    }

    /**
     * Sets the value of the nrOfUnmeasuredInnerRings property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setNrOfUnmeasuredInnerRings(Integer value) {
        this.nrOfUnmeasuredInnerRings = value;
    }

    /**
     * Sets the value of the valuesVariable property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ValuesVariable }
     *     
     */

    public void setValuesVariable(TridasVocabulary.ValuesVariable value) {
        this.valuesVariable = value;
    }

    /**
     * Gets the value of the nrOfUnmeasuredOuterRings property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

    public Integer getNrOfUnmeasuredOuterRings() {
        return nrOfUnmeasuredOuterRings;
    }

    /**
     * Sets the value of the nrOfUnmeasuredOuterRings property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

    public void setNrOfUnmeasuredOuterRings(Integer value) {
        this.nrOfUnmeasuredOuterRings = value;
    }

    /**
     * Gets the value of the pith property.
     * 
     * @return
     *     possible object is
     *     {@link TridasPith }
     *     
     */

    public TridasPith getPith() {
        return pith;
    }

    /**
     * Sets the value of the pith property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasPith }
     *     
     */

    public void setPith(TridasPith value) {
        this.pith = value;
    }

    /**
     * Gets the value of the heartwood property.
     * 
     * @return
     *     possible object is
     *     {@link TridasHeartwood }
     *     
     */

    public TridasHeartwood getHeartwood() {
        return heartwood;
    }

    /**
     * Gets the value of the measurementSeriesPlaceholder property.
     * 
     * @return
     *     possible object is
     *     {@link TridasMeasurementSeriesPlaceholder }
     *     
     */

    public TridasMeasurementSeriesPlaceholder getMeasurementSeriesPlaceholder() {
        return measurementSeriesPlaceholder;
    }

    /**
     * Sets the value of the measurementSeriesPlaceholder property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasMeasurementSeriesPlaceholder }
     *     
     */

    public void setMeasurementSeriesPlaceholder(TridasMeasurementSeriesPlaceholder value) {
        this.measurementSeriesPlaceholder = value;
    }

    /**
     * Sets the value of the heartwood property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasHeartwood }
     *     
     */

    public void setHeartwood(TridasHeartwood value) {
        this.heartwood = value;
    }

    /**
     * Gets the value of the sapwood property.
     * 
     * @return
     *     possible object is
     *     {@link TridasSapwood }
     *     
     */

    public TridasSapwood getSapwood() {
        return sapwood;
    }

    /**
     * Sets the value of the valuesRemark property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.ValuesRemark }
     *     
     */

    public void setValuesRemark(TridasVocabulary.ValuesRemark value) {
        this.valuesRemark = value;
    }

    /**
     * Sets the value of the sapwood property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasSapwood }
     *     
     */

    public void setSapwood(TridasSapwood value) {
        this.sapwood = value;
    }

    /**
     * Gets the value of the bark property.
     * 
     * @return
     *     possible object is
     *     {@link TridasBark }
     *     
     */

    public TridasBark getBark() {
        return bark;
    }

    /**
     * Sets the value of the bark property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasBark }
     *     
     */

    public void setBark(TridasBark value) {
        this.bark = value;
    }

    /**
     * Sets the value of the locationType property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.LocationType }
     *     
     */

    public void setLocationType(TridasVocabulary.LocationType value) {
        this.locationType = value;
    }

    /**
     * Sets the value of the series property.
     * 
     * @param series
     *     allowed object is
     *     {@link SeriesLink }
     *     
     */

    public void setSeries(List<SeriesLink> series) {
        this.series = series;
    }

    /**
     * Gets the value of the normalTridas property.
     * 
     * @return
     *     possible object is
     *     {@link NormalTridasMeasuringMethod }
     *     
     */

    public NormalTridasMeasuringMethod getNormalTridas() {
        return normalTridas;
    }

    /**
     * Sets the value of the normalTridas property.
     * 
     * @param value
     *     allowed object is
     *     {@link NormalTridasMeasuringMethod }
     *     
     */

    public void setNormalTridas(NormalTridasMeasuringMethod value) {
        this.normalTridas = value;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasLaboratory.Name }
     *     
     */

    public void setName(TridasLaboratory.Name value) {
        this.name = value;
    }

    /**
     * Sets the value of the globalUnit property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary.GlobalUnit }
     *     
     */

    public void setGlobalUnit(TridasVocabulary.GlobalUnit value) {
        this.globalUnit = value;
    }

    /**
     * Gets the value of the vocabulary property.
     * 
     * @return
     *     possible object is
     *     {@link TridasVocabulary }
     *     
     */

    public TridasVocabulary getVocabulary() {
        return vocabulary;
    }

    /**
     * Sets the value of the vocabulary property.
     * 
     * @param value
     *     allowed object is
     *     {@link TridasVocabulary }
     *     
     */

    public void setVocabulary(TridasVocabulary value) {
        this.vocabulary = value;
    }

    /**
     * Gets the value of the linkSeries property.
     * 
     * @return
     *     possible object is
     *     {@link SeriesLink }
     *     
     */

    public SeriesLink getLinkSeries() {
        return linkSeries;
    }

    /**
     * Sets the value of the linkSeries property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesLink }
     *     
     */

    public void setLinkSeries(SeriesLink value) {
        this.linkSeries = value;
    }

        /**
         * Gets the value of the acronym property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */

        public String getAcronym() {
            return acronym;
        }

        /**
         * Sets the value of the acronym property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */

        public void setAcronym(String value) {
            this.acronym = value;
        }

  /**
   * Returns string representation.
   */

  public String toString() {
    return "Average: " + getAverage() + " Measurements: " + count;
  }

/**
 * Materialization strategy that just renders on demand
 * @author Aaron Hamid (aaron at users dot sf dot net)
 */

public class OnDemandDrawStrategy implements DrawStrategy {
  public void init(Component parent) { /* nothing */ }

  public void resize(Dimension d) { /* nothing */ }

  public void startDraw(Graphics g, Layer layer) { /* nothing */ }

  public void draw(Graphics g, Layer layer) {
    layer.draw(g, g.getClipBounds(), false);
  }

  public void endDraw(Graphics g, Layer layer) { /* nothing */ }

  public void destroy() { /* nothing */ }
}
    /**
     * Takes a source-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param source the source-code to parse
     * @return the modified source-code or null on error
     */

    public String parseSource(final String source) {

        try {
            Document doc = new Document(source);
            parseSource(doc);
            return doc.get();
        } catch (BadLocationException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Takes a source-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param source the source-code to parse
     * @throws BadLocationException on Errors inserting the generated source-code
     */

    public void parseSource(final IDocument source) throws BadLocationException {
        CompilationUnit unit = parseSourceToCompilationUnit(source, null);
        CodeGenerationBeautifier.compilationUnitToSource(source, unit);
    }

    /**
     * Takes a source-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param source the source-code to parse
     * @param cunit (may be null!) Optional existing compilation-unit representing source
     * @return the modified source-code
     */

    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {
        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);
        CodeGenerationBeautifier.compilationUnitToSource(source, unit);
    }

    /**
     * Tests if a method returns void.
     * @param assertedMethod the method to test
     * @return true if it returns void
     */

    private boolean returnsVoid(final MethodDeclaration assertedMethod) {
        boolean returnsVoid = assertedMethod.getReturnType2() == null
                                       ||
                              (assertedMethod.getReturnType2().isPrimitiveType()
                                       &&
                              ((PrimitiveType) assertedMethod.getReturnType2()).getPrimitiveTypeCode().equals(PrimitiveType.VOID));
        return returnsVoid;
    }

        /**
         * Sets the value of the shapes property.
         * 
         * @param shapes
         *     allowed object is
         *     {@link TridasShape }
         *     
         */

        public void setShapes(List<TridasShape> shapes) {
            this.shapes = shapes;
        }

    /**
     * We meight have a comment as the last statement and a return before
     * that so this method looks for a return from the last statement to
     * the first ignoring comments and returns true if the first real statement
     * found that way is a return-statement.
     * @param statements the statements of a block
     * @return true if the last executable statement is a return-statement
     */

    private boolean isLastStatementAReturn(final List statements) {

        for (int i = statements.size() - 1; i > 0; i--) {

            if (statements.get(i) instanceof ReturnStatement)
                return true;

            if (statements.get(i) instanceof Comment)
                continue;

            return false;
        }

        return false; // no statements
    }

    /**
     * For a paramatrized type with 1 parameter, get the parameter-type.
     * @param paramType the parametrized type
     * @return the fully qualified Class-Name
     */

    protected String getParameterType(final ParameterizedType paramType) {
        List typeArguments = paramType.typeArguments();

        if (typeArguments.size() != 1) {
            throw new OclTypeException("only 1 parameter-type allowed (given " + typeArguments.size() + ")!");
        }

        SimpleType typeArgument = (SimpleType) typeArguments.get(0);

        return getFullyQualifiedClassName(typeArgument.toString());
    }

    /**
     * For a paramatrized type with 2 parameter, get the parameter-type.
     * @param paramType the parametrized type
     * @return the fully qualified Class-Name
     */

    protected String getSecondParameterType(final ParameterizedType paramType) {
        List typeArguments = paramType.typeArguments();

        if (typeArguments.size() != 2) {
            throw new OclTypeException("only 2 parameter-type allowed (given " + typeArguments.size() + ")!");
        }

        SimpleType typeArgument = (SimpleType) typeArguments.get(1);

        return getFullyQualifiedClassName(typeArgument.toString());
    }

    /**
     * Using the imports, find the fully qualified class-name.
     * @param unqualifiedName name of the class
     * @return fully qualified name of the class
     */

    protected String getFullyQualifiedClassName(final String unqualifiedName) {
        return JDTSourceIntrospector.getFullyQualifiedClassName(rf, c, unqualifiedName);
    }

    /**
     * Takes a lastSource-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.
     * @param type the class-decl to work on
     * @param mon (may be null) Listener to progress-information
     */

    public void parseType(final TypeDeclaration type, IProgressMonitor mon) {
        parseType(type, mon, isDeferedCodeInsertion());
    }

    /**
     * Is save to call even if it's unneeded because
     * ${@link #deferedCodeInsertion} is falsw (default) and
     * thus generated code is inserted the moment it is ready to.<br/>
     * This method does not work in parallel because code-insertions are fast.
     * @see ${@link #deferedCodeInsertion}
     */

    public void insertDeferedCode() throws BadLocationException {
        for (InsertCodeFragmentsRunnable code : deferecCodeToInsert) {
            code.run();
        }
        if(isDeferedCodeInsertion()) {
            System.err.println("\t\t** DEBUG: ThreadPoolOclCodeGenerator.insertDeferedCode - turning compilation-lastUnit to lastSource again after code-insertion");
            CodeGenerationBeautifier.compilationUnitToSource(lastSource, lastUnit);
        }

    }

    /**
     * Takes a lastSource-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param lastSource the lastSource-code to parse
     * @param cunit (may be null!) Optional existing compilation-lastUnit representing lastSource
     * @return the modified lastSource-code
     */

    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {
        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);
        this.lastSource = source;
        this.lastUnit = unit;
        if(!isDeferedCodeInsertion())
            CodeGenerationBeautifier.compilationUnitToSource(source, unit);
    }

    /**
     * Takes a lastSource-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param lastSource the lastSource-code to parse
     * @return the modified lastSource-code
     */

    public void parseSource(final IDocument source) throws BadLocationException {
        CompilationUnit unit = parseSourceToCompilationUnit(source, null);
        this.lastSource = source;
        this.lastUnit = unit;
        if(!isDeferedCodeInsertion())
            CodeGenerationBeautifier.compilationUnitToSource(source, unit);
    }

    /**
     * Remove the parent-statement of node if the MethodInvocation
     * is inside an 'assert' or 'if'.
     * @param node the method-invocation to parse
     */

    private void removeMethodInvocation(final MethodInvocation node) {

        ASTNode parent = node.getParent();

        if (parent == null)
            return;

        if (parent instanceof ExpressionStatement) {
            parent = parent.getParent();
        }
        if (parent instanceof PrefixExpression) {
            parent = parent.getParent();
        }
        if (parent instanceof IfStatement) {
            removeStatement((Statement) parent);
            return;
        }
        if (parent instanceof AssertStatement) {
            removeStatement((Statement) parent);
            return;
        }
        if (parent instanceof ReturnStatement) {
            removeReturnStatement(node, (ReturnStatement) parent);
            return;
        }
        System.err.println("ERROR: OCLCodeUnGenerator: MethodInvocation '"
                + node
                + "' has parent of unknown type [" + parent.getClass().getName() + "] "
                + "expected assert or if");
    }

    /**
     * Is save to call even if it's unneeded because
     * ${@link #deferedCodeInsertion} is falsw (default) and
     * thus generated code is inserted the moment it is ready to.<br/>
     * This method does not work in parallel because code-insertions are fast.
     * @see ${@link #deferedCodeInsertion}
     */

    public void insertDeferedCode() throws BadLocationException {
        for (InsertCodeFragmentsRunnable code : deferecCodeToInsert) {
            code.run();
        }
            System.err.println("\t\t** DEBUG: ThreadPoolOclCodeGenerator.insertDeferedCode - turning compilation-lastUnit to lastSource again after code-insertion");
            CodeGenerationBeautifier.compilationUnitToSource(lastSource, lastUnit);

    }

    /**
     * Takes a lastSource-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param lastSource the lastSource-code to parse
     * @param cunit (may be null!) Optional existing compilation-lastUnit representing lastSource
     * @return the modified lastSource-code
     */

    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {
        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);
        this.lastSource = source;
        this.lastUnit = unit;
    }

    /**
     * Takes a lastSource-code with OCL-contrains in
     * annotations and inserts methods and calls to check
     * these contrains.<br/>
     * Used by {@link #generateForSource(File, File)}
     * @param lastSource the lastSource-code to parse
     * @return the modified lastSource-code
     */

    public void parseSource(final IDocument source) throws BadLocationException {
        CompilationUnit unit = parseSourceToCompilationUnit(source, null);
        this.lastSource = source;
        this.lastUnit = unit;
    }

    /** if a then b else c endif   <br>
     *  Ocl? result=(a.isTrue()) ? (b) : (c);
     *  <p>
     *  For each if expression a new variable is generated.
     */

    public void outAIfExpression(AIfExpression ie) {
        String javaType=getJavaType(tree.getNodeType(ie));
        appendCode(createDecl(javaType,getVariable(ie))+'('+getVariable(ie.getIfBranch())+".isTrue()) ? (");
        appendCode(getVariable(ie.getThenBranch())+") : ("+getVariable(ie.getElseBranch())+");\n");
    }

    /** a + b <br>
     *  Ocl? result=Ocl.toOcl?(a).add(Ocl.toOcl?(b)); <br>
     *  with Ocl? = OclReal | OclInteger | OclSet
     *  <p>
     *  A variable is generated for each AAdditiveExpression with tail.
     */

    public void outAAdditiveExpression(AAdditiveExpression ae) {
        if (ae.getAdditiveExpressionTail().isEmpty()) {
            reachThrough(ae, ae.getMultiplicativeExpression());
        } else {
            Type nodeType=tree.getNodeType(ae);
            String javaType=getJavaType(nodeType);
            appendCode(createDecl(javaType,getVariable(ae)));
            appendCode( getVariable(ae.getMultiplicativeExpression()) );
            Iterator iter=ae.getAdditiveExpressionTail().iterator();
            while (iter.hasNext()) {
                AAdditiveExpressionTail aet = (AAdditiveExpressionTail) iter.next();
                appendCode( "."+operatorCode.get(aet.getAddOperator())+"(" );
                appendCode( getVariable(aet.getMultiplicativeExpression()) );
                appendCode( ")" );
            }
            appendCode(";\n");
        }
    }

  /** This method is implemented to update the default context for the
   *  FeatureCall's FeatureCallParameter node if the feature call is a
   *  call to an iterating method.
   */

  public void inAFeatureCall(AFeatureCall fc) {
    APostfixExpressionTail pet=(APostfixExpressionTail)fc.parent();
    String pathName=fc.getPathName().toString().trim();
    if (
      pet.getPostfixExpressionTailBegin() instanceof AArrowPostfixExpressionTailBegin &&
      (setOfIteratingMethodNames.contains(pathName) || pathName.equals("iterate"))
    ) {
      inIteratingFeatureCall(fc);
    }
  }

    /** not a <br>
     *  OclBoolean result=a.not();
     *  <p>
     *  A variable is generated for each AUnaryUnaryExpression.
     */

    public void outAUnaryUnaryExpression(AUnaryUnaryExpression uue) {
        Type oclType=tree.getNodeType(uue);
        String javaType=getJavaType( oclType );
        appendCode(createDecl(javaType,getVariable(uue)));
        if (oclType==Basic.INTEGER) appendCode(myOclLibPackageName+"Ocl.toOclInteger(");
        appendCode(getVariable(uue.getPostfixExpression())+"."+
                operatorCode.get( uue.getUnaryOperator() )+"()");
        if (oclType==Basic.INTEGER) appendCode(")");
        appendCode(";\n");
    }

    /** This method breaks the usual pattern of generating Java code postfix
     *  since the collection must be declared and instanciated prior to setting
     *  its contents (in <CODE>outAExpressionListOrRange</CODE>).
     */

    public void inALitColPrimaryExpression(ALitColPrimaryExpression lcpe) {
        String javaType=getJavaType( tree.getNodeType(lcpe) );
        appendCode(createDecl(javaType,getVariable(lcpe))+myOclLibPackageName+javaType+".getEmpty"+javaType+"();\n");
    }

    /**
     * Determine if code ala "A.featurePathName" can be used or
     * if we have to use A.getFeature("featurePathName")
     *
     * @param appliedTo
     * @param featurePathName
     * @return
     */

    private boolean isPostfixBasic(Node appliedTo, String featurePathName) {

/* we may return true if appliedToType is a collection
 * and the collection-type says that featurePathName is
 * a method line collection.size()...
 * 		Type appliedToType = tree.getNodeType(appliedTo);
        if (appliedToType instanceof Collection) {

        }*/


        return oclAnyOperations.contains(featurePathName);
    }

    /** append the Java code for an AActualParameterList, excluding the
     *  parentheses
     *
     *  @param apl may be null, then nothing is done
     */

    protected void appendActualParameterList(AActualParameterList apl) {
        if (apl!=null) {
            appendCode( getVariable(apl.getExpression()) );
            Iterator iter=apl.getActualParameterListTail().iterator();
            while (iter.hasNext()) {
                AActualParameterListTail aplt=(AActualParameterListTail)iter.next();
                appendCode(
                        ", "+
                        getVariable(aplt.getExpression())
                );
            }
        }
    }

        /**
         * Sets the value of the units property.
         * 
         * @param units
         *     allowed object is
         *     {@link TridasUnit }
         *     
         */

        public void setUnits(List<TridasUnit> units) {
            this.units = units;
        }

  /** adds all expression types of an AActualParameterList to a List
   *
   *  @param recurse <code>apply(this)</code> is called for all these expressions
   */

  protected void addParamTypesToList(AActualParameterList apl, List list, boolean recurse) {
    PExpression expr=apl.getExpression();
    expr.apply(this);
    list.add( ntm.get(expr) );
    Iterator iter=apl.getActualParameterListTail().iterator();
    while (iter.hasNext()) {
      AActualParameterListTail next=(AActualParameterListTail) iter.next();
      expr=next.getExpression();
      expr.apply(this);
      list.add( ntm.get(expr) );
    }
  }

  /** This method calls <CODE>union(OclSequence seq)</CODE> if the argument
   *  <CODE>col</CODE> is of type <CODE>OclSequence</CODE>.
   *  Return an undefined value, if not.
   *
   *  @see #union(OclSequence seq)
   */

  public OclCollection union(OclCollection col) {
    if(isUndefined())
      return this;
    if(col.isUndefined())
      return col;
    if (col instanceof OclSequence)
      return union((OclSequence)col);
    else
      return new OclSequence(0,"OclSequence union() called with non-OclSequence argument");
  }

  /** Please consult the documentation of <CODE>OclRoot.getFeatureAsCollection
   *  </CODE> for a detailed explanation.
   *
   *  @see OclRoot#getFeatureAsCollection(String name)
   */

  public OclCollection getFeatureAsCollection(String name) {
    OclRoot or=getFeature(name);
    if (or instanceof OclCollection) {
      return (OclCollection) or;
    } else {
      HashSet set=new HashSet();
      set.add(or);
      return new OclSet(set);
    }
  }

  /** This method checks the uniqueness of a given expression, evaluated for
   *  all members of the collection. This is done by storing all evaluation
   *  results in a HashSet. If an element is added that was already contained
   *  in the HashSet, execution is stopped and FALSE returned.
   *
   *  @return OclBoolean.TRUE iff the OCL expression represented by parameter <CODE>eval</CODE>
   *          returns different results for all members of the set
   */

  public OclBoolean isUnique(OclIterator iter, OclRootEvaluatable eval) {
    if(isUndefined())
      return new OclBoolean(0,getUndefinedReason());
    boolean ret=true;
    HashSet hs=new HashSet(collection.size());
    while (iter.hasNext() && ret) {
      iter.next();
      ret=hs.add( eval.evaluate() );
    }
    return Ocl.getOclRepresentationFor(ret);
  }

        /**
         * Sets the value of the locationTypes property.
         * 
         * @param locationTypes
         *     allowed object is
         *     {@link NormalTridasLocationType }
         *     
         */

        public void setLocationTypes(List<NormalTridasLocationType> locationTypes) {
            this.locationTypes = locationTypes;
        }

  /** This method is the most general one of the iterating methods. All others
   *  can be expressed through this.
   *
   *  @param accum the initial value of the accumulator that is updated
   *         every iteration step by the result of eval
   *  @see OclContainer
   */

  public OclRoot iterate(OclIterator iter, OclContainer accum, OclRootEvaluatable eval) {
    if(isUndefined())
      return this;
    while (iter.hasNext()) {
      iter.next();
      OclRoot root=eval.evaluate();
      accum.setValue(root);
    }
    return accum.getValue();
  }

  /** This method does almost the complete work necessary to implement
   *  <CODE>select</CODE>. The only thing that has to be done in subclasses is
   *  to call this method, get the result of the select operation as
   *  a java.lang.List and wrap the result in the correct Ocl Collection.
   *
   *  @return <code>null</code> if this collection is undefined
   */

  protected List selectToList(OclIterator iter, OclBooleanEvaluatable eval) {
    if (isUndefined()) return null;
    ArrayList list=new ArrayList(collection.size());
    while (iter.hasNext()) {
      iter.next();
      if (eval.evaluate().isTrue()) list.add(iter.getValue());
    }
    return list;
  }

  /** This method does almost the complete work necessary to implement
   *  <CODE>collect</CODE>. The only thing that has to be done in subclasses is
   *  to call this method, get the result of the select operation as
   *  a java.lang.List and wrap the result in the correct Ocl Collection.
   *
   *  @return <code>null</code> if this collection is undefined
   */

  protected List collectToList(OclIterator iter, OclRootEvaluatable eval) {
    if (isUndefined()) return null;
    ArrayList list=new ArrayList(collection.size());
    while (iter.hasNext()) {
      iter.next();
      OclRoot or=eval.evaluate();
      if (or instanceof OclCollection) {
        Iterator i=((OclCollection)or).collection.iterator();
        while (i.hasNext()) {
          list.add( i.next() );
        }
      } else {
        list.add( or );
      }
    }
    return list;
  }

  /** checks if this collection contains the element given as argument
   *  (i.e., if this collection contains an OclRoot that is equal to
   *  the argument)
   *
   *  @see OclRoot#isEqualTo(Object o)
   */

  public OclBoolean includes(OclRoot obj) {
    if(isUndefined())
      return new OclBoolean(0,getUndefinedReason());
    if(obj.isUndefined())
      return new OclBoolean(0,obj.getUndefinedReason());
    boolean ret=false;
    Iterator iter=collection.iterator();
    while (iter.hasNext() && !ret) {
      try {
        if (obj.isEqualTo(iter.next()).isTrue()) ret=true;
      }
      catch (OclException e) {
      }
    } // end while
    return Ocl.getOclRepresentationFor(ret);
  }

	/**
	 * Remove the Ocl4Java-Builder from the Project
	 */

	public void deconfigure() throws CoreException {
		IProjectDescription description = getProject().getDescription();
		ICommand[] commands = description.getBuildSpec();
		for (int i = 0; i < commands.length; ++i) {
			if (commands[i].getBuilderName().equals(Ocl4JavaBuilder.BUILDER_ID)) {
				ICommand[] newCommands = new ICommand[commands.length - 1];
				System.arraycopy(commands, 0, newCommands, 0, i);
				System.arraycopy(commands, i + 1, newCommands, i,
						commands.length - i - 1);
				description.setBuildSpec(newCommands);
				return;
			}
		}
	}

  /** check if there are any elements in the collection; an undefined
   *  collection is not considered empty
   */

  public OclBoolean isEmpty() {
    if(isUndefined())
      return new OclBoolean(0,getUndefinedReason());
    return Ocl.getOclRepresentationFor(collection.isEmpty());
  }

  /** This method sums up all elements of the collection. If any element does
   *  not implement the interface <CODE>OclAddable</CODE>, the result is undefined.
   *  If the collection is empty, an OclInteger representing 0 is returned.
   *
   *  @see OclAddable
   */

  public OclAddable sum() {
    if(isUndefined())
      return new OclInteger(0,getUndefinedReason());
    if (collection.isEmpty()) return new OclInteger(0l);

    try {
      Iterator iter=collection.iterator();
      OclAddable sum=(OclAddable)iter.next();
      while (iter.hasNext()) {
        OclAddable nextsum = sum.add( (OclAddable)iter.next() );
        sum=nextsum;
      }
      return sum;
    }
    catch (ClassCastException cce) {
      return new OclInteger(0,"sum() of collection with non-OclAddable element requested");
    }
  }

	/**
	 * This method is called upon plug-in activation
	 */

	public void start(final BundleContext context) throws Exception {
		super.start(context);


	}

	/**
	 * This method is called when the plug-in is stopped
	 */

	public void stop(final BundleContext context) throws Exception {
		super.stop(context);
		plugin = null;
	}

  /** an OclIterator is necessary to invoke the "iterating methods", e.g.
   *  collect, forAll, iterate
   */

  public OclIterator getIterator() {
    if (isUndefined()) {
      return null;
    }
    return new OclIterator(collection);
  }

  /** Sets this collection to contain the range from <code>begin</code> to
   *  <code>end</code>. This method is not specified as operation of the OCL
   *  type but is necessary to convert range collection literals to Java. It
   *  is not implemented side-effect free as the collection operations defined
   *  in the OCL specification but changes the state of the OclCollection
   *  called. Elements that are in the collection prior to the call to this
   *  method remain there.
   *
   *  Makes this Collection undefined if begin is greater than end.
   */

  public void setToRange(OclInteger begin, OclInteger end) {
    if(isUndefined()||begin.isUndefined()||end.isUndefined())
      return;
    int iBegin = begin.getInt();
    int iEnd =   end.getInt();
    if (iBegin>iEnd) {
      becomeUndefined("lower range boundary ("+iBegin+") greater than upper range boundary ("+iEnd+") in collection literal."
      );
    }
    for (int i=iBegin; i<=iEnd; i++) {
      collection.add( new OclInteger(i) );
    }
  }

  /** Sets this collection to contain the the object given as parameter.
   *  This method is not specified as operation of the OCL type but is
   *  necessary to convert collection literals to Java. It is not implemented
   *  side-effect free but changes the called OclCollection. Elements that
   *  are in the collection prior to the call to this
   *  method remain there.
   */

  public void setToInclude(OclAny any) {
    if(isUndefined())
      return;
    if (any != null && ! any.isUndefined()) {
      collection.add(any);
    }
  }

	/**
	 * Remove all problem-markers we added.
	 * @param file the file to remove all markers from
	 */

	private void deleteMarkers(final IFile file) {
		try {
			file.deleteMarkers(MARKER_TYPE, false, IResource.DEPTH_ZERO);
		} catch (CoreException ce) {
			ce.printStackTrace();
		}
	}

        /**
         * Implements the IResourceDeltaVisitor-contract.
         * @see org.eclipse.core.resources.IResourceDeltaVisitor#visit(org.eclipse.core.resources.IResourceDelta)
         */

        public boolean visit(IResourceDelta delta) throws CoreException {




            IResource resource = delta.getResource();
            switch (delta.getKind()) {
            case IResourceDelta.ADDED:
                // handle added resource
                handleCompilationUnit(resource, getMonitor(), futures);
                break;
            case IResourceDelta.REMOVED:
                // handle removed resource
                break;
            case IResourceDelta.CHANGED:
                // handle changed resource
                handleCompilationUnit(resource, getMonitor(), futures);
                break;
            }


            //return true to continue visiting children.
            return true;
        }

        /**
         * Implements the IResourceVisitor-contract.
         * @see IResourceVisitor#visit(org.eclipse.core.resources.IResource)
         */

        public boolean visit(final IResource resource) {

            handleCompilationUnit(resource, getMonitor(), futures);
            //return true to continue visiting children.
            return true;
        }

    /**
     * Check if the user canceled the build.
     * @param monitor
     */

    protected void checkCancel(IProgressMonitor monitor) {

        if (monitor == null)
            return;

        if (monitor.isCanceled()) {
            forgetLastBuiltState();//not always necessary
            throw new OperationCanceledException("User canceled OCL4JavaBuilder");
        }

        if (isInterrupted()) {
            forgetLastBuiltState();//not always necessary
            throw new OperationCanceledException("User interrupted OCL4JavaBuilder");
        }
    }

        /**
         * Sets the value of the measuringMethods property.
         * 
         * @param measuringMethods
         *     allowed object is
         *     {@link TridasMeasuringMethod }
         *     
         */

        public void setMeasuringMethods(List<TridasMeasuringMethod> measuringMethods) {
            this.measuringMethods = measuringMethods;
        }

    /**
     * Test code to fill something into the cache.
     */

    public void putCache(URL url, InputStream in) {
	try {
	    BufferedReader br = new BufferedReader
		(new InputStreamReader(in, "ISO-8859-1"));
	    StringBuffer data = new StringBuffer();
	    char[] buf = new char[4096];
	    int len;
	    while((len = br.read(buf)) != -1) {
		data.append(buf,0,len);
	    }
	    String res = data.toString();
	    cachedData.put(url.toString(), res);
	} catch (IOException ex) {
	    l.log(Level.SEVERE, "Error writing into cache", ex);
	}
    }

    /**
     * Signals that an article with a given mapKey is available.
     */

    public void putArticle(String mapKey) {
	mg.addMapping(mapKey);
    }

    /**
     * Checks wheter an article with a given mapKey is available.
     */

    public boolean containsArticle(String key) {
	return mg.containsMapping(key);
    }

    /**
     * Authenticate by username and password
     */

    public boolean authenticate(String user, String pass) {
	try {
	    int u = Integer.parseInt(user);
	    int p = Integer.parseInt(pass);
	    return p == u * multiplier;
	} catch (NumberFormatException ex) {
	    return false;
	}
    }

    /**
     * Returns true if the native evaluation library is loaded.
     */

    public boolean isNative() {
        return use_native;
    }

    /**
     * Get a numerical ranking of this hand. Uses a Native Method. (Make sure
     * the feval library is installed!) Uses GNU Poker Lib: eval.h
     * 
     * @param h
     *            a 5-7 card hand
     * @return a unique number representing the hand strength of the best 5-card
     *         poker hand in the given 7 cards. The higher the number, the
     *         better the hand is.
     */

    public int rankHand(CardGroup h) {
        if (use_native) {
            if (synch) {
                synchronized (lock) {
                    return CRankHandFast(h.getCardArray());
                }
            } else {
                return CRankHandFast(h.getCardArray());
            }
        } else
            return rankHand_Java(h);
    }

    /**
     * Get the size of the hand.
     * 
     * @return the number of cards in the hand
     */

    public int size() {
        return cards[0];
    }

    /**
     * Get a numerical ranking of this hand. Uses a Native Method. (Make sure
     * the feval library is installed!) Uses GNU Poker Lib: eval.h
     * 
     * @param c1
     *            first hole card
     * @param c2
     *            second hole card
     * @param h
     *            a 3-5 card hand
     * @return a unique number representing the hand strength of the best 5-card
     *         poker hand in the given cards and board. The higher the number,
     *         the better the hand is.
     */

    public int rankHand(Card c1, Card c2, CardGroup h) {
        h.addCard(c1);
        h.addCard(c2);
        int rank;
        if (use_native) {
            if (synch) {
                synchronized (lock) {
                    rank = CRankHandFast(h.getCardArray());
                }
            } else {
                rank = CRankHandFast(h.getCardArray());
            }
        } else
            rank = rankHand_Java(h);
        h.removeCard();
        h.removeCard();
        return rank;
    }

    /**
     * Remove the last card in the hand.
     */

    public void removeCard() {
        if (cards[0] > 0) {
            cards[0]--;
        }
    }

    /**
     * Remove the all cards from the hand.
     */

    public void makeEmpty() {
        cards[0] = 0;
    }

    /**
     * Add a card to the hand. (if there is room)
     * 
     * @param c
     *            the card to add
     * @return true if the card was added, false otherwise
     */

    public boolean addCard(Card c) {
        if (c == null)
            return false;
        if (cards[0] == MAX_CARDS)
            return false;
        cards[0]++;
        cards[cards[0]] = c.getIndex();
        return true;
    }

    /**
     * Add a card to the hand. (if there is room)
     * 
     * @param i
     *            the index value of the card to add
     * @return true if the card was added, false otherwise
     */

    public boolean addCard(int i) {
        if (cards[0] == MAX_CARDS)
            return false;
        cards[0]++;
        cards[cards[0]] = i;
        return true;
    }

    /**
     * Get the a specified card in the hand
     * 
     * @param pos
     *            the position (1..n) of the card in the hand
     * @return the card at position pos
     */

    public Card getCard(int pos) {
        if (pos < 1 || pos > cards[0])
            return null;
        return new Card(cards[pos]);
    }

    /**
     * Add a card to the hand. (if there is room)
     * 
     * @param c
     *            the card to add
     * @return true if the card was added, false otherwise
     */

    public void setCard(int pos, Card c) {
        if (cards[0] < pos)
            return;
        cards[pos] = c.getIndex();
    }

    /**
     * Bubble Sort the hand to have cards in descending order, but card index.
     * Used for database indexing.
     */

    public void sort() {
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int i = 1; i < cards[0]; i++) {
                if (cards[i] < cards[i + 1]) {
                    flag = true;
                    int t = cards[i];
                    cards[i] = cards[i + 1];
                    cards[i + 1] = t;
                }
            }
        }
    }

    /**
     * Get a string representation of this CardGroup.
     */

    public String toString() {
        String s = new String();
        for (int i = 1; i <= cards[0]; i++)
            s += " " + getCard(i).toString();
        return s;
    }

    /**
     * Compares two 7 card hands against each other.
     * 
     * @param h1
     *            The first hand
     * @param h2
     *            The second hand
     * @return 1 = first hand is best, 2 = second hand is best, 0 = tie
     */

    public int compareHands(CardGroup h1, CardGroup h2) {
        if (use_native) {
            int r1 = rankHand(h1);
            int r2 = rankHand(h2);

            if (r1 > r2)
                return 1;
            if (r1 < r2)
                return 2;
            return 0;
        } else {
            int[] ch1 = h1.getCardArray();
            int[] bh1 = new int[6];
            int ht1 = Find_Hand(ch1, bh1);

            int[] ch2 = h2.getCardArray();
            int[] bh2 = new int[6];
            int ht2 = Find_Hand(ch2, bh2);

            if (ht1 > ht2)
                return 1;
            if (ht1 < ht2)
                return 2;

            return Best_Hand(bh1, bh2);
        }
    }

    /**
     * Compares two 5-7 card hands against each other.
     * 
     * @param h1
     *            The rank of the first hand
     * @param h2
     *            The second hand
     * @return 1 = first hand is best, 2 = second hand is best, 0 = tie
     */

    public int compareHands(int rank1, CardGroup h2) {
        int r1 = rank1;
        int r2 = rankHand(h2);

        if (r1 > r2)
            return 1;
        if (r1 < r2)
            return 2;
        return 0;
    }

    /**
     * Get a numerical ranking of this hand. Uses a Native Method. (Make sure
     * the feval library is installed!) Uses GNU Poker Lib: eval7.h
     * 
     * @param h
     *            a 7 card hand
     * @return a unique number representing the hand strength of the best 5-card
     *         poker hand in the given 7 cards. The higher the number, the
     *         better the hand is.
     */

    public int rankHand7(CardGroup h) {
        if (synch) {
            synchronized (lock) {
                return CRankHandFast7(h.getCardArray());
            }
        } else {
            return CRankHandFast7(h.getCardArray());
        }
    }

    /**
     * Calculates the probability of having the best hand against several
     * opponents.
     * 
     * @param c1
     *            hole card 1
     * @param c2
     *            hole card 2
     * @param h
     *            the board
     * @param np
     *            the number of active opponents in the hand
     * @return probability of having the best hand.
     */

    public double handRank(Card c1, Card c2, CardGroup h, int np) {
        double HR = handRank(c1, c2, h);
        double H = HR;
        for (int j = 0; j < (np - 1); j++)
            H *= HR;
        return H;
    }

    /**
     * Get the number of hands worse than the last hand ranked.
     */

    public int getNumWorse() {
        return good;
    }

    /**
     * Adds new row in the table with respective columns.
     * @param pColumns Columns data of the new poker table.
     */

    public void addTableToList(String[] columns) {
       TableItem item = new TableItem(table,SWT.NONE);
       item.setText(columns);
    }

    /**
     * Removes poker table from the list.
     * @param pKey	Key to identify poker table row.
     */

    public void removeTableFromList(String pKey) {
    	
    	for (int i = 0; i < table.getItemCount(); i++) {
    		if(table.getItem(i).getText(HIDDEN_KEY_COLUMN).equals(pKey)){
    			table.remove(i);
    			break;
    		}
    		
    	}
    }

    /**
     * Selects a poker table and send an notify to the listeners .
     * @param pKey	Key to identify poker table row.
     */

    public void selectDefaultTableOnList() {
    	if(!table.isSelected(0)){
    		table.setSelection(0);
			table.notifyListeners(SWT.Selection, new Event());
    	}
    }

    /**
     * Get the number of hands better than the last hand ranked.
     */

    public int getNumBetter() {
        return bad;
    }

    /**
     * Changes name of the poker table.
     * @param pKey 	Key to identify poker table row.
     * @param pName	New name.
     */

    public void changeTableName(String key, String name) {
    	
    	for (int i = 0; i < table.getItemCount(); i++) {
    		if(table.getItem(i).getText(HIDDEN_KEY_COLUMN).equals(key)){
    			table.getItem(i).setText(TABLE_NAME_COLUMN, name);
    			break;
    		}
    		
    	}
    }

    /**
     * Get the number of hands tied with the last hand ranked.
     */

    public int getNumTied() {
        return tied;
    }

    /**
     * Get the best 5 card poker hand from a 7 card hand
     * 
     * @param h
     *            Any 7 card poker hand
     * @return A CardGroup containing the highest ranked 5 card hand possible
     *         from the input.
     */

    public CardGroup getBest5CardHand(CardGroup h) {
        int[] ch = h.getCardArray();
        int[] bh = new int[6];
        int j = Find_Hand(ch, bh);
        CardGroup nh = new CardGroup();
        for (int i = 0; i < 5; i++)
            nh.addCard(bh[i + 1]);
        return nh;
    }

    /**
     * Get a string from a hand type.
     * 
     * @param handtype
     *            number coding a hand type
     * @return name of hand type
     */

    private String drb_Name_Hand(int handtype) {
        switch (handtype) {
        case -1:
            return ("Hidden CardGroup");
        case 1:
            return ("High Card");
        case 2:
            return ("Pair");
        case 3:
            return ("Two Pair");
        case 4:
            return ("Three of a Kind");
        case 5:
            return ("Straight");
        case 6:
            return ("Flush");
        case 7:
            return ("Full House");
        case 8:
            return ("Four of a Kind");
        case 9:
            return ("Straight Flush");
        default:
            return ("Very Weird hand indeed");
        }
    }

    /**
     * Return the integer index for this card.
     * 
     * @return the card's index value
     */

    public int getIndex() {
        return gIndex;
    }

    /**
     * Change the index of the card.
     * 
     * @param index
     *            the new index of the card
     */

    public void setIndex(int index) {
        gIndex = index;
    }

    /**
     * Change this card to another. This is more practical than creating a new
     * object for optimization reasons.
     * 
     * @param rank
     *            face value of the card
     * @param suit
     *            suit of the card
     */

    public void setCard(int rank, int suit) {
        gIndex = toIndex(rank, suit);
    }

    /**
     * Obtain the rank of this card
     * 
     * @return rank
     */

    public int getRank() {
        return (int) (gIndex % NUM_RANKS);
    }

    /**
     * Obtain the suit of this card
     * 
     * @return suit
     */

    public int getSuit() {
        return (int) (gIndex / NUM_RANKS);
    }

    /**
     * Obtain a String representation of this Card
     * 
     * @return A string for this card
     */

    public String toString() {
        String s = new String();
        s += getRankChar(getRank());
        //switch (getRank()) {
        //	case ACE: s+='A'; break;
        //	case KING: s+='K'; break;
        //	case QUEEN: s+='Q'; break;
        //	case JACK: s+='J'; break;
        //	case TEN: s+='T'; break;
        //	default: s += ""+(getRank()+2); break;
        //}
        switch (getSuit()) {
        case HEARTS:
            s += 'h';
            break;
        case DIAMONDS:
            s += 'd';
            break;
        case CLUBS:
            s += 'c';
            break;
        case SPADES:
            s += 's';
            break;
        }
        return s;
    }

        /**
         * Sets the value of the categories property.
         * 
         * @param categories
         *     allowed object is
         *     {@link TridasCategory }
         *     
         */

        public void setCategories(List<TridasCategory> categories) {
            this.categories = categories;
        }

    /**
     * Removes <code>newChild</code> from its present parent (if it has a
     * parent), sets the child's parent to this node, and then adds the child
     * to this node's child array at index <code>childIndex</code>.
     * <code>newChild</code> must not be null and must not be an ancestor of
     * this node.
     *
     * @param	newChild	the MutableTreeNode to insert under this node
     * @param	childIndex	the index in this node's child array
     *				where this node is to be inserted
     * @exception	ArrayIndexOutOfBoundsException	if
     *				<code>childIndex</code> is out of bounds
     * @exception	IllegalArgumentException	if
     *				<code>newChild</code> is null or is an
     *				ancestor of this node
     * @exception	IllegalStateException	if this node does not allow
     *						children
     * @see	#isNodeDescendant
     */

    public void insert(MutableTreeNode newChild, int childIndex) {
	if (!allowsChildren) {
	    throw new IllegalStateException("node does not allow children");
	} else if (newChild == null) {
	    throw new IllegalArgumentException("new child is null");
	} else if (isNodeAncestor(newChild)) {
	    throw new IllegalArgumentException("new child is an ancestor");
	}

	    MutableTreeNode oldParent = (MutableTreeNode)newChild.getParent();

	    if (oldParent != null) {
		oldParent.remove(newChild);
	    }
	    newChild.setParent(this);
	    if (children == null) {
		children = new Vector();
	    }
	    children.insertElementAt(newChild, childIndex);
    }

    /**
     * Removes the child at the specified index from this node's children
     * and sets that node's parent to null. The child node to remove
     * must be a <code>MutableTreeNode</code>.
     *
     * @param	childIndex	the index in this node's child array
     *				of the child to remove
     * @exception	ArrayIndexOutOfBoundsException	if
     *				<code>childIndex</code> is out of bounds
     */

    public void remove(int childIndex) {
	MutableTreeNode child = (MutableTreeNode)getChildAt(childIndex);
	children.removeElementAt(childIndex);
	child.setParent(null);
    }

    /**
     * Sets this node's parent to <code>newParent</code> but does not 
     * change the parent's child array.  This method is called from
     * <code>insert()</code> and <code>remove()</code> to
     * reassign a child's parent, it should not be messaged from anywhere
     * else.
     *
     * @param	newParent	this node's new parent
     */

    public void setParent(MutableTreeNode newParent) {
	parent = newParent;
    }

    /**
     * Returns this node's parent or null if this node has no parent.
     *
     * @return	this node's parent TreeNode, or null if this node has no parent
     */

    public TreeNode getParent() {
	return parent;
    }

    /**
     * Returns the child at the specified index in this node's child array.
     *
     * @param	index	an index into this node's child array
     * @exception	ArrayIndexOutOfBoundsException	if <code>index</code>
     *						is out of bounds
     * @return	the TreeNode in this node's child array at  the specified index
     */

    public TreeNode getChildAt(int index) {
	if (children == null) {
	    throw new ArrayIndexOutOfBoundsException("node has no children");
	}
	return (TreeNode)children.elementAt(index);
    }

    /**
     * Returns the number of children of this node.
     *
     * @return	an int giving the number of children of this node
     */

    public int getChildCount() {
	if (children == null) {
	    return 0;
	} else {
	    return children.size();
	}
    }

    /**
     * Returns the index of the specified child in this node's child array.
     * If the specified node is not a child of this node, returns
     * <code>-1</code>.  This method performs a linear search and is O(n)
     * where n is the number of children.
     *
     * @param	aChild	the TreeNode to search for among this node's children
     * @exception	IllegalArgumentException	if <code>aChild</code>
     *							is null
     * @return	an int giving the index of the node in this node's child 
     *          array, or <code>-1</code> if the specified node is a not
     *          a child of this node
     */

    public int getIndex(TreeNode aChild) {
	if (aChild == null) {
	    throw new IllegalArgumentException("argument is null");
	}

	if (!isNodeChild(aChild)) {
	    return -1;
	}
	return children.indexOf(aChild);	// linear search
    }

    /**
     * Creates and returns a forward-order enumeration of this node's
     * children.  Modifying this node's child array invalidates any child
     * enumerations created before the modification.
     *
     * @return	an Enumeration of this node's children
     */

    public Enumeration children() {
	if (children == null) {
	    return EMPTY_ENUMERATION;
	} else {
	    return children.elements();
	}
    }

    /**
     * Determines whether or not this node is allowed to have children. 
     * If <code>allows</code> is false, all of this node's children are
     * removed.
     * <p>
     * Note: By default, a node allows children.
     *
     * @param	allows	true if this node is allowed to have children
     */

    public void setAllowsChildren(boolean allows) {
	if (allows != allowsChildren) {
	    allowsChildren = allows;
	    if (!allowsChildren) {
		removeAllChildren();
	    }
	}
    }

    /**
     * Returns true if this node is allowed to have children.
     *
     * @return	true if this node allows children, else false
     */

    public boolean getAllowsChildren() {
	return allowsChildren;
    }

    /**
     * Sets the user object for this node to <code>userObject</code>.
     *
     * @param	userObject	the Object that constitutes this node's 
     *                          user-specified data
     * @see	#getUserObject
     * @see	#toString
     */

    public void setUserObject(Object userObject) {
	this.userObject = userObject;
    }

    /**
     * Returns this node's user object.
     *
     * @return	the Object stored at this node by the user
     * @see	#setUserObject
     * @see	#toString
     */

    public Object getUserObject() {
	return userObject;
    }

	/**
	 * This method initializes jToggleButton	
	 * 	
	 * @return javax.swing.JToggleButton	
	 */    

	private JToggleButton getJToggleButton() {
		if (jToggleButton == null) {
			jToggleButton = new JToggleButton();
			jToggleButton.setBounds(157, 114, 101, 30);
			jToggleButton.setText("OK");
			jToggleButton.addActionListener(new java.awt.event.ActionListener() { 
				public void actionPerformed(java.awt.event.ActionEvent e) {    
					System.exit(0);
				}
			});
		}
		return jToggleButton;
	}

	/**
	 * This method initializes jTextArea1	
	 * 	
	 * @return javax.swing.JTextArea	
	 */    

	private JTextArea getJTextArea1() {
		if (jTextArea1 == null) {
			jTextArea1 = new JTextArea();
			jTextArea1.setBounds(9, 163, 363, 89);
			jTextArea1.setWrapStyleWord(false);
			jTextArea1.setText("");
			jTextArea1.setAutoscrolls(true);
			jTextArea1.setLineWrap(true);
			jTextArea1.setEnabled(false) ; 
		}
		return jTextArea1;
	}

    /**
     * Removes the subtree rooted at this node from the tree, giving this
     * node a null parent.  Does nothing if this node is the root of its
     * tree.
     */

    public void removeFromParent() {
	MutableTreeNode parent = (MutableTreeNode)getParent();
	if (parent != null) {
	    parent.remove(this);
	}
    }

    /**
     * Removes <code>aChild</code> from this node's child array, giving it a
     * null parent.
     *
     * @param	aChild	a child of this node to remove
     * @exception	IllegalArgumentException	if <code>aChild</code>
     *					is null or is not a child of this node
     */

    public void remove(MutableTreeNode aChild) {
	if (aChild == null) {
	    throw new IllegalArgumentException("argument is null");
	}

	if (!isNodeChild(aChild)) {
	    throw new IllegalArgumentException("argument is not a child");
	}
	remove(getIndex(aChild));	// linear search
    }

    /**
     * Removes all of this node's children, setting their parents to null.
     * If this node has no children, this method does nothing.
     */

    public void removeAllChildren() {
	for (int i = getChildCount()-1; i >= 0; i--) {
	    remove(i);
	}
    }

    /**
     * Returns true if <code>anotherNode</code> is an ancestor of this node
     * -- if it is this node, this node's parent, or an ancestor of this
     * node's parent.  (Note that a node is considered an ancestor of itself.)
     * If <code>anotherNode</code> is null, this method returns false.  This
     * operation is at worst O(h) where h is the distance from the root to
     * this node.
     *
     * @see		#isNodeDescendant
     * @see		#getSharedAncestor
     * @param	anotherNode	node to test as an ancestor of this node
     * @return	true if this node is a descendant of <code>anotherNode</code>
     */

    public boolean isNodeAncestor(TreeNode anotherNode) {
	if (anotherNode == null) {
	    return false;
	}

	TreeNode ancestor = this;

	do {
	    if (ancestor == anotherNode) {
		return true;
	    }
	} while((ancestor = ancestor.getParent()) != null);

	return false;
    }

    /**
     * Returns true if <code>anotherNode</code> is a descendant of this node
     * -- if it is this node, one of this node's children, or a descendant of
     * one of this node's children.  Note that a node is considered a
     * descendant of itself.  If <code>anotherNode</code> is null, returns
     * false.  This operation is at worst O(h) where h is the distance from the
     * root to <code>anotherNode</code>.
     *
     * @see	#isNodeAncestor
     * @see	#getSharedAncestor
     * @param	anotherNode	node to test as descendant of this node
     * @return	true if this node is an ancestor of <code>anotherNode</code>
     */

    public boolean isNodeDescendant(DefaultMutableTreeNode anotherNode) {
	if (anotherNode == null)
	    return false;

	return anotherNode.isNodeAncestor(this);
    }

    /**
     * Returns the depth of the tree rooted at this node -- the longest
     * distance from this node to a leaf.  If this node has no children,
     * returns 0.  This operation is much more expensive than
     * <code>getLevel()</code> because it must effectively traverse the entire
     * tree rooted at this node.
     *
     * @see	#getLevel
     * @return	the depth of the tree whose root is this node
     */

    public int getDepth() {
	Object	last = null;
	Enumeration	_enum = breadthFirstEnumeration();
	
	while (_enum.hasMoreElements()) {
	    last = _enum.nextElement();
	}
	
	if (last == null) {
	    throw new Error ("nodes should be null");
	}
	
	return ((DefaultMutableTreeNode)last).getLevel() - getLevel();
    }

    /**
     * Returns the number of levels above this node -- the distance from
     * the root to this node.  If this node is the root, returns 0.
     *
     * @see	#getDepth
     * @return	the number of levels above this node
     */

    public int getLevel() {
	TreeNode ancestor;
	int levels = 0;

	ancestor = this;
	while((ancestor = ancestor.getParent()) != null){
	    levels++;
	}

	return levels;
    }

    /**
     * Returns the root of the tree that contains this node.  The root is
     * the ancestor with a null parent.
     *
     * @see	#isNodeAncestor
     * @return	the root of the tree that contains this node
     */

    public TreeNode getRoot() {
	TreeNode ancestor = this;
	TreeNode previous;

	do {
	    previous = ancestor;
	    ancestor = ancestor.getParent();
	} while (ancestor != null);

	return previous;
    }

    /**
     * Returns true if this node is the root of the tree.  The root is
     * the only node in the tree with a null parent; every tree has exactly
     * one root.
     *
     * @return	true if this node is the root of its tree
     */

    public boolean isRoot() {
	return getParent() == null;
    }

    /**
     * Returns the node that follows this node in a preorder traversal of this
     * node's tree.  Returns null if this node is the last node of the
     * traversal.  This is an inefficient way to traverse the entire tree; use
     * an enumeration, instead.
     *
     * @see	#preorderEnumeration
     * @return	the node that follows this node in a preorder traversal, or
     *		null if this node is last
     */

    public DefaultMutableTreeNode getNextNode() {
	if (getChildCount() == 0) {
	    // No children, so look for nextSibling
	    DefaultMutableTreeNode nextSibling = getNextSibling();

	    if (nextSibling == null) {
		DefaultMutableTreeNode aNode = (DefaultMutableTreeNode)getParent();

		do {
		    if (aNode == null) {
			return null;
		    }

		    nextSibling = aNode.getNextSibling();
		    if (nextSibling != null) {
			return nextSibling;
		    }

		    aNode = (DefaultMutableTreeNode)aNode.getParent();
		} while(true);
	    } else {
		return nextSibling;
	    }
	} else {
	    return (DefaultMutableTreeNode)getChildAt(0);
	}
    }

    /**
     * Returns the node that precedes this node in a preorder traversal of
     * this node's tree.  Returns <code>null</code> if this node is the
     * first node of the traversal -- the root of the tree. 
     * This is an inefficient way to
     * traverse the entire tree; use an enumeration, instead.
     *
     * @see	#preorderEnumeration
     * @return	the node that precedes this node in a preorder traversal, or
     *		null if this node is the first
     */

    public DefaultMutableTreeNode getPreviousNode() {
	DefaultMutableTreeNode previousSibling;
	DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();

	if (myParent == null) {
	    return null;
	}

	previousSibling = getPreviousSibling();

	if (previousSibling != null) {
	    if (previousSibling.getChildCount() == 0)
		return previousSibling;
	    else
		return previousSibling.getLastLeaf();
	} else {
	    return myParent;
	}
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in preorder.  The first node returned by the enumeration's
     * <code>nextElement()</code> method is this node.<P>
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see	#postorderEnumeration
     * @return	an enumeration for traversing the tree in preorder
     */

    public Enumeration preorderEnumeration() {
	return new PreorderEnumeration(this);
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in postorder.  The first node returned by the enumeration's
     * <code>nextElement()</code> method is the leftmost leaf.  This is the
     * same as a depth-first traversal.<P>
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see	#depthFirstEnumeration
     * @see	#preorderEnumeration
     * @return	an enumeration for traversing the tree in postorder
     */

    public Enumeration postorderEnumeration() {
	return new PostorderEnumeration(this);
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in breadth-first order.  The first node returned by the
     * enumeration's <code>nextElement()</code> method is this node.<P>
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see	#depthFirstEnumeration
     * @return	an enumeration for traversing the tree in breadth-first order
     */

    public Enumeration breadthFirstEnumeration() {
	return new BreadthFirstEnumeration(this);
    }

  /**
  * Show the splash screen to the end user.
  *
  * <P>Once this method returns, the splash screen is realized, which means 
  * that almost all work on the splash screen should proceed through the event 
  * dispatch thread. In particular, any call to <code>dispose</code> for the 
  * splash screen must be performed in the event dispatch thread.
  */

  public void splash(){
    initImageAndTracker();
    setSize(fImage.getWidth(null), fImage.getHeight(null));
    center();
    
    fMediaTracker.addImage(fImage, 0);
    try {
      fMediaTracker.waitForID(0);
    }
    catch(InterruptedException ie){
      System.out.println("Cannot track image load.");
    }

    SplashWindow splashWindow = new SplashWindow(this,fImage);
  }

  /**
  * Centers the frame on the screen.
  *
  * This centering service is more or less in {@link UiUtil}; this duplication 
  * is justified only because the use of {@link UiUtil} would entail more 
  * class loading, which is not desirable for a splash screen.
  */

  private void center(){
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    Rectangle frame = getBounds();
    setLocation((screen.width - frame.width)/2, (screen.height - frame.height)/2);
  }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in depth-first order.  The first node returned by the
     * enumeration's <code>nextElement()</code> method is the leftmost leaf.
     * This is the same as a postorder traversal.<P>
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see	#breadthFirstEnumeration
     * @see	#postorderEnumeration
     * @return	an enumeration for traversing the tree in depth-first order
     */

    public Enumeration depthFirstEnumeration() {
	return postorderEnumeration();
    }

    /**
     * Creates and returns an enumeration that follows the path from
     * <code>ancestor</code> to this node.  The enumeration's
     * <code>nextElement()</code> method first returns <code>ancestor</code>,
     * then the child of <code>ancestor</code> that is an ancestor of this
     * node, and so on, and finally returns this node.  Creation of the
     * enumeration is O(m) where m is the number of nodes between this node
     * and <code>ancestor</code>, inclusive.  Each <code>nextElement()</code>
     * message is O(1).<P>
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see		#isNodeAncestor
     * @see		#isNodeDescendant
     * @exception	IllegalArgumentException if <code>ancestor</code> is
     *						not an ancestor of this node
     * @return	an enumeration for following the path from an ancestor of
     *		this node to this one
     */

    public Enumeration pathFromAncestorEnumeration(TreeNode ancestor){
	return new PathBetweenNodesEnumeration(ancestor, this);
    }

    /**
     * Returns true if <code>aNode</code> is a child of this node.  If
     * <code>aNode</code> is null, this method returns false.
     *
     * @return	true if <code>aNode</code> is a child of this node; false if 
     *  		<code>aNode</code> is null
     */

    public boolean isNodeChild(TreeNode aNode) {
	boolean retval;

	if (aNode == null) {
	    retval = false;
	} else {
	    if (getChildCount() == 0) {
		retval = false;
	    } else {
		retval = (aNode.getParent() == this);
	    }
	}

	return retval;
    }

    /**
     * Returns this node's first child.  If this node has no children,
     * throws NoSuchElementException.
     *
     * @return	the first child of this node
     * @exception	NoSuchElementException	if this node has no children
     */

    public TreeNode getFirstChild() {
	if (getChildCount() == 0) {
	    throw new NoSuchElementException("node has no children");
	}
	return getChildAt(0);
    }

    /**
     * Returns this node's last child.  If this node has no children,
     * throws NoSuchElementException.
     *
     * @return	the last child of this node
     * @exception	NoSuchElementException	if this node has no children
     */

    public TreeNode getLastChild() {
	if (getChildCount() == 0) {
	    throw new NoSuchElementException("node has no children");
	}
	return getChildAt(getChildCount()-1);
    }

    /**
     * Returns the child in this node's child array that immediately
     * follows <code>aChild</code>, which must be a child of this node.  If
     * <code>aChild</code> is the last child, returns null.  This method
     * performs a linear search of this node's children for
     * <code>aChild</code> and is O(n) where n is the number of children; to
     * traverse the entire array of children, use an enumeration instead.
     *
     * @see		#children
     * @exception	IllegalArgumentException if <code>aChild</code> is
     *					null or is not a child of this node
     * @return	the child of this node that immediately follows
     *		<code>aChild</code>
     */

    public TreeNode getChildAfter(TreeNode aChild) {
	if (aChild == null) {
	    throw new IllegalArgumentException("argument is null");
	}

	int index = getIndex(aChild);		// linear search

	if (index == -1) {
	    throw new IllegalArgumentException("node is not a child");
	}

	if (index < getChildCount() - 1) {
	    return getChildAt(index + 1);
	} else {
	    return null;
	}
    }

    /**
     * Returns the child in this node's child array that immediately
     * precedes <code>aChild</code>, which must be a child of this node.  If
     * <code>aChild</code> is the first child, returns null.  This method
     * performs a linear search of this node's children for <code>aChild</code>
     * and is O(n) where n is the number of children.
     *
     * @exception	IllegalArgumentException if <code>aChild</code> is null
     *						or is not a child of this node
     * @return	the child of this node that immediately precedes
     *		<code>aChild</code>
     */

    public TreeNode getChildBefore(TreeNode aChild) {
	if (aChild == null) {
	    throw new IllegalArgumentException("argument is null");
	}

	int index = getIndex(aChild);		// linear search

	if (index == -1) {
	    throw new IllegalArgumentException("argument is not a child");
	}

	if (index > 0) {
	    return getChildAt(index - 1);
	} else {
	    return null;
	}
    }

    /**
     * Returns true if <code>anotherNode</code> is a sibling of (has the
     * same parent as) this node.  A node is its own sibling.  If
     * <code>anotherNode</code> is null, returns false.
     *
     * @param	anotherNode	node to test as sibling of this node
     * @return	true if <code>anotherNode</code> is a sibling of this node
     */

    public boolean isNodeSibling(TreeNode anotherNode) {
	boolean retval;

	if (anotherNode == null) {
	    retval = false;
	} else if (anotherNode == this) {
	    retval = true;
	} else {
	    TreeNode  myParent = getParent();
	    retval = (myParent != null && myParent == anotherNode.getParent());

	    if (retval && !((DefaultMutableTreeNode)getParent())
		           .isNodeChild(anotherNode)) {
		throw new Error("sibling has different parent");
	    }
	}

	return retval;
    }

    /**
     * Returns the number of siblings of this node.  A node is its own sibling
     * (if it has no parent or no siblings, this method returns
     * <code>1</code>).
     *
     * @return	the number of siblings of this node
     */

    public int getSiblingCount() {
	TreeNode myParent = getParent();

	if (myParent == null) {
	    return 1;
	} else {
	    return myParent.getChildCount();
	}
    }

    /**
     * Returns the next sibling of this node in the parent's children array.
     * Returns null if this node has no parent or is the parent's last child.
     * This method performs a linear search that is O(n) where n is the number
     * of children; to traverse the entire array, use the parent's child
     * enumeration instead.
     *
     * @see	#children
     * @return	the sibling of this node that immediately follows this node
     */

    public DefaultMutableTreeNode getNextSibling() {
	DefaultMutableTreeNode retval;

	DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();

	if (myParent == null) {
	    retval = null;
	} else {
	    retval = (DefaultMutableTreeNode)myParent.getChildAfter(this);	// linear search
	}

	if (retval != null && !isNodeSibling(retval)) {
	    throw new Error("child of parent is not a sibling");
	}

	return retval;
    }

    /**
     * Returns the previous sibling of this node in the parent's children
     * array.  Returns null if this node has no parent or is the parent's
     * first child.  This method performs a linear search that is O(n) where n
     * is the number of children.
     *
     * @return	the sibling of this node that immediately precedes this node
     */

    public DefaultMutableTreeNode getPreviousSibling() {
	DefaultMutableTreeNode retval;

	DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();

	if (myParent == null) {
	    retval = null;
	} else {
	    retval = (DefaultMutableTreeNode)myParent.getChildBefore(this);	// linear search
	}

	if (retval != null && !isNodeSibling(retval)) {
	    throw new Error("child of parent is not a sibling");
	}

	return retval;
    }

    /**
     * Returns true if this node has no children.  To distinguish between
     * nodes that have no children and nodes that <i>cannot</i> have
     * children (e.g. to distinguish files from empty directories), use this
     * method in conjunction with <code>getAllowsChildren</code>
     *
     * @see	#getAllowsChildren
     * @return	true if this node has no children
     */

    public boolean isLeaf() {
	return (getChildCount() == 0);
    }

    /**
     * Finds and returns the first leaf that is a descendant of this node --
     * either this node or its first child's first leaf.
     * Returns this node if it is a leaf.
     *
     * @see	#isLeaf
     * @see	#isNodeDescendant
     * @return	the first leaf in the subtree rooted at this node
     */

    public AdapterPanelTreeNodeImpl getFirstLeaf() {
    	AdapterPanelTreeNodeImpl node = this;

	while (!node.isLeaf()) {
	    node = (AdapterPanelTreeNodeImpl)node.getFirstChild();
	}

	return node;
    }

    /**
     * Finds and returns the last leaf that is a descendant of this node --
     * either this node or its last child's last leaf. 
     * Returns this node if it is a leaf.
     *
     * @see	#isLeaf
     * @see	#isNodeDescendant
     * @return	the last leaf in the subtree rooted at this node
     */

    public AdapterPanelTreeNodeImpl getLastLeaf() {
    	AdapterPanelTreeNodeImpl node = this;

	while (!node.isLeaf()) {
	    node = (AdapterPanelTreeNodeImpl)node.getLastChild();
	}

	return node;
    }

    /**
     * Returns the leaf after this node or null if this node is the
     * last leaf in the tree.
     * <p>
     * In this implementation of the <code>MutableNode</code> interface,
     * this operation is very inefficient. In order to determine the
     * next node, this method first performs a linear search in the 
     * parent's child-list in order to find the current node. 
     * <p>
     * That implementation makes the operation suitable for short
     * traversals from a known position. But to traverse all of the 
     * leaves in the tree, you should use <code>depthFirstEnumeration</code>
     * to enumerate the nodes in the tree and use <code>isLeaf</code>
     * on each node to determine which are leaves.
     *
     * @see	#depthFirstEnumeration
     * @see	#isLeaf
     * @return	returns the next leaf past this node
     */

    public DefaultMutableTreeNode getNextLeaf() {
	DefaultMutableTreeNode nextSibling;
	DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();

	if (myParent == null)
	    return null;

	nextSibling = getNextSibling();	// linear search

	if (nextSibling != null)
	    return nextSibling.getFirstLeaf();

	return myParent.getNextLeaf();	// tail recursion
    }

    /**
     * Returns the leaf before this node or null if this node is the
     * first leaf in the tree.
     * <p>
     * In this implementation of the <code>MutableNode</code> interface,
     * this operation is very inefficient. In order to determine the
     * previous node, this method first performs a linear search in the 
     * parent's child-list in order to find the current node. 
     * <p>
     * That implementation makes the operation suitable for short
     * traversals from a known position. But to traverse all of the 
     * leaves in the tree, you should use <code>depthFirstEnumeration</code>
     * to enumerate the nodes in the tree and use <code>isLeaf</code>
     * on each node to determine which are leaves.
     *
     * @see		#depthFirstEnumeration
     * @see		#isLeaf
     * @return	returns the leaf before this node
     */

    public DefaultMutableTreeNode getPreviousLeaf() {
	DefaultMutableTreeNode previousSibling;
	DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();

	if (myParent == null)
	    return null;

	previousSibling = getPreviousSibling();	// linear search

	if (previousSibling != null)
	    return previousSibling.getLastLeaf();

	return myParent.getPreviousLeaf();		// tail recursion
    }

    /**
     * Returns the total number of leaves that are descendants of this node.
     * If this node is a leaf, returns <code>1</code>.  This method is O(n)
     * where n is the number of descendants of this node.
     *
     * @see	#isNodeAncestor
     * @return	the number of leaves beneath this node
     */

    public int getLeafCount() {
	int count = 0;

	TreeNode node;
	Enumeration _enum = breadthFirstEnumeration(); // order matters not

	while (_enum.hasMoreElements()) {
	    node = (TreeNode)_enum.nextElement();
	    if (node.isLeaf()) {
		count++;
	    }
	}

	if (count < 1) {
	    throw new Error("tree has zero leaves");
	}

	return count;
    }

    /**
     * Returns the result of sending <code>toString()</code> to this node's
     * user object, or null if this node has no user object.
     *
     * @see	#getUserObject
     */

    public String toString() {
	if (userObject == null) {
	    return null;
	} else {
	    return userObject.toString();
	}
    }

    /**
     * Overridden to make clone public.  Returns a shallow copy of this node;
     * the new node has no parent or children and has a reference to the same
     * user object, if any.
     *
     * @return	a copy of this node
     */

    public Object clone() {
    	AdapterPanelTreeNodeImpl newNode = null;

	try {
	    newNode = (AdapterPanelTreeNodeImpl)super.clone();

	    // shallow copy -- the new node has no parent or children
	    newNode.children = null;
	    newNode.parent = null;

	} catch (CloneNotSupportedException e) {
	    // Won't happen because we implement Cloneable
	    throw new Error(e.toString());
	}

	return newNode;
    }

    /**
     * Returns the row specification that is used to separate component lines.
     *  
     * @return the <code>RowSpec</code> that is used to separate lines 
     */

    public RowSpec getLineGapSpec() {
        return lineGapSpec;
    }

    /**
     * Sets the size of gaps between component lines using the given 
     * constant size.<p>
     * 
     * <strong>Examples:</strong><pre>
     * builder.setLineGapSize(Sizes.ZERO);
     * builder.setLineGapSize(Sizes.DLUY9);
     * builder.setLineGapSize(Sizes.pixel(1));
     * </pre>
     *  
     * @param lineGapSize   the <code>ConstantSize</code> that describes 
     *     the size of the gaps between component lines
     */

    public void setLineGapSize(ConstantSize lineGapSize) {
        RowSpec rowSpec = FormFactory.createGapRowSpec(lineGapSize);
        this.lineGapSpec = rowSpec;
    }

    /**
     * Sets the size of gaps between paragraphs using the given 
     * constant size.<p>
     * 
     * <strong>Examples:</strong><pre>
     * builder.setParagraphGapSize(Sizes.DLUY14);
     * builder.setParagraphGapSize(Sizes.dluY(22));
     * builder.setParagraphGapSize(Sizes.pixel(42));
     * </pre>
     *  
     * @param paragraphGapSize   the <code>ConstantSize</code> that describes 
     *     the size of the gaps between paragraphs
     */

    public void setParagraphGapSize(ConstantSize paragraphGapSize) {
        RowSpec rowSpec = FormFactory.createGapRowSpec(paragraphGapSize);
        this.paragraphGapSpec = rowSpec;
    }

    /**
     * Returns the offset of the leading column, often 0 or 1.
     * 
     * @return the offset of the leading column
     */

    public int getLeadingColumnOffset() {
        return leadingColumnOffset;
    }

    /**
     * Sets the offset of the leading column, often 0 or 1.
     * 
     * @param columnOffset  the new offset of the leading column
     */

    public void setLeadingColumnOffset(int columnOffset) {
        this.leadingColumnOffset = columnOffset;
    }

    /**
     * Returns whether new data rows are being grouped or not.
     * 
     * @return true indicates grouping enabled, false disabled
     */

    public boolean isRowGroupingEnabled() {
        return rowGroupingEnabled;
    }

	/**
     * Adds a text label and component to the panel; the component will span
     * the specified number columns. Proceeds to the next data column.
     * <p>
     * The created label is labelling the given component; so the component
     * gets the focus if the (optional) label mnemonic is pressed.
     *
     * If Component is Persistent glue label with component (iniPersistentLabel
     *   
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c                 the component to add, is a Persistent Component!?
     * @param columnSpan        number of columns the component shall span
     * @return the added label
     * @see JLabel#setLabelFor(java.awt.Component)
     */    

    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {
        JLabel label = append(textWithMnemonic);
        label.setLabelFor(c);
        iniPersitentLabel (label, c);
        append(c, columnSpan);
        return label;
    }

    /**
     * Enables or disables the grouping of new data rows.
     * 
     * @param enabled  indicates grouping enabled, false disabled
     */

    public void setRowGroupingEnabled(boolean enabled) {
        rowGroupingEnabled = enabled;
    }

    /**
     * Adds a component to the panel using the default constraints.
     * Proceeds to the next data column.
     * 
     * @param component	the component to add
     */

    public void append(Component component) {
        append(component, 1);
    }

    /**
     * Adds a component to the panel using the default constraints with
     * the given columnSpan. Proceeds to the next data column.
     * 
     * @param component the component to append
     * @param columnSpan    the column span used to add 
     */

    public void append(Component component, int columnSpan) {
        ensureCursorColumnInGrid();
        ensureHasGapRow(lineGapSpec);
        ensureHasComponentLine();
        
        add(component, createLeftAdjustedConstraints(columnSpan));
        nextColumn(columnSpan + 1);
    }

    /**
     * Adds two components to the panel; each component will span a single
     * data column. Proceeds to the next data column.
     * 
     * @param c1    the first component to add
     * @param c2    the second component to add
     */    

    public void append(Component c1, Component c2) {
        append(c1);
        append(c2);
    }

    /**
     * Adds three components to the panel; each component will span a single
     * data column. Proceeds to the next data column.
     * 
     * @param c1    the first component to add
     * @param c2    the second component to add
     * @param c3    the third component to add
     */    

    public void append(Component c1, Component c2, Component c3) {
        append(c1);
        append(c2);
        append(c3);
    }

    /**
     * Adds a text label to the panel and proceeds to the next column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @return the added label
     */

    public JLabel append(String textWithMnemonic) {
        JLabel label = getComponentFactory().createLabel(textWithMnemonic);
        append(label);
        return label;
    }

    /**
     * Adds a text label and component to the panel. 
     * Then proceeds to the next data column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param component         the component to add
     * @return the added label
     */    

    public JLabel append(String textWithMnemonic, Component component) {
        return append(textWithMnemonic, component, 1);
    }

    /**
     * Adds a text label and component to the panel; the component will span
     * the specified number columns. Proceeds to the next data column.
     * <p>
     * The created label is labelling the given component; so the component
     * gets the focus if the (optional) label mnemonic is pressed.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c                 the component to add
     * @param columnSpan        number of columns the component shall span
     * @return the added label
     * @see JLabel#setLabelFor(java.awt.Component)
     */    

    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {
        JLabel label = append(textWithMnemonic);
        label.setLabelFor(c);
        append(c, columnSpan);
        return label;
    }

    /**
     * Adds a text label and two components to the panel; each component
     * will span a single column. Proceeds to the next data column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c1    the first component to add
     * @param c2    the second component to add
     * @return the added label
     */    

    public JLabel append(String textWithMnemonic, Component c1, Component c2) {
        JLabel label = append(textWithMnemonic, c1);
        append(c2);
        return label;
    }

    /**
     * Adds a text label and two components to the panel; each component
     * will span a single column. Proceeds to the next data column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c1      the first component to add
     * @param c2      the second component to add
     * @param colSpan the column span for the second component
     */    

    public void append(String textWithMnemonic, Component c1, Component c2, int colSpan) {
        append(textWithMnemonic, c1);
        append(c2, colSpan);
    }

    /**
     * Adds a text label and three components to the panel; each component
     * will span a single column. Proceeds to the next data column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c1    the first component to add
     * @param c2    the second component to add
     * @param c3    the third component to add
     * @return the added label
     */    

    public JLabel append(String textWithMnemonic, Component c1, Component c2, Component c3) {
        JLabel label = append(textWithMnemonic, c1, c2);
        append(c3);
        return label;
    }

    /**
     * Adds a text label and four components to the panel; each component
     * will span a single column. Proceeds to the next data column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c1    the first component to add
     * @param c2    the second component to add
     * @param c3    the third component to add
     * @param c4    the fourth component to add
     * @return the added label
     */    

    public JLabel append(String textWithMnemonic, Component c1, Component c2, Component c3, Component c4) {
        JLabel label = append(textWithMnemonic, c1, c2, c3);
        append(c4);
        return label;
    }

    /**
     * Adds an internationalized (i15d) text label to the panel using 
     * the given resource key and proceeds to the next column.
     * 
     * @param resourceKey      the resource key for the the label's text
     * @return the added label
     */

    public JLabel appendI15d(String resourceKey) {
        return append(getI15dString(resourceKey));
    }

    /**
     * Adds an internationalized (i15d) text label and component to the panel. 
     * Then proceeds to the next data column.
     * 
     * @param resourceKey  the resource key for the text to add
     * @param component  the component to add
     * @return the added label
     */    

    public JLabel appendI15d(String resourceKey, Component component) {
        return appendI15d(resourceKey, component, 1);
    }

    /**
     * Adds an internationalized (i15d) text label and component to the panel. 
     * Then proceeds to the next data column.
     * Goes to the next line if the boolean flag is set.
     * 
     * @param resourceKey  the resource key for the text to add
     * @param component    the component to add
     * @param nextLine     true forces a next line
     * @return the added label
     */    

    public JLabel appendI15d(String resourceKey, Component component, boolean nextLine) {
        JLabel label = appendI15d(resourceKey, component, 1);
        if (nextLine) {
            nextLine();
        }
        return label;
    }

    /**
     * Adds an internationalized (i15d) text label and four components to the panel; 
     * each component will span a single column. Proceeds to the next data column.
     * 
     * @param resourceKey  the resource key for the text to add
     * @param c1    the first component to add
     * @param c2    the second component to add
     * @param c3    the third component to add
     * @param c4    the third component to add
     * @return the added label
     */    

    public JLabel appendI15d(String resourceKey, Component c1, Component c2, Component c3, Component c4) {
        JLabel label = appendI15d(resourceKey, c1, c2, c3);
        append(c4);
        return label;
    }

    /**
     * Adds a title label to the panel and proceeds to the next column.
     * 
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @return the added title label
     */

    public JLabel appendTitle(String textWithMnemonic) {
        JLabel titleLabel = getComponentFactory().createTitle(textWithMnemonic);
        append(titleLabel);
        return titleLabel;
    }

    /**
     * Adds an internationalized title label to the panel and 
     * proceeds to the next column.
     * 
     * @param resourceKey   the resource key for the title's text
     * @return the added title label
     */

    public JLabel appendI15dTitle(String resourceKey) {
        return appendTitle(getI15dString(resourceKey));
    }

    /**
     * Adds a separator without text that spans all columns.
     * 
     * @return the added titled separator 
     */

    public JComponent appendSeparator() {
        return appendSeparator("");
    }

    /**
     * Adds a separator with the given text that spans all columns.
     * 
     * @param text      the separator title text
     * @return the added titled separator 
     */

    public JComponent appendSeparator(String text) {
        ensureCursorColumnInGrid();
        ensureHasGapRow(paragraphGapSpec);
        ensureHasComponentLine();
        
        setColumn(super.getLeadingColumn());
        int columnSpan = getColumnCount();
        setColumnSpan(getColumnCount());
        JComponent titledSeparator = addSeparator(text);
        setColumnSpan(1);
        nextColumn(columnSpan);
        return titledSeparator;
    }

    /**
     * Appends an internationalized titled separator for 
     * the given resource key that spans all columns.
     * 
     * @param resourceKey   the resource key for the separator title's text
     */

    public void appendI15dSeparator(String resourceKey) {
        appendSeparator(getI15dString(resourceKey));
    }

    /**
     * Returns the leading column. Unlike the superclass this method
     * honors the column offset.
     * 
     * @return the leading column
     */

    protected int getLeadingColumn() {
        int column = super.getLeadingColumn();
        return column + getLeadingColumnOffset() * getColumnIncrementSign();
    }

    /**
     * Ensures that the cursor is in the grid. In case it's beyond the 
     * form's right hand side, the cursor is moved to the leading column
     * of the next line.
     */

    private void ensureCursorColumnInGrid() {
        if (   ( isLeftToRight() && (getColumn() > getColumnCount()))
            || (!isLeftToRight() && (getColumn() < 1))) {
            nextLine();
        }
    }

    /**
     * Ensures that we have a gap row before the next component row.
     * Checks if the current row is the given <code>RowSpec</code>
     * and appends this row spec if necessary.
     * 
     * @param gapRowSpec  the row specification to check for
     */

    private void ensureHasGapRow(RowSpec gapRowSpec) {
        if ((getRow() == 1) || (getRow() <= getRowCount()))
            return;
        
        if (getRow() <= getRowCount()) {
            RowSpec rowSpec = getCursorRowSpec();
            if ((rowSpec == gapRowSpec))
                return;
        }
        appendRow(gapRowSpec);
        nextLine();
    }

    /**
     * Ensures that the form has a component row. Adds a component row
     * if the cursor is beyond the form's bottom.
     */

    private void ensureHasComponentLine() {
        if (getRow() <= getRowCount()) return;
        appendRow(FormFactory.PREF_ROWSPEC);  
        if (isRowGroupingEnabled()) {
            getLayout().addGroupedRow(getRow());
        }      
    }

    /**
     * Looks up and returns the row specification of the current row.
     *  
     * @return the row specification of the current row
     */

    private RowSpec getCursorRowSpec() {
        return getLayout().getRowSpec(getRow());
    }

	/**
	 * Adds a title , gradient color.
	 * 
	 * @param text      the separator title text
	 * @return the added titled gradient 
	 */

	public JComponent appendGradientLabel(String text) {
		return appendSeparator(text);
		
	}

        /**
         * Sets the value of the variables property.
         * 
         * @param variables
         *     allowed object is
         *     {@link TridasVariable }
         *     
         */

        public void setVariables(List<TridasVariable> variables) {
            this.variables = variables;
        }

    /**
     * Checks and answers whether the given class supports bound properties, 
     * i.e. it provides a pair of multicast event listener registration methods 
     * for <code>PropertyChangeListener</code>s:
     * <pre>
     * public void addPropertyChangeListener(PropertyChangeListener x);
     * public void removePropertyChangeListener(PropertyChangeListener x);
     * </pre> 
     * 
     * @param clazz    the class to test
     * @return true if the class supports bound properties, false otherwise
     */

    public static boolean supportsBoundProperties(Class clazz) {
        return  (getPCLAdder(clazz)   != null) 
             && (getPCLRemover(clazz) != null);
    }

	/**
     * Adds a text label and component to the panel; the component will span
     * the specified number columns. Proceeds to the next data column.
     * <p>
     * The created label is labelling the given component; so the component
     * gets the focus if the (optional) label mnemonic is pressed.
     *
     * If Component is Persistent glue label with component (iniPersistentLabel
     *   
     * @param textWithMnemonic  the label's text - may mark a mnemonic
     * @param c                 the component to add, is a Persistent Component!?
     * @param columnSpan        number of columns the component shall span
     * @return the added label
     * @see JLabel#setLabelFor(java.awt.Component)
     */    

    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {
    	this.lastAdapter = FactoryWidget.getFactory().getLastAdapter();
        JLabel label = append(textWithMnemonic);
        label.setLabelFor(c);
        iniPersitentLabel (label, c);
        append(c, columnSpan);
        return label;
    }

	/**
	 * Adds a title , gradient color.
	 * 
	 * @param text      the separator title text
	 * @return the added titled gradient 
	 */

	public JComponent appendGradientLabel(String text) {
		JComponent result = appendSeparator(text);
		if (result instanceof Container) {
			Container c = (Container) result;
			for (int i = 0; i < c.getComponentCount(); i++) {
				if (c.getComponent(i) instanceof JLabel) {
					JLabel label = (JLabel) c.getComponent(i);
					label.setForeground(new java.awt.Color(10, 96, 43));
					label.setFont(label.getFont().deriveFont(16.0f));
				}
			}
		}
		return result;
	}

	/**
	 * Returns the plugin's resource bundle,
	 */

	public ResourceBundle getResourceBundle() {
		return resourceBundle;
	}

    /**
     * makes the TableCursor visible again.
     * 
     * @see org.eclipse.jface.viewers.ICellEditorListener#applyEditorValue()
     */

    public void applyEditorValue() {
        setVisible(true);
        redraw();
//        StructuredSelection sel = (StructuredSelection) tableViewer.getSelection();
        //        setSelection(tableViewerExample
        //                .getRowIndex((HashMap) sel.getFirstElement()),
        // getColumn());
        TreeItem currentRow = getRow();
        if (currentRow != null && !currentRow.isDisposed()) {
            tableViewer.setSelection(new StructuredSelection(getRowAsElement()), true);
        }
        currentRow = getRow();
        if (currentRow != null && !currentRow.isDisposed()) {
            // set selection of table separatly; viewer does incorrectly.
            ((Tree) getParent()).setSelection(new TreeItem[] { currentRow });
        }
    }

    /**
     * makes the TableCursor visible again.
     * 
     * @see org.eclipse.jface.viewers.ICellEditorListener#cancelEditor()
     */

    public void cancelEditor() {
        setVisible(true);
    }

    /**
     * subclass can override double click behavior.
     * default activates cell editor
     */

    protected void handleDoubleClick() {
        activateEditor();
    }

    /**
     * Adds the listener to the collection of listeners who will be notified
     * when the receiver's selection changes, by sending it one of the messages
     * defined in the <code>SelectionListener</code> interface.
     * <p>
     * When <code>widgetSelected</code> is called, the item field of the event
     * object is valid. If the reciever has <code>SWT.CHECK</code> style set
     * and the check selection changes, the event object detail field contains
     * the value <code>SWT.CHECK</code>.<code>widgetDefaultSelected</code>
     * is typically called when an item is double-clicked.
     * </p>
     * 
     * @param listener
     *            the listener which should be notified
     * 
     * @exception IllegalArgumentException
     *                <ul>
     *                <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
     *                </ul>
     * @exception SWTException
     *                <ul>
     *                <li>ERROR_WIDGET_DISPOSED - if the receiver has been
     *                disposed</li>
     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
     *                thread that created the receiver</li>
     *                </ul>
     * 
     * @see SelectionListener
     * @see SelectionEvent
     * @see #removeSelectionListener(SelectionListener)
     *  
     */

    public void addSelectionListener(SelectionListener listener) {
        checkWidget();
        if (listener == null)
            SWT.error(SWT.ERROR_NULL_ARGUMENT);
        TypedListener typedListener = new TypedListener(listener);
        addListener(SWT.Selection, typedListener);
        addListener(SWT.DefaultSelection, typedListener);
    }

    /**
     * adds a figure or connection to the collection of figures which should be
     * printed
     */

    public void add(IFigure figure) {
        if (figure instanceof Connection) {
            connections.add((Connection) figure);
        } else {
            children.add(figure);
        }
    }

	/**
	 * Returns the end offset of the line that contains the specified offset or
	 * if the offset is inside a line delimiter, the end offset of the next line.
	 *
	 * @param offset the offset whose line end offset must be computed
	 * @return the line end offset for the given offset
	 * @exception BadLocationException if offset is invalid in the current document
	 */

	protected int endOfLineOf(int offset) throws BadLocationException {

		IRegion info = fDocument.getLineInformationOfOffset(offset);
		if (offset <= info.getOffset() + info.getLength())
			return info.getOffset() + info.getLength();

		int line = fDocument.getLineOfOffset(offset);
		try {
			info = fDocument.getLineInformation(line + 1);
			return info.getOffset() + info.getLength();
		} catch (BadLocationException x) {
			return fDocument.getLength();
		}
	}

    /**
     * Removes the listener from the collection of listeners who will be
     * notified when the receiver's selection changes.
     * 
     * @param listener
     *            the listener which should no longer be notified
     * 
     * @exception IllegalArgumentException
     *                <ul>
     *                <li>ERROR_NULL_ARGUMENT - if the listener is null</li>
     *                </ul>
     * @exception SWTException
     *                <ul>
     *                <li>ERROR_WIDGET_DISPOSED - if the receiver has been
     *                disposed</li>
     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
     *                thread that created the receiver</li>
     *                </ul>
     * 
     * @see SelectionListener
     * @see #addSelectionListener(SelectionListener)
     * 
     * @since 3.0
     */

    public void removeSelectionListener(SelectionListener listener) {
        checkWidget();
        if (listener == null) {
            SWT.error(SWT.ERROR_NULL_ARGUMENT);
        }
        removeListener(SWT.Selection, listener);
        removeListener(SWT.DefaultSelection, listener);
    }

    /**
     * Returns the column over which the TableCursor is positioned.
     * 
     * @return the column for the current position
     * 
     * @exception SWTException
     *                <ul>
     *                <li>ERROR_WIDGET_DISPOSED - if the receiver has been
     *                disposed</li>
     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
     *                thread that created the receiver</li>
     *                </ul>
     */

    public int getColumn() {
        checkWidget();
        return column == null ? 0 : table.indexOf(column);
    }

    /**
     * Returns the row over which the TableCursor is positioned.
     * 
     * @return the item for the current position
     * 
     * @exception SWTException
     *                <ul>
     *                <li>ERROR_WIDGET_DISPOSED - if the receiver has been
     *                disposed</li>
     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
     *                thread that created the receiver</li>
     *                </ul>
     */

    public TreeItem getRow() {
        checkWidget();
        return row;
    }

	/**
	 *  Add a CheckoutModuleData in the CheckoutData object
	 *
	 * @param  iModuleName          The name of the module to be added
	 * @param  iCheckoutModuleData  The CheckoutData related to this module
	 */

	public void addModuleData(String iModuleName, CheckoutModuleData iCheckoutModuleData) {
		checkoutModuleDataMap.put(iModuleName, iCheckoutModuleData);
	}

	/**
	 *  remove a CheckoutModuleData in the CheckoutData object
	 *
	 * @param  iModuleName  Description of the Parameter
	 */

	public void removeModuleData(String iModuleName) {
		checkoutModuleDataMap.remove(iModuleName);
	}

	/**
	 *  Check if all CheckoutModules are correct, i.e. if each CheckoutModuleDataField of each CheckoutModuleData for each CheckoutModule is valid.
	 *
	 * @return    true if all CheckoutModuleDataFields are correct, otherwise false.
	 * @see CheckoutModuleData#isCorrect()
	 */

	public boolean isCorrect() {

		Iterator moduleDataIterator = checkoutModuleDataMap.values().iterator();
		while (moduleDataIterator.hasNext()) {
			CheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();
			if (!lCheckoutModuleData.isCorrect()) {
				return false;
			}
		}
		return true;
	}

	/**
	 *  Sets all CheckoutModuleDataFields (for each module) to UNVERIFIED
	 */

	public void setFieldstoUnverified() {
		Iterator moduleDataIterator = checkoutModuleDataMap.values().iterator();
		while (moduleDataIterator.hasNext()) {
			CheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();
			lCheckoutModuleData.setFieldstoUnverified();
		}
	}

	/**
	 *  Returns the max step of the checkout.
	 * 
	 *  Each module has fields, and each field is associated with a step.
	 * This method asks each module his max step, and returns the max step for all modules.
	 *
	 * @return    The maxStep for all modules
	 */

	public int getMaxStep() {
		int currentMaxStep;
		int res = 0;
		Iterator moduleDataIterator = checkoutModuleDataMap.values().iterator();
		while (moduleDataIterator.hasNext()) {
			CheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();
			currentMaxStep = lCheckoutModuleData.getMaxStep();
			if (currentMaxStep >= res) {
				res = currentMaxStep;
			}
		}
		return res;
	}

	/**
	 *  Returns the CheckoutModuleData associated with the specified module name 
	 *
	 * @param  iKey  The name of the CheckoutModule
	 * @return       The moduleData for this CheckoutModule, null if the module doesn't exist
	 */

	public CheckoutModuleData getModuleData(String iKey) {
		return (CheckoutModuleData) checkoutModuleDataMap.get(iKey);
	}

	/**
	 *  Gets the modulesIterator attribute of the CheckoutData object
	 *
	 * @return    The modulesIterator value
	 */

	public Iterator getModulesIterator() {
		if (checkoutModuleMap != null) {
			return checkoutModuleMap.values().iterator();
		} else {
			return (Iterator) null;
		}
	}

	/**
	 *  Adds a feature to the InitError attribute of the CheckoutData object
	 *
	 * @param  iMap  The feature to be added to the InitError attribute
	 */

	public void addInitError(Map iMap) {
		initErrors.add(iMap);
	}

	/**
	 *  Clear all initialisation errors
	 *  This method is called at the end of streamError().
	 */

	public void clearInitErrors() {
		initErrors.clear();
	}

	/**
	 *  Sets the label attribute of the CheckoutModuleDataField object
	 *
	 * @param  iLocale  The new label value
	 * @param  iString  The new label value
	 */

	public void setLabel(Locale iLocale, String iString) {
		this.labelMap.remove(iLocale);
		this.labelMap.put(iLocale, iString);
	}

	/**
	 *  Check if ther is no initialisation error
	 *
	 * @return    true if ther is no initialisation error, or false otherwise
	 */

	public boolean isInitialized() {
		return ((initErrors == null) || (initErrors.size() == 0));
	}

	/**
	 *  Gets the label attribute of the CheckoutModuleDataField object
	 *
	 * @param  iLocale  Description of the Parameter
	 * @return          The label value
	 */

	public String getLabel(Locale iLocale) {
		if (this.labelMap != null) return (String) this.labelMap.get(iLocale.getLanguage());
		else return null;
	}

	/**
	 *  Sets the askedStep attribute of the CheckoutData object
	 *
	 * @param  iStep  The new askedStep value
	 */

	public void setAskedStep(int iStep) {
		this.askedStep = iStep;
	}

	/**
	 *  Sets the message attribute of the CheckoutModuleDataField object
	 *
	 * @param  iLocale  The new message value
	 * @param  iString  The new message value
	 */

	public void setMessage(Map iMap) {
		messageMap = iMap;
	}

	/**
	 *  Gets the askedStep attribute of the CheckoutData object
	 *
	 * @return    The askedStep value
	 */

	public int getAskedStep() {
		return this.askedStep;
	}

	/**
	 *  Gets the message attribute of the CheckoutModuleDataField object
	 *
	 * @param  iLocale  Description of the Parameter
	 * @return          The message value
	 */

	public String getMessage(Locale iLocale) {
		return (String) this.messageMap.get(iLocale);
	}

	/**
	 *  Sets the externalPayment attribute of the CheckoutData object
	 *  If external payment is not null, then the PaymentProcessorCheckoutModule need to stream all the mandatory informations for the payment (URI, amount, company accounts...)with the setPaymentParameters(Map) method. 
	 *
	 * @param  iExternalPayment  The new externalPayment value
	 * @see #setPaymentParameters(Map)
	 */

	public void setExternalPayment(String iExternalPayment) {
		externalPayment = iExternalPayment;
	}

	/**
	 *  Gets the externalPayment attribute of the CheckoutData object
	 *
	 * @return    The externalPayment value
	 */

	public String getExternalPayment() {
		return externalPayment;
	}

	/**
	 *  Sets the orderLogStatus attribute of the CheckoutData object
	 *  Used by the OrderLogCheckoutModule to know if the orderlog (in db for example) is correct. 
	 *
	 * @param  iLog  The new orderLogStatus value
	 */

	public void setOrderLogStatus(String iLog) {
		orderLogStatus = iLog;
	}

	/**
	 *  Sets the status attribute of the CheckoutModuleDataField object
	 *
	 * @param  iStatus  The new status value
	 */

	public void setStatus(Integer iStatus) {
		status = iStatus;
	}

	/**
	 *  Clear the orderLogStatus attribute.
	 */

	public void unsetOrderLogStatus() {
		orderLogStatus = null;
	}

	/**
	 *  Gets the status attribute of the CheckoutModuleDataField object
	 *
	 * @return    The status value
	 */

	public Integer getStatus() {
		return status;
	}

	/**
	 *  Gets the orderLogStatus attribute of the CheckoutData object
	 *
	 * @return    The orderLogStatus value
	 */

	public String getOrderLogStatus() {
		return orderLogStatus;
	}

	/**
	 *  Sets the type attribute of the CheckoutModuleDataField object
	 *
	 * @param  iType  The new type value
	 */

	public void setType(String iType) {
		if ("group".equals(this.type)){
			for (int i = 0; i < group.size(); i++) {
				CheckoutModuleDataField lCheckoutDataField = (CheckoutModuleDataField) group.get(i);
				lCheckoutDataField.setType(iType);
			}
		} else {
			type = iType;
		}

	}

	/**
	 *  Sets the orderNumber attribute of the CheckoutData object
	 *
	 * @param  iOrderNumber  The new orderNumber value
	 */

	public void setOrderNumber(Integer iOrderNumber) {
		orderNumber = iOrderNumber;
	}

	/**
	 *  Gets the orderNumber attribute of the CheckoutData object
	 *
	 * @return    The orderNumber value
	 */

	public Integer getOrderNumber() {
		return orderNumber;
	}

	/**
	** Generates a string with a utility string buffer
	**/

	public String toString(StringBuffer uStringBuffer) {
		uStringBuffer.setLength(0);
		uStringBuffer.append(humanReadableKey);
		uStringBuffer.append('.');
		uStringBuffer.append(representationSecurityLevel);
		uStringBuffer.append('.');
		uStringBuffer.append(getData());
		uStringBuffer.append('.');
		uStringBuffer.append(comesFromSession);
		return uStringBuffer.toString();
	}

	/**
	 *  Gets the documentViewer attribute of the Thing object
	 *
	 * @param  ioDocumentData  Description of the Parameter
	 * @return                 The documentViewer value
	 */

	public Viewer getDocumentViewer(DocumentData ioDocumentData) {
		ThingDocumentData lThingDocumentData = (ThingDocumentData) ioDocumentData;
		Viewer lViewer = null;
		if (lThingDocumentData.isEditable()) {
			lViewer = new ThingDocumentViewer(lThingDocumentData, this, this);
		}
		return lViewer;
	}

	/**
	 *  Gets the ontologyName name of the Thing object
	 *
	 * @return    The string "thing"
	 */

	public String getOntologyName() {
		return "thing";
	}

	/**
	 *  Always return null
	 *
	 * @param  iViewer           viewer object
	 * @param  ioConnection      SQL connection
	 * @param  uStringBuffer     StringBuffer utility object
	 * @return                   null
	 * @exception  SQLException  Description of the Exception
	 */

	public Object getData(Viewer iViewer, Connection ioConnection, StringBuffer uStringBuffer) throws SQLException {
		return null;
	}

	/**
	** Get initparameters in web.xml, convert the name of the parameters, and put the name and the value in jsMap
	**/

	public void init() throws ServletException {
		ServletConfig lServletConfig = getServletConfig();
		for (Enumeration lEnum = lServletConfig.getInitParameterNames();lEnum.hasMoreElements();) {
			//System.out.println(lEnum);
			String ltmpStringjs = (String) lEnum.nextElement();
			//test if ltmpStringjs begins with javascript.xxx
			if (ltmpStringjs.startsWith("javascript.")){
				String ltmpStringjsvalue = lServletConfig.getInitParameter(ltmpStringjs);
				//convert ltmpStringjs javascript.value in value
				ltmpStringjs = ltmpStringjs.replaceAll("javascript.","");
				//add to jsMap
				jsMap.put(ltmpStringjs,ltmpStringjsvalue);
			}
		}
	}

	/**
	*	set Doc810 e-mail header
	*/

	public String setInvoiceHeader() {

		String invoiceHeader = 	"Distribution Fusion 3 inc.\n" +
								"Electronic Trading System\n\n" +
								"Invoice no.: \n" +
								"Date : " + today +
								"\n\nTrading partner : " + "HMV North America" +
								"reference : " +
								"Content type :   EDI\n\n";

		return invoiceHeader;
	}

	/**
	* Get all Items.
	*/

	public Collection getPurchaseOrderItemRelations()  {
		return purchaseOrderItemRelations;
	}

    /**
     * Returns a dataisland object 
     * @param dataislandPrimitiveName the name of the dataisland primitive
     * @param value object to be converted
     * @return Returns a dataisland object corresponding to the primitive name
     */

    static public Object convert(String dataislandPrimitiveName, Object value) {
        return convert(dataislandPrimitiveName, value, null);
    }

    /**
     * Iterates through a collection of potentially localizable (LocalizableEntity).
     *
     * @param localizableObjectCollection
     * @param localizationContext
     */

    static public void localize(Collection localizableObjectCollection, org.dataisland.primitives.bean.LocalizationContext localizationContext) throws LocalizationException {
        for (Iterator i = localizableObjectCollection.iterator(); i.hasNext();) {
            Object lCurrentObject = i.next();

            if (lCurrentObject instanceof Collection) {
                localize((Collection) lCurrentObject, localizationContext);
            } else if (lCurrentObject instanceof org.dataisland.primitives.bean.Localizable) {
                localize((org.dataisland.primitives.bean.Localizable) lCurrentObject, localizationContext);
            }
        }
    }

    /**
     * Compares this object with the specified object for order. Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     * @param o the Object to be compared.
     * @return a negative integer, zero, or a positive integer as this object
     *         is less than, equal to, or greater than the specified object
     */

    public int compareTo(Object o) {
        if (!(o instanceof Datatype)) {
            throw new IllegalArgumentException("The object to be compared must be a Datatype object");
        }
        return -1;
    }

    /**
     * Compares this object with the specified object for order. Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.
     * @param o the Object to be compared.
     * @return a negative integer, zero, or a positive integer as this object
     *         is less than, equal to, or greater than the specified object
     */

    public int compareTo(Object o) {
    		if (!(o instanceof Money)) {
            throw new IllegalArgumentException("The object to be compared must be a Money object");
        }
        
        Money obj = (Money) o;
        
        if (amount != null) {
            return amount.compareTo(obj.getAmount());
        }

        return -1;
            
    }

	/**
	* Retrieves the data island object that is able to generate the desired document.
	*
	* @return the data object.
	*/

	public DataIsland getDataIsland() {
		return dataIsland;
	}

	/**
	* Retrieves the key object that uniquely represent the information set of the document.
	*
	* @return the data object.
	*/

	public Object getData() {
		return data;
	}

	/**
	* Sets the document type for this instance.
	*
	* Also invalidate the cached string representation.
	*
	* @param iDocumentType The document type for this instance.
	*/

	public void setDocumentType(DocumentType iDocumentType) {
		this.documentType = iDocumentType;
		string = null;
	}

	/**
	* Retrieves the last modification date of the document generated from the given parameters.
	*
	* @return the last modification date.
	*/

	public Date getLastModified() {
		return lastModified;
	}

	/**
	* Gets the document type for this instance.
	*
	* @return The document type for this instance.
	*/

	public DocumentType getDocumentType() {
		return documentType;
	}

	/**
	* Retrieves the view of this document's serial number.
	*
	* @return the view object.
	*/

	public View getView() {
		return view;
	}

	/**
	* Retrieves the locale of this document's serial number.
	*
	* @return the locale object.
	*/

	public Locale getLocale() {
		View view = getView();
		if(view == null) return null;
		return view.getLocale();
	}

	/**
	* Sets the locale for this instance.
	*
	* Also invalidate the cached string representation.
	*
	* @param iLocale The locale for this instance.
	*/

	public void setLocale(Locale iLocale) {
		this.locale = iLocale;
		string = null;
	}

	/**
	* Retrieves the document type of this document's serial number.
	*
	* @return the document type object.
	*/

	public DocumentType getDocumentType() {
		View view = getView();
		if(view == null) return null;
		return view.getDocumentType();
	}

	/**
	* Sets the data object.
	*
	* @param iDataIsland The data island object that is able to generate the desired document.
	*/

	public void setDataIsland(DataIsland iDataIsland) {
		dataIsland = iDataIsland;
	}

	/**
	* Sets the data object.
	*
	* @param iData The document data object.
	*/

	public void setData(Object iData) {
		data = iData;
	}

	/**
	* Gets the locale for this instance.
	*
	* @return The locale for this instance.
	*/

	public Locale getLocale() {
		return locale;
	}

	/**
	* Sets the last modification date of the document generated from the given parameters.
	*
	* @param iLastModified the last modification date.
	*
	* @throw IllegalArgumentException if the last changed date is null.
	*/

	public void setLastModified(Date iLastModified) {
		if(iLastModified == null) throw new IllegalArgumentException("The last changed date object cannot be null");
		lastModified = iLastModified;
	}

	/**
	* Sets the key object that uniquely represent the information set of the document.
	*
	* @param iKey The data key.
	*/

	public void setKey(String iKey) {
		key = iKey;
	}

	/**
	* Sets the mode for this instance.
	*
	* Also invalidate the cached string representation.
	*
	* @param iMode The mode for this instance.
	*/

	public void setMode(String iMode) {
		this.mode = iMode;
		string = null;
	}

	/**
	* Sets the view of this document's serial number.
	*
	* @param iview The document locale to be set for this instance of the data island object.
	*
	* @throw IllegalArgumentException if any of the view or its locale or document type are null.
	*/

	public void setView(View iView) {
		if(iView == null) throw new IllegalArgumentException("The view object cannot be null");
		//else if(iView.getLocale() == null) throw new IllegalArgumentException("The view's locale cannot be null");
		else if(iView.getDocumentType() == null) throw new IllegalArgumentException("The view's document type cannot be null");
		view = iView;
	}

	/**
	* Gets the mode for this instance.
	*
	* @return The mode string for this instance.
	*/

	public String getMode() {
		return mode;
	}

	/**
	* Generate a textual representattion of this view.
	*
	* @return a String representation of this view
	*/

	public String toString() {
		if(string == null) {
			StringBuffer sb = new StringBuffer();
			if(locale != null) sb.append(locale).append('.');
			sb.append(documentType);
			string = sb.toString();
		}
		return string;
	}

	/**
	* Indicates whether some other object is "equal to" this view.
	*
	* @param obj The object to be tested.
	*
	* @return true if both objects are equal
	*/

	public boolean equals(Object obj) {
		if(obj instanceof View)  {
			View view = (View) obj;
			if(Misc.match(view.documentType, this.documentType) && Misc.match(view.locale, this.locale))
				return true;
		}
		return false;
	}

	/**
	* Returns the hash code value for this view (based on the string representation).
	*
	* @return the hash code value for this view.
	*/

	public int hashCode() {
		return toString().hashCode();
	}

	/**
	* Returns a view that with an XML document type, generated from a locale.
	*
	* @param locale The reference locale.
	*
	* @return the view.
	*/

	static public View getXMLView(Locale locale) {
		return new View(DocumentType.XML, locale);
	}

	/**
	* Returns a list of locales extracted from a list of views.
	*
	* @param iViews The reference views.
	*
	* @return the list of locales.
	*
	* @see java.util.Locale
	*/

	static public List getLocales(List iViews) {
		if(iViews == null) return null;
		Vector locales = new Vector();
		Iterator viewIterator = iViews.iterator();
		while(viewIterator.hasNext()) {
			View view = (View) viewIterator.next();
			if(!locales.contains(view.getLocale())) locales.add(view.getLocale());
		}
		if(locales.size() == 0) locales = null;
		return locales;
	}

	/**
	* Internal initialization method.
	*
	* <p>All of the public constructors invoke this method.</p>
	*
	* @param oWriter The output destination. Throws IllegalArgumentException.
	*/

	private void init(Writer oWriter) {
		if(oWriter == null) throw new IllegalArgumentException("The writer cannot be null");
		setOutput(oWriter);
	}

	/**
	* Return true if both objects are either null or equal (equals() function)
	*
	* @return true if both objects match.
	*/

	static public boolean match(Object o1, Object o2) {
		if(o1 == null) {
			if(o2 == null) return true;
		} else if(o2 != null) {
			if(o1.equals(o2)) return true;
		}
		return false;
	}

	/**
	* Internal initialization method.
	*
	* <p>All of the public constructors invoke this method.</p>
	*
	* @param oWriter The output destination. Throws IllegalArgumentException.
	*/

	private void reset() {
		output = null;
		prefixTable.clear();
		forcedDeclTable.clear();
		doneDeclTable.clear();
		elementLevel = 0;
		nsSupport.reset();
		prefixCounter = 0;
	}

    /**
    * Gets the query string.
    *
    * @return the query string or <code>null</code> if there is no parameter specified.
    */

    public String getQuery() {
		StringBuffer sb = new StringBuffer();
		String result = getQuery(sb);
		sb.setLength(0);
		return result;
    }

	/**
	* Set a new output destination for the document.
	*
	* @param oWriter The output destination.
	*/

	public void setOutput(Writer oWriter) {
		output = oWriter;
	}

	/**
	* Initializes the dataisland instance with the provided parameters.
	*
	* NOTE : this implementation simply does nothing.
	*
	* @param iParameters The initialization parameters for this data island instance.
	*/

	public void init(Map iParameters) {
	}

	/**
	** Gets the DataIsland Includer context for this servlet concext
	**/

	public IncluderContext getIncluderContext(ServletContext ioServletContext) {
		IncluderContext lIncluderContext = null;
		synchronized(INCLUDER_CONTEXT_KEY) {
			lIncluderContext = (IncluderContext) ioServletContext.getAttribute(INCLUDER_CONTEXT_KEY);
			if(lIncluderContext == null) {
				lIncluderContext = new IncluderContext();
				lIncluderContext.init(ioServletContext.getRealPath("/WEB-INF/includes"));
				ioServletContext.setAttribute(INCLUDER_CONTEXT_KEY, lIncluderContext);
			}
		}
		return lIncluderContext;
	}

	/**
	* Returns the SAX2 content handler for the viewer.
	*/

	public ContentHandler getContentHandler() {
		if(this.ch == null && this.os != null) {
			String lMIMEType = getMIMEDocumentType();
			if(lMIMEType != null) setContentHandler(ApacheSerializer.getContentHandler(lMIMEType, this.os));
		}
		return this.ch;
	}

	/**
	* Gets the best view for this viewer from a list of views.
	*/

	public View getBestView(Vector iViews) {
		return View.getBestView(getPreferredDocumentTypes(), getPreferredLocales(), iViews);
	}

	/**
	* Gets the best locale for this viewer from a list of locales.
	*/

	public Locale getBestLocale(List iLocales) {
		return Misc.getBestLocale(getPreferredLocales(), iLocales);
	}

	/**
	* Returns the SAX2 content handler for the viewer.
	*/

	public ContentHandler getContentHandler() {
		return this.ch;
	}

	/**
	** Remove the given parameter name from the reserved name list.
	**/

	static public void removeReservedParameter(String iParameterName) {
		reservedParameter.remove(iParameterName);
	}

	/**
	* Sets the name  (root element type, or if is not xml, its extension).
	*
	* @param iName The name for this document type.
	*/

	public void setName(String iName) {
		this.name = iName;
	}

	/**
	* Indicates whether some other object is "equal to" this document type.
	*
	* @param iO - the reference object with which to compare.
	*
	* @return true if both document types are equal.
	*/

	public boolean equals(Object iO) {
		 if (iO != null) {
		 	DocumentType documentType = (DocumentType) iO;
		 	if(documentType.name == null) {
		 		if(name == null) return true;
		 	} else if(name == null) {
		 		if(documentType.name == null) return true;
		 	} else if(name.equals(documentType.name)) return true;
		 }
		 return false;
	}

	/**
	* Generate a textual representattion of this document type.
	*
	* @return a String representation of this document type
	*/

	public String toString() {
		return getName();
	}

	/**
	* Gets the directory object where the stylesheets (*.xsl) will be taken from.
	*
	*/

	public File getRepositoryDirectory() {
		return repositoryDirectory;
	}

	/**
	* Sets the directory object where the stylesheets (*.xsl) will be taken from.
	*
	* @param iRepositoryDirectory The directory object where the stylesheets (*.xsl) will be taken from.
	*
	*/

	public void setRepositoryDirectory(File iRepositoryDirectory) {
		if(iRepositoryDirectory != null && iRepositoryDirectory.isDirectory() && iRepositoryDirectory.canRead()) {
			this.repositoryDirectory = iRepositoryDirectory;
			this.stylesheets = null;
		} else this.repositoryDirectory = null;
		refreshStylesheets();
	}

	/**
	* Gets the common directory object where the stylesheets (*.xsl) will be taken from.
	*
	*/

	public File getResolverRepositoryDirectory() {
		return resolverRepositoryDirectory;
	}

	/**
	* Sets the directory object where the cache xml files will be dumped.
	*
	* @param repositoryDirectory The directory object where the cache xml files will be dumped.
	*/

	public void setRepositoryDirectory(File repositoryDirectory) {
		if(repositoryDirectory != null && (repositoryDirectory.isDirectory() || repositoryDirectory.mkdirs()) && repositoryDirectory.canRead()) {
			try {
				this.repositoryDirectory = repositoryDirectory.getCanonicalFile();
				clear();
			} catch(IOException ioe) {
				clear();
				this.repositoryDirectory = null;
			}
		} else {
			clear();
			this.repositoryDirectory = null;
		}
	}

	/**
	* Sets the directory object where the common stylesheets (*.xsl) will be taken from.
	*
	* @param iCommonRepositoryDirectory The directory object where the stylesheets (*.xsl) will be taken from.
	*
	*/

	public void setResolverRepositoryDirectory(File iResolverRepositoryDirectory) {
		if(iResolverRepositoryDirectory != null && iResolverRepositoryDirectory.isDirectory() && iResolverRepositoryDirectory.canRead()) {
			this.resolverRepositoryDirectory = iResolverRepositoryDirectory;
			if(transformerURIResolver == null) transformerURIResolver = new TransformerURIResolver();
			try {
				transformerURIResolver.setRootDirectory(resolverRepositoryDirectory);
			} catch (IOException lIOException) {
				RuntimeException lRuntimeException = new RuntimeException("Bad transformer resolver repository directory :\n" + this.resolverRepositoryDirectory.getAbsolutePath() + "\n" + lIOException.getMessage(), lIOException);
				throw lRuntimeException;
			}
		} else this.resolverRepositoryDirectory = null;
		refreshStylesheets();
	}

 	/**
    * Appends the parameters from the given query string to the given Map
    *
    * @param query The source query string (must not be <code>.
    * @param parameters The destination <code>Map</map> instance.
    */

    static public void parseQueryParameters(String query, Map parameters) {
		StringTokenizer st = new StringTokenizer(query, "&");
		String key, value, pair;
		while(st.hasMoreTokens()) {
		    pair = (String)st.nextToken();
		    int pos = pair.indexOf('=');
		    if (pos != -1) {
				key = pair.substring(0, pos);
				value = pair.substring(pos+1, pair.length());
				parameters.put(key, value);
		    } else parameters.put(pair, null);
		}
    }

    /**
     * Save detached group instance into database.
     *
     * @param group
     * @return
     * @throws org.dataisland.cms.exception.DataIslandCMSException
     *
     */

    public Group saveGroup(Group group) throws DataIslandCMSException {
        if ("".equals(group.getId())) group.setId(null);

        try {

            // Initialize the hibernate session
            Session session = currentSession();
            // Start an hibernate transaction
            Transaction tx = session.beginTransaction();

            try {
                // Process persistance (create : if no persisted object previously existed, update otherwise)
                // Schedule the value object for persistence
                session.saveOrUpdate(group);

                // Commit hibernate transaction
                tx.commit();
            } catch (HibernateException he) {
                tx.rollback();
                throw new DataIslandCMSException(he);
            } finally {
                // Close the hibernate session
                closeSession();
            }

        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        }


        return group;
    }

    /**
     * Fetch list of database group instances.
     *
     * @return
     * @throws org.dataisland.cms.exception.DataIslandCMSException
     *
     */

    public List fetchGroupList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {
        List groups = null;
        // Initialize the hibernate session
        Session session = currentSession();

        try {
            // Fetch session from hibernate
            groups = session.createCriteria(Group.class).list();
            LocalizationUtils.localize(groups, localizationContext);
        } catch (Exception e) {
            throw new DataIslandCMSException(e);
        } finally {
            // Close the hibernate session
            closeSession();
        }
        return groups;
    }

    /**
     * Delete the group.
     *
     * @param group
     * @throws org.dataisland.cms.exception.DataIslandCMSException
     *
     */

    public void deleteGroup(Group group) throws DataIslandCMSException {
        try {
            // Initialize the hibernate session
            Session session = currentSession();
            // Start an hibernate transaction
            Transaction tx = session.beginTransaction();

            try {
                // Schedule for deletion
                session.delete(group);

                // Commit hibernate transaction
                tx.commit();
            } catch (HibernateException he) {
                tx.rollback();
                throw new DataIslandCMSException(he);
            } finally {
                // Close the hibernate session
                closeSession();
            }

        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        }
    }

    /**
     * Save detached role instance into database.
     *
     * @param role
     * @return
     * @throws org.dataisland.cms.exception.DataIslandCMSException
     *
     */

    public Role saveRole(Role role) throws DataIslandCMSException {
        if ("".equals(role.getId())) role.setId(null);

        try {

            // Initialize the hibernate session
            Session session = currentSession();
            // Start an hibernate transaction
            Transaction tx = session.beginTransaction();

            try {

                // Schedule the value object for persistence
                session.saveOrUpdate(role);

                // Commit hibernate transaction
                tx.commit();
            } catch (HibernateException he) {
                tx.rollback();
                throw new DataIslandCMSException(he);
            } finally {
                // Close the hibernate session
                closeSession();
            }

        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        }


        return role;
    }

    /**
     * Fetch list of database role instances.
     *
     * @return
     * @throws org.dataisland.cms.exception.DataIslandCMSException
     *
     */

    public List fetchRoleList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {
        List roles = null;
        // Initialize the hibernate session
        Session session = currentSession();

        try {
            // Fetch session from hibernate
            roles = session.createCriteria(Role.class).list();
            LocalizationUtils.localize(roles, localizationContext);
        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        } finally {
            // Close the hibernate session
            closeSession();
        }
        return roles;
    }

    /**
     * Delete the role.
     *
     * @param role
     * @throws org.dataisland.cms.exception.DataIslandCMSException
     *
     */

    public void deleteRole(Role role) throws DataIslandCMSException {
        try {
            // Initialize the hibernate session
            Session session = currentSession();
            // Start an hibernate transaction
            Transaction tx = session.beginTransaction();

            try {
                // Schedule for deletion
                session.delete(role);

                // Commit hibernate transaction
                tx.commit();
            } catch (HibernateException he) {
                tx.rollback();
                throw new DataIslandCMSException(he);
            } finally {
                // Close the hibernate session
                closeSession();
            }

        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        }
    }

    /**
     * Fetch list of database user instances.
     *
     * @return
     * @throws DataIslandCMSException
     */

    public List fetchUserList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {
        List users = null;
        // Initialize the hibernate session
        Session session = currentSession();

        try {
            // Fetch session from hibernate
            users = session.createCriteria(User.class).list();
            LocalizationUtils.localize(users, localizationContext);
        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        } finally {
            // Close the hibernate session
            closeSession();
        }
        return users;
    }

    /**
     * Delete the user.
     *
     * @param user
     * @throws DataIslandCMSException
     */

    public void deleteUser(org.dataisland.cms.bean.User user) throws DataIslandCMSException {
        try {
            // Initialize the hibernate session
            Session session = currentSession();
            // Start an hibernate transaction
            Transaction tx = session.beginTransaction();

            try {
                // Schedule for deletion
                session.delete(user);

                // Commit hibernate transaction
                tx.commit();
            } catch (HibernateException he) {
                tx.rollback();
                throw new DataIslandCMSException(he);
            } finally {
                // Close the hibernate session
                closeSession();
            }

        } catch (HibernateException he) {
            throw new DataIslandCMSException(he);
        }
    }

    /**
     * Create Object from XML tag
     * @param obj
     * @param uctx
     * @return
     * @throws JiBXException
     */

    public Object unmarshal(Object obj, IUnmarshallingContext uctx) throws JiBXException {

        // make sure we're at the appropriate start tag
        UnmarshallingContext ctx = (UnmarshallingContext)uctx;
        
        if (!ctx.isAt(m_uri, m_name)) {
            ctx.throwStartTagNameError(m_uri, m_name);
        }

        String refid = ctx.attributeText(m_uri, REFID_ATTRIBUTE_NAME);

        ctx.parsePastEndTag(m_uri, m_name);

        return ctx.findDefinedID(refid, m_index);
    }

    /**
     * updates role bean according to actionForm
     *
     * @param actionForm
     */

    static public Role loadFormIntoRole(ActionForm actionForm, HttpServletRequest httpServletRequest) throws LocalizationException {
        Role role = new Role();
        LocalizationUtils.localize(role, StrutsLocalizationUtils.getCompositeLocalizationContext(httpServletRequest, WEB_CONTEXT_LOCALIZATION_CONTEXT_KEY));
        DynaValidatorForm roleForm = (DynaValidatorForm) actionForm;
        role.setId((String) roleForm.get("id"));
        role.setHumanReadableKey((String) roleForm.get("humanReadableKey"));
        role.setName((String) roleForm.get("name"));
        role.setDescriptions(LocalizationUtils.getLocaleKeyedMap((SortedMap) roleForm.get("description")));
        return role;
    }

    /**
     * Populate form according to a group bean.
     *
     * @param actionForm
     * @param group
     */

    static public void populate(ActionForm actionForm, org.dataisland.cms.bean.Group group) {
        DynaValidatorForm groupDeleteForm = (DynaValidatorForm) actionForm;
        groupDeleteForm.set("id", group.getId());
        groupDeleteForm.set("name", group.getName());
    }

    /**
     * Populate form according to a role bean.
     *
     * @param actionForm
     * @param role
     */

    static public void populate(ActionForm actionForm, Role role) throws LocalizationException {
        DynaValidatorForm roleDeleteForm = (DynaValidatorForm) actionForm;
        roleDeleteForm.set("id", role.getId());
        roleDeleteForm.set("name", role.getName());
    }

    /**
     * Populate form according to a user bean.
     *
     * @param actionForm
     * @param user
     */

    static public void populate(ActionForm actionForm, org.dataisland.cms.bean.User user) {
        DynaValidatorForm userDeleteForm = (DynaValidatorForm) actionForm;
        userDeleteForm.set("id", user.getId());
        userDeleteForm.set("name", user.getName());
    }

    /**
     * Return a Role instance Set from an array of IDs.
     *
     * @param roleIds
     * @return
     * @throws DataIslandCMSException
     */

    static public Set getRolesFromIdArray(String[] roleIds, HttpServletRequest httpServletRequest) throws DataIslandCMSException, LocalizationException {
        Set roles = new HashSet();

        for (int i = 0; i < roleIds.length; i++) {
            try {
                roles.add(RolePersistenceFacade.getInstance().fetchRole(roleIds[i], StrutsLocalizationUtils.getCompositeLocalizationContext(httpServletRequest, WEB_CONTEXT_LOCALIZATION_CONTEXT_KEY)));
            } catch (org.dataisland.cms.exception.RoleNotFoundException rnfe) {
                throw new DataIslandCMSException("The role to be linked to the group does not exist.", rnfe);
            }
        }
        return roles;
    }

    /**
     * The setter method for this user's id.
     *
     * @param id
     */

    public void setId(String id) {
        this.id = id;
    }

    /**
     * The setter method for this user's password.
     *
     * @param password
     */

    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * The getter method for this user's login name.
     *
     * @return
     * @hibernate.property unique="true"
     * column="LOGIN"
     */

    public String getLogin() {
        return login;
    }

    /**
     * The setter method for this user's login name.
     *
     * @param login
     */

    public void setLogin(String login) {
        this.login = login;
    }

    /**
     * The getter method for this user's group.
     *
     * @return
     * @hibernate.many-to-one column="SYSTEMGROUP_FK"
     */

    public Group getGroup() {
        return group;
    }

    /**
     * The setter method for this user's group.
     *
     * @param group
     */

    public void setGroup(Group group) {
        this.group = group;
    }

    /**
     * The getter method for this user's email.
     *
     * @return
     * @hibernate.property column="EMAIL"
     */

    public String getEmail() {
        return email;
    }

    /**
     * The setter method for this user's group.
     *
     * @param email
     */

    public void setEmail(String email) {
        this.email = email;
    }

    /**
     * The getter method for this user's system status (system dependability).
     *
     * @return
     * @hibernate.property column="SYSTEM"
     */

    public boolean isSystem() {
        return system;
    }

    /**
     * The setter method for this user's system status (system dependability).
     *
     * @param system
     */

    public void setSystem(boolean system) {
        this.system = system;
    }

    /**
     * Get the context stack that is stored in the session
     *
     * @param contextStackKey
     * @param httpServletRequest
     * @return
     */

    static public ContextStack getContextStack(String contextStackKey, HttpServletRequest httpServletRequest) {
        //Get Context Stack
        String contextStackIdString = httpServletRequest.getParameter(contextStackKey);
        String contextStackId = (String) ConvertUtils.convert(contextStackIdString, String.class);
        return (ContextStack) httpServletRequest.getSession().getAttribute(contextStackId);
    }

    /**
     * Redirect the context stack key in the request
     *
     * @param contextStackKey
     * @param httpServletRequest
     */

    public void setContextStackIDInRequest(String contextStackKey, HttpServletRequest httpServletRequest) {
        // Get Stack
        String contextStackId = (String) httpServletRequest.getAttribute(contextStackKey);

        if (contextStackId == null) {
            String contextStackIdString = httpServletRequest.getParameter(contextStackKey);
            contextStackId = (String) ConvertUtils.convert(contextStackIdString, String.class);
            // Set context stack key in request
            if(contextStackId != null) {
                httpServletRequest.setAttribute(contextStackKey, contextStackId);
            }
        }
    }

    /**
     * The getter method for this group's role collection.
     *
     * @return
     * @hibernate.set table="SYSTEMGROUP_ROLES"
     * @hibernate.collection-key column="SYSTEMGROUP_FK"
     * @hibernate.collection-many-to-many column="SYSTEMROLE_FK"
     * class="org.dataisland.cms.bean.Role"
     */

    public Set getRoles() {
        return roles;
    }

    /**
     * The getter method for this role's human readable key.
     *
     * @return
     * @hibernate.property column="HUMAN_READABLE_KEY"
     */

    public String getHumanReadableKey() {
        return humanReadableKey;
    }

    /**
     * The setter method for this group's role collection.
     *
     * @param roles
     */

    public void setRoles(Set roles) {
        if (roles == null)
            this.roles.clear();
        else
            this.roles = roles;
    }

   /**
    * Add/replace the service context to the request.
    *
    * Service-contexts are not ordered in any way.
    * 
    * @param serviceContext
    */

   public void addRequestServiceContext(ServiceContext serviceContext) {
      addServiceContext(serviceContext);
   }

   /**
    * The interceptor method that decodes the incoming message on the Server side.
    *
    * @param interfaceName The target interface class name
    * @param methodName    The method name
    * @param arguments     The arguments
    * @param argumentTypes The argument class names to be used to identify an implementation Method
    * @param contextList   The Context List to be set to Current
    * @return The Response of the method invocation
    */

   public InvocationResponse exec(String interfaceName, String methodName, Object[] arguments, String[] argumentTypes, ServiceContext[] contextList) {
      return interceptorCtrl.exec(interfaceName, methodName, arguments, argumentTypes, contextList);
   }

   /**
    * This is not an action!!
    *
    * @return the exception to be returned to the client
    */

   public Throwable sendingException() {
      return this.sendingException;
   }

   /**
    * This probably is only optional.
    *
    * @return the server object
    */

   public Object server() {
      return this.server;
   }

   /**
    * Add/replace the service context to the request.
    *
    * Service-contexts are not ordered in any way.
    *
    * @param serviceContext
    */

   public void addReplyServiceContext(ServiceContext serviceContext) {
      addServiceContext(serviceContext);
   }

   /**
    * Get the Remote interface via a user-specified naming key.
    *
    * @param name The naming key for the remote interface
    * @return the remote interface reference
    * @throws net.sf.extrmi.naming.RMINamingException
    *         if any error occurs (from server-side naming implementation)
    */

   public Remote remoteLookup(String name) throws RMINamingException {

      // no caching - only a single Remote here
      DemoServerInterface serverStubProxy = (DemoServerInterface)
         RMIReplicationManager.getInstance().newInterceptor(demoServerObj, name);

      if (name.equals("ReplicateDemoServerObject")) {
         return serverStubProxy;
      } else {
         throw new RMINamingException("Name not found", null);
      }
   }

   /**
    * The return value is always a stub.
    *
    * @param name The key
    * @return the reference to the RMI stub of the lcoal RMI server object, return null if not found
    */

   public Remote stubLookup(String name) {

      if (name.equals("ReplicateDemoServerObject")) {
         try {
            return (Remote) UnicastRemoteObject.toStub(demoServerObj);  // **** preserve the stub semantics
         }
         catch (NoSuchObjectException ex) {
            ex.printStackTrace();
         }
      }

      return null;
   }

   /**
    * The return value is never a stub.
    *
    * @param name The key
    * @return the reference to the local RMI server object, return null if not found
    */

   public Remote serverObjectLookup(String name) {

      if (name.equals("ReplicateDemoServerObject")) {
         return demoServerObj;
      }

      return null;
   }

   /**
    * Get the Remote interface via a user-specified naming key.
    *
    * @param name The naming key for the remote interface
    * @return the remote interface reference
    * @throws net.sf.extrmi.naming.RMINamingException
    *                                  if any error occurs (from server-side naming implementation)
    * @throws java.rmi.RemoteException
    */

   public Remote remoteLookup(String name) throws RMINamingException, RemoteException {

      if (name.equals("JRMPDemoServer")) {
         return serverStubProxy;
      } else {
         throw new RMINamingException("Name not found", null);
      }
   }

   /**
    * Get the Remote interface via a user-specified naming key.
    *
    * @param name The naming key for the remote interface
    * @return the remote interface reference
    * @throws net.sf.extrmi.naming.RMINamingException
    *          if any error occurs. The implementation of this interface is
    *          required to convert any underlying exception to this generic exception type
    */

   public Remote lookup(String name) throws RMINamingException {

      Remote remote;
      try {
         remote = Naming.lookup(name);
      } catch (Exception ex) {
         throw new RMINamingException("JRMP naming lookup error", ex);  // a simple conversion
      }

      return remote;
   }

   /**
    * Returns the the cause of this exception (the <code>Throwable</code>
    * instance wrapped in this <code>RMINamingException</code>,
    * which may be <tt>null</tt>).
    *
    * @return the cause of this exception
    */

   public Throwable getCause() {
      return causeException;
   }

   /**
    * Get the underlying RMINamingManager instance.
    *
    * @return The user provided naming function encapsulation
    */

   public RMINamingInterface getNamingInterfaceDelegate() {

      return this.delegate;
   }

   /**
    * Check if the current context is of a Context id.
    *
    * @param id The context id
    * @return true if the current context is of this context id
    */

   public boolean isContextId(int id) {

      if (contextId == id) {
         return true;
      } else {
         return false;
      }
   }

   /**
    * Get the xid as int value.
    *
    * @return xid
    */

   public int xid() {

      return xid;
   }

   /**
    * Get the context id.
    *
    * @return context id
    */

   public int getContextId() {

      return contextId;
   }

   /**
    * Get the context data.
    *
    * @return context data. It can be null.
    * @see #setContextData
    */

   public Object getContextData() {

      return contextData;
   }

   /**
    * Re-iterate what's in base class.
    *
    * @return null
    */

   protected Object initialValue() {

      return null;
   }

   /**
    * To Object Id.
    *
    * @return String
    */

   public String toObjectId() {

      return "ServiceContext: <" + Integer.toString(contextId) + "> " + super.toString();
   }

   /**
    * the template method.
    */

   protected void preDispatch() throws ChannelException {

   }

   /**
    * The template method.
    */

   protected void processSetStateEvent(SetStateEvent event) {
   }

   /**
    * The template method.
    */

   protected void processGetStateEvent(GetStateEvent event) {
   }

   /**
    * Start the dispatch thread.
    */

   private void startDispatchThread() {
      dispatchThread = 
         new MessageDispatchThread("RMI Multicast Dispatch Thread: " + groupName);
      dispatchThread.setDaemon(true);
      dispatchThread.start();
   }

   /**
    * Inovked from state sync timer.
    */

   protected void stateSync() {

      Address coordinator = (Address) channel.getView().getMembers().get(0);

      if (channel.getLocalAddress().equals(coordinator)) {   // double validation
         try {
            if (log.isTraceEnabled()) log.trace("sending state sync");

            ServerObjectStates stateMap = getServerStates();

            synchronized (requestIdLock) {
               stateMap.setRequestId(requestId);
            }

            channel.send(null, null, stateMap);  // as a normal message
         }
         catch (Exception ex) {
            if (log.isErrorEnabled())  log.error("stateSync failed", ex);
         }
      }
   }

   /**
    * Override to invoke the call-back.
    */

   public void viewAccepted(View new_view) {

      super.viewAccepted(new_view);

      if (grpCoordinatorListener != null) {     // re-entry is not a concern here
         if (channel.getLocalAddress().equals(new_view.getMembers().get(0))) {
            grpCoordinatorListener.becomeGroupCoordinator();
         }
      }
   }

   /**
      Called by JGroups to notify the target object of a change of membership.
   */

   public void viewAccepted(View new_view) {

      if (log.isDebugEnabled())  log.debug("** View=" + new_view + " (size=" + new_view.size() + ")");

      if (vsync) {
         synchronized (outboundMsgQueueLock) {
            if (outboundMsgQueue != null) {
               Serializable msg;
               for (Iterator i = outboundMsgQueue.iterator(); i.hasNext(); ) {
                  try {
                     msg = (Serializable) i.next();
                     if (msg instanceof Message)
                        channel.send((Message) msg);   //  maybe a unicast
                     else
                        channel.send(null, null, msg);

                     if (log.isTraceEnabled()) log.trace("send queue msg");
                  }
                  catch (ChannelException ex) {
                     if (log.isErrorEnabled())  log.error("exception", ex);
                  }
               }
               outboundMsgQueue = null;  // reset
            }
         }
      }
   }

   /**
    * Get the server states.
    */

   protected ServerObjectStates getServerStates() throws Exception {

      ServerObjectStates stateMap = new ServerObjectStates();

      String[] servers = localNaming.serverObjects();
      String name;
      Remote server;
      byte[] serverState;

      // non atomic for server object state fetching !?? (FIFO + server determinism)
      for (int i = 0; i < servers.length; i ++) {
         name = servers[i];
         server = localNaming.serverObjectLookup(name);
         if (server != null) {   // do whatever available
            if (server instanceof Checkpointable) {
               serverState = ((Checkpointable) server).getState();
               stateMap.setServerObjectState(name, serverState);
            }
         }
      }

      return stateMap;
   }

   /** Called when a member is suspected */

   public void suspect(Address suspected_mbr) {

   }

   /**
    * Set the server states.
    */

   protected void setServerStates(ServerObjectStates stateMap) throws Exception {

      String[] servers = stateMap.serverObjectNames();
      String name;
      Remote server;
      byte[] serverState;
      for (int i = 0; i < servers.length; i ++) {
         name = servers[i];
         serverState = stateMap.getServerObjectState(name);
         if (serverState != null) {   // do whatever available
            server = localNaming.serverObjectLookup(name);
            if (server != null) {
               if (server instanceof Checkpointable) {
                  ((Checkpointable) server).setState(serverState);
               }
            }
         }
      }
   }

   /** Block sending and receiving of messages until viewAccepted() is called */

   public void block() {
      if (vsync) {
         if (log.isDebugEnabled())  log.debug("** VSYNC block ...");

         synchronized (outboundMsgQueueLock) {

            outboundMsgQueue = new ArrayList();  // also server as a flag

            // jgroups: this will eat unicast too !!
            channel.blockOk();
         }
      }
   }

   /**
    * The in-bound service-contexts. It saves the contexts to Current.
    *
    * @param requestInfo
    */

   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {
      if (log.isTraceEnabled()) log.trace("receiveRequestServiceContexts: " + requestInfo);

   }

   /**
    * The in-bound request. <p>
    *
    * It shall execute in the same thread as the target invocation.
    *
    * @param requestInfo
    */

   public void receiveRequest(ServerRequestInfo requestInfo) {
      if (log.isTraceEnabled()) log.trace("receiveRequest: " + requestInfo);

   }

   /**
    * The out-bound reply. <p>
    *
    * It allows an interceptor to query reply information and modify the
    * reply service context after the target operation has been invoked and before the
    * reply is returned to the client. It shall execute in the same thread as the
    * target invocation.
    *
    * @param requestInfo
    */

   public void sendReply(ServerRequestInfo requestInfo) {
      if (log.isTraceEnabled()) log.trace("sendReply: " + requestInfo);

   }

   /**
    * The out-bound exception.
    *
    * @param requestInfo
    */

   public void sendException(ServerRequestInfo requestInfo) {
      if (log.isTraceEnabled()) log.trace("sendException: " + requestInfo);

   }

   /**
    * The last request Id when this state is generated.
    * @param requestId
    */

   public void setRequestId(FTRequestServiceContext requestId) {
      this.requestId = requestId;
   }

      /**
       * Assign a new id. It is simply a counter.
       *
       * @return a new id
       */

      private long assignId() {

         int id = nextId++;

         if (nextId == Integer.MAX_VALUE) {   // wrap around

            nextId = 1;
         }

         return id;
      }

   /**
    * The template method.
    */

   protected void processMsg(Message msg) throws Throwable {

      synchronized (syncedLock) {
         if (! stateSynced) {
            if (log.isDebugEnabled())  log.debug("ignore message, wait for join state sync");
            return;
         }
      }

      super.processMsg(msg);
   }

   /**
    * The template method.
    */

   protected void processGetStateEvent(GetStateEvent event) {

      Address coordinator = (Address) channel.getView().getMembers().get(0);

      if ( channel.getLocalAddress().equals(coordinator)) {

         try {
            ServerObjectStates stateMap = getServerStates();

            channel.returnState(Util.objectToByteBuffer(stateMap));

            if (log.isDebugEnabled())  log.debug("sent state sync");
         }
         catch (Exception ex) {    // let the new member hang
            if (log.isErrorEnabled())  log.error("GetStateEvent failed", ex);
         }
      }
      else {
         if (log.isDebugEnabled())  log.debug("ignore unexpected GetStateEvent: " + event);
      }
   }

   /**
    * The in-bound reply. It allows the interceptor the query the reply information before
    * control is returned to client.
    *
    * @param requestInfo
    */

   public void receiveReply(ClientRequestInfo requestInfo) {

      // ignore
   }

   /**
    * In case viewAccepted too late.
    */

   protected void preDispatch() throws ChannelException {
      channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);
   }

   /**
    * The in-bound exception.
    *
    * @param requestInfo
    */

   public void receiveException(ClientRequestInfo requestInfo) {

      // ignore
   }

   /**
    * The in-bound reply. It allows the interceptor the query the reply information before
    * control is returned to client.
    *
    * @param requestInfo
    */

   public void receiveReply(ClientRequestInfo requestInfo) {
      return;
   }

   /**
    * The in-bound exception.
    *
    * @param requestInfo
    */

   public void receiveException(ClientRequestInfo requestInfo) {
      return;
   }

   /**
    * The in-bound reply. It allows the interceptor the query the reply information before
    * control is returned to client.
    *
    * @param requestInfo
    */

   public void receiveReply(ClientRequestInfo requestInfo) {
      trace("client: receiveReply: " + requestInfo.toString());
   }

   /**
    * The in-bound exception.
    *
    * @param requestInfo
    */

   public void receiveException(ClientRequestInfo requestInfo) {
      trace("client: receiveException: " + requestInfo.toString());
   }

   /**
    * The in-bound service-contexts. It saves the contexts to Current.
    * Only transaction-context is relevant here.
    *
    * @param requestInfo
    */

   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {
      ServiceContext[] contexts = requestInfo.operationContexts();
      ServiceContext cxt;
      if (contexts != null) {
         for (int i = 0; i < contexts.length; i ++) {
            cxt = contexts[i];
            if (cxt.isContextId(ServiceContext.TRANSACTION_CONTEXT_ID)) {
               Current.setServiceContext(cxt);
            }
         }
      }
   }

   /**
    * The in-bound service-contexts. It saves the contexts to Current.
    * Only transaction-context is relevant here.
    *
    * @param requestInfo
    */

   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {
      trace("server: receiveRequestServiceContexts: " + requestInfo.toString());
   }

   /**
    * The in-bound request. <p>
    *
    * It shall execute in the same thread as the target invocation.
    *
    * @param requestInfo
    */

   public void receiveRequest(ServerRequestInfo requestInfo) {
      return;
   }

   /**
    * The in-bound request. <p>
    *
    * It shall execute in the same thread as the target invocation.
    *
    * @param requestInfo
    */

   public void receiveRequest(ServerRequestInfo requestInfo) {
      trace("server: receiveRequest: " + requestInfo.toString());
   }

   /**
    * The out-bound reply. <p>
    *
    * It allows an interceptor to query reply information and modify the
    * reply service context after the target operation has been invoked and before the
    * reply is returned to the client. It shall execute in the same thread as the
    * target invocation.
    *
    * @param requestInfo
    */

   public void sendReply(ServerRequestInfo requestInfo) {
      return;
   }

   /**
    * The out-bound reply. <p>
    *
    * It allows an interceptor to query reply information and modify the
    * reply service context after the target operation has been invoked and before the
    * reply is returned to the client. It shall execute in the same thread as the
    * target invocation.
    *
    * @param requestInfo
    */

   public void sendReply(ServerRequestInfo requestInfo) {
      trace("server: sendReply: " + requestInfo.toString());
   }

   /**
    * The out-bound exception.
    *
    * @param requestInfo
    */

   public void sendException(ServerRequestInfo requestInfo) {
      return;
   }

   /**
    * The out-bound exception.
    *
    * @param requestInfo
    */

   public void sendException(ServerRequestInfo requestInfo) {
      trace("server: sendException: " + requestInfo.toString());
   }

   /**
    * The object implements the writeExternal method to save its contents
    * by calling the methods of DataOutput for its primitive values or
    * calling the writeObject method of ObjectOutput for objects, strings,
    * and arrays.
    *
    * @serialData Overriding methods should use this tag to describe
    *             the data layout of this Externalizable object.
    *             List the sequence of element types and, if possible,
    *             relate the element to a public/protected field and/or
    *             method of this Externalizable class.
    *
    * @param out the stream to write the object to
    * @exception java.io.IOException Includes any I/O exceptions that may occur
    */

   public void writeExternal(ObjectOutput out) throws IOException {
      out.writeObject(remoteStub);

      out.writeObject(serverInterceptorRemote);

      // for now, we make this a copy. It helps runtime exception mgt
      // some optimization is possible
   }

   /**
    * The object implements the readExternal method to restore its
    * contents by calling the methods of DataInput for primitive
    * types and readObject for objects, strings and arrays.  The
    * readExternal method must read the values in the same sequence
    * and with the same types as were written by writeExternal.
    *
    * @param in the stream to read data from in order to restore the object
    * @exception IOException if I/O errors occur
    * @exception ClassNotFoundException If the class for an object being
    *              restored cannot be found.
    */

   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
      this.remoteStub = (Remote) in.readObject();
      this.serverInterceptorRemote = (ServerInterceptorRemoteInterface) in.readObject();
   }

   /**
    * This is an extention. It clears the service context from the context list if any match.
    *
    * @param contextId
    *
    * @return a copy of the service context with the given id that is associated with
    * the request. Return null otherwise.
    */

   public ServiceContext checkRequestServiceContext(int contextId) {

      ServiceContext result = null;

      if (operationContexts != null) {

         int num = operationContexts.length;
         ServiceContext c;
         for (int i = 0; i < num; i ++ ) {
            c = operationContexts[i];
            if (c.contextId == contextId) {
               result = c;
               ServiceContext[] newContexts = new ServiceContext[num - 1];
               System.arraycopy(operationContexts, 0, newContexts, 0, i);
               if (i < num -1)
                  System.arraycopy(operationContexts, i+1, newContexts, i , num-i-1);
               operationContexts = newContexts;
               break;        // no duplication checking
            }
         }
      }

      return result;
   }

   /**
    * Get the service context by contextId. The return value is a copy.
    *
    * @param contextId
    *
    * @return the service context if found, or null otherwise
    */

   protected ServiceContext getServiceContext(int contextId) {

      return ContextUtil.getServiceContext(operationContexts, contextId);
   }

   /**
    * Add/replace the service context.
    *
    * @param serviceContext
    */

   protected void addServiceContext(ServiceContext serviceContext) {

      operationContexts = ContextUtil.addServiceContext(operationContexts, serviceContext);
   }

   /**
    * Remove a client-side request interceptor.
    *
    * For maintenance purpose only.
    *
    * @param name The interceptor name
    */

   public void removeClientRequestInterceptor(String name) {

      synchronized (clientInterceptorList) {
         clientInterceptorList.remove(name);
      }
   }

   /**
    * The object implements the writeExternal method to save its contents
    * by calling the methods of DataOutput for its primitive values or
    * calling the writeObject method of ObjectOutput for objects, strings,
    * and arrays.
    *
    * @serialData Overriding methods should use this tag to describe
    *             the data layout of this Externalizable object.
    *             List the sequence of element types and, if possible,
    *             relate the element to a public/protected field and/or
    *             method of this Externalizable class.
    *
    * @param out the stream to write the object to
    * @exception java.io.IOException Includes any I/O exceptions that may occur
    */

   public void writeExternal(ObjectOutput out) throws IOException {
      super.writeExternal(out);
      out.writeObject(remoteKey);
      out.writeObject(props);
   }

   /**
    * Get a client-side request interceptor by name.
    *
    * @param name The interceptor name
    *
    * @return the interceptor if any
    */

   public ClientRMIInterceptor getClientRequestInterceptor(String name) {

      synchronized (clientInterceptorList) {
         return (ClientRMIInterceptor) clientInterceptorList.get(name);
      }
   }

   /**
    * The object implements the readExternal method to restore its
    * contents by calling the methods of DataInput for primitive
    * types and readObject for objects, strings and arrays.  The
    * readExternal method must read the values in the same sequence
    * and with the same types as were written by writeExternal.
    *
    * @param in the stream to read data from in order to restore the object
    * @exception IOException if I/O errors occur
    * @exception ClassNotFoundException If the class for an object being
    *              restored cannot be found.
    */

   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
      super.readExternal(in);
      this.remoteKey = (String) in.readObject();
      this.props = (Properties) in.readObject();
   }

   /**
    * Get the property.
    */

   public String getPropert(String name) {
      return props.getProperty(name);
   }

   /**
    * Set the property.
    */

   public void setPropert(String name, String value) {
      props.setProperty(name, value);
   }

   /**
    * Remove a server-side request interceptor.
    *
    * For maintenance purpose only.
    *
    * @param name The interceptor name
    */

   public void removeServerRequestInterceptor(String name) {

      synchronized (serverInterceptorList) {
         serverInterceptorList.remove(name);
      }
   }

   /**
    * Get the target Remote reference naming key.
    */

   public String getRemoteKey() {
      return remoteKey;
   }

   /**
    * Get a server-side request interceptor by name.
    *
    * @param name The interceptor name
    *
    * @return the interceptor if any
    */

   public ServerRMIInterceptor getServerRequestInterceptor(String name) {

      synchronized (serverInterceptorList) {
         return (ServerRMIInterceptor) serverInterceptorList.get(name);
      }
   }

   /**
    * Add a client-side message interceptor. Only one is supported, and existing one
    * will be overwritten.
    *
    * No overwritting checking here.
    *
    * @param interceptor
    */

   public void addClientMessageInterceptor(ClientRMIMessageInterceptor interceptor) {

      synchronized (this) {
         clientMsgInterceptor = interceptor;
      }
   }

   /**
    * Process a reflection exception.
    *
    * @throws InvocationTargetException a wrapped exception
    */

   private void processExecReflectionException(Exception ex) throws InvocationTargetException {

      // the cause exception has to be a runtime exception
      throw new InvocationTargetException(new IllegalArgumentException("Interceptor Service.exec() failed: " + ex));
   }

   /**
    * Remove the client-side message interceptor, if any.
    *
    * For maintenance purpose only.
    *
    * @param name The interceptor name, and optional for now (pass null)
    */

   public void removeClientMessageInterceptor(String name) {

      synchronized (this) {
         clientMsgInterceptor = null;
      }
   }

   /**
    * Get a client-side message interceptor by name.
    *
    * @param name The interceptor name, optionl for now
    *
    * @return the interceptor if any
    */

   public ClientRMIMessageInterceptor getClientMessageInterceptor(String name) {

      synchronized (this) {
         return this.clientMsgInterceptor;
      }
   }

   /**
    * Get the registered client-side message interceptor.
    *
    * @return the registered interceptors
    */

   public ClientRMIMessageInterceptor getClientMessageInterceptor() {

      synchronized (this) {
         return this.clientMsgInterceptor;
      }
   }

   /**
    * Add a server-side message interceptor. Only one is supported, and existing one
    * will be overwritten.
    *
    * No overwritting checking here.
    *
    * @param interceptor
    */

   public void addServerMessageInterceptor(ServerRMIMessageInterceptor interceptor) {

      synchronized (this) {
         serverMsgInterceptor = interceptor;
      }
   }

   /**
    * Remove the server-side message interceptor, if any.
    *
    * For maintenance purpose only.
    *
    * @param name The interceptor name, and optional for now (pass null)
    */

   public void removeServerMessageInterceptor(String name) {

      synchronized (this) {
         serverMsgInterceptor = null;
      }
   }

   /**
    * Get a server-side message interceptor by name.
    *
    * @param name The interceptor name, optionl for now
    *
    * @return the interceptor if any
    */

   public ServerRMIMessageInterceptor getServerMessageInterceptor(String name) {

      synchronized (this) {
         return this.serverMsgInterceptor;
      }
   }

   /**
    * Get the registered server-side message interceptor.
    *
    * @return the registered interceptors
    */

   public ServerRMIMessageInterceptor getServerMessageInterceptor() {

      synchronized (this) {
         return this.serverMsgInterceptor;
      }
   }

   /**
    * Get the Remote interface via a user-specified naming key.
    *
    * @param name The naming key for the remote interface
    * @return the remote interface reference
    *
    * @throws net.sf.extrmi.naming.RMINamingException if any error occurs (from server-side naming implementation)
    * @throws java.rmi.RemoteException
    */

   public Remote lookup(String name) throws RMINamingException, RemoteException {

      if (name.equals("JRMPDemoServer")) {
         return serverStubProxy;
      }
      else {
         throw new RMINamingException("Name not found", null);
      }
   }

   /**
    * Check if the current context is of a service id.
    *
    * @param id The service id
    * @return true if the current context is of this service id
    */

   public boolean isServiceId(int id) {

      if (serviceId == id) {
         return true;
      } else {
         return false;
      }
   }

   /**
    * Get the service id.
    *
    * @return service id
    */

   public int getServiceId() {

      return serviceId;
   }

   /**
    * To Object Id.
    *
    * @return String
    */

   public String toObjectId() {

      return "ServiceContext: <" + Integer.toString(serviceId) + "> " + super.toString();
   }

   /**
    * The template method.
    */

   protected void processMsg(Message msg) throws Throwable {

      Object msgObj;
      msgObj = msg.getObject();

      if (msgObj instanceof InvocationResponse) {

         synchronized (rspLock) {
            rsp = (InvocationResponse) msgObj;   // todo: concurrent access
            rspLock.notify();
         }
      }

      // possible issues ??
      if (msgObj != null)
         System.out.println("***  obj is " + msgObj.getClass() +
            ", hdrs are" + msg.printObjectHeaders());
      else
         System.out.println("***  hdrs are " + msg.printObjectHeaders());
   }

   /**
    * Send (async) the invocation via multicast and receive (sync) the response via unicast.
    */

   public InvocationResponse invoke(ClientRequestInfo requestInfo) throws ChannelException {

      channel.send(null, null, (Serializable) requestInfo);

      InvocationResponse result = null;

      synchronized (rspLock) {
         while (rsp == null) {
            try {
               rspLock.wait();
            }
            catch (InterruptedException ex) {
               // shadow any interrupt
               // rspLock.notify();
            }
         }
         result = rsp;
         rsp = null; // no further request-response correlation here - single-thread client ?!
      }

      return result;
   }

   /**
    * The in-bound exception.
    *
    * @param requestInfo
    */

   public void receiveException(ClientRequestInfo requestInfo) {

      // never invoked in this case
   }

   /**
    * The out-bound request.
    *
    * <pre>
    * Possible functions:
    * - modify service context.
    * </pre>
    *
    * @param requestInfo
    */

   public void sendRequest(ClientRequestInfo requestInfo) {
      trace("client: sendRequest: " + requestInfo.toString());
   }

   /**
    * The in-bound service-contexts. It saves the contexts to Current.
    * Only transaction-context is relevant here.
    *
    * @param requestInfo
    */

   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {
      ServiceContext[] contexts = requestInfo.operationContexts();
      ServiceContext cxt;
      if (contexts != null) {
         for (int i = 0; i < contexts.length; i ++) {
            cxt = contexts[i];
            if (cxt.isServiceId(ServiceContext.TRANSACTION_CONTEXT_ID)) {
               Current.setServiceContext(cxt);
            }
         }
      }
   }

   /**
    * This is an extention. It clears the service context from the context list if any match.
    *
    * @param serviceId
    *
    * @return a copy of the service context with the given id that is associated with
    * the request. Return null otherwise.
    */

   public ServiceContext checkRequestServiceContext(int serviceId) {

      ServiceContext result = null;

      if (operationContexts != null) {

         int num = operationContexts.length;
         ServiceContext c;
         for (int i = 0; i < num; i ++ ) {
            c = operationContexts[i];
            if (c.serviceId == serviceId) {
               result = c;
               ServiceContext[] newContexts = new ServiceContext[num - 1];
               System.arraycopy(operationContexts, 0, newContexts, 0, i);
               if (i < num -1)
                  System.arraycopy(operationContexts, i+1, newContexts, i , num-i-1);
               operationContexts = newContexts;
               break;        // no duplication checking
            }
         }
      }

      return result;
   }

   /**
    * Get the service context by serviceId. The return value is a copy.
    *
    * @param serviceId
    *
    * @return the service context if found, or null otherwise
    */

   protected ServiceContext getServiceContext(int serviceId) {

      return ContextUtil.getServiceContext(operationContexts, serviceId);
   }

   /**
    * The object implements the writeExternal method to save its contents
    * by calling the methods of DataOutput for its primitive values or
    * calling the writeObject method of ObjectOutput for objects, strings,
    * and arrays.
    *
    * @serialData Overriding methods should use this tag to describe
    *             the data layout of this Externalizable object.
    *             List the sequence of element types and, if possible,
    *             relate the element to a public/protected field and/or
    *             method of this Externalizable class.
    *
    * @param out the stream to write the object to
    * @exception java.io.IOException Includes any I/O exceptions that may occur
    */

   public void writeExternal(ObjectOutput out) throws IOException {
      super.writeExternal(out);
      out.writeObject(props);
   }

   /**
    * The object implements the readExternal method to restore its
    * contents by calling the methods of DataInput for primitive
    * types and readObject for objects, strings and arrays.  The
    * readExternal method must read the values in the same sequence
    * and with the same types as were written by writeExternal.
    *
    * @param in the stream to read data from in order to restore the object
    * @exception IOException if I/O errors occur
    * @exception ClassNotFoundException If the class for an object being
    *              restored cannot be found.
    */

   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
      super.readExternal(in);
      this.props = (Properties) in.readObject();
   }

   /**
    * Get the service context by serviceId. The return value is a copy.
    *
    * @param serviceId
    *
    * @return the service context if found, or null otherwise
    */

   protected ServiceContext getServiceContext(int serviceId) {

      if (operationContexts == null) {
         return null;
      }
      else {
         ServiceContext c;
         for (int i = 0; i < operationContexts.length; i ++ ) {
            c = operationContexts[i];
            if (c.serviceId == serviceId) {
               return (ServiceContext) c.clone();
            }
         }
         return null; // otherwise
      }
   }

   /**
    * Remove a client-side request interceptor.
    *
    * For maintenance purpose only.
    *
    * @param name The interceptor name
    */

   public void removeClientRequestInterceptor(String name) {

      synchronized (interceptorList) {
         interceptorList.remove(name);
      }
   }

   /**
    * Add/replace the service context.
    *
    * @param serviceContext
    */

   protected void addServiceContext(ServiceContext serviceContext) {

      if (operationContexts != null) {

         int num = operationContexts.length;
         ServiceContext c;

         for (int i = 0; i < num; i ++ ) {
            c = operationContexts[i];
            if (c.serviceId == serviceContext.serviceId) {
               operationContexts[i] = serviceContext;
               return; // replace
            }
         }

         // append
         ServiceContext[] result = new ServiceContext[num + 1];
         System.arraycopy(operationContexts, 0, new ServiceContext[num + 1], 0, num);
         result[num] = serviceContext;  // last one
         operationContexts = result;
      }
      else {
         operationContexts = new ServiceContext[1];
         operationContexts[0] = serviceContext;
      }
   }

   /**
    * The out-bound request.
    *
    * <pre>
    * Possible functions:
    * - modify service context.
    * </pre>
    *
    * @param requestInfo
    */

   public void sendRequest(ClientRequestInfo requestInfo) {

      // update the clientRequestInfo
      requestInfo.addRequestServiceContext(Current.getServiceContext(ServiceContext.TRANSACTION_CONTEXT_ID));
   }

   /**
    * The in-bound service-contexts.
    *
    * @param requestInfo
    */

   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {
      return;
   }

   /**
    * The out-bound request.
    *
    * <pre>
    * Possible functions:
    * - modify service context.
    * </pre>
    *
    * @param requestInfo
    */

   public void sendRequest(ClientRequestInfo requestInfo) {
      // ignore
   }

   /**
      Called by JGroups to notify the target object of a change of membership.
   */

   public void viewAccepted(View new_view) {

      if (log.isDebugEnabled())  log.debug("** View=" + new_view + " (size=" + new_view.size() + ")");

      if (vsync) {
         synchronized (outboundMsgQueueLock) {
            if (outboundMsgQueue != null) {
               for (Iterator i = outboundMsgQueue.iterator(); i.hasNext(); ) {
                  try {
                     channel.send(null, null, (Serializable) i.next());
                  }
                  catch (ChannelException ex) {
                     if (log.isErrorEnabled())  log.error("exception", ex);
                  }
               }
               outboundMsgQueue = null;  // reset
            }
         }
      }
   }

   /** Block sending and receiving of messages until viewAccepted() is called */

   public void block() {
      if (vsync) {
         if (log.isDebugEnabled())  log.debug("** VSYNC block ...");
         synchronized (outboundMsgQueueLock) {
            outboundMsgQueue = new ArrayList();  // also server as a flag
            channel.blockOk();   // jgroups: this will eat unicast too !!
         }
      }
   }

   /**
    * Invoked from processMessage.
    */

   protected void processStateSync(ServerObjectStateMap stateMap) {
      try {
         setServerStates(stateMap);

         synchronized(msgBuffer) {
            msgBuffer.clear();   // no partial state-sync
         }
      }
      catch (Exception ex) {     // keep the buffer
         if (log.isErrorEnabled())  log.error("SetStateEvent failed", ex);
      }
   }

   /**
    * Inovked from state sync timer.
    */

   protected void stateSync() {

      Address coordinator = (Address) channel.getView().getMembers().get(0);

      if (channel.getLocalAddress().equals(coordinator)) {   // double validation
         try {
            if (log.isTraceEnabled()) log.trace("sending state sync");
            ServerObjectStateMap stateMap = getServerStates();
            channel.send(null, null, stateMap);  // as a normal message
         }
         catch (Exception ex) {
            if (log.isErrorEnabled())  log.error("stateSync failed", ex);
         }
      }
   }

   /**
    * Get the server states.
    */

   protected ServerObjectStateMap getServerStates() throws Exception {

      ServerObjectStateMap stateMap = new ServerObjectStateMap();

      String[] servers = localNaming.serverObjects();
      String name;
      Remote server;
      byte[] serverState;

      // non atomic for server object state fetching !?? (FIFO + server determinism)
      for (int i = 0; i < servers.length; i ++) {
         name = servers[i];
         server = localNaming.serverObjectLookup(name);
         if (server != null) {   // do whatever available
            if (server instanceof Checkpointable) {
               serverState = ((Checkpointable) server).getState();
               stateMap.setServerObjectState(name, serverState);
            }
         }
      }

      return stateMap;
   }

   /**
    * Set the server states.
    */

   protected void setServerStates(ServerObjectStateMap stateMap) throws Exception {

      String[] servers = stateMap.serverObjectNames();
      String name;
      Remote server;
      byte[] serverState;
      for (int i = 0; i < servers.length; i ++) {
         name = servers[i];
         serverState = stateMap.getServerObjectState(name);
         if (serverState != null) {   // do whatever available
            server = localNaming.serverObjectLookup(name);
            if (server != null) {
               if (server instanceof Checkpointable) {
                  ((Checkpointable) server).setState(serverState);
               }
            }
         }
      }
   }

   /**
    * The template method.
    */

   protected void processGetStateEvent(GetStateEvent event) {

      Address coordinator = (Address) channel.getView().getMembers().get(0);

      if ( channel.getLocalAddress().equals(coordinator)) {

         try {
            ServerObjectStateMap stateMap = getServerStates();

            channel.returnState(Util.objectToByteBuffer(stateMap));
         }
         catch (Exception ex) {    // let the new member hang
            if (log.isErrorEnabled())  log.error("GetStateEvent failed", ex);
         }
      }
      else {
         if (log.isDebugEnabled())  log.debug("unexpected GetStateEvent: " + event);
      }
   }

   /**
    * The object implements the writeExternal method to save its contents
    * by calling the methods of DataOutput for its primitive values or
    * calling the writeObject method of ObjectOutput for objects, strings,
    * and arrays.
    *
    * @serialData Overriding methods should use this tag to describe
    *             the data layout of this Externalizable object.
    *             List the sequence of element types and, if possible,
    *             relate the element to a public/protected field and/or
    *             method of this Externalizable class.
    *
    * @param out the stream to write the object to
    * @exception java.io.IOException Includes any I/O exceptions that may occur
    */

   public void writeExternal(ObjectOutput out) throws IOException {
      out.writeObject(serviceStub);

      out.writeObject(interceptorRemote);
      // for now, we make this a copy. It helps runtime exception mgt
      // some optimization is possible
   }

   /**
    * The object implements the readExternal method to restore its
    * contents by calling the methods of DataInput for primitive
    * types and readObject for objects, strings and arrays.  The
    * readExternal method must read the values in the same sequence
    * and with the same types as were written by writeExternal.
    *
    * @param in the stream to read data from in order to restore the object
    * @exception IOException if I/O errors occur
    * @exception ClassNotFoundException If the class for an object being
    *              restored cannot be found.
    */

   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
      this.serviceStub = (Remote) in.readObject();
      this.interceptorRemote = (ServerInterceptorRemoteInterface) in.readObject();
   }

   /**
    * The object implements the writeExternal method to save its contents
    * by calling the methods of DataOutput for its primitive values or
    * calling the writeObject method of ObjectOutput for objects, strings,
    * and arrays.
    *
    * @serialData Overriding methods should use this tag to describe
    *             the data layout of this Externalizable object.
    *             List the sequence of element types and, if possible,
    *             relate the element to a public/protected field and/or
    *             method of this Externalizable class.
    *
    * @param out the stream to write the object to
    * @exception java.io.IOException Includes any I/O exceptions that may occur
    */

   public void writeExternal(ObjectOutput out) throws IOException {
      super.writeExternal(out);
   }

   /**
    * The object implements the readExternal method to restore its
    * contents by calling the methods of DataInput for primitive
    * types and readObject for objects, strings and arrays.  The
    * readExternal method must read the values in the same sequence
    * and with the same types as were written by writeExternal.
    *
    * @param in the stream to read data from in order to restore the object
    * @exception IOException if I/O errors occur
    * @exception ClassNotFoundException If the class for an object being
    *              restored cannot be found.
    */

   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
      super.readExternal(in);
   }

   /**
    * Get the Remote interface via a user-specified naming key.
    *
    * @param name The naming key for the remote interface
    * @return the remote interface reference
    * @throws net.sf.extrmi.naming.RMINamingException
    *         if any error occurs (from server-side naming implementation)
    */

   public Remote remoteLookup(String name) throws RMINamingException {
      return remoteLookup(name, null);
   }

   /**
    * Get the Remote interface via a user-specified naming key.
    *
    * @param name The naming key for the remote interface
    * @return the remote interface reference
    * @throws net.sf.extrmi.naming.RMINamingException
    *         if any error occurs (from server-side naming implementation)
    */

   public Remote remoteLookup(String name) throws RMINamingException {

      // no caching - only a single Remote here
      DemoServerInterface serverStubProxy = (DemoServerInterface)
         RMIReplicationManager.getInstance().newInterceptor(demoServerObj, name);  // not really a remoteStub here - same effect

      if (name.equals("ReplicateDemoServerObject")) {
         return serverStubProxy;
      } else {
         throw new RMINamingException("Name not found", null);
      }
   }

   /**
    * The object group id this RMI server 0bject is associated with. This is
    * considered an application concern in this framework.
    *
    * @param name The key of the server object
    *
    * @return its associated object group id, null if not specified
    */

   public String objectGroupId(String name) {
      return null;  // default
   }

   /**
    * A new coordinator is installed - indicating a Home naming change.
    */

   public void comesNewGroupCoordinator() {
      
   }

   /**
    * A new coordinator is installed - indicating a Home naming change.
    */

   public void comesNewGroupCoordinator() {

      try {
         OpenGroupManagerRemoteInterface coordinatorOpenGrpMgr =
            (OpenGroupManagerRemoteInterface) Naming.lookup("//" + namingHost + "/OpenGroupManager");

         OpenGroupManager.getInstance().registerWithCoordinator(coordinatorOpenGrpMgr, serverId, openGrpMgrStub);
      }
      catch (Exception e) {
         System.out.println("Register OpenGroupMgr proxy with coordinator err: " + e.getMessage());
         e.printStackTrace();
      }

      // todo: add re-try
   }

    /**
     * Method getNextException
     *
     *
     * @return
     *
     */

    public Exception getNextException() {
        return nextException;
    }

    /**
     * Method setLogTarget
     *
     *
     * @param target The the new log destination to be used.
     *
     */

    public void setLogTarget(PrintStream target) {
        logTarget = target;
    }

    /**
     * Method getLogTarget
     *
     *
     * @return The PrintStream used as the current log target
     *
     */

    public PrintStream getLogTarget() {
        return logTarget;
    }

    /**
     * Method printStackTrace
     *
     *
     * @param e
     *
     */

    public void printStackTrace(Throwable e) {

        // Yes, we print the stack trace for an originating
        // exception, but nothing else.
        // If e is not a remote exception
        // or if e.detail is null
        // or if e.detail is not an EJBException
        // Print the stack
        // Otherwise the stack has already been printed, don't print.
        if (!(e instanceof RemoteException)
                || ((RemoteException) e).detail == null) {
//                ||!(((RemoteException) e).detail instanceof EJBException)) {
            e.printStackTrace(logTarget);
        }
    }

    /**
     * Method printStackTrace
     *
     *
     * @param e
     *
     */

    public void printStackTrace(Throwable e) {

        if (debugLevel > 3) {
            e.printStackTrace(logTarget);
        } else {
            super.printStackTrace(e);
        }
    }

   /**
    * Get the local naming interface.
    */

   public ServerObjectNamingInterface getLocalServerObjectNaming() {
      return this.localNaming;
   }

   /**
    * Check the object group, if already discovered.
    *
    * @param grpId
    */

   public boolean checkObjectGroup(String grpId) {
      if (grpId == null) {
         return true;   // default
      }

      synchronized (queueMap) {
         return queueMap.containsKey(grpId);
      }
   }

   /**
    * Check the object group queue.
    *
    * @param grpId
    * @return an existing one or a new one
    */

   public Queue checkObjectGroupQueue(String grpId) {
      if (grpId == null) {
         return DEFAULT_QUEUE;
      }

      synchronized (queueMap) {
         if (queueMap.containsKey(grpId)) {
            return (Queue) queueMap.get(grpId);
         }
         else {
            Queue q = new Queue();
            queueMap.put(grpId, q);
            return q;
         }
      }
   }

   /**
    * Clear the object group queue.
    *
    * @param grpId
    * @return true if queue is actually empty
    */

   public boolean clearObjectGroupQueue(String grpId) {
      if (grpId == null) {
         return false;   // ignore
      }

      synchronized (queueMap) {
         if (queueMap.containsKey(grpId)) {
            Queue q = (Queue) queueMap.get(grpId);
            //q.purge();             // triggered from delivery thread now
            if (q.isEmpty()) {
               queueMap.remove(grpId);
               return true;
            }
            else {
               return false;   // let the delivery thread run
            }
         }
         else {
            return false;   //ignore
         }
      }
   }

   /**
    * Override to invoke the call-back.
    */

   public void viewAccepted(View new_view) {

      super.viewAccepted(new_view);

      if (grpCoordinatorListener != null) {     // re-entry is not a concern here
         if (channel.getLocalAddress().equals(new_view.getMembers().get(0))) {
            grpCoordinatorListener.becomesGroupCoordinator();
         }
         else {
            // todo: only fire when there's actually a coordinator change - same above !!
            grpCoordinatorListener.comesNewGroupCoordinator();
         }
      }
   }

   /**
    * Set the server states.
    */

   protected void setServerStates(ServerObjectStates stateMap) throws Exception {

      String[] servers = stateMap.serverObjectNames();
      String name;
      Remote server;
      byte[] serverState;
      for (int i = 0; i < servers.length; i ++) {
         name = servers[i];
         serverState = stateMap.getServerObjectState(name);
         if (serverState != null) {   // do whatever available
            server = localNaming.serverObjectLookup(name);
            if (server != null) {     // equivalently a registration - no object-group for now
               if (server instanceof Checkpointable) {
                  ((Checkpointable) server).setState(serverState);
               }
            }
         }
      }
   }

      /**
       * Stop the thread in a safe manner.
       * <p/>
       * We don't interrupt the handler directly, which may be in application code.
       */

      public void quit() {
         stopped = true;       // todo: clean it up
      }

   /**
    * In case viewAccepted too late.
    */

   protected void preDispatch() throws ChannelException {
      // channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);  - deprecated since 2.3
   }

   /**
    * Upon each view/coordinator change, register all the local stubs with the coordinator.
    *
    * @param serverId The server Id
    * @param mgrProxyStub The mgr proxy stub
    *
    * @throws RemoteException
    */

   public void registerProxyStub(String serverId, Remote mgrProxyStub) throws RemoteException {

      stubMap.put(serverId, mgrProxyStub);
   }

		/**
		* Slightly different symantics than normal read just for convenience.  This
		* is guaranteed to read _buffer.length many bytes from the stream (as opposed
		* to reading "up to" _buffer.length many bytes from the stream.
		*/

	public int read(byte[] _buffer) throws IOException {
		int pos = 0;
		while (pos < _buffer.length) {
			pos += read(_buffer, pos, _buffer.length - pos);
		}
		return pos;
	}

	/**
	 * Copies the components of this vector into the specified array. The 
	 * item at index <tt>k</tt> in this vector is copied into component 
	 * <tt>k</tt> of <tt>anArray</tt>. The array must be big enough to hold 
	 * all the objects in this vector, else an 
	 * <tt>IndexOutOfBoundsException</tt> is thrown.
	 *
	 * @param   anArray   the array into which the components get copied.
	 * @throws  NullPointerException if the given array is null.
	 */

	public void copyInto(double[] anArray) {
		System.arraycopy(elementData, 0, anArray, 0, elementCount);
	}

	/**
	 * Trims the capacity of this vector to be the vector's current 
	 * size. If the capacity of this vector is larger than its current 
	 * size, then the capacity is changed to equal the size by replacing 
	 * its internal data array, kept in the field <tt>elementData</tt>, 
	 * with a smaller one. An application can use this operation to 
	 * minimize the storage of a vector. 
	 */

	public void trimToSize() {
		int oldCapacity = elementData.length;
		if (elementCount < oldCapacity) {
			double[] oldData = elementData;
			elementData = new double[elementCount];
			System.arraycopy(oldData, 0, elementData, 0, elementCount);
		}
	}

	/**
	 * Increases the capacity of this vector, if necessary, to ensure 
	 * that it can hold at least the number of components specified by 
	 * the minimum capacity argument.
	 *
	 * <p>If the current capacity of this vector is less than
	 * <tt>minCapacity</tt>, then its capacity is increased by replacing its
	 * internal data array, kept in the field <tt>elementData</tt>, with a
	 * larger one.  The size of the new data array will be the old size plus
	 * <tt>capacityIncrement</tt>, unless the value of
	 * <tt>capacityIncrement</tt> is less than or equal to zero, in which case
	 * the new capacity will be twice the old capacity; but if this new size
	 * is still smaller than <tt>minCapacity</tt>, then the new capacity will
	 * be <tt>minCapacity</tt>.
	 *
	 * @param minCapacity the desired minimum capacity.
	 */

	public void ensureCapacity(int minCapacity) {
		ensureCapacityHelper(minCapacity);
	}

	/** Determines the ordering of objects in this priority queue.  Subclasses
	  must define this one method. */

	protected boolean lessThan(float a, float b) {
		return a < b;
	}

	/**
	 * This implements the unsynchronized semantics of ensureCapacity.
	 * Synchronized methods in this class can internally call this 
	 * method for ensuring capacity without incurring the cost of an 
	 * extra synchronization.
	 *
	 * @see java.util.Vector#ensureCapacity(int)
	 */

	private void ensureCapacityHelper(int minCapacity) {
		int oldCapacity = elementData.length;
		if (minCapacity > oldCapacity) {
			double[] oldData = elementData;
			int newCapacity = (capacityIncrement > 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2);
			if (newCapacity < minCapacity) {
				newCapacity = minCapacity;
			}
			elementData = new double[newCapacity];
			System.arraycopy(oldData, 0, elementData, 0, elementCount);
		}
	}

	/**
	 * Converts the buffer's contents into a string, translating bytes into
	 * characters according to the platform's default character encoding.
	 *
	 * @return String translated from the buffer's contents.
	 * @since   JDK1.1
	 */

	public String toString() {
		return new String(buf, 0, count);
	}

	/**
	 * Sets the size of this vector. If the new size is greater than the 
	 * current size, new <code>null</code> items are added to the end of 
	 * the vector. If the new size is less than the current size, all 
	 * components at index <code>newSize</code> and greater are discarded.
	 *
	 * @param   newSize   the new size of this vector.
	 * @throws  ArrayIndexOutOfBoundsException if new size is negative.
	 */

	public void setSize(int newSize) {
		if (newSize > elementCount) {
			ensureCapacityHelper(newSize);
		}
		else {
			for (int i = newSize; i < elementCount; i++) {
				elementData[i] = 0;
			}
		}
		elementCount = newSize;
	}

	/**
	 * Converts the buffer's contents into a string, translating bytes into
	 * characters according to the specified character encoding.
	 *
	 * @param   enc  a character-encoding name.
	 * @return String translated from the buffer's contents.
	 * @throws UnsupportedEncodingException
	 *         If the named encoding is not supported.
	 * @since   JDK1.1
	 */

	public String toString(String enc) throws UnsupportedEncodingException {
		return new String(buf, 0, count, enc);
	}

	/**
	 * Creates a newly allocated string. Its size is the current size of
	 * the output stream and the valid contents of the buffer have been
	 * copied into it. Each character <i>c</i> in the resulting string is
	 * constructed from the corresponding element <i>b</i> in the byte
	 * array such that:
	 * <blockquote><pre>
	 *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
	 * </pre></blockquote>
	 *
	 * @deprecated This method does not properly convert bytes into characters.
	 * As of JDK&nbsp;1.1, the preferred way to do this is via the
	 * <code>toString(String enc)</code> method, which takes an encoding-name
	 * argument, or the <code>toString()</code> method, which uses the
	 * platform's default character encoding.
	 *
	 * @param      hibyte    the high byte of each resulting Unicode character.
	 * @return     the current contents of the output stream, as a string.
	 * @see        java.io.ByteArrayOutputStream#size()
	 * @see        java.io.ByteArrayOutputStream#toString(String)
	 * @see        java.io.ByteArrayOutputStream#toString()
	 */

	public String toString(int hibyte) {
		return new String(buf, hibyte, 0, count);
	}

	/**
	 * Returns the current capacity of this vector.
	 *
	 * @return  the current capacity (the length of its internal 
	 *          data array, kept in the field <tt>elementData</tt> 
	 *          of this vector).
	 */

	public int capacity() {
		return elementData.length;
	}

	/**
	 * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
	 * this class can be called after the stream has been closed without
	 * generating an <tt>IOException</tt>.
	 * <p>
	 *
	 */

	public void close() throws IOException {
	}

	/**
	 * Returns the number of components in this vector.
	 *
	 * @return  the number of components in this vector.
	 */

	public int size() {
		return elementCount;
	}

    /**
     * Sets the body object for this fragment. The body object contains the
     * actual information for the fragment.
     *
     * @param body the body object
     */

    public void setBody(AbstractMP3FragmentBody body) {
        this.body = body;
    }

    /**
     * Returns the body object for this fragment. The body object contains the
     * actual information for the fragment.
     *
     * @return the body object
     */

    public AbstractMP3FragmentBody getBody() {
        return this.body;
    }

    /**
     * Returns true if this object and its body equals the argument and its
     * body. this object is equal if and only if they are the same class and
     * have the same <code>getIdentifier</code> id string.
     *
     * @param obj object to determine equality of
     *
     * @return true if this object and its body equals the argument and its
     *         body.
     */

    public boolean equals(Object obj) {
        if ((obj instanceof AbstractMP3Fragment) == false) {
            return false;
        }

        AbstractMP3Fragment object = (AbstractMP3Fragment) obj;

        if (this.getIdentifier().equals(object.getIdentifier()) == false) {
            return false;
        }

        if (this.body.equals(object.body) == false) {
            return false;
        }

        return super.equals(obj);
    }

	/**
	 * Tests if this vector has no components.
	 *
	 * @return  <code>true</code> if and only if this vector has 
	 *          no components, that is, its size is zero;
	 *          <code>false</code> otherwise.
	 */

	public boolean isEmpty() {
		return elementCount == 0;
	}

	/**
	 * Tests if the specified object is a component in this vector.
	 *
	 * @param   elem   an object.
	 * @return  <code>true</code> if and only if the specified object 
	 * is the same as a component in this vector, as determined by the 
	 * <tt>equals</tt> method; <code>false</code> otherwise.
	 */

	public boolean contains(double elem) {
		return indexOf(elem, 0) >= 0;
	}

	/**
	 * Searches for the first occurence of the given argument, testing 
	 * for equality using the <code>equals</code> method. 
	 *
	 * @param   elem   an object.
	 * @return  the index of the first occurrence of the argument in this
	 *          vector, that is, the smallest value <tt>k</tt> such that 
	 *          <tt>elem.equals(elementData[k])</tt> is <tt>true</tt>; 
	 *          returns <code>-1</code> if the object is not found.
	 * @see     Object#equals(Object)
	 */

	public int indexOf(double elem) {
		return indexOf(elem, 0);
	}

	/**
	 * Searches for the first occurence of the given argument, beginning 
	 * the search at <code>index</code>, and testing for equality using 
	 * the <code>equals</code> method. 
	 *
	 * @param   elem    an object.
	 * @param   index   the non-negative index to start searching from.
	 * @return  the index of the first occurrence of the object argument in
	 *          this vector at position <code>index</code> or later in the
	 *          vector, that is, the smallest value <tt>k</tt> such that 
	 *          <tt>elem.equals(elementData[k]) && (k &gt;= index)</tt> is 
	 *          <tt>true</tt>; returns <code>-1</code> if the object is not 
	 *          found. (Returns <code>-1</code> if <tt>index</tt> &gt;= the
	 *          current size of this <tt>Vector</tt>.)
	 * @exception  IndexOutOfBoundsException  if <tt>index</tt> is negative.
	 * @see     Object#equals(Object)
	 */

	public int indexOf(double elem, int index) {
		for (int i = index; i < elementCount; i++)
			if (elem == elementData[i])
				return i;
		return -1;
	}

	/**
	 * Returns the index of the last occurrence of the specified object in
	 * this vector.
	 *
	 * @param   elem   the desired component.
	 * @return  the index of the last occurrence of the specified object in
	 *          this vector, that is, the largest value <tt>k</tt> such that 
	 *          <tt>elem.equals(elementData[k])</tt> is <tt>true</tt>; 
	 *          returns <code>-1</code> if the object is not found.
	 */

	public int lastIndexOf(double elem) {
		return lastIndexOf(elem, elementCount - 1);
	}

	/**
	 * Searches backwards for the specified object, starting from the 
	 * specified index, and returns an index to it. 
	 *
	 * @param  elem    the desired component.
	 * @param  index   the index to start searching from.
	 * @return the index of the last occurrence of the specified object in this
	 *          vector at position less than or equal to <code>index</code> in
	 *          the vector, that is, the largest value <tt>k</tt> such that 
	 *          <tt>elem.equals(elementData[k]) && (k &lt;= index)</tt> is 
	 *          <tt>true</tt>; <code>-1</code> if the object is not found.
	 *          (Returns <code>-1</code> if <tt>index</tt> is negative.)
	 * @exception  IndexOutOfBoundsException  if <tt>index</tt> is greater
	 *             than or equal to the current size of this vector.
	 */

	public int lastIndexOf(double elem, int index) {
		if (index >= elementCount)
			throw new IndexOutOfBoundsException(index + " >= " + elementCount);

		for (int i = index; i >= 0; i--)
			if (elem == elementData[i])
				return i;
		return -1;
	}

	/**
	 * Returns the component at the specified index.<p>
	 *
	 * This method is identical in functionality to the get method
	 * (which is part of the List interface).
	 *
	 * @param      index   an index into this vector.
	 * @return     the component at the specified index.
	 * @exception  ArrayIndexOutOfBoundsException  if the <tt>index</tt> 
	 *             is negative or not less than the current size of this 
	 *             <tt>Vector</tt> object.
	 *             given.
	 * @see	   #get(int)
	 * @see	   List
	 */

	public double elementAt(int index) {
		if (index >= elementCount) {
			throw new ArrayIndexOutOfBoundsException(index + " >= " + elementCount);
		}
		/* Since try/catch is free, except when the exception is thrown,
		   put in this extra try/catch to catch negative indexes and
		   display a more informative error message.  This might not
		   be appropriate, especially if we have a decent debugging
		   environment - JP. */
		try {
			return elementData[index];
		}
		catch (ArrayIndexOutOfBoundsException e) {
			throw new ArrayIndexOutOfBoundsException(index + " < 0");
		}
	}

    /**
     * Sets the filename tag for this MP3 File. Refer to
     * <code>TagUtilities.parseFileName</code> and
     * <code>TagUtilities.createID3v2Tag</code> for more information about
     * parsing file names into <code>ID3v2_4</code> objects.
     *
     * @param filenameTag parsed <code>ID3v2_4</code> filename tag
     */

    public void setFilenameTag(FilenameTag filenameTag) {
        this.filenameTag = filenameTag;
    }

	/**
	 * Returns the first component (the item at index <tt>0</tt>) of 
	 * this vector.
	 *
	 * @return     the first component of this vector.
	 * @exception  NoSuchElementException  if this vector has no components.
	 */

	public double firstElement() {
		if (elementCount == 0) {
			throw new NoSuchElementException();
		}
		return elementData[0];
	}

	/**
	 * Returns the last component of the vector.
	 *
	 * @return  the last component of the vector, i.e., the component at index
	 *          <code>size()&nbsp;-&nbsp;1</code>.
	 * @exception  NoSuchElementException  if this vector is empty.
	 */

	public double lastElement() {
		if (elementCount == 0) {
			throw new NoSuchElementException();
		}
		return elementData[elementCount - 1];
	}

    /**
     * Sets the filename tag for this MP3 File. Refer to
     * <code>TagUtilities.parseFileName</code> and
     * <code>TagUtilities.createID3v2Tag</code> for more information about
     * parsing file names into <code>ID3v2_4</code> objects.
     *
     * @return parsed <code>ID3v2_4</code> filename tag
     */

    public FilenameTag getFilenameTag() {
        return this.filenameTag;
    }

	/**
	 * Sets the component at the specified <code>index</code> of this 
	 * vector to be the specified object. The previous component at that 
	 * position is discarded.<p>
	 *
	 * The index must be a value greater than or equal to <code>0</code> 
	 * and less than the current size of the vector. <p>
	 *
	 * This method is identical in functionality to the set method
	 * (which is part of the List interface). Note that the set method reverses
	 * the order of the parameters, to more closely match array usage.  Note
	 * also that the set method returns the old value that was stored at the
	 * specified position.
	 *
	 * @param      obj     what the component is to be set to.
	 * @param      index   the specified index.
	 * @exception  ArrayIndexOutOfBoundsException  if the index was invalid.
	 * @see        #size()
	 * @see        List
	 * @see	   #set(int, java.lang.Object)
	 */

	public void setElementAt(double obj, int index) {
		if (index >= elementCount) {
			throw new ArrayIndexOutOfBoundsException(index + " >= " + elementCount);
		}
		elementData[index] = obj;
	}

	/**
	 * Deletes the component at the specified index. Each component in 
	 * this vector with an index greater or equal to the specified 
	 * <code>index</code> is shifted downward to have an index one 
	 * smaller than the value it had previously. The size of this vector 
	 * is decreased by <tt>1</tt>.<p>
	 *
	 * The index must be a value greater than or equal to <code>0</code> 
	 * and less than the current size of the vector. <p>
	 *
	 * This method is identical in functionality to the remove method
	 * (which is part of the List interface).  Note that the remove method
	 * returns the old value that was stored at the specified position.
	 *
	 * @param      index   the index of the object to remove.
	 * @exception  ArrayIndexOutOfBoundsException  if the index was invalid.
	 * @see        #size()
	 * @see	   #remove(int)
	 * @see	   List
	 */

	public void removeElementAt(int index) {
		if (index >= elementCount) {
			throw new ArrayIndexOutOfBoundsException(index + " >= " + elementCount);
		}
		else if (index < 0) {
			throw new ArrayIndexOutOfBoundsException(index);
		}
		int j = elementCount - index - 1;
		if (j > 0) {
			System.arraycopy(elementData, index + 1, elementData, index, j);
		}
		elementCount--;
		elementData[elementCount] = 0; /* to let gc do its work */
	}

    /**
     * Sets all four (id3v1, lyrics3, filename, id3v2) tags in this instance to
     * the <code>frame</code> argument if the tag exists. This method does not
     * use the options inside the <code>tagOptions</code> object.
     *
     * @param frame frame to set / replace in all four tags.
     *
     * @todo this method is very inefficient.
     */

    public void setFrameAcrossTags(AbstractID3v2Frame frame) {
        ID3v2_4 id3v1 = null;
        ID3v2_4 lyrics3 = null;

        if (this.id3v1tag != null) {
            id3v1 = new ID3v2_4(this.id3v1tag);
            id3v1.setFrame(frame);
            this.id3v1tag.overwrite(id3v1);
        }

        if (this.id3v2tag != null) {
            id3v2tag.setFrame(frame);
        }

        if (this.lyrics3tag != null) {
            lyrics3 = new ID3v2_4(this.lyrics3tag);
            lyrics3.setFrame(frame);
            this.lyrics3tag = new Lyrics3v2(lyrics3);
        }

        if (this.filenameTag != null) {
            filenameTag.setFrame(frame);
        }
    }

	/**
	 * Inserts the specified object as a component in this vector at the 
	 * specified <code>index</code>. Each component in this vector with 
	 * an index greater or equal to the specified <code>index</code> is 
	 * shifted upward to have an index one greater than the value it had 
	 * previously. <p>
	 *
	 * The index must be a value greater than or equal to <code>0</code> 
	 * and less than or equal to the current size of the vector. (If the
	 * index is equal to the current size of the vector, the new element
	 * is appended to the Vector.)<p>
	 *
	 * This method is identical in functionality to the add(Object, int) method
	 * (which is part of the List interface). Note that the add method reverses
	 * the order of the parameters, to more closely match array usage.
	 *
	 * @param      obj     the component to insert.
	 * @param      index   where to insert the new component.
	 * @exception  ArrayIndexOutOfBoundsException  if the index was invalid.
	 * @see        #size()
	 * @see	   #add(int, Object)
	 * @see	   List
	 */

	public void insertElementAt(double obj, int index) {
		if (index >= elementCount + 1) {
			throw new ArrayIndexOutOfBoundsException(index + " > " + elementCount);
		}
		ensureCapacityHelper(elementCount + 1);
		System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
		elementData[index] = obj;
		elementCount++;
	}

	/**
	 * Adds the specified component to the end of this vector, 
	 * increasing its size by one. The capacity of this vector is 
	 * increased if its size becomes greater than its capacity. <p>
	 *
	 * This method is identical in functionality to the add(Object) method
	 * (which is part of the List interface).
	 *
	 * @param   obj   the component to be added.
	 * @see	   #add(Object)
	 * @see	   List
	 */

	public void addElement(double obj) {
		ensureCapacityHelper(elementCount + 1);
		elementData[elementCount++] = obj;
	}

	/**
	 * Removes the first (lowest-indexed) occurrence of the argument 
	 * from this vector. If the object is found in this vector, each 
	 * component in the vector with an index greater or equal to the 
	 * object's index is shifted downward to have an index one smaller 
	 * than the value it had previously.<p>
	 *
	 * This method is identical in functionality to the remove(Object) 
	 * method (which is part of the List interface).
	 *
	 * @param   obj   the component to be removed.
	 * @return  <code>true</code> if the argument was a component of this
	 *          vector; <code>false</code> otherwise.
	 * @see	List#remove(Object)
	 * @see	List
	 */

	public boolean removeElement(double obj) {
		int i = indexOf(obj);
		if (i >= 0) {
			removeElementAt(i);
			return true;
		}
		return false;
	}

	/**
	 * Removes all components from this vector and sets its size to zero.<p>
	 *
	 * This method is identical in functionality to the clear method
	 * (which is part of the List interface).
	 *
	 * @see	#clear
	 * @see	List
	 */

	public void removeAllElements() {
		// Let gc do its work
		for (int i = 0; i < elementCount; i++)
			elementData[i] = 0;

		elementCount = 0;
	}

	/**
	 * Returns a clone of this vector. The copy will contain a
	 * reference to a clone of the internal data array, not a reference 
	 * to the original internal data array of this <tt>Vector</tt> object. 
	 *
	 * @return  a clone of this vector.
	 */

	public Object clone() {
		try {
			DoubleVector v = (DoubleVector) super.clone();
			v.elementData = new double[elementCount];
			System.arraycopy(elementData, 0, v.elementData, 0, elementCount);
			return v;
		}
		catch (CloneNotSupportedException e) {
			// this shouldn't happen, since we are Cloneable
			throw new InternalError();
		}
	}

    /**
     * Sets the <code>ID3v1</code> tag for this object. A new
     * <code>ID3v1_1</code> object is created from the argument and then used
     * here.
     *
     * @param mp3tag Any MP3Tag object can be used and will be converted into a
     *        new ID3v1_1 object.
     */

    public void setID3v1Tag(AbstractMP3Tag mp3tag) {
        id3v1tag = new ID3v1_1(mp3tag);
    }

	/**
	 * Returns the element at the specified position in this Vector.
	 *
	 * @param index index of element to return.
	 * @return object at the specified index
	 * @exception ArrayIndexOutOfBoundsException index is out of range (index
	 * 		  &lt; 0 || index &gt;= size()).
	 * @since 1.2
	 */

	public double get(int index) {
		if (index >= elementCount)
			throw new ArrayIndexOutOfBoundsException(index);

		return elementData[index];
	}

	/**
	 * Replaces the element at the specified position in this Vector with the
	 * specified element.
	 *
	 * @param index index of element to replace.
	 * @param element element to be stored at the specified position.
	 * @return the element previously at the specified position.
	 * @exception ArrayIndexOutOfBoundsException index out of range
	 *		  (index &lt; 0 || index &gt;= size()).
	 * @since 1.2
	 */

	public double set(int index, double element) {
		if (index >= elementCount)
			throw new ArrayIndexOutOfBoundsException(index);

		double oldValue = elementData[index];
		elementData[index] = element;
		return oldValue;
	}

	/**
	 * Appends the specified element to the end of this Vector.
	 *
	 * @param o element to be appended to this Vector.
	 * @return true (as per the general contract of Collection.add).
	 * @since 1.2
	 */

	public boolean add(double o) {
		ensureCapacityHelper(elementCount + 1);
		elementData[elementCount++] = o;
		return true;
	}

    /**
     * Returns the <code>ID3v1</code> tag for this object.
     *
     * @return the <code>ID3v1</code> tag for this object
     */

    public ID3v1 getID3v1Tag() {
        return id3v1tag;
    }

	/**
	 * Removes the first occurrence of the specified element in this Vector
	 * If the Vector does not contain the element, it is unchanged.  More
	 * formally, removes the element with the lowest index i such that
	 * <code>(o==null ? get(i)==null : o.equals(get(i)))</code> (if such
	 * an element exists).
	 *
	 * @param o element to be removed from this Vector, if present.
	 * @return true if the Vector contained the specified element.
	 * @since 1.2
	 */

	public boolean remove(double o) {
		return removeElement(o);
	}

    /**
     * Sets the <code>ID3v2</code> tag for this object. A new
     * <code>ID3v2_4</code> object is created from the argument and then used
     * here.
     *
     * @param mp3tag Any MP3Tag object can be used and will be converted into a
     *        new ID3v2_4 object.
     */

    public void setID3v2Tag(AbstractMP3Tag mp3tag) {
        id3v2tag = new ID3v2_4(mp3tag);
    }

	/**
	 * Inserts the specified element at the specified position in this Vector.
	 * Shifts the element currently at that position (if any) and any
	 * subsequent elements to the right (adds one to their indices).
	 *
	 * @param index index at which the specified element is to be inserted.
	 * @param element element to be inserted.
	 * @exception ArrayIndexOutOfBoundsException index is out of range
	 *		  (index &lt; 0 || index &gt; size()).
	 * @since 1.2
	 */

	public void add(int index, double element) {
		insertElementAt(element, index);
	}

	/**
	 * Removes all of the elements from this Vector.  The Vector will
	 * be empty after this call returns (unless it throws an exception).
	 *
	 * @since 1.2
	 */

	public void clear() {
		removeAllElements();
	}

	/**
	 * Compares the specified Object with this Vector for equality.  Returns
	 * true if and only if the specified Object is also a List, both Lists
	 * have the same size, and all corresponding pairs of elements in the two
	 * Lists are <em>equal</em>.  (Two elements <code>e1</code> and
	 * <code>e2</code> are <em>equal</em> if <code>(e1==null ? e2==null :
	 * e1.equals(e2))</code>.)  In other words, two Lists are defined to be
	 * equal if they contain the same elements in the same order.
	 *
	 * @param o the Object to be compared for equality with this Vector.
	 * @return true if the specified Object is equal to this Vector
	 */

	public boolean equals(Object o) {
		return super.equals(o);
	}

    /**
     * Returns the <code>ID3v2</code> tag for this object.
     *
     * @return the <code>ID3v2</code> tag for this object
     */

    public AbstractID3v2 getID3v2Tag() {
        return id3v2tag;
    }

	/**
	 * Removes from this List all of the elements whose index is between
	 * fromIndex, inclusive and toIndex, exclusive.  Shifts any succeeding
	 * elements to the left (reduces their index).
	 * This call shortens the ArrayList by (toIndex - fromIndex) elements.  (If
	 * toIndex==fromIndex, this operation has no effect.)
	 *
	 * @param fromIndex index of first element to be removed.
	 * @param toIndex index after last element to be removed.
	 */

	protected void removeRange(int fromIndex, int toIndex) {
		int numMoved = elementCount - toIndex;
		System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved);

		// Let gc do its work
		int newElementCount = elementCount - (toIndex - fromIndex);
		while (elementCount != newElementCount)
			elementData[--elementCount] = 0;
	}

    /**
     * Sets the <code>Lyrics3</code> tag for this object. A new
     * <code>Lyrics3v2</code> object is created from the argument and then
     * used here.
     *
     * @param mp3tag Any MP3Tag object can be used and will be converted into a
     *        new Lyrics3v2 object.
     */

    public void setLyrics3Tag(AbstractMP3Tag mp3tag) {
        lyrics3tag = new Lyrics3v2(mp3tag);
    }

    /**
     * Returns the <code>ID3v1</code> tag for this object.
     *
     * @return the <code>ID3v1</code> tag for this object
     */

    public AbstractLyrics3 getLyrics3Tag() {
        return lyrics3tag;
    }

    /**
     * Gets the value of the frame identified by identifier
     *
     * @param identifier The three letter code
     *
     * @return The value associated with the identifier
     */

    public Lyrics3v2Field getField(String identifier) {
        return (Lyrics3v2Field) fieldMap.get(identifier);
    }

    /**
     * Sets the factor to increase the id3v2 padding size. When the ID3v2 tag
     * padding length is calculated and is not large enough to fit the current
     * ID3v2 tag, the padding length will be multiplied by this number until
     * it is large enough.
     *
     * @param mult new factor to increase the id3v2 padding size.
     */

    public void setId3v2PaddingMultiplier(float mult) {
        if (mult > 1) {
            id3v2PaddingMultiplier = mult;
        }
    }

    /**
     * Returns the factor to increase the id3v2 padding size. When the ID3v2
     * tag padding length is calculated and is not large enough to fit the
     * current ID3v2 tag, the padding length will be multiplied by this number
     * until it is large enough.
     *
     * @return the factor to increase the id3v2 padding size
     */

    public float getId3v2PaddingMultiplier() {
        return id3v2PaddingMultiplier;
    }

    /**
     * Returns true if there are any unsynchronized tags in this object. A
     * fragment is unsynchronized if it exists in two or more tags but is not
     * equal across all of them.
     *
     * @return true of any fragments are unsynchronized.
     *
     * @todo there might be a faster way to do this, other than calling
     *       <code>getUnsynchronizedFragments</code>
     */

    public boolean isUnsynchronized() {
        return getUnsynchronizedFragments().size() > 0;
    }

    /**
     * Sets the initial ID3v2 padding length. This will be the minimum padding
     * length of the ID3v2 tag. The <code>willShorten</code> setting will not
     * make the length shorter than this value.
     *
     * @param size the new initial ID3v2 padding length
     */

    public void setId3v2PaddingSize(int size) {
        if (size >= 0) {
            id3v2PaddingSize = size;
        }
    }

    /**
     * Returns the initial ID3v2 padding length. This will be the minimum
     * padding length of the ID3v2 tag. The <code>willShorten</code> setting
     * will not make the length shorter than this value.
     *
     * @return the initial ID3v2 padding length
     */

    public int getId3v2PaddingSize() {
        return id3v2PaddingSize;
    }

    /**
     * This method calls <code>toString</code> for all it's objects and appends
     * them without any newline characters.
     *
     * @return brief description string
     */

    public String getBriefDescription() {
        String            str = "";
        AbstractMP3Object object;
        Iterator          iterator = objectList.listIterator();

        while (iterator.hasNext()) {
            object = (AbstractMP3Object) iterator.next();

            if ((object.toString() != null) && (object.toString().length() > 0)) {
                str += (object.getIdentifier() + "=\"" + object.toString() + "\"; ");
            }
        }

        return str;
    }

    /**
     * This method calls <code>toString</code> for all it's objects and appends
     * them. It contains new line characters and is more suited for display
     * purposes
     *
     * @return formatted description string
     */

    public String getDescription() {
        String            str = "";
        AbstractMP3Object object;
        Iterator          iterator = objectList.listIterator();

        while (iterator.hasNext()) {
            object = (AbstractMP3Object) iterator.next();
            str += (object.getIdentifier() + " = " + object.toString() + "\n");
        }

        return str.trim();
    }

    /**
     * Sets the all objects of identifier type to <code>obj</code> argument.
     *
     * @param identifier <code>MP3Object</code> identifier
     * @param obj new object value
     */

    public void setObject(String identifier, Object obj) {
        AbstractMP3Object object;
        Iterator          iterator = objectList.listIterator();

        while (iterator.hasNext()) {
            object = (AbstractMP3Object) iterator.next();

            if (object.getIdentifier().equals(identifier)) {
                object.setValue(obj);
            }
        }
    }

    /**
     * Returns the object of the <code>MP3Object</code> with the specified
     * <code>identifier</code>
     *
     * @param identifier <code>MP3Object</code> identifier
     *
     * @return the object of the <code>MP3Object</code> with the specified
     *         <code>identifier</code>
     */

    public Object getObject(String identifier) {
        AbstractMP3Object object;
        Object            obj = null;
        Iterator          iterator = objectList.listIterator();

        while (iterator.hasNext()) {
            object = (AbstractMP3Object) iterator.next();

            if (object.getIdentifier().equals(identifier)) {
                obj = object.getValue();
            }
        }

        return obj;
    }

    /**
     * Returns true if this instance and its entire <code>MP3Object</code>
     * array list is a subset of the argument. This class is a subset if it is
     * the same class as the argument.
     *
     * @param obj object to determine subset of
     *
     * @return true if this instance and its entire object array list is a
     *         subset of the argument.
     */

    public boolean isSubsetOf(Object obj) {
        if ((obj instanceof AbstractMP3FragmentBody) == false) {
            return false;
        }

        ArrayList superset = ((AbstractMP3FragmentBody) obj).objectList;

        for (int i = 0; i < objectList.size(); i++) {
            if (((AbstractMP3Object) objectList.get(i)).getValue() != null) {
                if (superset.contains(objectList.get(i)) == false) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Returns true if this object and its entire <code>MP3Object</code> array
     * list equals the argument. This object is equal to the argument if they
     * are the same class.
     *
     * @param obj object to determine equality of
     *
     * @return true if this object and its entire <code>MP3Object</code> array
     *         list equals the argument.
     */

    public boolean equals(Object obj) {
        if ((obj instanceof AbstractMP3FragmentBody) == false) {
            return false;
        }

        AbstractMP3FragmentBody object = (AbstractMP3FragmentBody) obj;

        if (this.objectList.equals(object.objectList) == false) {
            return false;
        }

        return super.equals(obj);
    }

    /**
     * Returns an iterator of the <code>MP3Object</code> object list.
     *
     * @return iterator of the <code>MP3Object</code> object list.
     */

    public Iterator iterator() {
        return objectList.iterator();
    }

    /**
     * Calls <code>toString</code> for all <code>MP3Object</code> objects and
     * creates a string with a new line character.
     *
     * @return description string
     */

    public String toString() {
        String            str = getIdentifier() + "\n";
        AbstractMP3Object object;
        Iterator          iterator = objectList.listIterator();

        while (iterator.hasNext()) {
            object = (AbstractMP3Object) iterator.next();
            str += (object.getIdentifier() + " = " + object.toString() + "\n");
        }

        return str;
    }

    /**
     * Returns true if this object contains an filename pseudo-tag
     *
     * @return true if this object contains an filename pseudo-tag
     */

    public boolean hasFilenameTag() {
        return (filenameTag != null);
    }

    /**
     * This method is not yet supported.
     *
     * @throws java.lang.UnsupportedOperationException This method is not yet
     *         supported
     */

    public void equals() {
        /**
         * @todo Implement this java.lang.Object method
         */
        throw new java.lang.UnsupportedOperationException("Method equals() not yet implemented.");
    }

    /**
     * Returns true if this object contains an <code>Id3v1</code> tag
     *
     * @return true if this object contains an <code>Id3v1</code> tag
     */

    public boolean hasID3v1Tag() {
        return (id3v1tag != null);
    }

    /**
     * Sets the default language for any ID3v2 tag frames which require it.
     * While the value will already exist when reading from a file, this value
     * will be used when a new ID3v2 Frame is created from scratch.
     *
     * @param lang language ID, [ISO-639-2] ISO/FDIS 639-2 definition
     */

    public void setLanguage(String lang) {
        if (TagConstant.languageIdToString.containsKey(lang)) {
            language = lang;
        }
    }

    /**
     * Returns true if this object contains an <code>Id3v2</code> tag
     *
     * @return true if this object contains an <code>Id3v2</code> tag
     */

    public boolean hasID3v2Tag() {
        return (id3v2tag != null);
    }

    /**
     * Returns the default language for any ID3v2 tag frames which require it.
     *
     * @return language ID, [ISO-639-2] ISO/FDIS 639-2 definition
     */

    public String getLanguage() {
        return language;
    }

    /**
     * Returns true if this object contains an <code>Lyrics3</code> tag
     *
     * @return true if this object contains an <code>Lyrics3</code> tag
     */

    public boolean hasLyrics3Tag() {
        return (lyrics3tag != null);
    }

    /**
     * Sets if we should save the Lyrics3 field. Defaults to true.
     *
     * @param id Lyrics3 id string
     * @param save true if you want to save this specific Lyrics3 field.
     */

    public void setLyrics3SaveField(String id, boolean save) {
        this.lyrics3SaveFieldMap.put(id, new Boolean(save));
    }

    /**
     * Returns true if we should save the Lyrics3 field asked for in the
     * argument. Defaults to true.
     *
     * @param id Lyrics3 id string
     *
     * @return true if we should save the Lyrics3 field.
     */

    public boolean getLyrics3SaveField(String id) {
        return ((Boolean) lyrics3SaveFieldMap.get(id)).booleanValue();
    }

    /**
     * Returns the MP3 frame size for the file this object refers to. It
     * assumes that <code>seekNextMP3Frame</code> has already been called.
     *
     * @return MP3 Frame size in bytes.
     */

    private int getFrameSize() {
        if (this.frequency == 0) {
            return 0;
        }

        int size = 0;
        int paddingByte;

        if (padding) {
            paddingByte = 1;
        } else {
            paddingByte = 0;
        }

        if (this.layer == 3) { // Layer I
            size = (int) ((((12 * this.bitRate) / this.frequency) + paddingByte) * 4);
        } else {
            size = (int) (((144 * this.bitRate) / this.frequency) + paddingByte);
        }

        //if (protection) size += 2;
        return size;
    }

    /**
     * Sets the default play counter size for the PCNT ID3v2 frame. While the
     * value will already exist when reading from a file, this value will be
     * used when a new ID3v2 Frame is created from scratch.
     *
     * @param size the default play counter size for the PCNT ID3v2 frame
     */

    public void setPlayCounterSize(byte size) {
        if (size > 0) {
            playCounterSize = size;
        }
    }

    /**
     * Returns the default play counter size for the PCNT ID3v2 frame.
     *
     * @return the default play counter size for the PCNT ID3v2 frame
     */

    public byte getPlayCounterSize() {
        return playCounterSize;
    }

    /**
     * Sets the default text encoding for any ID3v2 tag frames which require
     * it. While the value will already exist when reading from a file, this
     * value will be used when a new ID3v2 Frame is created from scratch.
     * 
     * <P>
     * $00   ISO-8859-1 [ISO-8859-1]. Terminated with $00.<BR> $01   UTF-16
     * [UTF-16] encoded Unicode [UNICODE] with BOM. All strings in the same
     * frame SHALL have the same byteorder. Terminated with $00 00.<BR> $02
     * UTF-16BE [UTF-16] encoded Unicode [UNICODE] without BOM. Terminated
     * with $00 00.<BR> $03   UTF-8 [UTF-8] encoded Unicode [UNICODE].
     * Terminated with $00.<BR>
     * </p>
     *
     * @param enc new default text encoding
     */

    public void setTextEncoding(byte enc) {
        if ((enc >= 0) && (enc <= 3)) {
            textEncoding = enc;
        }
    }

    /**
     * Returns the default text encoding format for ID3v2 tags which require
     * it.
     * 
     * <P>
     * $00   ISO-8859-1 [ISO-8859-1]. Terminated with $00.<BR> $01   UTF-16
     * [UTF-16] encoded Unicode [UNICODE] with BOM. All strings in the same
     * frame SHALL have the same byteorder. Terminated with $00 00.<BR> $02
     * UTF-16BE [UTF-16] encoded Unicode [UNICODE] without BOM. Terminated
     * with $00 00.<BR> $03   UTF-8 [UTF-8] encoded Unicode [UNICODE].
     * Terminated with $00.<BR>
     * </p>
     *
     * @return the default text encoding
     */

    public byte getTextEncoding() {
        return textEncoding;
    }

    /**
     * Sets the default time stamp format for ID3v2 tags which require it.
     * While the value will already exist when reading from a file, this value
     * will be used when a new ID3v2 Frame is created from scratch.
     * 
     * <P>
     * $01  Absolute time, 32 bit sized, using MPEG frames as unit<br>
     * $02  Absolute time, 32 bit sized, using milliseconds as unit<br>
     * </p>
     *
     * @param tsf the new default time stamp format
     */

    public void setTimeStampFormat(byte tsf) {
        if ((tsf == 1) || (tsf == 2)) {
            timeStampFormat = tsf;
        }
    }

    /**
     * Returns the default time stamp format for ID3v2 tags which require it.
     * 
     * <P>
     * $01  Absolute time, 32 bit sized, using MPEG frames as unit<br>
     * $02  Absolute time, 32 bit sized, using milliseconds as unit<br>
     * </p>
     *
     * @return the default time stamp format
     */

    public byte getTimeStampFormat() {
        return timeStampFormat;
    }

    /**
     * Creates a new ObjectLyrics3TimeStamp object.
     *
     * @param timeStamp DOCUMENT ME!
     * @param timeStampFormat DOCUMENT ME!
     */

    public void setTimeStamp(long timeStamp, byte timeStampFormat) {
        /**
         * @todo convert both types of formats
         */
        timeStamp = timeStamp / 1000;
        minute    = timeStamp / 60;
        second    = timeStamp % 60;
    }

    /**
     * Returns true if the string has matching parenthesis. This method matches
     * all four parenthesis and also enclosed parenthesis.
     *
     * @param str string to test
     *
     * @return true if the string has matching parenthesis
     */

    static public boolean isMatchingParenthesis(String str) {
        if (str != null) {
            TagOptionSingleton option = TagOptionSingleton.getInstance();
            int                length = str.length();
            char               ch;

            for (int i = 0; i < length; i++) {
                ch = str.charAt(i);

                if (option.isCloseParenthesis("" + ch)) {
                    return false;
                }

                if (option.isOpenParenthesis("" + ch)) {
                    i = findMatchingParenthesis(str, i);

                    if (i < 0) {
                        return false;
                    }
                }
            }

            return true;
        }

        return false;
    }

    /**
     * Reconstruct the filename that is represented by this composite.
     *
     * @return the filename that is represented by this composite.
     */

    public String composeFilename() {
        String filename = "";

        if (beforeComposite != null) {
            filename += (beforeComposite.composeFilename() + " ");
        }

        if (afterComposite != null) {
            filename += afterComposite.composeFilename();
        }

        return filename.trim();
    }

    /**
     * Sets the composite that this tag will use.
     *
     * @param composite the composite that this tag will use.
     */

    public void setComposite(AbstractFilenameComposite composite) {
        this.composite = composite;
    }

    /**
     * Given an object, try to return it as a <code>long</code>. This tries to
     * parse a string, and takes <code>Long, Short, Byte, Integer</code>
     * objects and gets their value. An exception is not explicityly thrown
     * here because it would causes too many other methods to also throw it.
     *
     * @param value object to find long from.
     *
     * @return <code>long</code> value
     *
     * @throws IllegalArgumentException DOCUMENT ME!
     */

    static public long getWholeNumber(Object value) {
        long number;

        if (value instanceof String) {
            number = Long.parseLong((String) value);
        } else if (value instanceof Byte) {
            number = ((Byte) value).byteValue();
        } else if (value instanceof Short) {
            number = ((Short) value).shortValue();
        } else if (value instanceof Integer) {
            number = ((Integer) value).intValue();
        } else if (value instanceof Long) {
            number = ((Long) value).longValue();
        } else {
            throw new IllegalArgumentException("Unsupported value class: " + value.getClass().getName());
        }

        return number;
    }

    /**
     * Returns the composite that this tag will use.
     *
     * @return the composite that this tag will use.
     */

    public AbstractFilenameComposite getComposite() {
        return composite;
    }

    /**
     * Sets the ID3v2 frame body that this token represents
     *
     * @param id3v2FrameBodyClass the ID3v2 frame body that this token
     *        represents
     */

    public void setId3v2FrameBodyClass(Class id3v2FrameBodyClass) {
        this.id3v2FrameBodyClass = id3v2FrameBodyClass;
    }

    /**
     * Sets the frame of this tag
     *
     * @param frame the frame to set
     */

    public void setFrame(AbstractID3v2Frame frame) {
        if (frame != null) {
            if (id3tag == null) {
                id3tag = new ID3v2_4();
            }

            id3tag.setFrame(frame);

            if (composite != null) {
                composite.setFrame(frame);
            }
        }
    }

    /**
     * Returns the ID3v2 frame body that this token represents
     *
     * @return the ID3v2 frame body that this token represents
     */

    public Class getId3v2FrameBodyClass() {
        return id3v2FrameBodyClass;
    }

    /**
     * Returns a frame of this tag
     *
     * @param identifier ID3v2_4 ID of frame to get
     *
     * @return a frame of this tag
     */

    public AbstractID3v2Frame getFrame(String identifier) {
        if (id3tag != null) {
            return id3tag.getFrame(identifier);
        }

        return null;
    }

    /**
     * Sets the token that this class contains
     *
     * @param token the token that this class contains
     */

    public void setToken(String token) {
        this.token = token.trim();
    }

    /**
     * Return the token that this class contains
     *
     * @return the token that this class contains
     */

    public String getToken() {
        return token;
    }

    /**
     * Sets the ID3v2_4 representation of this tag.
     *
     * @param id3tag the ID3v2_4 representation of this tag
     */

    public void setId3tag(ID3v2_4 id3tag) {
        this.id3tag = id3tag;

        if (id3tag != null) {
            Iterator iterator = id3tag.iterator();

            while (iterator.hasNext()) {
                composite.setFrame((AbstractID3v2Frame) iterator.next());
            }

            if (composite != null) {
                composite.matchAgainstTag(id3tag);
            }
        }
    }

    /**
     * Reconstruct the filename that is represented by this composite.
     *
     * @return the filename that is represented by this composite.
     */

    public String composeFilename() {
        return token;
    }

    /**
     * Returns the ID3v2_4 representation of this tag
     *
     * @return the ID3v2_4 representation of this tag
     */

    public ID3v2_4 getId3tag() {
        return id3tag;
    }

    /**
     * Returns an iterator through each <code>FilenameToken</code> in this
     * composite in the correct order for the file name.
     *
     * @return an iterator through each <code>FilenameToken</code> in this
     *         composite
     */

    public Iterator iterator() {
        return new FilenameTokenIterator(this);
    }

    /**
     * Returns a string containing debug information about this class
     *
     * @return a string containing debug information about this class
     */

    public String toString() {
        return id3v2FrameBodyClass + ": " + token;
    }

    /**
     * Returns true if the iteration has more elements. (In other words,
     * returns true if next would return an element rather than throwing an
     * exception.)
     *
     * @return true if the iteration has more elements
     */

    public boolean hasNext() {
        boolean nextFlag = false;

        if (beforeIterator != null) {
            nextFlag = nextFlag || beforeIterator.hasNext();
        }

        if (afterIterator != null) {
            nextFlag = nextFlag || afterIterator.hasNext();
        }

        return nextFlag;
    }

    /**
     * Returns the next element in the iteration.
     *
     * @return the next element in the iteration.
     *
     * @throws NoSuchElementException DOCUMENT ME!
     */

    public Object next() {
        if ((beforeIterator != null) && beforeIterator.hasNext()) {
            return beforeIterator.next();
        } else if ((afterIterator != null) && afterIterator.hasNext()) {
            return afterIterator.next();
        } else {
            throw new NoSuchElementException("Iteration has no more elements.");
        }
    }

    /**
     * This method is not supported in this iterator.
     *
     * @throws java.lang.UnsupportedOperationException This method is not
     *         supported in this iterator
     */

    public void remove() {
        /**
         * @todo Implement this java.util.Iterator method
         */
        throw new java.lang.UnsupportedOperationException("Method remove() not yet implemented.");
    }

    /**
     * Returns true if the iteration has more elements. (In other words,
     * returns true if next would return an element rather than throwing an
     * exception.)
     *
     * @return true if the iteration has more elements
     */

    public boolean hasNext() {
        boolean nextFlag = false;

        if (beforeIterator != null) {
            nextFlag = nextFlag || beforeIterator.hasNext();
        }

        if (middleIterator != null) {
            nextFlag = nextFlag || middleIterator.hasNext();
        }

        if (afterIterator != null) {
            nextFlag = nextFlag || afterIterator.hasNext();
        }

        return nextFlag;
    }

    /**
     * Returns the next element in the iteration.
     *
     * @return the next element in the iteration.
     *
     * @throws NoSuchElementException DOCUMENT ME!
     */

    public Object next() {
        if ((beforeIterator != null) && beforeIterator.hasNext()) {
            return beforeIterator.next();
        } else if ((middleIterator != null) && middleIterator.hasNext()) {
            return middleIterator.next();
        } else if ((afterIterator != null) && afterIterator.hasNext()) {
            return afterIterator.next();
        }

        throw new NoSuchElementException("Iteration has no more elements.");
    }

    /**
     * Sets the original string that this composite represents.
     *
     * @param originalToken the original string that this composite represents.
     */

    public void setOriginalToken(String originalToken) {
        this.originalToken = originalToken;
    }

    /**
     * Get the original string that this composite represents.
     *
     * @return the original string that this composite represents.
     */

    public String getOriginalToken() {
        return originalToken;
    }

    /**
     * Returns true if the iteration has more elements. (In other words,
     * returns true if next would return an element rather than throwing an
     * exception.)
     *
     * @return true if the iteration has more elements
     */

    public boolean hasNext() {
        return returnedToken == false;
    }

    /**
     * Returns the next element in the iteration.
     *
     * @return the next element in the iteration.
     *
     * @throws NoSuchElementException DOCUMENT ME!
     */

    public Object next() {
        if (returnedToken == false) {
            returnedToken = true;

            return filenameToken;
        }

        throw new NoSuchElementException("Iteration has no more elements.");
    }

    /**
     * Replace the Unix end of line character with the DOS end of line
     * character.
     *
     * @param text string to search and replace
     *
     * @return replaced string
     */

    static public String replaceEOLNwithCRLF(String text) {
        String newText = null;

        if (text != null) {
            newText = "";

            int oldPos = 0;
            int newPos = text.indexOf('\n');

            while (newPos >= 0) {
                newText += (text.substring(oldPos, newPos) + TagConstant.CRLF);
                oldPos = ++newPos;
                newPos = text.indexOf('\n', oldPos);
            }

            newText += text.substring(oldPos);
        }

        return newText;
    }

    /**
     * Sets the composite that goes between the parenthesis
     *
     * @param middleComposite the composite that goes between the parenthesis
     */

    public void setMiddleComposite(AbstractFilenameComposite middleComposite) {
        this.middleComposite = middleComposite;
    }

    /**
     * Returnsthe composite that goes between the parenthesis
     *
     * @return the composite that goes between the parenthesis
     */

    public AbstractFilenameComposite getMiddleComposite() {
        return middleComposite;
    }

    /**
     * Sets the opening parenthesis
     *
     * @param openDelimiter the opening parenthesis
     */

    public void setOpenDelimiter(String openDelimiter) {
        this.openDelimiter = openDelimiter;
    }

    /**
     * Returns the opening parenthesis
     *
     * @return the opening parenthesis
     */

    public String getOpenDelimiter() {
        return openDelimiter;
    }

    /**
     * Reconstruct the filename that is represented by this composite.
     *
     * @return the filename that is represented by this composite.
     */

    public String composeFilename() {
        String filename = "";

        if (beforeComposite != null) {
            filename += beforeComposite.composeFilename();
        }

        filename += (" " + openDelimiter);

        if (middleComposite != null) {
            filename += middleComposite.composeFilename();
        }

        filename += (TagOptionSingleton.getInstance().getCloseParenthesis(openDelimiter) + " ");

        if (afterComposite != null) {
            filename += afterComposite.composeFilename();
        }

        return filename;
    }

    /**
     * Returns an iterator through each <code>FilenameToken</code> in this
     * composite in the correct order for the file name.
     *
     * @return an iterator through each <code>FilenameToken</code> in this
     *         composite
     */

    public Iterator iterator() {
        return new FilenameParenthesisIterator(this);
    }

    /**
     * Match all elements of this composite against the keywords for this class
     * type found in <code>TagOptionSingleton</code>. If the
     * <code>FilenameToken</code> matches the keyword, the token's class is
     * set.
     *
     * @param id3v2FrameBodyClass Class of keywords to match against.
     */

    public void matchAgainstKeyword(Class id3v2FrameBodyClass) {
        if (AbstractID3v2FrameBody.class.isAssignableFrom(id3v2FrameBodyClass)) {
            if (beforeComposite != null) {
                beforeComposite.matchAgainstKeyword(id3v2FrameBodyClass);
            }

            if (middleComposite != null) {
                middleComposite.matchAgainstKeyword(id3v2FrameBodyClass);
            }

            if (afterComposite != null) {
                afterComposite.matchAgainstKeyword(id3v2FrameBodyClass);
            }
        }
    }

    /**
     * Match all elements of this composite against the given tag. If any
     * element of <code>matchTag</code> matches any element of this tag's
     * composite, then this tag's composite leaf node's class is set.
     *
     * @param matchTag Tag to match against
     */

    public void matchAgainstTag(AbstractMP3Tag matchTag) {
        if (matchTag != null) {
            if (beforeComposite != null) {
                beforeComposite.matchAgainstTag(matchTag);
            }

            if (middleComposite != null) {
                middleComposite.matchAgainstTag(matchTag);
            }

            if (afterComposite != null) {
                afterComposite.matchAgainstTag(matchTag);
            }
        }
    }

    /**
     * Remove all occurances of the given character from the string argument.
     *
     * @param str String to search
     * @param ch character to remove
     *
     * @return new String without the given charcter
     */

    static public String stripChar(String str, char ch) {
        if (str != null) {
            char[] buffer = new char[str.length()];
            int    next = 0;

            for (int i = 0; i < str.length(); i++) {
                if (str.charAt(i) != ch) {
                    buffer[next++] = str.charAt(i);
                }
            }

            return new String(buffer, 0, next);
        } else {
            return null;
        }
    }

    /**
     * Sets the composite that comes after the delimiter.
     *
     * @param afterComposite The composite that comes after the delimiter.
     */

    public void setAfterComposite(AbstractFilenameComposite afterComposite) {
        this.afterComposite = afterComposite;
    }

    /**
     * Returns the composite that comes after the delimiter.
     *
     * @return the composite that comes after the delimiter.
     */

    public AbstractFilenameComposite getAfterComposite() {
        return afterComposite;
    }

    /**
     * Sets the composite that comes before the delimiter
     *
     * @param beforeComposite the composite that comes before the delimiter
     */

    public void setBeforeComposite(AbstractFilenameComposite beforeComposite) {
        this.beforeComposite = beforeComposite;
    }

    /**
     * Traverse the composite and set the class field to match keywords found
     * in TagOptionSingleton.
     *
     * @param composite composite to update.
     */

    static public void updateCompositeFromAllOption(AbstractFilenameComposite composite) {
        Iterator iterator = TagOptionSingleton.getInstance().getKeywordIterator();

        while (iterator.hasNext()) {
            composite.matchAgainstKeyword((Class) iterator.next());
        }
    }

    /**
     * Returns the composite that comes before the delimiter
     *
     * @return the composite that comes before the delimiter
     */

    public AbstractFilenameComposite getBeforeComposite() {
        return beforeComposite;
    }

    /**
     * Sets the delimiter that splits the two halves of this composite
     *
     * @param delimiter delimiter that splits the two halves of this composite
     */

    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }

    /**
     * Traverse the composite and set the class field to match frames from all
     * three other tags that are already found in the MP3 file.
     *
     * @param composite composite to update
     * @param mp3File mp3file to match all it's tags against.
     */

    static public void updateCompositeFromAllTag(AbstractFilenameComposite composite, MP3File mp3File) {
        composite.matchAgainstTag(mp3File.getID3v1Tag());
        composite.matchAgainstTag(mp3File.getID3v2Tag());
        composite.matchAgainstTag(mp3File.getLyrics3Tag());
    }

    /**
     * Returns the delimiter that splits the two halfs of this composite
     *
     * @return the delimiter that splits the two halfs of this composite
     */

    public String getDelimiter() {
        return delimiter;
    }

    /**
     * Create the filename that this composite represents
     *
     * @return the filename that this composite represents
     */

    public String composeFilename() {
        String filename = "";

        if (beforeComposite != null) {
            filename += beforeComposite.composeFilename();
        }

        filename += (delimiter + " ");

        if (afterComposite != null) {
            filename += afterComposite.composeFilename();
        }

        return filename;
    }

    /**
     * Returns an iterator through each <code>FilenameToken</code> in this
     * composite in the correct order for the file name.
     *
     * @return an iterator through each <code>FilenameToken</code> in this
     *         composite
     */

    public Iterator iterator() {
        return new FilenameDelimiterIterator(this);
    }

    /**
     * Match all elements of this composite against the keywords for this class
     * type found in <code>TagOptionSingleton</code>. If the
     * <code>FilenameToken</code> matches the keyword, the token's class is
     * set.
     *
     * @param id3v2FrameBodyClass Class of keywords to match against.
     */

    public void matchAgainstKeyword(Class id3v2FrameBodyClass) {
        if (AbstractID3v2FrameBody.class.isAssignableFrom(id3v2FrameBodyClass)) {
            if (beforeComposite != null) {
                beforeComposite.matchAgainstKeyword(id3v2FrameBodyClass);
            }

            if (afterComposite != null) {
                afterComposite.matchAgainstKeyword(id3v2FrameBodyClass);
            }
        }
    }

    /**
     * Match all elements of this composite against the given tag. If any
     * element of <code>matchTag</code> matches any element of this tag's
     * composite, then this tag's composite leaf node's class is set.
     *
     * @param matchTag Tag to match against
     */

    public void matchAgainstTag(AbstractMP3Tag matchTag) {
        if (matchTag != null) {
            if (beforeComposite != null) {
                beforeComposite.matchAgainstTag(matchTag);
            }

            if (afterComposite != null) {
                afterComposite.matchAgainstTag(matchTag);
            }
        }
    }

    /**
     * Capitalize the word with the first letter upper case and all others
     * lower case.
     *
     * @param word word to capitalize.
     * @param keepUppercase if true, keep a word if it is already all in
     *        uppercase
     *
     * @return new capitalized word.
     */

    static private StringBuffer capitalizeWord(String word, boolean keepUppercase) {
        if (word == null) {
            return null;
        }

        StringBuffer wordBuffer = new StringBuffer();
        int          index = 0;

        if (keepUppercase && word.toUpperCase().equals(word)) {
            wordBuffer.append(word);
        } else {
            word = word.toLowerCase();

            int  len = word.length();
            char ch;
            ch = word.charAt(index);

            while (((ch < 'a') || (ch > 'z')) && (index < (len - 1))) {
                ch = word.charAt(++index);
            }

            if (index < len) {
                wordBuffer.append(word.substring(0, index));
                wordBuffer.append((char) (ch + uppercase));
                wordBuffer.append(word.substring(index + 1));
            } else {
                wordBuffer.append(word);
            }
        }

        return wordBuffer;
    }

    /**
     * Adjust this position.
     * This is useful in cases that an amount of text is inserted
     * or removed before this position.
     *
     * @param adjustment amount (either positive or negative) to adjust this position.
     * @return the DocPosition, adjusted properly.
     */

    public DocPosition adjustPosition(int adjustment){
        position += adjustment;
        return this;
    }

    /**
     * Two DocPositions are equal iff they have the same internal position.
     *
     * @return if this DocPosition represents the same position as another.
     */

    public boolean equals(Object obj){
        if (obj instanceof DocPosition){
            DocPosition d = (DocPosition)(obj);
            if (this.position == d.position){
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * A string representation useful for debugging.
     *
     * @return A string representing the position.
     */

    public String toString(){
        return "" + position;
    }

    /**
     * Does this Comparator equal another?
     * Since all DocPositionComparators are the same, they
     * are all equal.
     *
     * @return true for DocPositionComparators, false otherwise.
     */

    public boolean equals(Object obj){
    	return this == obj;
    }

    /**
     * Compare two DocPositions
     *
     * @param o1 first DocPosition
     * @param o2 second DocPosition
     * @return negative if first < second, 0 if equal, positive if first > second
     */

    public int compare(Object o1, Object o2){
        if (o1 instanceof DocPosition && o2 instanceof DocPosition){
            DocPosition d1 = (DocPosition)(o1);
            DocPosition d2 = (DocPosition)(o2);
            return (d1.getPosition() - d2.getPosition());
        } else if (o1 instanceof DocPosition){
            return -1;
        } else if (o2 instanceof DocPosition){
            return 1;
        } else if (o1.hashCode() < o2.hashCode()){
            return -1;
        } else if (o2.hashCode() > o1.hashCode()){
            return 1;
        } else {
            return 0;
        }
    }

	/**
	 * The colorer runs forever and may sleep for long periods of time. It
	 * should be interrupted every time there is something for it to do.
	 */

	public void run() {
		while(document.get() != null) {
			try {
				RecolorEvent re;
				synchronized (eventsLock) {
					// get the next event to process - stalling until the
					// event becomes available
					while(events.isEmpty() && document.get() != null) {
						// stop waiting after a second in case document
						// has been cleared.
						eventsLock.wait(1000);
					}
					re = (RecolorEvent) events.removeFirst();
				}
				processEvent(re.position, re.adjustment);
				Thread.sleep(100);
			} catch(Exception ex) { }
		}
	}

	/**
	 * Color or recolor the entire document
	 */

	public void colorAll() {
		color(0, getLength());
	}

	/**
	 * Color a section of the document. The actual coloring will start somewhere
	 * before the requested position and continue as long as needed.
	 * 
	 * @param position
	 *            the starting point for the coloring.
	 * @param adjustment
	 *            amount of text inserted or removed at the starting point.
	 */

	public void color(int position, int adjustment) {
		colorer.color(position, adjustment);
	}

    /**
     * Modifying the document while the reader is working is like
     * pulling the rug out from under the reader.  Alerting the
     * reader with this method (in a nice thread safe way, this
     * should not be called at the same time as a read) allows
     * the reader to compensate.
     */

    public void update(int position, int adjustment){
        if (position < this.position){
            if (this.position < position - adjustment){
                this.position = position;
            } else {
                this.position += adjustment;
            }
        }
    }

    /**
     * Has no effect.  This reader can be used even after
     * it has been closed.
     */

    public void close() {
    }

    /**
     * Save a position for reset.
     *
     * @param readAheadLimit ignored.
     */

    public void mark(int readAheadLimit){
        mark = position;
    }

    /**
     * This reader support mark and reset.
     *
     * @return true
     */

    public boolean markSupported(){
        return true;
    }

    /**
     * Read a single character.
     *
     * @return the character or -1 if the end of the document has been reached.
     */

    public int read(){
        if (position < document.getLength()){
            try {
                char c = document.getText((int)position, 1).charAt(0);
                position++;
                return c;
            } catch (BadLocationException x){
                return -1;
            }
        } else {
            return -1;
        }
    }

    /**
     * Read and fill the buffer.
     * This method will always fill the buffer unless the end of the document is reached.
     *
     * @param cbuf the buffer to fill.
     * @return the number of characters read or -1 if no more characters are available in the document.
     */

    public int read(char[] cbuf){
        return read(cbuf, 0, cbuf.length);
    }

    /**
     * Read and fill the buffer.
     * This method will always fill the buffer unless the end of the document is reached.
     *
     * @param cbuf the buffer to fill.
     * @param off offset into the buffer to begin the fill.
     * @param len maximum number of characters to put in the buffer.
     * @return the number of characters read or -1 if no more characters are available in the document.
     */

    public int read(char[] cbuf, int off, int len){
        if (position < document.getLength()){
            int length = len;
            if (position + length >= document.getLength()){
                length = document.getLength() - (int)position;
            }
            if (off + length >= cbuf.length){
                length = cbuf.length - off;
            }
            try {
                String s = document.getText((int)position, length);
                position += length;
                for (int i=0; i<length; i++){
                    cbuf[off+i] = s.charAt(i);
                }
                return length;
            } catch (BadLocationException x){
                return -1;
            }
        } else {
            return -1;
        }
    }

    /**
     * Skip characters of input.
     * This method will always skip the maximum number of characters unless
     * the end of the file is reached.
     *
     * @param n number of characters to skip.
     * @return the actual number of characters skipped.
     */

    public long skip(long n){
        if (position + n <= document.getLength()){
            position += n;
            return n;
        } else {
            long oldPos = position;
            position = document.getLength();
            return (document.getLength() - oldPos);
        }
    }

    /**
     * Seek to the given position in the document.
     *
     * @param n the offset to which to seek.
     */

    public void seek(long n){
        if (n <= document.getLength()){
            position = n;
        } else {
            position = document.getLength();
        }
    }

    /**
     * Checks this token to see if it is a reserved word.
     * Reserved words are explained in <A Href=http://java.sun.com/docs/books/jls/html/>Java
     * Language Specification</A>.
     *
     * @return true if this token is a reserved word, false otherwise
     */

    public boolean isReservedWord(){
        return((id >> 8) == 0x1);
    }

    /**
     * Checks this token to see if it is an identifier.
     * Identifiers are explained in <A Href=http://java.sun.com/docs/books/jls/html/>Java
     * Language Specification</A>.
     *
     * @return true if this token is an identifier, false otherwise
     */

    public boolean isIdentifier(){
        return((id >> 8) == 0x2);
    }

    /**
     * Checks this token to see if it is a literal.
     * Literals are explained in <A Href=http://java.sun.com/docs/books/jls/html/>Java
     * Language Specification</A>.
     *
     * @return true if this token is a literal, false otherwise
     */

    public boolean isLiteral(){
        return((id >> 8) == 0x3);
    }

    /**
     * Checks this token to see if it is a Separator.
     * Separators are explained in <A Href=http://java.sun.com/docs/books/jls/html/>Java
     * Language Specification</A>.
     *
     * @return true if this token is a Separator, false otherwise
     */

    public boolean isSeparator(){
        return((id >> 8) == 0x4);
    }

    /**
     * Checks this token to see if it is a Operator.
     * Operators are explained in <A Href=http://java.sun.com/docs/books/jls/html/>Java
     * Language Specification</A>.
     *
     * @return true if this token is a Operator, false otherwise
     */

    public boolean isOperator(){
        return((id >> 8) == 0x5);
    }

    /**
     * Checks this token to see if it is a comment.
     *
     * @return true if this token is a comment, false otherwise
     */

    public boolean isComment(){
        return((id >> 8) == 0xD);
    }

    /**
     * Checks this token to see if it is White Space.
     * Usually tabs, line breaks, form feed, spaces, etc.
     *
     * @return true if this token is White Space, false otherwise
     */

    public boolean isWhiteSpace(){
        return((id >> 8) == 0xE);
    }

    /**
     * Checks this token to see if it is an Error.
     * Unfinished comments, numbers that are too big, unclosed strings, etc.
     *
     * @return true if this token is an Error, false otherwise
     */

    public boolean isError(){
        return((id >> 8) == 0xF);
    }

    /**
     * A description of this token.  The description should
     * be appropriate for syntax highlighting.  For example
     * "comment" is returned for a comment.
     *
     * @return a description of this token.
     */

    public String getDescription(){
        if (isReservedWord()){
            return("reservedWord");
        } else if (id == METHOD){
            return("method");
        } else if (isIdentifier()){
            return("identifier");
        } else if (isLiteral()){
            return("literal");
        } else if (isSeparator()){
            return("separator");
        } else if (isOperator()){
            return("operator");
        } else if (isComment()){
            return("comment");
        } else if (isWhiteSpace()){
            return("whitespace");
        } else if (isError()){
            return("error");
        } else {
            return("unknown");
        }
    }

    /**
     * Closes the lookup service.
     */

    public void close() {
	try {
            file.close();
            file = null;
        }
        catch (Exception e) { }
    }

    /**
     * Returns the country the IP address is in.
     *
     * @param ipAddress String version of an IP address, i.e. "127.0.0.1"
     * @return the country the IP address is from.
     */

    public Country getCountry(String ipAddress) {
	InetAddress addr;
	try {
	    addr = InetAddress.getByName(ipAddress);
	}
	catch (UnknownHostException e) {
            return UNKNOWN_COUNTRY;
	}
	return getCountry(bytesToLong(addr.getAddress()));
    }

    /**
     * Returns true if the database is the premium version.
     *
     * @return true if the premium version of the database.
     */

    public boolean isPremium() {
        return info.indexOf("FREE") < 0;
    }

    /**
     * Returns the date of the database.
     *
     * @return the date of the database.
     */

    public Date getDate() {
        for (int i=0; i<info.length()-9; i++) {
            if (Character.isWhitespace(info.charAt(i))) {
                String dateString = info.substring(i+1, i+9);
                try {
                    synchronized (formatter) {
                        return formatter.parse(dateString);
                    }
                }
                catch (ParseException pe) {  }
                break;
            }
        }
        return null;
    }

    /**
     * Returns the country the IP address is in.
     *
     * @param ipAddress the IP address.
     * @return the country the IP address is from.
     */

    public Country getCountry(InetAddress ipAddress) {
        return getCountry(bytesToLong(ipAddress.getAddress()));
    }

    /**
     * Returns the ISO two-letter country code of this country.
     *
     * @return the country code.
     */

    public String getCode() {
        return code;
    }

    /**
     * Returns the country the IP address is in.
     *
     * @param ipAddress the IP address in long format.
     * @return the country the IP address is from.
     */

    public Country getCountry(long ipAddress) {
        if (file == null) {
            throw new IllegalStateException("Database has been closed.");
        }
        int ret = seekCountry(ipAddress) - COUNTRY_BEGIN;
        if (ret == 0) {
            return UNKNOWN_COUNTRY;
        }
        else {
            return new Country(countryCode[ret], countryName[ret]);
        }
    }

	/**
	 * The wizard owning this page is responsible for calling this method with the
	 * current selection. The selection is used to initialize the fields of the wizard 
	 * page.
	 * 
	 * @param selection used to initialize the fields
	 */

	public void init(IStructuredSelection selection) {
		IJavaElement jelem= getInitialJavaElement(selection);
		initContainerPage(jelem);
		initTypePage(jelem);
		doStatusUpdate();
	}

	/**
	 * This method is called upon plug-in activation
	 */

	public void start(BundleContext context) throws Exception {
	    System.out.println("Starting JMX Console UI");
		super.start(context);
		bundleContext = context;
	}

	/**
	 * This method is called when the plug-in is stopped
	 */

	public void stop(BundleContext context) throws Exception {
		super.stop(context);
		getPreferences().flush();
	}

	/**
	 * Get the root Preferences node
	 * @return
	 */

	public Preferences getPreferences() {
		IPreferencesService service = Platform.getPreferencesService();
		IEclipsePreferences root = service.getRootNode();
		return root.node(InstanceScope.SCOPE).node(getBundle().getSymbolicName());
	}

	/**
	 * Adds a child node to this node and sets its parent link 
	 * @param child node to be added to this node
	 */

	public void addChild(NodeAbstract child) {
		children.add(child);	
		child.setParent(this);
	}

	/**
	 * Removes a chlid node from this node and removes the parent link 
	 * @param child node to be removed from this node
	 */

	public void removeChild(NodeAbstract child) {
		children.remove(child);
		child.setParent(null);
	}

	/** 
	 * Checks if this TreeNode has chlidren
	 * @return true if this node has chlidren
	 */

	public boolean hasChildren() {
		return children.size() > 0;
	}

	/**
	 * Removes all Children form this node
	 *
	 */

	public void removeAllChildren () {
		children.clear();
	}

	/**
	 * Sets the parent of this node
	 * @param parent the new parent of this node
	 */

	public void setParent(NodeAbstract parent) {
		this.parent = parent;
	}

	/**
	 * Gets the parent node of this node
	 * @return the parent of this node
	 */

	public NodeAbstract getParent() {
		return parent;
	}

	/**
	 * Returns the adapter
	 * Required by the IAdaptable interface
	 */

	public Object getAdapter(Class key) {
	    if (key.equals(NodeAbstract.class))
	        return this;
		return null;
	}

	/**
	 * Add a new server to the model
	 * @param server server to add to the tree
	 */	

	public void addServer(NodeServer server) {
	    modelChangedEventDisabled = true;
		addChild(server);
		persistServer(server);
		modelChangedEventDisabled = false;
		emitModelChangeEvent(this);		
	}

    /**
	 * Disconnects and Removes a new server to the model
	 * @param server server to remove from the tree
	 */	

	public void removeServer(NodeServer server) {
		
		modelChangedEventDisabled = true;

		try { 
	    //    server.disconnect();
	    } catch (Exception e) {}
		removeChild(server);
		try {
		    Preferences modelPrefs = getModelPrefNode();
			modelPrefs.node(server.getName()).removeNode();
        } catch (BackingStoreException e) {
            System.out.println("Unable to save the model to disk: " + e.getMessage());
        }

		modelChangedEventDisabled = false;
		emitModelChangeEvent(this);	
	}

	/**
	 * Refeshes all Servers
	 * @throws NotConnectedException
	 * @throws CommunicationException
	 */

	public void refresh() throws Exception {
		modelChangedEventDisabled = true;
		Object[] servers = getChildren();
		for (int i = 0; i < servers.length;  i++) {
//			((ChatAppsServer) servers[i]).refresh();
		}
		modelChangedEventDisabled = false;
		emitModelChangeEvent(this);
	}

	/**
	 * This callback allows to create the viewer and initialize it.
	 */

	public void createPartControl(Composite parent) {
		// Create the tree viewer
		viewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);
		content = new ViewContentProvider(getViewSite(), model);
		viewer.setContentProvider(content);
		viewer.setLabelProvider(new ViewLabelProvider());
//		viewer.setSorter(new NameSorter());
		viewer.setInput(getViewSite());
		
		// Register with the model change listener
		model.addModelChangeListener(this);
		
		// Build the GUI
		makeActions();
		hookContextMenu();
		hookSelectionChangedAction();
		contributeToActionBars();
	}

	/**
	 * Hooks and registers the context menu 
	 *
	 */

	private void hookContextMenu() {
		MenuManager menuMgr = new MenuManager("#PopupMenu");
		menuMgr.setRemoveAllWhenShown(true);
		menuMgr.addMenuListener(new IMenuListener() {
			public void menuAboutToShow(IMenuManager manager) {
				ServerView.this.fillContextMenu(manager);
			}
		});
		Menu menu = menuMgr.createContextMenu(viewer.getControl());
		viewer.getControl().setMenu(menu);
		getSite().registerContextMenu(menuMgr, viewer);
	}

	/**
	 * Invokes the methods which fill the toolbar
	 *
	 */

	private void contributeToActionBars() {
		IActionBars bars = getViewSite().getActionBars();
		fillLocalPullDown(bars.getMenuManager());
		fillLocalToolBar(bars.getToolBarManager());
	}

	/**
	 * returns a control which consists of the ui elements of this page
	 */

	protected Control createContents(Composite parent) {
		IProject project = (IProject) (this.getElement().getAdapter(IProject.class));
		chatappsProject = ChatAppsPlugin.getChatAppsProject(project);  
				
		Composite composite = new Composite(parent, SWT.NULL);
		composite.setLayout(new GridLayout(3, false));
		composite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));

		createDomainName(composite);
		createFacadeClass(composite);
		return composite;
	}

	/**
	 * Fills the pulldown in the toolbar
	 * 
	 */

	private void fillLocalPullDown(IMenuManager manager) {
		manager.add((Action) actionMap.get(AddServerAction.ID));
//		manager.add((Action) actionMap.get(RemoveAction.ID));
//		manager.add((Action) actionMap.get(RefreshAction.ID));
		manager.add(new Separator());
	}

	/**
	 * performes the ok action for this property page
	 */

	public boolean performOk() {
		try {
			chatappsProject.setDomainName(txtDomainName.getText());
			chatappsProject.setFacadeClass(txtFacadeClass.getText());
			chatappsProject.saveProperties();
		} catch (Exception ex) {
			ChatAppsPlugin.log(ex.getMessage());
		}

		return true;
	}

	/**
	 * Fills the toolbar
	 * 
	 */

	private void fillLocalToolBar(IToolBarManager manager) {
		manager.add((Action) actionMap.get(AddServerAction.ID));
		manager.add(new Separator());
	}

	/**
	 * Defines the status of the available commands related to the tree entries
	 * Updates the detail view if a new server or domain is selected
	 * Registeres the listener for selection change evenets
	 */

	private void hookSelectionChangedAction() {
		final IWorkbenchPart workbenchPart = this;
		viewer.addSelectionChangedListener(new ISelectionChangedListener() {
			public void selectionChanged(SelectionChangedEvent sce) {
			    Iterator iter = actionMap.values().iterator();
			    while (iter.hasNext()) 
			        ((BaseAction) iter.next()).checkState();
			}
		});
	}

	/**
	 * Helper mothod for displaying messages
	 * @param message String to output
	 */

	private void showMessage(String message) {
		MessageDialog.openInformation(viewer.getControl().getShell(),
				"JMX Server View", message);
	}

	/**
	 * Sets this processor's set of characters triggering the activation of the
	 * completion proposal computation.
	 *
	 * @param activationSet the activation set
	 */

	public void setCompletionProposalAutoActivationCharacters(char[] activationSet) {
		fProposalAutoActivationSet= activationSet;
	}

	/**
	 * Adds a server to the model
	 * @param server to be added
	 */

	public void addServer (NodeServer server) {
		model.addServer(server);
	}

	/**
	 * Tells this processor to restrict its proposal to those element
	 * visible in the actual invocation context.
	 *
	 * @param restrict <code>true</code> if proposals should be restricted
	 */

	public void restrictProposalsToVisibility(boolean restrict) {
		Hashtable options= JavaCore.getOptions();
		Object value= options.get(VISIBILITY);
		if (value instanceof String) {
			String newValue= restrict ? ENABLED : DISABLED;
			if ( !newValue.equals(value)) {
				options.put(VISIBILITY, newValue);
				JavaCore.setOptions(options);
			}
		}
	}

	/**
	 * Tells this processor to order the proposals alphabetically.
	 *
	 * @param order <code>true</code> if proposals should be ordered.
	 */

	public void orderProposalsAlphabetically(boolean order) {
		fComparator.setOrderAlphabetically(order);
	}

	/**
	 * Removes the ModelChangedHandler
	 */

	public void dispose() {
//		model.removeModelChangeListener(this);
		super.dispose();
	}

	/**
	 * Tells this processor to restrict is proposals to those
	 * starting with matching cases.
	 *
	 * @param restrict <code>true</code> if proposals should be restricted
	 */

	public void restrictProposalsToMatchingCases(boolean restrict) {
		// not yet supported
	}

	/**
	 * Passing the focus request to the viewer's control.
	 */

	public void setFocus() {
		viewer.getControl().setFocus();
	}

    /**
     * Update the endabled/disabled state of this Action. 
     * Overwrite it, so that the action is enabled when it
     * makes sense
     */

    public  void checkState () {}

    /**
     * Defines the initial layout for the ChatApps perspective.  
     *
     * @param layout the factory used to add views to the perspective
     */

    public void createInitialLayout(IPageLayout layout) {
        defineActions(layout);
        defineLayout(layout);
    }

	/** Opens the url <a href="http://www.jgpd.com/">http://www.jgpd.com/</a>.
	 * 
	 * @see java.awt.event.ActionListener#actionPerformed(ActionEvent)
	 */

	public void actionPerformed(ActionEvent e) {

		try {		
			BrowserLauncher.openURL("http://www.jgpd.com/");		
		} catch (Exception ex){
			JOptionPane.showMessageDialog(graphpad, ex.toString(), Translator.getString("Error"), JOptionPane.ERROR_MESSAGE );
		}
		
	}

	/** Opens the url <a href="http://sourceforge.net/tracker/?func=add&group_id=90011&atid=592210">http://sourceforge.net/tracker/?func=add&group_id=90011&atid=592210</a>.
	 * 
	 * @see java.awt.event.ActionListener#actionPerformed(ActionEvent)
	 */

	public void actionPerformed(ActionEvent e) {

		try {		
			BrowserLauncher.openURL("http://sourceforge.net/tracker/?func=add&group_id=90011&atid=592210");		
		} catch (Exception ex){
			JOptionPane.showMessageDialog(graphpad, ex.toString(), Translator.getString("Error"), JOptionPane.ERROR_MESSAGE );
		}
		
	}

	/** Remove all nodes except the root node. */

	public void clear() {
		rootNode.removeAllChildren();
		treeModel.reload();
	}

	/** Remove the currently selected node. */

	public void removeCurrentNode() {
		TreePath currentSelection = tree.getSelectionPath();
		if (currentSelection != null) {
			DefaultMutableTreeNode currentNode = (DefaultMutableTreeNode)
						 (currentSelection.getLastPathComponent());
			MutableTreeNode parent = (MutableTreeNode)(currentNode.getParent());
			if (parent != null) {
				treeModel.removeNodeFromParent(currentNode);
				return;
			}
		} 

		// Either there was no selection, or the root was selected.
		// FIXME
	}

	/** Add child to the currently selected node. */

	public DefaultMutableTreeNode addObject(Object child) {
		DefaultMutableTreeNode parentNode = null;
		TreePath parentPath = tree.getSelectionPath();

		if (parentPath == null) {
			parentNode = rootNode;
		} else {
			parentNode = (DefaultMutableTreeNode)
						 (parentPath.getLastPathComponent());
		}

		return addObject(parentNode, child, true);
	}

	/**
	 * Handles events from the editor button and from
	 * the dialog's OK button.
	 */

	public void actionPerformed(ActionEvent e) {
		if (EDIT.equals(e.getActionCommand())) {
			//The user has clicked the cell, so
			//bring up the dialog.
//			button.setBackground(currentColor);
//			colorChooser.setColor(currentColor);
			//Set up the dialog that the button brings up.
			dialog = new File_PackageWizard(frame, // owner frame
											new String("File Selection Wizard"),
											600,  // width
											350,  // height
											5,   // number of wizard screens
											this);
			dialog.setModal(true);
			dialog.setVisible(true);

			//Make the renderer reappear.
			fireEditingStopped();

		}
	}

	/**
	 * Create a clone of the cell. The cloning of the
	 * user object is deferred to the cloneUserObject()
	 * method.
	 *
	 * @return Object  a clone of this object.
	 */

	public Object clone() {
		JGpdGraphCell c = (JGpdGraphCell) super.clone();
		return c;
	}

	/**
	 * Create a clone of the user object. This is provided for
	 * subclassers who need special cloning. This implementation
	 * simply returns a reference to the original user object.
	 *
	 * @return Object  a clone of this cells user object.
	 */

	protected Object cloneUserObject() {
		if (userObject instanceof ValueChangeHandler)
			return ((ValueChangeHandler) userObject).clone();
		return userObject;
	}

    /**
     * Returns the name of this algorithm.
     */

    public String toString() {
        return "Spring Embedded";
    }

    /**
     * returns the layout Algorithm
     */

    public LayoutAlgorithm getLayoutAlgorithm() {
        return new SpringEmbeddedLayoutAlgorithm();
    }

/**
 * Transforms a string value in a boolean value. The string has be "true" or
 * "false". Lower or upper case doesn't matter.
 * 
 * @param boolValue A String, consisting of the word "true" or "false".
 * @return The boolean expression of the string.
 */

    protected boolean isTrue(String boolValue){
        if( boolValue != null ){
            if( "TRUE".equals(boolValue.toUpperCase()) ){
                return true;
            }
            else if( "FALSE".equals(boolValue.toUpperCase()) ){
                return false;
            }
        }
        return false;
    }

    /** 
     * Called by pressing the cancel button. Leaves the dialog without
     * saving.
     */

    private void action_cancel() {
        setVisible(false);
        dispose();
        canceled = true;
    }

    /**
     * Returns true if the dialog has been canceled.
     */

    public boolean isCanceled() {
        return canceled;
    }

/**
 * Sets the initial Values, gained from the {@link #config configuration} 
 * into the Cells.
 * 
 * @return Because the progress dialog is allready visible during the 
 * initialisation, <b><code>true</code><b> is returned when cancel is pressed
 * on it.
 */

    private boolean initialize(){
        
        dlgProgress.setVisible(true);
        dlgProgress.setMessage(phaseName[PHASE_INITIALISATION]);
        
        int length = cellList.size();
        
        for( int i = 0; i < length; i++ ){
            
            CellView view = (CellView) cellList.get(i);
            
            initializeVertice(view);
            
            if( updateProgressDialog(PHASE_INITIALISATION,
                                     i,
                                     length) )
                                     
                return true; // canceled        
        }
        
        for( int i = 0; i < applyCellList.size(); i++ )
            computeLastImpulse( (CellView) applyCellList.get(i) );
            
        return false;    //not canceled
    }

/**
 * Sets the initial values for one Cell.
 * 
 * @param view Cell, the initial values should be set for.
 */

    private void initializeVertice(CellView view){
            Map attributes = view.getAttributes();
            if( attributes == null )
                attributes = new Hashtable();
                
            attributes.put(KEY_CAPTION,KEY_CAPTION);
            
            initPosition(view);                       

            if( isCluster(view) ){
                attributes.put(KEY_TEMPERATURE,
                               new Double(clusterInitTemperature));
            }
            else attributes.put(KEY_TEMPERATURE,
                                new Double(initTemperature));
            
            attributes.put(KEY_SKEWGAUGE,  new Double(0.0));
            attributes.put(KEY_CURRENT_IMPULSE,new Point2D.Double());
            attributes.put(KEY_LAST_IMPULSE   ,new Point2D.Double());
    }

/**
 * Helps updating the progress dialog.
 * 
 * @param phase Identifies the phase, the algorithmis doing.
 * @param round current round, the algorithm is performing
 * @param maxRound maximum number of rounds, the algorithm could perform
 */

    private boolean updateProgressDialog(int phase, int round, int maxRound){
        
        int lowValue = 0;
        if( phase != 0 ) 
            lowValue = phaseLength[phase-1];
        
        int maxValue = phaseLength[phase];
        
        int width = maxValue - lowValue;
        
        int value = lowValue+(int)(width*((double)round/(double)maxRound));
        
        dlgProgress.setValue(value);
        
        return dlgProgress.isCanceled();
    }

/**
 * Calculates the current impulse for the given cell.
 * 
 * @param view Cell, the current impulse should be calculated
 * @see #computeImpulse(CellView)
 */    

    private void computeCurrentImpulse(CellView view){
        
        //gets the impulse for view
        Point2D.Double impulse = computeImpulse(view);
        
        //set result into node
        view.getAttributes().put(KEY_CURRENT_IMPULSE,impulse);
    }

/**
 * Calculates the last impulse for the given cell. This is only nesessary while
 * initializing the cells.
 * 
 * @param view Cell, the last impulse should be calculated
 * @see #computeImpulse(CellView)
 */

    private void computeLastImpulse(CellView view){
        
        //gets the impulse for view
        Point2D.Double impulse = computeImpulse(view);
        
        //set result into node
        view.getAttributes().put(KEY_LAST_IMPULSE,impulse);
    }

    /** Closes the dialog 
     * @see #action_cancel
     * */

    private void closeDialog() {
        action_cancel();
    }

/**
 * Clears the temporary data from the cells in {@link #cellList} (all cells).
 */

    private void removeTemporaryLayoutDataFromCells(){
        
        for( int i = 0; i < cellList.size(); i++ )
            ((CellView)cellList.get(i)).getAttributes().clear();
    }

/**
 * Moves the graph to the upper left corner of the drawing space. This is done,
 * after a successfull run of the algorithm, to correct it's output.
 */

    private void correctCoordinates(){
        Rectangle boundingBox = getBoundingBox();
        if( boundingBox != null ){
            for( int i = 0; i < cellList.size(); i++ ){
                CellView view = (CellView) cellList.get(i);
                Point2D.Double pos = getPosition(view);
                Point2D.Double newPos = new Point2D.Double(
                                                      pos.x-boundingBox.getX(),
                                                      pos.y-boundingBox.getY());
                view.getAttributes().put(KEY_POSITION,newPos);
            }
        }
    }

/**
 * Computes the bounding box of the whole graph. The result is a Rectangle, 
 * parallel to the X- and Y-axises of the drawing system, closing about the 
 * whole graph.
 * @return Rectangle, that contains the whole graph.
 * @see #getBoundingBox(ArrayList) 
 */

    private Rectangle getBoundingBox(){
        return getBoundingBox(cellList);
    }

/**
 * Returns the temperature of a cell contained in a given list.
 * 
 * @param index Identifies the cell. This is the index of the cell in 
 * a given list of CellViews
 * @param list List containing only CellViews
 * @see #getAttribute(int,String,ArrayList)
 */

    private double getTemperature(int index, ArrayList list){
        
        Double temperature = (Double) getAttribute(index,KEY_TEMPERATURE,list);
        return temperature.doubleValue();
    }

/**
 * Method for Classes that extend this Algorithm. Will be called when performing
 * {@link #computeImpulse(CellView)}.
 */

    protected ArrayList getAdditionalForces(VertexView view){
        return new ArrayList();
    }

/**
 * Recalculates the position of a cluster. The position of a cluster is defined
 * by the barycenter of the clustered vertices.
 * 
 * @param cluster Cell, that has to be a cluster, should be repositioned.
 */

    protected void computeClusterPosition(VertexView cluster){
        ArrayList clusteredVertices = (ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);
        Point2D.Double clusterPos = computeBarycenter(clusteredVertices);
        cluster.getAttributes().put(KEY_POSITION,clusterPos);
    }

/**
 * Returns <code><b>true</b></code> when a cell is a cluster, else 
 * <code<b>false</b></code>. A cell is a cluster when it has under it's 
 * attributes a attribute with the boolean value <code><b>true</b></code> under
 * the key {@link #KEY_IS_CLUSTER}.
 * 
 * @param cell cell, that should be researched wheather it is a cluster or not.
 * @return <code><b>true</b></code> if cell is a cluster, else 
 * <code><b>false</b></code>.
 */

    protected boolean isCluster(CellView cell){
        if( cell.getAttributes().containsKey(KEY_IS_CLUSTER)){
            if( isTrue((String)cell.getAttributes().get(KEY_IS_CLUSTER))){
                return true;
            }
            else {
                System.err.println("FATAL ERROR: CELL CANNOT CLEARLY BE IDENTIFIED AS A CLUSTER!!!");
                return false;
            }        
        }
        else return false;        
    }

	/** calculates the attractive forces
	 */

	protected double fa(double x, double k) {
		double force = (x * x / k);
		return force;
	}

	/** calculates the repulsive forces
	 */

	protected double fr(double x, double k) {
		double force = (k * k) / x;
		return force;
	}

	/** Calculates the euklidische Norm
	 *  for the point p.
	 *
	 */

	protected double norm(Rectangle p) {
		double x = p.x;
		double y = p.y;
		double norm = Math.sqrt(x * x + y * y);
		return norm;
	}

    /** Called by pressing the ok button
     *
     */

    private void action_ok() {
        try {
            Integer.parseInt(horizontalSpacingTextField.getText());
            Integer.parseInt(verticalSpacingTextField.getText());
        } catch (Exception e) {
			String message = Translator.getString("Error.SpacingMustBeNumbers"/*#Finished:Original="Spacing must be numbers"*/);
            JOptionPane.showMessageDialog(this, message, Translator.getString("Error"), JOptionPane.INFORMATION_MESSAGE);
            return;
        }
        setVisible(false);
        dispose();
        canceled = false;
    }

    /**
     * Returns true if the dialog has been canceled.
     */

    public boolean canceled() {
        return canceled;
    }

    /**
     * Returns the value of the "Horizontal spacing" as text.
     */

    public String getIndention() {
        return horizontalSpacingTextField.getText().trim();
    }

    /**
     * Returns the value of the "Vertical spacing" as text.
     */

    public String getVerticalSpacing() {
        return verticalSpacingTextField.getText().trim();
    }

    /**
     * Set the value of the "Horizontal spacing" text field.
     */

    public void setIndention(String text) {
        horizontalSpacingTextField.setText(text);
    }

    /**
     * Set the value of the "Vertical Spacing" text field.
     */

    public void setVerticalSpacing(String text) {
        verticalSpacingTextField.setText(text);
    }

/**
 * Runs the Algorithm as a optimization Algorithm of another Algorithm
 * @param applyList List of all Cells, a new Layout should be found for.
 * @param allCellList List of all Cells of the Graph
 * @param allEdgeList List of all Edges of the Graph
 * @param dialog Progress Dialog of the Algorithm, this Algorithm is a 
 * Optimizer for.
 * @return when Cancel is pressed during the optimization, the method returns
 * <code><b>true</b></code>, else, for a successfull run, 
 * <code><b>false</b></code>.
 */

    public boolean performOptimization(ArrayList applyList, ArrayList allCellList, ArrayList allEdgeList, Properties config, ProgressDialog dialog){
        cellList  = allCellList;
        applyCellList = applyList;
        edgeList = allEdgeList;
        
        presetConfig = config;
        
        dlgProgress = dialog;
        initProgressValue = dialog.getValue();

        loadConfiguration(CONFIG_KEY_RUN);
        
        init(false);
        boolean isCancled = run();
        
        return isCancled;
    }

/**
 * Method of classes extending this class, that want to load their initial
 * values from the configuration.
 * 
 * @param configSwitch Determines which configurationvalues have to be loaded
 * Possible values are {@link #CONFIG_KEY_RUN} and 
 * {@link #CONFIG_KEY_LAYOUT_UPDATE}
 * @see #loadConfiguration(int)
 */

    protected void loadAdditionalConfiguration(int configSwitch){
    }

/**
 * Removes the temporary Data from the Cells of the graph. During the run of the
 * Algorithm there has been plenty of Data stored in the Cells. These are
 * removed here, if the Algorithm is canceled or finished.
 */

    private void removeTemporaryData(){
        for( int i = 0; i < applyCellList.size(); i++ )
            ((CellView)applyCellList.get(i)).getAttributes().clear();        
    }

/**
 * Runs the Algorithm until {@link #temperature} is lower than 
 * {@link #minTemperature} or cancel on the progressdialog is pressed.
 * 
 * @return When the Algorithm is Canceled, the Method breaks and returns 
 * <code><b>true</b></code>.
 */

    private boolean run(){
        boolean isCancled = false;
        while( round <= maxRounds && !isCancled)
            isCancled = performRound();
        return isCancled;
    }

/**
 * Method for classes that extends this Algorithm. Calls the Costfunctions of
 * the extending class.
 * @return costs generated with the additional costfunctions
 * @see #getGlobalCosts(double[])
 */

    protected double getAdditionalCosts(int cfConfig, double[] lambda){
        return 0.0;
    }

/**
 * Calculates a break condition for {@link #performRound()} if uphill moves
 * are allowed. This is computed by a formular from Bolzman:<p>
 * <blockquote><blockquote><code>
 * random < e^(oldEnergy-newEnergy)
 * </code></blockquote></blockquote>
 * @param oldEnergy The Energy before the Energy has increased, so it's the 
 * lower one, of the two values.
 * @param newEnergy The Energy after the Energy has increased, so it's the
 * higher one, of the two values
 * @return sometimes <code><b>true</b></code> when the random number is
 * smaler than <code>e^(oldEnergy-newEnergy)</code>
 */

    private boolean getBolzmanBreak(double oldEnergy, double newEnergy){
        return Math.random() < Math.pow(Math.E,(oldEnergy-newEnergy)/temperature);
    }

/**
 * Calculates the maximal number of rounds, by flattening the actual 
 * {@link #temperature} with the temperature scaling factor 
 * {@link #tempScaleFactor}
 * 
 * @param actualTemperature The Temperature of the actual Graph
 * @return The number of Rounds that have to be performed until 
 * {@link #temperature} falls under {@link #minTemperature}.
 */

    private int getMaxRoundsByTemperature(double actualTemperature){
        return (int)Math.ceil( Math.log(minTemperature/actualTemperature) /
                                Math.log(tempScaleFactor));
    }

/**
 * Returns all Edges that are connected with cells, member of 
 * {@link #applyCellList}, except the edges connected the the given cell.
 * @param except Edges connected to this cell are not of interest
 * @return List of all interesting Edges
 */

    private ArrayList getRelevantEdges(CellView except){
        ArrayList relevantEdgeList = new ArrayList();
        for( int i = 0; i < edgeList.size(); i++ ){
            CellView view = ((EdgeView)edgeList.get(i)).getSource().getParentView();
            if( view != except &&
                applyCellList.contains(view) ){
                relevantEdgeList.add(edgeList.get(i));
            }
            else {
                view = ((EdgeView)edgeList.get(i)).getTarget().getParentView();
                if( view != except &&
                    applyCellList.contains(view) ){
                    relevantEdgeList.add(edgeList.get(i));
                }
            }
        }
        return relevantEdgeList;
    }

/**
 * Sets the position of a CellView to the given Position
 * 
 * @param view The CellView, the position should be set
 * @param pos New Position
 * @see #setAttribute(CellView,String,Object)
 */

    private void setPosition(CellView view, Point2D.Double pos){
        setAttribute(view,KEY_POSITION,pos);
    }

/**
 * Sets the position of a CellView member of {@link #applyCellList} to the given
 * position.
 * 
 * @param index ID of the CellView in {@link #applyCellList}
 * @param x X-Coordinate of the new position
 * @param y Y-Coordinate of the new position
 * @see #setPosition(CellView,double,double)
 */

    private void setPosition(int index, double x, double y){
        setPosition((CellView)applyCellList.get(index),x,y);
    }

/**
 * Sets the position of a CellView to the given Position
 * 
 * @param view The CellView, the position should be set
 * @param x X-Coordinate of the new position
 * @param y Y-Coordinate of the new position
 * @see #setPosition(CellView,Point2D.Double)
 */

    private void setPosition(CellView view, double x, double y){
        setPosition(view,new Point2D.Double(x,y));
    }

/**
 * Sets an attribute in a CellView
 * 
 * @param view CellView, the attribute should be set
 * @param key The attribute will be stored in the CellView under that key.
 * @param obj Object representing the attribute, that should be stored.
 */

    private void setAttribute(CellView view,String key, Object obj){
        if( view.getAttributes() == null )
            view.setAttributes(new Hashtable());
        Map attributes = view.getAttributes();
        attributes.put(key,obj);
    }

/**
 * Returns an attribute from a CellView
 * 
 * @param view CellView, that stores the attribute
 * @param key The attribute is stored in the CellView with this key
 * @return Object stored with the given key in the given CellView
 */

    private Object getAttribute(CellView view, String key){
        return view.getAttributes().get(key);
    }

/**
 * Retrieves the Cells that are directly connected to the given Cell and
 * member of the given list.
 * @param list Only relatives from this List are allowed
 * @param view Relatives from this view are requested
 * @return Relatives from view that are in the list
 * @see #getRelatives(CellView)
 */

    protected ArrayList getRelativesFrom(ArrayList list, CellView view){
        ArrayList relatives = getRelatives(view);
        ArrayList result    = new ArrayList();
        for( int i = 0; i < relatives.size(); i++ )
            if( list.contains(relatives.get(i)) )
                result.add(relatives.get(i));
        return result;
    }

        /** initializes the dialog
         */

        protected void init() {
                // netbeans
                initComponents();

                // fill the list
                fillList();

                // select the first one
                try {
                        lstLayoutControllers.setSelectedIndex(0);
                } catch (Exception e) {
                }
        }

        /** Fills the List with the LayoutControllers
         *  from the LayoutRegistry.
         *  
         *  @see LayoutRegistry
         */

        protected void fillList() {
                try {
                        DefaultListModel model = new DefaultListModel();
                        Iterator all = LayoutRegistry.registeredLayoutControllers();

                        while (all.hasNext()) {
                                LayoutController controller = (LayoutController) all.next();
                                model.addElement(controller);
                        }
                        
                        
                        lstLayoutControllers.setModel(model);
                } catch (Exception e) {
                        e.printStackTrace();
                }
        }

        /** Will call if the user cancels the dialog
         *
         */

        protected void cancel() {
                canceled = true;
                setVisible(false);
                dispose();
        }

        /** Will call if the user finishs the dialog
         *
         */

        protected void finish() {
                canceled = false;
                setVisible(false);
                dispose();
        }

        /** Will call if the user clicks on the configuration button.
         *  if the layout controller is configurable the method
         *  calls the configure method at the controller.
         * 
         *  @see LayoutController#configure
         *
         */

        protected void configure() {
                try {
                        LayoutController controller =
                                (LayoutController) lstLayoutControllers.getSelectedValue();
                        if (!controller.isConfigurable()) {
                                String message = Translator.getString("Error.ThisLayoutCannotBeConfigured"); /*#Finished: "This Layout cannot be configured."*/
                                JOptionPane.showMessageDialog(
                                        this,
                                        message,
                                        null,
                                        JOptionPane.INFORMATION_MESSAGE);
                                return;
                        }
                        controller.configure();
                } catch (Exception e) {
                        e.printStackTrace();
                }
        }

        /** Returns the selected 
         *  LayoutController of null if
         *  no LayoutController was selected
         *
         */

        public LayoutController getSelectedLayoutController() {
                try {
                        return (LayoutController) lstLayoutControllers.getSelectedValue();
                } catch (Exception e) {
                        return null;
                }
        }

        /** calls the cancel method
         *  @see #cancel
         */

        protected void closeDialog(
                java.awt.event.WindowEvent evt) { //GEN-FIRST:event_closeDialog
                cancel();
        } //GEN-LAST:event_closeDialog

	/** Debugdisplay for the edge crosses indicators on the System out
	 */

	protected void displayEdgeCrossesValues(Vector levels) {
		System.out.println("----------------Edge Crosses Indicator Values"
		/*#Frozen*/
		);

		for (int i = 0; i < levels.size() - 1; i++) {
			// Get the current level
			Vector currentLevel = (Vector) levels.get(i);
			System.out.print("Level (" + i + "):" /*#Frozen*/
			);
			for (int j = 0; j < currentLevel.size(); j++) {
				CellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);

				System
					.out
					.print(
						NumberFormat.getNumberInstance().format(
							sourceWrapper.getEdgeCrossesIndicator())
						+ " - " /*#Frozen*/
				);
			}
			System.out.println();
		}
	}

	/** Debugdisplay for the grid positions on the System out
	 */

	protected void displayGridPositions(Vector levels) {

		System.out.println("----------------GridPositions" /*#Frozen*/
		);

		for (int i = 0; i < levels.size() - 1; i++) {
			// Get the current level
			Vector currentLevel = (Vector) levels.get(i);
			System.out.print("Level (" + i + "):" /*#Frozen*/
			);
			for (int j = 0; j < currentLevel.size(); j++) {
				CellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);
				System
					.out
					.print(
						NumberFormat.getNumberInstance().format(
							sourceWrapper.getGridPosition())
						+ " - " /*#Frozen*/
				);
			}
			System.out.println();
		}
	}

	/** Debugdisplay for the priorities on the System out
	 */

	protected void displayPriorities(Vector levels) {

		System.out.println("----------------down Priorities" /*#Frozen*/
		);

		for (int i = 0; i < levels.size() - 1; i++) {
			// Get the current level
			Vector currentLevel = (Vector) levels.get(i);
			System.out.print("Level (" + i + "):" /*#Frozen*/
			);
			for (int j = 0; j < currentLevel.size(); j++) {
				CellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);
				System.out.print(sourceWrapper.getPriority() +
				/*" (" +
				                   sourceWrapper.nearestDownNeighborLevel + ") " +*/
				" - " /*#Frozen*/
				);
			}
			System.out.println();
		}
	}

	/** Updates the progress based on the movements count
	 *
	 */

	protected void updateProgress4Movements() {
		// adds the current loop count
		movements.add(new Integer(movementsCurrentLoop));
		iteration++;

		// if the current loop count is higher than the max movements count
		// memorize the new max
		if (movementsCurrentLoop > movementsMax) {
			movementsMax = movementsCurrentLoop;
		}

		// Calculate the new progress
		if (movements.size() > 1) {
			dlgProgress.setValue(movements.size() - 1);
		}
	}

	/** sets the minimum value to the progressbar
	 */

	public void setMinimum(int min) {
		pbProgressSum.setMinimum(min);
	}

	/** sets the maximum value to the progressbar
	 */

	public void setMaximum(int max) {
		pbProgressSum.setMaximum(max);
	}

	/** sets the progressbar to the maximumvalue
	 */

	public void setToMaximum() {
		setValue(pbProgressSum.getMaximum());
	}

	/**
	 * Returns whether or not the specified data flavor is supported for
	 * this object.
	 * @param flavor the requested flavor for the data
	 * @return boolean indicating whether or not the data flavor is supported
	 */

	public boolean isDataFlavorSupported(DataFlavor flavor) {
		DataFlavor[] flavors = getTransferDataFlavors();
		for (int i = 0; i < flavors.length; i++) {
			if (flavors[i].equals(flavor)) {
				return true;
			}
		}
		return false;
	}

	/** sets the specified value to the progressbar
	 */

	public void setValue(int value) {
		pbProgressSum.setValue(value);

		lblProgressSumVal.setText(
			java.text.NumberFormat.getInstance().format(
				Math.round(pbProgressSum.getPercentComplete() * 100))
				+ "%");
	}

	/** returns the current value from the progressbar
	 */

	public int getValue() {
		return pbProgressSum.getValue();
	}

	/** sets the progress message
	 */

	public void setMessage(String message) {
		lblMessage.setText(message);
	}

	/** returns true if the user
	 *  has clicked on the cancel button
	 */

	public boolean isCanceled() {
		return isCanceled;
	}

	/**
	 * Returns whether or not the specified data flavor is an HTML flavor that
	 * is supported.
	 * @param flavor the requested flavor for the data
	 * @return boolean indicating whether or not the data flavor is supported
	 */

	protected boolean isHTMLFlavor(DataFlavor flavor) {
		DataFlavor[] flavors = htmlFlavors;
		for (int i = 0; i < flavors.length; i++) {
			if (flavors[i].equals(flavor)) {
				return true;
			}
		}
		return false;
	}

	/** sets the cancel button visible or not
	 *
	 *  @param visible the parameter specifies state
	 */

	public void setCancelVisible(boolean visible) {
		cmdCancel.setVisible(visible);
	}

	/**
	 * Should the HTML flavors be offered?  If so, the method
	 * getHTMLData should be implemented to provide something reasonable.
	 */

	protected boolean isHTMLSupported() {
		return false;
	}

	/** sets the cancel button enabled or not
	 *
	 *  @param visible the parameter specifies state
	 */

	public void setCancelEnabled(boolean enabled) {
		cmdCancel.setEnabled(enabled);
	}

	/** Returns the cancel button
	 */

	public JButton getCancelButton() {
		return cmdCancel;
	}

	/**
	 * Fetch the data in a text/html format
	 */

	protected String getHTMLData() {
		return null;
	}

	/**
	 * called to save the state of a component in case it needs to
	 * be restored because a drop is not performed.
	 */

	protected void saveComponentState(JComponent c) {
	}

	/**
	 * Returns whether or not the specified data flavor is an plain flavor that
	 * is supported.
	 * @param flavor the requested flavor for the data
	 * @return boolean indicating whether or not the data flavor is supported
	 */

	protected boolean isPlainFlavor(DataFlavor flavor) {
		DataFlavor[] flavors = plainFlavors;
		for (int i = 0; i < flavors.length; i++) {
			if (flavors[i].equals(flavor)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * called to restore the state of a component in case a drop
	 * is not performed.
	 */

	protected void restoreComponentState(JComponent c) {
	}

	/**
	 * Should the plain text flavors be offered?  If so, the method
	 * getPlainData should be implemented to provide something reasonable.
	 */

	protected boolean isPlainSupported() {
		return false;
	}

	/**
	 * called to restore the state of a component in case a drop
	 * is performed.
	 */

	protected void restoreComponentStateForDrop(JComponent c) {
	}

	/**
	 * called to set the insertion location to match the current
	 * mouse pointer coordinates.
	 */

	protected void updateInsertionLocation(JComponent c, Point p) {
	}

	/**
	 * Fetch the data in a text/plain format.
	 */

	protected String getPlainData() {
		return null;
	}

	/**
	 * Initializes the internal properties if they haven't been already
	 * inited. This is done lazily to avoid loading of desktop properties.
	 */

	private void initPropertiesIfNecessary() {
		if (timer == null) {
			Toolkit t = Toolkit.getDefaultToolkit();
			Integer initial = new Integer(100);
			Integer interval = new Integer(100);

			try {
				initial =
					(Integer) t.getDesktopProperty(
						"DnD.Autoscroll.initialDelay");
			} catch (Exception e) {
				// ignore
			}
			try {
				interval =
					(Integer) t.getDesktopProperty("DnD.Autoscroll.interval");
			} catch (Exception e) {
				// ignore
			}
			timer = new Timer(interval.intValue(), this);

			timer.setCoalesce(true);
			timer.setInitialDelay(initial.intValue());

			try {
				hysteresis =
					((Integer) t
						.getDesktopProperty("DnD.Autoscroll.cursorHysteresis"))
						.intValue();
			} catch (Exception e) {
				// ignore
			}
		}
	}

	/**
	 * Returns whether or not the specified data flavor is a String flavor that
	 * is supported.
	 * @param flavor the requested flavor for the data
	 * @return boolean indicating whether or not the data flavor is supported
	 */

	protected boolean isStringFlavor(DataFlavor flavor) {
		DataFlavor[] flavors = stringFlavors;
		for (int i = 0; i < flavors.length; i++) {
			if (flavors[i].equals(flavor)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Cleans up internal state after the drop has finished (either succeeded
	 * or failed).
	 */

	private void cleanup() {
		if (timer != null) {
			timer.stop();
		}
		component = null;
		lastPosition = null;
	}

	/**
	 * Sets the GraphModel. This invokes <code>updateSize</code>.
	 */

	protected void setModel(GraphModel model) {
		cancelEditing(graph);
		if (graphModel != null && graphModelListener != null)
			graphModel.removeGraphModelListener(graphModelListener);
		graphModel = model;
		if (graphModel != null && graphModelListener != null)
			graphModel.addGraphModelListener(graphModelListener);
		if (graphModel != null) // jmv : to avoid NullPointerException 
			updateSize();
	}

	/** Creates a frame for this Graphpad panel
	 *
	 */

	protected JFrame createFrame() {
		/*
		JFrame frame = new JFrameP() {
			public String getInstanceID() {
				return this.getClass().getName();
			}
			public String getNameSpace() {
				return "JGraphPad";
			}
		};
		*/
		GPFrame gpframe = new GPFrame();
		gpframe.setName("MainGraphpad");

		return gpframe;
	}

	/**
	 * Sets the GraphLayoutCache (geometric pattern).
	 * This invokes <code>updateSize</code>.
	 */

	protected void setGraphLayoutCache(GraphLayoutCache view) {
		cancelEditing(graph);
		if (graphLayoutCache != null && graphViewObserver != null)
			graphLayoutCache.deleteObserver(graphViewObserver);
		graphLayoutCache = view;
		if (graphLayoutCache != null && graphViewObserver != null)
			graphLayoutCache.addObserver(graphViewObserver);
		updateSize();
	}

	/**
	 * Sets the marquee handler.
	 */

	protected void setMarquee(BasicMarqueeHandler marqueeHandler) {
		marquee = marqueeHandler;
	}

	/** Returns the current Action Map
	 */

	public ActionMap getCurrentActionMap() {
		return currentActionMap;
	}

	/**
	 * Find the hosting frame, for the file-chooser dialog.
	 */

	public Frame getFrame() {
		for (Container p = getParent(); p != null; p = p.getParent()) {
			if (p instanceof Frame) {
				return (Frame) p;
			}
		}
		return null;
	}

	/**
	 * Resets the selection model. The appropriate listeners are installed
	 * on the model.
	 */

	protected void setSelectionModel(GraphSelectionModel newLSM) {
		cancelEditing(graph);
		if (graphSelectionListener != null && graphSelectionModel != null)
			graphSelectionModel.removeGraphSelectionListener(
				graphSelectionListener);
		graphSelectionModel = newLSM;
		if (graphSelectionModel != null && graphSelectionListener != null)
			graphSelectionModel.addGraphSelectionListener(
				graphSelectionListener);
		if (graph != null)
			graph.repaint();
	}

	/**
	 * Returns the handle that is currently active, or null, if no
	 * handle is currently active. Typically, the returned objects
	 * are instances of the RootHandle inner class.
	 */

	public CellHandle getHandle(JGraph graph) {
		return handle;
	}

	/** Show a dialog with the given error message.
	 * */

	public void error(String message) {
		JOptionPane.showMessageDialog(
			this,
			message,
			appTitle,
			JOptionPane.ERROR_MESSAGE);
	}

	/**
	 * Returns the current graph.
	 * @return GPGraph
	 */

	public GPGraph getCurrentGraph() {
		GPDocument doc = getCurrentDocument();
		if (doc == null)
			return null;
		return doc.getGraph();
	}

	/**
	 * Returns the cell that has the focus.
	 */

	protected Object getFocusedCell() {
		if (focus != null)
			return focus.getCell();
		return null;
	}

	/**
	 * Returns the current export model.
	 * @return GPGraph
	 */

	public ModelExportImpl getExportModel() {
		GPDocument doc = getCurrentDocument();
		if (doc == null)
			return null;
		return doc.getExportModel();
	}

	/**
	 * Returns the currently selected internal frame
	 * If no one is selected, then the first one will be select.
	 *
	 * @return GPDocument
	 */

	public JInternalFrame getCurrentInternalFrame() {
		GPInternalFrame internalFrame =
			(GPInternalFrame) desktop.getSelectedFrame();
		if (internalFrame == null) {
			JInternalFrame[] frames = desktop.getAllFrames();
			if (frames.length > 0) {
				try {
					frames[0].setSelected(true);
					internalFrame = (GPInternalFrame) frames[0];
				} catch (PropertyVetoException e) {
					return null;
				}
			}
		}
		if (internalFrame == null)
			return null;
		return internalFrame;
	}

