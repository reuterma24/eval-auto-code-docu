{
    "321": "\tpublic int getPushesLowerbound() {\n\t\treturn pushesLowerbound;\n\t}\n",
    "323": "\tpublic void setPushesLowerbound(int pushesLowerbound) {\n\t\tthis.pushesLowerbound = pushesLowerbound;\n\t}\n",
    "324": "\t\tpublic void play() {\n\t\t\t\n\t\t\t// If no sound file is there nothing can be played.\n\t\t\tif(currentSoundFilename.equals(\"\"))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// Check if the this sound must be read from another file (the user has\n\t\t\t// chosen another sound to be played).\n\t\t\tString settingsFileName = Settings.get(soundSettingsKey);\n\t\t\tif(!currentSoundFilename.equals(settingsFileName)) {\n\t\t\t\tloadClip(settingsFileName);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Stop the currently playing sound to play the new sound if necessary.\n\t\t\tif (clip.isRunning()) {\n\t\t\t\tclip.stop();\n\t\t\t}\n\t\t\t\n\t\t\t// Rewind to the beginning.\n\t\t\tclip.setFramePosition(0); \n\t\t\t\n\t\t\t// Start playing.\n\t\t\tclip.start();    \n\t\t}\n",
    "343": "\tpublic int getInfluenceValue(int boxNo1, int boxNo2) {\n\t\treturn influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),\n\t\t\t\t                               board.boxData.getBoxPosition(boxNo2) );\n\t}\n",
    "351": "\tpublic void setPositions(int[] positions){\n\t\tthis.positions = positions;\n\t}\n",
    "352": "\tpublic int getPlayerPosition() {\n\t\treturn positions[positions.length-1];\n\t}\n",
    "355": "\tpublic int getPulledBoxNumber() {\n\t\treturn pulledBoxNo;\n\t}\n",
    "357": "\tpublic int getStartBoxPosition() {\n\t\treturn startPosition;\n\t}\n",
    "359": "\tpublic int getTargetBoxPosition() {\n\t\treturn targetPosition;\n\t}\n",
    "361": "    public BoardPositionPackingSequence getPrecedingBoardPosition() {\n    \treturn precedingBoardPosition;\n    }\n",
    "364": "\tpublic int compareTo(BoardPositionPackingSequence boardPosition) {\n\t\treturn boardPosition.getRelevance() - getRelevance();\n\t}\n",
    "373": "\tpublic boolean isForcedPush() {\n\t\treturn isPushForced;\n\t}\n",
    "376": "\tfinal public void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "412": "\tpublic boolean isSolverStoppedDueToOutOfMemory() {\n\t\treturn isSolverStoppedDueToOutOfMemory;\n\t}\n",
    "428": "    final protected IBoardPositionMoves getBestBoardPosition(){\n\n\t\t// Nimmt die Liste aller Stellungen mit einer bestimmten L\u00f6sungspfadl\u00e4nge auf\n\t\tLinkedList<IBoardPositionMoves> boardPositionList;\n\t\t\n\t\tfor(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {\n\t\t\n\t\t\t// Liste der Stellungen mit der aktuellen Pfadl\u00e4nge holen. \n\t\t\tboardPositionList = boardPositionQueue.get(solutionLength);\n\t\t\t\n\t\t\tif(boardPositionList.size() > 0){\t \n\t\t\t    shortestSolutionPathLength = solutionLength;\n\t\t\t    \n\t\t\t\t// Die zuletzt eingef\u00fcgte Stellung zur\u00fcckgeben\n\t    \t\treturn boardPositionList.removeLast();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "437": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn precedingBoardPosition;\n\t}\n",
    "440": "\tfinal public int getDirection() {\n\t\treturn positionData >>> 13;\n\t}\n",
    "442": "\tpublic int getBoxNo() {\n\t\treturn positionData & ((1 << 10) - 1);\n\t}\n",
    "445": "\tprotected String creatorName() {\n\t\treturn Texts.getText(\"solver\");\n\t}\n",
    "446": "\tfinal public int getPlayerPosition() {\n\t\treturn playerPosition;\n\t}\n",
    "448": "\tfinal public void setPositions(int[] positions) {\n\t\tthis.positions = positions;\n\t}\n",
    "450": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn null;\n\t}\n",
    "454": "\tfinal public void setSearchDirection(SearchDirection searchDirection) {\n\n\t\tif (searchDirection == SearchDirection.FORWARD) {\n\t\t\tforwardsSearch  = true;\n\t\t} else {\n\t\t\tbackwardsSearch = true;\n\t\t}\n\t}\n",
    "458": "\tfinal public int getDirection() {\n\t\treturn 0;\n\t}\n",
    "459": "\tpublic int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (BoardPosition currentBoardPosition = this; currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition()) {\n\t\t\tif (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn pushesCount;\n\t}\n",
    "461": "\tfinal public int getBoxNo() {\n\t\treturn NO_BOX_PUSHED;\n\t}\n",
    "463": "\tpublic void setMaximumSolutionLength(short maximumSolutionLength) {\n\t\tmaximumPushesCurrentIteration = maximumSolutionLength;\n\t}\n",
    "464": "\tfinal public int getPlayerPosition() {\n\t\treturn positions[boxCount];\n\t}\n",
    "466": "\tpublic short getMaximumSolutionLength() {\n\t\treturn maximumPushesCurrentIteration;\n\t}\n",
    "467": "\tfinal public int getPushesCount() {\n\t\treturn 0;\n\t}\n",
    "472": "\tprotected String solutionByMeAt(Date date) {\n\t\treturn  Texts.getText(\"createdBy\")\n\t\t      + \" \" + creatorName()\n\t\t      + \" \" + Utilities.dateString(date);\n\t}\n",
    "476": "\tfinal public void setMovesCount(int movesCount) {\n\t\tthis.movesCount = (short) movesCount;\n\t}\n",
    "487": "\tpublic int getIndexPackingSequence() {\n\t\treturn indexPackingSequence;\n\t}\n",
    "489": "\tpublic void setIndexPackingSequence(int indexPackingSequence) {\n\t\tthis.indexPackingSequence = indexPackingSequence;\n\t}\n",
    "494": "\tprotected boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "496": "\tfinal public boolean isBoxInactive() {\n\t\treturn (positionData & INACTIVE_BOX) > 0;\n\t}\n",
    "497": "\tpublic void setCorralDeadlock() {\n\t\tisDeadlock = true;\n\t}\n",
    "498": "\tpublic void setNotCorralDeadlock() {\n\t\tisNotDeadlock = true;\n\t}\n",
    "499": "\t\tpublic boolean getValue() {\n\t\t\t/*\n\t\t\t * Since we here are inside of class Settings, we should not get\n\t\t\t * an IllegalAccessException.\n\t\t\t * Hence, we catch the exceptions here, and return false,\n\t\t\t * just in case.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\treturn field.getBoolean(null);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "500": "\tprotected String solutionByMeNow() {\n\t\treturn solutionByMeAt(null);\n\t}\n",
    "501": "\tpublic void setCorralNo(int corralNo) {\n\t\tthis.corralNo = corralNo;\n\t}\n",
    "503": "\tpublic void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "504": "\tpublic int getCorralNo() {\n\t\treturn corralNo;\n\t}\n",
    "506": "\tpublic boolean isCorralDeadlock() {\n\t\treturn isDeadlock;\n\t}\n",
    "507": "\tpublic boolean isNotCorralDeadlock() {\n\t\treturn isNotDeadlock;\n\t}\n",
    "508": "\tpublic boolean isClassified() {\n\t\treturn isDeadlock || isNotDeadlock;\n\t}\n",
    "510": "\tpublic boolean isBeeingAnalyzed() {\n\t\treturn !isDeadlock && !isNotDeadlock;\n\t}\n",
    "513": "\tpublic CBoard getClone() {\n\t\treturn new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);\n\t}\n",
    "514": "\t\tpublic void setValue(boolean value) {\n\t\t\t/*\n\t\t\t * Regarding exceptions see comment in \"getValue\"\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tfield.setBoolean(null, value);\n\t\t\t\tSystem.out.println(\"Setting: DebugVar: \"+field.getName()+\" set to \"+value);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// well... forget it.\n\t\t}\n",
    "517": "\tprivate boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {\n\t\t\n\t\tint indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;\n\t\t\n\t\t// Compare byte by byte of both box configurations.\n\t\tfor(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {\n\t\t\tif (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n",
    "523": "\tpublic int getMaxCapacity() {\n\t\treturn maxCapacity;\n\t}\n",
    "524": "\tpublic void add(int boardPositionIndex, int boardPositionPredecessor) {\n\t\t\n\t\t// The moves queue also contains an arbitrary number of span markers.\n\t\t// Therefore after every added board position there must be done\n\t\t// a check whether the memory block is already full.\n\t\tadd(boardPositionIndex      );\n\t\tadd(boardPositionPredecessor);\n\t}\n",
    "531": "\tpublic void jumpOverBoardPosition(int boardPosition) {\n\t\n\t\t// \"Remove\" all values from the queue which are equal to the passed one\n\t\t// FFS/hm: does the caller guarantee that the Q cannot become empty by this?\n\t\twhile(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {\n\t\t\tremoveBoardPosition();\n\t\t}\n\t}\n",
    "535": "\tpublic int removeLastBoardPosition() {\n\t\t\t\t\t\t\n\t\tif(nextIndexToWrite == 0) {\n\t\t\t\n\t\t\t// The previous memory block becomes the new current memory block.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\n\t\t}\n\t\t\n\t\treturn memoryBlockToWrite.memory[--nextIndexToWrite];\n\t}\n",
    "538": "\tpublic void jumpXBoardPositionsBackwards(int jumpCount) {\n\t\t\n\t\twhile(jumpCount > nextIndexToWrite) {\n\t\t\t\t\t\t\t\n\t\t\t// Assign the previous memory block of the queue.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\t\n\t\t\tjumpCount -= nextIndexToWrite;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\t\t\t\t\t\n\t\t}\n\t\tnextIndexToWrite -= jumpCount;\n\t}\n",
    "542": "\tpublic boolean isEmpty() {\n\t\t// This method is only called for the moves queue which has recycling activated.\n\t\treturn memoryBlockToRead == memoryBlockToWrite\n\t\t    && nextIndexToRead   == nextIndexToWrite;\n\t}\n",
    "547": "\tpublic boolean isGenerationStoppedDueToFullStorage() {\n\t\treturn generationStoppedDueToFullStorage;\n\t}\n",
    "551": "\tpublic int getBoxConfigurationNumber() {\n\t\treturn uniqueBoxConfigurationNumber;\n\t}\n",
    "561": "\tpublic boolean isBetterMovesPushesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( movesCount , other.movesCount,\n\t\t                                   pushesCount, other.pushesCount )\n\t\t     < 0 ;\n\t}\n",
    "563": "\tpublic boolean isBetterPushesMovesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( pushesCount, other.pushesCount,\n\t\t                                   movesCount , other.movesCount  )\n\t\t     < 0 ;\n\t}\n",
    "568": "\tpublic void add(OptimizerBoardPosition boardPosition) {\n\n\t\t// Ensure that a real board position has been passed.\n        if (boardPosition == null)\n            throw new NullPointerException();\n\t\t\n\t\t// Double the size of the queue if it is full.\n\t\tif (count >= queue.length) {\n\t\t\tqueue = Arrays.copyOf(queue, queue.length * 2);\t\n\t\t}\t\t\n\t\t\n\t\t// Add the new value at the correct position. \n\t\tsiftUp(count, boardPosition);\n\t\t\n\t\t// One more board position has been stored => increase the counter.\n\t\tcount++;\n\t}\n",
    "570": "\tpublic int size() {\n\t\treturn count;\n\t}\n",
    "572": "\tpublic OptimizerBoardPosition removeFirst() {\n\n\t\tif (count == 0)\n\t\t\treturn null;\n\n\t\t// The head of the queue must be returned.\n\t\tOptimizerBoardPosition result = queue[0];\n\t\t\n\t\t// The head of the queue has (logically) been removed => adjust the size.\n\t\t--count;\n\t\t\n\t\t// Remove the last board position.\n\t\tOptimizerBoardPosition x = queue[count];\n\t\tqueue[count] = null;\n\t\t\n\t\t// If there is at least one board position left in the queue then \n\t\t// shift the board positions so the queue has a new head.\n\t\tif (count != 0)\n\t\t\tsiftDown(0, x);\n\n\t\treturn result;\n\t}\n",
    "576": "\tprivate void addLogTextStyle(final String text, final String stylename) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tStyledDocument doc = optimizerLog.getStyledDocument(); \n\t\t\t\t\tdoc.insertString(doc.getLength(), text+\"\\n\", doc.getStyle(stylename));\t\t\t\n\t\t\t\t} catch (BadLocationException e) {\t/* ignore */ }\n\t\t\t}\n\t\t});\n\t}\n",
    "577": "\t private void siftDown(int position, OptimizerBoardPosition boardPosition) {\n\t\t \n\t\t // Calculate the half of the size as the maximum position the loop must go to.\n\t\t int half = count >>> 1;        \n\t\t \n\t\t while (position < half) {\n\t\t\t int childIndex = (position << 1) + 1; // assuming the left child is the \"better\" board position\n\t\t\t OptimizerBoardPosition child = queue[childIndex];\n\t\t\t int rightChildIndex = childIndex + 1;\n\t\t\t if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)\n\t\t\t\t child = queue[childIndex = rightChildIndex];\n\t\t\t if (boardPosition.compareTo(child) <= 0)\n\t\t\t\t break;\n\t\t\t queue[position] = child;\n\t\t\t position = childIndex;\n\t\t }\n\t\t \n\t\t queue[position] = boardPosition;\n\t }\n",
    "580": "\tpublic int getNumberOfStoredBoardPositions() {\n\t\treturn count.get();\n\t}\n",
    "601": "\tpublic void removeAllMarkings() {\n\t\tmarkedSquares = null;\n\t}\n",
    "608": "\tpublic void showDeadlockQueryStats() {\n\t\tdlqTotStats.sumFrom(dlqCurStats);\n\t\tif ( ! dlqTotStats.equals(dlqCurStats)) {\n\t\t\tshow1DLQStats(\"total\", dlqTotStats, 0);\n\t\t}\n\t\t\n\t\tshow1DLQStats(\"this time\", dlqCurStats, dlqTotStats.dlqAsked);\n\t\tdlqCurStats.clear();\n\t}\n",
    "610": "\tprivate int getBoxConfigurationIndex(int boardPositionIndex) {\n\t\t// The board position may just been locked by another thread. However,\n\t\t// this method is only called for already completely stored board positions.\n\t\t// Hence, the index can't hold just the \"LOCKED\" value but must\n\t\t// always also contain a valid box configuration index.\n\t\treturn table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); \n\t}\n",
    "613": "\tfinal private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {\n\t\tfor (int i = 0; i < packedBoardByteSize; i++) {\n\t\t\tbyte b2 = boxConfigurationArray[indexInArray + i];\n\t\t\t// \"b2\" is a subset, if all its 1-bits survive the ANDing with the first byte\n\t\t\tif ((boxConfiguration1[i] & b2) != b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "617": "\tprivate int getPlayerPosition(int boardPositionIndex) {\n\t\t// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.\n\t\treturn table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;\n\t}\t\n",
    "619": "\t\tfinal private void doubleTreeSize() {\n\t\n\t\t\t// Double the tree size.\n\t\t\tint[] newArrayPointers = new int[2*2*treeSizeMax];\n\t\t\tSystem.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);\n\t\t\tarrayPointers = newArrayPointers;\n\t\n\t\t\tbyte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];\n\t\t\tSystem.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);\n\t\t\ttreeData = newArrayData;\n\t\n\t\t\ttreeSizeMax <<= 1;\n\t\t}\n",
    "626": "\t\tfinal private int treeToSortedListRecursively(int indexInTree, int last) {\n\t\n\t\t\t// If the end of the tree has been reached return the last index.\n\t\t\tif (indexInTree == -1) {\n\t\t\t\treturn last;\n\t\t\t}\n\t\n\t\t\t// Left side of the tree.\n\t\t\tint d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);\n\t\t\tsortedList[d++] = indexInTree;\n\t\n\t\t\t// Right side of the tree.\n\t\t\treturn (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));\n\t\t}\n",
    "637": "\tfinal public int getNumberOfSelectedObject() {\n\t\treturn currentlyMarkedObject;\n\t}\n",
    "638": "\t\tfinal private void binaryTreeToBinaryHeap() {\n\t\t\n\t\t\tbyte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];\n\t\t\n\t\t\tfor (int i=0, indexInVector = 0; i<treeSize; i++) {\n\t\t\t\tSystem.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);\n\t\t\t\tindexInVector += packedBoardByteSize;\n\t\t\t}\n\t\t\n\t\t\ttreeData = treeDataTemp;\n\t\t\tarrayPointers = null;\n\t\t}\n",
    "641": "\tfinal public void mouseWheelMoved(MouseWheelEvent evt) {\n\n\t\tint scrollDirection = evt.getWheelRotation();\n\n\t\t// Scrollen nach oben\n\t\tif (scrollDirection < 0 && currentlyMarkedObject > 0) {\n\t\t\tcurrentlyMarkedObject--;\n\t\t}\n\n\t\t// Scrollen nach unten\n\t\tif (scrollDirection > 0 && currentlyMarkedObject < 4) {\n\t\t\tcurrentlyMarkedObject++;\n\t\t}\n\n\t\tapplication.redraw(false);\n\t}\n",
    "643": "\tpublic void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {\n\t\t\n\t\t// Set/delete the \"processed\"-flag. This needn't to be done using compareAndSwap\n\t\t// because all of the other information stored at that offset have already been \n\t\t// stored and cannot change anymore while this method is executed.\n\t\tint currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);\n\t\tif(processedStatus == true)\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);\n\t\telse\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));\n\t}\n",
    "648": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * View on the levels\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "651": "\t\tprotected void finalize() {\n\t\t\tarrayPointers = null;\n\t\t\tsortedList = null;\n\t\t\ttreeData = null;\n\t\t}\n",
    "653": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * Language settings\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "656": "\tprivate void createPanel() {\n\t\t\n\t\tsetLayout(new BorderLayout());\n\n\t\tJPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));\n\t\tguiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));\n\n\t\t// Just a quick and dirty test coding ...\n\t\tNimRODFontDialog d = new NimRODFontDialog(null);\n\t\tComponent[] c = d.getContentPane().getComponents();\n\t\tguiPanel.add(c[0]);\n\t\t\n\t\tadd(guiPanel, BorderLayout.NORTH);\n\t}\n",
    "663": "\tprivate void updateElements() {\n\t\tfinal boolean selected = checkboxGUI.isSelected();\n\t\t\n\t\ttextfieldGUI.setEnabled(selected);\n\t\tlabelGUI.setEnabled(selected);\n\t}\n",
    "666": "\tpublic Double getValueAsDouble() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;\n\t}\n",
    "669": "\tpublic Integer getValueAsInteger() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;\n\t}\n",
    "670": "\tpublic void enterMeForTypeDate(JTable table) {\n\t\ttable.setDefaultRenderer(java.util.Date.class, this);\n\t}\n",
    "672": "\tpublic void addLevel(Level level) {\n\t\tdisplayedLevels.add(level);\n\t\tif (displayedLevels.size() < levelsPerPage) {\n\t\t\tlastLevelIndex = displayedLevels.size() - 1;\n\t\t} else {\n\t\t\tlastLevelIndex = levelsPerPage - 1;\n\t\t}\n\t}\n",
    "675": "\tpublic boolean isFieldActive() {\n\t\treturn textfieldGUI.isEnabled();\n\t}\n",
    "676": "\tpublic void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {\n\t\tfor(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {\n\t\t\taddLevel(collection.getLevel(levelNo));\n\t\t}\n\t}\n",
    "677": "\tpublic double setValue(double value) {\n\n\t\tdouble rc = value;\n\t\tif (value > maximumValue) {\n\t\t\trc = maximumValue;\n\t\t} else if (value < minimumValue) {\n\t\t\trc = minimumValue;\n\t\t} else {\n\t\t\trc = value;\n\t\t}\n\t\ttextfieldGUI.setValue(rc);\n\n\t\treturn rc;\t\t\n\t}\n",
    "684": "\tpublic void actionPerformed(ActionEvent actionevent) {\n\t\tif (actionevent.getActionCommand() == \"okbutton\") {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "685": "\tpublic void informAllUnsync(Generator<E> eventgen) {\n\t\t/*\n\t\t * We must not directly use (weakhashmap.keySet()), since it still\n\t\t * is coupled to the weakhashmap itself, which needs synchronization.\n\t\t * Hence we first must obtain a copy.\n\t\t */\n\t\tfor (L listener : getListenersCopy()) {\n\t\t\tfinal E evt = ((eventgen != null) ? eventgen.generate() : null);\n\t\t\tcaller.call(listener, evt);\n\t\t}\n\t}\n",
    "687": "\tpublic void setToStart() {\n\t\tsetTo(true);\n\t}\n",
    "688": "\tpublic void setToStop() {\n\t\tsetTo(false);\n\t}\n",
    "690": "\tprivate void setTo( boolean forStart ) {\n\t\tString textkey = (forStart ? startkey           : stopkey          );\n\t\tString action  = (forStart ? startActionCommand : stopActionCommand);\n\t\t\n\t\tsetText(Texts.getText( textkey ));\n\t\tsetActionCommand( action );\n\t\t\n\t\tsetupBorder(forStart);\n\t\tsetupBgColor(forStart);\n\t}\n",
    "693": "\tprivate void setupBorder(boolean forStart) {\n\t\tsetBorder( useBorder ? makeBorder(forStart) : null );\n\t}\n",
    "694": "\tprivate void setupBgColor(boolean forStart) {\n\t\tif (useBgColor) {\n\t\t\tint rgb = (forStart ? bgColorStart : bgColorStop);\n\t\t\t\n\t\t\tsetBackground( new Color(rgb) );\n\t\t\tsetOpaque(false);\n\t\t} else {\n\t\t\t// FFS/hm: should we actively put away a background color?\n\t\t}\n\t}\n",
    "696": "\tpublic Border makeBorder(boolean forStart) {\n\t\tint rgb = (forStart ? borderColorStart : borderColorStop);\n\t\treturn makeRgbBorder(rgb, useRoundedCorners);\n\t}\n",
    "697": "\tpublic Border makeStartBorder() {\n\t\treturn makeBorder(true);\n\t}\n",
    "699": "\tpublic Border makeStopBorder() {\n\t\treturn makeBorder(false);\n\t}\n",
    "703": "\tpublic void setUseBorder(boolean useBorder) {\n\t\tthis.useBorder = useBorder;\n\t}\n",
    "706": "\tpublic void setUseBgColor(boolean useBgColor) {\n\t\tthis.useBgColor = useBgColor;\n\t}\n",
    "710": "\tpublic void setBorderColorStart(int borderColorStart) {\n\t\tthis.borderColorStart = borderColorStart;\n\t}\n",
    "715": "\tpublic void setBorderColorStop(int borderColorStop) {\n\t\tthis.borderColorStop = borderColorStop;\n\t}\n",
    "718": "\tpublic void setBgColorStart(int bgColorStart) {\n\t\tthis.bgColorStart = bgColorStart;\n\t}\n",
    "721": "\tpublic void setBgColorStop(int bgColorStop) {\n\t\tthis.bgColorStop = bgColorStop;\n\t}\n",
    "722": "\tstatic private boolean isOutsideClip(int x, int y, int xlen, int ylen, Rectangle clip) {\n\n\t\t// Non-existing rectangle stands for the complete plane => nothing is outside of the complete plane.\n\t\t// We are \"outside\" of \"clip\", if we do not intersect with it.\n\t\treturn clip != null && ! clip.intersects(x, y, xlen, ylen);\n\t\t\n\t}\n",
    "741": "\tpublic boolean hasAlias() {\n\t\treturn (alias.length() > 0);\n\t}\n",
    "743": "\tpublic String getAlias() {\n\t\treturn alias;\n\t}\n",
    "746": "\tpublic void setAlias(String newAlias) {\n\t\talias = newAlias;\n\t}\n",
    "747": "\tpublic String getPath() {\n\t\treturn path;\n\t}\n",
    "750": "\tpublic String getName() {\n\t\tif (hasAlias()) {\n\t\t\treturn alias;\n\t\t}\n\t\treturn path;\n\t}\n",
    "752": "\tpublic String getDisplayName() {\n\t\tif (hasAlias()) {\n\t\t\treturn '[' + alias + ']';\n\t\t}\n\t\treturn path;\n\t}\n",
    "753": "\tprivate BufferedImage extractGraphicTwoCoordinates(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tPoint graphicCoordinates = getPoint(graphicName);\n\t\t\tif(graphicCoordinates != null) {\n\t\t\t\treturn entireGraphic.getSubimage(graphicCoordinates.x * graphicWidth,\n\t\t\t\t\t\t                         graphicCoordinates.y * graphicHeight,\n\t\t\t\t\t\t                         graphicWidth, graphicHeight);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "754": "\tpublic Color getColor() {\n\t\treturn color;\n\t}\n",
    "755": "\tpublic void setColor(String color) {\n\t\tthis.color = parseColor(color);\n\t}\n",
    "756": "\tpublic void setBoardToDisplay(Board board) {\n\n\t\t// Save the reference.\n\t\tthis.board = board;\n\n\t\t// Create new array for storing information about which positions have to be drawn when repainting.\n\t\tgraphicStatus = new byte[board.size];\n\n\t\t// Initialize the debug array used for showing numbers on the board.\n\t\tArrays.fill(numbersToShow, -1);\n\n\t\t// Reset the transformation of the board.\n\t\ttransformBoard(-1);\n\t}\n",
    "758": "\tpublic String getColorString() {\n\t\treturn colorToString(color);\n\t}\n",
    "759": "\tprivate BufferedImage extractGraphicOneCoordinate(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tint xCoordinate = getInt(graphicName, -1);\n\t\t\tif(xCoordinate == -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn entireGraphic.getSubimage(xCoordinate * graphicWidth, 0, graphicWidth, graphicHeight);\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "764": "\tprivate String trimValue(String propertyValue) {\n\t\n\t\tif (propertyValue == null || propertyValue.length() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\n\t\tint lastpos = propertyValue.indexOf('#');\n\t\tif (lastpos == -1) {\n\t\t\tlastpos = propertyValue.length() - 1;\n\t\t}\n\t\t\n\t\t\n\t\tfor(; lastpos >= 0 ; --lastpos ) {\n\t\t\tchar c = propertyValue.charAt(lastpos);\n\t\t\tif (c != ' ' && c != '\\t') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Now, \"lastpos\" indexes the last char to be retained (or -1 if there is none)\n\t\t\n\t\t// Return the trimmed value.\n\t\treturn propertyValue.substring(0, lastpos + 1);\n\t}\n",
    "772": "\tstatic public String getTransformationAsString() {\n\n\t\t// If the level isn't displayed transformed return an empty String.\n\t\tif (getRotationValue() == ROTATION_BY_0_DEGREES && isLevelFlippedHorizontally() == false) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Build the transformation string and return it.\n\t\tString transformationString = \"View: Rotated \"\n\t\t\t                        + getRotationAsString()\n\t\t\t                        + \" degrees clockwise\";\n\t\tif (isLevelFlippedHorizontally()) {\n\t\t\ttransformationString += \", flipped horizontally.\";\n\t\t} else {\n\t\t\ttransformationString += \".\";\n\t\t}\n\n\t\treturn transformationString;\n\t}\n",
    "774": "\tpublic T generate() {\n\t\treturn base;\n\t}\n",
    "779": "\tfinal private JButton createToolBarButton(String iconName, String actionCommand, String toolTipText) {\n\n\t\t// Create and initialize the button.\n\t\tJButton button = new JButton(Utilities.getIcon(iconName, null));\n\t\tbutton.setActionCommand(actionCommand);\n\t\tbutton.setToolTipText(toolTipText);\n\t\tbutton.addActionListener(this);\n\n\t\t// The buttons must be clicked with the mouse.\n\t\tbutton.setFocusable(false);\n\n\t\treturn button;\n\t}\n",
    "781": "\tpublic Skin getCurrentSkin() {\n\t\treturn skin;\n\t}\n",
    "784": "\tprivate String getString(String name, String ... defaultValue) {\n\t\n\t\t// Get the value of the property.\n\t\tString propertyValue = trimValue(properties.getProperty(name));\n\t\n\t\t// If the the property couldn't be found set the default value.\n\t\tif (propertyValue == null) {\n\t\t\tif(defaultValue.length > 0) {\n\t\t\t\treturn defaultValue[0];\n\t\t\t}\n\t\t}\n\t\n\t\treturn propertyValue;\n\t}\n",
    "785": "\tfinal private JButton createToolBarButtonByKey(String iconName, String actionCommand, String toolTipTextKey) {\n\t\tString toolTipText = Texts.getText(toolTipTextKey);\n\t\treturn createToolBarButton(iconName, actionCommand, toolTipText);\n\t}\n",
    "787": "\tpublic void setSkinAnimationDelay(int delay) {\n\n\t\t// Save the delay in the settings.\n\t\tSettings.set(\"skinAnimationDelay\", \"\" + delay);\n\n\t\t// If a timer is running set the new delay value.\n\t\tif (animationTimer != null && animationTimer.isRunning()) {\n\t\t\tanimationTimer.setDelay(delay);\n\t\t}\n\t}\n",
    "793": "\tpublic void setViewDirection(int viewDirection) {\n\t\tthis.viewDirection = (byte) viewDirection;\n\t}\n",
    "800": "\tpublic void setMaximumScalingFactor(int maximumScalingFactor) {\n\n\t\tmaximumScaling = maximumScalingFactor;\n\n\t\trecalculateGraphicSizes();\n\t\trepaint();\n\n\t\t// Save the zooming factor.\n\t\tSettings.set(\"maximumScaling\", \"\" + maximumScaling);\n\t}\n",
    "805": "\tpublic void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "806": "\tpublic void transformBoard(int transformationValue) {\n\n\t\t// Tell it to the Transformation class.\n\t\tTransformation.transform(transformationValue);\n\n\t\t// Since the transformation may have exchanged height and width, we force a\n\t\t// recalculation of the graphics, as if we had loaded a new level.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Show new graphics\n\t\trepaint();\n\t}\n",
    "808": "\tpublic void setLevelToDisplay(Level levelToBeDisplayed) {\n\t\t\n\t\t// Create an own board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Set the passed level on the board.\n\t\ttry {\n\t\t\tboard.setBoardFromString(levelToBeDisplayed.getBoardDataAsString());\n\t\t} catch (Exception e) {\n\t\t\t// Show the error message.\n\t\t\tUtilities.showExceptionError(this, e);\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "810": "\tpublic void setBoardToDisplay(String boardAsString) {\n\t\t\n\t\t// Create an new board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Create an own board from the board of the level.\n\t\ttry {\n\t\t\tboard.setBoardFromString(boardAsString);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "813": "\tpublic void setInfoBarVisible(boolean visibleStatus) {\n\t\tisInfoBarVisible = visibleStatus;\n\t}\n",
    "814": "\tpublic void setBoardToDisplay(Board board) {\n\t\t\n\t\tthis.board = board;\n\t\t\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "816": "\tpublic Board getBoard() {\n\t\treturn board;\n\t}\n",
    "819": "\tpublic Level getDisplayedLevel() {\n\t\treturn displayedLevel;\n\t}\n",
    "821": "\tpublic int getSquareWidth() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicWidth;\n\t}\n",
    "823": "\tpublic int getSquareHeight() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicHeight;\n\t}\n",
    "824": "\tfinal public void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "827": "\tprivate void setInitialBoardPosition() {\n\t\tboard      = boardInitial.boardElements.clone();\n\t\tplayerPosX = boardInitial.playerPositionX;\n\t\tplayerPosY = boardInitial.playerPositionY;\n\t}\n",
    "835": "\tpublic void paintImmediately() {\n\t\tpaintImmediately(0, 0, getWidth(), getHeight());\n\t}\n",
    "840": "\tprivate void packBoxConfiguration(byte[] newPackedBoxConfiguration, byte[] unpackedBoxConfiguration) {\n\n\t\tint bytePosition = 0, bitPosition = 0;\n\n\t\t// Loop over all internal box positions.\n\t\tfor (int i = 0; i < boxPositionsCount; i++) {\n\n\t\t\tbytePosition = i >> 3;\n\t\t\tbitPosition  = i & 7;\n\n\t\t\tif ((unpackedBoxConfiguration[boxInternalToExternalPosition[i]] & BOX) == BOX)\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] |= 1 << bitPosition;\n\t\t\telse\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] &= (255 - (1 << bitPosition));\n\t\t}\n\t}\n",
    "856": "\tprivate void setVisited(int boardPositionIndex) {\n\t\tint bytePosition = (boardPositionIndex >>> 3), bitPosition = (boardPositionIndex & 7);\n\t\tvisitedData[bytePosition] |= (1 << bitPosition);\n\t}\n",
    "863": "\tfinal public void setCursor(int cursor) {\n\n\t\t// Set the specified predefined cursor.\n\t\tmainBoardDisplay.setCursor(Cursor.getPredefinedCursor(cursor));\n\t}\n",
    "865": "\tprotected void adjustToBoard(Point p) {\n\t\t\n\t\t// Clip both point coordinates at their allowed minimum (inclusive).\n\t\tif( p.x < xOffset ) {\n\t\t\tp.x = xOffset;\n\t\t}\n\t\tif( p.y < yOffset ) {\n\t\t\tp.y = yOffset;\n\t\t}\n\t\t\n\t\t// Compute maximal point coordinates, inclusive...\n\t\tint xmax = xOffset + Transformation.getOutputLevelWidth()  * skin.graphicWidth  - 1;\n\t\tint ymax = yOffset + Transformation.getOutputLevelHeight() * skin.graphicHeight - 1;\n\t\t\n\t\t// ... and use them to clip off larger values:\n\t\tif( p.x > xmax ) {\n\t\t\tp.x = xmax;\n\t\t}\n\t\tif( p.y > ymax ) {\n\t\t\tp.y = ymax;\t\n\t\t}\n\t}\n",
    "866": "\tprivate void paintExtSqRect(int xmin, int ymin, int extWidth, int extHeight) {\n\t\tint pixXmin   = xOffset + xmin * skin.graphicWidth;\n\t\tint pixYmin   = yOffset + ymin * skin.graphicHeight;\n\t\tint pixWidth  =      extWidth  * skin.graphicWidth;\n\t\tint pixHeight =      extHeight * skin.graphicHeight;\n\t\t\n\t\tif (pixWidth > 0 || pixHeight > 0) {\n\t\t\trepaint(pixXmin, pixYmin, pixWidth, pixHeight);\n\t\t\tpaintMovesPushes();\n\t\t}\n\t}\n",
    "870": "\tpublic int getInfluenceDistance(int startSquare, int targetSquare) {\n\t\treturn influenceDistances[startSquare][targetSquare];\n\t}\n",
    "871": "\tfinal public void setNewLanguage() {\n\n\t\t// Create a new menu bar and and a new tool bar according to the new language.\n\t\tapplication.setJMenuBar(createMenuBar());\n\t\tcreateToolBar();\n\t}\n",
    "872": "\tprivate boolean isVisited(int boardPositionIndex) {\n\t\tint i = (boardPositionIndex >>> 3), j = (boardPositionIndex & 7);\n\t\treturn (visitedData[i] & (1 << j)) > 0;\n\t}\n",
    "874": "\tfinal public void addPlayerMove(int direction) {\n\t\taddMovement(direction, -1);\n\t}\n",
    "876": "\t\tpublic void clear() {\n\t\t\tminX = Integer.MAX_VALUE;\n\t\t\tmaxX = Integer.MIN_VALUE;\n\t\t\tminY = Integer.MAX_VALUE;\n\t\t\tmaxY = Integer.MIN_VALUE;\n\t\t}\n",
    "877": "\tfinal public HistoryElement getSuccessorMovement() {\n\t\tif (hasSuccessorMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( ++currentMovementNo );\n\t}\n",
    "878": "\tfinal public HistoryElement getPrecedingMovement() {\n\t\tif (hasPrecedingMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( currentMovementNo-- );\n\t}\n",
    "881": "\tfinal public HistoryElement getMovement(int movementNo) {\n\n\t\tif (movementNo < 0 || movementNo > movementHistory.size() - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get(movementNo);\n\t}\n",
    "882": "\tfinal public int getCurrentMovementNo() {\n\t\treturn currentMovementNo;\t\n\t}\n",
    "883": "\t\tpublic boolean isEmpty() {\n\t\t\treturn (minX > maxX) || (minY > maxY);\n\t\t}\n",
    "884": "\tfinal public int getMovementsCount() {\n\t\treturn movementHistory.size();\n\t}\n",
    "885": "\tfinal public int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (HistoryElement historyElement : movementHistory) {\n\t\t\tif (historyElement.pushedBoxNo != -1) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\t\treturn pushesCount;\n\t}\n",
    "889": "\tfinal public String getLURDString() {\n\t\treturn getLURDString(0, currentMovementNo);\n\t}\n",
    "890": "\t\tpublic void add(int x, int y) {\n\t\t\tminX = Math.min(minX, x);\n\t\t\tmaxX = Math.max(maxX, x);\n\t\t\tminY = Math.min(minY, y);\n\t\t\tmaxY = Math.max(maxY, y);\n\t\t}\n",
    "891": "\tfinal public String getLURDStringTotal() {\n\t\treturn getLURDString(0, getMovementsCount() - 1);\n\t}\n",
    "893": "\tfinal public void setHistoryToStart() {\n\t\tcurrentMovementNo = -1;\n\t}\n",
    "895": "\tfinal public void setMovementNo(int movementNo) {\n\t\tcurrentMovementNo = movementNo;\n\t}\n",
    "897": "\tfinal public void setStartOfCombinedMovement() {\n\t\tisStartOfCombinedMovement = true;\n\t}\n",
    "898": "\t\tpublic void addExternal(int externalPos) {\n\t\t\tif (externalPos != -1) {\n\t\t\t\tint externalWidth = Transformation.getOutputLevelWidth();\n\t\t\t\tint extX = externalPos % externalWidth;\n\t\t\t\tint extY = externalPos / externalWidth;\n\t\t\t\t\n\t\t\t\tadd(extX, extY);\n\t\t\t}\n\t\t}\n",
    "900": "\tfinal public void goToPrecedingMovement() {\n\t\tcurrentMovementNo--;\n\t}\n",
    "903": "\tfinal public void goToNextMovement() {\n\t\t++currentMovementNo;\n\t}\n",
    "904": "\t\tpublic void addInternal(int internalPos) {\n\t\t\tif (internalPos != -1) {\n\t\t\t\tint externalPos = Transformation.getExternalPosition(internalPos);\n\t\t\t\t\n\t\t\t\taddExternal(externalPos);\n\t\t\t}\n\t\t}\n",
    "905": "\tfinal public boolean hasPrecedingMovement() {\n\t\treturn currentMovementNo >= 0;\n\t}\n",
    "908": "\tfinal public boolean hasSuccessorMovement() {\n\t\treturn (currentMovementNo + 1) < movementHistory.size();\n\t}\n",
    "910": "\tprivate void paintMovesPushes() {\n\t\t// Moves and pushes are displayed as part of the history slider panel.\n\t\tif (historySliderPanel != null) {\n\t\t\t// We have to include the textual representation, as well as the graphical\n\t\t\t// slider representation.  That includes most of the area.\n\t\t\tint w = historySliderPanel.getWidth();\n\t\t\tint h = historySliderPanel.getHeight();\n\t\t\t\n\t\t\t// Redraw the slider. This needn't to be done immediately. Repaint is much\n\t\t\t// faster then paintImmediately.\n\t\t\thistorySliderPanel.repaint(0, 0, w, h);\n\t\t}\n\t}\n",
    "911": "\tfinal public int combinedLengthPreceding() {\n\t\tint steps = 0;\n\t\t\n\t\tfor( int mNo = currentMovementNo; mNo >= 0 ; --mNo ) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn steps;\n\t}\n",
    "913": "\tfinal public int combinedLengthSuccessor() {\n\t\tint steps = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\t++mNo;\n\t\t\t\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn steps;\n\t}\n",
    "915": "\tfinal public int countCombinedForward() {\n\t\tint starts = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\t++starts;\n\t\t\t} else if( starts == 0 ) {\n\t\t\t\t++starts;\n\t\t\t}\n\t\t\t++mNo;\n\t\t}\n\t\t\n\t\treturn starts;\n\t}\n",
    "918": "\tfinal public float averageLengthCombinedForward() {\n\t\tint len = getMovementsCount() - currentMovementNo;\n\t\tif( len <= 0 ) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tint cntcombined = countCombinedForward();\n\t\treturn (float)len / cntcombined;\n\t}\n",
    "932": "\tpublic boolean isABoxBeenMoved() {\n\t\treturn pushedBoxNo != -1;\n\t}\n",
    "939": "\tprivate MouseListener getMouseListener() {\n\t\treturn new MouseAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e) {\n\t\t\t\tif(e.getClickCount() > 1) {\n\t\t\t\t\tint index = locationToIndex(e.getPoint());\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// This action can be disabled (for instance when the solver is running).\n\t\t\t\t\t\tif(!isTakeSolutionAsHistoryEnabled) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSolution clickedSolution = (Solution) listModel.getElementAt(index);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the selected solution as new history in the game.\n\t\t\t\t\t\tapplication.takeSolutionForHistory(clickedSolution);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n",
    "941": "\tfinal public void setEditorMenuItemEnabled(boolean enabled) {\n\t\teditorMenuItem.setEnabled(enabled);\n\t}\n",
    "948": "\tfinal public JMenuItem getSaveLevelMenuItem() {\n\t\treturn saveLevelMenuItem;\n\t}\n",
    "954": "\tfinal public JButton getInfoButton() {\n\t\treturn infoButton;\n\t}\n",
    "960": "\tfinal public void setModeDependentObjectStatus() {\n\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component button : playModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isPlayModeActivated());\n\t\t\t\t}\n\n\t\t\t\tfor (AbstractButton button : editorModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isEditorModeActivated());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "966": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boardPositionIndex, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boardPositionIndex / playerSquaresCount);\n\t\tint playerPosition = boardPositionIndex % playerSquaresCount;\n\t\tdebugDisplayBoxConfiguration(temp, playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "969": "\tpublic void setSolutionColor(Solution solution, Color color) {\n\t\tif(color == null) {\n\t\t\tcoloredSolutions.remove(solution);\n\t\t} else {\n\t\t\tcoloredSolutions.put(solution, color);\n\t\t}\n\t}\n",
    "971": "\tfinal public void setSolverDependentObjectsEnabled(final boolean enabledStatus) {\n\t\t\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : solverModeDependentObjects) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "972": "\t\tpublic boolean isValidNewSolution() {\n\t\t\treturn this != INVALID_SOLUTION && this != DUPLICATE_SOLUTION;\n\t\t}\n",
    "973": "\tpublic void setAllSolutionsUncolored() {\n\t\tcoloredSolutions.clear();\n\t}\n",
    "974": "\tprivate void setSelectedViewRow(int viewrowindex) {\n\t\tif (       (viewrowindex >= 0)\n\t\t\t\t&& (tableModelSolutionData != null)\n\t\t\t\t&& (tableModelSolutionData.getRowCount() > 0)\n\t\t\t\t&& (tableSolutionData != null)) {\n\t\t\tListSelectionModel lsm = tableSolutionData.getSelectionModel();\n\t\t\tlsm.setSelectionInterval(viewrowindex, viewrowindex);\n\t\t}\n\t}\n",
    "976": "\tpublic void addActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.register(actionListener);\n\t}\n",
    "979": "\tprotected void showNoSolutionsSelected() {\n\t\tUtilities.showInfoNoteTextKey(getParent(), \"solutionList.noSolutionSelected\");\n\t}\n",
    "980": "\tpublic void removeActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.unregister(actionListener);\n\t}\n",
    "982": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boxConfigurationIndex, int playerPosition, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boxConfigurationIndex);\n\t\tdebugDisplayBoxConfiguration(temp,playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "984": "\tfinal public void setUndoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : undoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "985": "\t\tpublic void mouseDragged(MouseEvent evt) {\n\t\t\n\t\t\tif(isMouseDragged == false) {\n\t\t\t\n\t\t\t\tstartOfLastDrag = evt.getWhen();\n\t\t\t\t\n\t\t\t\t// Save the dragged status.\n\t\t\t\tisMouseDragged = true;\n\t\t\t}\n\t\t\t\n\t\t\tmousePressed(evt);\n\t\t}\t\t\n",
    "987": "\tprivate void informThemHere(final Solution solution, final String action) {\n\t\tactionListenerSet.informAllSync(makeActionGenerator(solution, action));\n\t}\n",
    "989": "\tprivate void informListeners(final Solution solution, final String action) {\n\t\n\t\t// The GUI should be updated in the EDT.\n\t\tif(SwingUtilities.isEventDispatchThread()) {\n\t\t\tinformThemHere(solution, action);\n\t\t}\n\t\telse {\n\t\t\t// Update the GUI before this thread continues. \n\t\t\ttry {\n\t\t\t\tSwingUtilities.invokeAndWait(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tinformThemHere(solution, action);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t} catch (InvocationTargetException e) { /* just continue */ }\n\t\t}\n\t}\n",
    "993": "\tpublic void setTakeSolutionAsHistoryVisible(boolean isVisible) {\n\t\tisTakeSolutionAsHistoryEnabled = isVisible;\n\t}\n",
    "996": "\tfinal public void setRedoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : redoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "1000": "\t\tpublic void addSolutionToBeHighlighted(Solution solution) {\n\t\t\thighlightedSolutions.put(solution, 10);\n\t\t\t\n\t\t\t// Inform this thread that new solutions are to be highlighted.\n\t\t\tsynchronized(this) {\n\t\t\t\tnotify();\n\t\t\t}\n\t\t}\n",
    "1002": "\t\tpublic void removeAllSolutionsToBeHighlighted() {\n\t\t\thighlightedSolutions.clear();\n\t\t}\n",
    "1006": "\t\tpublic Integer getHighlightIntensity(Solution solution) {\n\t\t\treturn highlightedSolutions.get(solution);\n\t\t}\n",
}
