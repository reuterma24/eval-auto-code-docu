321, public int getPushesLowerbound() {		return pushesLowerbound;	}
323, public void setPushesLowerbound(int pushesLowerbound) {		this.pushesLowerbound = pushesLowerbound;	}
324, public void play() {									if(currentSoundFilename.equals(""))				return;												String settingsFileName = Settings.get(soundSettingsKey);			if(!currentSoundFilename.equals(settingsFileName)) {				loadClip(settingsFileName);						}									if (clip.isRunning()) {				clip.stop();			}									clip.setFramePosition(0); 									clip.start(); 		}
343, public int getInfluenceValue(int boxNo1, int boxNo2) {		return influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),				 board.boxData.getBoxPosition(boxNo2) );	}
351, public void setPositions(int[] positions){		this.positions = positions;	}
352, public int getPlayerPosition() {		return positions[positions.length-1];	}
355, public int getPulledBoxNumber() {		return pulledBoxNo;	}
357, public int getStartBoxPosition() {		return startPosition;	}
359, public int getTargetBoxPosition() {		return targetPosition;	}
361, public BoardPositionPackingSequence getPrecedingBoardPosition() { 	return precedingBoardPosition; }
364, public int compareTo(BoardPositionPackingSequence boardPosition) {		return boardPosition.getRelevance() - getRelevance();	}
373, public boolean isForcedPush() {		return isPushForced;	}
376, final public void setInfoText(String text) {		infoText.setText(text);	}
412, public boolean isSolverStoppedDueToOutOfMemory() {		return isSolverStoppedDueToOutOfMemory;	}
428, final protected IBoardPositionMoves getBestBoardPosition(){				LinkedList<IBoardPositionMoves> boardPositionList;				for(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {								boardPositionList = boardPositionQueue.get(solutionLength);						if(boardPositionList.size() > 0){	 			 shortestSolutionPathLength = solutionLength;			 					 		return boardPositionList.removeLast();			}		}				return null;	}
437, final public IBoardPosition getPrecedingBoardPosition() {		return precedingBoardPosition;	}
440, final public int getDirection() {		return positionData >>> 13;	}
442, public int getBoxNo() {		return positionData & ((1 << 10) - 1);	}
445, protected String creatorName() {		return Texts.getText("solver");	}
446, final public int getPlayerPosition() {		return playerPosition;	}
448, final public void setPositions(int[] positions) {		this.positions = positions;	}
450, final public IBoardPosition getPrecedingBoardPosition() {		return null;	}
454, final public void setSearchDirection(SearchDirection searchDirection) {		if (searchDirection == SearchDirection.FORWARD) {			forwardsSearch = true;		} else {			backwardsSearch = true;		}	}
458, final public int getDirection() {		return 0;	}
459, public int getPushesCount() {		int pushesCount = 0;		for (BoardPosition currentBoardPosition = this; currentBoardPosition				.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition				.getPrecedingBoardPosition()) {			if (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {				pushesCount++;			}		}		return pushesCount;	}
461, final public int getBoxNo() {		return NO_BOX_PUSHED;	}
463, public void setMaximumSolutionLength(short maximumSolutionLength) {		maximumPushesCurrentIteration = maximumSolutionLength;	}
464, final public int getPlayerPosition() {		return positions[boxCount];	}
466, public short getMaximumSolutionLength() {		return maximumPushesCurrentIteration;	}
467, final public int getPushesCount() {		return 0;	}
472, protected String solutionByMeAt(Date date) {		return Texts.getText("createdBy")		 + " " + creatorName()		 + " " + Utilities.dateString(date);	}
476, final public void setMovesCount(int movesCount) {		this.movesCount = (short) movesCount;	}
487, public int getIndexPackingSequence() {		return indexPackingSequence;	}
489, public void setIndexPackingSequence(int indexPackingSequence) {		this.indexPackingSequence = indexPackingSequence;	}
494, protected boolean isBoxInactive(int boxNo) {		return isBoxInactive[boxNo];	}
496, final public boolean isBoxInactive() {		return (positionData & INACTIVE_BOX) > 0;	}
497, public void setCorralDeadlock() {		isDeadlock = true;	}
498, public void setNotCorralDeadlock() {		isNotDeadlock = true;	}
499, public boolean getValue() {			/*			 * Since we here are inside of class Settings, we should not get			 * an IllegalAccessException.			 * Hence, we catch the exceptions here, and return false,			 * just in case.			 */			try {				return field.getBoolean(null);			} catch (IllegalArgumentException e) {				e.printStackTrace();			} catch (IllegalAccessException e) {				e.printStackTrace();			}			return false;		}
500, protected String solutionByMeNow() {		return solutionByMeAt(null);	}
501, public void setCorralNo(int corralNo) {		this.corralNo = corralNo;	}
503, public void setInfoText(String text) {		infoText.setText(text);	}
504, public int getCorralNo() {		return corralNo;	}
506, public boolean isCorralDeadlock() {		return isDeadlock;	}
507, public boolean isNotCorralDeadlock() {		return isNotDeadlock;	}
508, public boolean isClassified() {		return isDeadlock || isNotDeadlock;	}
510, public boolean isBeeingAnalyzed() {		return !isDeadlock && !isNotDeadlock;	}
513, public CBoard getClone() {		return new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);	}
514, public void setValue(boolean value) {			/*			 * Regarding exceptions see comment in "getValue"			 */			try {				field.setBoolean(null, value);				System.out.println("Setting: DebugVar: "+field.getName()+" set to "+value);			} catch (IllegalArgumentException e) {				e.printStackTrace();			} catch (IllegalAccessException e) {				e.printStackTrace();			}					}
517, private boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {				int indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;						for(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {			if (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {				return false;			}		}				return true;	}
523, public int getMaxCapacity() {		return maxCapacity;	}
524, public void add(int boardPositionIndex, int boardPositionPredecessor) {										add(boardPositionIndex );		add(boardPositionPredecessor);	}
531, public void jumpOverBoardPosition(int boardPosition) {							while(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {			removeBoardPosition();		}	}
535, public int removeLastBoardPosition() {								if(nextIndexToWrite == 0) {									memoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;			nextIndexToWrite = MEMORY_BLOCK_SIZE;		}				return memoryBlockToWrite.memory[--nextIndexToWrite];	}
538, public void jumpXBoardPositionsBackwards(int jumpCount) {				while(jumpCount > nextIndexToWrite) {													memoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;						jumpCount -= nextIndexToWrite;			nextIndexToWrite = MEMORY_BLOCK_SIZE;							}		nextIndexToWrite -= jumpCount;	}
542, public boolean isEmpty() {				return memoryBlockToRead == memoryBlockToWrite		 && nextIndexToRead == nextIndexToWrite;	}
547, public boolean isGenerationStoppedDueToFullStorage() {		return generationStoppedDueToFullStorage;	}
551, public int getBoxConfigurationNumber() {		return uniqueBoxConfigurationNumber;	}
561, public boolean isBetterMovesPushesThan( OptimizerSolution other ) {		if (other == null) {			return true;					}		return Utilities.intCompare2Pairs( movesCount , other.movesCount,		 pushesCount, other.pushesCount )		 < 0 ;	}
563, public boolean isBetterPushesMovesThan( OptimizerSolution other ) {		if (other == null) {			return true;					}		return Utilities.intCompare2Pairs( pushesCount, other.pushesCount,		 movesCount , other.movesCount )		 < 0 ;	}
568, public void add(OptimizerBoardPosition boardPosition) {		 if (boardPosition == null) throw new NullPointerException();						if (count >= queue.length) {			queue = Arrays.copyOf(queue, queue.length * 2);			}								siftUp(count, boardPosition);						count++;	}
570, public int size() {		return count;	}
572, public OptimizerBoardPosition removeFirst() {		if (count == 0)			return null;				OptimizerBoardPosition result = queue[0];						--count;						OptimizerBoardPosition x = queue[count];		queue[count] = null;								if (count != 0)			siftDown(0, x);		return result;	}
576, private void addLogTextStyle(final String text, final String stylename) {		SwingUtilities.invokeLater(new Runnable() {			@Override			public void run() {				try {					StyledDocument doc = optimizerLog.getStyledDocument(); 					doc.insertString(doc.getLength(), text+"\n", doc.getStyle(stylename));							} catch (BadLocationException e) {	/* ignore */ }			}		});	}
577, private void siftDown(int position, OptimizerBoardPosition boardPosition) {		 		 		 int half = count >>> 1; 		 		 while (position < half) {			 int childIndex = (position << 1) + 1; 			 OptimizerBoardPosition child = queue[childIndex];			 int rightChildIndex = childIndex + 1;			 if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)				 child = queue[childIndex = rightChildIndex];			 if (boardPosition.compareTo(child) <= 0)				 break;			 queue[position] = child;			 position = childIndex;		 }		 		 queue[position] = boardPosition;	 }
580, public int getNumberOfStoredBoardPositions() {		return count.get();	}
601, public void removeAllMarkings() {		markedSquares = null;	}
608, public void showDeadlockQueryStats() {		dlqTotStats.sumFrom(dlqCurStats);		if ( ! dlqTotStats.equals(dlqCurStats)) {			show1DLQStats("total", dlqTotStats, 0);		}				show1DLQStats("this time", dlqCurStats, dlqTotStats.dlqAsked);		dlqCurStats.clear();	}
610, private int getBoxConfigurationIndex(int boardPositionIndex) {										return table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); 	}
613, final private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {		for (int i = 0; i < packedBoardByteSize; i++) {			byte b2 = boxConfigurationArray[indexInArray + i];						if ((boxConfiguration1[i] & b2) != b2) {				return false;			}		}		return true;	}
617, private int getPlayerPosition(int boardPositionIndex) {				return table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;	}
619, final private void doubleTreeSize() {							int[] newArrayPointers = new int[2*2*treeSizeMax];			System.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);			arrayPointers = newArrayPointers;				byte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];			System.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);			treeData = newArrayData;				treeSizeMax <<= 1;		}
626, final private int treeToSortedListRecursively(int indexInTree, int last) {							if (indexInTree == -1) {				return last;			}							int d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);			sortedList[d++] = indexInTree;							return (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));		}
637, final public int getNumberOfSelectedObject() {		return currentlyMarkedObject;	}
638, final private void binaryTreeToBinaryHeap() {					byte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];					for (int i=0, indexInVector = 0; i<treeSize; i++) {				System.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);				indexInVector += packedBoardByteSize;			}					treeData = treeDataTemp;			arrayPointers = null;		}
641, final public void mouseWheelMoved(MouseWheelEvent evt) {		int scrollDirection = evt.getWheelRotation();				if (scrollDirection < 0 && currentlyMarkedObject > 0) {			currentlyMarkedObject--;		}				if (scrollDirection > 0 && currentlyMarkedObject < 4) {			currentlyMarkedObject++;		}		application.redraw(false);	}
643, public void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {										int currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);		if(processedStatus == true)			table.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);		else			table.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));	}
648, public void stateChanged(final ChangeEvent e) {								JTabbedPane tabbedPane = (JTabbedPane) e.getSource();				/*		 * View on the levels		 */		if(tabbedPane.getSelectedComponent() == languageSettings) {				}					}
651, protected void finalize() {			arrayPointers = null;			sortedList = null;			treeData = null;		}
653, public void stateChanged(final ChangeEvent e) {								JTabbedPane tabbedPane = (JTabbedPane) e.getSource();				/*		 * Language settings		 */		if(tabbedPane.getSelectedComponent() == languageSettings) {				}					}
656, private void createPanel() {				setLayout(new BorderLayout());		JPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));		guiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));				NimRODFontDialog d = new NimRODFontDialog(null);		Component[] c = d.getContentPane().getComponents();		guiPanel.add(c[0]);				add(guiPanel, BorderLayout.NORTH);	}
663, private void updateElements() {		final boolean selected = checkboxGUI.isSelected();				textfieldGUI.setEnabled(selected);		labelGUI.setEnabled(selected);	}
666, public Double getValueAsDouble() {		return checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;	}
669, public Integer getValueAsInteger() {		return checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;	}
670, public void enterMeForTypeDate(JTable table) {		table.setDefaultRenderer(java.util.Date.class, this);	}
672, public void addLevel(Level level) {		displayedLevels.add(level);		if (displayedLevels.size() < levelsPerPage) {			lastLevelIndex = displayedLevels.size() - 1;		} else {			lastLevelIndex = levelsPerPage - 1;		}	}
675, public boolean isFieldActive() {		return textfieldGUI.isEnabled();	}
676, public void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {		for(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {			addLevel(collection.getLevel(levelNo));		}	}
677, public double setValue(double value) {		double rc = value;		if (value > maximumValue) {			rc = maximumValue;		} else if (value < minimumValue) {			rc = minimumValue;		} else {			rc = value;		}		textfieldGUI.setValue(rc);		return rc;			}
684, public void actionPerformed(ActionEvent actionevent) {		if (actionevent.getActionCommand() == "okbutton") {			dispose();		}	}
685, public void informAllUnsync(Generator<E> eventgen) {		/*		 * We must not directly use (weakhashmap.keySet()), since it still		 * is coupled to the weakhashmap itself, which needs synchronization.		 * Hence we first must obtain a copy.		 */		for (L listener : getListenersCopy()) {			final E evt = ((eventgen != null) ? eventgen.generate() : null);			caller.call(listener, evt);		}	}
687, public void setToStart() {		setTo(true);	}
688, public void setToStop() {		setTo(false);	}
690, private void setTo( boolean forStart ) {		String textkey = (forStart ? startkey : stopkey );		String action = (forStart ? startActionCommand : stopActionCommand);				setText(Texts.getText( textkey ));		setActionCommand( action );				setupBorder(forStart);		setupBgColor(forStart);	}
693, private void setupBorder(boolean forStart) {		setBorder( useBorder ? makeBorder(forStart) : null );	}
694, private void setupBgColor(boolean forStart) {		if (useBgColor) {			int rgb = (forStart ? bgColorStart : bgColorStop);						setBackground( new Color(rgb) );			setOpaque(false);		} else {					}	}
696, public Border makeBorder(boolean forStart) {		int rgb = (forStart ? borderColorStart : borderColorStop);		return makeRgbBorder(rgb, useRoundedCorners);	}
697, public Border makeStartBorder() {		return makeBorder(true);	}
699, public Border makeStopBorder() {		return makeBorder(false);	}
703, public void setUseBorder(boolean useBorder) {		this.useBorder = useBorder;	}
