{
    "321": "\tpublic int getPushesLowerbound() {\n\t\treturn pushesLowerbound;\n\t}\n",
    "323": "\tpublic void setPushesLowerbound(int pushesLowerbound) {\n\t\tthis.pushesLowerbound = pushesLowerbound;\n\t}\n",
    "324": "\t\tpublic void play() {\n\t\t\t\n\t\t\t// If no sound file is there nothing can be played.\n\t\t\tif(currentSoundFilename.equals(\"\"))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// Check if the this sound must be read from another file (the user has\n\t\t\t// chosen another sound to be played).\n\t\t\tString settingsFileName = Settings.get(soundSettingsKey);\n\t\t\tif(!currentSoundFilename.equals(settingsFileName)) {\n\t\t\t\tloadClip(settingsFileName);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Stop the currently playing sound to play the new sound if necessary.\n\t\t\tif (clip.isRunning()) {\n\t\t\t\tclip.stop();\n\t\t\t}\n\t\t\t\n\t\t\t// Rewind to the beginning.\n\t\t\tclip.setFramePosition(0); \n\t\t\t\n\t\t\t// Start playing.\n\t\t\tclip.start();    \n\t\t}\n",
    "343": "\tpublic int getInfluenceValue(int boxNo1, int boxNo2) {\n\t\treturn influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),\n\t\t\t\t                               board.boxData.getBoxPosition(boxNo2) );\n\t}\n",
    "351": "\tpublic void setPositions(int[] positions){\n\t\tthis.positions = positions;\n\t}\n",
    "352": "\tpublic int getPlayerPosition() {\n\t\treturn positions[positions.length-1];\n\t}\n",
    "355": "\tpublic int getPulledBoxNumber() {\n\t\treturn pulledBoxNo;\n\t}\n",
    "357": "\tpublic int getStartBoxPosition() {\n\t\treturn startPosition;\n\t}\n",
    "359": "\tpublic int getTargetBoxPosition() {\n\t\treturn targetPosition;\n\t}\n",
    "361": "    public BoardPositionPackingSequence getPrecedingBoardPosition() {\n    \treturn precedingBoardPosition;\n    }\n",
    "364": "\tpublic int compareTo(BoardPositionPackingSequence boardPosition) {\n\t\treturn boardPosition.getRelevance() - getRelevance();\n\t}\n",
    "373": "\tpublic boolean isForcedPush() {\n\t\treturn isPushForced;\n\t}\n",
    "376": "\tfinal public void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "412": "\tpublic boolean isSolverStoppedDueToOutOfMemory() {\n\t\treturn isSolverStoppedDueToOutOfMemory;\n\t}\n",
    "428": "    final protected IBoardPositionMoves getBestBoardPosition(){\n\n\t\t// Nimmt die Liste aller Stellungen mit einer bestimmten L\u00f6sungspfadl\u00e4nge auf\n\t\tLinkedList<IBoardPositionMoves> boardPositionList;\n\t\t\n\t\tfor(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {\n\t\t\n\t\t\t// Liste der Stellungen mit der aktuellen Pfadl\u00e4nge holen. \n\t\t\tboardPositionList = boardPositionQueue.get(solutionLength);\n\t\t\t\n\t\t\tif(boardPositionList.size() > 0){\t \n\t\t\t    shortestSolutionPathLength = solutionLength;\n\t\t\t    \n\t\t\t\t// Die zuletzt eingef\u00fcgte Stellung zur\u00fcckgeben\n\t    \t\treturn boardPositionList.removeLast();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "437": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn precedingBoardPosition;\n\t}\n",
    "440": "\tfinal public int getDirection() {\n\t\treturn positionData >>> 13;\n\t}\n",
    "442": "\tpublic int getBoxNo() {\n\t\treturn positionData & ((1 << 10) - 1);\n\t}\n",
    "445": "\tprotected String creatorName() {\n\t\treturn Texts.getText(\"solver\");\n\t}\n",
    "446": "\tfinal public int getPlayerPosition() {\n\t\treturn playerPosition;\n\t}\n",
    "448": "\tfinal public void setPositions(int[] positions) {\n\t\tthis.positions = positions;\n\t}\n",
    "450": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn null;\n\t}\n",
    "454": "\tfinal public void setSearchDirection(SearchDirection searchDirection) {\n\n\t\tif (searchDirection == SearchDirection.FORWARD) {\n\t\t\tforwardsSearch  = true;\n\t\t} else {\n\t\t\tbackwardsSearch = true;\n\t\t}\n\t}\n",
    "458": "\tfinal public int getDirection() {\n\t\treturn 0;\n\t}\n",
    "459": "\tpublic int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (BoardPosition currentBoardPosition = this; currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition()) {\n\t\t\tif (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn pushesCount;\n\t}\n",
    "461": "\tfinal public int getBoxNo() {\n\t\treturn NO_BOX_PUSHED;\n\t}\n",
    "463": "\tpublic void setMaximumSolutionLength(short maximumSolutionLength) {\n\t\tmaximumPushesCurrentIteration = maximumSolutionLength;\n\t}\n",
    "464": "\tfinal public int getPlayerPosition() {\n\t\treturn positions[boxCount];\n\t}\n",
    "466": "\tpublic short getMaximumSolutionLength() {\n\t\treturn maximumPushesCurrentIteration;\n\t}\n",
    "467": "\tfinal public int getPushesCount() {\n\t\treturn 0;\n\t}\n",
    "472": "\tprotected String solutionByMeAt(Date date) {\n\t\treturn  Texts.getText(\"createdBy\")\n\t\t      + \" \" + creatorName()\n\t\t      + \" \" + Utilities.dateString(date);\n\t}\n",
    "476": "\tfinal public void setMovesCount(int movesCount) {\n\t\tthis.movesCount = (short) movesCount;\n\t}\n",
    "487": "\tpublic int getIndexPackingSequence() {\n\t\treturn indexPackingSequence;\n\t}\n",
    "489": "\tpublic void setIndexPackingSequence(int indexPackingSequence) {\n\t\tthis.indexPackingSequence = indexPackingSequence;\n\t}\n",
    "494": "\tprotected boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "496": "\tfinal public boolean isBoxInactive() {\n\t\treturn (positionData & INACTIVE_BOX) > 0;\n\t}\n",
    "497": "\tpublic void setCorralDeadlock() {\n\t\tisDeadlock = true;\n\t}\n",
    "498": "\tpublic void setNotCorralDeadlock() {\n\t\tisNotDeadlock = true;\n\t}\n",
    "499": "\t\tpublic boolean getValue() {\n\t\t\t/*\n\t\t\t * Since we here are inside of class Settings, we should not get\n\t\t\t * an IllegalAccessException.\n\t\t\t * Hence, we catch the exceptions here, and return false,\n\t\t\t * just in case.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\treturn field.getBoolean(null);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "500": "\tprotected String solutionByMeNow() {\n\t\treturn solutionByMeAt(null);\n\t}\n",
    "501": "\tpublic void setCorralNo(int corralNo) {\n\t\tthis.corralNo = corralNo;\n\t}\n",
    "503": "\tpublic void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "504": "\tpublic int getCorralNo() {\n\t\treturn corralNo;\n\t}\n",
    "506": "\tpublic boolean isCorralDeadlock() {\n\t\treturn isDeadlock;\n\t}\n",
    "507": "\tpublic boolean isNotCorralDeadlock() {\n\t\treturn isNotDeadlock;\n\t}\n",
    "508": "\tpublic boolean isClassified() {\n\t\treturn isDeadlock || isNotDeadlock;\n\t}\n",
    "510": "\tpublic boolean isBeeingAnalyzed() {\n\t\treturn !isDeadlock && !isNotDeadlock;\n\t}\n",
    "513": "\tpublic CBoard getClone() {\n\t\treturn new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);\n\t}\n",
    "514": "\t\tpublic void setValue(boolean value) {\n\t\t\t/*\n\t\t\t * Regarding exceptions see comment in \"getValue\"\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tfield.setBoolean(null, value);\n\t\t\t\tSystem.out.println(\"Setting: DebugVar: \"+field.getName()+\" set to \"+value);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// well... forget it.\n\t\t}\n",
    "517": "\tprivate boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {\n\t\t\n\t\tint indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;\n\t\t\n\t\t// Compare byte by byte of both box configurations.\n\t\tfor(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {\n\t\t\tif (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n",
    "523": "\tpublic int getMaxCapacity() {\n\t\treturn maxCapacity;\n\t}\n",
    "524": "\tpublic void add(int boardPositionIndex, int boardPositionPredecessor) {\n\t\t\n\t\t// The moves queue also contains an arbitrary number of span markers.\n\t\t// Therefore after every added board position there must be done\n\t\t// a check whether the memory block is already full.\n\t\tadd(boardPositionIndex      );\n\t\tadd(boardPositionPredecessor);\n\t}\n",
    "531": "\tpublic void jumpOverBoardPosition(int boardPosition) {\n\t\n\t\t// \"Remove\" all values from the queue which are equal to the passed one\n\t\t// FFS/hm: does the caller guarantee that the Q cannot become empty by this?\n\t\twhile(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {\n\t\t\tremoveBoardPosition();\n\t\t}\n\t}\n",
    "535": "\tpublic int removeLastBoardPosition() {\n\t\t\t\t\t\t\n\t\tif(nextIndexToWrite == 0) {\n\t\t\t\n\t\t\t// The previous memory block becomes the new current memory block.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\n\t\t}\n\t\t\n\t\treturn memoryBlockToWrite.memory[--nextIndexToWrite];\n\t}\n",
    "538": "\tpublic void jumpXBoardPositionsBackwards(int jumpCount) {\n\t\t\n\t\twhile(jumpCount > nextIndexToWrite) {\n\t\t\t\t\t\t\t\n\t\t\t// Assign the previous memory block of the queue.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\t\n\t\t\tjumpCount -= nextIndexToWrite;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\t\t\t\t\t\n\t\t}\n\t\tnextIndexToWrite -= jumpCount;\n\t}\n",
    "542": "\tpublic boolean isEmpty() {\n\t\t// This method is only called for the moves queue which has recycling activated.\n\t\treturn memoryBlockToRead == memoryBlockToWrite\n\t\t    && nextIndexToRead   == nextIndexToWrite;\n\t}\n",
    "547": "\tpublic boolean isGenerationStoppedDueToFullStorage() {\n\t\treturn generationStoppedDueToFullStorage;\n\t}\n",
    "551": "\tpublic int getBoxConfigurationNumber() {\n\t\treturn uniqueBoxConfigurationNumber;\n\t}\n",
    "561": "\tpublic boolean isBetterMovesPushesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( movesCount , other.movesCount,\n\t\t                                   pushesCount, other.pushesCount )\n\t\t     < 0 ;\n\t}\n",
    "563": "\tpublic boolean isBetterPushesMovesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( pushesCount, other.pushesCount,\n\t\t                                   movesCount , other.movesCount  )\n\t\t     < 0 ;\n\t}\n",
    "568": "\tpublic void add(OptimizerBoardPosition boardPosition) {\n\n\t\t// Ensure that a real board position has been passed.\n        if (boardPosition == null)\n            throw new NullPointerException();\n\t\t\n\t\t// Double the size of the queue if it is full.\n\t\tif (count >= queue.length) {\n\t\t\tqueue = Arrays.copyOf(queue, queue.length * 2);\t\n\t\t}\t\t\n\t\t\n\t\t// Add the new value at the correct position. \n\t\tsiftUp(count, boardPosition);\n\t\t\n\t\t// One more board position has been stored => increase the counter.\n\t\tcount++;\n\t}\n",
    "570": "\tpublic int size() {\n\t\treturn count;\n\t}\n",
    "572": "\tpublic OptimizerBoardPosition removeFirst() {\n\n\t\tif (count == 0)\n\t\t\treturn null;\n\n\t\t// The head of the queue must be returned.\n\t\tOptimizerBoardPosition result = queue[0];\n\t\t\n\t\t// The head of the queue has (logically) been removed => adjust the size.\n\t\t--count;\n\t\t\n\t\t// Remove the last board position.\n\t\tOptimizerBoardPosition x = queue[count];\n\t\tqueue[count] = null;\n\t\t\n\t\t// If there is at least one board position left in the queue then \n\t\t// shift the board positions so the queue has a new head.\n\t\tif (count != 0)\n\t\t\tsiftDown(0, x);\n\n\t\treturn result;\n\t}\n",
    "576": "\tprivate void addLogTextStyle(final String text, final String stylename) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tStyledDocument doc = optimizerLog.getStyledDocument(); \n\t\t\t\t\tdoc.insertString(doc.getLength(), text+\"\\n\", doc.getStyle(stylename));\t\t\t\n\t\t\t\t} catch (BadLocationException e) {\t/* ignore */ }\n\t\t\t}\n\t\t});\n\t}\n",
    "577": "\t private void siftDown(int position, OptimizerBoardPosition boardPosition) {\n\t\t \n\t\t // Calculate the half of the size as the maximum position the loop must go to.\n\t\t int half = count >>> 1;        \n\t\t \n\t\t while (position < half) {\n\t\t\t int childIndex = (position << 1) + 1; // assuming the left child is the \"better\" board position\n\t\t\t OptimizerBoardPosition child = queue[childIndex];\n\t\t\t int rightChildIndex = childIndex + 1;\n\t\t\t if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)\n\t\t\t\t child = queue[childIndex = rightChildIndex];\n\t\t\t if (boardPosition.compareTo(child) <= 0)\n\t\t\t\t break;\n\t\t\t queue[position] = child;\n\t\t\t position = childIndex;\n\t\t }\n\t\t \n\t\t queue[position] = boardPosition;\n\t }\n",
    "580": "\tpublic int getNumberOfStoredBoardPositions() {\n\t\treturn count.get();\n\t}\n",
    "601": "\tpublic void removeAllMarkings() {\n\t\tmarkedSquares = null;\n\t}\n",
    "608": "\tpublic void showDeadlockQueryStats() {\n\t\tdlqTotStats.sumFrom(dlqCurStats);\n\t\tif ( ! dlqTotStats.equals(dlqCurStats)) {\n\t\t\tshow1DLQStats(\"total\", dlqTotStats, 0);\n\t\t}\n\t\t\n\t\tshow1DLQStats(\"this time\", dlqCurStats, dlqTotStats.dlqAsked);\n\t\tdlqCurStats.clear();\n\t}\n",
    "610": "\tprivate int getBoxConfigurationIndex(int boardPositionIndex) {\n\t\t// The board position may just been locked by another thread. However,\n\t\t// this method is only called for already completely stored board positions.\n\t\t// Hence, the index can't hold just the \"LOCKED\" value but must\n\t\t// always also contain a valid box configuration index.\n\t\treturn table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); \n\t}\n",
    "613": "\tfinal private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {\n\t\tfor (int i = 0; i < packedBoardByteSize; i++) {\n\t\t\tbyte b2 = boxConfigurationArray[indexInArray + i];\n\t\t\t// \"b2\" is a subset, if all its 1-bits survive the ANDing with the first byte\n\t\t\tif ((boxConfiguration1[i] & b2) != b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "617": "\tprivate int getPlayerPosition(int boardPositionIndex) {\n\t\t// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.\n\t\treturn table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;\n\t}\t\n",
    "619": "\t\tfinal private void doubleTreeSize() {\n\t\n\t\t\t// Double the tree size.\n\t\t\tint[] newArrayPointers = new int[2*2*treeSizeMax];\n\t\t\tSystem.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);\n\t\t\tarrayPointers = newArrayPointers;\n\t\n\t\t\tbyte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];\n\t\t\tSystem.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);\n\t\t\ttreeData = newArrayData;\n\t\n\t\t\ttreeSizeMax <<= 1;\n\t\t}\n",
    "626": "\t\tfinal private int treeToSortedListRecursively(int indexInTree, int last) {\n\t\n\t\t\t// If the end of the tree has been reached return the last index.\n\t\t\tif (indexInTree == -1) {\n\t\t\t\treturn last;\n\t\t\t}\n\t\n\t\t\t// Left side of the tree.\n\t\t\tint d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);\n\t\t\tsortedList[d++] = indexInTree;\n\t\n\t\t\t// Right side of the tree.\n\t\t\treturn (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));\n\t\t}\n",
    "637": "\tfinal public int getNumberOfSelectedObject() {\n\t\treturn currentlyMarkedObject;\n\t}\n",
    "638": "\t\tfinal private void binaryTreeToBinaryHeap() {\n\t\t\n\t\t\tbyte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];\n\t\t\n\t\t\tfor (int i=0, indexInVector = 0; i<treeSize; i++) {\n\t\t\t\tSystem.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);\n\t\t\t\tindexInVector += packedBoardByteSize;\n\t\t\t}\n\t\t\n\t\t\ttreeData = treeDataTemp;\n\t\t\tarrayPointers = null;\n\t\t}\n",
    "641": "\tfinal public void mouseWheelMoved(MouseWheelEvent evt) {\n\n\t\tint scrollDirection = evt.getWheelRotation();\n\n\t\t// Scrollen nach oben\n\t\tif (scrollDirection < 0 && currentlyMarkedObject > 0) {\n\t\t\tcurrentlyMarkedObject--;\n\t\t}\n\n\t\t// Scrollen nach unten\n\t\tif (scrollDirection > 0 && currentlyMarkedObject < 4) {\n\t\t\tcurrentlyMarkedObject++;\n\t\t}\n\n\t\tapplication.redraw(false);\n\t}\n",
    "643": "\tpublic void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {\n\t\t\n\t\t// Set/delete the \"processed\"-flag. This needn't to be done using compareAndSwap\n\t\t// because all of the other information stored at that offset have already been \n\t\t// stored and cannot change anymore while this method is executed.\n\t\tint currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);\n\t\tif(processedStatus == true)\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);\n\t\telse\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));\n\t}\n",
    "648": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * View on the levels\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "651": "\t\tprotected void finalize() {\n\t\t\tarrayPointers = null;\n\t\t\tsortedList = null;\n\t\t\ttreeData = null;\n\t\t}\n",
    "653": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * Language settings\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "656": "\tprivate void createPanel() {\n\t\t\n\t\tsetLayout(new BorderLayout());\n\n\t\tJPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));\n\t\tguiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));\n\n\t\t// Just a quick and dirty test coding ...\n\t\tNimRODFontDialog d = new NimRODFontDialog(null);\n\t\tComponent[] c = d.getContentPane().getComponents();\n\t\tguiPanel.add(c[0]);\n\t\t\n\t\tadd(guiPanel, BorderLayout.NORTH);\n\t}\n",
    "663": "\tprivate void updateElements() {\n\t\tfinal boolean selected = checkboxGUI.isSelected();\n\t\t\n\t\ttextfieldGUI.setEnabled(selected);\n\t\tlabelGUI.setEnabled(selected);\n\t}\n",
    "666": "\tpublic Double getValueAsDouble() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;\n\t}\n",
    "669": "\tpublic Integer getValueAsInteger() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;\n\t}\n",
    "670": "\tpublic void enterMeForTypeDate(JTable table) {\n\t\ttable.setDefaultRenderer(java.util.Date.class, this);\n\t}\n",
    "672": "\tpublic void addLevel(Level level) {\n\t\tdisplayedLevels.add(level);\n\t\tif (displayedLevels.size() < levelsPerPage) {\n\t\t\tlastLevelIndex = displayedLevels.size() - 1;\n\t\t} else {\n\t\t\tlastLevelIndex = levelsPerPage - 1;\n\t\t}\n\t}\n",
    "675": "\tpublic boolean isFieldActive() {\n\t\treturn textfieldGUI.isEnabled();\n\t}\n",
    "676": "\tpublic void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {\n\t\tfor(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {\n\t\t\taddLevel(collection.getLevel(levelNo));\n\t\t}\n\t}\n",
    "677": "\tpublic double setValue(double value) {\n\n\t\tdouble rc = value;\n\t\tif (value > maximumValue) {\n\t\t\trc = maximumValue;\n\t\t} else if (value < minimumValue) {\n\t\t\trc = minimumValue;\n\t\t} else {\n\t\t\trc = value;\n\t\t}\n\t\ttextfieldGUI.setValue(rc);\n\n\t\treturn rc;\t\t\n\t}\n",
    "684": "\tpublic void actionPerformed(ActionEvent actionevent) {\n\t\tif (actionevent.getActionCommand() == \"okbutton\") {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "685": "\tpublic void informAllUnsync(Generator<E> eventgen) {\n\t\t/*\n\t\t * We must not directly use (weakhashmap.keySet()), since it still\n\t\t * is coupled to the weakhashmap itself, which needs synchronization.\n\t\t * Hence we first must obtain a copy.\n\t\t */\n\t\tfor (L listener : getListenersCopy()) {\n\t\t\tfinal E evt = ((eventgen != null) ? eventgen.generate() : null);\n\t\t\tcaller.call(listener, evt);\n\t\t}\n\t}\n",
    "687": "\tpublic void setToStart() {\n\t\tsetTo(true);\n\t}\n",
    "688": "\tpublic void setToStop() {\n\t\tsetTo(false);\n\t}\n",
    "690": "\tprivate void setTo( boolean forStart ) {\n\t\tString textkey = (forStart ? startkey           : stopkey          );\n\t\tString action  = (forStart ? startActionCommand : stopActionCommand);\n\t\t\n\t\tsetText(Texts.getText( textkey ));\n\t\tsetActionCommand( action );\n\t\t\n\t\tsetupBorder(forStart);\n\t\tsetupBgColor(forStart);\n\t}\n",
    "693": "\tprivate void setupBorder(boolean forStart) {\n\t\tsetBorder( useBorder ? makeBorder(forStart) : null );\n\t}\n",
    "694": "\tprivate void setupBgColor(boolean forStart) {\n\t\tif (useBgColor) {\n\t\t\tint rgb = (forStart ? bgColorStart : bgColorStop);\n\t\t\t\n\t\t\tsetBackground( new Color(rgb) );\n\t\t\tsetOpaque(false);\n\t\t} else {\n\t\t\t// FFS/hm: should we actively put away a background color?\n\t\t}\n\t}\n",
    "696": "\tpublic Border makeBorder(boolean forStart) {\n\t\tint rgb = (forStart ? borderColorStart : borderColorStop);\n\t\treturn makeRgbBorder(rgb, useRoundedCorners);\n\t}\n",
    "697": "\tpublic Border makeStartBorder() {\n\t\treturn makeBorder(true);\n\t}\n",
    "699": "\tpublic Border makeStopBorder() {\n\t\treturn makeBorder(false);\n\t}\n",
    "703": "\tpublic void setUseBorder(boolean useBorder) {\n\t\tthis.useBorder = useBorder;\n\t}\n",
    "706": "\tpublic void setUseBgColor(boolean useBgColor) {\n\t\tthis.useBgColor = useBgColor;\n\t}\n",
    "710": "\tpublic void setBorderColorStart(int borderColorStart) {\n\t\tthis.borderColorStart = borderColorStart;\n\t}\n",
    "715": "\tpublic void setBorderColorStop(int borderColorStop) {\n\t\tthis.borderColorStop = borderColorStop;\n\t}\n",
    "718": "\tpublic void setBgColorStart(int bgColorStart) {\n\t\tthis.bgColorStart = bgColorStart;\n\t}\n",
    "721": "\tpublic void setBgColorStop(int bgColorStop) {\n\t\tthis.bgColorStop = bgColorStop;\n\t}\n",
    "722": "\tstatic private boolean isOutsideClip(int x, int y, int xlen, int ylen, Rectangle clip) {\n\n\t\t// Non-existing rectangle stands for the complete plane => nothing is outside of the complete plane.\n\t\t// We are \"outside\" of \"clip\", if we do not intersect with it.\n\t\treturn clip != null && ! clip.intersects(x, y, xlen, ylen);\n\t\t\n\t}\n",
    "741": "\tpublic boolean hasAlias() {\n\t\treturn (alias.length() > 0);\n\t}\n",
    "743": "\tpublic String getAlias() {\n\t\treturn alias;\n\t}\n",
    "746": "\tpublic void setAlias(String newAlias) {\n\t\talias = newAlias;\n\t}\n",
    "747": "\tpublic String getPath() {\n\t\treturn path;\n\t}\n",
    "750": "\tpublic String getName() {\n\t\tif (hasAlias()) {\n\t\t\treturn alias;\n\t\t}\n\t\treturn path;\n\t}\n",
    "752": "\tpublic String getDisplayName() {\n\t\tif (hasAlias()) {\n\t\t\treturn '[' + alias + ']';\n\t\t}\n\t\treturn path;\n\t}\n",
    "753": "\tprivate BufferedImage extractGraphicTwoCoordinates(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tPoint graphicCoordinates = getPoint(graphicName);\n\t\t\tif(graphicCoordinates != null) {\n\t\t\t\treturn entireGraphic.getSubimage(graphicCoordinates.x * graphicWidth,\n\t\t\t\t\t\t                         graphicCoordinates.y * graphicHeight,\n\t\t\t\t\t\t                         graphicWidth, graphicHeight);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "754": "\tpublic Color getColor() {\n\t\treturn color;\n\t}\n",
    "755": "\tpublic void setColor(String color) {\n\t\tthis.color = parseColor(color);\n\t}\n",
    "756": "\tpublic void setBoardToDisplay(Board board) {\n\n\t\t// Save the reference.\n\t\tthis.board = board;\n\n\t\t// Create new array for storing information about which positions have to be drawn when repainting.\n\t\tgraphicStatus = new byte[board.size];\n\n\t\t// Initialize the debug array used for showing numbers on the board.\n\t\tArrays.fill(numbersToShow, -1);\n\n\t\t// Reset the transformation of the board.\n\t\ttransformBoard(-1);\n\t}\n",
    "758": "\tpublic String getColorString() {\n\t\treturn colorToString(color);\n\t}\n",
    "759": "\tprivate BufferedImage extractGraphicOneCoordinate(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tint xCoordinate = getInt(graphicName, -1);\n\t\t\tif(xCoordinate == -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn entireGraphic.getSubimage(xCoordinate * graphicWidth, 0, graphicWidth, graphicHeight);\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "764": "\tprivate String trimValue(String propertyValue) {\n\t\n\t\tif (propertyValue == null || propertyValue.length() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\n\t\tint lastpos = propertyValue.indexOf('#');\n\t\tif (lastpos == -1) {\n\t\t\tlastpos = propertyValue.length() - 1;\n\t\t}\n\t\t\n\t\t\n\t\tfor(; lastpos >= 0 ; --lastpos ) {\n\t\t\tchar c = propertyValue.charAt(lastpos);\n\t\t\tif (c != ' ' && c != '\\t') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Now, \"lastpos\" indexes the last char to be retained (or -1 if there is none)\n\t\t\n\t\t// Return the trimmed value.\n\t\treturn propertyValue.substring(0, lastpos + 1);\n\t}\n",
    "772": "\tstatic public String getTransformationAsString() {\n\n\t\t// If the level isn't displayed transformed return an empty String.\n\t\tif (getRotationValue() == ROTATION_BY_0_DEGREES && isLevelFlippedHorizontally() == false) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Build the transformation string and return it.\n\t\tString transformationString = \"View: Rotated \"\n\t\t\t                        + getRotationAsString()\n\t\t\t                        + \" degrees clockwise\";\n\t\tif (isLevelFlippedHorizontally()) {\n\t\t\ttransformationString += \", flipped horizontally.\";\n\t\t} else {\n\t\t\ttransformationString += \".\";\n\t\t}\n\n\t\treturn transformationString;\n\t}\n",
    "774": "\tpublic T generate() {\n\t\treturn base;\n\t}\n",
    "779": "\tfinal private JButton createToolBarButton(String iconName, String actionCommand, String toolTipText) {\n\n\t\t// Create and initialize the button.\n\t\tJButton button = new JButton(Utilities.getIcon(iconName, null));\n\t\tbutton.setActionCommand(actionCommand);\n\t\tbutton.setToolTipText(toolTipText);\n\t\tbutton.addActionListener(this);\n\n\t\t// The buttons must be clicked with the mouse.\n\t\tbutton.setFocusable(false);\n\n\t\treturn button;\n\t}\n",
    "781": "\tpublic Skin getCurrentSkin() {\n\t\treturn skin;\n\t}\n",
    "784": "\tprivate String getString(String name, String ... defaultValue) {\n\t\n\t\t// Get the value of the property.\n\t\tString propertyValue = trimValue(properties.getProperty(name));\n\t\n\t\t// If the the property couldn't be found set the default value.\n\t\tif (propertyValue == null) {\n\t\t\tif(defaultValue.length > 0) {\n\t\t\t\treturn defaultValue[0];\n\t\t\t}\n\t\t}\n\t\n\t\treturn propertyValue;\n\t}\n",
    "785": "\tfinal private JButton createToolBarButtonByKey(String iconName, String actionCommand, String toolTipTextKey) {\n\t\tString toolTipText = Texts.getText(toolTipTextKey);\n\t\treturn createToolBarButton(iconName, actionCommand, toolTipText);\n\t}\n",
    "787": "\tpublic void setSkinAnimationDelay(int delay) {\n\n\t\t// Save the delay in the settings.\n\t\tSettings.set(\"skinAnimationDelay\", \"\" + delay);\n\n\t\t// If a timer is running set the new delay value.\n\t\tif (animationTimer != null && animationTimer.isRunning()) {\n\t\t\tanimationTimer.setDelay(delay);\n\t\t}\n\t}\n",
    "793": "\tpublic void setViewDirection(int viewDirection) {\n\t\tthis.viewDirection = (byte) viewDirection;\n\t}\n",
    "800": "\tpublic void setMaximumScalingFactor(int maximumScalingFactor) {\n\n\t\tmaximumScaling = maximumScalingFactor;\n\n\t\trecalculateGraphicSizes();\n\t\trepaint();\n\n\t\t// Save the zooming factor.\n\t\tSettings.set(\"maximumScaling\", \"\" + maximumScaling);\n\t}\n",
    "805": "\tpublic void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "806": "\tpublic void transformBoard(int transformationValue) {\n\n\t\t// Tell it to the Transformation class.\n\t\tTransformation.transform(transformationValue);\n\n\t\t// Since the transformation may have exchanged height and width, we force a\n\t\t// recalculation of the graphics, as if we had loaded a new level.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Show new graphics\n\t\trepaint();\n\t}\n",
    "808": "\tpublic void setLevelToDisplay(Level levelToBeDisplayed) {\n\t\t\n\t\t// Create an own board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Set the passed level on the board.\n\t\ttry {\n\t\t\tboard.setBoardFromString(levelToBeDisplayed.getBoardDataAsString());\n\t\t} catch (Exception e) {\n\t\t\t// Show the error message.\n\t\t\tUtilities.showExceptionError(this, e);\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "810": "\tpublic void setBoardToDisplay(String boardAsString) {\n\t\t\n\t\t// Create an new board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Create an own board from the board of the level.\n\t\ttry {\n\t\t\tboard.setBoardFromString(boardAsString);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "813": "\tpublic void setInfoBarVisible(boolean visibleStatus) {\n\t\tisInfoBarVisible = visibleStatus;\n\t}\n",
    "814": "\tpublic void setBoardToDisplay(Board board) {\n\t\t\n\t\tthis.board = board;\n\t\t\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "816": "\tpublic Board getBoard() {\n\t\treturn board;\n\t}\n",
    "819": "\tpublic Level getDisplayedLevel() {\n\t\treturn displayedLevel;\n\t}\n",
    "821": "\tpublic int getSquareWidth() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicWidth;\n\t}\n",
    "823": "\tpublic int getSquareHeight() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicHeight;\n\t}\n",
    "824": "\tfinal public void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "827": "\tprivate void setInitialBoardPosition() {\n\t\tboard      = boardInitial.boardElements.clone();\n\t\tplayerPosX = boardInitial.playerPositionX;\n\t\tplayerPosY = boardInitial.playerPositionY;\n\t}\n",
    "835": "\tpublic void paintImmediately() {\n\t\tpaintImmediately(0, 0, getWidth(), getHeight());\n\t}\n",
    "840": "\tprivate void packBoxConfiguration(byte[] newPackedBoxConfiguration, byte[] unpackedBoxConfiguration) {\n\n\t\tint bytePosition = 0, bitPosition = 0;\n\n\t\t// Loop over all internal box positions.\n\t\tfor (int i = 0; i < boxPositionsCount; i++) {\n\n\t\t\tbytePosition = i >> 3;\n\t\t\tbitPosition  = i & 7;\n\n\t\t\tif ((unpackedBoxConfiguration[boxInternalToExternalPosition[i]] & BOX) == BOX)\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] |= 1 << bitPosition;\n\t\t\telse\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] &= (255 - (1 << bitPosition));\n\t\t}\n\t}\n",
    "856": "\tprivate void setVisited(int boardPositionIndex) {\n\t\tint bytePosition = (boardPositionIndex >>> 3), bitPosition = (boardPositionIndex & 7);\n\t\tvisitedData[bytePosition] |= (1 << bitPosition);\n\t}\n",
    "863": "\tfinal public void setCursor(int cursor) {\n\n\t\t// Set the specified predefined cursor.\n\t\tmainBoardDisplay.setCursor(Cursor.getPredefinedCursor(cursor));\n\t}\n",
    "865": "\tprotected void adjustToBoard(Point p) {\n\t\t\n\t\t// Clip both point coordinates at their allowed minimum (inclusive).\n\t\tif( p.x < xOffset ) {\n\t\t\tp.x = xOffset;\n\t\t}\n\t\tif( p.y < yOffset ) {\n\t\t\tp.y = yOffset;\n\t\t}\n\t\t\n\t\t// Compute maximal point coordinates, inclusive...\n\t\tint xmax = xOffset + Transformation.getOutputLevelWidth()  * skin.graphicWidth  - 1;\n\t\tint ymax = yOffset + Transformation.getOutputLevelHeight() * skin.graphicHeight - 1;\n\t\t\n\t\t// ... and use them to clip off larger values:\n\t\tif( p.x > xmax ) {\n\t\t\tp.x = xmax;\n\t\t}\n\t\tif( p.y > ymax ) {\n\t\t\tp.y = ymax;\t\n\t\t}\n\t}\n",
    "866": "\tprivate void paintExtSqRect(int xmin, int ymin, int extWidth, int extHeight) {\n\t\tint pixXmin   = xOffset + xmin * skin.graphicWidth;\n\t\tint pixYmin   = yOffset + ymin * skin.graphicHeight;\n\t\tint pixWidth  =      extWidth  * skin.graphicWidth;\n\t\tint pixHeight =      extHeight * skin.graphicHeight;\n\t\t\n\t\tif (pixWidth > 0 || pixHeight > 0) {\n\t\t\trepaint(pixXmin, pixYmin, pixWidth, pixHeight);\n\t\t\tpaintMovesPushes();\n\t\t}\n\t}\n",
    "870": "\tpublic int getInfluenceDistance(int startSquare, int targetSquare) {\n\t\treturn influenceDistances[startSquare][targetSquare];\n\t}\n",
    "871": "\tfinal public void setNewLanguage() {\n\n\t\t// Create a new menu bar and and a new tool bar according to the new language.\n\t\tapplication.setJMenuBar(createMenuBar());\n\t\tcreateToolBar();\n\t}\n",
    "872": "\tprivate boolean isVisited(int boardPositionIndex) {\n\t\tint i = (boardPositionIndex >>> 3), j = (boardPositionIndex & 7);\n\t\treturn (visitedData[i] & (1 << j)) > 0;\n\t}\n",
    "874": "\tfinal public void addPlayerMove(int direction) {\n\t\taddMovement(direction, -1);\n\t}\n",
    "876": "\t\tpublic void clear() {\n\t\t\tminX = Integer.MAX_VALUE;\n\t\t\tmaxX = Integer.MIN_VALUE;\n\t\t\tminY = Integer.MAX_VALUE;\n\t\t\tmaxY = Integer.MIN_VALUE;\n\t\t}\n",
    "877": "\tfinal public HistoryElement getSuccessorMovement() {\n\t\tif (hasSuccessorMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( ++currentMovementNo );\n\t}\n",
    "878": "\tfinal public HistoryElement getPrecedingMovement() {\n\t\tif (hasPrecedingMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( currentMovementNo-- );\n\t}\n",
    "881": "\tfinal public HistoryElement getMovement(int movementNo) {\n\n\t\tif (movementNo < 0 || movementNo > movementHistory.size() - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get(movementNo);\n\t}\n",
    "882": "\tfinal public int getCurrentMovementNo() {\n\t\treturn currentMovementNo;\t\n\t}\n",
    "883": "\t\tpublic boolean isEmpty() {\n\t\t\treturn (minX > maxX) || (minY > maxY);\n\t\t}\n",
    "884": "\tfinal public int getMovementsCount() {\n\t\treturn movementHistory.size();\n\t}\n",
    "885": "\tfinal public int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (HistoryElement historyElement : movementHistory) {\n\t\t\tif (historyElement.pushedBoxNo != -1) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\t\treturn pushesCount;\n\t}\n",
    "889": "\tfinal public String getLURDString() {\n\t\treturn getLURDString(0, currentMovementNo);\n\t}\n",
    "890": "\t\tpublic void add(int x, int y) {\n\t\t\tminX = Math.min(minX, x);\n\t\t\tmaxX = Math.max(maxX, x);\n\t\t\tminY = Math.min(minY, y);\n\t\t\tmaxY = Math.max(maxY, y);\n\t\t}\n",
    "891": "\tfinal public String getLURDStringTotal() {\n\t\treturn getLURDString(0, getMovementsCount() - 1);\n\t}\n",
    "893": "\tfinal public void setHistoryToStart() {\n\t\tcurrentMovementNo = -1;\n\t}\n",
    "895": "\tfinal public void setMovementNo(int movementNo) {\n\t\tcurrentMovementNo = movementNo;\n\t}\n",
    "897": "\tfinal public void setStartOfCombinedMovement() {\n\t\tisStartOfCombinedMovement = true;\n\t}\n",
    "898": "\t\tpublic void addExternal(int externalPos) {\n\t\t\tif (externalPos != -1) {\n\t\t\t\tint externalWidth = Transformation.getOutputLevelWidth();\n\t\t\t\tint extX = externalPos % externalWidth;\n\t\t\t\tint extY = externalPos / externalWidth;\n\t\t\t\t\n\t\t\t\tadd(extX, extY);\n\t\t\t}\n\t\t}\n",
    "900": "\tfinal public void goToPrecedingMovement() {\n\t\tcurrentMovementNo--;\n\t}\n",
    "903": "\tfinal public void goToNextMovement() {\n\t\t++currentMovementNo;\n\t}\n",
    "904": "\t\tpublic void addInternal(int internalPos) {\n\t\t\tif (internalPos != -1) {\n\t\t\t\tint externalPos = Transformation.getExternalPosition(internalPos);\n\t\t\t\t\n\t\t\t\taddExternal(externalPos);\n\t\t\t}\n\t\t}\n",
    "905": "\tfinal public boolean hasPrecedingMovement() {\n\t\treturn currentMovementNo >= 0;\n\t}\n",
    "908": "\tfinal public boolean hasSuccessorMovement() {\n\t\treturn (currentMovementNo + 1) < movementHistory.size();\n\t}\n",
    "910": "\tprivate void paintMovesPushes() {\n\t\t// Moves and pushes are displayed as part of the history slider panel.\n\t\tif (historySliderPanel != null) {\n\t\t\t// We have to include the textual representation, as well as the graphical\n\t\t\t// slider representation.  That includes most of the area.\n\t\t\tint w = historySliderPanel.getWidth();\n\t\t\tint h = historySliderPanel.getHeight();\n\t\t\t\n\t\t\t// Redraw the slider. This needn't to be done immediately. Repaint is much\n\t\t\t// faster then paintImmediately.\n\t\t\thistorySliderPanel.repaint(0, 0, w, h);\n\t\t}\n\t}\n",
    "911": "\tfinal public int combinedLengthPreceding() {\n\t\tint steps = 0;\n\t\t\n\t\tfor( int mNo = currentMovementNo; mNo >= 0 ; --mNo ) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn steps;\n\t}\n",
    "913": "\tfinal public int combinedLengthSuccessor() {\n\t\tint steps = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\t++mNo;\n\t\t\t\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn steps;\n\t}\n",
    "915": "\tfinal public int countCombinedForward() {\n\t\tint starts = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\t++starts;\n\t\t\t} else if( starts == 0 ) {\n\t\t\t\t++starts;\n\t\t\t}\n\t\t\t++mNo;\n\t\t}\n\t\t\n\t\treturn starts;\n\t}\n",
    "918": "\tfinal public float averageLengthCombinedForward() {\n\t\tint len = getMovementsCount() - currentMovementNo;\n\t\tif( len <= 0 ) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tint cntcombined = countCombinedForward();\n\t\treturn (float)len / cntcombined;\n\t}\n",
    "932": "\tpublic boolean isABoxBeenMoved() {\n\t\treturn pushedBoxNo != -1;\n\t}\n",
    "939": "\tprivate MouseListener getMouseListener() {\n\t\treturn new MouseAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e) {\n\t\t\t\tif(e.getClickCount() > 1) {\n\t\t\t\t\tint index = locationToIndex(e.getPoint());\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// This action can be disabled (for instance when the solver is running).\n\t\t\t\t\t\tif(!isTakeSolutionAsHistoryEnabled) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSolution clickedSolution = (Solution) listModel.getElementAt(index);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the selected solution as new history in the game.\n\t\t\t\t\t\tapplication.takeSolutionForHistory(clickedSolution);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n",
    "941": "\tfinal public void setEditorMenuItemEnabled(boolean enabled) {\n\t\teditorMenuItem.setEnabled(enabled);\n\t}\n",
    "948": "\tfinal public JMenuItem getSaveLevelMenuItem() {\n\t\treturn saveLevelMenuItem;\n\t}\n",
    "954": "\tfinal public JButton getInfoButton() {\n\t\treturn infoButton;\n\t}\n",
    "960": "\tfinal public void setModeDependentObjectStatus() {\n\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component button : playModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isPlayModeActivated());\n\t\t\t\t}\n\n\t\t\t\tfor (AbstractButton button : editorModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isEditorModeActivated());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "966": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boardPositionIndex, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boardPositionIndex / playerSquaresCount);\n\t\tint playerPosition = boardPositionIndex % playerSquaresCount;\n\t\tdebugDisplayBoxConfiguration(temp, playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "969": "\tpublic void setSolutionColor(Solution solution, Color color) {\n\t\tif(color == null) {\n\t\t\tcoloredSolutions.remove(solution);\n\t\t} else {\n\t\t\tcoloredSolutions.put(solution, color);\n\t\t}\n\t}\n",
    "971": "\tfinal public void setSolverDependentObjectsEnabled(final boolean enabledStatus) {\n\t\t\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : solverModeDependentObjects) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "972": "\t\tpublic boolean isValidNewSolution() {\n\t\t\treturn this != INVALID_SOLUTION && this != DUPLICATE_SOLUTION;\n\t\t}\n",
    "973": "\tpublic void setAllSolutionsUncolored() {\n\t\tcoloredSolutions.clear();\n\t}\n",
    "974": "\tprivate void setSelectedViewRow(int viewrowindex) {\n\t\tif (       (viewrowindex >= 0)\n\t\t\t\t&& (tableModelSolutionData != null)\n\t\t\t\t&& (tableModelSolutionData.getRowCount() > 0)\n\t\t\t\t&& (tableSolutionData != null)) {\n\t\t\tListSelectionModel lsm = tableSolutionData.getSelectionModel();\n\t\t\tlsm.setSelectionInterval(viewrowindex, viewrowindex);\n\t\t}\n\t}\n",
    "976": "\tpublic void addActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.register(actionListener);\n\t}\n",
    "979": "\tprotected void showNoSolutionsSelected() {\n\t\tUtilities.showInfoNoteTextKey(getParent(), \"solutionList.noSolutionSelected\");\n\t}\n",
    "980": "\tpublic void removeActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.unregister(actionListener);\n\t}\n",
    "982": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boxConfigurationIndex, int playerPosition, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boxConfigurationIndex);\n\t\tdebugDisplayBoxConfiguration(temp,playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "984": "\tfinal public void setUndoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : undoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "985": "\t\tpublic void mouseDragged(MouseEvent evt) {\n\t\t\n\t\t\tif(isMouseDragged == false) {\n\t\t\t\n\t\t\t\tstartOfLastDrag = evt.getWhen();\n\t\t\t\t\n\t\t\t\t// Save the dragged status.\n\t\t\t\tisMouseDragged = true;\n\t\t\t}\n\t\t\t\n\t\t\tmousePressed(evt);\n\t\t}\t\t\n",
    "987": "\tprivate void informThemHere(final Solution solution, final String action) {\n\t\tactionListenerSet.informAllSync(makeActionGenerator(solution, action));\n\t}\n",
    "989": "\tprivate void informListeners(final Solution solution, final String action) {\n\t\n\t\t// The GUI should be updated in the EDT.\n\t\tif(SwingUtilities.isEventDispatchThread()) {\n\t\t\tinformThemHere(solution, action);\n\t\t}\n\t\telse {\n\t\t\t// Update the GUI before this thread continues. \n\t\t\ttry {\n\t\t\t\tSwingUtilities.invokeAndWait(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tinformThemHere(solution, action);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t} catch (InvocationTargetException e) { /* just continue */ }\n\t\t}\n\t}\n",
    "993": "\tpublic void setTakeSolutionAsHistoryVisible(boolean isVisible) {\n\t\tisTakeSolutionAsHistoryEnabled = isVisible;\n\t}\n",
    "996": "\tfinal public void setRedoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : redoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "1000": "\t\tpublic void addSolutionToBeHighlighted(Solution solution) {\n\t\t\thighlightedSolutions.put(solution, 10);\n\t\t\t\n\t\t\t// Inform this thread that new solutions are to be highlighted.\n\t\t\tsynchronized(this) {\n\t\t\t\tnotify();\n\t\t\t}\n\t\t}\n",
    "1002": "\t\tpublic void removeAllSolutionsToBeHighlighted() {\n\t\t\thighlightedSolutions.clear();\n\t\t}\n",
    "1006": "\t\tpublic Integer getHighlightIntensity(Solution solution) {\n\t\t\treturn highlightedSolutions.get(solution);\n\t\t}\n",
    "1014": "\tfinal public void setInvalidLevelModeDependentObjectsEnabled(boolean enabledStatus) {\n\n\t\tfor (Component component : invalidLevelModeDependentObjects) {\n\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t}\n\n\t\t// An invalid level can't have a movement history.\n\t\t// Hence, disable the undo/redo buttons.\n\t\tsetUndoButtonsEnabled(enabledStatus);\n\t\tsetRedoButtonsEnabled(enabledStatus);\n\n\t\t// Enable the editor menu item so the user can open the editor.\n\t\tsetEditorMenuItemEnabled(true);\n\t}\n",
    "1015": "\tpublic boolean isValidLastChanged() {\n\t\tif (lastChanged != null) {\n\t\t\tif (lastChanged.getTime() > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1025": "\tfinal public void setDebugMenuVisible(boolean isToBeVisible) {\n\t\tfor (Component component : debugModeDependentObjects) {\n\t\t\tcomponent.setVisible(isToBeVisible);\n\t\t}\n\t}\n",
    "1035": "\tpublic SolutionsGUI getSolutionsView() {\n\t\treturn solutionsGUI;\n\t}\n",
    "1041": "\tfinal public void update(String expression) {\n\n\t\ttry {\n\t\t\tStatement st = conn.createStatement();\n\n\t\t\t// Run the query.\n\t\t\tif (st.executeUpdate(expression) == -1) {\n\t\t\t\tSystem.out.println(\"db error: \" + expression);\n\t\t\t}\n\n\t\t\t// Close the Statement object.\n\t\t\tst.close();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n",
    "1046": "\tprivate void waitForDeadlockIdentification() {\n\t\ttry {\n\t\t\tif(deadlockIdentification.isAlive()) {\n\t\t\t\toptimizerGUI.setInfoText(Texts.getText(\"optimizer.waitingForDeadlockDetection\"));\n\t\t\t\tdeadlockIdentification.join();\n\t\t\t}\n\t\t} catch (InterruptedException e) {}\n\t}\n",
    "1049": "\tfinal public void saveLevel(Level level, String fileName) throws IOException {\n\n\t\t// Create a PrintWriter for writing the data to hard disk.\n\t\tPrintWriter levelFile = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));\n\n\t\t// Write the level data to the file.\n\t\twriteLevelToFile(level, levelFile);\n\n\t\t// Check the error status.\n\t\tboolean isFileSavingFailed = levelFile.checkError();\n\n\t\t// Close the file.\n\t\tlevelFile.close();\n\n\t\t// Throw exception in the case of an error.\n\t\tif (isFileSavingFailed) {\n\t\t\tthrow new IOException(Texts.getText(\"errorBySaving\"));\n\t\t}\n\t}\n",
    "1055": "\tfinal public int getSquareCharacter(int xPosition, int yPosition) {\n\n\t\t// Select the line by the Y coordinate\n\t\tif (yPosition < 0 || yPosition >= boardData.size()) {\n\t\t\treturn ' ';\n\t\t}\n\t\tfinal String line = boardData.get(yPosition);\n\t\t\n\t\t// The level lines need not be filled with spaces at the end.\n\t\t// Such a line may be shorter than the level width.\n\t\tif (xPosition < 0 || xPosition >= line.length()) {\n\t\t\treturn ' ';\n\t\t}\n\n\t\treturn line.charAt(xPosition);\n\t}\n",
    "1066": "\tprotected void refreshView() {\n\t\tactionPerformed(new ActionEvent(this, 0, \"refreshView\"));\n\t}\n",
    "1071": "\t\tpublic int getID() {\n\t\t\treturn ID;\n\t\t}\n",
    "1092": "\tprotected void updateComboBoxAuthors() {\n\t\t\n\t\t// Update all needed ComoboBoxes of this view.\n\t\tsuper.updateComboBoxAuthors(comboBoxAuthors, selectionAuthor);\n\t\t\n\t\t// When adding new items the combo boxes should not fire actions.\n\t\t// (If this isn't set the combo boxes refresh the views every time their content changes)\n\t\tdoNotFireActions = true;\n\t\t\n\t\t// The selection ComboBox's first item is always the wildcard \"*\".\n\t\tselectionAuthor.insertItemAt(new ComboBoxEntry(\"*\", 0), 0);\n\t\t\n\t\t// Set the wildcard as selected.\n\t\tselectionAuthor.setSelectedIndex(0);\n\t\t\n\t\t// Actions may be fired again.\n\t\tdoNotFireActions = false;\n\t}\n",
    "1097": "    protected void finalize() {\n    \tdatabaseViews.dispose();\n    \tdatabaseViews = null;\n    }\n",
    "1098": "    \tstatic public void authorsNamesChanged() {\n    \t\tfor(int i=0; i<changeInAuthorView.length; i++) {\n    \t\t\tchangeInAuthorView[i] = true;\n    \t\t}\n    \t}\n",
    "1100": "    \tstatic public void collectionNamesChanged() {\n    \t\tfor(int i=0; i<changeInCollectionView.length; i++) {\n    \t\t\tchangeInCollectionView[i] = true;\n    \t\t}\n    \t}\n",
    "1102": "    \tstatic public void changeInAssignmentView() {\n    \t\tfor(int i=0; i<changeInAssignmentView.length; i++) {\n    \t\t\tchangeInAssignmentView[i] = true;\n    \t\t}\n    \t}\n",
    "1103": "    \tstatic public void changeInLevelView() {\n    \t\tfor(int i=0; i<changeInLevelView.length; i++) {\n    \t\t\tchangeInLevelView[i] = true;\n    \t\t}\n    \t}\n",
    "1107": "    \tstatic public void resetUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = false;\n        \tchangeInCollectionView[view] = false;\n        \tchangeInAssignmentView[view] = false;\n        \tchangeInLevelView[view]      = false;\n    \t}\n",
    "1108": "    \tstatic public void setUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = true;\n        \tchangeInCollectionView[view] = true;\n        \tchangeInAssignmentView[view] = true;\n        \tchangeInLevelView[view]      = true;\n    \t}\n",
    "1114": "\tprotected void updateAdditionalInformation() {\n\t\tint firstSelectedRow = tableLevelData.convertRowIndexToModel(tableLevelData.getSelectionModel().getMinSelectionIndex());\n\t\tvalueChanged(new ListSelectionEvent(tableLevelData.getSelectionModel(), firstSelectedRow, firstSelectedRow, false));\n\t}\n",
    "1115": "\tfinal public int getNumberOfStoredBoardPositions() {\n\t\treturn count;\n\t}\n",
    "1120": "\tfinal public void clear() {\n\t\t// This code is similar to hash table.clear()\n\t\tEntry tab[] = table;\n\t\t\n\t\tfor (int index = tab.length; --index >= 0;) {\n\t\t\ttab[index] = null;\n\t\t}\n\t\tcount = 0;\n\t}\n",
    "1123": "\t\tpublic Object getBoardPosition() {\n\t\t\treturn boardPosition;\n\t\t}\n",
    "1125": "\tprotected Object getSelectedCollection() {\n\t\treturn selectionCollection.getSelectedItem();\n\t}\n",
    "1127": "\tprotected int bytesPerAtom() {\n\t\treturn (4);\n\t}\n",
    "1129": "\tprotected int bytesPerLine() {\n\t\treturn (72);\n\t}\n",
    "1135": "\t\tprotected int decodeLinePrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException {\n\t\t\treturn (bytesPerLine());\n\t\t}\n",
    "1138": "\t\tprotected void decodeAtom(PushbackInputStream aStream, OutputStream bStream, int l) throws IOException {\n\t\t\tthrow new IOException();\n\t\t}\n",
    "1144": "\t\tpublic byte decodeBuffer(String inputString)[] throws IOException {\n\t\t\tbyte    inputBuffer[] = new byte[inputString.length()];\n\t\t\tByteArrayInputStream inStream;\n\t\t\tByteArrayOutputStream outStream;\n\n\t\t\tinputBuffer = inputString.getBytes();\n\t\t\tinStream = new ByteArrayInputStream(inputBuffer);\n\t\t\toutStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(inStream, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1146": "\t\tpublic byte decodeBuffer(InputStream in)[] throws IOException {\n\t\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(in, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1150": "\tpublic void setStep(int msStep) {\n\t\tstepMillis = msStep;\n\t}\n",
    "1152": "\tpublic int getStep() {\n\t\treturn stepMillis;\n\t}\n",
    "1153": "\tpublic void setLength(int len) {\n\t\tintendedLength = len;\n\t}\n",
    "1155": "\tpublic int getLength() {\n\t\treturn intendedLength;\n\t}\n",
    "1157": "\tstatic public Delays makeDelayNormal() {\n\t\treturn makeDelayNormal(0);\n\t}\n",
    "1158": "\tstatic public Delays makeDelayNormal(int seqLength) {\n\t\treturn new Delays(Settings.delayValue, seqLength);\n\t}\n",
    "1159": "\tstatic public Delays makeDelayUndoRedo() {\n\t\treturn makeDelayUndoRedo(0);\n\t}\n",
    "1161": "\tprivate void saveButtonActionPerformed() {\n\n\t\t// Save properties to a file.\n\t\tsaveProperties(newLanguageProperties, getFilepathFromLanguageCode(newLanguageCode));\n\n\t\t// Make new backup copy of properties.\n\t\tlastSavedNewLanguageProperties = (Properties) newLanguageProperties.clone();\n\t}\n",
    "1162": "\tstatic public Delays makeDelayUndoRedo(int seqLength) {\n\t\treturn new Delays(Settings.delayValueUndoRedo, seqLength);\n\t}\n",
    "1163": "\tpublic void start() {\n\t\tif ( ! started ) {\n\t\t\tlastNow = System.currentTimeMillis();\n\t\t\tstarted = true;\n\t\t}\n\t}\n",
    "1164": "\tpublic void stop() {\n\t\tstarted = false;\n\t}\n",
    "1169": "\tprivate int effStepInt( boolean slowstep ) {\n\t\tfloat step = effStep(slowstep);\n\t\tint  istep = Math.round(step);\n\t\t\n\t\t// When we would tell a zero delay (or even less), but the original\n\t\t// intention was a positive delay, we shall return the smallest\n\t\t// possible positive value: 1.\n\t\tif( istep <= 0 ) {\n\t\t\tif( stepMillis > 0 ) {\n\t\t\t\tistep = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Never consider negative values\n\t\tif( istep < 0 ) {\n\t\t\tistep = 0;\n\t\t}\n\t\t\n\t\treturn istep;\n\t}\n",
    "1172": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start the backward search.\n\t\t\t\t\tbackwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\t}\n",
    "1173": "\tstatic public void main(String[] argv) {\n\n\t\t// Check for debug parameters.\n\t\tfor(String parameter : argv) {\n\t\t\tif(parameter.equalsIgnoreCase(\"-debug\")) {\n\t\t\t\tSettings.isDebugModeActivated = true;\t\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugSettings\")) {\n\t\t\t\tSettings.isSettingsDebugModeActivated = true;\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugTiming\")) {\n\t\t\t\tSettings.isTimingDebugModeActivated = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Save the information whether this program is started as \"web start application\".\n\t\tSettings.isStartedAsWebStartApplication =\n\t\t\t\t\t   (argv.length > 0 && argv[0].equals(\"-webstart\"))\n\t\t\t\t\t|| (argv.length > 1 && argv[1].equals(\"-webstart\"));\n\t\t\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew JSoko().startProgram();\n\t\t\t}\n\t\t});\n\t}\n",
    "1174": "\tpublic void sleep(boolean reassertIntr) {\n\t\tsleep(reassertIntr, false);\n\t}\n",
    "1177": "\tprivate char decryptCharcode(int c, int start, int end, int offset) {\n\t\t\n\t\tc+=offset;\n\t\tif(offset > 0 && c > end){\n\t\t\tc= (start+(c-end-1));\n\t\t}\n\t\telse if(offset < 0 && c < start){\n\t\t\tc= (end-(start-c-1));\n\t\t}\n\t\treturn (char) c;\n\t}\n",
    "1179": "\tprivate void restoreButtonActionPerformed(ActionEvent evt) {\n\t\tnewLanguageProperties = (Properties) lastSavedNewLanguageProperties.clone();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\trefreshTranslationTextAreas();\n\t}\n",
    "1183": "\tprotected void stateChanged() {\n\t\tChangeEvent e = new ChangeEvent(this);\n\t\tfor (ChangeListener listener : changeListeners) {\n\t\t\tlistener.stateChanged(e);\n\t\t}\n\t}\n",
    "1186": "\tpublic void addValueListener(ChangeListener listener) {\n\t\tchangeListeners.add(listener);\n\t}\n",
    "1188": "\tpublic double getValueAsDouble() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn (Double) currentValue;\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn ((Integer) currentValue).doubleValue();\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1189": "\tpublic int getValueAsInteger() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn ((Double) currentValue).intValue();\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn (Integer) currentValue;\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1193": "\tpublic void setMinRAMinMiB(long minRAMinMiB) {\n\t\tthis.minRAMinMiB = minRAMinMiB;\n\t}\n",
    "1194": "\tprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n\t\tif (minRAMinMiB >= 0) {\n\t\t\t// We are limited...\n\t\t\tif (size() >= 2) {\n\t\t\t\t// We are large enough to loose an entry...\n\t\t\t\tif (Utilities.getMaxUsableRAMinMiB() < minRAMinMiB) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1197": "\tpublic V getV(K key) {\n\t\treturn map.get(key);\n\t}\n",
    "1199": "\tpublic void add(K key, V value) {\n\t\tmap.put(key, value);\n\t}\n",
    "1200": "\tpublic void trimToSize() {\n\t\t// we cannot do anything useful, here\n\t}\n",
    "1215": "\tfinal public Object clone() {\n\t\treturn new BoxData(this);\n\t}\n",
    "1216": "\tfinal public void setBoxStartPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1218": "\tfinal public void setBoxPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1219": "\tfinal public void setBoxPositions(int[] newBoxPositions) {\n\n\t\t// We must use a copy of the the array!\n\t\t// The caller does not donate this object, he will continue\n\t\t// to use and modify that array, while we expect to own this array.\n\t\tboxPositions = newBoxPositions.clone();\n\t}\n",
    "1221": "\tfinal public void setBoxActive(int boxNo) {\n\t\tisBoxInactive[boxNo] = false;\n\t}\n",
    "1223": "\tfinal public void setBoxInactive(int boxNo) {\n\t\tisBoxInactive[boxNo] = true;\n\n\t\t// An inactive box cannot be part of a corral\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1224": "\tfinal public boolean isBoxActive(int boxNo) {\n\t\treturn isBoxInactive[boxNo] == false;\n\t}\n",
    "1225": "\tfinal public boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "1226": "\tfinal public void setBoxFrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = true;\n\t}\n",
    "1227": "\tpublic void setLevelForPlaying(int levelNo) {\n\t\tsetLevelForPlaying(currentLevelCollection.getLevel(levelNo));\n\t}\n",
    "1228": "\tfinal public boolean isBoxFrozen(int boxNo) {\n\t\treturn isBoxFrozen[boxNo];\n\t}\n",
    "1230": "\tfinal public void setBoxUnfrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = false;\n\t}\n",
    "1231": "\tfinal public void setBoxInCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = true;\n\t}\n",
    "1232": "\tfinal public void removeBoxFromCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1233": "\tfinal public boolean isBoxInCorral(int boxNo) {\n\t\treturn isBoxInCorral[boxNo];\n\t}\n",
    "1234": "\tfinal public int getBoxPosition(int boxNo) {\n\t\treturn boxPositions[boxNo];\n\t}\n",
    "1236": "\tfinal public boolean isEveryBoxOnAGoal() {\n\n\t\t// Check all boxes for \"on goal\"\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated boxes\n\t\t\tif (isBoxInactive(boxNo))\n\t\t\t\tcontinue;\n\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1237": "\tpublic int getBoxesOnGoalsCount() {\n\t\tint boxesOnGoalsCount = 0;\n\t\tfor(int boxNo=0; boxNo<boxCount; boxNo++) {\n\t\t\t// TODO: explain why inactive boxes are not ignored Answer: bad programming. this method\n\t\t\t// is only used when a new level is loaded and all boxes are active. Inactive boxes are\n\t\t\t// only there during deadlock detection. Nevertheless, I think it's better to check for \n\t\t\t// inactive boxes here, too. I will have a look at this at some time. \n\t\t\tif(board.isGoal(getBoxPosition(boxNo))) {\n\t\t\t\tboxesOnGoalsCount++;\n\t\t\t}\n\t\t}\n\t\treturn boxesOnGoalsCount;\n\t}\n",
    "1238": "\tfinal public boolean isEveryBoxOnABackwardGoal() {\n\n\t\tint[] backwardGoalPositions = board.getGoalPositionsBackward();\n\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tif (isBoxInactive(boxNo)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBox(backwardGoalPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1239": "\tfinal public boolean isEveryCorralBoxOnAGoal() {\n\n\t\t// check all boxes\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated and non-corral boxes\n\t\t\tif (isBoxInactive(boxNo) || isBoxInCorral(boxNo) == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1242": "\tfinal public void setAllBoxesNotFrozen() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tisBoxFrozen[boxNo] = false;\n\t\t}\n\t}\n",
    "1243": "\tpublic long length() {\n\t\treturn size;\n\t}\n",
    "1244": "\tpublic byte getAt(long lax) {\n\t\tif ((lax < 0) || (lax >= size)) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"lax=\"+lax+\",size=\"+size);\n\t\t}\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ]);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\treturn (arrvec[(int)blockno][(int)eleminx]);\n\t}\n",
    "1246": "\tpublic byte putAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] = val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] = val);\n\t}\n",
    "1248": "\tpublic byte orAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] |= val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] |= val);\n\t}\n",
    "1253": "\tpublic long getNumBitsAt( long bitlax, int totbits ) {\n\t\tif (totbits > 64 || totbits < 0) {\n\t\t\tthrow new java.lang.UnsupportedOperationException(\"bits=\"+totbits);\n\t\t}\n\t\t// asserted: 0 <= totbits <= 64\n\t\tlong result = 0;\n\t\t\n\t\tint  resoff = 0;\n\t\twhile (totbits > resoff) {\n\t\t\tint  toget  = totbits - resoff;\n\t\t\tbyte bitoff = (byte)(bitlax & 0x07);\t// [0..7]\n\t\t\tlong lax    = bitlax >>> 3;\n\n\t\t\tint bitlen = 8 - bitoff;\t\t// so many in this byte [1..8]\n\t\t\tif (bitlen > toget) {\n\t\t\t\tbitlen = toget;\n\t\t\t}\n\t\t\tlong v    = getAt(lax) & 0xffL;\n\t\t\tv      >>>= bitoff;\n\t\t\tv        &= (1L << bitlen) - 1;\n\n\t\t\tresult |= (v << resoff);\n\t\t\tresoff += bitlen;\n\t\t\tbitlax += bitlen;\n\t\t}\n\t\treturn result;\n\t}\n",
    "1257": "\tpublic void showMissingFileDialog(String filePath, int messageType) {\n\t\tJOptionPane.showMessageDialog(\n\t\t\t\tparent,\n\t\t\t\t\"File: \" + filePath + \" is missing!\",\n\t\t\t\t\"Error\",\n\t\t\t\tmessageType);\n\n\t\tif (messageType == JOptionPane.ERROR_MESSAGE) {\n\t\t\tsetBlankProject();\n\t\t}\n\t}\n",
    "1258": "\tpublic boolean isEmpty() {\n\t\treturn root == null;\n\t}\n",
    "1259": "\tpublic void clear() {\n\t\tthis.root      = null;\n\t\tthis.elemcount = 0;\n\t}\n",
    "1264": "\tprivate Properties loadPropertiesByFilename(String fileName) throws IOException {\n\n\t\t// Create new properties.\n\t\tProperties tempProp = new Properties();\n\n\t\t// Get input stream to the property file.\n\t\tInputStream inPropFile = Utilities.getInputStream(fileName);\n\t\t\n\t\ttry {\n\t\t\t// Load properties.\n\t\t\ttempProp.load(inPropFile);\n\t\t\t\n\t\t\t// Close file.\n\t\t\tinPropFile.close();\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\n\t\t// Return the read properties.\n\t\treturn tempProp;\n\n\t}\n",
    "1268": "\tprivate Properties loadPropertiesByLanguageCode(String languageCode) throws IOException {\n\n\t\t// Return the read properties.\n\t\treturn loadPropertiesByFilename(getFilepathFromLanguageCode(languageCode));\n\n\t}\n",
    "1275": "\tpublic V rd(long inx) {\n\t\treturn rd(root, MAX_DEP, inx);\n\t}\n",
    "1277": "\tprivate void paput(Inner<V> pa, byte painx, Node<V> nref) {\n\t\tif (pa == null) {\n\t\t\troot = nref;\n\t\t} else {\n\t\t\t// Store leaf where we found the null in the last step\n\t\t\tpa.iput(painx, nref);\n\t\t}\n\t}\n",
    "1278": "\tprivate void reloadGUI() {\n\t\tchangeLanguageComboBoxes();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\tloadLanguageTexts(HINT_LANGUAGE_COLUMN);\n\n\t\t// Set new and hint language combo boxes for default values.\n\t\tString language = (new Locale(Settings.get(\"newTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\n\t\tnewLanguageComboBox.setSelectedItem(language);\n\n\t\tlanguage = (new Locale(Settings.get(\"hintTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\t\thintLanguageComboBox.setSelectedItem(language);\n\n\t\t// By default select the first row of the table.\n\t\tif (table.getRowCount() > 0) {\n\t\t\ttable.changeSelection(0, NEW_LANGUAGE_COLUMN, false, false);\n\t\t}\n\t}\n",
    "1279": "\tpublic void redraw(boolean waitForEnter) {\n\n\t\t// Draw the new GUI.\n\t\tapplicationGUI.mainBoardDisplay.repaint();\n\n\t\t// For debugging purposes wait for \"Enter\"\n\t\tif (waitForEnter) {\n\t\t\tJDialog dialog = new JOptionPane(\"\").createDialog(null, \"Waiting for Enter\");\n\t\t\tdialog.setLocation(getX() + getWidth() + 45, getY() + 10);\n\t\t\tdialog.setVisible(true);\n\t\t\t// Beginners explanation: The above dialog is \"modal\", and hence freezes\n\t\t\t// all other graphics activity.  That way \"we wait\" by being frozen.\n\t\t\t// When \"setVisible(true)\" returns, the dialog is done!\n\t\t}\n\t}\n",
    "1281": "\tpublic V wr(long inx, V val) {\n\t\treturn wr(root, MAX_DEP, inx, val);\n\t}\n",
    "1283": "\tfinal public void removeBox(int position) {\n\t\tboxesArray[position] = false;\n\t}\n",
    "1287": "\tprivate void calculateLowerboundOfAllLevel() {\n\n\t\tfinal int maxLevelNo = currentLevelCollection.getNumberOfLevels();\n\t\tint[] lowerbounds = new int[1 + maxLevelNo];\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tsetLevelForPlaying(levelNo);\n\t\t\tlowerbounds[levelNo] = board.lowerbound.calculateLowerbound(SearchDirection.FORWARD);\n\t\t}\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tSystem.out.printf(\"Level: %3d  Name: %-60s Lowerbound: %3d \\n\",\n\t\t\t\t\tlevelNo, currentLevelCollection.getLevel(levelNo).getTitle(), lowerbounds[levelNo]);\n\t\t}\n\t}\n",
    "1290": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start a new forward search.\n\t\t\t\t\tforwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\n\t\t\t}\n",
    "1291": "\tfinal public void removeBoxByNumber(int boxNo) {\n\t\tboxesArray[boxData.getBoxPosition(boxNo)] = false;\n\t}\n",
    "1296": "\tpublic boolean isPlayModeActivated() {\n\t\treturn gameMode == GameMode.PLAY;\n\t}\n",
    "1300": "\tfinal public void removeBox(int x, int y) {\n\t\tboxesArray[x + width * y] = false;\n\t}\n",
    "1304": "\tpublic boolean isEditorModeActivated() {\n\t\treturn gameMode == GameMode.EDITOR;\n\t}\n",
    "1308": "\tfinal public void removeWall(int position) {\n\t\twallsArray[position] -= ((wallsArray[position] > 0) ? 1 : 0);\n\t}\n",
    "1313": "\tprivate void setInvalidLevelMode() {\n\t\tapplicationGUI.setInvalidLevelModeDependentObjectsEnabled(false);\n\t\tgameMode = GameMode.INVALID_LEVEL;\n\t}\n",
    "1319": "\tfinal public void removeWall(int x, int y) {\n\t\twallsArray[x + width * y] -= ((wallsArray[x + width * y] > 0) ? 1 : 0);\n\t}\n",
    "1344": "\tfinal public void removeGoal(int position) {\n\t\tgoalsArray[position] = false;\n\t}\n",
    "1373": "\tfinal public void removeGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = false;\n\t}\n",
    "1378": "\tpublic long firstInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(true, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1384": "\tpublic long lastInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(false, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1393": "\tfinal public void removePlayer() {\n\t\tplayerPosition = NO_PLAYER;\n\t}\n",
    "1453": "\tfinal public void setBox(int position) {\n\t\tboxesArray[position] = true;\n\t}\n",
    "1496": "    public String send(){\n        //do real logic\n        return (\"success\");\n    }\n",
    "1503": "\tfinal public void setBox(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t}\n",
    "1518": "\tprivate int nextLockId() {\n\t\tif (nextLockId==Integer.MAX_VALUE) nextLockId = Integer.MIN_VALUE;\n\t\treturn nextLockId++;\n\t}\n",
    "1519": "\tprivate void decrementLock(Object key, Lock lock) throws CacheException {\n\t\t//decrement the lock\n\t\tlock.unlock( cache.nextTimestamp() );\n\t\tif ( cache instanceof ClusterCache)\n\t\t\t((ClusterCache)cache).putQuiet(key, lock);\n\t\telse\n\t\t\tcache.put(key, lock);\n\t}\n",
    "1534": "    public Object get(Object key) throws CacheException {\n        try {\n            if ( log.isDebugEnabled() ) {\n                log.debug(\"key: \" + key);\n            }\n            if (key == null) {\n                return null;\n            } \n            else {\n                Element element = cache.get( (Serializable) key );\n                if (element == null) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug(\"Element for \" + key + \" is null\");\n                    }\n                    return null;\n                } \n                else {\n                    return element.getValue();\n                }\n            }\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1536": "\tfinal public void setBoxWithNo(int boxNo, int position) {\n\t\tboxesArray[position] = true;\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1537": "    public void put(Object key, Object value) throws CacheException {\n        try {\n            Element element = new Element( (Serializable) key, (Serializable) value );\n            cache.put(element);\n        } \n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n",
    "1538": "    public void remove(Object key) throws CacheException {\n        try {\n            cache.remove( (Serializable) key );\n        } \n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1540": "    public void clear() throws CacheException {\n        try {\n            cache.removeAll();\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (IOException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1542": "    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1543": "    public void lock(Object key) throws CacheException {\n    }\n",
    "1545": "    public void unlock(Object key) throws CacheException {\n    }\n",
    "1546": "\tprivate void setUndoRedoFromHistory() {\n\t\tapplicationGUI.setUndoButtonsEnabled(movementHistory.hasPrecedingMovement());\n\t\tapplicationGUI.setRedoButtonsEnabled(movementHistory.hasSuccessorMovement());\n\t}\n",
    "1547": "\t\tpublic long getFreshTimestamp() {\n\t\t\treturn freshTimestamp;\n\t\t}\n",
    "1548": "    public long nextTimestamp() {\n        return Timestamper.next();\n    }\n",
    "1549": "    public int getTimeout() {\n        // 60 second lock timeout\n        return Timestamper.ONE_MS * 60000;\n    }\n",
    "1550": "\t\tpublic Object getValue() {\n\t\t\treturn value;\n\t\t}\n",
    "1552": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\treturn new Lock(timeout, id, version);\n\t\t}\n",
    "1554": "\t\tpublic boolean isLock() {\n\t\t\treturn false;\n\t\t}\n",
    "1555": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn freshTimestamp < txTimestamp;\n\t\t}\n",
    "1558": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\t// we really could refresh the item if it  \n\t\t\t// is not a lock, but it might be slower\n\t\t\t//return freshTimestamp < txTimestamp\n\t\t\treturn  ( version!=null && newVersion!=null)&& comparator.compare(version, newVersion) < 0;\n\t\t}\n",
    "1561": "\tfinal public void setBoxWithNo(int boxNo, int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1563": "\tpublic boolean greaterThan(LockMode mode) {\n\t\treturn level > mode.level;\n\t}\n",
    "1564": "\tpublic boolean lessThan(LockMode mode) {\n\t\treturn level < mode.level;\n\t}\n",
    "1572": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\tconcurrentLock = true;\n\t\t\tmultiplicity++;\n\t\t\tthis.timeout = timeout;\n\t\t\treturn this;\n\t\t}\n",
    "1579": "\t\tpublic void unlock(long currentTimestamp) {\n\t\t\tif ( --multiplicity == 0 ) {\n\t\t\t\tunlockTimestamp = currentTimestamp;\n\t\t\t}\n\t\t}\n",
    "1587": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\tif (timeout < txTimestamp) return true;\n\t\t\tif (multiplicity>0) return false;\n\t\t\treturn version==null || newVersion==null? \n\t\t\t\tunlockTimestamp < txTimestamp :\n\t\t\t\tcomparator.compare(version, newVersion) < 0; //by requiring <, we rely on lock timeout in the case of an unsuccessful update!\n\t\t}\n",
    "1592": "\t\tpublic boolean wasLockedConcurrently() {\n\t\t\treturn concurrentLock;\n\t\t}\n",
    "1599": "\t\tpublic boolean isLock() {\n\t\t\treturn true;\n\t\t}\n",
    "1605": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn false;\n\t\t}\n",
    "1617": "\tfinal public void setBoxOnGoal(int position) {\n\t\tboxesArray[position] = true;\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1634": "    public Mapper createMapper() throws BuildException {\n        if (_mapper != null) {\n            throw new BuildException(\"Cannot define more than one mapper\");\n        }\n        _mapper = new Mapper(this.getProject());\n        return _mapper;\n    }\n",
    "1638": "\tprivate void exportLevelToClipboard(boolean withRLE) {\n\t\texportLevelToClipboard(withRLE, false);\n\t}\n",
    "1647": "\tfinal public void setBoxOnGoal(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1665": "\tfinal public void setGoal(int position) {\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1680": "\tfinal public void setGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1692": "\tfinal public void setWall(int position) {\n\t\twallsArray[position]++;\n\t}\n",
    "1704": "\tfinal public void setWall(int x, int y) {\n\t\twallsArray[x + width * y]++;\n\t}\n",
    "1716": "\tfinal public void setBoxNo(int boxNo, int position) {\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1727": "\tfinal public void setBoxNo(int boxNo, int x, int y) {\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1738": "\tfinal public void setAdvancedSimpleDeadlock(int position) {\n\t\tadvancedSimpleDeadlockSquareForwards[position] = true;\n\t}\n",
    "1761": "\tfinal public void setPlayerPosition(int position) {\n\t\tplayerPosition = position;\n\t}\n",
    "1778": "\tfinal public void setPlayerPosition(int x, int y) {\n\t\tplayerPosition = x + width * y;\n\t}\n",
    "1808": "\tfinal public boolean isCorralForcerSquare(int position) {\n\t\treturn corralForcer[position];\n\t}\n",
    "1837": "\tfinal public boolean isCorralForcerSquare(int x, int y) {\n\t\treturn corralForcer[x + width * y];\n\t}\n",
    "1865": "\tfinal public boolean isBox(int position) {\n\t\treturn boxesArray[position];\n\t}\n",
    "1889": "\tfinal public boolean isBox(int x, int y) {\n\t\treturn boxesArray[x + width * y];\n\t}\n",
    "1911": "\tfinal public boolean isWall(int position) {\n\t\treturn wallsArray[position] > 0;\n\t}\n",
    "1916": "\tpublic boolean isABoxSelected() {\n\t\treturn isABoxSelected;\n\t}\n",
    "1931": "\tfinal public boolean isWall(int x, int y) {\n\t\treturn wallsArray[x + width * y] > 0;\n\t}\n",
    "1946": "\tpublic boolean isHighLightingOfPlayerReachableSquaresActivated() {\n\t\treturn isHighLightOfPlayerSquaresActivated;\n\t}\n",
    "1956": "\tpublic void setAntInstallLib(File antInstallLib) {\n\t\tthis.antInstallLib = antInstallLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antInstallLib,\"tikal-antinstaller.jar\"));\n\t\tset.setFile(new File(antInstallLib,\"sysout.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1958": "\tpublic void setAntLib(File antLib) {\n\t\tthis.antLib = antLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antLib,\"tikal-ant.jar\"));\n\t\tset.setFile(new File(antLib,\"ant-launcher.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1959": "\tfinal public boolean isGoal(int position) {\n\t\treturn goalsArray[position];\n\t}\n",
    "1991": "\tpublic int getSelectedBoxPosition() {\n\t\treturn selectedBoxPosition;\n\t}\n",
    "2003": "\tfinal public boolean isGoal(int x, int y) {\n\t\treturn goalsArray[x + width * y];\n\t}\n",
    "2086": "\tpublic boolean isGoalOrWall(int position) {\n\t\treturn goalsArray[position] || wallsArray[position] > 0;\n\t}\n",
    "2156": "\tprivate void redoMovementInOwnThread(final boolean redoAllMovements) {\n\t\t\n\t\tmovePlayerThread = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tredoMovement(redoAllMovements);\n\n\t\t\t\t// The \"setUndoRedoFromHistory()\" has happened already.\n\n\t\t\t\t// This thread has finished its work. The thread isn't needed any more.\n\t\t\t\tmovePlayerThread = null;\n\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2159": "\tfinal public boolean isCorralForcer(int position) {\n\t\treturn corralForcer[position] == true;\n\t}\n",
    "2165": "    public List getKeysWithExpiryCheck() throws IllegalStateException, CacheException {\n        List allKeyList = getKeys();\n        //remove keys of expired elements\n        ArrayList nonExpiredKeys = new ArrayList(allKeyList.size());\n        int allKeyListSize = allKeyList.size();\n        for (int i = 0; i < allKeyListSize; i++) {\n            Serializable key = (Serializable) allKeyList.get(i);\n            Element element = getQuiet(key);\n            if (element != null) {\n                nonExpiredKeys.add(key);\n            }\n        }\n        nonExpiredKeys.trimToSize();\n        return nonExpiredKeys;\n    }\n",
    "2169": "\tfinal public boolean isGoalBackwardsSearch(int position) {\n\t\treturn goalSquareBackwardsSearch[position];\n\t}\n",
    "2175": "    public long getMemoryStoreSize() throws IllegalStateException {\n        checkStatus();\n        return memoryStore.getSize();\n    }\n",
    "2177": "    public int getDiskStoreSize() throws IllegalStateException {\n        checkStatus();\n        if (overflowToDisk) {\n            return diskStore.getSize();\n        } else {\n            return 0;\n        }\n    }\n",
    "2180": "\tfinal public boolean isGoalBackwardsSearch(int x, int y) {\n\t\treturn goalSquareBackwardsSearch[x + width * y];\n\t}\n",
    "2181": "    public Status getStatus() {\n        return status;\n    }\n",
    "2186": "\tprivate void undoMovementInOwnThread() {\n\n\t\tmovePlayerThread = new Thread() {\n\t\t\t@SuppressWarnings(\"synthetic-access\")\n\t\t\tpublic void run() {\n\t\t\t\tundoMovement();\n\n\t\t\t\t// Enable / disable the undo / redo button depending on the history status.\n\t\t\t\tsetUndoRedoFromHistory();\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2187": "    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n    }\n",
    "2191": "    public int getMemoryStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return memoryStoreHitCount;\n    }\n",
    "2193": "\tfinal public boolean isEmptySquare(int position) {\n\t\treturn ! (boxesArray[position] || wallsArray[position] > 0 || goalsArray[position]);\n\t}\n",
    "2195": "    public int getDiskStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return diskStoreHitCount;\n    }\n",
    "2196": "    private Method findCreateMethod(Class objClass, String name) {\n        final String methodName = makeMethodName(\"create\", name);\n        final Method[] methods = objClass.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            final Method method = methods[i];\n            if (!method.getName().equals(methodName)) {\n                continue;\n            }\n            if (Modifier.isStatic(method.getModifiers())) {\n                continue;\n            }\n            if (method.getParameterTypes().length != 0) {\n                continue;\n            }\n            if (method.getReturnType().isPrimitive() || method.getReturnType().isArray()) {\n                continue;\n            }\n            return method;\n        }\n\n        return null;\n    }\n",
    "2197": "    private String makeMethodName(final String prefix, final String name) {\n        return prefix + Character.toUpperCase(name.charAt(0)) + name.substring(1);\n    }\n",
    "2198": "    public int getMissCountNotFound() throws IllegalStateException {\n        checkStatus();\n        return missCountNotFound;\n    }\n",
    "2203": "    public int getMissCountExpired() throws IllegalStateException {\n        checkStatus();\n        return missCountExpired;\n    }\n",
    "2205": "\tfinal public boolean isEmptySquare(int x, int y) {\n\t\treturn ! (   boxesArray[x + width * y]\n\t\t          || wallsArray[x + width * y] > 0\n\t\t          || goalsArray[x + width * y]     );\n\t}\n",
    "2207": "    public String getName() {\n        return name;\n    }\n",
    "2208": "    private String getLocation() {\n        return locator.getSystemId() + ':' + locator.getLineNumber();\n    }\n",
    "2209": "    public long getTimeToIdleSeconds() {\n        return timeToIdleSeconds;\n    }\n",
    "2211": "    public long getTimeToLiveSeconds() {\n        return timeToLiveSeconds;\n    }\n",
    "2213": "\tfinal public boolean isAccessible(int position) {\n\t\treturn ! (wallsArray[position] > 0 || boxesArray[position]);\n\t}\n",
    "2219": "    public boolean isOverflowToDisk() {\n        return overflowToDisk;\n    }\n",
    "2221": "    public int getMaxElementsInMemory() {\n        return maxElementsInMemory;\n    }\n",
    "2223": "\tfinal public boolean isAccessible(int x, int y) {\n\t\treturn ! (wallsArray[x + width * y] > 0 || boxesArray[x + width * y]);\n\t}\n",
    "2224": "    public MemoryStoreEvictionPolicy getMemoryStoreEvictionPolicy() {\n        return memoryStoreEvictionPolicy;\n    }\n",
    "2225": "    public String getDiskCachePath() {\n        if (diskStore != null) {\n            return diskStore.path;\n        } else {\n            return null;\n        }\n    }\n",
    "2227": "    public Set getCacheKeySet() {\n        return caches.keySet();\n    }\n",
    "2229": "    public boolean isExpired(Element element) throws IllegalStateException, NullPointerException {\n        checkStatus();\n        boolean expired;\n        synchronized (element) {\n            if (element.getValue() == null) {\n                expired = true;\n            }\n            if (!eternal) {\n                expired = checkExpirationForNotEternal(element);\n            } else {\n                expired = false;\n            }\n            if (LOG.isDebugEnabled()) {\n                Serializable key = null;\n                if (element != null) {\n                    key = element.getKey();\n                }\n                LOG.debug(getName() + \": Is element with key \" + key + \" expired?: \" + expired);\n            }\n            return expired;\n        }\n    }\n",
    "2233": "\tfinal public boolean isAccessibleBox(int position) {\n\t\treturn ! (   wallsArray[position] > 0\n\t\t\t\t  || boxesArray[position]\n\t\t\t\t  || simpleDeadlockSquareForwards[position]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[position] );\n\t}\n",
    "2235": "    public Object clone() throws CloneNotSupportedException {\n        if (!(memoryStore == null && diskStore == null)) {\n            throw new CloneNotSupportedException(\"Cannot clone an initialized cache.\");\n        }\n        //added by yanai\n        Cache cache = (Cache) super.clone();\n        cache.cacheEventNotificationService = new CacheEventNotificationService(cache);\n        return cache;\n       //end of add\n    }\n",
    "2238": "        public void setClass(String fullyQualifiedClassPath) {\n            this.fullyQualifiedClassPath = fullyQualifiedClassPath;\n        }\n",
    "2241": "\tfinal public boolean isAccessibleBox(int x, int y) {\n\t\treturn ! (   wallsArray[x + width * y] > 0\n\t\t\t\t  || boxesArray[x + width * y]\n\t\t\t\t  || simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[x + width * y] );\n\t}\n",
    "2242": "        public void setName(String name) {\n            this.name = name;\n        }\n",
    "2243": "    public CacheEventNotificationService getCacheEventNotificationService() {\n        return cacheEventNotificationService;\n    }\n",
    "2244": "        public void setMaxElementsInMemory(int maxElementsInMemory) {\n            this.maxElementsInMemory = maxElementsInMemory;\n        }\n",
    "2247": "    public void notifyElementRemoved(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener = (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementRemoved(cache, element);\n        }\n    }\n",
    "2248": "        public void setMemoryStoreEvictionPolicy(String memoryStoreEvictionPolicy) {\n            this.memoryStoreEvictionPolicy = MemoryStoreEvictionPolicy.fromString(memoryStoreEvictionPolicy);\n        }\n",
    "2251": "    public void notifyElementExpiry(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener =  (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementExpired(cache, element);\n        }\n    }\n",
    "2252": "    public boolean registerListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.add(cacheEventListener);\n    }\n",
    "2253": "    public boolean unregisterListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.remove(cacheEventListener);\n    }\n",
    "2254": "    public Set getCacheEventListeners() {\n        return cacheEventListeners;\n    }\n",
    "2255": "\tfinal public boolean isWallOrIllegalSquare(int position) {\n\t\treturn     wallsArray[position] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2261": "        public void setEternal(boolean eternal) {\n            this.eternal = eternal;\n        }\n",
    "2266": "\tpublic boolean isLevelValid() {\n\n\t\tStringBuilder validityMessage = new StringBuilder();\n\n\t\t// Let the board check if it is valid.\n\t\tboolean levelIsValid = board.isValid(validityMessage);\n\n\t\t// If the level is invalid the editor mustn't be left and the\n\t\t// reason for the invalidity is displayed.\n\t\tif (levelIsValid == false) {\n\t\t\tdisplayInfotext(validityMessage.toString());\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(false);\n\t\t} else {\n\t\t\tdisplayInfotext(\"\");\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(true);\n\t\t}\n\n\t\treturn levelIsValid;\n\t}\n",
    "2268": "\tpublic void sendNotification(ClusterNotification message) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"sendNotification : \" + message);\n\t\tbus.sendNotification(message);\n\t}\n",
    "2270": "        public void setTimeToIdleSeconds(int timeToIdleSeconds) {\n            this.timeToIdleSeconds = timeToIdleSeconds;\n        }\n",
    "2272": "\tpublic Serializable getCache() {\n\t\treturn \"BroadcastingManager: \" + bus.getLocalAddress();\n\t}\n",
    "2273": "\tpublic void memberJoined(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"A new member at address '\" + address + \"' has joined the cluster\");\n\t\t}\n\t}\n",
    "2274": "\tpublic void memberLeft(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"Member at address '\" + address + \"' left the cluster\");\n\t\t}\n\t}\n",
    "2278": "        public void setTimeToLiveSeconds(int timeToLiveSeconds) {\n            this.timeToLiveSeconds = timeToLiveSeconds;\n        }\n",
    "2280": "\tfinal public boolean isWallOrIllegalSquare(int x, int y) {\n\t\treturn     wallsArray[x + width * y] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2281": "    public void shutdown() {\n        if (status.equals(Status.STATUS_SHUTDOWN)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"CacheManager already shutdown\");\n            }\n            return;\n        }\n        synchronized (CacheManager.class) {\n            allCacheManagersDiskStorePaths.remove(diskStorePath);\n            Enumeration allCaches = caches.elements();\n            while (allCaches.hasMoreElements()) {\n                Cache cache = (Cache) allCaches.nextElement();\n                if (cache != null) {\n                    cache.dispose();\n                }\n            }\n            if ( getBroadcastingManager()!=null) getBroadcastingManager().stop();\n            status = Status.STATUS_SHUTDOWN;\n            \n            //only delete singleton if the singleton is shutting down.\n            if (this == singleton) {\n                singleton = null;\n            }\n        }\n    }\n",
    "2283": "        public void setOverflowToDisk(boolean overflowToDisk) {\n            this.overflowToDisk = overflowToDisk;\n        }\n",
    "2285": "        public void setDiskPersistent(boolean diskPersistent) {\n            this.diskPersistent = diskPersistent;\n        }\n",
    "2288": "        public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {\n            this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;\n        }\n",
    "2291": "\tfinal public boolean isOuterSquareOrWall(int position) {\n\t\treturn    ! playersReachableSquaresOnlyWallsAtLevelStart[position]\n\t\t       || wallsArray[position] > 0;\n\t}\n",
    "2311": "\tfinal public boolean isSimpleDeadlockSquare(int position) {\n\t\treturn     simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position]\n\t\t\t\t|| simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2329": "\tpublic void start(BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\t}\n",
    "2331": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t}\n",
    "2338": "    protected void giveFocusToProjectsNames() {\n        projectsNamesCombo.setFocus();\n    }\n",
    "2351": "\tfinal public boolean isSimpleDeadlockSquare(int x, int y) {\n\t\treturn     simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2362": "\tpublic void setCurrentCollection(LevelCollection levelCollection) {\n\n\t\tcurrentLevelCollection = levelCollection;\n\n\t\t// Update the combo box showing all levels.\n\t\tupdateLevelComboBox();\n\t\t\n//\t\tif (Settings.isDebugModeActivated) {\n//\t\t\tSystem.out.println( \"Set collection with \"\n//\t\t\t\t\t            + levelCollection.getNumberOfLevels() + \" levels\" );\n//\t\t\tSystem.out.println( \"  ID = \" + levelCollection.getDatabaseID());\n//\t\t\tSystem.out.println( \"  title = \" + levelCollection.getTitle());\n//\t\t}\n\t}\n",
    "2377": "\tprotected String handleDirectoryBrowse(String path) {\n\t\tDirectoryDialog directoryDialog = new DirectoryDialog(getShell());\n\t\tif (path != null && !\"\".equals(path)) {\n\t\t\tdirectoryDialog.setFilterPath(path);\n\t\t}\n\t\tString dirName = directoryDialog.open();\n\n\t\treturn dirName;\n\t}\n",
    "2378": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareForwards[position];\n\t}\n",
    "2418": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2441": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2449": "\tpublic String collectionTitleOfLevelID(int levelID) {\n\t\tif (findLevelByID(levelID) != null) {\n\t\t\treturn currentLevelCollection.getTitle();\n\t\t}\n\t\treturn null;\n\t}\n",
    "2455": "    public Serializable save(Object obj) throws HibernateException {\n\n        if (obj==null) throw new NullPointerException(\"attempted to save null\");\n\n        Object object = unproxy(obj); //throws exception if uninitialized\n\n        EntityEntry e = getEntry(object);\n        if ( e!=null ) {\n            if ( e.status==DELETED ) {\n                forceFlush(e);\n            }\n            else {\n                log.trace( \"object already associated with session\" );\n                return e.id;\n            }\n        }\n\n        Serializable id = saveWithGeneratedIdentifier(object, Cascades.ACTION_SAVE_UPDATE, null); //id might be generated by SQL insert\n        reassociateProxy(obj, id); //TODO: move into saveWithGeneratedIdentifier()?\n        return id;\n\n    }\n",
    "2463": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2478": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int position) {\n\t\treturn advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2488": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int x, int y) {\n\t\treturn advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2500": "\tfinal public boolean isBoxOnGoal(int position) {\n\t\treturn boxesArray[position] && goalsArray[position];\n\t}\n",
    "2512": "\tfinal public boolean isBoxOnGoal(int x, int y) {\n\t\treturn boxesArray[x + width * y] && goalsArray[x + width * y];\n\t}\n",
    "2521": "\tfinal public boolean isPlayerInLevel() {\n\t\treturn playerPosition != NO_PLAYER;\n\t}\n",
    "2528": "\tfinal public boolean isMarked(int position) {\n\t\treturn marked[position];\n\t}\n",
    "2543": "\tfinal public boolean isMarked(int x, int y) {\n\t\treturn marked[x + width * y];\n\t}\n",
    "2552": "\tfinal public void removeMarking(int position) {\n\t\tmarked[position] = false;\n\t}\n",
    "2561": "\tfinal public void removeMarking(int x, int y) {\n\t\tmarked[x + width * y] = false;\n\t}\n",
    "2569": "\tfinal public void removeAllMarking() {\n\t\tArrays.fill(marked, false);\t\t\t// this is not time critical\n\t}\n",
    "2576": "\tfinal public void setMarking(int position) {\n\t\tmarked[position] = true;\n\t}\n",
    "2580": "    private void reassociateProxy(LazyInitializer li, HibernateProxy proxy) throws MappingException {\n        if ( li.getSession()!=this ) {\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key( li.getIdentifier(), persister );\n            if ( !proxiesByKey.containsKey(key) ) proxiesByKey.put(key, proxy); // any earlier proxy takes precedence\n            HibernateProxyHelper.getLazyInitializer( proxy ).setSession(this);\n        }\n    }\n",
    "2583": "\tfinal public void setMarking(int x, int y) {\n\t\tmarked[x + width * y] = true;\n\t}\n",
    "2591": "\tfinal public void assignMarking(int position, boolean markValue) {\n\t\tmarked[position] = markValue;\n\t}\n",
    "2600": "\tfinal public void flipMarking(int position) {\n\t\tmarked[position] = ! marked[position];\n\t}\n",
    "2608": "\tfinal public int getBoxNo(int position) {\n\t\treturn boxNumbers[position];\n\t}\n",
    "2616": "\tfinal public int getGoalNo(int position) {\n\t\treturn goalsNumbers[position];\n\t}\n",
    "2625": "\tfinal public int getGoalPosition(int goalNo) {\n\t\treturn goalsPositions[goalNo];\n\t}\n",
    "2633": "\tfinal public int getPlayerDistance(int fromSquare, int toSquare) {\n\t\treturn playerDistances[fromSquare][toSquare];\n\t}\n",
    "2641": "\tfinal public void setBoardPosition(IBoardPosition position) {\n\t\tsetBoardPosition(position.getPositions());\n\t}\n",
    "2650": "\tfinal public void setBoardPosition(int[] positions) {\n\n\t\t// remove all boxes from the board\n\t\tremoveAllBoxes();\n\n\t\t// store the new box positions in our box data object\n\t\tboxData.setBoxPositions(positions);\n\n\t\t// Put the new boxes into the board\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tsetBoxWithNo(boxNo, positions[boxNo]);\n\t\t}\n\n\t\t// set up the new player location\n\t\tplayerPosition = positions[boxCount];\n\t}\n",
    "2659": "\tfinal public void removeAllBoxes() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tremoveBox(boxData.getBoxPosition(boxNo));\n\t\t}\n\t}\n",
    "2668": "\tfinal public void setGoalsBackwardsSearch() {\n\n\t\tint goalNo = 0;\n\n\t\t// Set up the new goals for backwards search, and clear the old ones\n\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\tif (isBox(position) && isOuterSquareOrWall(position) == false) {\n\t\t\t\tgoalSquareBackwardsSearch[position] = true;\n\t\t\t\tgoalsPositionsBackwardsSearch[goalNo++] = position;\n\t\t\t} else {\n\t\t\t\tgoalSquareBackwardsSearch[position] = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "2683": "    public List find(String query) throws HibernateException {\n        return find(query, NO_ARGS, NO_TYPES);\n    }\n",
    "2781": "\t\tpublic int getBoxDistanceForwardsPlayerPositionIndependentNo(int boxNo, int goalNo) {\n\t\t\treturn getBoxDistanceForwardsPlayerPositionIndependent(boxData.getBoxPosition(boxNo), goalsPositions[goalNo]);\n\t\t}\n",
    "2880": "\tpublic void run(IAction action) {\n\t\tUpdateManagerDialog d = new UpdateManagerDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());\n\t\td.open();\n\t}\n",
    "2881": "\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t}\n",
    "2882": "\tpublic void dispose() {\n\t}\n",
    "2883": "\tpublic void init(IWorkbenchWindow window) {\n\t\tthis.window = window;\n\t}\n",
    "2930": "    protected boolean allowNewContainerName() {\n        return false;\n    }\n",
    "2961": "    public void aboutToOpen() {\n        determineWhiteCheckedDescendents(root);\n        checkNewTreeElements(treeContentProvider.getElements(root));\n\n        //select the first element in the list\n        Object[] elements = treeContentProvider.getElements(root);\n        Object primary = elements.length > 0 ? elements[0] : null;\n        if (primary != null) {\n            treeViewer.setSelection(new StructuredSelection(primary));\n        }\n        treeViewer.getControl().setFocus();\n    }\n",
    "2963": "    public void addCheckStateListener(ICheckStateListener listener) {\n        addListenerObject(listener);\n    }\n",
    "2964": "    private ITreeContentProvider getResourceProvider(final int resourceType) {\n        return new WorkbenchContentProvider() {\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic Object[] getChildren(Object o) {\n                //input element case\n                if (o instanceof ArrayList) {\n                    return ((ArrayList) o).toArray();\n                } \n               return new Object[0];            \t\n            }\n        };\n    }\n",
    "2965": "    protected boolean areAllChildrenWhiteChecked(Object treeElement) {\n        Object[] children = treeContentProvider.getChildren(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n            if (!whiteCheckedTreeItems.contains(children[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n        }\n\n        return true;\n    }\n",
    "2970": "    protected boolean areAllElementsChecked(Object treeElement) {\n        List checkedElements = (List) checkedStateStore.get(treeElement);\n        if (checkedElements == null) {\n\t\t\treturn false;\n\t\t}\n        return true;\n    }\n",
    "2971": "    protected void checkNewTreeElements(Object[] elements) {\n        for (int i = 0; i < elements.length; ++i) {\n            Object currentElement = elements[i];\n            boolean checked = checkedStateStore.containsKey(currentElement);\n            treeViewer.setChecked(currentElement, checked);\n            treeViewer.setGrayed(currentElement, checked\n                    && !whiteCheckedTreeItems.contains(currentElement));\n        }\n    }\n",
    "2972": "    protected Iterator getSelectedResourcesIterator() {\n        return this.resourceGroup.getAllCheckedListItems().iterator();\n    }\n",
    "2974": "    public void checkStateChanged(final CheckStateChangedEvent event) {\n\n        //Potentially long operation - show a busy cursor\n        BusyIndicator.showWhile(treeViewer.getControl().getDisplay(),\n            new Runnable() {\n                public void run() {\n                    if (event.getCheckable().equals(treeViewer)) {\n\t\t\t\t\t\ttreeItemChecked(event.getElement(), event\n                                .getChecked());\n\t\t\t\t\t}\n\n                    notifyCheckStateChangeListeners(event);\n                }\n            });\n    }\n",
    "2975": "    protected List getTypesToExport() {\n        return selectedTypes;\n    }\n",
    "2980": "    protected List getWhiteCheckedResources() {\n        return this.resourceGroup.getAllWhiteCheckedItems();\n    }\n",
    "2981": "    protected void createTreeViewer(Composite parent, boolean useHeightHint) {\n        Tree tree = new Tree(parent, SWT.CHECK | SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_BOTH);\n        if (useHeightHint) {\n\t\t\tdata.heightHint = PREFERRED_HEIGHT;\n\t\t}\n        tree.setLayoutData(data);\n        tree.setFont(parent.getFont());\n\n        treeViewer = new CheckboxTreeViewer(tree);\n        treeViewer.setContentProvider(treeContentProvider);\n        treeViewer.setLabelProvider(treeLabelProvider);\n        treeViewer.addTreeListener(this);\n        treeViewer.addCheckStateListener(this);\n        treeViewer.addSelectionChangedListener(this);\n    }\n",
    "2986": "    protected boolean hasExportableExtension(String resourceName) {\n        if (selectedTypes == null) {\n\t\t\treturn true;\n\t\t}\n\n        int separatorIndex = resourceName.lastIndexOf(\".\"); //$NON-NLS-1$\n        if (separatorIndex == -1) {\n\t\t\treturn false;\n\t\t}\n\n        String extension = resourceName.substring(separatorIndex + 1);\n\n        Iterator it = selectedTypes.iterator();\n        while (it.hasNext()) {\n            if (extension.equalsIgnoreCase((String) it.next())) {\n\t\t\t\treturn true;\n\t\t\t}\n        }\n\n        return false;\n    }\n",
    "2987": "    protected boolean determineShouldBeWhiteChecked(Object treeElement) {\n        return areAllChildrenWhiteChecked(treeElement)\n                && areAllElementsChecked(treeElement);\n    }\n",
    "2990": "    protected void determineWhiteCheckedDescendents(Object treeElement) {\n        // always go through all children first since their white-checked\n        // statuses will be needed to determine the white-checked status for\n        // this tree element\n        Object[] children = treeContentProvider.getElements(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n\t\t\tdetermineWhiteCheckedDescendents(children[i]);\n\t\t}\n\n        // now determine the white-checked status for this tree element\n        if (determineShouldBeWhiteChecked(treeElement)) {\n\t\t\tsetWhiteChecked(treeElement, true);\n\t\t}\n    }\n",
    "2991": "    protected void saveWidgetValues() {\n        // allow subclasses to save values\n        internalSaveWidgetValues();\n    }\n",
    "2992": "    public void expandAll() {\n        treeViewer.expandAll();\n    }\n",
    "2993": "    protected void setupBasedOnInitialSelections() {\n\n        Iterator it = this.initialResourceSelection.iterator();\n        while (it.hasNext()) {\n            IResource currentResource = (IResource) it.next();\n            if (currentResource.getType() != IResource.FILE) {\n\t\t\t\tthis.resourceGroup.initialCheckTreeItem(currentResource);\n\t\t\t}\n        }\n    }\n",
    "2995": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3005": "    protected boolean saveDirtyEditors() {\n        return IDEWorkbenchPlugin.getDefault().getWorkbench().saveAllEditors(\n                true);\n    }\n",
    "3008": "    public List getAllCheckedListItems() {\n\n        final ArrayList returnValue = new ArrayList();\n\n        IElementFilter passThroughFilter = new IElementFilter() {\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Collection elements,\n                    IProgressMonitor monitor) {\n                returnValue.addAll(elements);\n            }\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Object[] elements,\n                    IProgressMonitor monitor) {\n                for (int i = 0; i < elements.length; i++) {\n                    returnValue.add(elements[i]);\n                }\n            }\n        };\n\n        try {\n            getAllCheckedListItems(passThroughFilter, null);\n        } catch (InterruptedException exception) {\n            return new ArrayList();\n        }\n        return returnValue;\n\n    }\n",
    "3009": "    protected void updateWidgetEnablements() {\n\n        boolean pageComplete = determinePageCompletion();\n        setPageComplete(pageComplete);\n        if (pageComplete) {\n\t\t\tsetMessage(null);\n\t\t}\n        super.updateWidgetEnablements();\n    }\n",
    "3010": "\t\tfinal public PlayersReachableSquares getClone() {\n\t\t\treturn new PlayersReachableSquares(playersReachableSquaresArray, indicatorReachableSquare);\n\t\t}\n",
    "3012": "    public Object instantiate(ClassPersister persister, Serializable id) throws HibernateException {\n        Object result = interceptor.instantiate( persister.getMappedClass(), id );\n        if (result==null) result = persister.instantiate(id);\n        return result;\n    }\n",
    "3013": "    protected void addDestinationItem(String value) {\n        destinationNameField.add(value);\n    }\n",
    "3017": "    public List getAllWhiteCheckedItems() {\n\n        List result = new ArrayList();\n\n        //Iterate through the children of the root as the root is not in the store\n        Object[] children = treeContentProvider.getChildren(root);\n        for (int i = 0; i < children.length; ++i) {\n            findAllWhiteCheckedItems(children[i], result);\n        }\n\n        return result;\n    }\n",
    "3018": "    public int getCheckedElementCount() {\n        return checkedStateStore.size();\n    }\n",
    "3022": "    protected void createDirectoryStructureOptions(Composite optionsGroup, Font font) {\n        // create directory structure radios\n        createDirectoryStructureButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createDirectoryStructureButton.setText(DataTransferMessages.FileExport_createDirectoryStructure);\n        createDirectoryStructureButton.setSelection(false);\n        createDirectoryStructureButton.setFont(font);\n\n        // create directory structure radios\n        createSelectionOnlyButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createSelectionOnlyButton.setText(DataTransferMessages.FileExport_createSelectedDirectories);\n        createSelectionOnlyButton.setSelection(true);\n        createSelectionOnlyButton.setFont(font);\n    }\n",
    "3024": "\t\tfinal public int getPlayerPositionTopLeft() {\n\n\t\t\t// Calculate squares reachable by the player.\n\t\t\tupdate();\n\n\t\t\t// This is just the square with the smallest index.\n\t\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\t\tif (isSquareReachable(position)) {\n\t\t\t\t\treturn position;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The player can't reach any square.\n\t\t\treturn -1;\n\t\t}\n",
    "3028": "    private void grayUpdateHierarchy(Object treeElement) {\n\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setGrayChecked(treeElement, shouldBeAtLeastGray);\n\n        if (whiteCheckedTreeItems.contains(treeElement)) {\n\t\t\twhiteCheckedTreeItems.remove(treeElement);\n\t\t}\n\n        // proceed up the tree element hierarchy\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3029": "    public void initialCheckTreeItem(Object element) {\n        treeItemChecked(element, true);\n        selectAndReveal(element);\n    }\n",
    "3030": "    protected boolean ensureDirectoryExists(File directory) {\n        if (!directory.exists()) {\n            if (!queryYesNoQuestion(DataTransferMessages.DataTransfer_createTargetDirectory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n            if (!directory.mkdirs()) {\n                displayErrorDialog(DataTransferMessages.DataTransfer_directoryCreationError);\n                giveFocusToDestination();\n                return false;\n            }\n        }\n\n        return true;\n    }\n",
    "3032": "    protected boolean ensureTargetIsValid(File targetDirectory) {\n        if (targetDirectory.exists() && !targetDirectory.isDirectory()) {\n            displayErrorDialog(DataTransferMessages.FileExport_directoryExists);\n            giveFocusToDestination();\n            return false;\n        }\n\n        return ensureDirectoryExists(targetDirectory);\n    }\n",
    "3035": "    protected boolean executeExportOperation(FileSystemExportOperation op) {\n        op.setCreateLeadupStructure(createDirectoryStructureButton\n                .getSelection());\n        op.setOverwriteFiles(overwriteExistingFilesCheckbox.getSelection());\n\n        try {\n            getContainer().run(true, true, op);\n        } catch (InterruptedException e) {\n            return false;\n        } catch (InvocationTargetException e) {\n            displayErrorDialog(e.getTargetException());\n            return false;\n        }\n\n        IStatus status = op.getStatus();\n        if (!status.isOK()) {\n            ErrorDialog.openError(getContainer().getShell(),\n                    DataTransferMessages.DataTransfer_exportProblems,\n                    null, // no special message\n                    status);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3038": "\t\tfinal public PlayersReachableSquaresOnlyWalls getClone() {\n\t\t\treturn new PlayersReachableSquaresOnlyWalls(playersReachableSquaresOnlyWallsArray, reachableSquareIndicatorOnlyWalls);\n\t\t}\n",
    "3043": "    protected String getDestinationLabel() {\n        return DataTransferMessages.FileExport_toDirectory;\n    }\n",
    "3044": "    public void removeCheckStateListener(ICheckStateListener listener) {\n        removeListenerObject(listener);\n    }\n",
    "3046": "    protected String getDestinationValue() {\n        return destinationNameField.getText().trim();\n    }\n",
    "3050": "    protected void giveFocusToDestination() {\n        destinationNameField.setFocus();\n    }\n",
    "3053": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresOnlyWallsArray[position] == reachableSquareIndicatorOnlyWalls;\n\t\t}\n",
    "3054": "    protected void handleDestinationBrowseButtonPressed() {\n        DirectoryDialog dialog = new DirectoryDialog(getContainer().getShell(),\n                SWT.SAVE);\n        dialog.setMessage(SELECT_DESTINATION_MESSAGE);\n        dialog.setText(SELECT_DESTINATION_TITLE);\n        dialog.setFilterPath(getDestinationValue());\n        String selectedDirectoryName = dialog.open();\n\n        if (selectedDirectoryName != null) {\n            setErrorMessage(null);\n            setDestinationValue(selectedDirectoryName);\n        }\n    }\n",
    "3055": "    public void setRoot(Object newRoot) {\n        this.root = newRoot;\n        initialize();\n    }\n",
    "3056": "    public void handleEvent(Event e) {\n        Widget source = e.widget;\n\n        if (source == destinationBrowseButton) {\n\t\t\thandleDestinationBrowseButtonPressed();\n\t\t}\n\n        updatePageCompletion();\n    }\n",
    "3057": "    protected void setTreeChecked(Object treeElement, boolean state) {\n\n        if (!state) {\n\t\t\tcheckedStateStore.remove(treeElement);\n\t\t}\n\n        setWhiteChecked(treeElement, state);\n        treeViewer.setChecked(treeElement, state);\n        treeViewer.setGrayed(treeElement, false);\n\n        // now logically check/uncheck all children as well if it has been expanded\n        if (expandedTreeNodes.contains(treeElement)) {\n            Object[] children = treeContentProvider.getChildren(treeElement);\n            for (int i = 0; i < children.length; ++i) {\n                setTreeChecked(children[i], state);\n            }\n        }\n    }\n",
    "3060": "    private void internalSaveWidgetValues() {\n        // update directory names history\n        IDialogSettings settings = getDialogSettings();\n        if (settings != null) {\n            String[] directoryNames = settings\n                    .getArray(STORE_DESTINATION_NAMES_ID);\n            if (directoryNames == null) {\n\t\t\t\tdirectoryNames = new String[0];\n\t\t\t}\n\n            directoryNames = addToHistory(directoryNames, getDestinationValue());\n            settings.put(STORE_DESTINATION_NAMES_ID, directoryNames);\n\n            // options\n            settings.put(STORE_OVERWRITE_EXISTING_FILES_ID,\n                    overwriteExistingFilesCheckbox.getSelection());\n\n            settings.put(STORE_CREATE_STRUCTURE_ID,\n                    createDirectoryStructureButton.getSelection());\n\n        }\n    }\n",
    "3061": "    public Object narrowProxy(Object proxy, ClassPersister persister, Key key, Object object) throws HibernateException {\n\n        if ( !persister.getConcreteProxyClass().isAssignableFrom( proxy.getClass() ) ) {\n\n            if ( log.isWarnEnabled() ) log.warn(\n                \"Narrowing proxy to \" + persister.getConcreteProxyClass() + \" - this operation breaks ==\"\n            );\n\n            if (object!=null) {\n                proxiesByKey.remove(key);\n                return object; //return the proxied object\n            }\n            else {\n                proxy = persister.createProxy( key.getIdentifier(), this );\n                proxiesByKey.put(key, proxy); //overwrite old proxy\n                return proxy;\n            }\n\n        }\n        else {\n            return proxy;\n        }\n    }\n",
    "3062": "    public void setTreeSorter(ViewerSorter sorter) {\n        treeViewer.setSorter(sorter);\n    }\n",
    "3063": "    protected void restoreWidgetValues() {\n        IDialogSettings settings = getDialogSettings();\n        if (settings != null) {\n            String[] directoryNames = settings\n                    .getArray(STORE_DESTINATION_NAMES_ID);\n            if (directoryNames == null) {\n\t\t\t\treturn; // ie.- no settings stored\n\t\t\t}\n\n            // destination\n            setDestinationValue(directoryNames[0]);\n            for (int i = 0; i < directoryNames.length; i++) {\n\t\t\t\taddDestinationItem(directoryNames[i]);\n\t\t\t}\n\n            // options\n            overwriteExistingFilesCheckbox.setSelection(settings\n                    .getBoolean(STORE_OVERWRITE_EXISTING_FILES_ID));\n\n            boolean createDirectories = settings\n                    .getBoolean(STORE_CREATE_STRUCTURE_ID);\n            createDirectoryStructureButton.setSelection(createDirectories);\n            createSelectionOnlyButton.setSelection(!createDirectories);\n        }\n    }\n",
    "3066": "\t\tfinal public boolean isSquareReachable(int x, int y) {\n\t\t\treturn playersReachableSquaresOnlyWallsArray[x + width * y] == reachableSquareIndicatorOnlyWalls;\n\t\t}\n",
    "3067": "    public void treeCollapsed(TreeExpansionEvent event) {\n        // We don't need to do anything with this\n    }\n",
    "3068": "    protected void setDestinationValue(String value) {\n        destinationNameField.setText(value);\n    }\n",
    "3069": "    public void treeExpanded(TreeExpansionEvent event) {\n        expandTreeElement(event.getElement());\n    }\n",
    "3070": "    protected boolean validateDestinationGroup() {\n        String destinationValue = getDestinationValue();\n        if (destinationValue.length() == 0) {\n            setMessage(destinationEmptyMessage());\n            return false;\n        }\n\n        String conflictingContainer = getConflictingContainerNameFor(destinationValue);\n        if (conflictingContainer == null) {\n\t\t\tsetErrorMessage(null);\n\t\t} else {\n            setErrorMessage(NLS.bind(DataTransferMessages.FileExport_conflictingContainer, conflictingContainer));\n            giveFocusToDestination();\n            return false;\n        }\n\n        return true;\n    }\n",
    "3072": "    public Object proxyFor(ClassPersister persister, Key key, Object impl) throws HibernateException {\n        if ( !persister.hasProxy() ) return impl;\n        Object proxy = proxiesByKey.get(key);\n        if (proxy!=null) {\n            return narrowProxy(proxy, persister, key, impl);\n        }\n        else {\n            return impl;\n        }\n    }\n",
    "3073": "    protected void treeItemChecked(Object treeElement, boolean state) {\n\n        // recursively adjust all child tree elements appropriately\n        setTreeChecked(treeElement, state);\n\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent == null) {\n\t\t\treturn;\n\t\t}\n\n        // now update upwards in the tree hierarchy \n        if (state) {\n\t\t\tgrayCheckHierarchy(parent);\n\t\t} else {\n\t\t\tungrayCheckHierarchy(parent);\n\t\t}\n\n        //Update the hierarchy but do not white select the parent\n        grayUpdateHierarchy(parent);\n    }\n",
    "3075": "    protected void ungrayCheckHierarchy(Object treeElement) {\n        if (!determineShouldBeAtLeastGrayChecked(treeElement)) {\n\t\t\tcheckedStateStore.remove(treeElement);\n\t\t}\n\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n\t\t\tungrayCheckHierarchy(parent);\n\t\t}\n    }\n",
    "3077": "    protected void updateHierarchy(Object treeElement) {\n\n        boolean whiteChecked = determineShouldBeWhiteChecked(treeElement);\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setChecked(treeElement, shouldBeAtLeastGray);\n        setWhiteChecked(treeElement, whiteChecked);\n        if (whiteChecked) {\n\t\t\ttreeViewer.setGrayed(treeElement, false);\n\t\t} else {\n\t\t\ttreeViewer.setGrayed(treeElement, shouldBeAtLeastGray);\n\t\t}\n\n        // proceed up the tree element hierarchy but gray select all of them\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3078": "    protected String destinationEmptyMessage() {\n        return DataTransferMessages.FileExport_destinationEmpty;\n    }\n",
    "3081": "    protected String getConflictingContainerNameFor(String targetDirectory) {\n\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IPath testPath = new Path(targetDirectory);\n\n        if (root.getLocation().isPrefixOf(testPath)) {\n\t\t\treturn DataTransferMessages.FileExport_rootName;\n\t\t}\n\n\t    IContainer[] containers = root.findContainersForLocation(testPath);\n\t    if (containers.length > 0){\n    \t\treturn containers[0].getName();\n\t    }\n\n        return null;\n\n    }\n",
    "3082": "    public void setFocus() {\n        this.treeViewer.getTree().setFocus();\n    }\n",
    "3095": "    protected int countSelectedResources() throws CoreException {\n        int result = 0;\n        Iterator resources = resourcesToExport.iterator();\n\n        while (resources.hasNext()) {\n\t\t\tresult += countChildrenOf((IResource) resources.next());\n\t\t}\n\n        return result;\n    }\n",
    "3096": "    protected void createLeadupDirectoriesFor(IResource childResource) {\n        IPath resourcePath = childResource.getFullPath().removeLastSegments(1);\n        makePathTree(resourcePath);\n    }\n",
    "3098": "    protected void createLeadupDirectoriesFor(IPath childPath) {\n        IPath resourcePath = childPath.removeLastSegments(1);\n        makePathTree(resourcePath);\n    }\n",
    "3100": "    private void makePathTree(IPath tree) {\n        IPath targetPath = tree.removeLastSegments(tree.segmentCount() - 1);\n        for (int i = 1; i < tree.segmentCount(); i++) {\n        \ttargetPath = targetPath.append(tree.segment(i));\n            if (!targetPath.toFile().exists())\n            \ttargetPath.toFile().mkdir();\n        }    \t\n    }\n",
    "3107": "    public void addUninitializedEntity(Key key, Object object, LockMode lockMode) {\n        addEntity(key, object);\n        addEntry( object, LOADING, null, key.getIdentifier(), null, lockMode, true, null /*getPersister(object)*/, false ); //temporary\n    }\n",
    "3116": "    protected boolean isDescendent(List resources, IResource child) {\n        if (child.getType() == IResource.PROJECT) {\n\t\t\treturn false;\n\t\t}\n\n        IResource parent = child.getParent();\n        if (resources.contains(parent)) {\n\t\t\treturn true;\n\t\t}\n\n        return isDescendent(resources, parent);\n    }\n",
    "3122": "    public void setCreateContainerDirectories(boolean value) {\n        createContainerDirectories = value;\n    }\n",
    "3124": "    public void setCreateLeadupStructure(boolean value) {\n        createLeadupStructure = value;\n    }\n",
    "3126": "    public void setOverwriteFiles(boolean value) {\n        if (value) {\n\t\t\toverwriteState = OVERWRITE_ALL;\n\t\t}\n    }\n",
    "3127": "    public void postHydrate(ClassPersister persister, Serializable id, Object[] values, Object object, LockMode lockMode) throws HibernateException {\n        //persister.setIdentifier(object, id);\n        Object version = Versioning.getVersion(values, persister);\n        addEntry(object, LOADING, values, id, version, lockMode, true, persister, false);\n\n        if ( log.isTraceEnabled() && version!=null ) log.trace(\"Version: \" + version);\n    }\n",
    "3129": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn boxReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3135": "    private ZipFile getSpecifiedSourceFile(String fileName) {\n        if (fileName.length() == 0)\n            return null;\n\n        try {\n            return new ZipFile(fileName);\n        } catch (ZipException e) {\n           addError(DataTransferMessages.ZipImport_badFormat, e);\n        } catch (IOException e) {\n           addError(DataTransferMessages.ZipImport_couldNotRead, e);\n        }\n\n        return null;\n    }\n",
    "3137": "    protected boolean closeZipFile(ZipFile file) {\n        try {\n            file.close();\n        } catch (IOException e) {\n            addError(NLS.bind(DataTransferMessages.ZipImport_couldNotClose, file.getName()), e);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3189": "\tprivate void initializeValues() {\n\t\tfinal IPreferenceStore store = getPreferenceStore();\n\t\tfor (Iterator iter = fFields.iterator(); iter.hasNext();) {\n\t\t\t((Field)iter.next()).initializeValue(store);\n\t\t}\n\t}\n",
    "3200": "\tprotected IPreferenceStore doGetPreferenceStore() {\n\t\treturn CVSUIPlugin.getPlugin().getPreferenceStore();\n\t}\n",
    "3201": "\tprotected void createImageDescriptor(String id) {\n\t\tURL url = FileLocator.find(CVSUIPlugin.getPlugin().getBundle(), new Path(ICVSUIConstants.ICON_PATH + id), null);\n\t\tImageDescriptor desc = ImageDescriptor.createFromURL(url);\n\t\timageDescriptors.put(id, desc);\n\t}\n",
    "3205": "\tpublic void setCompressionLevel(int level) {\n\t\tcompressionLevel = level;\n\t}\n",
    "3207": "\tpublic int getCompressionLevel() {\n\t\treturn compressionLevel;\n\t}\n",
    "3209": "\tpublic ImageDescriptor getImageDescriptor(String id) {\n\t\treturn (ImageDescriptor)imageDescriptors.get(id);\n\t}\n",
    "3211": "\tpublic void setDefaultTextKSubstOption(KSubstOption ksubst) {\n\t\tdefaultTextKSubstOption = ksubst;\n\t}\n",
    "3214": "\tpublic KSubstOption getDefaultTextKSubstOption() {\n\t\treturn defaultTextKSubstOption;\n\t}\n",
    "3215": "\tprivate String getPreviousBugId(String string){\n\t\tif(string.startsWith(BUG_ID_INITIAL)){\n\t\t\tint newLineIndex = string.indexOf(LINE_SEPARATOR);\n\t\t\treturn string.substring(BUG_ID_INITIAL.length(), newLineIndex);\n\t\t}\n\t\treturn \"\";\t\n\t}\n",
    "3217": "\tpublic boolean getPruneEmptyDirectories() {\n\t\treturn pruneEmptyDirectories;\n\t}\n",
    "3218": "\tprivate String getPreviousComment(String string){\n\t\tif(string.startsWith(BUG_ID_INITIAL)){\n\t\t\tint newLineIndex = string.indexOf(LINE_SEPARATOR);\n\t\t\treturn string.substring(newLineIndex+LINE_SEPARATOR.length(), string.length());\n\t\t}\n\t\treturn string;\t\t\n\t}\n",
    "3221": "\tpublic void setPruneEmptyDirectories(boolean prune) {\n\t\tpruneEmptyDirectories = prune;\n\t}\n",
    "3226": "\tpublic int getTimeout() {\n\t\treturn communicationsTimeout;\n\t}\n",
    "3230": "\tpublic void setTimeout(int timeout) {\n\t\tthis.communicationsTimeout = Math.max(0, timeout);\n\t}\n",
    "3231": "\tprivate Label createLabel(Composite parent, String text, int horizontalSpan) {\n\t\tLabel label = new Label(parent, SWT.LEFT);\n\t\tlabel.setText(text);\n\t\tGridData data = new GridData();\n\t\tdata.horizontalSpan = horizontalSpan;\n\t\tdata.horizontalAlignment = GridData.FILL;\n\t\tlabel.setLayoutData(data);\n\t\treturn label;\n\t}\n",
    "3232": "\tprivate Button createCheckBox(Composite group, String label) {\n\t\tButton button = new Button(group, SWT.CHECK | SWT.LEFT);\n\t\tbutton.setText(label);\n\t\tGridData data = new GridData();\n\t\tdata.horizontalSpan = 2;\n\t\tbutton.setLayoutData(data);\n\t\treturn button;\n\t}\t\n",
    "3233": "\tpublic void setQuietness(QuietOption option) {\n\t\t\tthis.quietness = option;\n\t}\n",
    "3237": "\tpublic QuietOption getQuietness() {\n\t\treturn quietness;\n\t}\n",
    "3243": "\tpublic void setConsoleListener(IConsoleListener consoleListener) {\n\t    ConsoleListeners.getInstance().addListener(consoleListener);\n\t}\n",
    "3253": "\tprotected void performDefaults() {\n\t\tsuper.performDefaults();\n        initializeValues();\n\t\t\n        verifyValidation();\n\t}\n",
    "3254": "\tpublic String getCvsRshCommand() {\n\t\treturn cvsRshCommand;\n\t}\n",
    "3258": "\tpublic void setCvsRshCommand(String cvsRshCommand) {\n\t\tthis.cvsRshCommand = cvsRshCommand;\n\t}\n",
    "3260": "\tpublic boolean isUseProjectNameOnCheckout() {\n\t\treturn getPreferenceStore().getBoolean(ICVSUIConstants.PREF_USE_PROJECT_NAME_ON_CHECKOUT);\n\t}\n",
    "3262": "\tpublic String getCvsRshParameters() {\n\t\treturn cvsRshParameters;\n\t}\n",
    "3265": "\tpublic void setCvsRshParameters(String cvsRshParameters) {\n\t\tthis.cvsRshParameters = cvsRshParameters;\n\t}\n",
    "3270": "\tpublic String getCvsServer() {\n\t\treturn cvsServer;\n\t}\n",
    "3271": "\tprivate void initializeValues() {\n\t\t\n\t\t// populate the previous comment list\n\t\tfor (int i = 0; i < comments.length; i++) {\n\t\t\tpreviousCommentsCombo.add(flattenText(comments[i]));\n\t\t}\n\t\t\n\t\t// We don't want to have an initial selection\n\t\t// (see bug 32078: http://bugs.eclipse.org/bugs/show_bug.cgi?id=32078)\n\t\tpreviousCommentsCombo.setText(\"\"); //$NON-NLS-1$\n\t\t\n\t\tif (commentProperties == null && oldComment == null) text.setText(\"\"); //$NON-NLS-1$\n\t\tcomment = text.getText();\n\t}\n",
    "3275": "\tpublic void setCvsServer(String cvsServer) {\n\t\tthis.cvsServer = cvsServer;\n\t}\n",
    "3277": "\tprivate void signalCtrlEnter() {\n\t\tfirePropertyChangeChange(OK_REQUESTED, null, null);\n\t}\n",
    "3278": "\tpublic String getComment() {\n\t\tIPreferenceStore store = SVNUIPlugin.getPlugin().getPreferenceStore();\n\t\tif(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){\n\t\t\tif(comment.length() > 0 && bugId.length() > 0)\n\t\t\tcomment = bugId + comment;\n\t\t}\n\t\tif (comment != null && comment.length() > 0) finished();\n\t\tif(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){\n\t\t\tif(comment.length() > 0 && bugId.length() == 0)\n\t\treturn comment;\n\t}\n\t\treturn comment;\t\n\t}\n",
    "3280": "\tpublic boolean getFetchAbsentDirectories() {\n\t\treturn fetchAbsentDirectories;\n\t}\n",
    "3288": "\tpublic void setFetchAbsentDirectories(boolean fetchAbsentDirectories) {\n\t\tthis.fetchAbsentDirectories = fetchAbsentDirectories;\n\t}\n",
    "3296": "    private void setSvnClientInterface(String clientInterface) {\n        if (CmdLineClientAdapterFactory.COMMANDLINE_CLIENT.equals(clientInterface))\n            clientInterface = JavaSvnClientAdapterFactory.JAVASVN_CLIENT;\n        SVNProviderPlugin.getPlugin().getSVNClientManager().setSvnClientInterface(clientInterface);\n    }\n",
    "3297": "    private void setSvnClientConfigDir(String configDir) {\n        SVNProviderPlugin plugin = SVNProviderPlugin.getPlugin();\n        SVNClientManager svnClientManager = plugin.getSVNClientManager();\n        if (\"\".equals(configDir)) { //$NON-NLS-1$\n        \tsvnClientManager.setConfigDir(null);\n        } else {\n        \tFile configDirFile = new File(configDir);\n            svnClientManager.setConfigDir(configDirFile);\n        }\n    }\n",
    "3305": "\t\tpublic IProject getProject() {\n\t\t\treturn project;\n\t\t}\n",
    "3306": "\t\tpublic void setProject(IProject project) {\n\t\t\tthis.project = project;\n\t\t}\n",
    "3308": "\tpublic boolean isReplaceUnmanaged() {\n\t\treturn replaceUnmanaged;\n\t}\n",
    "3313": "\tpublic void setReplaceUnmanaged(boolean replaceUnmanaged) {\n\t\tthis.replaceUnmanaged = replaceUnmanaged;\n\t}\n",
    "3321": "\tpublic void addRepositoryListener(ICVSListener listener) {\n\t\tKnownRepositories.getInstance().addRepositoryListener(listener);\n\t}\n",
    "3327": "\t\tstatic public InstallerProject create(IJavaProject javaProject) {\n\t\t\tInstallerProject result = null;\n\t\t\ttry {\n\t\t\t\tInstallerProject.addTikalInstallerNature(javaProject);\n\t\t\t\tresult = (InstallerProject)javaProject.getProject().getNature(InstallerPlugin.NATURE_ID);\n\t\t\t\tif(result != null)\n\t\t\t\t\tresult.setJavaProject(javaProject);\n\t\t\t} catch(CoreException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n",
    "3329": "\tpublic void addDecoratorEnablementListener(ICVSDecoratorEnablementListener listener) {\n\t\tsynchronized(decoratorEnablementListeners) {\n\t\t\tdecoratorEnablementListeners.add(listener);\n\t\t}\n\t}\n",
    "3332": "\t\tstatic public InstallerProject create(IProject project) {\n\n\t\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\t\tif(javaProject != null) {\n\t\t\t\treturn InstallerProject.create(javaProject);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\t\n",
    "3350": "    private void doLoadByObject(Object object, Serializable id, LockMode lockMode) throws HibernateException {\n\n        Class clazz = object.getClass();\n        if ( getEntry(object)!=null ) throw new PersistentObjectException(\n            \"attempted to load into an instance that was already associated with the Session: \" +\n            MessageHelper.infoString(clazz, id)\n        );\n        Object result = doLoad(clazz, id, object, lockMode, true);\n        ObjectNotFoundException.throwIfNull(result, id, clazz);\n        if (result!=object) throw new NonUniqueObjectException(id, clazz);\n\n    }\n",
    "3370": "\tpublic boolean isDetermineVersionEnabled() {\n\t\treturn determineVersionEnabled;\n\t}\n",
    "3377": "\tpublic void setDetermineVersionEnabled(boolean determineVersionEnabled) {\n\t\tthis.determineVersionEnabled = determineVersionEnabled;\n\t}\n",
    "3379": "\tpublic String getComment() {\n\t    if ((projectProperties != null) && (issue != null) && (issue.length() > 0)) {\n\t        if (projectProperties.isAppend()) \n\t            return commitCommentArea.getComment() + \"\\n\" + projectProperties.getResolvedMessage(issue) + \"\\n\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t        else\n\t            return projectProperties.getResolvedMessage(issue) + \"\\n\" + commitCommentArea.getComment(); //$NON-NLS-1$\n\t    }\n\t\treturn commitCommentArea.getComment();\n\t}\n",
    "3383": "\tpublic FileModificationManager getFileModificationManager() {\n\t\treturn fileModificationManager;\n\t}\n",
    "3475": "\tpublic void setExcludesDirs(String[] excludesDirs) {\n\t\tthis.excludesDirs = excludesDirs;\n\t}\n",
    "3478": "\tpublic void setIncludesDirs(String[] includesDirs) {\n\t\tthis.includesDirs = includesDirs;\n\t}\n",
    "3498": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] toFiles) {\n\t\tFileNameMapper mapper = null;\n\t\tmapper = new IdentityMapper();\n\t\tbuildMap(fromDir, toDir, files, mapper, toFiles);\n\n\t}\n",
    "3520": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] dirs) {\n\t\tboolean flatten = false;\n\t\tFileNameMapper mapper = null;\n\t\tif (mapperElement != null) {\n\t\t\tmapper = mapperElement.getImplementation();\n\t\t} else if (flatten) {\n\t\t\tmapper = new FlatFileNameMapper();\n\t\t} else {\n\t\t\tmapper = new IdentityMapper();\n\t\t}\n\t\tbuildMap(fromDir, toDir, files, mapper);\n\n\t}\n",
    "3543": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] dirs) {\n\t\tFileNameMapper mapper = null;\n\t\tmapper = new IdentityMapper();\n\t\tbuildMap(fromDir, toDir, files, mapper);\n\n\t}\n",
    "3589": "    public void setOptional(boolean optional) {\n        this.optional = optional;\n    }\n",
    "3590": "    public void setFile(String file) {\n        // I don't think we can use File - different rules\n        // for relative paths.\n        this.file = file;\n    }\n",
    "3597": "    public void setClasspath(Path classpath) {\n        if (this.classpath == null) {\n            this.classpath = classpath;\n        } else {\n            this.classpath.append(classpath);\n        }\n    }\n",
    "3599": "    public Path createClasspath() {\n        if (this.classpath == null) {\n            this.classpath = new Path(getProject());\n        }\n        return this.classpath.createPath();\n    }\n",
    "3600": "    public void setClasspathRef(Reference r) {\n        createClasspath().setRefid(r);\n    }\n",
    "3611": "\tpublic URL getResource(String resourceName) {\n\t\tURL result = null;\n\n\t\twhile (_policy .hasNext() && result == null) {\n\t\t\tresult = _policy.next().getResource(resourceName);\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "3612": "\tpublic Class loadClass(String className) throws ClassNotFoundException {\n\t\tClass result = null;\n\n\t\twhile (_policy .hasNext() && result == null) {\n\t\t\ttry {\n\t\t\t\tresult = _policy.next().loadClass(className);\n\t\t\t} catch (ClassNotFoundException ignore) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\tif (result == null) {\n\t\t\tthrow new ClassNotFoundException(className);\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "3613": "\tpublic boolean hasNext() {\n\t\treturn _iterator.hasNext();\n\t}\n",
    "3614": "\tpublic ClassLoader next() {\n\t\treturn (ClassLoader) _iterator.next();\n\t}\n",
    "3615": "\tpublic void reset() {\n\t\tinit();\n\t}\n",
    "3648": "\tpublic boolean isDebugEnabled() {\n\t\tLevel l = Level.DEBUG;\n\t\tif (!_log.isEnabledFor(l)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn l.isGreaterOrEqual(_log.getEffectiveLevel());\n\t}\n",
    "3651": "\tpublic void debug(Object message) {\n\t\t_log.log(Level.DEBUG, message, null);\n\t}\n",
    "3653": "\tpublic void debug(Object message, Throwable t) {\n\t\t_log.log(Level.DEBUG, message, t);\n\t}\n",
    "3655": "\tpublic boolean isInfoEnabled() {\n\t\tLevel l = Level.INFO;\n\t\tif (!_log.isEnabledFor(l)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn l.isGreaterOrEqual(_log.getEffectiveLevel());\n\t}\n",
    "3659": "\tpublic void info(Object message) {\n\t\t_log.log(Level.INFO, message, null);\n\t}\n",
    "3665": "\tpublic void info(Object message, Throwable t) {\n\t\t_log.log(Level.INFO, message, t);\n\t}\n",
    "3670": "\tpublic void warn(Object message) {\n\t\t_log.log(Level.WARN, message, null);\n\t}\n",
    "3674": "\tpublic void warn(Object message, Throwable t) {\n\t\t_log.log(Level.WARN, message, t);\n\t}\n",
    "3679": "\tpublic void error(Object message) {\n\t\t_log.log(Level.ERROR, message, null);\n\t}\n",
    "3685": "\tpublic void error(Object message, Throwable t) {\n\t\t_log.log(Level.ERROR, message, t);\n\t}\n",
    "3689": "\tpublic void fatal(Object message) {\n\t\t_log.log(Level.FATAL, message, null);\n\t}\n",
    "3695": "\tpublic void fatal(Object message, Throwable t) {\n\t\t_log.log(Level.FATAL, message, t);\n\t}\n",
    "3701": "\tpublic void log(Level l, Object message) {\n\t\t_log.log(l, message, null);\n\t}\n",
    "3704": "    public String getJHObject(String target) {\n        // crack the definition string.\n        if (!definition.startsWith(VIEWER_TAG)) {\n            logger.warn(\"Called with a incorrect definition: \" + definition);\n            return definition; // do nothing\n        }\n        String text = null;\n        try {\n            text = definition.substring(VIEWER_TAG.length());\n            PopupObject popup = new PopupObject(props);\n            text = popup.getJHObject(target, text);\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Error handling definition. \" + definition + \" : \" + e.getMessage());\n            text = definition;\n        }\n        return text;\n    }\n",
    "3705": "\tpublic void log(Level l, Object message, Throwable t) {\n\t\t_log.log(l, message, t);\n\t}\n",
    "3708": "    public String getProjectName() {\n        return projectName;\n    }\n",
    "3709": "    private String paramStr(String name, String value) {\n        return \"<param name=\\\"\" + name +\"\\\" value=\\\"\" + value + \"\\\">\\n\"; \n    }\n",
    "3711": "    private boolean setPlayerMediaLocation() { \n        \n        String location = null;\n        if (baseDoc.getBase().getProtocol() != \"file\")\n            messages.append(\"Unable to handle the \" + baseDoc.getBase().getProtocol() + \" protocol.\\r\\n\");\n        else {\n            try {\n                URL linkUrl = new URL(baseDoc.getBase(), strUrl);\n                location = linkUrl.toString().replaceFirst(\"file:/\", \"file://\");\n            }\n            catch (MalformedURLException e) {\n                messages.append(\"Couldn't form URL \" + e.getMessage() + \"\\r\\n\");\n            }\n        }\n        \n        if (location != null) {\n            messages.append(\"Media file: \" + location + \"\\r\\n\");\n            player.setMediaLocation(location);\n            return true;\n        }\n        return false; // can' handle this yet\n    }\n",
    "3712": "    public String getSourceFolder() {\n        return sourceFolder;\n    }\n",
    "3715": "    public void setSourceFolder(String sourceFolder) {\n        this.sourceFolder = sourceFolder;\n    }\n",
    "3716": "    private String getParent(URL url) {\n        int end = url.getPath().lastIndexOf(\"/\");\n        if (end >= 0)\n            return url.getPath().substring(0, end + 1);\n        else\n            return url.getPath();  \n    }\n",
    "3717": "    public String getTargetFolder() {\n        return targetFolder;\n    }\n",
    "3720": "    public void setViewData(View view) {\n        baseDoc = (HTMLDocument)view.getDocument();\n        super.setViewData(view);\n    }\n",
    "3721": "    public String getSourceName() {\n        return sourceName;\n    }\n",
    "3722": "    private void createTempObject(String url) {\n        // File fin = new File();\n    }\n",
    "3723": "    public void setSourceName(String sourceName) {\n        this.sourceName = sourceName;\n    }\n",
    "3724": "    public void actionPerformed(ActionEvent event) {\n        strUrl = this.getContent();\n        if (jd == null)\n            createDialog();\n        showVideo();\n    }\n",
    "3726": "    public boolean accept(File f) { \n        if (f.isDirectory())\n            return true;\n        String ext = FileManager.getExtension(f);\n        return (ext.equals(\".hhp\"));\n    }\n",
    "3727": "    public String getDescription() {\n        return (\"hhp - HTML Help project files\");\n    }\n",
    "3729": "    private void createDialog() {\n        // set up the messages area\n        jd = new JDialog();\n        contentPane = jd.getContentPane();\n\n        messages = new JTextArea();\n        messages.setLineWrap(true);\n        messages.setWrapStyleWord(true);\n        messages.setEditable(false);\n        messagePanel = new JScrollPane();\n        \n        messagePanel.setOpaque(false);\n        messagePanel.setRequestFocusEnabled(false);\n        messagePanel.setPreferredSize(new java.awt.Dimension(400, 200));\n        messagePanel.setViewportView(messages);\n        contentPane.add(messagePanel, BorderLayout.NORTH);\n        northComponent = messagePanel;\n        \n        jd.pack();\n        jd.show();\n        jd.requestFocusInWindow();        \n    }\n",
    "3736": "    private void centre() {\n        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n        Dimension winSize = getSize();\n        setLocation((screen.width - winSize.width)/2, (screen.height - winSize.height)/2);\n    }\n",
    "3737": "        public void realizeComplete(RealizeCompleteEvent event) {\n            Component vc = player.getVisualComponent();\n            messagePanel.setVisible(false);\n           \n            if (vc != null) {\n                contentPane.add(vc,BorderLayout.CENTER);\n                centerComponent = vc;\n            } else {\n                if (centerComponent != null) {\n                    contentPane.remove(centerComponent);\n                    contentPane.validate();\n                }\n            }\n            Component cpc = player.getControlPanelComponent();\n            if (cpc != null) {\n                contentPane.add(cpc, BorderLayout.SOUTH);\n                southComponent = cpc;\n            } else {\n                if (southComponent != null) {\n                    contentPane.remove(southComponent);\n                    contentPane.validate();\n                }\n            }\n            jd.addWindowListener(new WindowHandler());\n            jd.pack();\n            jd.setTitle(strUrl);\n            jd.show();           \n        }\n",
    "3738": "    private void setLicenceText() {\n        URL url = getClass().getResource(\"/resources/licence.html\");\n        try {\n            informationArea.setPage(url);\n        }\n        catch (IOException e) {\n            informationArea.setText(\"Unable to open licence page. This program is copyrighted.  Please do not use and re-install.\");\n        }\n    }\n",
    "3742": "    public void display() {\n        setLicenceText();\n        pack();\n        centre();\n        setVisible(true); \n        toFront();\n        \n    }\n",
    "3743": "        public void windowClosing(WindowEvent e) {\n            if (player != null) {\n                player.stopAndDeallocate();\n                player.close();\n            }\n            \n            jd.dispose();\n        }\n",
    "3745": "    public void init() {\n        logger.debug(\"Initialise the application.\");\n        configProps = new PropertyManager(\"configuration.properties\");\n        window = new MainFrame(this);\n        window.pack();\n        window.setVisible(true);   \n    }\n",
    "3746": "    public void close() {\n        // nothing to do\n    }\n",
    "3747": "    public String getDefaultSource() {\n        return configProps.getProperty(\"defaultSource\", \"\");\n    }\n",
    "3748": "        protected void checkNamespace(String uri) {\n\n        }\n",
    "3749": "    public boolean requiresLayout() {\n        return true;\n    }\n",
    "3750": "    public void setDefaultSource(String defaultSource) {\n        configProps.setProperty(\"defaultSource\", defaultSource);\n    }\n",
    "3751": "    public void append(LoggingEvent event) {\n        if (textArea != null) {\n            Level level = event.getLevel();\n            if (level == Level.FATAL)\n                textArea.append(\"[FATAL] \");\n            else if (level == Level.WARN)\n                textArea.append(\"[WARN] \");\n            else if (level == Level.INFO)\n                textArea.append(\"[INFO] \");\n            else if (level == Level.DEBUG)\n                textArea.append(\"[DEBUG] \");\n            else \n                textArea.append(\"[----] \");\n            \n            textArea.append(event.getRenderedMessage());\n            textArea.append(\"\\n\");\n            \n        }\n    }\n",
    "3753": "    public String getDefaultTarget() {\n        return configProps.getProperty(\"defaultTarget\", \"\");\n    }\n",
    "3754": "    public void setTextArea(JTextArea argTextArea) {\n        textArea = argTextArea;\n    }\n",
    "3756": "    public void saveConfig() {\n        logger.debug(\"Save the configuration properties.\");\n        configProps.store();\n    }\n",
    "3760": "     static public void copyFile(File in, File out) throws Exception {\n        FileInputStream fis  = new FileInputStream(in);\n        FileOutputStream fos = new FileOutputStream(out);\n        byte[] buf = new byte[1024];\n        int i = 0;\n        while((i=fis.read(buf))!=-1) {\n            fos.write(buf, 0, i);\n        }\n        fis.close();\n        fos.close();\n    }\n",
    "3764": "        public AntHandler getCurrentAntHandler() {\n            return currentHandler;\n        }\n",
    "3765": "     static public String makeAbsolute(String currentPath, String defaultDir) {\n         File file = new File(currentPath);\n         if (file.isAbsolute())\n             return currentPath;\n         else\n             return combine(defaultDir, file.getName());\n     }\n",
    "3768": "     static public String buildPath(String dir, String fileName, String ext) {\n         return combine(dir, fileName + ext);\n     }\n",
    "3769": "    public String getLanguage(int encType) {\n        if (encType == INDEX) {\n            return m_props.getProperty(\"index_lang\", \"en\");\n        }\n        else if (encType == MAP) {\n            return m_props.getProperty(\"map_lang\", \"en\");\n        }\n        else if (encType == TOC) {\n            return m_props.getProperty(\"toc_lang\", \"en\");\n        }\n        else if (encType == HS) {\n            return m_props.getProperty(\"hs_lang\", \"en\");\n        }        \n        return \"en\";\n    }\n",
    "3770": "    static public String changeDirectory(String path, String newDir) {\n        String fileName = \"\";\n        try {\n            File file = new File(path);\n            fileName = file.getName();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        \n        return combine(newDir, fileName);\n    }\n",
    "3772": "    static public String getDirectory(String path) {\n        String dir = path;\n        try {\n            File file = new File(path);\n            dir = file.getParent();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        return dir;\n    }\n",
    "3773": "    public String getInputEncoding(int encType) {\n        if (encType == HTML) {\n            return m_props.getProperty(\"html_in\", \"UTF-8\");\n        }\n        else if (encType == CSS) {\n            return m_props.getProperty(\"css_in\", \"UTF-8\");\n        }\n        else if (encType == HPP) {\n            return m_props.getProperty(\"hpp_in\", \"UTF-8\");\n        }\n        else if (encType == JS) {\n            return m_props.getProperty(\"js_in\", \"UTF-8\");\n        }\n        else if (encType == HCC) {\n            return m_props.getProperty(\"hcc_in\", \"UTF-8\");\n        }\n        m_logger.warn(\"Attempted to get input encoding for unrecognised encoding type.\");\n        return \"UTF-8\";\n    }\n",
    "3774": "    static public String getName(String path) {\n        String name = path;\n        try {\n            File file = new File(path);\n            name = file.getName();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        return name;\n        \n    }\n",
    "3777": "    public int getEncodingJTidyR7(String enc) {\n        if (enc.equalsIgnoreCase(\"ASCII\")) {\n            return org.w3c.tidy.Configuration.ASCII;\n        }\n        else if (enc.equalsIgnoreCase(\"ISO2022\")) {\n            return org.w3c.tidy.Configuration.ISO2022;\n        }\n        else if (enc.equalsIgnoreCase(\"LATIN1\")) {\n            return org.w3c.tidy.Configuration.LATIN1;\n        }\n        else if (enc.equalsIgnoreCase(\"MACROMAN\")) {\n            return org.w3c.tidy.Configuration.MACROMAN;\n        }\n        else if (enc.equalsIgnoreCase(\"RAW\")) {\n            return org.w3c.tidy.Configuration.RAW;\n        }\n        else if (enc.equalsIgnoreCase(\"UTF8\")) {\n            return org.w3c.tidy.Configuration.UTF8;\n        }\n        else {\n            return org.w3c.tidy.Configuration.UTF8;\n        }\n    \n    }\n",
    "3778": "    static public String getExtension(File f) {\n        return getExtension(f.getPath());\n    }\n",
    "3780": "    static public String getExtension(String path) {\n        int extStart = path.lastIndexOf(\".\");\n        if (extStart >= 0)\n            return path.substring(extStart).toLowerCase();\n        else\n            return \"\";  \n    }\n",
    "3782": "    static public String changeExtension(String path, String newExtension) {\n        String retStr;\n        int extStart = path.lastIndexOf(\".\");\n        if (extStart >= 0)\n            retStr = path.substring(0, extStart);\n        else\n            retStr = path;\n        if (newExtension.length() > 0) \n            retStr += (newExtension.charAt(0) == '.' ? newExtension : \".\" + newExtension);\n        return retStr;\n    }\n",
    "3787": "    static public boolean isExistingDirectory(String name) {\n        File file = new File(name);\n        return file != null && file.exists() && file.isDirectory();\n    }\n",
    "3788": "    public BufferedReader getBufferedFileReader(String inname, int encType) throws java.io.FileNotFoundException {\n        String enc = getInputEncoding(encType);\n        boolean encodingValid = false;\n        try {\n            encodingValid = Charset.isSupported(enc);\n        }\n        catch (Exception e) {\n            m_logger.warn(\"Unable to use encoding \" + enc + \".  \" + e.getMessage());\n        }\n        if (encodingValid) {\n            m_logger.info(\"Reader created with encoding \" + enc);\n            return new BufferedReader(new InputStreamReader(new FileInputStream(inname), Charset.forName(enc)));\n        }\n        else {\n            return new BufferedReader(new InputStreamReader(new FileInputStream(inname)));\n        }\n    }\n",
    "3791": "    static public boolean isExistingFile(String name) {\n        File file = new File(name);\n        return file != null && file.exists() && file.isFile();\n    }\n",
    "3792": "    public BufferedReader getBufferedReader(InputStream in, int encType) {\n        String enc = getInputEncoding(encType);\n        boolean encodingValid = false;\n        try {\n            encodingValid = Charset.isSupported(enc);\n        }\n        catch (Exception e) {\n            m_logger.warn(\"Unable to use encoding \" + enc + \".  \" + e.getMessage());\n        }\n        if (encodingValid) {\n            m_logger.info(\"Reader created with encoding \" + enc);\n            return new BufferedReader(new InputStreamReader(in, Charset.forName(enc)));\n        }\n        else {\n            return new BufferedReader(new InputStreamReader(in));\n        }\n    }\n",
    "3793": "    public String parse(HTMLDoc doc, Node node) {\n        if (node.getNodeName().equals(\"a\"))\n            return parseAnchor(doc, node);\n        else if (node.getNodeName().equals(\"script\"))\n            return parseScript(doc, node);\n        \n        return null;\n            \n    }\n",
    "3794": "    static public String toUri(String name) {\n        File file = new File(name);\n        String uri;\n        // Convert the file object to a URL\n        URL url = null;\n        try {\n            // The file need not exist. It is made into an absolute path\n            // by prefixing the current working directory\n            url = file.toURL();          // file:/d:/almanac1.4/java.io/filename\n            uri = url.toString();\n        } \n        catch (MalformedURLException e) {\n            uri = \"\";\n        }\n        return uri;\n    }\n",
    "3796": "    public boolean run() {\n        return true;\n    }\n",
    "3798": "   protected void logRunHeader(String header) {\n        logger.info(header);\n        logger.info(\"Source name: \" + sourceName);\n        logger.info(\"Target folder: \" + project.getTargetFolder());\n    }\n",
    "3800": "    protected void logRunFooter() {\n        // do nothing\n    }\n",
    "3801": "        public void setDocumentLocator(Locator locator) {\n            context.setLocator(locator);\n        }\n",
    "3802": "    private boolean createHTMLFile(String text, String targetName, String source) {\n        String htmlOut = \"<html><head><title>popup</title></head><body>\" + text + \"</body></html>\";\n        ByteArrayInputStream in = new ByteArrayInputStream(htmlOut.getBytes());\n        ParserHTML parser = new ParserHTML(project, source); \n        return parser.run((InputStream)in, targetName);\n    }\n",
    "3803": "    protected void logMessageAtLine(String message) {\n        logger.info(\"Line \" + lineNumber + \": \" + message);\n    }\n",
    "3805": "    protected void logWarningAtLine(String message) {\n        logger.warn(\"Line \" + lineNumber + \": \" + message);\n    }\n",
    "3806": "    private String getPopupIdName(String text) {\n        int start;\n        int end;\n        try {\n            start = text.indexOf(popupSignature);\n            end = start + popupSignature.length();\n            \n            while (CharUtility.isAsciiVariable(text.charAt(end)) ) {\n                end++;\n            }\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Could not decode popup id from \" + text);\n            return null;\n        }\n        if (start >= 0 && end > start) \n            return text.substring(start, end);\n        return null;\n        \n    }\n",
    "3807": "    protected boolean startReader(int encType) {\n        boolean bOkay = true;\n        reader = null;\n        lineNumber = 0;\n        try {\n            // reader = new BufferedReader(new FileReader(sourceName));\n            reader = EncodingManager.getInstance().getBufferedFileReader(sourceName, encType);\n        }\n        catch(FileNotFoundException e) {\n            logger.warn(\"Cannot open file \" + sourceName + \": \" + e.toString());\n            \n            bOkay = false;\n        }\n        return bOkay;\n    }\n",
    "3809": "    private void processSource(String name) {\n        if (sourceFiles.contains(name)) {\n            logger.debug(\"Already handled \" + name);\n            return;\n        }\n\n        sourceFiles.add(name);\n        \n        File f = new File(name);\n        String line;\n        boolean processing = true;\n        while (processing) {\n            processing = false;\n        }\n    \n    }\n",
    "3810": "    protected String getLine() {\n        String retLine = null;\n        try {\n            retLine = reader.readLine();\n            lineNumber++;\n        }\n        \n        catch (IOException e) {\n            logger.warn(\"IO error reading \" + sourceName + \"at line \" + lineNumber + \": \" + e.toString());\n            \n        }\n        return retLine;\n    }\n",
    "3814": "    private void handleAssignments(String line) {\n        String[] elements = line.split(\"=\");\n        if (elements.length > 1) {\n            String attribute = elements[0].trim().toUpperCase();\n            String value = elements[1].trim();\n            if (attribute.equals(\"TITLE\")) {\n                title = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value );\n            } \n            else if (attribute.equals(\"INDEX FILE\")) {\n                indexName = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value );\n            }\n            else if (attribute.equals(\"CONTENTS FILE\")) {\n                contentsName = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value);\n            }\n            else if (attribute.equals(\"DEFAULT TOPIC\")) {\n                defaultTopic = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value);\n            }\n        }\n    }\n",
    "3816": "    public void setMap(HashMap argMap) {\n        map = argMap;\n    }\n",
    "3818": "    public String getIndexName() {\n        return indexName;\n    }\n",
    "3819": "        public void endElement(String uri, String name, String qName) throws SAXException {\n            currentHandler.onEndElement(uri, name, context);\n            AntHandler prev = (AntHandler) antHandlers.pop();\n            currentHandler = prev;\n            if (currentHandler != null) {\n                currentHandler.onEndChild(uri, name, qName, context);\n            }\n        }\n",
    "3821": "    public void buildMap(XMLDoc doc) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        element = doc.addElement(null, \"maps\");\n        doc.addElement((org.w3c.dom.Node)element, \"homeID\", defaultTopicId);\n        element = doc.addElement((org.w3c.dom.Node)element, \"mapref\");\n        doc.setAttribute(element, \"location\", project.getProjectName() + \".jhm\");\n    }\n",
    "3822": "    public String getQuotedText(String text, boolean toHTML) {\n        StringBuffer out = new StringBuffer(100);\n        int end = text.length();\n        try {\n            int start = text.indexOf('\\\"');\n            start++;\n            while (start < end) {\n                if (text.charAt(start) == '\\\"')\n                    break;\n                if (text.charAt(start) == '\\\\')\n                    out.append(unescape(text.charAt(++start), toHTML));\n                else\n                    out.append(text.charAt(start));\n                start++;\n            }\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Error finding javascript quoted line: \" + e.getMessage());\n            return null;\n        }\n        return out.toString();\n    }\n",
    "3823": "    public String getContentsName() {\n        return contentsName;\n    }\n",
    "3824": "    private String unescape(char esc, boolean toHTML) {\n        if (esc == 'n')\n            return toHTML ? \"<br>\" : \"\\n\";\n        else if (esc == 'r')\n            return toHTML ? \"\" : \"\\r\"; // ignored as only handle \\n\n        else if (esc == 't')\n            return toHTML ? \"&nbsp;&nbsp;&nbsp;&nbsp;\" : \"\\r\";\n        else if (esc == '\\\\')\n            return \"\\\\\";\n        else if (esc == 'f')\n            return toHTML ? \"<hr>\" : \"\\f\";\n        else if (esc == '\\'')\n            return \"\\'\";\n        else if (esc == '\\\"')\n            return \"\\\"\";\n        else\n            return String.valueOf(esc); // ignore the escaping\n    }\n",
    "3825": "    public void buildView(XMLDoc doc, String merge, String name, String label, String typeName, String data ) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        \n        element = doc.addElement(null, \"view\");\n     \n        doc.setAttribute(element, \"xml:lang\", EncodingManager.getInstance().getLanguage(EncodingManager.HS));\n        doc.setAttribute(element, \"mergetype\", merge);\n        doc.addElement((org.w3c.dom.Node)element, \"name\", name);\n        doc.addElement((org.w3c.dom.Node)element, \"label\", label);\n        doc.addElement((org.w3c.dom.Node)element, \"type\", typeName);\n        doc.addElement((org.w3c.dom.Node)element, \"data\", data);\n      \n        \n    }\n",
    "3826": "    public String getTitle() {\n        return title;\n    }\n",
    "3829": "    public HashMap getLinks() {\n        return links;\n    }\n",
    "3831": "    public String getDefaultTopic() {\n        return defaultTopic;\n    }\n",
    "3833": "    public void setDefaultTopicId(String id) {\n        defaultTopicId = id;\n    }\n",
    "3835": "    public String getDefaultTopicId() {\n        return defaultTopicId;\n    }\n",
    "3837": "    public HashSet getHtmlFiles() {\n        return htmlFiles;\n    }\n",
    "3838": "    public boolean write(BufferedWriter writer) throws IOException {\n        logger.debug(\"Writing the HTMLDoc to file.\");\n        if (htmlDoc == null) {\n            logger.warn(\"Attempt to write a null XML document.\");\n            return false;\n        }\n        // writer.write(\"<?xml version='1.0' encoding='ISO-8859-1' ?>\");\n        writer.write(NEW_LINE);\n        writer.write(getDocTypeString());\n        String rawText = getDocumentNode(htmlDoc.getDocumentElement(), \" \");\n        writer.write(replaceText(rawText));\n        return true;\n    }\n",
    "3839": "    public  void setLinks(HashMap argLinks) {\n        links = argLinks;\n    }\n",
    "3840": "    public String getFileName() {\n        return fileName;\n    }\n",
    "3844": "     private void buildDocument(XMLDoc doc) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        doc.setAttribute(null, \"version\", \"2.0\");\n        doc.setAttribute(null, \"xml:lang\", EncodingManager.getInstance().getLanguage(EncodingManager.MAP));\n        doc.addComment(null, \"Map IDs\");\n\n        // iterate through the map adding the links\n        Set set = links.entrySet();\n        Iterator it = set.iterator();\n        while (it.hasNext()) {\n            Map.Entry ent = (Map.Entry)it.next();\n            String target = (String)ent.getValue();\n            String url = (String)ent.getKey();\n            addID(doc, target, url);\n        }\n    }\n",
    "3845": "    public boolean run() {\n        logRunHeader(\"Parsing css file.\");\n        FileInputStream in = null;\n\n        try {\n            in = new FileInputStream(sourceName);\n        }\n        catch (FileNotFoundException e) {\n            logger.warn(\"Error reading css file: \" + e.getMessage());\n            return false;\n        }\n       \n        return run(in, sourceName);\n    }\n",
    "3846": "     private void addID(XMLDoc doc, String target, String url) {\n        org.w3c.dom.Element element;\n        element = doc.addElement(null, \"mapID\");\n        doc.setAttribute(element, \"target\", target);\n        doc.setAttribute(element, \"url\", url); \n     }\n",
    "3848": "        public void startPrefixMapping(String prefix, String uri) {\n            context.startPrefixMapping(prefix, uri);\n        }\n",
    "3851": "    public boolean run() {\n        logRunHeader(\"Parsing HTML file.\");\n        FileInputStream in = null;\n\n        try {\n            in = new FileInputStream(sourceName);\n        }\n        catch (FileNotFoundException e) {\n            logger.warn(\"Error reading HTML file: \" + e.getMessage());\n            return false;\n        }\n       \n        return run(in, sourceName);\n        \n        \n    }\n",
    "3852": "    public String replaceQuotes(String str) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == QUOTE) \n                buf.append(QUOTE_ENTITY);\n            else\n                buf.append(str.charAt(i));\n        }\n        return buf.toString();\n    } \n",
    "3853": "    private void copyImageFile(String image) {\n        File fin =new File(FileManager.buildPath(sourceFolder, image, \"\"));\n        File fout = new File(FileManager.buildPath(project.getTargetFolder(), image, \"\"));\n        if (!fin.exists()) \n            logger.warn(\"Image \" + fin.getPath() + \"does not exist.\");\n        else {\n            logger.info(\"Copy \" + fin.getPath() + \" to \" + fout.getPath());\n            try {\n                FileManager.copyFile(fin, fout);\n            }\n            catch (Exception e) {\n                logger.warn(\"Error copying files. \" + e.toString());\n            }\n        }\n    }\n",
    "3856": "    private String replaceElement(org.w3c.dom.Node node) {\n        String nodeName = node.getNodeName();\n        // handle any popup information\n        String popup = popupParser.parse(this, node); \n        if (popup != null)\n            return popup;\n        \n        if (nodeName.equals(\"object\")) {\n            return objectParser.parse(this, node);\n        }\n        else if (nodeName.equals(\"embed\")) {\n            objectParser.handleEmbed(this, node);\n        }\n        \n        if (replaceElements == null)\n            return null;\n        return replaceElements.getProperty(nodeName);\n    }\n",
    "3857": "    private void createFullIndexItem(org.w3c.dom.Element parentIndexItem) {\n        if (!skipElement(currentIndexItem, currentName)) {\n            currentIndexItem = xmlDoc.addElement(parentIndexItem, \"indexitem\");\n            xmlDoc.setAttribute(currentIndexItem, \"text\", currentName);\n            String mapID = (String)map.get(currentTarget);\n            if (mapID == null) {\n                // couldn't find the mapID\n                mapID = handleUnknownTarget(currentTarget);\n            }\n            xmlDoc.setAttribute(currentIndexItem, \"target\", mapID);\n        }\n    }\n",
    "3859": "        public void endPrefixMapping(String prefix) {\n            context.endPrefixMapping(prefix);\n        }\n",
    "3860": "    private String handleUnknownTarget(String url) {\n        String id = null;\n        logger.debug(\"Unknown target \" + url);\n        String[] parts = url.split(\"#\");\n        if (parts.length > 1) {\n            logger.debug(\"Anchor so add to map.\");\n            id = (String)map.get(parts[0]);\n            if (id != null) {\n                // okay the target document does exist so we can add the anchor\n                id = id + \"#\" + parts[1] + \"_\"; // form a new map id\n                map.put(url, id);\n            }\n            else\n                logger.warn(\"Anchor to missing target file found. \" + url);\n        }\n        \n        return id;\n    }\n",
    "3862": "    private String replaceText(String str) {\n        return TextReplacer.replaceText(replaceText, str);\n    }\n",
    "3864": "    private void createTargetlessIndexItem(org.w3c.dom.Element parentIndexItem) {\n        if (!skipElement(currentIndexItem, currentName)) {\n            currentIndexItem = xmlDoc.addElement(parentIndexItem, \"indexitem\");\n            xmlDoc.setAttribute(currentIndexItem, \"text\", currentName);\n        }\n    }\n",
    "3865": "    public void handleEmbed(HTMLDoc doc, Node node) {\n       if (currentNode != null) {\n           source = doc.getAttribute(node, \"src\");\n       } \n    }\n",
    "3866": "    private String getLinkText(String classID) {\n        if (classID == null) \n            return \"\";\n        String classText = null;\n        \n        classText = props.getProperty(classID, props.getProperty(\"unknownClass\", \"Unknown object.  Not supported in JavaHelp\"));\n        if (source == null)\n           return classText;\n        \n        if (classText.startsWith(PopupSecondaryViewer.VIEWER_TAG)) {\n            PopupSecondaryViewer sv = new PopupSecondaryViewer(props, classText.replace(\"__SOURCE__\", source));\n            return sv.getJHObject(source);\n        }\n        else\n            return classText.replace(\"__SOURCE__\", source);\n    }\n",
    "3867": "    private String handleWrapperTag(org.w3c.dom.Node node, StringBuffer nodeStr) {\n        String endWrapper = \"\";\n        if (node.getNodeName().equals(\"table\")) {\n            String color = getAttribute(node, \"bgcolor\");\n            if (color != null) {\n                nodeStr.append(\"<div style=\\\"background-color:\" +  color + \"\\\">\\n\");\n                endWrapper = \"</div>\\n\";\n            }\n        }\n        return endWrapper;\n    }\n",
    "3869": "    public String getDocTypeString() {\n        StringBuffer buffer = new StringBuffer(1000);\n        String str;\n        buffer.append(\"<!DOCTYPE \");\n        buffer.append(docType.getName());\n        if ((str = docType.getSystemId()) != null)\n            buffer.append(\"\\n   SYSTEM \\\"\" + str + \"\\\"\");\n        if ((str = docType.getPublicId()) != null)\n            buffer.append(\"\\n   PUBLIC \\\"\" + str + \"\\\"\");\n        if ((str = docType.getInternalSubset()) != null)\n            buffer.append(\"\\n   [\" + str + \"]\");\n        if (namespace != null)\n            buffer.append(\"\\n   \\\"\" + namespace + \"\\\"\");\n        \n        buffer.append(\">\\n\");\n        return buffer.toString();\n        \n    }\n",
    "3870": "    private String additionalChildren(org.w3c.dom.Node node) {\n        if (node.getNodeName().equals(\"head\")) {\n            // we need to put the encoding string at the top or JavaHelp seems to ignore it.\n            return EncodingManager.getInstance().getEncodingTag(EncodingManager.HTML) + \"\\n\";\n        }\n        return \"\";\n    } \n",
    "3871": "    private boolean skipElement(org.w3c.dom.Element prev, String text) {\n        String oldText = xmlDoc.getAttribute(prev, \"text\");\n        if (oldText == null)\n            return false;\n        return oldText.equals(text);\n    }\n",
    "3872": "    public boolean write(BufferedWriter writer, String tag) throws IOException {\n        if (doc == null) {\n            logger.warn(\"Attempt to write a null XML document.\");\n            return false;\n        }\n        writer.write(tag);\n        writer.write(NEW_LINE);\n        writer.write(getDocTypeString());\n        writer.write(getDocumentNode(doc.getDocumentElement(), \"\"));\n        return true;\n    }\n",
    "3881": "    public HashMap getMap() {\n        return map;\n    }\n",
    "3883": "    public String replaceQuotes(String str) {\n        if (str == null) {\n            return \"\";\n        }\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == QUOTE) \n                buf.append(QUOTE_ENTITY);\n            else\n                buf.append(str.charAt(i));\n        }\n        return buf.toString();\n    }\n",
    "3971": "        public void onEndElement(String uri, String tag, AntXMLContext context) {\n            context.setCurrentTarget(context.getImplicitTarget());\n        }\n",
    "4041": "        public void onEndElement(String uri, String tag, AntXMLContext context) {\n            context.popWrapper();\n        }\n",
    "4413": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t    \tif (extension.equals(WEIGHTS_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4415": "\tpublic String getDescription(){\n\t\treturn WEIGHTS_DESCRIPTION;\n\t}\n",
    "4417": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t\t\tif (extension.equals(LOG_FILE_EXTENSION)) {\n\t\t        return true;\n\t\t\t} else {\n\t\t\t    return false;\n\t\t\t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4419": "\tpublic String getDescription(){\n\t\treturn LOG_FILE_DESCRIPTION;\n\t}\n",
    "4421": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t    \tif (extension.equals(PERFORMANCE_CONFIG_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4422": "\tpublic String getDescription(){\n\t\treturn PERFORMANCE_CONFIG_DESCRIPTION;\n\t}\n",
    "4437": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t    if (extension != null) {\n\t    \tif (extension.equals(CASEBASE_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4438": "\tpublic String getDescription(){\n\t\treturn CASEBASE_DESCRIPTION;\n\t}\n",
    "4448": "    public void TeamNameMissing(CaseEvent ce){\n\tSystem.err.println(\"The Log File doesn't contain initialization messages.\");\n\tSystem.err.println(\"Please run again with the third parameter.\");\n\tSystem.err.println(\" \");\n\tdisplayUsage();\n\tSystem.exit(1);\n    }\n",
    "4451": "    public void GotInputs(CaseEvent ce){\n\tm_lastInputs=ce.getAgentInputs();\n    }\n",
    "4453": "    public void GotActions(CaseEvent ce){\n\tm_actionList=ce.getAgentActions();\n\tCase c = new Case(m_lastInputs,m_actionList);\n\tm_casebase.addCase(c);\n    }\n",
    "4459": "    public CaseBase getCaseBase(){\n\treturn new CaseBase(this.m_casebase);\n    }\n",
    "4462": "    public void writeCaseBaseFile() throws IOException {\n\t\t\n\tCaseBaseIO.saveCaseBase(this.m_casebase,this.m_outputFileName);\n\t\t\n    }\n",
    "4464": "\tpublic void setHorizontalPosition(String pos){\n\t\t//check params\n\t\tif(pos == null){\n\t\t\tthrow new IllegalArgumentException(\"Horizonal position of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM)){\n\t\t\tthrow new IllegalArgumentException(\"Horizonal position of a flag set to an invalid value: \" + pos);\n\t\t}\n\t\t\n\t\tthis.m_horizontal = pos;\n\t}\n",
    "4467": "\tpublic String getHorizontalPosition(){\n\t\treturn this.m_horizontal;\n\t}\n",
    "4471": "\tpublic void setVerticalPosition(String pos){\n\t\t//check params\n\t\tif(pos == null){\n\t\t\tthrow new IllegalArgumentException(\"Vertical position of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT)){\n\t\t\tthrow new IllegalArgumentException(\"Vertical position of a flag set to an invalid value: \" + pos);\n\t\t}\n\t\t\n\t\tthis.m_vertical = pos;\n\t}\n",
    "4472": "\tpublic String getVerticalPosition(){\n\t\treturn this.m_vertical;\n\t}\n",
    "4473": "        public String toString(){\n\t    String result=super.toString()+\":\";\n\t    result+=Float.toString(this.m_distanceChange)+\":\";\n\t    result+=Float.toString(this.m_directionChange);\n\t    return result;\n\t}\n",
    "4476": "        public RoboCupSimulation2DSpatialObject copyOfThis(){\n\t    RoboCupSimulation2DSpatialObject copy=new RoboCupSimulation2DSpatialObject(this.getFeatureName());\n\t    copy.setDistance(this.getDistance());\n\t    copy.setDirection(this.getDirection());\n\t    copy.setDistanceChange(this.m_distanceChange);\n\t    copy.setDirectionChange(this.m_directionChange);\n\t    return copy;\n\t}\n",
    "4477": "\tpublic void setOutOfBounds(boolean out){\n\t\tthis.m_outOfBounds = out;\n\t}\n",
    "4478": "\tpublic void setDistanceChange(float distChange){\n\t\tthis.m_distanceChange = distChange;\n\t}\n",
    "4479": "\tpublic boolean isOutOfBounds(){\n\t\treturn this.m_outOfBounds;\n\t}\n",
    "4480": "\tpublic void setDirectionChange(float dirChange){\n\t\tthis.m_directionChange = dirChange;\n\t}\n",
    "4481": "\tpublic void setFlagNumber(int num){\n\t\tthis.m_flagNumber = num;\n\t}\n",
    "4483": "\tpublic float getDistanceChange(){\n\t\treturn this.m_distanceChange;\n\t}\n",
    "4485": "\tpublic float getDirectionChange(){\n\t\treturn this.m_directionChange;\n\t}\n",
    "4486": "\tpublic int getFlagNumber(){\n\t\treturn this.m_flagNumber;\n\t}\n",
    "4488": "\tpublic void setLocation(String s){\n\t\t//check parameters\n\t\tif(s == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given.\");\n\t\t}\n\t\t//check for invalid locations\n\t\tString lowerside = s.toLowerCase();\n\t\tif( !(lowerside.equals(LineFeature.c_LOCATION_LEFT)) && !(lowerside.equals(LineFeature.c_LOCATION_RIGHT)) && !(lowerside.equals(LineFeature.c_LOCATION_TOP)) && !(lowerside.equals(LineFeature.c_LOCATION_BOTTOM))){\n\t\t\tthrow new IllegalArgumentException(\"Illegal line position: \" + lowerside);\n\t\t}\n\t\t\n\t\tthis.m_location = lowerside;\n\t}\n",
    "4489": "\tprivate String browseForExistingFile(int fileType) {\n\t\tthis.fileChooser.resetChoosableFileFilters();\n\t\tswitch(fileType){\n\t\tcase CASE_BASE_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new CaseBaseFileFilter());\n\t\t\tbreak;\n\t\tcase WEIGHTS_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new WeightsFileFilter());\n\t\t\tbreak;\n\t\tcase CONFIG_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new PerformanceConfigFileFilter());\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint returnVal = this.fileChooser.showOpenDialog(this);\n\t\t\n\t\tif(returnVal == JFileChooser.APPROVE_OPTION){\n\t\t\treturn fileChooser.getSelectedFile().getAbsolutePath();\n\t\t}\n        else {\n            return \"\";\n        }\n\t}\n",
    "4490": "\tpublic void setBox(String box){\n\t\t//check params\n\t\tif(box == null){\n\t\t\tthrow new IllegalArgumentException(\"Box location of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!box.equals(FlagFeature.c_GOAL_BOX) && !box.equals(FlagFeature.c_PENALTY_BOX) ){\n\t\t\tthrow new IllegalArgumentException(\"Box location of a flag set to an invalid value: \" + box);\n\t\t}\n\t\t\n\t\tthis.m_box = box;\n\t}\n",
    "4491": "\tpublic String getLocation(){\n\t\treturn new String(this.m_location);\n\t}\n",
    "4494": "\tpublic float getBodyDirection() {\n\t\treturn this.m_bodyDirection;\n\t}\n",
    "4495": "\tpublic String getBox(){\n\t\treturn this.m_box;\n\t}\n",
    "4496": "\tpublic void setBodyDirection(float direction) {\n\t\tthis.m_bodyDirection = direction;\n\t}\n",
    "4498": "\tpublic float getHeadDirection() {\n\t\treturn this.m_headDirection;\n\t}\n",
    "4500": "\tpublic void setHeadDirection(float direction) {\n\t\tthis.m_headDirection = direction;\n\t}\n",
    "4501": "\tpublic boolean isGoalie() {\n\t\treturn this.m_isGoalie;\n\t}\n",
    "4502": "\tpublic void setSide(String side){\n\t\t//test the params\n\t\tif(side == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given.\");\n\t\t}\n\t\t//make sure a valid side selected\n\t\tString lowerside = side.toLowerCase();\n\t\tif( !(lowerside.equals(GoalFeature.c_SIDE_LEFT)) && !(lowerside.equals(GoalFeature.c_SIDE_RIGHT))){\n\t\t\tthrow new IllegalArgumentException(\"Invalid side given for goal.\");\n\t\t}\n\t\t\n\t\t//save the side\n\t\tthis.m_side = lowerside;\n\t}\n",
    "4503": "\tpublic void setIsGoalie(boolean goalie) {\n\t\tthis.m_isGoalie = goalie;\n\t}\n",
    "4505": "\tpublic String getSide(){\n\t\treturn new String(this.m_side);\n\t}\n",
    "4506": "\tpublic int getUniformNumber() {\n\t\treturn this.m_uniformNumber;\n\t}\n",
    "4509": "\tpublic void setUniformNumber(int number) {\n\t\tthis.m_uniformNumber = number;\n\t}\n",
    "4511": "        public TurnNeckAction copyThis(){\n\t    return new TurnNeckAction(this);\n\t}\n",
    "4512": "        public DashAction copyThis(){\n\t    return new DashAction(this);\n\t}\n",
    "4513": "\tpublic float getDashPower(){\n\t\treturn this.m_power;\n\t}\n",
    "4515": "\tpublic float getTurnNeckAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4516": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"power\") == 0)\n\t\treturn Float.toString(this.m_power);\n\t    return \"\";\n\t}\n",
    "4517": "        public CatchAction copyThis(){\n\t    return new CatchAction(this);\n\t}\n",
    "4518": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"angle\") == 0)\n\t\treturn Float.toString(this.m_angle);\n\t    return \"\";\n\t}\n",
    "4520": "\tpublic float getCatchAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4521": "        public KickAction copyThis(){\n\t    return new KickAction(this);\n\t}\n",
    "4523": "\tprivate void runLog2CaseBase(){\n\t\tString input = this.jInputFileName.getText();\n\t\tString output = this.jOutputFileName.getText();\n\t\tString team = this.jTeamName.getText();\n\t\ttry{\n\t\t\tLogFile2CaseBase builder = new LogFile2CaseBase(input, output, team);\n\t\t\tbuilder.parseLogFile();\n\t\t\tbuilder.writeCaseBaseFile();\n\t\t\tJOptionPane.showMessageDialog(this, \"Case base written to \" + output, \"Complete\", JOptionPane.INFORMATION_MESSAGE);\n\t\t}catch(Exception e){\n\t\t\tJOptionPane.showMessageDialog(this, \"Error: \" + e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n",
    "4525": "\tpublic float getKickPower(){\n\t\treturn this.m_power;\n\t}\n",
    "4527": "        public TurnAction copyThis(){\n\t    return new TurnAction(this);\n\t}\n",
    "4528": "\tpublic float getKickAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4530": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"power\") == 0)\n\t\treturn Float.toString(this.m_power);\n\t    if(attrib.compareTo(\"angle\") == 0)\n\t\treturn Float.toString(this.m_angle);\n\t    return \"\";\n\t}\n",
    "4531": "\tpublic float getTurnAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4533": "\tpublic void see(AgentInputs inputs){\n\t\t  this.m_vision.store(inputs);\n\t  }\n",
    "4535": "\tpublic void setTimeOver(boolean b) {\n\t\tthis.m_timeOver = b;\n\t}\n",
    "4539": "\tprivate void displayAboutMessage(){\n\t\tJOptionPane.showMessageDialog(this, this.c_ABOUTMESSAGE, \"About RCSImitate\", JOptionPane.PLAIN_MESSAGE);\n\t}\n",
    "4541": "    public void run(){\n\ttry {\n\t    execute();\n\t} catch (Exception e) {\n\t    System.out.println(\"Fatal Error: \" + e.getMessage());\n\t}\n    }\n",
    "4542": "    private void initAgent(CaseBase cb) {\n\t    CaseBaseSearch cbSearch = new NearestNeighbourSearch(1);\n\t    ActionEstimation ae = new LastActionEstimate();\n\t    ActionSelection actionSelection = new ClosestNeighbourSelection(ae);\n\t    \n\t    // Create an agent with the dummy case base\n\t    agent = new Agent(cb,cbSearch,actionSelection);\n    }\n",
    "4546": "    private void initWeights(String weightsFile) {\n        // If no file was specified, use default values\n        if (weightsFile == null) {\n            weights = new Weights(0.0f);\n            weights.setWeight(BallFeature.c_BALL, 1.0f);\n            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);\n            return;\n        }\n\n        try {\n            weights = WeightsIO.loadWeights(weightsFile);\n        }\n        catch (FileNotFoundException fnfe) {\n            // If an error occurs, use default values\n            weights = new Weights(0.0f);\n            weights.setWeight(BallFeature.c_BALL, 1.0f);\n            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);\n        }\n    }\n",
    "4547": "\tprivate void displayHelpLog2CaseBaseMessage(){\n\t\tJOptionPane.showMessageDialog(this, this.c_HELPLOG2CASEBASEMESSAGE, \"Help\", JOptionPane.PLAIN_MESSAGE);\n\t}\n",
    "4548": "    public void move(double x, double y){\n\t//the message will be (move X Y)\n\tsend(\"(move \" + Double.toString(x) + \" \" + Double.toString(y) + \")\");\n    }\n",
    "4549": "    public void addCEListener(CaseEventListener cel){\n\tCEListeners.add(cel);\n    }\n",
    "4550": "    public void turn(double moment){\n\t//the message will be (turn moment)\n\tsend(\"(turn \" + Double.toString(moment) + \")\");\n    }\n",
    "4552": "    public void removeCEListener(CaseEventListener cel){\n\tCEListeners.remove(cel);\n    }\n",
    "4553": "    public void turn_neck(double moment){\n\t//the message will be (turn_neck moment)\n\tsend(\"(turn_neck \" + Double.toString(moment) + \")\");\n    }\n",
    "4555": "    public void performTests() {\n\tapplyPreprocessing(testBase, testFilenameRoot);\n\t\n\tapplyPreprocessing(agentBase, agentFilenameRoot);\n\n\t// the global values must after the weights are final\n\tsetGlobalValues(weights);\n\n\t// reset the test classes\n\tinitTests();\n\t\n\tinitAgent(agentBase);\n\t\n\trunTests(testBase);\n\t\n\tsaveExpectedAndReceived();\n\t\n\tSystem.out.println(\"[\" + getTime() + \"]: Results:\\n\");\n\t\n\tSystem.out.println(getReportString());\n\t\n\t// Space out the output\n\tSystem.out.println();\n\t\n\t// Outputs result data to text files\n\toutputResultToFile();\n\toutputExpectedActualToFile();\n    }\n",
    "4556": "    public void ClientInit(ParsingEvent pe){\n\tm_teamName=pe.get(\"team_name\");\n\tCaseEvent ce = new CaseEvent(this,m_teamName);\n\tfor(CaseEventListener cel:CEListeners) cel.Connecting(ce);\n    }\n",
    "4557": "    public void dash(double power){\n\t//the message will be (dash power)\n\tsend(\"(dash \" + Double.toString(power) + \")\");\n    }\n",
    "4558": "    public void ServerInit(ParsingEvent pe){\n\tCaseEvent ce = new CaseEvent(this);\n\tfor(CaseEventListener cel:CEListeners) cel.Connected(ce);\n    }\n",
    "4559": "    public void kick(double power, double direction){\n\t//the message will be (kick power direction)\n\tsend(\"(kick \" + Double.toString(power) + \" \" + Double.toString(direction) + \")\");\n    }\n",
    "4561": "    private void outputResultToFile(){\n    \ttry{\n\t    \tPrintStream output = new PrintStream(new File(\"Results-\" + testID + \".txt\"));\n\t    \toutput.println(\"[\" + getTime() + \"]: Results:\\n\");\n\t    \toutput.println(getReportString());\n\t    \toutput.close();\n    \t}catch(IOException e){\n    \t\tSystem.out.println(\"Result File Creation Error\");\n    \t}\n    }\n",
    "4562": "    public void say(String message){\n\t//message will be (say message)\n\tsend(\"(say \" + message + \")\");\n    }\n",
    "4563": "    public void Sensing(ParsingEvent pe){\n\tif(m_teamName.equals(\"\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);\n\t}\n\telse{\n\t    if(m_lastInputs.getNumberSensoryItems()>0){\n\t\tCaseEvent ce = new CaseEvent(this,m_actionList);\n\t\tfor(CaseEventListener cel:CEListeners) cel.GotActions(ce);\n\t    }\n\t    m_lastInputs = new AgentInputs();\n\t    m_actionList = new ArrayList<AgentAction>();\n\t}\n    }\n",
    "4565": "    private void outputExpectedActualToFile(){\n    \tif(saveArtifacts){\n\t    \ttry{\n\t    \t\tPrintStream output = new PrintStream(new File(\"Expected-Actual-\" + testID + \".txt\"));\n\t    \t\toutput.println(saveExpectedAndReceived());\n\t    \t\toutput.close();\n\t    \t}catch(IOException e){\n\t    \t\tSystem.out.println(\"Expected Acutal File Creation Error\");\n\t    \t}\n    \t}\n    }\n",
    "4566": "    public void changeView(String angle, String quality){\n\t//message will be (change_view angle quality)\n\tsend(\"(change_view \" + angle + \" \" + quality + \")\");\n    }\n",
    "4567": "    public void SeeReceived(ParsingEvent pe){\n\tm_lastInputs = new AgentInputs();\n    }\n",
    "4569": "    public void catchBall(String direction){\n\t//message will be (catch direction)\n\tsend(\"(catch \" + direction + \")\");\n    }\n",
    "4571": "    private void applyPreprocessing(CaseBase cb, StringBuilder filenameRoot) {\n\tfor (String action : preprocessingActions) {\n\t    if (action.matches(\"(?i)(NoActionsFilter)|(naf)\")) {\n\t\tapplyNoActionsFilter(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(FeatureDistancePresort)|(fdp)\")) {\n\t\tapplyFeatureDistancePresort(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(SequentialBackwardGeneration)|(sbg)\")) {\n\t\tapplySequentialBackwardGeneration(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(ZeroWeightFilter)|(zwf)\")) {\n\t\tapplyZeroWeightFilter(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(RoughSetFeatureSelection)|(rsfs)\")) {\n\t\tapplyRoughSetFeatureSelection(cb, filenameRoot);\n\t    }\n\t}\n    }\n",
    "4573": "    protected void init(){\n\t//the message is (init teamname (version 8))\n        send(\"(init \" + this.m_teamname + \" (version 8))\");\n    }\n",
    "4574": "    private void execute() throws HibernateException {\n\n        log.trace(\"executing flush\");\n\n        try {\n            // we need to lock the collection caches before\n            // executing entity inserts/updates in order to\n            // account for bidi associations\n            beforeExecutionsAll(collectionRemovals);\n            beforeExecutionsAll(collectionUpdates);\n            beforeExecutionsAll(collectionCreations);\n\n            // now actually execute SQL and update the\n            // second-level cache\n            executeAll(insertions);\n            executeAll(updates);\n            executeAll(collectionRemovals);\n            executeAll(collectionUpdates);\n            executeAll(collectionCreations);\n            executeAll(deletions);\n        }\n        catch (HibernateException he) {\n            log.error(\"Could not synchronize database state with session\");\n            throw he;\n        }\n    }\n",
    "4575": "    public void Controling(ParsingEvent pe){\n\tif(m_lastInputs.getNumberSensoryItems()>0){\n\t    CaseEvent ce = new CaseEvent(this,m_lastInputs);\n\t    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);\n\t}\n    }\n",
    "4576": "    public void Sensing(ParsingEvent pe){\n\tif(m_teamName.equals(\"\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);\n\t}\n    }\n",
    "4577": "    private void send(String message){\n\tbyte[] buffer = new byte[RCSImitate.MSG_SIZE];\n\tbuffer = message.getBytes();\n\n\tDatagramPacket packet \n\t    = new DatagramPacket(buffer, buffer.length, this.m_serverhost, this.m_serverport);\n\n\ttry{\n\t    this.m_socket.send(packet);\n\t}catch(IOException e){\n\t    System.err.println(\"Socket sending error : \" + e);\n\t}\n    }\n",
    "4578": "    private void applyNoActionsFilter(CaseBase cb, StringBuilder filenameRoot) {\n\tSystem.out.println(\"[\" + getTime() + \"]: Applying No Actions Filter ...\");\n\tNoActionsFilter naf = new NoActionsFilter();\n\tcb.setCaseList(naf.filter(cb).getCaseList());\n\t\n\tfilenameRoot.append(\"-naf\");\n\t\n\tif (saveArtifacts) {\n\t    // Save the new case base\n\t    System.out.println(\"[\" + getTime() + \"]: Saving CaseBase to \" + filenameRoot.toString() + \".cb\");\n\t    try {\n\t\tCaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + \".cb\");\n\t    }\n\t    catch (IOException ioe) {\n\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving CaseBase after applying NoActionsFilter failed.\");\n\t    }\n\t}\n    }\n",
    "4579": "    private void setObjectPosition(RoboCupSimulation2DSpatialObject so,\n\t\t\t    ParsingEvent pe){//this sets the parameters that are common to all field objects\n\tif(pe.contains(\"dir_change\")) so.setDirectionChange(Float.parseFloat(pe.get(\"dir_change\")));\n\tif(pe.contains(\"dist_change\")) so.setDistanceChange(Float.parseFloat(pe.get(\"dist_change\")));\n\tif(pe.contains(\"direction\")) so.setDirection(Float.parseFloat(pe.get(\"direction\")));\n\tif(pe.contains(\"distance\")) so.setDistance(Float.parseFloat(pe.get(\"distance\")));\n    }\n",
    "4580": "    public void SeeReceived(ParsingEvent pe){\n\tif(m_lastInputs.getNumberSensoryItems()>0){\n\t    CaseEvent ce = new CaseEvent(this,m_actionList);\n\t    for(CaseEventListener cel:CEListeners) cel.GotActions(ce);\n\t}\n\tm_lastInputs = new AgentInputs();\n\tm_actionList = new ArrayList<AgentAction>();\n    }\n",
    "4581": "    private String receive() {\n\tbyte[] buffer = new byte[RCSImitate.MSG_SIZE];\n\tDatagramPacket packet = new DatagramPacket(buffer, RCSImitate.MSG_SIZE);\n\ttry{\n\t    this.m_socket.receive(packet);\n\t}catch(IOException e){\n\t    System.err.println(\"Socket receiving error : \" + e);\n\t}\n\treturn new String(buffer);\n    }\n",
    "4586": "    public void SeeParsed(ParsingEvent pe){\n\t    CaseEvent ce = new CaseEvent(this,m_lastInputs);\n\t    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);\n    }\n",
    "4588": "    public void Goal(ParsingEvent pe){\n\tGoalFeature gf = new GoalFeature();\n\tif(pe.contains(\"name\"))\n\t    gf.setSide(pe.get(\"name\"));\n\tsetObjectPosition(gf,pe);\n\tm_lastInputs.addSensoryItem(gf);\n    }\n",
    "4589": "    private void applyRoughSetFeatureSelection(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying RoughSetFeatureSelection\");\n\t\tweights = WeightAdjuster.featureSelect(WeightAdjuster.ROUGH_SET_FEATURE_SELECTION, cb);\n\t\t\n\t\tfilenameRoot.append(\"-rsfs\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save generated Weights object\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving generated Weights object to \" + filenameRoot.toString() + \".weights\");\n\t\t\ttry {\n\t\t\t\tWeightsIO.saveWeights(weights, filenameRoot.toString() + \".weights\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException iae) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving generated Weights failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4592": "    public void Ball(ParsingEvent pe){\n\tBallFeature bf = new BallFeature();\n\tsetObjectPosition(bf,pe);\n\tm_lastInputs.addSensoryItem(bf);\n    }\n",
    "4593": "    private void applySequentialBackwardGeneration(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying SequentialBackwardGeneration\");\n\t\tweights = WeightAdjuster.featureSelect(WeightAdjuster.SEQUENTIAL_BACKWARD_GENERATION, cb);\n\t\t\n\t\tfilenameRoot.append(\"-sbg\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save generated Weights object\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving generated Weights object to \" + filenameRoot.toString() + \".weights\");\n\t\t\ttry {\n\t\t\t\tWeightsIO.saveWeights(weights, filenameRoot.toString() + \".weights\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException iae) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving generated Weights failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4596": "    public void Flag(ParsingEvent pe){\n\tFlagFeature flag = new FlagFeature();\n\tString name=pe.get(\"name\");\n\tif(pe.contains(\"Box\")) flag.setBox(pe.get(\"Box\"));\n\tif(pe.contains(\"hp\")) \n\t    flag.setHorizontalPosition(pe.get(\"hp\"));\n\tif(pe.contains(\"vp\")) \n\t    flag.setVerticalPosition(pe.get(\"vp\"));\n\tif(pe.contains(\"flag_number\")){\n\t    flag.setFlagNumber(Integer.parseInt(pe.get(\"flag_number\")));\n\t    flag.setOutOfBounds(true);\n\t} else\n\t    flag.setOutOfBounds(false);\n\tsetObjectPosition(flag,pe);\n\tm_lastInputs.addSensoryItem(flag);\n    }\n",
    "4599": "\tprivate void applyZeroWeightFilter(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying Zero Weight Filter\");\n\t\tZeroWeightFilter zwf = new ZeroWeightFilter(weights);\n\t\tcb.setCaseList(zwf.filter(cb).getCaseList());\n\t\t\n\t\tfilenameRoot.append(\"-zwf\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save the new case base\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving CaseBase to \" + filenameRoot.toString() + \".cb\");\n\t\t\ttry {\n\t\t\t\tCaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + \".cb\");\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving CaseBase after applying ZeroWeightFilter failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4600": "    public void Line(ParsingEvent pe){\n\tLineFeature lf = new LineFeature();\n\tif(pe.contains(\"name\")) lf.setLocation(pe.get(\"name\"));\n\tsetObjectPosition(lf,pe);\n\tm_lastInputs.addSensoryItem(lf);\n    }\n",
    "4601": "    public void TimeOver(CaseEvent ce){\n\tthis.m_timeOver = true;\n\tthis.m_brain.setTimeOver(true);\n    }\n",
    "4604": "    public void Catch(ParsingEvent pe){\n\tCatchAction catchAct = new CatchAction();\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(catchAct);\n    }\n",
    "4605": "    private void setGlobalValues(Weights w) {\n        GlobalDistanceMeasure gd = new OrderIndexMatchingAlgorithm(w);\n\t\tCase.setGlobalDistanceCalculation(gd);\n\t\t\n\t\tSensoryItem.setDistanceCalculation(new EqualityDistanceAlgorithm());\n\t\tSensoryItem.setPenaltyDistanceCalculation(new ConstantPenalty(100));\n\t\tSpatial2DObject.setDistanceCalculation(new PolarDistanceAlgorithm());\n    }\n",
    "4609": "    public void Dash(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tDashAction dash = new DashAction(power);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(dash);\n    }\n",
    "4615": "    public void Kick(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tKickAction kick = new KickAction(power,angle);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(kick);\n    }\n",
    "4616": "    public void Catch(ParsingEvent pe){\n\tCatchAction catchAct = new CatchAction();\n\tm_actionList.add(catchAct);\n    }\n",
    "4620": "    public void Turn(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tTurnAction turn = new TurnAction(angle);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(turn);\n    }\n",
    "4621": "    public void Dash(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tDashAction dash = new DashAction(power);\n\tm_actionList.add(dash);\n    }\n",
    "4623": "    private void showResults() {\n        System.out.println(\"[\" + getTime() + \"]: Results:\\n\");\n        \n        System.out.println(getReportString());\n        \n        // Space out the output\n        System.out.println();\n    }\n",
    "4625": "    public void Kick(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tKickAction kick = new KickAction(power,angle);\n\tm_actionList.add(kick);\n    }\n",
    "4626": "    public void TurnNeck(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"neck_angle\"));\n\tTurnNeckAction turnNeck = new TurnNeckAction(angle);\n\t//m_actionList.add(turnNeck);\n    }\n",
    "4628": "    public void Turn(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tTurnAction turn = new TurnAction(angle);\n\tm_actionList.add(turn);\n    }\n",
    "4629": "    public void Hear(ParsingEvent pe){\n\tString who=pe.get(\"who\");\n\tString what=pe.get(\"what\");\n\tif(who.equals(\"referee\") && what.equals(\"time_over\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TimeOver(ce);\n\t}\t    \n    }\n",
    "4772": "\tpublic Case getCase(){\n\t\treturn this.m_case;\n\t}\n",
    "4773": "\tpublic AgentAction getAction(){\n\t\treturn this.m_action;\n\t}\n",
    "4776": "\tpublic AgentAction senseEnvironment(Case c) {\n\t\t//check the parameters\n\t\tif(c == null){\n\t\t\tthrow new IllegalArgumentException(\"Null Case given to senseEnvironment\");\n\t\t}\n\t\tAgentInputs av = c.getInputs();\n\t\t\n\t\tlong startTime = System.currentTimeMillis();\n\t\tAgentAction action = this.m_agent.senseEnvironment(av);\n\t\tlong endTime = System.currentTimeMillis();\n\t\t\n\t\tthis.m_totalTime += endTime - startTime;\n\t\tthis.m_numInputs ++;\n\t\t\n\t\treturn action;\n\t}\n",
    "4778": "\tpublic float getMeanExecutionTime(){\n\t\t//make sure we don't divide by zero\n\t\tif(this.m_numInputs == 0){\n\t\t\treturn 0.0f;\n\t\t}\n\t\treturn ((float)this.m_totalTime)/this.m_numInputs;\n\t}\n",
    "4785": "         public AgentAction copyThis(){\n\t     AgentAction newAgent = null;\n\t     \n\t     Class<? extends AgentAction> clazz = this.getClass();\n\t     \n\t     Constructor<? extends AgentAction> constructor;\n\t     \n\t     try {\n\t\t constructor = clazz.getConstructor(clazz);\n\t\t newAgent = constructor.newInstance(this);\n\t     }\n\t     catch (Exception e) {\n\t\t e.printStackTrace();\n\t\t System.exit(1);\n\t     }\n\t     \n\t     return newAgent;\n\t }\n",
    "4787": "\tpublic String getActionName(){\n\t\treturn this.m_name;\n\t}\n",
    "4788": "    public int getCasebaseSize(){\n    \treturn this.m_casebase.size();\n    }\n",
    "4789": "         public String toString(){\n\t     String result=super.toString()+\":\";\n\t     result+=Float.toString(this.m_distance)+\":\";\n\t     result+=Float.toString(this.m_direction);\n\t     return result;\n\t }\n",
    "4790": "        public String getAttrib(String attrib){\n\t    return \"\";\n\t}\n",
    "4793": "    public void addCase(Case ca){\n    \tif(ca == null){\n    \t\tthrow new IllegalArgumentException(\"Null Case added to CaseBase.\");\n    \t}\n\t\t\n    \tthis.m_casebase.add(ca);\n    }\n",
    "4794": "         public Spatial2DObject copyOfThis(){\n\t     Spatial2DObject copy=new Spatial2DObject(this.getFeatureName());\n\t     copy.setDistance(this.m_distance);\n\t     copy.setDirection(this.m_direction);\n\t     return copy;\n\t }\n",
    "4795": "        public String toString(){\n        \treturn m_name;\t\n        }\n",
    "4796": "    public void setCaseList(List<Case> cbList){\n    \t//check params\n    \tif(cbList == null){\n    \t\tthrow new IllegalArgumentException(\"Null paramater given to CaseBase constructor\");\n    \t}\n\t\t\n    \tthis.m_casebase = new ArrayList<Case>(cbList);\n    }\n",
    "4798": "\tpublic void setDistance(float dist){\n\t\tthis.m_distance = dist;\n\t}\n",
    "4800": "\tpublic void setValue(float value){\n\t\tthis.m_value = value;\n\t}\n",
    "4802": "\tpublic void setDirection(float dir){\n\t\tthis.m_direction = dir;\n\t}\n",
    "4803": "\tpublic float getValue(){\n\t\treturn this.m_value;\n\t}\n",
    "4806": "\tpublic AgentAction selectAction(List<Case> nearestNeighbours) {\n\t\t//check parameters\n\t\tif(nearestNeighbours == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to ClosestNeighbourSelection\");\n\t\t}\n\t\tif(nearestNeighbours.size() == 0){\n\t\t\tthrow new IllegalArgumentException(\"ClosestNeighbourSelection requires at least 1 Case to be given.\");\n\t\t}\n\t\t\n\t\t//get the first Case and its actions\n\t\tCase firstCase = nearestNeighbours.get(0);\n\t\tList<AgentAction> actions = firstCase.getActions();\n\t\t\n\t\treturn this.m_actionEst.estimateAction(actions);\n\t}\n",
    "4807": "\tpublic AgentAction estimateAction(List<AgentAction> possibilities) {\n\t\t//check parameters\n\t\tif(possibilities == null){\n\t\t\tthrow new IllegalArgumentException(\"Null list given to LastActionEstimate.\");\n\t\t}\n\t\t\n\t\t//if there are no associated actions, return null\n\t\tif(possibilities.size() == 0){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//return the last item\n\t\treturn possibilities.get(possibilities.size() -1);\n\t}\n",
    "4808": "\tpublic float getDistance(){\n\t\treturn this.m_distance;\n\t}\n",
    "4811": "\tpublic float calculatePenalty(SensoryItem feat) {\n\t\t//sanity check, even though we don't use it, we still don't want null\n\t\tif(feat == null){\n\t\t\tthrow new IllegalArgumentException(\"Null feature given to penalty function.\");\n\t\t}\n\t\t\n\t\treturn this.m_penalty;\n\t}\n",
    "4813": "\tpublic void setFilters(CaseFilter[] filters){\n\t\tfor(int ii=0;ii<filters.length;ii++){\n\t\t\tif(filters[ii] == null){\n\t\t\t\tthrow new IllegalArgumentException(\"Null CaseFilter given to agent.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.m_filters = filters;\n\t}\n",
    "4814": "\tpublic float getDirection(){\n\t\treturn this.m_direction;\n\t}\n",
    "4816": "\tpublic void setWeights(Weights newWeights){\n\t\tif(newWeights == null){\n\t\t\tthrow new IllegalArgumentException(\"Null weights given to GlobalDistanceMeasure\");\n\t\t}\n\t\tthis.m_featureWeights = newWeights;\n\t}\n",
    "4817": "\tpublic void setCaseBase(CaseBase cb){\n\t\tif(cb == null){\n\t\t\tthrow new IllegalArgumentException(\"Null CaseBase given to Agent.\");\n\t\t}\n\t\tif(cb.getCasebaseSize() == 0){\n\t\t\tthrow new IllegalArgumentException(\"Empty CaseBase given to Agent. At least one Case must be in CaseBase.\");\n\t\t}\n\t\t\n\t\tthis.m_caseBase = cb;\n\t\t\n\t}\n",
    "4819": "\tpublic Weights getWeights(){\n\t\treturn this.m_featureWeights;\n\t}\n",
    "4821": "\tprotected float weightedDistance(Map<String, Float> distances) {\n\t\tfloat totalDistance = 0.0f;\n\t\t\n\t\t//get a list of object types we have and go through each type\n\t\tList<String> objectTypes = new ArrayList<String>(distances.keySet());\n\t\tfor(String currentType : objectTypes){\n\t\t\tfloat rawDistance = distances.get(currentType);\n\t\t\t\t\n\t\t\t//apply the weight\n\t\t\tfloat currentWeight = this.m_featureWeights.getWeight(currentType);\n\t\t\ttotalDistance += rawDistance*currentWeight;\n\t\t}\n\t\t\n\t\treturn totalDistance;\n\t}\n",
    "4822": "\tpublic void setWeight(String itemName, float weight){\n\t\t//check parameters\n\t\tif(itemName == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given to Weights object.\");\n\t\t}\n\t\tif(weight < 0.0f || weight > 1.0f){\n\t\t\tthrow new IllegalArgumentException(\"The weights must be between 0.0 and 1.0 (inclusive)\");\n\t\t}\n\t\t\n\t\t//set the weight value\n\t\tthis.m_weights.put(itemName, new Float(weight));\n\t}\n",
    "4824": "\tpublic float getWeight(String itemName){\n\t\t//check parameters\n\t\tif(itemName == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given to Weights object.\");\n\t\t}\n\t\t\n\t\t//get the associated weight\n\t\tFloat weight = this.m_weights.get(itemName);\n\t\t\n\t\t//see if the weight has actually been set, otherwise use default\n\t\tif(weight == null){\n\t\t\treturn this.m_defaultWeight;\n\t\t}\n\t\treturn weight.floatValue();\n\t}\n",
    "4825": "    public void setSensoryItems(Hashtable<String,List<SensoryItem>> items){\n    \tthis.m_featuregroupTable=new Hashtable<String,List<SensoryItem>>(items);\n    }\n",
    "4826": "    public void setActions(List<AgentAction> actions){\n    \tthis.m_actions= new ArrayList<AgentAction>(actions);\n    }\n",
    "4831": "    public AgentInputs getInputs(){\n    \treturn this.m_inputs;\n    }\n",
    "4832": "\tpublic void setSampleSize(int sampleSize){\n\t\tif(sampleSize <= 0){\n\t\t\tthrow new IllegalArgumentException(\"Invalid sample size given to RandomUnderSample.setSampleSize(int)\");\n\t\t}\n\t\tthis.m_maxNum = sampleSize;\n\t}\n",
    "4834": "\tpublic int getSampleSize(){\n\t\treturn this.m_maxNum;\n\t}\n",
    "4836": "    public void setInputs(AgentInputs inputs){\n    \tthis.m_inputs=inputs;\n    }\n",
    "4837": "    public boolean doesContain(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list of that type of feature\n    \tList<SensoryItem> l = this.m_featuregroupTable.get(featureName);\n\t\t\n    \t//if there is no entry in the feature table the HashMap will\n    \t//have returned null\n    \tif(l == null || l.size() == 0){\n    \t\treturn false;\n    \t}\n    \treturn true;\n    }\n",
    "4842": "    public int getNumberSensoryItems(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list for that feature\n    \tList<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);\n    \t//if null then no features of that type exist\n    \tif(sensoryItemList == null){\n    \t\treturn 0;\n    \t}\n\t\treturn sensoryItemList.size();\n    }\n",
    "4844": "    public String toString(){\n    \tString output = \"Case : \";\n    \toutput += \"\\n\\tInputs : \";\n    \toutput += \"\\n\\t\\t\" + m_inputs.toString(m_inputs.getSensoryItemNames()); \n    \toutput += \"\\n\\tActions : \"; \n    \tfor(AgentAction a : m_actions){\n    \t\toutput += \"\\n\\t\\t\" + a.toString();\n    \t}  \t\n    \treturn output;\n    }\n",
    "4847": "    public int getNumberSensoryItems(){\n    \t//get the feature list for each type of feature\n    \tCollection<List<SensoryItem>> lists = this.m_featuregroupTable.values();\n\t\t\n    \tint featureCounter = 0;\n\t\t\n    \tfor(List<SensoryItem> currentList : lists){\n    \t\t//ignore null lists, these occur when we remove a feature list\n    \t\tif(currentList != null){\n    \t\t\tfeatureCounter += currentList.size();\n    \t\t}\n    \t}\n\t\t\n    \treturn featureCounter;\n    }\n",
    "4850": "\tprivate void resetLists(){\n\t\tthis.m_best = null;\n\t\tthis.m_evalBest = -1;\n\t\tthis.m_statsBest = null;\n\t\tthis.m_closed = new ArrayList<Weights>();\n\t\tthis.m_open = new ArrayList<Weights>();\n\t\tthis.m_evalOpen = new ArrayList<Float>();\n\t\tthis.m_statsOpen = new ArrayList<StatisticsBundle>();\n\t}\n",
    "4851": "    public void addMember(Case c) {\n\tif(c == null){\n\t    throw new IllegalArgumentException(\"Null Case given to Cluster.addMember(Case c)\");\n\t}\n\tthis.m_members.add(c);\n    }\n",
    "4853": "    public void removeSensoryItemType(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list for the specified feature\n    \tList<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);\n\t\t\n    \t//if it is null then the feature doesn't exist in the AgentVision\n    \tif(sensoryItemList != null){\n    \t\t//clear the list\n    \t\tsensoryItemList.clear();\n    \t\t//change the table entry to null  (meaning empty)\n    \t\tthis.m_featuregroupTable.remove(featureName);\n    \t}\n    }\n",
    "4855": "\tpublic String getID(){\n\t\treturn this.m_id;\n\t}\n",
    "4856": "\tprivate double calculateError(List<List<VectorPoint>> clusters, VectorPoint[] newCentroids) {\n\t\tdouble total = 0;\n\t\t\n\t\t//go through each cluster\n\t\tfor(int ii=0; ii<clusters.size(); ii++){\n\t\t\tList<VectorPoint> nextCluster = clusters.get(ii);\n\t\t\tVectorPoint centroid = newCentroids[ii];\n\t\t\t//go through each cluster member\n\t\t\tfor(int jj=0; jj<nextCluster.size(); jj++){\n\t\t\t\tVectorPoint item = nextCluster.get(jj);\n\t\t\t\ttotal += item.euclideanDistance(centroid);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn total;\n\t}\n",
    "4857": "\tpublic CaseBase filter(CaseBase initialCB) {\n\t\t//check parameters\n\t\tif(initialCB == null){\n\t\t\tthrow new IllegalArgumentException(\"Null CaseBase given to NoActionsFilter.\");\n\t\t}\n\t\t\n\t\tCaseBase newCB = new CaseBase();\n\t\t\n\t\t//go through each Case in the initial CaseBase\n\t\tList<Case> allCases = initialCB.getCaseList();\n\t\tfor(Case currentCase : allCases){\n\t\t\t//only add ones that have AgentActions\n\t\t\tif(currentCase.getActions().size() != 0){\n\t\t\t\tnewCB.addCase(currentCase);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newCB;\n\t}\n",
    "4860": "\tpublic CaseBase filter(CaseBase initialCB) {\n\t\t//check parameters\n\t\tif(initialCB == null){\n\t\t\tthrow new IllegalArgumentException(\"Null case base given to FeatureDistancePresort.\");\n\t\t}\n\t\t\n\t\t//Create the Case filter\n\t\tFeatureDistanceCasePresort fdcp = new FeatureDistanceCasePresort();\n\t\t\n\t\t//create the new CaseBase\n\t\tCaseBase sorted = new CaseBase();\n\t\t\n\t\t//go through each Case in the CaseBase\n\t\tList<Case> allCases = initialCB.getCaseList();\n\t\tfor(Case currentCase : allCases){\n\t\t\tCase filteredCase = fdcp.filter(currentCase);\n\t\t\tsorted.addCase(filteredCase);\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n",
    "4861": "        public void add(AgentAction decClass){\n            elements+=1;\n            if(!Dclass.equals(decClass)){\n                consistent = false;\n            }\n        }\n",
    "4864": "\tpublic double euclideanDistance(VectorPoint otherPoint){\n\t\t//test the params\n\t\tif(otherPoint == null){\n\t\t\tthrow new IllegalArgumentException(\"Null point given.\");\n\t\t}\n\t\tfloat[] otherData = otherPoint.getPoint();\n\t\tif(otherData.length != this.m_point.length){\n\t\t\tthrow new IllegalArgumentException(\"Euclidean distance cannot be calculated because vectors are of different lengths.\");\n\t\t}\n\t\t\n\t\tdouble distance = 0;\n\t\tfor(int ii=0; ii<this.m_point.length; ii++){\n\t\t\tdistance += (this.m_point[ii] - otherData[ii])*(this.m_point[ii] - otherData[ii]);\n\t\t}\n\t\t\n\t\tdistance = Math.sqrt(distance);\n\t\treturn distance;\n\t}\n",
    "4865": "\tprivate void sortByDistance(List<SensoryItem> sensoryItemList){\n\t\t\n\t\t//define a comparator for sorting a List of Features by distance\n\t\tComparator<SensoryItem> comp = new Comparator<SensoryItem>(){\n\t\t\t public int compare(SensoryItem f1, SensoryItem f2){\n\t\t\t\t \n\t\t\t\t Spatial2DObject sf1 = (Spatial2DObject)f1;\n\t\t\t\t Spatial2DObject sf2 = (Spatial2DObject)f2;\n\t\t\t\t \n\t\t\t\t float dist1 = sf1.getDistance();\n\t\t\t\t float dist2 = sf2.getDistance();\n\t\t\t\t \n\t\t\t\t if (dist1 == dist2){\n\t\t\t\t\t return 0;\n\t\t\t\t }else if(dist1 > dist2){\n\t\t\t\t\t return 1;\n\t\t\t\t }else{\n\t\t\t\t\t return -1;\n\t\t\t\t }\n\t\t\t }\n\t\t};\n\t\t\n\t\t//sort the List based on our comparator we defined\n\t\tCollections.sort(sensoryItemList, comp);\n\t}\n",
    "4868": "        public int getCount(){\n            if(consistent == true)\n                return elements;\n            return 0;\n        }\n",
    "4871": "\tprivate CaseBaseProtocol saveCaseProtocolBufferHelpper(CaseBase casebase){\n\t\tCaseBaseProtocol.Builder builder = CaseBaseProtocol.newBuilder();\n\n\t\tfor(Case c : casebase.getCaseList()){\n\t\t\tbuilder.addMCasebase(saveCaseHelper(c));\n\t\t}\n\n\t\treturn builder.build();\n\t}\n",
    "4872": "\tprivate CaseProtocol saveCaseHelper(Case cases){\n\t\tCaseProtocol.Builder caseBuilder = CaseProtocol.newBuilder();\n\n\t\tcaseBuilder.setMInputs(saveAgentInputsHelper(cases.getInputs()));\n\t\tfor(AgentAction a : cases.getActions()){\n\t\t\tcaseBuilder.addMActions(saveAgentActionHelper(a));\n\t\t}\n\t\treturn caseBuilder.build();\n\t}\n",
    "4873": "        public AgentAction getDclass(){\n            if(consistent == true)\n                return Dclass;\n            return null;\n        }\n",
    "4875": "\tprivate AgentInputsProtocol saveAgentInputsHelper(AgentInputs i){\n\t\tAgentInputsProtocol.Builder inputsBuilder = AgentInputsProtocol.newBuilder();\n\n\t\tfor(String s : i.getSensoryItemNames()){\n\t\t\tAgentInputsProtocol.FeatureGroupTable.Builder featureBuilder = AgentInputsProtocol.FeatureGroupTable.newBuilder();\n\t\t\tfeatureBuilder.setFeature(s);\n\t\t\tfor(SensoryItem si : i.getSensoryItems(s)){\n\t\t\t\tfeatureBuilder.addItem(saveSensoryItemHelper(si));\n\t\t\t}\n\t\t\tinputsBuilder.addMFeaturegroupTable(featureBuilder.build());\n\t\t}\n\t\treturn inputsBuilder.build();\n\t}\n",
    "4876": "\tpublic int getMaximum(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger max = m_max.get(item);\n\t\tif(max == null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn max.intValue();\n\t}\n",
    "4877": "\tprivate SensoryItemProtocol saveSensoryItemHelper(SensoryItem s){\n\t\tSensoryItemProtocol.Builder sensoryBuilder = SensoryItemProtocol.newBuilder();\n\t\tsensoryBuilder.setMFeatureName(s.getFeatureName());\n\t\treturn sensoryBuilder.build();\n\t}\n",
    "4879": "\tpublic int getMinimum(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger min = m_min.get(item);\n\t\tif(min == null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn min.intValue();\n\t}\n",
    "4880": "\tprivate AgentActionProtocol saveAgentActionHelper(AgentAction a){\n\t\tAgentActionProtocol.Builder actionBuilder = AgentActionProtocol.newBuilder();\n\n\t\tactionBuilder.setMName(a.getActionName());\n\t\treturn actionBuilder.build();\n\t}\n",
    "4881": "\tpublic float getMean(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger count = m_count.get(item);\n\t\tif(count == null || m_numCases == 0){\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (float)count/(float)m_numCases;\n\t}\n",
    "4882": "    public AgentInputs getAgentInputs(){\n\treturn aInputs;\n    }\n",
    "4885": "    public String getTeamName(){\n\treturn m_teamName;\n    }\n",
    "4886": "\tpublic String getFeatureName(){\n\t\treturn this.m_featureName;\n\t}\n",
    "4890": "        public SensoryItem copyOfThis(){\n\t    return new SensoryItem(this.getFeatureName());\n\t}\n",
    "4893": "       public String toString(){\n\t   return this.m_featureName;\n       }\n",
    "4894": "\tpublic float pairwiseDistance(SensoryItem f){\n\t\t//check the validity of parameters\n\t\tif(f == null){\n\t\t\tthrow new IllegalArgumentException(\"A null feature was given.\");\n\t\t}\n\t\t\n\t\t//make sure we have a distance calculation algorithm set\n\t\tif(SensoryItem.m_distanceCalculation == null){\n\t\t\tthrow new IllegalStateException(\"The distance calculation algorithm has not yet been set.\");\n\t\t}\n\t\t\n\t\t//if everything is fine, return the pairwise distance\n\t\treturn SensoryItem.m_distanceCalculation.pairwiseDistance(this, f);\n\t}\n",
    "4898": "\tpublic float penaltyDistance(){\n\t\n\t\t//make sure we have a penalty calculation algorithm set\n\t\tif(SensoryItem.m_penaltyCalculation == null){\n\t\t\tthrow new IllegalStateException(\"The penalty calculation algorithm has not yet been set.\");\n\t\t}\n\t\t\n\t\t//if everything is fine, return the pairwise distance\n\t\treturn SensoryItem.m_penaltyCalculation.calculatePenalty(this);\n\t}\n",
    "4899": "\tpublic String toXML(){\n\t\tString xml = \"\";\n\t\t\n\t\txml += \"<SensoryItem>\";\n\t\txml += \"<FeatureName>\";\n\t\txml += this.m_featureName;\n\t\txml += \"</FeatureName>\";\n\t\txml += \"</SensoryItem>\";\n\t\t\n\t\treturn xml;\n\t}\n",
    "5030": "\t@Test\n\tpublic void getClassificationAccuracy_manyTypesPerfect() throws Exception{\t\n\t\tMethod addPair = addPairHack();\n\t\t\n\t\t//simulate the pairings\n\t\taddPair.invoke(this.dummysw, \"oneAction\", \"oneAction\");\n\t\taddPair.invoke(this.dummysw, \"otherAction\", \"otherAction\");\n\t\taddPair.invoke(this.dummysw, \"otherAction\", \"otherAction\");\n\t\taddPair.invoke(this.dummysw, \"thirdAction\", \"thirdAction\");\n\t\taddPair.invoke(this.dummysw, \"thirdAction\", \"thirdAction\");\n\t\t\n\t\tassertEquals(this.dummysw.getClassificationAccuracy(), 1.0f);\n\t}\n",
    "5143": "    private void preFlushEntities() throws HibernateException {\n\n        List list = IdentityMap.concurrentEntries(entityEntries);\n        //safe from concurrent modification because of how entrySet() is implemented on IdentityMap\n        int size = list.size();\n        for ( int i=0; i<size; i++ ) {\n\n            Map.Entry me = (Map.Entry) list.get(i);\n            EntityEntry entry = (EntityEntry) me.getValue();\n            Status status = entry.status;\n\n            if ( status!=LOADING && status!=GONE && status!=DELETED ) {\n                Object object = me.getKey();\n                cascading++;\n                try {\n                    Cascades.cascade(this, entry.persister, object, Cascades.ACTION_SAVE_UPDATE, Cascades.CASCADE_ON_UPDATE);\n                }\n                finally {\n                    cascading--;\n                }\n            }\n        }\n\n    }\n",
    "5203": "\tprivate Method addPairHack() throws Exception{\n\t\t\n\t\tClass<StatisticsWrapper> c = StatisticsWrapper.class;\n\t\tMethod addPair = c.getDeclaredMethod(\"addPair\", new Class[]{String.class, String.class});\n\t\taddPair.setAccessible(true);\n\t\t\n\t\treturn addPair;\n\t}\n",
    "5380": "    public boolean contains(String paramName){\n\treturn line.contains(paramName);\n    }\n",
    "5419": "    private void parseOptions(String message, String params)\n    { //parse an initialization info\n\tparsed.setSensor(message);\n\tparsed.setParam(\"params\",params);\n\tparsed.setCycle(-1);\n\tParsingEvent pe=new ParsingEvent(this,parsed);\n\tfor(ParsingEventListener pel:PEListeners) pel.ServerParams(pe);\n    }\n",
    "5423": "    private void parseError(String message, String params)\n    { //parse an error\n\tparsed.setSensor(message);\n\tparsed.setParam(\"error\",params);\n\tparsed.setCycle(-2);\n\tParsingEvent pe=new ParsingEvent(this,parsed);\n\tfor(ParsingEventListener pel:PEListeners) pel.Error(pe);\n    }\n",
    "5521": "    private void preFlushCollections() throws HibernateException {\n\n        // Initialize dirty flags for arrays + collections with composite elements\n        // and reset reached, doupdate, etc.\n\n        List list = IdentityMap.entries(collectionEntries);\n        int size = list.size();\n        for ( int i=0; i<size; i++ ) {\n            Map.Entry e = (Map.Entry) list.get(i);\n           \t( (CollectionEntry) e.getValue() ).preFlush( (PersistentCollection) e.getKey() );\n        }\n    }\n",
    "5654": "    public void setPageSize(int pageSize){\n        this.pageSize = pageSize;\n        maxPage = rowCount / this.pageSize;\n        if (rowCount % pageSize > 0)\n            maxPage++;\n        currentPage = 0;\n            gotoPage(0);\n    }\n",
    "5658": "    public int getPageSize(){\n        return pageSize;\n    }\n",
    "5660": "    public void gotoPage(int pageNumber){\n        if ((pageNumber < 0)  || (pageNumber > maxPage))\n                throw new IndexOutOfBoundsException(\"Page number incorrect: got \"+pageNumber+ \"min 0, max \"+maxPage);\n        currentPage = pageNumber;\n        index = pageSize * currentPage;\n\n        length = ((rowCount - index) < pageSize) ? (rowCount - index): (pageSize);\n\n        fireTableStructureChanged();\n\n    }\n",
    "5665": "        public void setCheckValues(ArrayList<Map<K, V>> checkValues) {\n             this.checkValues.clear();\n             this.checkValues.addAll(checkValues);\n        }\n",
    "5666": "    public void gotoPrevPage(){\n        gotoPage(currentPage--);\n    }\n",
    "5668": "    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        if (isSelected){\n            setForeground(table.getSelectionForeground());\n            setBackground(table.getSelectionBackground());\n        }\n        else{\n            setForeground(table.getForeground());\n            setBackground(table.getBackground());\n        }\n        boolean selected = (Boolean)value; //\u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a \u0442\u0438\u043f\u0443 Boolean\n        setSelected(selected); //\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0432\u0438\u0434 \u0447\u0435\u043a\u0431\u043e\u043a\u0441\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n        return this;\n    }\n",
    "5669": "    public int getPageCount(){\n        return maxPage;\n    }\n",
    "5672": "    public int getPageNumber(){\n        return currentPage;\n    }\n",
    "5677": "    public void setData(String[][] data, String[] columnNames, int pageSize){\n        this.data = data;\n        this.columnNames = columnNames;\n        this.isEnabled = new boolean[columnNames.length];\n        colCount = data.length;\n        if (colCount > 0)\n            rowCount = data[0].length;\n        setPageSize(pageSize);\n\n    }\n",
    "5679": "    public void warning(SAXParseException e) throws SAXException {\n        String location = \"Warning at [ \"+e.getColumnNumber()+\",\"+e.getLineNumber()+\"]:\";\n        System.out.println(e.getMessage());\n    }\n",
    "5683": "        public int getColumnCount() {\n            return colCount;\n        }\n",
    "5693": "        private void changeFilterState(int columnIndex, boolean  state){\n            if (state) {  // if check is enabled\n                manager.updateData(columnIndex,data[columnIndex]); //update validator\n                for (int i = 0; i < rowCount; i++) //corrects values for cells in columns\n                    data[columnIndex][i] = manager.getValidValue(columnIndex,data[columnIndex][i]);\n                fireTableDataChanged();\n            }\n\n        }\n",
    "5697": "        public Object getValueAt(int rowIndex, int columnIndex) {\n            if (rowIndex == 0)\n                return isEnabled[columnIndex];\n            else {\n                rowIndex+=index;\n                if (isEnabled[columnIndex])\n                    return manager.getValidValue(columnIndex,data[columnIndex][rowIndex-1]);\n                return data[columnIndex][rowIndex-1];\n            }\n\n            }\n",
    "5700": "        public boolean addValidator(int columnIndex, Validator validator){\n            if ((columnIndex >= 0 ) && (columnIndex <= columnNames.length -1)) {\n                manager.addValidator(columnIndex,validator);\n                return true;\n            }\n\n            else return false;\n        }\n",
    "5708": "    public boolean addEditor(String columnName, Editor editor){\n        return addEditor(findColumn(columnName),editor);\n    }\n",
    "5709": "    public void resizeNumberPanel( int maxNumber){\n        int digitCount = 3;\n        while ((maxNumber = maxNumber/10) > 0)\n            digitCount++;\n        this.setMinimumDisplayDigits(digitCount);\n    }\n",
    "5710": "    public Validator getValidator(int columnIndex){\n        return manager.getValidator(columnIndex);\n    }\n",
    "5766": "    private DefaultMutableTreeNode copy(DefaultMutableTreeNode node) {\n        return new DefaultMutableTreeNode(node.getUserObject());\n    }\n",
    "5776": "    private void refreshData(){\n        try {\n            countLines();\n            readData();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        JTableHeader header = owner.getTableHeader();\n        owner.setTableHeader(new JTableHeader());\n        fireTableStructureChanged();\n        fireTableDataChanged();\n        owner.setTableHeader(header);\n\n    }\n",
    "5779": "    private void countLines() throws IOException {\n        fileLineCount = 0;\n        steamReader = new InputStreamReader(new FileInputStream(this.inputFile),this.charset);\n        BufferedReader dataReader = new BufferedReader(steamReader);\n        while ( dataReader.readLine() !=null)\n            fileLineCount++;\n        steamReader.close();\n        dataReader.close();\n    }\n",
    "5782": "     public void setSplitRegexp(String splitRegexp) {\n         this.splitRegexp = splitRegexp;\n         refreshData();\n     }\n",
    "5784": "    public String getSplitRegexp() {\n        return splitRegexp;\n    }\n",
    "5785": "    public int getRowCount() {\n        return map.size();\n    }\n",
    "5786": "    public int getRowCount() {\n        return fileLineCount - startLine;\n    }\n",
    "5787": "    public int getColumnCount() {\n        return 2;\n    }\n",
    "5788": "    public int getColumnCount() {\n         return fileColumnCount;\n    }\n",
    "5789": "    public Object getValueAt(int row, int column) {\n        Object[] entries=map.entrySet().toArray();\n        Map.Entry entry=(Map.Entry)entries[row];\n        if (column==0) {\n            return entry.getKey();\n        } else if (column==1) { // column==1\n            return entry.getValue();\n        } else {\n            throw new IndexOutOfBoundsException(Integer.toString(column));\n        }\n    }\n",
    "5792": "    public String getColumnName(int column) {\n        return columnNames[column];\n    }\n",
    "5794": "    public void setColumnNames(String keyName, String valueName) {\n        columnNames= new String[]{keyName, valueName};\n    }\n",
    "5796": "    public Map getMap() {\n        return map;\n    }\n",
    "5797": "    public char getMinChar() {\n        return minChar;\n    }\n",
    "5798": "    public int getLength() {\n        return length;\n    }\n",
    "5799": "    public void setMap(Map map) {\n        this.map = map;\n    }\n",
    "5805": "    public WizardModel getWizardModel() {\n        return wizard.getModel();\n    }\n",
    "5812": "    public void aboutToDisplayPanel() {\n\n    }\n",
    "5813": "    public void displayingPanel() {\n\n    }\n",
    "5815": "    public void aboutToHidePanel() {\n\n    }    \n",
    "5851": "    public JDialog getDialog() {\n        return wizardDialog;\n    }\n",
    "5859": "    public Component getOwner() {\n        return wizardDialog.getOwner();\n    }\n",
    "5861": "    public void setFormat(SimpleDateFormat format) {\n        this.format = format;\n    }\n",
    "5864": "    public void tableChanged(TableModelEvent e) {\n\n        makeSample();\n    }\n",
    "5865": "    public void setTitle(String s) {\n        wizardDialog.setTitle(s);\n    }\n",
    "5867": "    private void makeSample(){\n        panel.getFileBrowser().setText(\"\");\n        Map<String, String> fieldMap;\n        fieldMap = model.getMap();\n        String[] fields = fieldMap.values().toArray(new String[fieldMap.values().size()]); \n        builder.mapAttributes(columns, fields);\n        builder.makeSample(data[0],sampleWriter);\n        panel.getFileBrowser().setCaretPosition(0);\n    }\n",
    "5871": "    public String getTitle() {\n        return wizardDialog.getTitle();\n    }\n",
    "5875": "    private void  fillArrayLoop(Object[] source, Object[] dest){\n\n        if  (source.length >= dest.length)\n        System.arraycopy(source,0,dest,0,dest.length);\n        else {\n            System.arraycopy(source,0,dest,0,source.length);\n            int length = source.length;\n            int counter = 0;\n            while (length < dest.length) {\n                dest[length] = source[counter];\n                counter++;\n                length++;\n                if (counter == source.length)\n                    counter = 0;\n            }\n        }\n\n\n    }\n",
    "5877": "    public void setModal(boolean b) {\n        wizardDialog.setModal(b);\n    }\n",
    "5881": "    public void showButtons(String fileName){\n        if (FileValidate.canWrite(fileName))  {\n            getWizard().setNextFinishButtonEnabled(true);\n            Core appCore = Core.getInstance();\n            appCore.setOutputFile(new File(fileName));\n            appCore.setOutputWriter(writer);\n\n        }\n\n        else\n            getWizard().setNextFinishButtonEnabled(false);\n    }\n",
    "5884": "    public boolean isModal() {\n        return wizardDialog.isModal();\n    }\n",
    "5890": "    public int showModalDialog() {\n        \n     //   wizardDialog.setModalityType(Dialog.ModalityType.TOOLKIT_MODAL);\n        wizardDialog.pack();\n        wizardDialog.setModal(true);\n        wizardDialog.setVisible(true);\n        return returnCode;\n    }\n",
    "5897": "    public WizardModel getModel() {\n        return wizardModel;\n    }\n",
    "5898": "    public JTextField getFileNameField(){\n        return content.getFileNameField();\n    }\n",
    "5900": "    public JTextArea getFileBrowser(){\n        return content.getContentBrowser();\n    }\n",
    "5901": "    public JTable getContentTable(){\n        return content.getMapTable();\n    }\n",
    "5902": "    public JTextField getFileNameField() {\n        return fileNameField;\n    }\n",
    "5903": "    public XMLWriterGUI getContent(){\n        return content;\n    }\n",
    "5904": "    public JTextArea getContentBrowser() {\n        return contentBrowser;\n    }\n",
    "5907": "    public void registerWizardPanel(Object id, WizardPanelDescriptor panel) {\n        \n        //  Add the incoming panel to our JPanel display that is managed by\n        //  the CardLayout layout manager.\n        \n        cardPanel.add(panel.getPanelComponent(), id);\n        \n        //  Set a callback to the current wizard.\n        \n        panel.setWizard(this);\n        \n        //  Place a reference to it in the model. \n        \n        wizardModel.registerPanel(id, panel);\n        \n    }  \n",
    "5909": "    public void mapAttributes(String[] columnNames, String[] attributes) {\n        indexesMap.clear();\n        for (int i = 0; i < attributes.length; i++ ){\n            String name = this.attributes[i];\n            indexesMap.put(name,findIndex(attributes[i],columnNames));\n        }\n    }\n",
    "5913": "    public void setCurrentPanel(Object id) {\n\n        //  Get the hashtable reference to the panel that should\n        //  be displayed. If the identifier passed in is null, then close\n        //  the dialog.\n        \n        if (id == null)\n            close(ERROR_RETURN_CODE);\n        \n        WizardPanelDescriptor oldPanelDescriptor = wizardModel.getCurrentPanelDescriptor();\n        if (oldPanelDescriptor != null)\n            oldPanelDescriptor.aboutToHidePanel();\n        \n        wizardModel.setCurrentPanel(id);\n        wizardModel.getCurrentPanelDescriptor().aboutToDisplayPanel();\n        \n        //  Show the panel in the dialog.\n        \n        cardLayout.show(cardPanel, (String)id);\n        wizardModel.getCurrentPanelDescriptor().displayingPanel();        \n        \n        \n    }\n",
    "5914": "    public void reset(){\n        users.clear();\n    }\n",
    "5918": "    public void makeSample(String[] fields, Writer out){\n        UserList sampleList = new UserList();\n        List<UserList.User> sample = sampleList.getUser();\n        sample.add(createUser(fields));\n        JAXBElement<UserList> sampleElement = new JAXBElement<UserList>(name,UserList.class,null,sampleList);\n        JAXB.marshal(sampleElement,out);\n\n\n\n\n    }\n",
    "5921": "    public void openFile(String fileName) throws IOException {\n        output = new FileOutputStream(fileName,false);\n\n\n    }\n",
    "5922": "    public void close() throws IOException {\n        output.close();\n    }\n",
    "5923": "    public void writeData(MappingResult result) throws IOException {\n        builder.reset();\n        for (String[] row : result.getData()){\n            builder.addUser(row);\n        }\n            builder.writeData(output);\n    }\n",
    "5926": "    public int getReturnCode() {\n        return returnCode;\n    }\n",
    "5933": "    public boolean getBackButtonEnabled() {\n        return wizardModel.getBackButtonEnabled();\n    }\n",
    "5935": "    public void insertUpdate(DocumentEvent e) {\n        showButtons(fileNameField.getText());\n\n    }\n",
    "5936": "    public void removeUpdate(DocumentEvent e) {\n        showButtons(fileNameField.getText());\n\n    }\n",
    "5939": "    public void setBackButtonEnabled(boolean newValue) {\n        wizardModel.setBackButtonEnabled(newValue);\n    }\n",
    "5945": "    public boolean getNextFinishButtonEnabled() {\n        return wizardModel.getNextFinishButtonEnabled();\n    }\n",
    "5951": "    public void setNextFinishButtonEnabled(boolean newValue) {\n        wizardModel.setNextFinishButtonEnabled(newValue);\n    }\n",
    "5958": "    public boolean getCancelButtonEnabled() {\n        return wizardModel.getCancelButtonEnabled();\n    }\n",
    "5963": "    public void setCancelButtonEnabled(boolean newValue) {\n        wizardModel.setCancelButtonEnabled(newValue);\n    }\n",
    "5972": "    public void initDialog(MappingResult result){\n        String[] columns = result.getColumns();\n        String data[][] = result.getData();\n        Set<String> ouNames = new HashSet<String>();\n            for (String[] row : data){\n              OUNode node = new OUNode(columns,row);\n              String name = node.toString();\n              if (!ouNames.contains(name))  {\n                  root.add(new DefaultMutableTreeNode(node));\n                  ouNames.add(name);\n              }\n            }\n            availableFields.setModel(new DefaultComboBoxModel<String>(columns));\n    }\n",
    "5974": "    public void clearTree(){\n        OUNode rootNode = new OUNode(new String[]{\"ou\"},new String[]{\"Domain Controllers\"});\n        root = new DefaultMutableTreeNode(rootNode);\n    }\n",
    "5975": "    public void openFile(String fileName) throws IOException {\n        writer = new BufferedWriter(new FileWriter(fileName, false));\n    }\n",
    "5978": "    public void close() throws IOException {\n        writer.close();\n    }\n",
    "5980": "    public String generateScript(MappingResult result){\n        UserFactory factory = new UserFactory(\"dc=edo ,dc=chsu, dc=ru\",\n                Arrays.asList(\"cn\",\"sn\",\"userPrincipalName\",\n                        \"userAccountControl\",\"unicodePwd\", \"givenName\"));\n        factory.initFactory(result);\n        StringBuilder script = new StringBuilder();\n        for( String[] row : result.getData()){\n            try {\n\n                script.append(documentBuilder.createAddStatement(factory.createClass(row)));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return script.toString();\n    }\n",
    "5983": "    public void writeData(MappingResult result) throws IOException {\n       writer.write(generateScript(result));\n    }\n",
    "5984": "    public void initFactory(MappingResult result) {\n        this.columns = result.getColumns();\n        for (int i = 0; i < columns.length; i++){ //searches for dn-attributes\n            int index =Arrays.binarySearch(dnAttributes,columns[i]); \n            if (index > -1)\n                dnIndexes[index] = i; // stores found indexes\n        }\n        \n    }\n",
    "5988": "    private StringBuilder makeAttributeDescription(LDIFClass object){\n        StringBuilder builder = new StringBuilder();\n        for (String key : object.keySet()) {\n            String[] values = object.get(key);\n            for (String value : values){\n                builder.append(key);\n                builder.append(\":\");\n                builder.append(generateSafeString(value));\n                builder.append(SEP);\n            }\n        }\n        return builder;\n    }\n",
    "5989": "    public LDIFClass createClass(String[] data) {\n        LDIFClass result = new LDIFClass();\n        result.setDN(makeDN(data)); //make and store DN\n        result.put(\"objectclass\",\"user\"); //store object class\n\n        for (int i = 0; i < columns.length; i++ )  //for all attributes in row\n            if (attributeNames.contains(columns[i])) // if this attribute is an user attributes\n              result.put(columns[i],data[i]); //store it\n        return result;\n    }\n",
    "5991": "    public StringBuilder createAddStatement(LDIFClass object) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"dn:\");\n        builder.append(generateSafeString(object.getDN()));\n        builder.append(SEP);\n        builder.append(\"changetype:add\");\n\n        builder.append(SEP);\n        builder.append(makeAttributeDescription(object));\n        builder.append(SEP);\n        return builder;\n    }\n",
    "5992": "    public void setSheetName(String sheetName) {\n        this.sheetName = sheetName;\n    }\n",
    "5993": "    public void setSelectedColumns(int[] selectedColumns,String[] columnNames){\n        this.selectedColumns = selectedColumns;\n        this.columnNames = columnNames;\n    }\n",
    "6000": "    public void close() throws IOException {\n        try {\n            workbook.write();\n            workbook.close();\n        } catch (WriteException e) {\n            throw new IOException(e);\n        }\n    }\n",
    "6003": "    private void writeRow(String[] data) throws IOException {\n        int colCounter = 0;\n        for (int index : selectedColumns){// for all indexes of selectedColumns\n            try {       // write values to sheet as text label\n                sheet.addCell(new Label(colCounter,activeRow,data[index]));\n                colCounter++; //increase column number\n            } catch (WriteException e) {\n                throw new IOException(e);\n            }\n        }\n\n    }\n",
    "6005": "    public void writeData(MappingResult result) throws IOException {\n\n        activeRow = 0;\n        int colCounter = 0;\n        String columnNames[] = result.getColumns(); // getting column names\n        for ( int index : selectedColumns)\n            try {  //writing selected column names\n                sheet.addCell(new Label(colCounter,activeRow,columnNames[index]));\n                colCounter++;\n            } catch (WriteException e) {\n                throw new IOException(e.getMessage(),e);\n            }\n        activeRow++;\n        for (String[] row : result.getData()){//for all selected rows of mapping output\n            writeRow(row); //write the row to worksheet\n            activeRow++;\n        }\n\n\n    }\n",
    "6008": "    public XLSWriterGUI getContent(){\n        return content;\n    }\n",
    "6013": "    public Charset getCharset() {\n        return charset;\n    }\n",
    "6015": "     public void setCharset(Charset charset) {\n        this.charset = charset;\n    }\n",
    "6020": "     public int getStartLine() {\n        return startLine;\n    }\n",
    "6022": "    public void setStartLine(int startLine) {\n        if (startLine < 0)   //line number must be non-negative\n            this.startLine = 0;\n        else\n          this.startLine = startLine;\n    }\n",
    "6024": "    public void stateChanged(ChangeEvent e) {\n        refreshFileContent();\n    }\n",
    "6027": "    public void actionPerformed(ActionEvent e) {\n        refreshFileContent();\n    }\n",
    "6029": "    public void setSplitRegexp(String splitRegexp) {\n        this.splitRegexp = splitRegexp;\n    }\n",
    "6032": "    public void setColumns(String[] columns) {\n        this.columns = columns;\n    }\n",
    "6040": "    public void actionPerformed(ActionEvent e) {\n        readerPanel.getContent().updateSeparators();\n    }\n",
    "6043": "    private void gotoStartLine() throws FileNotFoundException, NoSuchElementException {\n        inputScanner = new Scanner(getFile(),charset.name());\n                int lineCount = startLine;\n        while (lineCount-- > 0)\n                inputScanner.nextLine();\n    }\n",
    "6050": "    public FileReaderGUI getReaderGUI() {\n        return readerGUI;\n    }\n",
    "6051": "    public FileSeparator getContent() {\n        return GUI;\n    }\n",
    "6052": "    public JSpinner getImportStringSpinner() {\n        return importStringSpinner;\n    }\n",
    "6053": "   public JTable getFiletable(){\n       return GUI.getFileTable();\n   }\n",
    "6055": "    public Charset getCharset(){\n        return (Charset) charsetComboBox.getSelectedItem();\n    }\n",
    "6057": "    public JTable getFileTable() {\n        return fileTable;\n    }\n",
    "6059": "    public File getFile() {\n        return file;\n    }\n",
    "6060": "    public void setCheckboxesActionListener(ActionListener a){\n        for (Component component : separators.getComponents()) {\n            if (component instanceof JCheckBox)\n            {\n                ((JCheckBox)component).addActionListener(a);\n            }\n        }\n    }\n",
    "6061": "    public void setFile(File file) {\n        this.file = file;\n    }\n",
    "6063": "    public void setPreviewModel(TableModel fileViewModel) {\n        fileTable.setModel(fileViewModel);\n    }\n",
    "6064": "    public void setWorkSheet(int sheetIndex){\n        if (sheetIndex < sheetCount) {\n            this.sheetIndex = sheetIndex;\n            worksheet = workbook.getSheet(sheetIndex);\n        }\n    }\n",
    "6065": "    public int getSheetIndex() {\n        return sheetIndex;\n    }\n",
    "6066": "    public JPanel getContentPane() {\n        return contentPane;\n    }\n",
    "6067": "    public String getSheetName(){\n        return workbook.getSheet(sheetIndex).getName();\n    }\n",
    "6068": "    public void updateSeparators(){\n        String result =\"\";\n        for (Component component : separators.getComponents()) { // determine what checkboxes are checked\n            boolean isSelected = (component instanceof JCheckBox) && ((JCheckBox)component).isSelected();\n            if (isSelected)\n                result += ((JCheckBox)component).getActionCommand(); //add corresponding regexp to result\n        }\n        if (result.length() > 0) //if some regexp is selected\n            result =\"[\"+result+\"]\"; // quote it\n        else\n            result =  \"/.?/\"; // otherwise use default value\n        FileViewModel model = (FileViewModel) fileTable.getModel();\n        model.setSplitRegexp(result);      //update model\n        ColumnPacker.packColumns(fileTable, 3);  //pack table\n    }\n",
    "6070": "    public int getSheetCount(){\n        return sheetCount;\n    }\n",
    "6071": "    public void setSelectedColumns(int[] selectedColumns, String[] columnNames) throws IndexOutOfBoundsException{\n        this.selectedColumns = selectedColumns;\n        int maxColumns = worksheet.getColumns();\n        for (int selectedColumn : selectedColumns) {\n            if ((selectedColumn < 0 ) || (selectedColumn >= maxColumns))\n                throw new IndexOutOfBoundsException(\"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \"+selectedColumn+ \" >= \"+maxColumns);\n        }\n        this.columnNames = columnNames;\n\n    }\n",
    "6076": "    public void setSelectedColumns() throws IndexOutOfBoundsException{\n        int maxColumns = worksheet.getColumns();\n        this.selectedColumns = new int[maxColumns];\n        this.columnNames = new String[selectedColumns.length];\n\n        for (int i = 0; i < selectedColumns.length; i++) {\n            selectedColumns[i] = i;\n            columnNames[i] = worksheet.getCell(i,0).getContents();\n        }\n    }\n",
    "6084": "    public JTable getContentTable() {\n        return contentTable;\n    }\n",
    "6086": "    public JLabel getSheetName() {\n        return sheetName;\n    }\n",
    "6088": "    public JSpinner getSheetSpinner() {\n        return sheetSpinner;\n    }\n",
    "6090": "    public XLSReaderGUI getContent(){\n        return content;\n    }\n",
    "6096": "    public void setSheet(int sheetNumber){\n        if (sheetNumber < sheetCount) { // check if number is valid\n            workSheet = workbook.getSheet(sheetNumber); // change actual worksheet\n            sheetIndex = sheetNumber;\n            fireTableStructureChanged(); // fire table change events\n            fireTableDataChanged();\n        }\n    }\n",
    "6099": "    public String getSheetName(){\n        return workSheet.getName();\n    }\n",
    "6106": "    public File getFile() {\n        return filename;\n    }\n",
    "6107": "    public void stateChanged(ChangeEvent e) {\n        JSpinner source = (JSpinner)e.getSource();\n        xlsModel.setSheet((Integer)source.getValue());  //update sheet\n        panel.getContent().getSheetName().setText(xlsModel.getSheetName()); //update name\n        JTableHeader header = new EditableTableHeader(contentTable.getColumnModel());\n        contentTable.setTableHeader(header); //set up the header\n        ColumnPacker.packColumns(contentTable, 3);\n    }\n",
    "6113": "    public int getRowCount() {\n        return workSheet.getRows()-1;\n    }\n",
    "6114": "    public void actionPerformed(ActionEvent e) {\n        refreshPageCounter();\n    }\n",
    "6115": "    public int getColumnCount() {\n        return workSheet.getColumns();\n    }\n",
    "6118": "    public Object getValueAt(int rowIndex, int columnIndex) {\n        return workSheet.getCell(columnIndex, rowIndex+1).getContents();//not displaying the header row\n    }\n",
    "6122": "    public void stateChanged(ChangeEvent e) {\n           int pageNumber = (Integer)recordSpinner.getValue() - 1; // get selected page number from event\n           model.gotoPage(pageNumber);// change model state\n    }\n",
    "6129": "    private void refreshPageCounter(){\n\n        int pageSize = panel.getContent().getRecordsPerPage();\n        model.setPageSize(pageSize);\n        int pageCount = model.getPageCount();\n        recordSpinner.setModel(new SpinnerNumberModel(1,1,pageCount,1));\n        panel.getContent().getAmount().setText(Integer.toString(pageCount));\n\n\n    }\n",
    "6135": "    private void reshapeData() {\n        String[][] newArray;\n        newArray = new String[linesCount][];\n        for (int i = 0; i < newArray.length; i++){\n            newArray[i] = new String[columns.length];\n            for (int j = 0; j < columns.length; j++)\n                newArray[i][j] = displayData[j][i];\n        }\n        displayData = newArray;\n    }\n",
    "6144": "    public MappingSettings getContent() {\n        return content;\n    }\n",
    "6154": "    private int findMapperIndex(Class mapperClass){\n        ListModel<MapperDecorator> model = pluginsList.getModel();\n        int length = model.getSize();\n        for (int i = 0;i < length; i++ ){\n            AttributeMapper current = model.getElementAt(i).getDelegate();\n            if (current.getClass().equals(mapperClass))\n                return i;\n\n        }\n        return -1;\n    }\n",
    "6158": "    public JLabel getAmount() {\n        return amount;\n    }\n",
    "6159": "    public Integer getRecordsPerPage() {\n        return Integer.parseInt((String)recordsPerPage.getSelectedItem());\n    }\n",
    "6161": "    public JComboBox getRecordsComboBox(){\n        return recordsPerPage;\n    }\n",
    "6163": "    public JSpinner getRecordSpinner() {\n        return recordSpinner;\n    }\n",
    "6165": "    public JTable getResultsTable() {\n        return resultsTable;\n    }\n",
    "6166": "            public void valueChanged(ListSelectionEvent e) {\n                //retrieve dialog window for selected plugin from manager\n                currentDialog = dialogManager.getDialog(pluginsList.getSelectedValue().getDelegate());\n                if (currentDialog==null) { //if dialog window is not found\n                    configPanel.removeAll();\n                    configPanel.add(defaultPanel); //display default panel\n                    configPanel.repaint();\n                }\n                else  {\n                     configPanel.removeAll();   //otherwise display dialog for mapper\n                     configPanel.add(currentDialog.getConfigPanel());\n                     configPanel.repaint();\n                }\n                pack();\n            }\n",
    "6168": "    private void createUIComponents() {\n\n        recordSpinner = new JSpinner();\n        resultsTable = new JTable();\n        resultsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n    }\n",
    "6170": "    public void setAvailableAttributes(Collection<AttributeBean>collection){\n        fieldList.removeAll();\n        DefaultListModel<String> model = (DefaultListModel<String>) fieldList.getModel();\n        for (AttributeBean bean : collection)\n            model.addElement(bean.getName());\n    }\n",
    "6173": "    private void showAddDialog(AttributeBean bean){\n        DefaultListModel<AttributeBean> model =\n                (DefaultListModel<AttributeBean>) availableAttributesList.getModel();\n       List<AttributeBean> list = Collections.list(model.elements());\n       model = (DefaultListModel<AttributeBean>) usedAttributesList.getModel();\n       list.addAll(Collections.list(model.elements()));\n\n         addDialog.setAvailableAttributes(list);\n         addDialog.setData(bean);\n\n         addDialog.pack();\n         addDialog.setVisible(true);\n         addDialog.getData(bean);\n\n    }\n",
    "6176": "    public AttributeMapper createPlugin(Class<? extends AttributeMapper> mapperClass) throws PluginConfigurationException {\n        boolean isFound = pluginsMap.values().contains(mapperClass);\n        if (!isFound)\n            throw new PluginConfigurationException(mapperClass) ;\n        AttributeMapper result;\n        try {\n            result = mapperClass.newInstance();//\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\n        } catch (InstantiationException e) {\n            throw new PluginConfigurationException(mapperClass);\n        } catch (IllegalAccessException e) {\n             throw new PluginConfigurationException(mapperClass);\n        }\n        return result;\n    }\n",
    "6181": "    public boolean contains(String value){\n        return value.equals(data) || parent != null && parent.contains(value);\n    }\n",
    "6183": "    private void createUIComponents() {\n        // TODO: place custom component creation code here\n        availableAttributesList = new JList<AttributeBean>();\n        usedAttributesList = new JList<AttributeBean>();\n\n        availableAttributesList.setModel(new DefaultListModel<AttributeBean>());\n        usedAttributesList.setModel(new DefaultListModel<AttributeBean>());\n        addDialog = new AddMapper();\n        addDialog.setModal(true);\n        addDialog.setLocation(this.getX(),this.getY());\n    }\n",
    "6184": "    public void addChild(String value)throws DependencyException {\n        if (!contains(value)){\n            childs.add(new DependencyTree(this,value));\n        } else throw new DependencyException(\"\u0426\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u0430 \"+value);\n\n    }\n",
    "6186": "    public void addChilds(String[] values) throws DependencyException {\n        for (String value : values) {\n            addChild(value);\n        }\n\n    }\n",
    "6191": "    private void isCyclicDependent(String attributeName, ru.chsu.mapper.dependence.DependencyTree parent)throws ru.chsu.mapper.dependence.DependencyException {\n            ru.chsu.mapper.dependence.DependencyTree tree = new ru.chsu.mapper.dependence.DependencyTree(parent,attributeName);\n            AttributeBean attributeBean = config.get(attributeName);\n            AttributeMapper plugin = attributeBean.getMapper();\n            if (plugin != null){\n                String[] dependencies = attributeBean.getMapper().getDependencies();\n                tree.addChilds(dependencies);\n                for (ru.chsu.mapper.dependence.DependencyTree child : tree.getChilds()) {\n                    isCyclicDependent(child.getData(), tree);\n                }\n            }\n    }\n",
    "6196": "    public void checkDependencies(Collection<String> attributes) throws ru.chsu.mapper.dependence.DependencyException {\n        for (String attribute : attributes) {\n            isCyclicDependent(attribute,null);\n        }\n    }\n",
    "6201": "    public void setInputAttributes(Map<String, String> inputAttributes) {\n        this.inputAttributes = inputAttributes;\n    }\n",
    "6212": "    private void configureMappers(String configFileName) throws DependencyException, PluginConfigurationException{\n        ConfigParser parser;\n        try {\n            parser = new ConfigParser(configFileName);\n        } catch (IOException e) {\n            throw new PluginConfigurationException(\"Error: configuration file cannot be read\");\n        } catch (ParserConfigurationException e) {\n            throw new PluginConfigurationException(\"Error: configuration file structure is invalid\");\n        }\n        try {\n            config = parser.loadAttributes();\n        } catch (PluginConfigurationException e) {\n            e.printStackTrace();\n\n        }\n        checkDependencies(config.keySet());\n    }\n",
    "6229": "    public void setMapper(String field, AttributeBean mapperBean){\n        config.put(field, mapperBean);\n    }\n",
    "6540": "    private void convertNonSerializableParams(Object[] params) {\n        // Happens when the method is parameter-less\n        if (params == null) {\n            return;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            params[i] = Naming.getParameterStubIfNeeded(params[i]);\n        }\n    }\n",
    "6650": "    private void addUninitializedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {\n        CollectionEntry ce = new CollectionEntry(persister, id, flushing);\n        collection.setCollectionSnapshot(ce);\n        addCollection(collection, ce, id);\n    }\n",
    "6717": "    private void addUninitializedDetachedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {\n        CollectionEntry ce = new CollectionEntry(persister, id);\n        collection.setCollectionSnapshot(ce);\n        addCollection(collection, ce, id);\n    }\n",
    "6852": "    public void addArrayHolder(ArrayHolder holder) {\n        //TODO:refactor + make this method private\n        arrayHolders.put( holder.getArray(), holder );\n    }\n",
    "6868": "\tpublic void dragDropEnd(DragSourceDropEvent e)\t{}\n",
    "7190": "\tpublic void keyReleased(KeyEvent e) {}\n",
    "7463": "    protected void finalize() throws Throwable {\n\n        log.debug(\"running Session.finalize()\");\n\n        if (isCurrentTransaction) log.warn(\"afterTransactionCompletion() was never called\");\n\n        if (connection!=null) { //ie it was never disconnected\n\n            //afterTransactionCompletion(false);\n\n            if ( connection.isClosed() ) {\n                log.warn(\"finalizing unclosed session with closed connection\");\n            }\n            else {\n                log.warn(\"unclosed connection, forgot to call close() on your session?\");\n                if (autoClose) connection.close();\n                //TODO: Should I also call closeStatements() from here?\n            }\n        }\n    }\n",
    "7571": "    private CollectionEntry getCollectionEntryOrNull(Object collection) {\n\n        PersistentCollection coll;\n        if (collection instanceof PersistentCollection) {\n            coll = (PersistentCollection) collection;\n            //if (collection==null) throw new TransientObjectException(\"Collection was not yet persistent\");\n        }\n        else {\n            coll = getArrayHolder(collection);\n            if (coll==null) {\n                //it might be an unwrapped collection reference!\n                //try to find a wrapper (slowish)\n                Iterator wrappers = IdentityMap.keyIterator(collectionEntries);\n                while ( wrappers.hasNext() ) {\n                    PersistentCollection pc = (PersistentCollection) wrappers.next();\n                    if ( pc.isWrapper(collection) ) {\n                        coll=pc;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return (coll==null) ? null : getCollectionEntry(coll);\n\n    }\n",
    "7828": "    public void evict(Object object) throws HibernateException {\n        if (object instanceof HibernateProxy) {\n            LazyInitializer li = HibernateProxyHelper.getLazyInitializer( (HibernateProxy) object );\n            Serializable id = li.getIdentifier();\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key(id, persister);\n            proxiesByKey.remove(key);\n            if ( !li.isUninitialized() ) {\n                Object entity = removeEntity(key);\n                if (entity!=null) {\n                    EntityEntry e = removeEntry(entity);\n                    doEvict(e.persister, entity);\n                }\n            }\n        }\n        else {\n            EntityEntry e = removeEntry(object);\n            if (e!=null) {\n                removeEntity( new Key(e.id, e.persister) );\n                doEvict(e.persister, object);\n            }\n        }\n    }\n",
    "7938": "    private void evictCachedCollections(ClassPersister persister, Serializable id) throws HibernateException {\n        evictCachedCollections( persister.getPropertyTypes(), id );\n    }\n",
    "12961": "\tpublic void ejbCreate() throws CreateException {\n\t\t// TODO Auto-generated method stub\n\t}\n",
    "29877": "    public void setCodeset(String codeset) {\n        this.codeset = codeset;\n    }\n",
    "29883": "    public String getCodeset() {\n        return codeset;\n    }\n",
    "29887": "    public XMLDocument addStylesheet(String href, String type) {\n        PI pi = new PI();\n        pi.setTarget(\"xml-stylesheet\")\n          .addInstruction(\"href\", href)\n          .addInstruction(\"type\", type);\n        prolog.addElement(pi);\n        \n        return(this);\n    }\n",
    "29892": "    public XMLDocument addStylesheet(String href) {\n        return addStylesheet(href, \"text/xsl\");\n    }\n",
    "29897": "    public XMLDocument addToProlog(ConcreteElement element) {\n        prolog.addElement(element);\n        return(this);\n    }\n",
    "29900": "    public XMLDocument addElement(XML element) {\n        if (content == null)\n            content = element;\n        else\n            content.addElement(element);\n            \n        return(this);\n    }\n",
    "29906": "    public void output(OutputStream out)\n    {        \n        /** \n         * FIXME: The other part of the version hack!\n         *   Add the version declaration to the beginning of the document.\n         */\n        try {\n            out.write(versionDecl.getBytes());\n        } catch (Exception e) { }\n        \n        for (int i=0; i<prolog.size(); i++) {\n            ConcreteElement e = (ConcreteElement)prolog.elementAt(i);\n            e.output(out);\n        }\n         \n        if (content != null)\n            content.output(out);\n    }\n",
    "29909": "    public PI addInstruction(String name, String value) {\n        addAttribute(name, value);\n        return(this);\n    }\n",
    "29916": "    public Object clone() {\n        return content.clone();\n    }\n",
    "29941": "    public String process(String to_process)\n    {   System.out.println(\"\\nString to Process in StringFilter = \"+to_process);\n        String[] value = split(to_process);\n        StringBuffer new_value = new StringBuffer();\n        for(int x = 0; x < value.length; x++)\n        {\n            if(hasAttribute(value[x]))\n                new_value.append((String)get(value[x]));\n            else\n                new_value.append(value[x]);\n            if(x != value.length - 1)\n                new_value.append(\" \");\n        }\n        return(new_value.toString());\n    }\n",
    "30502": "\tpublic CToggleButton () {\n\t\tthis(null, null, false);\n\t}\n",
    "30504": "\tpublic CToggleButton (String text) {\n\t\tthis(text, null, false);\n\t}\n",
    "30508": "\tpublic CToggleButton (String text, boolean selected) {\n\t\tthis(text, null, selected);\n\t}\n",
    "42686": "\tpublic MQuery (int AD_Table_ID)\n\t{\t//\tUse Client Context as r/o\n\t\tm_TableName = M_Table.getTableName (Env.getCtx(), AD_Table_ID);\n\t}\t//\tMQuery\n",
    "63167": "\n\tprotected String checkOptions()\t{ return null; }\n",
    "64598": "    public void initialize() {\n    }\n",
    "64614": "    public int getInitialFirstRowHeight() {\n    \treturn -1;\n    }\n",
    "64625": "    public void setFirstRowHeight(int value) {\n        setRowHeight(0, value);\n    }\n",
    "64630": "    public Object getContentAt(int col, int row) {\n        return doGetContentAt(col, row);\n    }\n",
    "64634": "    public String getTooltipAt(int col, int row) {\n        return doGetTooltipAt(col, row);\n    }\n",
    "64639": "    public String doGetTooltipAt(int col, int row) {\n        return null;\n    }\n",
    "64645": "    public KTableCellEditor getCellEditor(int col, int row) {\n        return doGetCellEditor(col, row);\n    }\n",
    "64662": "    public void setContentAt(int col, int row, Object value) {\n        doSetContentAt(col, row, value);\n        for (int i = 0; i < modelChangeListeners.size(); i++) {\n        \tModelChangeListener listener = (ModelChangeListener)modelChangeListeners.get(i);\n        \tlistener.modelChanged(col, row, value);\n        }\n    }\n",
    "64674": "    public boolean isFixedCell(int col, int row) {\n        return col < getFixedColumnCount()\n        || row < getFixedRowCount();\n    }\n",
    "64698": "\tprotected void onTraverse(TraverseEvent e) {\n\t    if (e.keyCode == SWT.ARROW_LEFT) {\n\t        if (m_Text.getCaretPosition()==0 && m_Text.getSelectionCount()==0)\n\t            super.onTraverse(e);\n\t        // handel the event within the text widget!\n\t    } else if (e.keyCode == SWT.ARROW_RIGHT) {\n\t        if (m_Text.getCaretPosition()==m_Text.getText().length() && m_Text.getSelectionCount()==0)\n\t            super.onTraverse(e);\n\t        // handle the event within the text widget!\n\t    } else\n\t        super.onTraverse(e);\n\t}\n",
    "64712": "    private boolean isValidHAlignment(int align) {\n        if (align==SWTX.ALIGN_HORIZONTAL_CENTER || \n            align==SWTX.ALIGN_HORIZONTAL_LEFT  || \n            align==SWTX.ALIGN_HORIZONTAL_RIGHT)\n            return true;\n        return false;\n    }\n",
    "64715": "    private boolean isValidVAlignment(int align) {\n        if (align==SWTX.ALIGN_VERTICAL_TOP || \n            align==SWTX.ALIGN_VERTICAL_CENTER  || \n            align==SWTX.ALIGN_VERTICAL_BOTTOM)\n            return true;\n        return false;\n    }\n",
    "64719": "\tpublic void close(boolean save) {\n\t\tsuper.close(save);\n\t\tm_Dialog = null;\n\t}\n",
    "64722": "    public Point belongsToCell(int col, int row) {\n        return doBelongsToCell(col, row);\n    }\n",
    "64723": "\tpublic void setBounds(Rectangle rect) {\n\t    // ignored.\n\t}\n",
    "64727": "    protected Control createControl() {\n        return null;\n    }\n",
    "64733": "    public Point doBelongsToCell(int col, int row) {\n        return new Point(col, row);\n    }\n",
    "64735": "\tpublic void open(KTable table, int col, int row, Rectangle rect) {\n\t\tm_Table = table;\n\t\tm_Model = table.getModel();\n\t\tm_Rect = rect;\n\t\tm_Row = row;\n\t\tm_Col = col;\n\t\t\n\t\tclose(true);\n\t\t\n\t\tGC gc = new GC(m_Table);\n\t\tm_Table.updateCell(m_Col, m_Row);\n\t\tgc.dispose();\n\t}\n",
    "64737": "\tpublic void close(boolean save) {\n\t    if (save) {\n\t        Object o = m_Model.getContentAt(m_Col, m_Row);\n\t        if (!(o instanceof Boolean))\n\t            throw new ClassCastException(\"CheckboxCellEditor needs a Boolean content!\");\n\t        \n\t        boolean newVal = !((Boolean)o).booleanValue();\n\t        \n\t        m_Model.setContentAt(m_Col, m_Row, new Boolean(newVal));\n\t    }\n\t    super.close(save);\n\t}\n",
    "64743": "    public void setContent(Object content) {\n    }\n",
    "64744": "    public int mapRowIndexToModel(int shownRow) {\n        return shownRow;\n    }\n",
    "64749": "    public void setColumnToCompare(int column) {\n        //if (row>=m_Model.getFixedRowCount())\n        //    throw new IllegalArgumentException(\"An invalid column index was given!\");\n        \n        m_ColIndex=column;\n    }\n",
    "64752": "    public int mapRowIndexToTable(int modelRow) {\n    \treturn modelRow;\n    }\n",
    "64754": "\tpublic void cellDoubleClicked(int col, int row, int statemask) {\n\t}\n",
    "64757": "\tpublic void fixedCellDoubleClicked(int col, int row, int statemask) {\n\t}\n",
    "64759": "    public void setSortDirection(int direction) {\n    \t if (direction!=SORT_UP && direction!=SORT_DOWN && direction!=SORT_NONE)\n             throw new IllegalArgumentException(\"Undefined sorting direction: \"+direction);\n         \n    \t m_Direction = direction;\n    }\n",
    "64763": "\tpublic void dispose() {\n\t\tif (m_Control != null) {\n\t\t\tControl contr = m_Control;\n\t\t\tm_Control = null;\n\t\t\tcontr.dispose();\n\t\t}\n\t}\n",
    "64768": "    public void setModel(KTableSortedModel model) {\n    \tm_Model = model;\n    }\n",
    "64775": "\tpublic void close(boolean save) {\n\t\tm_Table.m_CellEditor = null;\n\t\t//m_Control.setVisible(false);\n\t\tGC gc = new GC(m_Table);\n\t\tm_Table.drawCell(gc, m_Col, m_Row);\n\t\tgc.dispose();\n\t\tthis.dispose();\n\t\tm_Table.setFocus();\n\t}\n",
    "64776": "    public void sort(KTableSortComparator comparator) {\n        Collections.sort(rowMapping, comparator);\n        \n        m_Ordered = comparator.getSortDirection();\n        \n        if (m_Ordered==KTableSortComparator.SORT_NONE)\n            setSortColumn(-1);\n        else\n            setSortColumn(comparator.getColumnToSortOn());\n    }\n",
    "64777": "\tpublic boolean isFocused() {\n\t\tif (m_Control == null)\n\t\t\treturn false;\n\t\treturn m_Control.isFocusControl();\n\t}\n",
    "64780": "\tpublic void setBounds(Rectangle rect) {\n\t\tif (m_Control != null)\n\t\t\tm_Control.setBounds(rect);\n\t}\n",
    "64784": "    public void setStyle(int style) {\n        m_Style = style;\n    }\n",
    "64786": "    public Object getContentAt(int col, int row) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        return doGetContentAt(valid.x, valid.y);\n    }\n",
    "64789": "    public String getTooltipAt(int col, int row) {\n        row = mapRowIndexToModel(row);\n        Point valid = getValidCell(col, row);\n        return doGetTooltipAt(valid.x, valid.y);\n    }\n",
    "64794": "    public KTableCellEditor getCellEditor(int col, int row) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        return doGetCellEditor(valid.x, valid.y);\n    }\n",
    "64796": "    public void setContentAt(int col, int row, Object value) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        doSetContentAt(valid.x, valid.y, value);\n    }\n",
    "64800": "    public KTableCellRenderer getCellRenderer(int col, int row) {\n        row = mapRowIndexToModel(row);\n        Point valid = getValidCell(col, row);\n        return doGetCellRenderer(valid.x, valid.y);\n    }\n",
    "64803": "    public Point belongsToCell(int col, int row) {\n        if (getSortState() == KTableSortComparator.SORT_NONE)\n            return doBelongsToCell(col, row);\n        // if sorting is active, all cells get rendered seperately!\n        return new Point(col, row);\n    }\n",
    "64810": "    protected void drawCellButton(GC gc, Rectangle rect, String text, boolean pressed) {\n        rect.height += 1;\n        rect.width += 1;\n        gc.setForeground(Display.getCurrent().getSystemColor(\n                SWT.COLOR_LIST_FOREGROUND));\n        if (pressed) {\n            SWTX.drawButtonDown(gc, \n                    text, getAlignment(),\n                    null, getAlignment(), rect);\n        } else {\n            SWTX.drawButtonUp(gc, \n                    text, getAlignment(),\n                    null, getAlignment(), rect);\n        }\n    }\n",
    "64839": "    private Image mirrorImage(Image source) {\n        Rectangle bounds = source.getBounds();\n        \n        ImageData sourceData = source.getImageData();\n        ImageData resultData = new ImageData(\n                sourceData.height, sourceData.width, \n                sourceData.depth, sourceData.palette);\n        for (int x = 0; x<bounds.width; x++)\n            for (int y=0; y<bounds.height; y++)\n                resultData.setPixel(y, resultData.height-x-1, sourceData.getPixel(x, y));\n        source.dispose();\n        return new Image(Display.getCurrent(), resultData);        \n    }\n",
    "64840": "\tpublic void cellSelected(int col, int row, int statemask) {\n\t}\n",
    "64841": "\tpublic void fixedCellSelected(int col, int row, int statemask) {\n\t}\n",
    "64848": "    protected Rectangle drawDefaultSolidCellLine(GC gc, Rectangle rect, Color vBorderColor, Color hBorderColor) {\n        return BorderPainter.drawDefaultSolidCellLine(gc, rect, vBorderColor, hBorderColor);\n    }\n",
    "64860": "    public void setAlignment(int style) {\n        m_alignment = style;\n    }\n",
    "64885": "    public void setForeground(Color fgcolor) {\n        m_fgColor=fgcolor;\n    }\n",
    "64898": "    public void setDefaultForeground(Color fgcolor) {\n        COLOR_TEXT = fgcolor;\n    }\n",
    "64900": "    public Point doBelongsToCell(int col, int row) {\n        if ((col==2 || col==3)&& !isFixedCell(col, row)) {\n            int newRow = row;\n            if ((row-getFixedRowCount())%2==1)\n                newRow--;\n            return new Point(2, newRow);\n        }\n        return new Point(col,row);\n    }\n",
    "64907": "    public void setBackground(Color bgcolor) {\n        m_bgColor=bgcolor;\n    }\n",
    "64917": "    public void setDefaultBackground(Color bgcolor) {\n        COLOR_BACKGROUND = bgcolor;\n    }\n",
    "64943": "    public void setFont(Font font) {\n        m_font = font;\n    }\n",
    "64959": "    protected void applyFont(GC gc) {\n        m_GCfont = gc.getFont();\n        if (m_font == null)\n            m_font = Display.getCurrent().getSystemFont();\n        if ((m_Style & SWT.BOLD) != 0 || (m_Style & SWT.ITALIC)!=0) {\n            FontData[] fd = m_font.getFontData();\n            int style = SWT.NONE;\n            if ((m_Style & SWT.BOLD)!=0)\n                style |= SWT.BOLD;\n            if ((m_Style & SWT.ITALIC)!=0)\n                style |= SWT.ITALIC;\n            \n            for (int i=0; i<fd.length; i++)\n                fd[i].setStyle(style);\n            m_TMPfont = new Font(Display.getCurrent(), fd);\n            gc.setFont(m_TMPfont);\n        }  else\n            gc.setFont(m_font);\n    }\n",
    "64969": "    protected void resetFont(GC gc) {\n        if (m_TMPfont!=null) {\n            m_TMPfont.dispose();\n            m_TMPfont = null;\n        }\n            \n        gc.setFont(m_GCfont);\n    }\n",
    "64989": "\tpublic Vector getTasks() {\n\t\treturn tasks;\n\t}\n",
    "64991": "\tpublic void addTask() {\n\t\tExampleTask task = new ExampleTask(\"New task\");\n\t\ttasks.add(tasks.size(), task);\n\t\tIterator iterator = taskChangeListeners.iterator();\n\t\twhile (iterator.hasNext())\n\t\t\t((ITaskChangeListener) iterator.next()).taskAdded(task);\n\t}\n",
    "65013": "\tpublic void setCompleted(boolean b) {\n\t\tcompleted = b;\n\t}\n",
    "65014": "\tpublic void setDescription(String string) {\n\t\tdescription = string;\n\t}\n",
    "65017": "\tpublic void setOwner(String string) {\n\t\towner = string;\n\t}\n",
    "65018": "\tpublic void setPercentComplete(int i) {\n\t\tpercentComplete = i;\n\t}\n",
    "65052": "\tprivate void createSashForm() {\n\t\tGridData gridData = new org.eclipse.swt.layout.GridData();\n\t\tgridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData.grabExcessHorizontalSpace = true;\n\t\tgridData.grabExcessVerticalSpace = true;\n\t\tgridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tsashForm = new SashForm(top, SWT.NONE);\n\t\tsashForm.setOrientation(org.eclipse.swt.SWT.VERTICAL);\n\t\tsashForm.setLayoutData(gridData);\n\t\tcreateTopComposite();\n\t\tcreateBottomComposite();\n\t}\n",
    "65053": "\tprivate TrifonTextModelExample getTrifonTextModelExample() {\n\t\tif (trifonTextModelExample == null) {\n\t\t\ttrifonTextModelExample = new TrifonTextModelExample();\n\t\t}\n\t\treturn trifonTextModelExample;\n\t}\n",
    "65055": "\tprivate void createTopComposite() {\n\t\ttopComposite = new Composite(sashForm, SWT.NONE);\n\t\ttopComposite.setLayout(new GridLayout());\n\t\tcreateKTable();\n\t}\n",
    "65057": "\tprivate void createBottomComposite() {\n\t\tbottomComposite = new Composite(sashForm, SWT.NONE);\n\t}\n",
    "65059": "\tprivate void createComposite() {\n\t\tcomposite = new Composite(tabFolder, SWT.NONE);\n\t\tbuttonOne = new Button(composite, SWT.NONE);\n\t\tbuttonOne.setBounds(new org.eclipse.swt.graphics.Rectangle(5,5,12,23));\n\t\tbuttonOne.setText(\"Button One\");\n\t}\n",
    "65060": "\tprivate void createKTable() {\n\t\tGridData gridData1 = new org.eclipse.swt.layout.GridData();\n\t\tgridData1.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData1.grabExcessHorizontalSpace = true;\n\t\tgridData1.grabExcessVerticalSpace = true;\n\t\tgridData1.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tkTable = new KTable(topComposite, SWT.NONE);\n\t\tkTable.setLayoutData(gridData1);\n\t\t\n\t\tkTable.setModel(model);\n\t}\n",
    "65063": "\tprivate void createComposite1() {\n\t\tcompositeTwo = new Composite(tabFolder, SWT.NONE);\n\t\tcreateKTable();\n\t}\n",
    "65066": "\tprivate void createKTable() {\n\t\tkTable = new KTable(compositeTwo, SWT.V_SCROLL | SWT.H_SCROLL \n\t\t\t\t| SWTX.FILL_WITH_LASTCOL\n\t\t\t\t| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important\n\n\t\tkTable.setModel(getTrifonTextModelExample());\n\t\tkTable.setBounds(new org.eclipse.swt.graphics.Rectangle(115,15,77,23));\n\t\t\n\t}\n",
    "65070": "\tprivate void createBottomCTabFolder() {\n\t\tbottomTabFolder = new TabFolder(sashForm, SWT.NONE);\n\t\t\n\t\ttabItemOne = new TabItem(bottomTabFolder, SWT.NONE);\n\t\ttabItemOne.setText(\"Text Table\");\n\t\t\n\t\tComposite comp1 = new Composite(bottomTabFolder, SWT.NONE);\n\t\ttabItemOne.setControl(comp1);\n\t\tcomp1.setLayout(new FillLayout());\n\t\ttabOneKTable = new KTable(comp1, SWT.V_SCROLL | SWT.H_SCROLL \n\t\t\t\t| SWTX.FILL_WITH_LASTCOL\n\t\t\t\t| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important\n\t\t\n\t}\n",
    "65108": "\tpublic boolean isSurveyant() {\n\t\treturn this.level == OutlawUser.LEVEL_NOBODY;\n\t}\n",
    "65110": "\tpublic Condition getPostCondition() {\n\t\treturn this.postCondition;\n\t}\n",
    "65112": "\tpublic void setContent(List<PersistentObject> list) {\n\t\tthis.content = list;\n\t}\n",
    "65113": "\tprivate void createTabFolder() {\n\t\tGridData gridData = new org.eclipse.swt.layout.GridData();\n\t\tgridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData.grabExcessHorizontalSpace = true;\n\t\tgridData.grabExcessVerticalSpace = true;\n\t\tgridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\ttabFolder = new TabFolder(top, SWT.NONE);\n\t\ttabFolder.setLayoutData(gridData);\n\t}\n",
    "65115": "\tpublic String getFilename() {\n\t\treturn this.filename;\n\t}\n",
    "65117": "\tpublic void setFilename(final String string) {\n\t\tthis.filename = string;\n\t}\n",
    "65118": "\tpublic void setImage(byte[] data) {\n\t\tthis.data = data;\n\t}\n",
    "65119": "\tpublic boolean isUser() {\n\t\treturn this.level == OutlawUser.LEVEL_USER;\n\t}\n",
    "65128": "\tpublic boolean isAdmin() {\n\t\treturn this.level == OutlawUser.LEVEL_ADMIN;\n\t}\n",
    "65132": "\tpublic String getText() {\n\t\treturn this.text;\n\t}\n",
    "65135": "\tpublic int getLayout() {\n\t\treturn this.layout;\n\t}\n",
    "65138": "\tpublic void setText(final String string) {\n\t\tthis.text = string;\n\t}\n",
    "65141": "\tpublic void setLayout(final int theLayout) {\n\t\tthis.layout = theLayout;\n\t}\n",
    "65144": "\tpublic String getTextPreview() {\n\t\tString retVal;\n\n\t\tif (this.text.length() > 120) {\n\t\t\tretVal = this.text.substring(0, 60);\n\t\t\tretVal += \"...\";\n\t\t\tretVal += this.text.substring(this.text.length() - 60 - 1, this.text.length() - 1);\n\t\t} else {\n\t\t\tretVal = this.text;\n\t\t}\n\n\t\treturn retVal;\n\t}\n",
    "65147": "\tpublic Date getCdate() {\n\t\treturn this.cdate;\n\t}\n",
    "65150": "\tpublic Date getEdate() {\n\t\treturn this.edate;\n\t}\n",
    "65151": "\tpublic Date getSdate() {\n\t\treturn this.sdate;\n\t}\n",
    "65155": "\tpublic int getState() {\n\t\treturn this.state;\n\t}\n",
    "65158": "\tpublic Survey getSurvey() {\n\t\treturn this.survey;\n\t}\n",
    "65162": "\tpublic void setCdate(final Date date) {\n\t\tthis.cdate = date;\n\t}\n",
    "65165": "\tpublic void setEdate(final Date date) {\n\t\tthis.edate = date;\n\t}\n",
    "65168": "\tpublic void setSdate(final Date date) {\n\t\tthis.sdate = date;\n\t}\n",
    "65171": "\tpublic void setState(final int theState) {\n\t\tthis.state = theState;\n\t}\n",
    "65175": "\tpublic void setSurvey(final Survey theSurvey) {\n\t\tthis.survey = theSurvey;\n\t}\n",
    "65212": "\tpublic int getQuestionLayout() {\n\t\treturn this.questionLayout;\n\t}\n",
    "65220": "\tpublic int getAnswerLayout() {\n\t\treturn this.answerLayout;\n\t}\n",
    "65353": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalGroupPrincipal))\n            return false;\n\n        InternalGroupPrincipal r = (InternalGroupPrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65370": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalRolePrincipal))\n            return false;\n\n        InternalRolePrincipal r = (InternalRolePrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65394": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalUserPrincipal))\n            return false;\n\n        InternalUserPrincipal r = (InternalUserPrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65424": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalCredential))\n            return false;\n\n        InternalCredential c = (InternalCredential) object;\n        boolean isEqual = ((c.getValue().equals(this.getValue())) && (c.getType() == this.getType()) && ((null == c.getClassname()) || (c.getClassname().equals(this.getClassname()))));\n        return isEqual;\n    }\n",
    "65427": "    public String getSystemRoot()\n    {        \n        return \"/\";\n    }\n",
    "65555": "    public List retrieveOptions(Object command, Object context) {\n        if (getRefreshPropertyAsBoolean(command)) {\n            return chainedOption.retrieveOptions(command, context);\n        } else {\n            return new LinkedList();\n        }\n    }\n",
    "65556": "    protected LabelValueBean convertBean(Object object) {\n        String string = (String) object;\n        return new LabelValueBean(string, string);\n    }\n",
    "65558": "    public List adjustAndSort(List options, Object context) {\n        return options;\n    }\n",
    "65559": "    public void updateValue(Object command, List options, Object context) {\n        if (getRefreshPropertyAsBoolean(command)) {\n            chainedOption.updateValue(command, options, context);\n        }\n    }\n",
    "65561": "    public String getDefaultValue(List options, Object context) {\n        if (options.size() > 0) {\n            LabelValueBean bean = (LabelValueBean) options.get(0);\n            return bean.getValue();\n        } else {\n            return \"\";\n        }\n    }\n",
    "65569": "    public void setExtraItems(List extraItems) {\n        this.extraItems = extraItems;\n    }\n",
    "65570": "    public String getOptionsKey() {\n        return chainedOption.getOptionsKey();\n    }\n",
    "65574": "    public void setChainedOption(ChainedOption chainedOption) {\n        this.chainedOption = chainedOption;\n    }\n",
    "65581": "    public void setRefreshProperty(String refreshProperty) {\n        this.refreshProperty = refreshProperty;\n    }\n",
    "65582": "    public void setOptions(List options) {\n        this.options = options;\n    }\n",
    "65584": "    public List adjustAndSort(List options, Object context) {\n        LinkedList result = new LinkedList();\n        result.addAll(options);\n        Collections.sort(result);\n        return result;\n    }\n",
    "65588": "    public List convert(List beans) {\n        List retval = new ArrayList(beans.size());\n        for (Iterator iter = beans.iterator(); iter.hasNext();) {\n            LabelValueBean bean = convertBean(iter.next());\n            retval.add(bean);\n        }\n\n        return retval;\n    }\n",
    "65589": "    public void referenceData(Map model, Object command, Object context) {\n        for (Iterator iter = chainedOptions.iterator(); iter.hasNext();) {\n            ChainedOption chainedOption = (ChainedOption) iter.next();\n            List options = chainedOption.retrieveOptions(command, context);\n            model.put(chainedOption.getOptionsKey(), options);\n            chainedOption.updateValue(command, options, context);\n        }\n    }\n",
    "65590": "    public ChainedOptionStrategy getStrategy(Object command) {\n        return chainedOption.getStrategy(command);\n    }\n",
    "65600": "    public void updateValue(Object command, List options, Object context) {\n        String selectedValue = getProperty(command, getCommandProperty());\n\n        for (Iterator iter = options.iterator(); iter.hasNext();) {\n            if (matches((LabelValueBean) iter.next(), selectedValue)) {\n                return;\n            }\n        }\n\n        setProperty(command, getCommandProperty(), getStrategy(command)\n                .getDefaultValue(options, context));\n    }\n",
    "65607": "    protected boolean matches(LabelValueBean bean, String value) {\n        if (value == null) {\n            return false;\n        }\n        String beanValue = ((LabelValueBean) bean).getValue();\n        return StringUtils.equals(beanValue, value);\n    }\n",
    "65615": "    protected void initChainedOption() {\n    }\n",
    "65625": "    protected void setProperty(Object bean, String propertyName, Object value) {\n        BeanWrapper commandWrapper = new BeanWrapperImpl(bean);\n        commandWrapper.setPropertyValue(new PropertyValue(propertyName, value));\n    }\n",
    "65640": "    public void setCommandProperty(String commandProperty) {\n        this.commandProperty = commandProperty;\n    }\n",
    "65653": "    public void setOptionsKey(String optionsKey) {\n        this.optionsKey = optionsKey;\n    }\n",
    "65665": "    public void setConverter(BeanConverter converter) {\n        this.converter = converter;\n    }\n",
    "65667": "    public void testUpdateValue_valueExists() {\n        SomeCommand someCommand = new SomeCommand();\n        someCommand.setRegion(\"EU\");\n\n        final LabelValueBean expected = new LabelValueBean(\"a\", \"b\");\n        AbstractChainedOption tested = new AbstractChainedOption() {\n\n            public List retrieveOptions(Object command, Object context) {\n                return null;\n            }\n\n            protected boolean matches(LabelValueBean bean, String value) {\n                assertSame(expected, bean);\n                return true;\n            }\n\n            public ChainedOptionStrategy getStrategy(Object command) {\n                return strategyMock;\n            }\n        };\n\n        tested.setCommandProperty(\"region\");\n\n        tested.updateValue(someCommand, Collections.singletonList(expected),\n                null);\n\n        assertEquals(\"EU\", someCommand.getRegion());\n    }\n",
    "65674": "    public ChainedOptionStrategy getStrategy(Object command) {\n        return defaultStrategy;\n    }\n",
    "65683": "    public void setDefaultStrategy(ChainedOptionStrategy defaultStrategy) {\n        this.defaultStrategy = defaultStrategy;\n    }\n",
    "65802": "    @Override protected void startup() {\n        show(new VisualJBusinessView(this));\n    }\n",
    "65803": "    @Override protected void configureWindow(java.awt.Window root) {\n    }\n",
    "65809": "    public Database getDatabase() {\n        return this.database;\n    }\n",
    "65811": "    public void setDatabase(Database database) {\n        this.database = database;\n    }\n",
    "65812": "     public Table getChoosenTableByName(String name) {\n        Table table = null, target = null;\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(name)) {\n                return target;\n            }\n        }\n        return table;\n    }\n",
    "65813": "     public Table getChoosenTableHlsHead(Table table) {\n        Table target = null;\n        if (table.getHlsHead().equals(\"\")) {\n            // there is no head\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(table.getHlsHead())) {\n                // head found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65815": "    public Table getChoosenTableHlsLines(Table table) {\n        Table target = null;\n        if (table.getHlsLines().equals(\"\")) {\n            // there is no lines\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(table.getHlsLines())) {\n                // lines found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65817": "    public Table getColumnFkTable(Column column) {\n        Table target = null;\n        if (column.getFkTable().equals(\"\")) {\n            // there is no fkTable\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(column.getFkTable())) {\n                // fkTable found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65844": "    public String getSecurityPath() {\n        return securityPath;\n    }\n",
    "65845": "    public void setSecurityPath(String securityPath) {\n        securityPath = securityPath.toLowerCase().trim();\n        if(!securityPath.equals(\"\")) {\n            //securityPath.replaceAll(\"\\\\\", \"/\");\n            securityPath.replaceAll(\".\", \"/\");\n            securityPath.replaceAll(\" \", \"\");\n            if(securityPath.startsWith(\"/\")) {\n                securityPath = securityPath.substring(1);\n            }\n            if(!securityPath.endsWith(\"/\")) {\n                securityPath = securityPath + \"/\";\n            }\n        }\n        this.securityPath = securityPath;\n    }\n",
    "65874": "    protected Rectangle getCellRectIgnoreSpan(int col, int row) {\n        return getCellRectIgnoreSpan(col, row, getColumnLeft(col) + 1);\n    }\n",
    "65967": "    public String getTableName() {\n        return tableName;\n    }\n",
    "65968": "    public MenuVJB getMenuVJB() {\n        return menuVJB;\n    }\n",
    "65969": "    public void setTableName(String tableName) {\n        this.tableName = tableName;\n    }\n",
    "65970": "    public void setMenuVJB(MenuVJB menuVJB) {\n        this.menuVJB = menuVJB;\n    }\n",
    "65975": "    public String getTitleOfMenuOfItemsVJB() {\n        return titleOfMenuOfItemsVJB;\n    }\n",
    "65977": "    public void setTitleOfMenuOfItemsVJB(String titleOfMenuOfItemsVJB) {\n        this.titleOfMenuOfItemsVJB = titleOfMenuOfItemsVJB;\n    }\n",
    "65978": "    public boolean isMenuOfItemsSetted() {\n        return menuOfItemsSetted;\n    }\n",
    "65980": "    public void setMenuOfItemsSetted(boolean menuOfItemsSetted) {\n        this.menuOfItemsSetted = menuOfItemsSetted;\n    }\n",
    "65981": "    public MenuBarVJB getMenuBarVJB() {\n        return menuBarVJB;\n    }\n",
    "65983": "    public void setMenuBarVJB(MenuBarVJB menuBarVJB) {\n        this.menuBarVJB = menuBarVJB;\n    }\n",
    "65987": "    public boolean isAddNewMenuBar() {\n        return addNewMenuBar;\n    }\n",
    "65990": "    public void setAddNewMenuBar(boolean addNewMenuBar) {\n        this.addNewMenuBar = addNewMenuBar;\n    }\n",
    "66004": "    public Table getSelectedTable() {\n        return selectedTable;\n    }\n",
    "66005": "    public MenuOfBarVJB getMenuOfBarVJB() {\n        return menuOfBarVJB;\n    }\n",
    "66006": "    public void setSelectedTable(Table selectedTable) {\n        this.selectedTable = selectedTable;\n    }\n",
    "66007": "    public void setMenuOfBarVJB(MenuOfBarVJB menuOfBarVJB) {\n        this.menuOfBarVJB = menuOfBarVJB;\n    }\n",
    "66008": "    public boolean isTargetClassSelected() {\n        return targetClassSelected;\n    }\n",
    "66010": "    public void setTargetClassSelected(boolean targetClassSelected) {\n        this.targetClassSelected = targetClassSelected;\n    }\n",
    "66022": "    public String getMenuTitle() {\n        return menuTitle;\n    }\n",
    "66026": "    public void setMenuTitle(String menuTitle) {\n        this.menuTitle = menuTitle;\n    }\n",
    "66028": "    public int getMenuVJBType() {\n        return menuVJBType;\n    }\n",
    "66030": "    public void setMenuVJBType(int menuVJBType) {\n        this.menuVJBType = menuVJBType;\n    }\n",
    "66031": "    public boolean isCreateNewMenuBar() {\n        return createNewMenuBar;\n    }\n",
    "66032": "    public boolean isSelected() {\n        return selected;\n    }\n",
    "66033": "    public void setCreateNewMenuBar(boolean createNewMenuBar) {\n        this.createNewMenuBar = createNewMenuBar;\n    }\n",
    "66035": "    public void setSelected(boolean selected) {\n        this.selected = selected;\n    }\n",
    "66041": "    public String getMenuBarVJBName() {\n        return menuBarVJBName;\n    }\n",
    "66042": "    public void setMenuBarVJBName(String menuBarVJBName) {\n        this.menuBarVJBName = menuBarVJBName;\n    }\n",
    "66048": "    public void setMenuItemVJBList(ArrayList<MenuItemVJB> menuItemVJBList) {\n        this.menuItemVJBList = menuItemVJBList;\n    }\n",
    "66053": "    public void setMenuVJBList(ArrayList<MenuVJB> menuVJBList) {\n        this.menuVJBList = menuVJBList;\n    }\n",
    "66063": "    public void setMenusBarVJB(ArrayList<MenuBarVJB> menusBarVJB) {\n        this.menusBarVJB = menusBarVJB;\n    }\n",
    "66132": "    private String testDropTarget(TreePath destination, TreePath dropper) {\n        //Typical Tests for dropping\n\n        //Test 1.\n        boolean destinationPathIsNull = destination == null;\n        if (destinationPathIsNull) {\n            return \"Invalid drop location.\";\n        }\n\n        //Test 2.\n        MenuNode node = (MenuNode) destination.getLastPathComponent();\n        if (!node.getAllowsChildren()) {\n            return \"This node does not allow children\";\n        }\n\n        if (destination.equals(dropper)) {\n            return \"Destination cannot be same as source\";\n        }\n\n        //Test 3.\n        if (dropper.isDescendant(destination)) {\n            return \"Destination node cannot be a descendant.\";\n        }\n\n        //Test 4.\n        if (dropper.getParentPath().equals(destination)) {\n            return \"Destination node cannot be a parent.\";\n        }\n\n        return null;\n    }\n",
    "66171": "    public void redraw(Rectangle cellsToRedraw) {\n        checkWidget();\n        redraw(cellsToRedraw.x, cellsToRedraw.y, cellsToRedraw.width,\n                cellsToRedraw.height);\n    }\n",
    "66199": "    protected void drawCell(GC gc, int col, int row) {\n        \n        drawCell(gc, col, row, getCellRect(col, row));\n        \n        Rectangle oldClip = gc.getClipping();\n        gc.setClipping(getClientArea());\n        if ((getStyle() & SWTX.MARK_FOCUS_HEADERS)==SWTX.MARK_FOCUS_HEADERS) {\n            if (row>=m_TopRow) {\n                for (int i=0; i<m_Model.getFixedHeaderColumnCount(); i++)\n                    drawCell(gc, i, row, getCellRect(i, row));\n                for (int i=0; i<m_Model.getFixedHeaderRowCount(); i++)\n                    drawCell(gc, col, i, getCellRect(col, i));\n            }\n        }\n        gc.setClipping(oldClip);\n    }\n",
    "66227": "    public String getDateMask() {\n        return dateMask;\n    }\n",
    "66229": "    public void setDateMask(String dateMask) {\n        this.dateMask = dateMask;\n    }\n",
    "66231": "    public void updateCell(int col, int row) {\n        checkWidget();\n        if ((row < 0) || (row >= m_Model.getRowCount()) || \n            (col < 0) || (col >= m_Model.getColumnCount()))\n            return;\n\n        // be sure it is a valid cell if cells span \n        Point valid = getValidCell(col, row);\n        // update it:\n        GC gc = new GC(this);\n        drawCell(gc, valid.x, valid.y);\n        gc.dispose();\n    }\n",
    "66237": "    public JPanel getSelectedPanel() {\n        return selectedPanel;\n    }\n",
    "66238": "    public void setSelectedPanel(JPanel selectedPanel) {\n        this.selectedPanel = selectedPanel;\n    }\n",
    "66270": "    @Override protected void startup() {\n        show(new HotdogView(this));\n    }\n",
    "66273": "    public boolean isUfRecordSelected() {\n        return ufTable.getSelectedRow() != -1;\n    }\n",
    "66284": "    public boolean isSaveFired() {\n        return saveFired;\n    }\n",
    "66285": "    public void setSaveFired(boolean saveFired) {\n        this.saveFired = saveFired;\n    }\n",
    "66286": "    public Cliente getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66288": "    public void setCurrentRecord(Cliente currentRecord) {\n        Cliente oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66297": "    public boolean isCidadeRecordSelected() {\n        return cidadeTable.getSelectedRow() != -1;\n    }\n",
    "66300": "    public void setDefaultCursor(Cursor cursor, Point size_below_hotspot) {\n        checkWidget();\n        if (m_defaultCursor != null)\n            m_defaultCursor.dispose();\n        m_defaultCursor = cursor;\n        m_defaultCursorSize = size_below_hotspot;\n        setCursor(cursor);\n    }\n",
    "66305": "    public Animal getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66306": "    public void setCurrentRecord(Animal currentRecord) {\n        Animal oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66323": "    public Hospedagem getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66324": "    public void setCurrentRecord(Hospedagem currentRecord) {\n        Hospedagem oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n        if(this.currentRecord == null) {\n            Logger.getLogger(this.getClass().getName()).\n                warning(\"this.current record is null!\");\n        }\n        Logger.getLogger(this.getClass().getName()).\n                info(\"setCurrentRecord method, diaria value : \" + this.currentRecord.getDiaria());\n    }\n",
    "66330": "    public boolean isAnimalRecordSelected() {\n        return animalTable.getSelectedRow() != -1;\n    }\n",
    "66341": "    public Cidade getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66342": "    public void setCurrentRecord(Cidade currentRecord) {\n        Cidade oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66379": "    public boolean isClienteRecordSelected() {\n        return clienteTable.getSelectedRow() != -1;\n    }\n",
    "66438": "    public boolean isHospedagemRecordSelected() {\n        return hospedagemTable.getSelectedRow() != -1;\n    }\n",
    "66452": "    public Double getDesconto() {\n        return desconto;\n    }\n",
    "66453": "    public void setDesconto(Double desconto) {\n        this.desconto = desconto;\n    }\n",
    "66455": "    public Double getDiaria() {\n        return diaria;\n    }\n",
    "66456": "    public void setDiaria(Double diaria) {\n        this.diaria = diaria;\n    }\n",
    "66459": "    public Date getFim() {\n        return fim;\n    }\n",
    "66461": "    public void setFim(Date fim) {\n        this.fim = fim;\n    }\n",
    "66462": "    public Date getInicio() {\n        return inicio;\n    }\n",
    "66464": "    public void setInicio(Date inicio) {\n        this.inicio = inicio;\n    }\n",
    "66465": "    public Animal getAnimal() {\n        return animal;\n    }\n",
    "66467": "    public void setAnimal(Animal animal) {\n        this.animal = animal;\n    }\n",
    "66477": "    protected Point checkIfMatchesInColumns(int startRow, int endRow, int startCol, int endCol, Point toFind, boolean span) {\n        \n        for (int row = startRow; row < endRow; row++) {\n            for (int col = startCol; col < endCol; col++) {\n                \n                Rectangle rect = getCellRectIgnoreSpan(col, row);\n                // take into account the 1px right and bottom border\n                rect.width+=1;\n                rect.height+=1;\n                if (rect.contains(toFind))\n                    if (span)\n                    // take into account the spanning when reporting a match:\n                        return getValidCell(col, row);\n                    else\n                        return new Point(col, row);\n            }\n        }\n        return null;\n    }\n",
    "66478": "    public void setPlayers(ArrayList<PlayerThread> players) {\n        this.players = players;\n    }\n",
    "66535": "    public int getType() {\n        return type;\n    }\n",
    "66537": "    public void setType(int type) {\n        this.type = type;\n    }\n",
    "66570": "    public String getPlayerName() {\n        return playerName;\n    }\n",
    "66571": "    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n",
    "66572": "    public Integer getServerPort() {\n        return serverPort;\n    }\n",
    "66573": "    public void setServerPort(Integer serverPort) {\n        this.serverPort = serverPort;\n    }\n",
    "66575": "    public String getServerIP() {\n        return serverIP;\n    }\n",
    "66577": "    public void setServerIP(String serverIP) {\n        this.serverIP = serverIP;\n    }\n",
    "66585": "    public KeyframeController getKeyframeController() {\n        return keyframeController;\n    }\n",
    "66587": "    public void setKeyframeController(KeyframeController keyframeController) {\n        this.keyframeController = keyframeController;\n    }\n",
    "66588": "    public Node getNode() {\n        return node;\n    }\n",
    "66590": "    public void setNode(Node node) {\n        this.node = node;\n    }\n",
    "66607": "    public void setModelAnimationsList(List<ModelAnimation> modelAnimationsList) {\n        this.modelAnimationsList = modelAnimationsList;\n    }\n",
    "66609": "    public ModelAnimation getBaseAnimation() {\n        return baseAnimation;\n    }\n",
    "66611": "    public void setBaseAnimation(ModelAnimation baseAnimation) {\n        this.baseAnimation = baseAnimation;\n    }\n",
    "66612": "    public ModelAnimation getRunAnimation() {\n        return runAnimation;\n    }\n",
    "66614": "    public void setRunAnimation(ModelAnimation runAnimation) {\n        this.runAnimation = runAnimation;\n    }\n",
    "66632": "    private void buildInput() {\n        input = new ChaseDoomHandler(player.getNode(), properties.getRenderer());\n        mouse = new RelativeMouse(\"Mouse Input\");\n        mouse.registerWithInputHandler(input);\n\tmouse.setCullMode(Spatial.CULL_ALWAYS);\n        URL cursorFile = null;\n        try {\n            cursorFile = new File(\"model\", \"cursor1.png\").toURI().toURL();\n        } catch (MalformedURLException ex) {\n            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        MouseInput.get().setHardwareCursor(cursorFile);\n    }\n",
    "66638": "    public int getBeginFrame() {\n        return beginFrame;\n    }\n",
    "66639": "    public void setBeginFrame(int beginFrame) {\n        this.beginFrame = beginFrame;\n    }\n",
    "66640": "    public int getEndFrame() {\n        return endFrame;\n    }\n",
    "66641": "    public void setEndFrame(int endFrame) {\n        this.endFrame = endFrame;\n    }\n",
    "66642": "    public boolean isAnimating() {\n        return animating;\n    }\n",
    "66643": "    public void setAnimating(boolean animating) {\n        this.animating = animating;\n    }\n",
    "66644": "    public void setKeys(List<Integer> keys) {\n        if (this.getKeys().size()>0) {\n            this.getKeys().clear();\n        }\n        this.getKeys().addAll(keys);\n    }\n",
    "66647": "    public boolean isEnabled() {\n\n        return enabled;\n    }\n",
    "66649": "    public void setEnabled(boolean enabled) {\n\n        this.enabled = enabled;\n\n        if (enabled) {\n            setCullMode(CULL_DYNAMIC);\n        } else {\n            setCullMode(CULL_ALWAYS);\n        }\n    }\n",
    "66650": "    public void setColor(ColorRGBA color) {\n\n        this.color = color;\n\n        text2D.setTextColor(color);\n    }\n",
    "66651": "    public void setOffset(Vector3f offset) {\n\n        this.offset = offset;\n    }\n",
    "66652": "    public void setText(String text) {\n\n        text2D.setText(text);\n    }\n",
    "66656": "    public void setHorizontalAlignment(int align) {\n\n        if (align == HA_LEFT) {\n            alignOffset = 0;\n        } else if (align == HA_CENTER) {\n            alignOffset = (text2D.getWidth() / 2) * -1;\n        } else if (align == HA_RIGHT) {\n            alignOffset = text2D.getWidth() * -1;\n        }\n\n        alignOffset = alignOffset * getLocalScale().x;\n    }\n",
    "66658": "    public void setVerticalAlignment(int valign) {\n\n        if (valign == VA_TOP) {\n            valignOffset = 0;\n        } else if (valign == VA_MIDDLE) {\n            valignOffset = (text2D.getHeight() / 2) * -1;\n        } else if (valign == VA_BOTTOM) {\n            valignOffset = text2D.getHeight() * -1;\n        }\n\n        valignOffset = valignOffset * getLocalScale().y;\n    }\n",
    "66661": "    public boolean isEditorOutcomeSave() {\n        return editorOutcomeSave;\n    }\n",
    "66663": "    public void setEditorOutcomeSave(boolean editorOutcomeSave) {\n        this.editorOutcomeSave = editorOutcomeSave;\n    }\n",
    "66720": "    public void setToolTipText(String tooltip) {\n        m_nativTooltip = tooltip;\n    }\n",
    "66734": "    public String getToolTipText() {\n        return m_nativTooltip;\n    }\n",
    "66811": "    public void openEditorInFocus(KTableCellEditor cellEditor) {\n        checkWidget();\n        //m_CellEditor = m_Model.getCellEditor(m_FocusCol, m_FocusRow);\n        m_CellEditor = cellEditor; //@Trifon\n        if (m_CellEditor != null) {\n            scrollToFocus();\n            Rectangle r = getCellRect(m_FocusCol, m_FocusRow);\n            m_CellEditor.open(this, m_FocusCol, m_FocusRow, r);\n        }\n    }\n",
    "66843": "    public void scroll(int col, int row) {\n        if (col<0 || col>=m_Model.getColumnCount() ||\n            row<0 || row>=m_Model.getRowCount())\n            return;\n        \n        m_TopRow = row;\n        m_LeftColumn=col;\n        redraw();\n    }\n",
    "66897": "    public void addCellSelectionListener(KTableCellSelectionListener listener) {\n        cellSelectionListeners.add(listener);\n    }\n",
    "66909": "    public void addCellResizeListener(KTableCellResizeListener listener) {\n        cellResizeListeners.add(listener);\n    }\n",
    "66949": "    public void addCellDoubleClickListener(KTableCellDoubleClickListener listener) {\n        cellDoubleClickListeners.add(listener);\n    }\n",
    "66967": "    public boolean removeCellSelectionListener(KTableCellSelectionListener listener) {\n        return cellSelectionListeners.remove(listener);\n    }\n",
    "66991": "    public boolean removeCellResizeListener(KTableCellResizeListener listener) {\n        return cellResizeListeners.remove(listener);\n    }\n",
    "67028": "    public boolean removeDoubleClickListener(KTableCellDoubleClickListener listener) {\n        return cellDoubleClickListeners.remove(listener);\n    }\n",
    "67038": "  public void gotoRecord(int pos) {\n    curRecordIndex = pos;\n    int rowNb = curRecordIndex-1+firstRowIndex;\n    getCaller().trace.trace(\"Moving to record #\"+pos+\" (row #\"+rowNb+\")\");\n    if(rowNb<firstRowIndex || rowNb>lastRowIndex)\n      curRow = null;\n    else\n      curRow = curSheet.getRow(rowNb);\n  }\n",
    "67043": "  public Value getColumn(int i) throws ExecuteException {\n    if(i<1 || i>sheetLabels.length)\n      throw new ExecuteException(\"Cell #\"+i+\" is out of range\");\n    if(curRow==null) return NullValue.NULL;\n    getCaller().trace.trace(\"Getting column #\"+i);\n    return getCellValue((short)(i-1));\n    // getCellType: CELL_TYPE_STRING, CELL_TYPE_NUMERIC, CELL_TYPE_FORMULA, CELL_TYPE_BOOLEAN, CELL_TYPE_ERROR\n    //    return cell.getNumericCellValue();\n  }\n",
    "67044": "    public boolean isRowSelectMode() {\n        return (getStyle() & SWT.FULL_SELECTION) == SWT.FULL_SELECTION;\n    }\n",
    "67056": "    public boolean isMultiSelectMode() {\n        return (getStyle() & SWT.MULTI) == SWT.MULTI;\n    }\n",
    "67066": "  protected boolean first100AreInteger(short col) {\n    int i = firstRowIndex;\n    HSSFRow row;\n    while((row=curSheet.getRow(i++))!=null && i<100) {\n      HSSFCell cell = row.getCell(col);\n      if(cell!=null) {\n\tif(cell.getCellType()==HSSFCell.CELL_TYPE_NUMERIC)\n        try {\n          float val = (float)cell.getNumericCellValue();\n          if(val!=(float)((int)val)) return false;\n\t} catch (NumberFormatException exc) {return false;}\n      }\n    }\n    return true;\n  }\n",
    "67081": "  public ASTXMLObject nextXML() throws ExecuteException {\n    currentChildIndex++;\n    if(currentChildIndex<(bufStart+buffer.size()))\n      return (ASTXMLObject) buffer.get(currentChildIndex+bufStart);\n    else \n      try{return parseXML();}\n      catch (XMLException exc) {\n        if(onerror==null) throw exc;\n        else {\n          onerror.executeWithExc(exc,\n              \"Caught XML exception while parsing \"+fileName);\n          return null;\n        }\n      }\n  }\n",
    "67085": "  public void initParser() throws ExecuteException {\n    bufStart = -1;\n    buffer.removeAllElements();\n    getCaller().trace.debug(\"*** Parsing \"+fileName+\" header...\");\n    FileReader fileReader;\n    // TBD: set encoding\n    try {fileReader = new FileReader(fileName);}\n    catch (FileNotFoundException exc) {\n      throw new ExecuteException(\"File not found: \"+fileName);}\n    parser = new Parser(fileReader);\n    // parse header\n    try {\n      boolean allowDSQL = allowDSQL();\n      root = parser.XMLHeader(allowDSQL,allowDSQL);\n      // TBD: detect empty document, i.e. <doc/>\n    } catch (ParseException exc) {\n      throw new XMLException(fileName,exc);\n    } catch (TokenMgrError exc) {\n      throw new XMLException(fileName,exc);\n    }\n  }\n",
    "67140": "  public String getString() throws ExecuteException {\n    if(getColumnCount()==0) return null;\n    if(currentRecord()>1) reset();\n    if(currentRecord()==0) \n      if(!nextRecord()) return null;\n    return getColumnString(1);\n  }\n",
    "67178": "  protected int findColumn(String label) throws ExecuteException {\n    Integer i = (Integer) columnLabels.get(label);\n    if(i!=null) return i.intValue();\n    else throw new ExecuteException(\"No column \"+label+\" in results\");\n  }\n",
    "67180": "    public void clearSelection() {\n        checkWidget();\n        clearSelectionWithoutRedraw();\n        m_FocusCol = -1;\n        m_FocusRow = -1;\n        if (isMultiSelectMode())\n            redraw();\n    }\n",
    "67193": "    protected boolean toggleSelection(int col, int row) {\n\n        if (isMultiSelectMode()) {\n            Object o;\n            if (isRowSelectMode()) {\n                o = new Integer(row);\n            } else {\n                o = new Point(col, row);\n            }\n            if (m_Selection.get(o) != null) {\n                m_Selection.remove(o);\n                return false;\n            } else {\n                m_Selection.put(o, o);\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "67203": "    protected void addToSelectionWithoutRedraw(int col, int row) {\n        if (isMultiSelectMode()) {\n            if (isRowSelectMode()) {\n                Integer o = new Integer(row);\n                m_Selection.put(o, o);\n            } else {\n                Point o = new Point(col, row);\n                m_Selection.put(o, o);\n            }\n        }\n    }\n",
    "67213": "    public void setSelection(int col, int row, boolean scroll) {\n        checkWidget();\n        if (col < m_Model.getColumnCount()\n                && col >= m_Model.getFixedHeaderColumnCount()\n                && row < m_Model.getRowCount()\n                && row >= m_Model.getFixedHeaderRowCount()) {\n            focusCell(col, row, 0);\n            if (scroll) {\n                scrollToFocus();\n            }\n        }\n    }\n",
    "67216": "  protected int findColumn(String label) throws ExecuteException {\n    if(cachedLabels!=null && cachedLabels.get(label)!=null)\n      return ((Integer)cachedLabels.get(label)).intValue();\n    else {\n      if(rs==null) // not sure this can ever happen \n        throw new ExecuteException(\"No SQL results\");\n      try {return rs.findColumn(label);}\n      catch (SQLException exc) {throw new ExecuteException(\n        \"Column \"+label+\" does not exist in results\");}\n    }\n  }\n",
    "67233": "    public boolean isCellSelected(int col, int row) {\n        checkWidget();\n        Point v = getValidCell(col, row);\n        col = v.x;\n        row = v.y;\n        if (!isMultiSelectMode()) {\n            if (isRowSelectMode())\n                return (row == m_FocusRow);\n            return (col == m_FocusCol && row == m_FocusRow);\n        }\n\n        if (isRowSelectMode())\n            return (m_Selection.get(new Integer(row)) != null);\n        else\n            return (m_Selection.get(new Point(col, row)) != null);\n    }\n",
    "67241": "    public boolean isRowSelected(int row) {\n        return (m_Selection.get(new Integer(row)) != null);\n    }\n",
    "67255": "  public Object getField(String name) throws ExecuteException {\n    if(name.equals(\"start\")) return new IntValue(start);\n    if(name.equals(\"end\")) return new IntValue(end);\n    return super.getField(name);\n  }\n",
    "67321": "    private boolean highlightSelectedRowCol(int col, int row) {\n        if (!isHighlightSelectionInHeader() || !isHeaderCell(col, row))\n            return false;\n        \n        Point[] sel = getCellSelection();\n        if (sel!=null) {\n            for (int i=0; i<sel.length; i++) {\n                if (sel[i].x == col || sel[i].y == row) \n                    return true;\n                Point valid = getValidCell(sel[i].x, row);\n                if (valid.x == col) return true;\n                valid = getValidCell(col, sel[i].y);\n                if (valid.y == row) return true;\n            }\n        }\n        return false;\n    }\n",
    "67364": "    public void setModel(KTableModel model) {\n        checkWidget();\n        m_Model = model;\n        m_FocusCol = -1;\n        m_FocusRow = -1;\n        clearSelectionWithoutRedraw();\n        \n        // implement autoscrolling if needed:\n        if ((getStyle() & SWTX.AUTO_SCROLL) == SWTX.AUTO_SCROLL)\n            updateScrollbarVisibility();\n        \n        redraw();\n        // TODO add KTable as listener to KModel...\n        if (m_Model != null) {\n        \tSystem.out.println(\"KTable added as listener to KTableModel...\");\n        \tm_Model.addModelChangeListener(this);\n        }\n    }\n",
    "67396": "    public KTableModel getModel() {\n        return m_Model;\n    }\n",
    "67402": "  public Object getType(Class cl) throws ExecuteException {\n    if(cl==String.class) return getString();\n    if(cl==Boolean.class) return new Boolean(getBoolean());\n    if(cl==Integer.class) return new Integer(getInt());\n    if(cl==Float.class) return new Float(getFloat());\n    if(cl==RecordHolder.class) return getRecordHolder();\n    if(cl==XmlElement.class) return getXmlElement();\n    if(cl==ASTXMLObject.class) return getASTXML();\n    throw new ExecuteException(\"Cannot convert \"+this.toString()+\n\t\t\t       \" to \"+cl);\n  }\n",
    "67404": "  public Class getObjectClass() {\n    return getClass();\n  }\n",
    "67405": "  public Object getField(String name) throws ExecuteException {\n    try {\n      return getValue(getClass().getField(name).get(this));\n    } catch (NoSuchFieldException exc) {\n      StringBuffer available = new StringBuffer(\"Valid fields are: \");\n      boolean first = true;\n      for (Enumeration e=getFieldsEnumeration(); e.hasMoreElements();) {\n        available.append((first?\"\":\",\")+e.nextElement());\n        first = false;\n      }\n      throw new ExecuteException(\"Field '\"+name+\"' does not exist. \"\n                               +(first?\"No fields defined.\":available.toString()));\n    } catch (IllegalAccessException exc) {\n      throw new ExecuteException(\"Field '\"+name+\"' cannot be accessed\",exc);\n    }\n  }\n",
    "67409": "  public Enumeration getFieldsEnumeration() {\n    Field[] fields = getClass().getFields();\n    Vector v = new Vector();\n    for(int i=0; i<fields.length; i++) v.add(fields[i].getName());\n    return Collections.enumeration(v);\n  }\n",
    "67432": "  public Object getField(String name) throws ExecuteException {\n    return getColumn(name);\n  }\n",
    "67441": "    protected int getFixedColumnCount() {\n        return m_Model.getFixedHeaderColumnCount()+m_Model.getFixedSelectableColumnCount();\n    }\n",
    "67494": "  public void reset() throws ExecuteException {\n      if(currentIndex==0) return;\n      else throw new ExecuteException(\"Unable to reset enumerator value\");\n  }\n",
    "67526": "    protected int getFixedRowCount() {\n        return m_Model.getFixedHeaderRowCount()+m_Model.getFixedSelectableRowCount();\n    }\n",
    "67554": "  public void highlight(String pattern) {\n    // First remove all old highlights\n    try {\n      Highlighter hilite = getHighlighter();\n      Document doc = getDocument();\n      String text = doc.getText(0, doc.getLength());\n      int pos = 0;\n      // Search for pattern\n      while ((pos = text.indexOf(pattern, pos)) >= 0) {\n\t// Create highlighter using private painter and apply around pattern\n\thilite.addHighlight(pos, pos+pattern.length(), findHighlightPainter);\n\tpos += pattern.length();\n      }\n    } catch (BadLocationException e) {\n    }\n  }\n",
    "67555": "  public void removeHighlights() {\n    Highlighter hilite = getHighlighter();\n    Highlighter.Highlight[] hilites = hilite.getHighlights();  \n    for (int i=0; i<hilites.length; i++) {\n      if (hilites[i].getPainter() == findHighlightPainter) {\n\thilite.removeHighlight(hilites[i]);\n      }\n    }\n  }\n",
    "67572": "  public boolean abortOpen() {\n    if(unsavedEdits()) {\n      // bring up save dialog\n      int i=gui.chooseYesNoCancel(\"Save changes to \"+\n\t\t\t      (fileName==null?\"buffer\":fileName)+\n\t\t\t      \"?\",\"Unsaved\");\n      if(i==JOptionPane.CANCEL_OPTION) return true;\n      if(i==JOptionPane.YES_OPTION) {\n\tif(fileName!=null) saveFile(fileName);\n\telse if(!saveDialog()) return true;\n      }\n    }\n    return false;\n  }\n",
    "67606": "  public void addStackValue(Value v) {\n    if(getGui()!=null) getGui().addReturnValue(v);\n  }\n",
    "67639": "  protected ConnectStmt openConnection() throws ExecuteException {\n    try {\n      if(driverClass!=null) Class.forName(driverClass);\n      getCaller().trace.sql(\"Connecting to \"+conurl);\n      Connection con = \n        DriverManager.getConnection(conurl,userName.getUserName(),\n        \t                    password.getPassword());\n      ConnectStmt conStmt = new ConnectStmt(con);\n      SQLconns.addElement(conStmt);\n      setMetadata();\n      return conStmt;\n    } catch (ClassNotFoundException exc) {\n      throw new ExecuteException(\"Unable to use driver \"+getDriverId()+\n        \": class \"+driverClass+\" could not be found.\");\n    } catch (SQLException exc) {\n      throw new ExecuteException(\"Unable to establish connection to '\"+\n        getId()+\"': \"+exc.getMessage(),exc);\n    }\n  }\n",
    "67646": "   public void stopMasking() {\n      this.stop = true;\n   }\n",
    "67647": "    public boolean hasMoreElements() {\n        if (hasMore)\n            hasChecked = hasMore = e1.hasMoreElements();\n        return hasMore ? true : e2.hasMoreElements();\n    }\n",
    "67648": "    public Object nextElement() {\n        if (hasMore && !hasChecked)\n            hasMore = e1.hasMoreElements();\n\thasChecked = false;\n        return hasMore ? e1.nextElement() : e2.nextElement();\n    }\n",
    "67669": "  protected int priority() {\n    return Integer.MAX_VALUE;\n  }\n",
    "67718": "  public void addVariable(Variable var) {\n    ((Hashtable)vars.elementAt(vars.size()-1)).put(var.getName(),var);\n    getCaller().trace.debug(\"Added \"+var+\" to the current variable context\");\n  }\n",
    "67719": "  public void setVariable(String name, Value value) throws ExecuteException {\n    Variable var;\n    try { var = getVariable(name); }\n    catch (VarNotSetException exc) { \n      var = new Variable(name);\n      addVariable(var); \n    }\n    var.setValue(value);\n  }\n",
    "67810": "  public String getXMLText() throws ExecuteException {\n    String r = \"\";\n    // TBD: should start from attributes?\n    for(int i=0; i<jjtGetNumChildren(); i++)\n      if(children[i] instanceof ASTXMLObject &&\n         !(children[i] instanceof ASTXMLAttribute))\n        r = r+((ASTXMLObject)children[i]).getXMLText();\n    return r;\n  }\n",
    "67862": "  public void updateCursorPos(int line, int col) {\n    caretPos.setText(\"\"+line+\":\"+col);\n  }\n",
    "67892": "  public Value executeWithCatch() throws ExecuteException {\n    if(getCaller().hasRequestToStop()) \n      throw new StopException();\n    try {return execute();}\n    catch (ExecuteException exc) {\n      if(exc.getNode()==null) exc.setNode(this); \n      throw exc;\n    }\n  }\n",
    "67954": "  public ASTXMLObject executeXML() {\n    return this;\n  }\n",
    "68115": "   public Food findIdenticalFood(Food f) {\n      Iterator iter = map.values().iterator();\n      while (iter.hasNext()) {\n         FoodProxy food = (FoodProxy)iter.next();\n         if (food.getDescription().equals(f.getDescription())) {\n            if (food.getFood().equals(f)) {\n               return food.getFood();\n            }\n         }\n      }\n      return null;\n   }\n",
    "68207": "   private String fixString(String str) {\n      //return \"<html><div align=\\\"center\\\">\" + str + \"</div></html>\";\n      if (str.length() > 53) {\n         return str.substring(0, 50)+\"...\";\n      } else {\n         return str;\n      }\n   }\n",
    "68213": "   private void createFile() {\n      for (Iterator iter = Biomarker.createPredefinedBiomarkers().iterator(); iter.hasNext();) {\n         Biomarker biomarker = (Biomarker) iter.next();\n         addBiomarker(biomarker);\n      }\n      save();\n   }\n",
    "68215": "   private void createDataset() {\n      actualData = new TimeSeries(metricName, Day.class);\n      dataset = new TimeSeriesCollection();\n      getData();\n      dataset.addSeries(actualData);\n   }\n",
    "68229": "   public int compareTo(Object object) {\n      return date.compareTo(((Metric)object).getDate());\n   }\n",
    "68297": "   public void addFood(NutrientTable toAdd, double weight) {\n      for (int i = 0; i < nutrients.length; i++) {\n         nutrients[i] += toAdd.getAmount(i) * weight;\n      }\n   }\n",
    "68319": "    public void update() {\n       UserManager.getCurrentUser().getFoodHistory().update(this);\n        //lds.changeServingAmount(this);\n    }\n",
    "68342": "   public void setMeasure(String measureName) {\n      if (food == null) return;\n      List measures = getFoodProxy().getFood().getMeasures();\n      for (int i=0; i<measures.size(); i++) {\n         Measure m = (Measure)measures.get(i);\n         if (m.getDescription().equals(measureName)) {\n            setMeasure(m);\n            return;\n         }\n      }\n      // if nothing found, default to GRAMS\n      setMeasure(Measure.GRAM);\n   }\n",
    "68372": "   public String getDescription() {\n      return description;\n   }\n",
    "68373": "   public void setFood(Food f) {\n      measures.setModel(new DefaultComboBoxModel(f.getMeasures().toArray()));\n      curMeasure = Measure.GRAM;\n      fireChangeEvent();\n   }\n",
    "68375": "   public void setDescription(String text) {\n      description = text;\n      setDirty(true);\n   }\n",
    "68376": "   public void setMeasure(Measure w, double mult) {\n     // measures.setSelectedItem(w);\n      for (int i=0; i<measures.getItemCount(); i++) {\n         Measure m = (Measure)measures.getItemAt(i);\n         if (m.equals(w)) {\n            measures.setSelectedIndex(i);\n            break;\n         }\n      }\n      multiplier.setValue(mult);\n      fireChangeEvent();\n   }\n",
    "68377": "   public List getMeasures() {\n      if (measures == null) {\n         measures = new ArrayList();\n         measures.add(Measure.GRAM);\n      }\n      return measures;\n   }\n",
    "68378": "   public void updateMeasure() {\n      Measure w = getSelectedMeasure();     \n      if (linked) {\n         double mult = w.getAmount();\n         if (curMeasure != null) {\n            double grams = curMeasure.getGrams() * multiplier.getValue();\n            mult = grams/w.getGrams();\n         }\n         multiplier.setValue(mult);\n      }\n      setFocus();\n      curMeasure = w;\n      fireChangeEvent();\n   }      \n",
    "68380": "   public double getMultiplier() {\n      return getGrams() / 100.0;\n   }\n",
    "68381": "   public void setMeasures(List measures) {\n      this.measures = measures;\n      setDirty(true);\n   }\n",
    "68382": "   public double getGrams() {\n      Measure w = getSelectedMeasure();\n      if (w != null) {\n         return multiplier.getValue() * w.getGrams();// * (1.0/w.getAmount()); \n      }\n      return 0;\n   }\n",
    "68383": "   public boolean hasDataFor(NutrientInfo ni) {\n        if (ni == null) return false;\n        return getNutrients().dataExists(ni.getIndex());         \n    }\n",
    "68386": "   public double getNutrientAmount(NutrientInfo ni) {\n        if (ni == null) return 0;\n        return getNutrients().getAmount(ni.getIndex());         \n    }\n",
    "68388": "   public void setNutrientAmount(NutrientInfo ni, double val) {\n      getNutrients().setAmount(ni.getIndex(), val);        \n      setDirty(true);\n   }\n",
    "68401": "   public void addServings(Serving[] list) {\n      addServingsToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());\n   }\n",
    "68402": "   public void itemStateChanged(ItemEvent e) {\n      updateMeasure();\n   }\n",
    "68403": "   public void actionPerformed(ActionEvent e) {\n      fireChangeEvent();\n      fireActionEvent();\n      //Toolkit.getDefaultToolkit().beep();\n   }\n",
    "68410": "   public String getSourceUID() {\n      return sourceUID;\n   }\n",
    "68411": "   public void keyReleased(KeyEvent e) {\n      //System.out.println(\"keyReleased: \" + e);\n      fireChangeEvent();\n   }\n",
    "68413": "   public void setSourceUID(String uid) {\n      sourceUID = uid;\n      setDirty(true);\n   }\n",
    "68415": "   public boolean isLinked() {\n      return linked;\n   }\n",
    "68416": "   public void setComment(String comment) {\n      this.comment = comment;\n      setDirty(true);\n   }\n",
    "68418": "   public void setLinked(boolean linked) {\n      this.linked = linked;\n   }\n",
    "68419": "   public String getComment() {\n      return comment;\n   }\n",
    "68433": "   public boolean equals(Food f) {\n      if (!f.getDescription().equals(getDescription())) return false;\n      List nutrients = NutrientInfo.getGlobalList();\n      for (int i=0; i<nutrients.size(); i++) {\n         NutrientInfo ni = (NutrientInfo)nutrients.get(i);\n         if (f.getNutrientAmount(ni) != getNutrientAmount(ni)) {\n            return false;\n         }\n      }\n      return true;\n   }\n",
    "68453": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      Serving s = getServing(row);\n      if (s != null) {\n         if (s.getFoodProxy().isDeprecated()) {\n            c.setForeground(Color.LIGHT_GRAY);               \n         } else if (col == 0) {\n            c.setForeground(s.getFoodProxy().getSource().getDisplayColor());               \n         } else {\n            c.setForeground(Color.BLACK);\n         }\n      }\n      return c;\n   }\n",
    "68457": "   private void setMeasureBox(Serving s) {\n      if (s != null) {\n         measureBox.removeAllItems();\n         List measures = s.getFood().getMeasures();\n         for (int i=0; i<measures.size(); i++) {\n            measureBox.addItem(measures.get(i));\n         }\n         measureBox.setSelectedItem(s.getMeasure());\n      }\n   }\n",
    "68461": "   public void updateOriginal() {\n      original.copy(food);\n      original.update();\n   }\n",
    "68472": "    public double getAmount() {\n        return amount;\n    }\n",
    "68474": "    public void setAmount(double amount) {\n        this.amount = amount;\n    }\n",
    "68477": "    public void setDescription(String description) {\n        this.description = description;\n    }\n",
    "68478": "    public double getGrams() {\n        return grams;\n    }\n",
    "68480": "    public void setGrams(double grams) {\n        this.grams = grams;\n    }\n",
    "68523": "   public void doPrint() {\n      try {         \n         MessageFormat headerFormat = new MessageFormat(getTitle());\n         MessageFormat footerFormat = new MessageFormat(\"- {0} -\");\n         getTable().print(JTable.PrintMode.FIT_WIDTH, headerFormat, footerFormat);          \n      } catch (PrinterException e) {\n         e.printStackTrace();\n         JOptionPane.showMessageDialog(this, e.getMessage());\n      }\n   }     \n",
    "68552": "   private void recomputeNutrients() {\n      double total = getTotalGrams();\n      \n      Iterator iter = NutrientInfo.getGlobalList().iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         setNutrientAmount(ni, getAmount(ni, total));\n      }\n      \n      recomputeFactors();\n      \n      boolean found = false;\n      List list = getMeasures();      \n      for (int i=0; i<list.size(); i++) {\n         Measure m = (Measure)list.get(i);\n         if (m.getDescription().equals(\"full recipe\")) {\n            m.setGrams(total);\n            found = true;\n         }\n      }\n      if (!found) {\n         getMeasures().add( new Measure(1.0, \"full recipe\", total) );\n      }\n      //update();\n   }\n",
    "68556": "   private double getAmount(NutrientInfo ni, double totalGrams) {\n      double total = 0;\n      for (Iterator iter = getServings().iterator(); iter.hasNext();) {\n         Serving serving = (Serving) iter.next();\n         if (serving.getFood() != null) {\n            double weight = (serving.getGrams()/totalGrams);\n            total += weight * serving.getFood().getNutrientAmount(ni);\n         }\n      }\n      return total;\n   }\n",
    "68563": "   public void updateOriginal() {\n      ((Recipe)original).copy(getRecipe());\n      original.update();\n   }\n",
    "68564": "   public boolean isSparseData() {\n      return sparse;\n   }\n",
    "68601": "   public User getLastUser() {\n      User user = getUser(getLastUsername());\n      if (user == null) {\n         user = getUserList().get(0);\n      }\n      return user;\n   }\n",
    "68615": "   public void addUser(JComponent parentWindow) {\n      User user = new User(new Settings(Settings.TAG_USER));\n      setCurrentUser(user);\n      addUser(user);\n      user.doFirstRun(parentWindow);\n      settings.save();\n   }\n",
    "68621": "   public void addUser(User user) {\n      userList.add(user);\n      settings.save();\n   }\n",
    "68626": "   public User getUser(String username) {\n      return getUser(getUserList(), username);\n   }\n",
    "68631": "   public void deleteUser(User user) {\n      userList.remove(user);\n      deleteFiles(user);\n      if (currentUser == user) {\n         // Make sure we select a new currentUser, find the first active user\n         setCurrentUser(getUserList().get(0));\n      }\n      settings.save();\n   }\n",
    "68635": "   public void deleteFiles(User user) {\n      File userDir = getUserDirectory(user);\n      if (userDir.exists()) {\n         int i;\n         for (i=0; i<userFileList.length; i++) {\n            File userFile = new File(userDir.getAbsolutePath(), userFileList[i]);\n            if (userFile.exists()) {\n               if (!userFile.delete()) {\n                  Logger.error(\"Unable to delete the file: \" + userFile.getAbsolutePath());\n               }\n            }\n         }\n         if (!userDir.delete()) {\n            Logger.error(\"Unable to delete the folder: \" + userDir.getAbsolutePath());\n         }\n      }\n   }\n",
    "68641": "   public boolean deleteUser(String username) {\n      User user = getUser(username);\n      if (userExists(username)) {\n         deleteUser(user);\n         return true;\n      }\n      return false;\n   }\n",
    "68649": "   public boolean setCurrentUser(String username) {\n      User user = getUser(username);\n      if (user != null) {\n         setCurrentUser(user);\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "68660": "   public int getAge() {\n      if (null != getBirthDate()) {\n         return getAge(getBirthDate());\n      }\n      return 0;\n   }\n",
    "68746": "   private void deleteSelectedUser(int row) {\n      String username = (String)userListModel.get(row);\n      \n      if ( ! isOkToDeleteUser()) {\n         return;\n      }\n      \n      if (userListModel.size() == 1) {\n         Logger.error(\"Not allowed to delete last user.\");\n         return;\n      }\n      if (!userMan.deleteUser(username)) {\n         Logger.error(\"Unable to delete user.\");\n         return;\n      }\n      userListModel.remove(row);\n      selectCurrentUser();\n      setDirty(true);\n   }\n",
    "68754": "   public void selectDefaultUser() {\n      userList.setSelectedValue(UserManager.selectOtherUser().getUsername(), true);   \n   }\n",
    "68759": "   public void selectCurrentUser() {\n      userList.setSelectedValue(UserManager.getCurrentUser().getUsername(), true);   \n      if (userListModel.getSize() == 1) {\n         delBtn.setEnabled(false);\n      }\n   }\n",
    "68774": "   public double getTargetCompletion(boolean average) {\n      double total = 0;\n      double value = 0;\n      double valueFull = 0; \n      \n      Iterator iter = getNutrientList().iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         Target target = UserManager.getCurrentUser().getTarget(ni);\n         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {\n            double amount = getNutrientTable().getAmount(ni);\n            valueFull += amount/target.getMin();\n            if (amount < target.getMin()) {\n               value += amount/target.getMin();\n            } else {\n               value++;\n            }\n            total++;\n         }\n      }\n      if (average) {\n         return valueFull/total;\n      } else {\n         return value / total;\n      }\n   }\n",
    "68851": "   public void initUserData() {\n      getFoodHistory();\n      getNotesHistory();\n      getBiometricsHistory();\n   }\n",
    "68906": "   public void saveUserData() {\n      getFoodHistory().save();\n      getBiometricsHistory().save();\n      getNotesHistory().save();\n      getExerciseHistory().save();\n   }\n",
    "68918": "   public double getTargetCompletion(List servings, List nutrients, int days, boolean average) {\n      double total = 0;\n      double value = 0;\n      double valueFull = 0; \n      \n      Iterator iter = nutrients.iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         Target target = UserManager.getCurrentUser().getTarget(ni);\n         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {\n            double amount = getAmount(servings, ni) / (double) days;\n            valueFull += amount/target.getMin();\n            if (amount < target.getMin()) {\n               value += amount/target.getMin();\n            } else {\n               value++;\n            }\n            total++;\n         }\n      }\n      if (average) {\n         return valueFull / total;\n      } else {\n         return value / total;\n      }\n   }\n",
    "69072": "   public void focusLost(FocusEvent e) {\n      if (curDate != null) {\n         saveCurrentNote(); \n      }\n   }\n",
    "69106": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      Exercise s = getExercise(row);\n      if (s != null) {\n         c.setForeground(Color.BLACK);\n      }\n      return c;\n   }\n",
    "69119": "   public void doDBSearch() {\n      Object sel = getSourceBox().getSelectedItem();\n      if (sel instanceof FoodDataSource) {\n         doDBSearch((FoodDataSource)sel);\n      } else {\n         doDBSearch(null);\n      }\n   }\n",
    "69156": "   public void restoreWindow() {\n      setVisible(true);\n      setExtendedState(Frame.NORMAL);\n      toFront();\n   }\n",
    "69168": "   public void goToToday() {\n      setDate(new Date(System.currentTimeMillis()), false);\n   }\n",
    "69174": "   private void copyPreviousDay() {\n//      if (isOkToAddServings(curDate)) {\n\t   Date previousDay = new Date(curDate.getTime() - ONE_DAY);\n      UserManager.getCurrentUser().getFoodHistory().copyConsumedOn(previousDay, curDate);\n\t   notifyObservers();\n//      }\n   }\n",
    "69192": "      public Component customRender(Component c, PrettyTable table, int row, int col) {\n         FoodProxy f = getSearchHit(row).getFoodProxy();\n         if (f != null) {\n            if (col == 0) {\n               c.setForeground(f.getSource().getDisplayColor());\n               if (f.isDeprecated()) {\n                  c.setForeground(Color.LIGHT_GRAY);\n               }\n            }\n         }\n         return c;\n      }\n",
    "69198": "   public void update() {\n      UserManager.getCurrentUser().getExerciseHistory().update(this);\n   }\n",
    "69207": "   public void addExercises(Exercise[] list) {\n      addExercisesToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());\n   }\n",
    "69234": "   public void setDate(Date d, boolean userChanged) {\n      curDate = d;      \n      // getDateTitle().setDate(curDate);\n      getDateTitle().setText(df.format(curDate));\n      validate();\n      getBioMarkersPanel().setDate(d);\n      getServingTable().setTitle(df.format(curDate));\n      if (!userChanged) {\n         getNotesEditor().saveCurrentNote(); \n      }\n      getNotesEditor().setDate(d);\n      asked = false;\n      refreshTime();\n      notifyObservers();\n   }\n",
    "69318": "   public void reload() {\n      load();\n   }\n",
    "69347": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      //Record entry = getUserEntry(row);\n      return c;\n   } \n",
    "69454": "   public void addEntries(Record[] list) {\n      for (int i=0; i<list.length; i++) {\n         add(list[i].copy());\n      }\n   }\n",
    "69485": "    public void removeLayoutComponent(Component comp) {\n        compTable.remove(comp);\n    }\n",
    "69504": "    public Dimension minimumLayoutSize(Container parent) {\n    \tint ncomponents = parent.getComponentCount();\n\t\tif (ncomponents == 0) return new Dimension(1,1);\n\t\tRectangle totalRect = new Rectangle(0,0,1,1);\n\t\tfor ( int i = 0; i < ncomponents; i++ ) {\n\t\t\tComponent c = parent.getComponent(i);\n\t\t\tSpazPosition lp = (SpazPosition)compTable.get(c);\n         Rectangle rect = lp.getMinRectangle();\n         if ( rect != null ) \n         \ttotalRect = totalRect.union(rect); \n\n\t\t}\n\t\treturn new Dimension(totalRect.width,totalRect.height);\n    }\n",
    "69515": "    public void addLayoutComponent(Component comp, Object constraints) {\n        if (constraints instanceof SpazPosition) {\n            SpazPosition cons = (SpazPosition)constraints;\n            setConstraints(comp, cons);\n        } else if (constraints != null) {\n            throw new IllegalArgumentException(\n                \"cannot add to layout: constraint must be a SpazPostion\");\n        }\n    }\n",
    "69519": "    public Dimension maximumLayoutSize(Container target) {\n        return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n    }\n",
    "69523": "    public float getLayoutAlignmentX(Container target) {\n        return 0.5f;\n    }\n",
    "69527": "    public float getLayoutAlignmentY(Container target) {\n        return 0.5f;\n    }\n",
    "69530": "    public void invalidateLayout(Container target) {\n        // Do nothing\n    }\n",
    "69551": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      return c;\n   }\n",
    "69578": "   public void showWindow() {\n      setVisible(true); \n      toFront();\n   }\n",
    "69601": "   public void setExternal(boolean val) {\n      external = val;\n   }\n",
    "69606": "   public Object newInstance(String name) {\n      try {\n         Class c = this.loadClass(name, true);\n         return c.newInstance();\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n      return null;\n   }\n",
    "69631": "   public long getBytesRead() {\n      return bytesRetrieved;\n   }\n",
    "69634": "   public String getKey() {\n      return key;\n   }\n",
    "69636": "   public String getNewValue() {\n      return newValue;\n   }\n",
    "69659": "   public SQLColumnSet getColumns() {\n      return cols;\n   }\n",
    "69660": "    public void addWhere(String name, Object val) {\n        addWhere(name, EQ, val);\n    }\n",
    "69676": "    public void addWhereLike(String name, String val) {\n        where.add(\"upper(\" + name + \") like '\"\n                + escape(val.toString()).toUpperCase() + \"' \");\n    }\n",
    "69689": "    public void addSelection(String field) {\n        items.add(field);\n    }\n",
    "69692": "    protected ResultSet doExecuteQuery(Connection con) throws SQLException {\n        Statement stmt = con.createStatement();\n        String query = this.getQueryString();\n        if (Logger.isDebugEnabled()) {\n           Logger.debug(\"executeQuery() - Statement to be executed: \" + query);\n        }\n\n        results = stmt.executeQuery(query);\n        return results;\n    }\n",
    "69695": "   public void setPrintNewLines(boolean b) {\n      printNewLines  = b;\n      Iterator iter = children.iterator();\n      while (iter.hasNext()) {\n         ((XMLNode)iter.next()).setPrintNewLines(b);\n      }\n   }\n",
    "69701": "   protected String getQueryString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(\"UPDATE \");\n      sb.append(getTableName());\n      sb.append(\" SET \");\n      List names = cols.getNames();\n      List terms = cols.getValues();\n      for (int i=0; i<names.size(); i++) {         \n         Object name = names.get(i);\n         Object term = terms.get(i);\n         if (term == null) {\n            term = \"NULL\"; \n         }\n         sb.append(name.toString());\n         sb.append(\" = '\");\n         sb.append(escape(term.toString()));\n         sb.append(\"' \");\n         if (i < names.size() - 1) {\n            sb.append(\", \");\n         }\n      }\n      sb.append(getWhere());\n      return sb.toString();\n   }\n",
    "69706": "   protected String getQueryString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(\"DELETE FROM \");\n      sb.append(getTableName());\n      sb.append(getWhere());\n      return sb.toString();\n   }\n",
    "69730": "   public void setHgap(int hgap) {\n       this.hgap = hgap;\n   }\n",
    "69735": "   public int getVgap() {\n       return vgap;\n   }\n",
    "69757": "   public void setVgap(int vgap) {\n       this.vgap = vgap;\n   }\n",
    "69767": "   public void removeLayoutComponent(Component comp) {\n      constraints.remove(comp);\n   }\n",
    "69866": "    public DistributorMO setEndPoint(Location endPoint) {\n        this.endPoint = endPoint;\n        return this;\n    }\n",
    "70192": "    public void menuVJBTreeClear() {\n        menuSetDMT.removeAllChildren();\n        menuVJBTreeModel.reload();\n    }\n",
    "70311": "    public void menuVJBTreeRemoveCurrentNode() {\n        TreePath currentSelection = menuVJBTree.getSelectionPath();\n        if (currentSelection != null) {\n            DefaultMutableTreeNode currentNode = \n                    (DefaultMutableTreeNode)\n                    (currentSelection.getLastPathComponent());\n            MutableTreeNode parent = \n                    (MutableTreeNode)(currentNode.getParent());\n            if (parent != null) {\n                menuVJBTreeModel.removeNodeFromParent(currentNode);\n                return;\n            }\n        } \n        // Either there was no selection, or the root was selected.\n    }\n",
    "70455": "    public DefaultMutableTreeNode menuVJBTreeAddObject(Object child) {\n        DefaultMutableTreeNode parentNode = null;\n        TreePath parentPath = menuVJBTree.getSelectionPath();\n        if (parentPath == null) {\n            parentNode = menuSetDMT;\n        } else {\n            parentNode = (DefaultMutableTreeNode)\n                 (parentPath.getLastPathComponent());\n        }\n        return menuVJBTreeAddObject(parentNode, child, true);\n    }\n",
    "70493": "    public TimeLimit timeLimit(TickTock tickTock) {\n        return new TimeLimit(this, tickTock);\n    }\n",
    "70817": "    public TimeSpan approximate(TimeUnit unit) {\n        long nanos = nanoTime();\n        long tenths = (long)Math.floor(Math.log10(nanos));\n        for (int i = 0; ; i++) {\n            int exp = (i + 1) * 3;\n            if (tenths < exp || i == 3 || unit == UNITS[i]) {\n                long div = (long)Math.pow(10, exp - 3);\n                long time = nanos / div;\n                return new TimeSpan(time, UNITS[i]);\n            }\n        }\n    }\n",
    "70823": "    public TimeSpan approximate() {\n        return approximate(null);\n    }\n",
    "70872": "    public boolean isWrapped() {\n        return this.wrappedValue != null;\n    }\n",
    "70880": "    public Object getValueString() {\n        return this.valueString;\n    }\n",
    "70884": "    public Object getTypedValue() {\n        return this.typedValue;\n    }\n",
    "70888": "    public Class getType() {\n        return this.type;\n    }\n",
    "70892": "    public String getTypeName() {\n        return this.typeName;\n    }\n",
    "70898": "    public boolean isPrimitive() {\n        return this.primitive;\n    }\n",
    "70902": "    public Throwable getThrowable() {\n        return this.throwable;\n    }\n",
    "70909": "    protected void writeToBuffer(StringBuffer buffer, int x, boolean indent) {\n        buffer.append(this.getType().getLeft());\n        for (int i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].writeToBuffer(buffer, x + 2, true);\n            if (i < (this.nodes.length - 1)) {\n                buffer.append(\" \");\n            }\n        }\n        buffer.append(this.getType().getRight());\n    }\n",
    "70916": "    public long getEvalTime() {\n        return this.evalTime;\n    }\n",
    "70922": "    public boolean isOK() {\n        return this.throwableType == null;\n    }\n",
    "71014": "    protected void writeToBuffer(StringBuffer buffer, int x, boolean i) {\n        String string = this.isContentString()\n            ? \"\\\"\" + this.getContent() + \"\\\"\"\n            : (this.isContentHolder()\n               ? ((Holder)this.getContent()).toValueString()\n               : String.valueOf(this.getContent()));\n        buffer.append(string);\n    }\n",
    "71023": "    public Object evaluate(Context context) {\n        if (this.isContentSymbol()) {\n            Object value = context.lookup(this.getSymbolContent());\n            if (value == null) {\n                value = Reflector.get().resolveLeafNode(context, this);\n                if (value == null) {\n                    throw new EvaluationException\n                        (\"Unknown symbol or type \" + this.getSymbolContent());\n                }\n            }\n            return value;\n        } else {\n            return this.getContent();\n        }\n    }\n",
    "71705": "    private void addClassNodes() {\n        if (getRealObject() != null) {\n            ClassNode actualClass = new ClassNode(this,\n                                                  getRealObject().getClass(),\n                                                  \"Actual class\");\n            addChild(actualClass);\n        }\n        if (getDeclaredClass() != null) {\n            ClassNode declaredClass = new ClassNode(this,\n                                                    getDeclaredClass(),\n                                                    \"Declared class\");\n            addChild(declaredClass);\n        }\n    }\n",
    "71708": "    private void addFieldListNodes() {\n        for (Class clazz = getActualClass();\n             clazz != null;\n             clazz = clazz.getSuperclass()) {\n            addFieldList(clazz);\n        }\n    }\n",
    "72000": "    public void testMod() {\n        assertEquals(\"Module failed\",\n                     DataHolderFactory.holder(5),\n                     DataHolderFactory.holder(20).mod(DataHolderFactory.holder(15)));\n    }\n",
    "72003": "    public void testMul() {\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Multiplicatio failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));\n    }\n",
    "72005": "    public void testDiv() {\n        assertEquals(\"Division failed\",\n                     DataHolderFactory.holder(100),\n                     DataHolderFactory.holder(20).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Division failed\",\n                     DataHolderFactory.holder(100),\n                     DataHolderFactory.holder(20.0).mul(DataHolderFactory.holder(5.0)));\n    }\n",
    "72007": "    public void testSub() {\n        assertEquals(\"Subtraction failed\",\n                     DataHolderFactory.holder(4),\n                     DataHolderFactory.holder(20).sub(DataHolderFactory.holder(16)));\n        assertEquals(\"Subtraction failed\",\n                     DataHolderFactory.holder(4),\n                     DataHolderFactory.holder(20.0).sub(DataHolderFactory.holder(16.0)));\n    }\n",
    "72010": "    public void testAdd() {\n        assertEquals(\"Addition failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(12).add(DataHolderFactory.holder(8)));\n        assertEquals(\"Addition failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(12.0).add(DataHolderFactory.holder(8.0)));\n    }\n",
    "72016": "    public void setUp() {\n    }\n",
    "72020": "    public void tearDown() {\n    }\n",
    "72294": "\tprivate void populateFields() {\n\t\tfields = editDVD.getFields();\n\t\t//We also need to add any extra fields that may have been added later\n\t\tfields = Field.addMissingFields(fields);\n\t\tupdateTabel();\n\t\tif(editDVD.getPoster() == null) {\n\t\t\tposter.setIcon(new ImageIcon(getClass().getResource(\"/org/dvdcatalog/dvdc/images/poster.png\")));\n\t\t}\n\t\telse {\n\t\t\tposter.setIcon(new ImageIcon(editDVD.getPoster()));\n\t\t}\n\t}\n",
    "72310": "\tprivate void saveFields() throws RuntimeException {\n\t\teditDVD.setFields(fields);\n\t}\n",
    "72311": "\tpublic Class getColumnClass(int c) {\n\t\ttry {\n            return super.getColumnClass (c);\n\t\t} catch (NullPointerException e) {\n\t\t\treturn String.class;\n\t\t}\n\t}\n",
    "72313": "\tpublic void setData(Vector v) {\n\t\tdata = v;\n\t\tfireTableDataChanged();\n\t}\n",
    "72323": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setLayout(new GridLayout(1, 3));\n\n\t\tpreviousButton.addActionListener(this);\n\t\tbuttonPane.add(previousButton);\n\n\t\tnextButton.addActionListener(this);\n\t\tbuttonPane.add(nextButton);\n\n\t\tsaveButton.addActionListener(this);\n\t\tsaveButton.setEnabled(false);\n\t\tbuttonPane.add(saveButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72324": "\tpublic BufferedImage getPoster() {\n\t\treturn poster;\n\t}\n",
    "72326": "\tpublic void run() {\n\t\tif(info != null) {\n\t\t\tinfo.setBar(bar);\n\t\t\tinfo.start();\n\t\t}\n\t\telse if(imdbSearch != null) {\n\t\t\timdbSearch.start();\n\t\t}\n\t}\n",
    "72330": "\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n",
    "72340": "\tprivate Component createInputComponents() {\n\t\tcards = new JPanel(new CardLayout());\n\t\tcards.add(createCard1(), \"INPUT\");\n\t\tcards.add(createCard2(), \"SEARCHING\");\n\t\tcards.add(createCard3(), \"LIST\");\n\t\tcards.add(createCard4(), \"RETRIEVING\");\n\t\tcards.add(createCard5(), \"INFO\");\n\t\treturn cards;\n\t}\n",
    "72341": "\tpublic String getDirector() {\n\t\treturn director;\n\t}\n",
    "72342": "\tprivate Component createCard1() {\n\t\tJPanel p = new JPanel();\n\t\tp.setAlignmentX(0.5f);\n\t\tp.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\t\tJLabel l = new JLabel(\"Movie Title: \");\n\t\timdbSearch = new JTextField(20);\n        imdbSearch.addActionListener (this);\n\n\t\tp.add(l);\n\t\tp.add(imdbSearch);\n\n\t\tJPanel toReturn = new JPanel();\n\t\ttoReturn.setLayout(new BoxLayout(toReturn, BoxLayout.PAGE_AXIS));\n\t\ttoReturn.add(createTopTitle(\"Enter a movietitle to search for\", \"Step 1 of 5\"));\n\t\ttoReturn.add(p);\n\n\t\treturn toReturn;\n\t}\n",
    "72345": "\tpublic String getGenre() {\n\t\treturn genre;\n\t}\n",
    "72350": "\tpublic String getTagline() {\n\t\treturn tagline;\n\t}\n",
    "72354": "\tpublic String getPlot() {\n\t\treturn plot;\n\t}\n",
    "72360": "\tpublic String getRating() {\n\t\treturn rating;\n\t}\n",
    "72365": "\tpublic Class getColumnClass(int c) {\n\t\ttry {\n\t\t\treturn getValueAt(0, c).getClass();\n\t\t} catch (NullPointerException e) {\n\t\t\treturn String.class;\n\t\t}\n\t}\n",
    "72366": "\tpublic String getPosterUrl() {\n\t\treturn posterUrl;\n\t}\n",
    "72367": "\tpublic void setData(Vector v) {\n        if (v instanceof SortedVector) data = v;\n        else {\n            data.clear ();\n\n            for (int i = 0; i < v.size (); i++)\n                data.add (v.get (i));\n        }\n\t\tfireTableDataChanged();\n\t}\n",
    "72369": "    public void addMouseListenerToTableHeader (final JTable table) {\n        final MouseAdapter adapter = new MouseAdapter () {\n            public void mouseClicked (final MouseEvent e) {\n                final TableColumnModel columnModel = table.getColumnModel ();\n                final int x = columnModel.getColumnIndexAtX (e.getX ());\n                final int col = table.convertColumnIndexToModel (x);\n\n                if(e.getClickCount () == 1 && col != -1) {\n                    ((SortedVector)data).sortBy (col);\n                    fireTableDataChanged ();\n                }\n            }\n        };\n        table.getTableHeader ().addMouseListener (adapter);\n    }\n",
    "72371": "\tpublic String getAddress() {\n\t\treturn address;\n\t}\n",
    "72385": "    public int compare (final Object o1, final Object o2) {\n        final Object[] a = (Object[])o1, b = (Object[])o2;\n\n        return ((String)a[col]).compareTo (b[col]);\n    }\n",
    "72387": "    public boolean equals (final Object o) {\n        return o instanceof ColumnComparator && ((ColumnComparator)o).col == col;\n    }\n",
    "72389": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\t\tbuttonPane.setLayout(new FlowLayout());\n\n\t\tbackButton.addActionListener(this);\n\t\tbackButton.setEnabled(false);\n\t\tbuttonPane.add(backButton);\n\n\t\tnextButton.addActionListener(this);\n\t\tbuttonPane.add(nextButton);\n\n\t\tskipButton.addActionListener(this);\n\t\tbuttonPane.add(skipButton);\n\n\t\tcancelButton.addActionListener(this);\n\t\tbuttonPane.add(cancelButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72390": "    public boolean add (final Object o) {\n        final ColumnComparator cc = new ColumnComparator (col);\n\n        for (int i = 0; i < size (); i++) {\n            final int res = cc.compare (get (i), o) * (ascending ? 1 : -1);\n            if (res > 0) {\n                add (i, o);\n                return true;\n            }\n        }\n        return super.add (o);\n    }\n",
    "72391": "    public void sortBy (final int col) {\n        if (this.col == col || isSorted (col)) reverse ();\n        else {\n            this.col = col;\n            ascending = true;\n            if (size () > 1) Collections.sort (this, new ColumnComparator (col));\n        }\n    }\n",
    "72393": "    public void reverse () {\n        ascending = !ascending;\n        final int lastIdx = size () - 1;\n\n        for (int i = 0; i < lastIdx; i++)\n            add (i, remove (lastIdx));\n    }\n",
    "72397": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setLayout(new FlowLayout());\n\n\t\tnewButton.setName(\"new\");\n\t\tbuttonPane.add(newButton);\n\t\teditButton.setName(\"edit\");\n\t\teditButton.setEnabled(false);\n\t\tbuttonPane.add(editButton);\n\t\tdeleteButton.setName(\"delete\");\n\t\tdeleteButton.setEnabled(false);\n\t\tbuttonPane.add(deleteButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72402": "\tprivate JTable createTable() {\n\t\tDVDTableModel dvdModel = new DVDTableModel();\n\t\t//dvdModel.setData(dvdCollection);\n\t\tJTable table = new JTable(dvdModel);\n\t\ttable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        dvdModel.addMouseListenerToTableHeader (table);\n\n\t\treturn table;\n\t}\n",
    "72404": "\tpublic void updateTableData(Vector v) {\n\t\tDVDTableModel model = (DVDTableModel) dvdTable.getModel();\n\t\tVector data = new Vector();\n\t\tIterator i = v.iterator();\n\n\t\twhile (i.hasNext()) {\n\t\t\tDVD dvd = (DVD) i.next();\n\t\t\tdata.add(dvd.toArray());\n\t\t}\n\n\t\tmodel.setData(data);\n\t}\n",
    "72407": "\tpublic void enableEditDeleteButtons() {\n\t\teditButton.setEnabled(true);\n\t\tdeleteButton.setEnabled(true);\n\t}\n",
    "72410": "\tpublic void valueChanged(ListSelectionEvent e) {\n        //Ignore extra messages.\n        if (e.getValueIsAdjusting()) return;\n\n        ListSelectionModel lsm = (ListSelectionModel)e.getSource();\n        if (lsm.isSelectionEmpty()) {\n            //no rows are selected\n        \tmainFrame.disableEditDeleteButtons();\n        \tselectedRow = -1;\n\n        } else {\n        \t// a row has been selected\n             selectedRow = lsm.getMinSelectionIndex();\n             mainFrame.enableEditDeleteButtons();\n        }\n\n\t}\n",
    "72413": "\tpublic void disableEditDeleteButtons() {\n\t\teditButton.setEnabled(false);\n\t\tdeleteButton.setEnabled(false);\n\t}\n",
    "72414": "\tpublic void setPermanentType() {\n\t\tpermanent = true;\n\t}\n",
    "72419": "\tprivate void collectTypes() {\n\t\tboolean foundNewType = true;\n\t\tIterator i = types.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tString t = (String) i.next();\n\t\t\tif(t.equalsIgnoreCase(type)) {\n\t\t\t\tfoundNewType = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(foundNewType) {\n\t\t\tLog.print(3, \"New type found, added to the list: \" + type);\n\t\t\ttypes.add(type);\n\t\t}\n\t}\n",
    "72420": "\tpublic void mouseClicked(MouseEvent e){\n\t\tif (e.getClickCount() == 2){\n\t\t\tDVD dvd = (DVD)dvdCollection.get(selectedRow);\n\t\t\topenEditWindow(dvd);\n\t\t}\n\t}\n",
    "72427": "\tpublic void nextPage(ImdbInfo[] imdbAddresses) {\n\t\tCardLayout cl = (CardLayout) (cards.getLayout());\n\t\tcl.next(cards);\n\t\tcardNr++;\n\n\t\tString[] moviesFound = new String[imdbAddresses.length];\n\t\tfor(int i = 0; i < imdbAddresses.length; i++) {\n\t\t\tmoviesFound[i] = imdbAddresses[i].getTitle();\n\t\t}\n\n        //Arrays.sort (moviesFound, new RelevanceComparator (imdbSearch.getText ()));\n\n\t\tlist.setListData(moviesFound);\n\n\t\tthis.imdbAddresses = imdbAddresses;\n\n\t\tbackButton.setEnabled(true);\n\t\tnextButton.setEnabled(true);\n\t}\n",
    "72436": "\tpublic int compareTo(Object o) {\n\t\tif (o instanceof DVD) {\n\t\t\tDVD d = (DVD) o;\n\t\t\tField f = (Field) fields.get(0);\n\t\t\tField f2 = (Field) d.getFields().get(0);\n\t\t\treturn f.getValue().compareTo(f2.getValue());\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "72442": "\tpublic void setFromWizard(boolean wiz) {\n\t\twizard = wiz;\n\t}\n",
    "72448": "\tpublic boolean isFromWizard() {\n\t\treturn wizard;\n\t}\n",
    "72463": "\tpublic void enableMainWindow() {\n\t\tmainFrame.setEnabled(true);\n\t\tmainFrame.setVisible(true);\n\t}\n",
    "72471": "\tpublic void dvdDataUpdated() {\n\t\tCollections.sort(dvdCollection);\n\t\tmainFrame.updateTableData(dvdCollection);\n\t}\n",
    "72479": "\tpublic void addDVD(DVD d) {\n\t\tdvdCollection.add(d);\n\t}\n",
    "72487": "\tpublic boolean hasNextDVD() {\n\t\treturn (selectedRow < dvdCollection.size()-1);\n\t}\n",
    "72498": "\tpublic boolean hasPreviousDVD() {\n\t\treturn (selectedRow > 0);\n\t}\n",
    "72555": "    public void next() {\n        Event e = new Event();\n        e.type = Event.NEXT;\n        e.time = System.currentTimeMillis() + delay;\n        queue.add(e);\n    }\n",
    "72562": "    public void poke(int channel) {\n        Event e = new Event();\n        e.type = Event.POKE;\n        e.channel = channel;\n        e.time = System.currentTimeMillis() + delay;\n        queue.add(e);\n    }\n",
    "72565": "    public char getChannel(int channel) {\n        synchronized (scopes) {\n            return levels[(int)scopes[channel]];\n        }\n    }\n",
    "72570": "    public String getAllChannels() {\n        StringBuffer sb = new StringBuffer();\n        for (int n = 0; n < scopes.length; n++) {\n            sb.append(getChannel(n));\n        }\n        return sb.toString();\n    }\n",
    "72667": "    public double getInitialVolume(int track) {\n    \treturn initialTrackVolume[track];\n    }\n",
    "72680": "    public int getTrackCount() {\n        return getPatternAtPos(0).getTrackCount();\n    }\n",
    "72830": "    private void loadList(LineNumberReader lnr) throws IOException {\n        position = -1;\n        list = new ArrayList<String>();\n        String line = null;\n        while ((line = lnr.readLine()) != null) {\n            line = line.trim();\n            File file = new File(line);\n            if (file.exists() && file.isFile())\n                list.add(line);\n        }\n    }\n",
    "72842": "    public void remove() {\n        list.remove(position);\n    }\n",
    "72849": "    private PlayerThread createPlayerThread(Module module) {\n        Player player = new Player();\n        try {\n            player.init(\n                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),\n                INTERPOLATE);\n            player.load(module);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        PlayerThread playerthread = new PlayerThread(player);\n        playerthread.pause(true);\n        return playerthread;\n    }\n",
    "72852": "    private Module loadModule(int nextModule) {\n        int mc = fileList.size();\n        while (nextModule <= 0) nextModule += mc;\n        try {\n            theUrl = new URL(protocol, host, port, fileList.get((nextModule + mc) % mc));\n            return ModuleLoader.getModuleLoader(theUrl).getModule();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "72854": "    private ThreadedPlayer createPlayer(Module module) {\n        ThreadedPlayer player = new ThreadedPlayer();\n        try {\n            player.init(\n                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),\n                INTERPOLATE);\n            player.load(module);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        player.pause(true);\n        return player;\n    }\n",
    "72869": "        public void quit() {\n            run = false;\n        }\n",
    "72871": "    public void savePlayList() throws IOException {\n        savePlayList(new File(playListFile),playList);\n        Logger.debug(\"Saved playlist: \" + playListFile);\n    }\n",
    "72996": "    public void start() {\n        running = true;\n        t = new Thread(this);\n        t.start();\n    }\n",
    "72998": "    public void stop() {\n        running = false;\n    }\n",
    "73002": "    public boolean isRunning() {\n        return running;\n    }\n",
    "73003": "    public void pause(boolean pause) {\n        paused = pause;\n    }\n",
    "73007": "    public boolean isPaused() {\n        return paused;\n    }\n",
    "73009": "    public boolean hasFailed() {\n        return error;\n    }\n",
    "73012": "    public Throwable getFailiureCause() {\n        return errorCause;\n    }\n",
    "73085": "        public void setMute(boolean mute) {\n            this.mute = mute;\n        }\n",
    "73130": "    public boolean init(Output output, boolean interpolate) {\n        out = output;\n        lowLevelMixerClass = interpolate ? InterpolatingMixer.class : FastMixer.class;\n        return true;\n    }\n",
    "73132": "    public boolean load(String fileName) throws InvalidFormatException, IOException {\n        ModuleLoader ml = ModuleLoader.getModuleLoader(new File(fileName));\n        Module module = ml.getModule();\n        return load(module);\n    }\n",
    "73133": "    public boolean load(Module module) {\n        int tracks = module.getPatternAtPos(0).getTrackCount();\n\n        Mixer mixer = new DefaultMixer(out, lowLevelMixerClass, tracks);\n\n        ms = new ModuleState(module, mixer);\n\n        // do some mixer initialization...\n        mixer.setAmplification(getDefaultAmplification());\n\n        return out.open();\n    }\n",
    "73135": "    public boolean play() throws PlayerException {\n        return ms.play();\n    }\n",
    "73140": "    public ModuleState getModuleState() {\n        return ms;\n    }\n",
    "73141": "    public Module getModule() {\n        return getModuleState().getModule();\n    }\n",
    "73142": "    public double getDefaultAmplification() {\n        return getModuleState().getModule().getPatternAtPos(0).getTrackCount() / 4.0;\n    }\n",
    "73220": "    private void writeData(byte[] data, int ofs, int len) {\n        int count = 0;\n        int written = 0;\n        while (written < len) {\n            written += sdl.write(data, ofs + written, len - written);\n\n            // take a litle break if we couldn't write everything in 100\n            // tries...\n            count++;\n            if (count >= 100) {\n                try { Thread.sleep(10); } catch (InterruptedException e) { }\n                count = 0;\n            }\n        }\n    }\n",
    "74678": "\tprotected CatalogInquiry getCatalogService(){\n\t\treturn catalogService;\n\t}\n",
    "74681": "\tprotected AccountManagement getAccountService(){\n\t\treturn accountService;\n\t}\n",
    "74685": "\tprotected OrderEntry getOrderService(){\n\t\treturn orderService;\n\t}\n",
    "76469": "    public void shutdownServices() {\n\tif(services==null) return;\n\n        for(Iterator it = services.iterator();\n            it.hasNext();){\n               MPPlugin serv = (MPPlugin)it.next();\n\t       // Shutdown service\n\t       serv.shutdown();\n\t}\n\n\tservices = null;\n    }\n",
    "76483": "    private String getLocationString(SAXParseException ex) {\n\tStringBuffer str = new StringBuffer();\n\n\tString systemId = ex.getSystemId();\n\tif (systemId != null) {\n\t    int index = systemId.lastIndexOf('/');\n\t    if (index != -1) \n\t\tsystemId = systemId.substring(index + 1);\n\t    str.append(systemId);\n\t}\n\tstr.append(':');\n\tstr.append(ex.getLineNumber());\n\tstr.append(':');\n\tstr.append(ex.getColumnNumber());\n\n\treturn str.toString();\n\n    } // getLocationString(SAXParseException):String\n",
    "76485": "    public String getPassword() {\n        return password;\n    }\n",
    "76487": "  public void finished() {\n    workers.removeElement(this);\n    workersStart.remove(this);\n  }\n",
    "76489": "    public void setPassword(String newPassword) {\n        this.password = newPassword;\n    }\n",
    "76490": "  public void interrupt() {\n    Thread t = threadVar.get();\n    if (t != null) {\n      t.interrupt();\n    }\n    threadVar.clear();\n  }\n",
    "76492": "    public String getUserid() {\n        return userid;\n    }\n",
    "76493": "  public Object get() {\n    while (true) {  \n      Thread t = threadVar.get();\n      if (t == null) {\n\treturn getValue();\n      }\n      try {\n\tt.join();\n      }\n      catch (InterruptedException e) {\n\tThread.currentThread().interrupt(); // propagate\n\treturn null;\n      }\n    }\n  }\n",
    "76495": "    public void setUserid(String newUserid) {\n        this.userid = newUserid;\n    }\n",
    "76496": "  public void start(){\n    startThread.start();\n  }\n",
    "76498": "    public String getConnectUrl() {\n        return connectUrl;\n    }\n",
    "76501": "    public void setConnectUrl(String newConnectUrl) {\n        this.connectUrl = newConnectUrl;\n    }\n",
    "76505": "    public String getJdbcDriver() {\n        return jdbcDriver;\n    }\n",
    "76507": "    public void setJdbcDriver(String newJdbcDriver) {\n        this.jdbcDriver = newJdbcDriver;\n    }\n",
    "76525": "    public boolean isDoPopup() {\n        \n        return this.doPopup;\n    }\n",
    "76530": "    public void setDoPopup(boolean doPopup) {\n        this.doPopup = doPopup;\n    }\n",
    "76542": "    public File translateDocument(String inputDocument) throws Exception {\n\n        try {\n            documentTree = FileUtils.getInstance().stringToDocument(\n                    inputDocument);\n        } catch (Exception e) {\n            throw e;\n        }\n\n        result = new StringBuffer();\n        result.append(\"(deffacts patientSummary\");\n        result.append(\"\\n\");\n        buildResult(documentTree.getFirstChild(), \"\");\n        result.append(\"\\n\");\n        result.append(\")\");\n        File f = null;\n        try {\n            f = this.createFileFromStr(result.toString());\n        } catch (Exception e) {\n            throw e;\n        }\n        return f;\n\n    }\n",
    "76545": "    private File createFileFromStr(String str) throws Exception {\n        File file = new File(\"fileForIE.clp\");\n        FileWriter fileWriter;\n        try {\n            fileWriter = new FileWriter(file);\n            BufferedWriter out = new BufferedWriter(fileWriter);\n            out.write(str);\n            out.close();\n        } catch (IOException e) {\n            throw e;\n        }\n        return file;\n    }\n",
    "76607": "    private String getCurrentTime() {\n\n        Date now = new Date();\n        SimpleDateFormat df1 = new SimpleDateFormat(\"yyyyMMdd\");\n\n        return df1.format(now);\n    }\n",
    "76618": "    private String generateDocCode() {\n        // TO DO: come up with document code generation mechanism\n        return \"111\";\n    }\n",
    "76629": "    private String generateDocCodeSystem() {\n        // come up with document code generation mechanism\n        return \"111\";\n    }\n",
    "76670": "    private void registerIDocImport(IDocumentImport iDocumentImport) {\n        this.iDocumentImport = iDocumentImport;\n\n    }\n",
    "76672": "    private void registerIDocExport(IDocumentExport iDocumentExport) {\n        this.iDocumentExport = iDocumentExport;\n\n    }\n",
    "76675": "    private void registerIInference(IInference iInference) {\n        this.iInference = iInference;\n\n    }\n",
    "76679": "    private void registerIAuditLog(IAuditLog iAuditLog) {\n        this.iAuditLog = iAuditLog;\n\n    }\n",
    "76685": "    public boolean hasNext() {\n        return (position < length);\n    }\n",
    "76774": "    public PrimitiveType primitive(String name) {\n        return new PrimitiveType(this, name);\n    }\n",
    "76778": "    public PrimitiveType primitive(Token token) {\n        return primitive(token.getText());\n    }\n",
    "76780": "    public PrimitiveType primitive(Symbol symbol) {\n        return primitive(symbol.toString());\n    }\n",
    "76787": "    protected void visit(List nodes) {\n        Iterator iNodes = nodes.iterator();\n        while (iNodes.hasNext())\n            ((Node) iNodes.next()).apply(this);\n    }\n",
    "76790": "    protected void visit(Node node) {\n        node.apply(this);\n    }\n",
    "76794": "    protected void warning(String msg) {\n        logger.warning(msg);\n        // _errOut.println(msg);\n    }\n",
    "76795": "    public boolean hasErrors() {\n        return _errors;\n    }\n",
    "76804": "    public String getRecommendations(String patientSummary) {\n\n        helper = new SimpleWebServiceHelper();\n        String result = null;\n        try {\n            result = helper.getRecommendations(patientSummary);\n        } catch (EgadssException ex) {\n            logger.log(Level.SEVERE, ex.toString(), ex);\n        }\n        return result;\n\n    }\n",
    "76847": "    private void startSystem() throws Exception {\n        try {\n            this.createComponents();\n\n            this.initializeComponents();\n            log.info(\"EGADSS SYSTEM HAS BEEN STARTED\");\n\n        } catch (Exception e) {\n            throw e;\n        }\n\n    }\n",
    "76930": "    public String velocityClinicalGuideline()throws EgadssException {\n        if(!initialized)\n    throw new EgadssException(\"Configuration must be initialized before fields can be accessed\");\n        return this.velocityClinicalGuideline;\n    }\n",
    "76934": "    public void testValidateDocumentCase1() {\n        try {\n\n            if (documentValidator.validateDocument(FileUtils.getInstance()\n                    .filetoString(\n                            new File(Configuration.getInstance()\n                                    .testPatientXmlUri())), Configuration\n                    .getInstance().patientSummarySchemaUri())) {\n                assertTrue(true);\n            } else\n                assertTrue(false);\n        } catch (Exception e) {\n\n            logger.log(Level.WARNING, \"Case 1 Exception in DocumentValidator.validateDocument method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76946": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfig.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.fine(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76949": "    public void testInitialize() {\n        try {\n            iConfig.initialize(docImpExCompMap);\n            assertTrue(true);\n            logger.fine(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger\n                    .log(Level.WARNING,\n                            \"Exception in testing initialize method: \"\n                                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76952": "    public void testTerminate() {\n        // try{\n        // iConfig.terminate();\n        // logger.fine(\"Testing of terminate method was successful\");\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // logger.log(Level.WARNING, \"Exception in testing initialize method:\n        // \"+e.getMessage(), e);\n        // }\n    }\n",
    "76956": "    public void testImportDocument() {\n        try {\n\n            iDocumentImport.importDocument(xmlDocumentStr);\n            logger.fine(\"Testing of importDocument method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            assertTrue(false);\n            logger.log(Level.WARNING, \"Exception in testing importDocument: \"\n                    + e.getMessage(), e);\n        }\n\n    }\n",
    "76959": "    public void testExportDocument() {\n\n        try {\n            outputFromIeFile = new File(Configuration.getInstance()\n                    .patientResultInstancesClpUri());\n            iDocumentImport.importDocument(xmlDocumentStr);\n            iDocumentExport.exportDocument(outputFromIeFile);\n            logger.fine(\"Testing of exportDocument method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            assertTrue(false);\n            logger.log(Level.WARNING, \"Exception in testing exportDocument: \"\n                    + e.getMessage(), e);\n        }\n\n    }\n",
    "76964": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigTransController.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.fine(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76968": "    public void testInitialize() {\n        try {\n            iConfigTransController.initialize(transControllerCompMap);\n            assertTrue(true);\n            logger.fine(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger\n                    .log(Level.WARNING,\n                            \"Exception in testing initialize method: \"\n                                    + e.getMessage(), e);\n        }\n    }\n",
    "76973": "    public void testParseKnowledgeModuleForXPath() {\n        try {\n\n            preprocessor.parseKnowledgeModuleForXPath(knowledgeModuleFile);\n            logger.fine(\"Testing of parseKnowledgeModuleForXPath method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing preprocessXPath: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n\n        }\n\n    }\n",
    "76975": "    public void testTerminate() {\n        // try{\n        // iConfigTransController.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // }\n    }\n",
    "76980": "    // public void testGetRecommendations() {\n    //\n    // this.testInitialize();\n    //\t\t\n    // //assert knowledge module into InferenceEngine\n    // try{\n    // ie.assertKnowledgeModule(testGuideline, \"Immunizations\");\n    // }catch(Exception e){\n    // assertTrue(false);\n    // }\n    //\t\t\n    // try{\n    //\t\t\t\n    //\t\t\t\n    // resultsDocument=iTrans.getRecommendations(inputDocument);\n    //\t\t\t\n    // assertTrue(true);\n    // }\n    // catch(Exception e){\n    // assertTrue(false);\n    // }\n    // }\n",
    "76987": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigDataStorage.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.info(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76990": "    public void testInitialize() {\n        try {\n            iConfigDataStorage.initialize(dataStorageComMap);\n            assertTrue(true);\n            logger.info(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing initialize method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76991": "    public void testWriteLogEntry() {\n        try {\n            iAuditLog.writeLogEntry(logEntry);\n            logger.info(\"Testing of writeLogEntry method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing writeLogEntry method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76992": "    public void testTerminate() {\n        // try{\n        // docImpEx.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // }\n    }\n",
    "76995": "    public void testGenerateAuditReport() {\n        try {\n            report = iAudit.generateAuditReport();\n            if (!(report == null)) {\n                logger.fine(\"Audit report string: \" + report);\n                logger\n                        .info(\"Testing of generateAuditReport method was successful\");\n                assertTrue(true);\n            } else {\n                assertTrue(false);\n            }\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing generateAuditReport method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n\n    }\n",
    "76997": "    public void testSetAndGetAuditingMode() {\n        try {\n            iAudit.setAuditingMode(\"privacy mode\");\n            if ((iAudit.getAuditingMode()).equals(\"privacy mode\")) {\n                logger\n                        .info(\"Testing of setAuditingMode and getAuditingMode methods was successful\");\n                assertTrue(true);\n            } else {\n                assertTrue(false);\n            }\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing setAuditingMode method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n\n    }\n",
    "77002": "    public void testShutSystemDown() {\n        // TO DO: figure out how to test methods that terminate the\n        // application...\n\n        \n\n    }\n",
    "77005": "    public void testViewSystemConfig() {\n        try {\n            config = iSysConfig.viewSystemConfig();\n            logger.fine(\"Config string: \" + config);\n            logger.info(\"Testing of viewSystemConfig method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing viewSystemConfig method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77008": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigConfigManager.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.info(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77015": "    public void testInitialize() {\n        try {\n            iConfigConfigManager.initialize(configManagerCompMap);\n            assertTrue(true);\n            logger.info(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing initialize method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77021": "    public void testTerminate() {\n        // try{\n        // iConfigConfigManager.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // assertTrue(false);\n        // }\n    }\n",
    "81092": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t}\n",
    "81105": "    public void trace(boolean onoff) {\n      try {\n        serverControl.trace(onoff);\n      } catch (Exception e) {\n          e.printStackTrace();\n        }\n    }\n",
    "81107": "    public void shutdown() {\n        try {\n            serverControl.shutdown();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "81108": "    public void start() {\n        try {\n\t\t\tserverControl.start(pw);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "81112": "\t public Connection getConnection(String dbUrl, Properties properties) {\n\t\t Connection conn = null;\n\t\t try {\n\t\t\tpw.println(\"[NsSampleWork] Thread id - \"+thread_id + \"; requests database connection, dbUrl =\"+dbUrl);\n\t\t\tconn = DriverManager.getConnection(dbUrl, properties);\n\t\t  } catch (Exception e) {\n\t\t\t System.out.println(\"[NsSampleWork] Thread id - \"+ thread_id + \"; failed to get database connection. Exception thrown:\");\n\t\t\t e.printStackTrace();\n\t\t    }\n\t\t  return conn;\n\t }\n",
    "81114": "\t public void setIsolationLevel(Connection conn, int level) {\n\t\t try {\n\t\t\tconn.setTransactionIsolation(level);\n\t\t } catch (Exception e) {\n\t\t\t pw.println(\"[NsSampleWork] Thread id - \"+ thread_id +\"; setIsolationLevel failed. Exception thrown: \");\n\t\t\t e.printStackTrace();\n\t\t   }\n\t }\n",
    "81131": "\tpublic long length() throws SQLException {\n\t\treturn dataLength;\n\t\t\n\t}\n",
    "81443": "\tprotected byte getCurrChainState() {\n\n\t\tif (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)\n\t\t\treturn DssConstants.DSS_NOCHAIN;\n\n\t\tif (dssIsChainedWithSameID)\n\t\t\treturn DssConstants.DSSCHAIN_SAME_ID;\n\n\t\treturn DssConstants.DSSCHAIN;\n\n\t}\n",
    "81557": "\tprotected void endDss() {\n\t\tendDss(true);\n\t}\n",
    "81745": "\tprivate int getCorrelationID() {\n\n\t\tint cId;\n\t\tif (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {\n\t\t\tif (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)\n\t\t\t// then we have to use the last correlation id we sent.\n\t\t\t\tcId = previousCorrId;\n\t\t\telse\n\t\t\t// get correlation id as normal.\n\t\t\t\tcId = nextCorrelationID++;\n\t\t}\n\t\telse {\n\t\t// must be the case that this is the first DSS we're\n\t\t// writing for this connection (because we haven't\n\t\t// called \"endDss\" yet).  So, get the corr id as\n\t\t// normal.\n\t\t\tcId = nextCorrelationID++;\n\t\t}\n\n\t\treturn cId;\n\n\t}\n",
    "82376": "\tpublic String getHtmlLabelledMessageInstance(LocalizedResource localUtil, String key, String id) {\n\n\t\tif (id == null)\n\t\t\tid = \"\";\n\n\t\treturn (\"<label for='\" + id + \"'>\" + localUtil.getTextMessage(key) +\n\t\t\t\"</label>\");\n\n\t}\n",
    "82378": "\tprivate void printAsContentHeader(String str) {\n\n\t\tout.println(\"<a name=\\\"navskip\\\"></a><h2>\" + str + \"</h2>\");\n\t\treturn;\n\n\t}\n",
    "82382": "\tprivate String escapeSingleQuotes(String str) {\n\n\t\tif ((str == null) || (str.indexOf(\"'\") < 0))\n\t\t\treturn str;\n\n\t\tchar [] cA = str.toCharArray();\n\n\t\t// Worst (and extremely unlikely) case is every \n\t\t// character is a single quote, which means the\n\t\t// escaped string would need to be 4 times as long.\n\t\tchar [] result = new char[4*cA.length];\n\n\t\tint j = 0;\n\t\tfor (int i = 0; i < cA.length; i++) {\n\n\t\t\tif (cA[i] == '\\'') {\n\t\t\t\tresult[j++] = '&';\n\t\t\t\tresult[j++] = '#';\n\t\t\t\tresult[j++] = '3';\n\t\t\t\tresult[j++] = '9';\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult[j++] = cA[i];\n\n\t\t}\n\n\t\treturn new String(result, 0, j);\n\n\t}\n",
    "82653": "\tprivate String  buildPreformattedSqlerrmc(SQLException se) {\n\t\tif (se == null)\n\t\t\treturn \"\";\n\t\t\n\t\tStringBuffer sb = new StringBuffer(); \n\t\t // String buffer to build up message\n\t\tdo {\n\t\t\tsb.append(se.getLocalizedMessage());\n\t\t\tse = se.getNextException();\n\t\t\tif (se != null)\n\t\t\t\tsb.append(SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER + \n\t\t\t\t\t\t\"SQLSTATE: \" + se.getSQLState());\n\t\t} while (se != null);\t\t\t\n\t\treturn sb.toString();\t\t\n\t}\n",
    "82659": "\tprivate String buildTokenizedSqlerrmc(EmbedSQLException se) {\n\t\t\n\t\tString sqlerrmc = \"\";\n\t\tdo {\n\t\t\tString messageId = se.getMessageId();\n\t\t\t// arguments are variable part of a message\n\t\t\tObject[] args = se.getArguments();\n\t\t\tfor (int i = 0; args != null &&  i < args.length; i++)\n\t\t\t\tsqlerrmc += args[i] + SQLERRMC_TOKEN_DELIMITER;\n\t\t\tsqlerrmc += messageId;\n\t\t\tse = (EmbedSQLException) se.getNextException();\n\t\t\tif (se != null)\n\t\t\t{\n\t\t\t\tsqlerrmc += SQLERRMC_MESSAGE_DELIMITER + se.getSQLState() + \":\";\t\t\t\t\n\t\t\t}\n\t\t} while (se != null);\n\t\treturn sqlerrmc;\n\t}\n",
    "83118": "\tprivate void finalizeChain() throws DRDAProtocolException {\n\n\t\twriter.finalizeChain(reader.getCurrChainState(), getOutputStream());\n\t\treturn;\n\n\t}\n",
    "83491": "    public int getTransactionTimeout() throws XAException {\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceEntry(this, \"getTransactionTimeout\");\n        }\n        exceptionsOnXA = null;\n        if (conn_.isPhysicalConnClosed()) {\n            connectionClosedFailure();\n        }\n\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceExit(this, \"getTransactionTimeout\", 0);\n        }\n        return 0; // we don't support transaction timeout\n    }\n",
    "83501": "    public boolean setTransactionTimeout(int seconds) throws XAException {\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceExit(this, \"setTransactionTimeout\", false);\n        }\n        exceptionsOnXA = null;\n        return false; // we don't support transaction timeout in our layer.\n        /* int rc = xaSetTransTimeOut(seconds);\n           if (rc != XAResource.XA_OK)\n             throwXAException(rc); */\n    }\n",
    "84264": "    public String getCatalogName(int column) throws SqlException {\n        checkForClosedStatement();\n        checkForValidColumnIndex(column);\n        return \"\";\n    }\n",
    "84396": "    public void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {\n        if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {\n            agent_.sectionManager_.holdPKGNAMCBytes = b;\n        } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {\n            agent_.sectionManager_.noHoldPKGNAMCBytes = b;\n        }\n    }\n",
    "84636": "    public boolean isPhysicalConnClosed() {\n    return !open_ && !availableForReuse_; \n   }\n",
    "84681": "    public void setPKGNAMCBytes(byte[] b) {\n        if (isGenerated) {\n            PKGNAMCBytes = b;\n        } else {\n            agent_.sectionManager_.setPKGNAMCBytes(b, resultSetHoldability_);\n        }\n    }\n",
    "84794": "    public Object run() {\n        this.systemProperties_ = System.getProperties();\n        return this.systemProperties_;\n    }\n",
    "84802": "    public Connection getConnection() throws SQLException {\n        return getConnection(user, password);\n    }\n",
    "84803": "    public Connection getConnection(String user, String password) throws SQLException {\n        // Jdbc 2 connections will write driver trace info on a\n        // datasource-wide basis using the jdbc 2 data source log writer.\n        // This log writer may be narrowed to the connection-level\n        // This log writer will be passed to the agent constructor.\n\n        LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection(\"_sds\");\n        updateDataSourceValues(tokenizeAttributes(connectionAttributes, null));\n        return new NetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false);\n    }\n",
    "84869": "\tprotected void runTestSet() throws T_Fail {\n\n\t\t// Set up the expected error handling\n\t\ttry {\n\t\t\t\n\t\t\tS001();\n\t\t\tS002();\n\t\t\tS003();\n\t\t\tS004();\n\t\t\tS005();\n\t\t\tS007();\n\t\t\tS008();\n\n\t\t\tM001();\n\t\t\tM002();\n\t\t\tM003();\n\t\t\tM004();\n\t\t\t\n\n\t\t} catch (StandardException se) {\n\n\t\t\tthrow T_Fail.exceptionFail(se);\n\n\t\t}\n\t}\n",
    "84901": "\tpublic void clearIdentity() {\n\t\tkeyValue = null;\n\t}\n",
    "84903": "\tpublic Object getIdentity() {\n\t\treturn keyValue;\n\t}\n",
    "84907": "\tpublic void lockEvent(Latch lockInfo) {\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(lockInfo.getQualifier() == null);\n\n\t\tlatch = lockInfo;\n\n\t\tcount++;\n\t}\n",
    "84913": "\tpublic void unlockEvent(Latch lockInfo) {\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(lockInfo.getQualifier() == null);\n\t\t\n\t\tcount--;\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(count >= 0);\n\t\tlatch = null;\n\t}\n",
    "84927": "\tpublic boolean isDirty() {\n\t\tsynchronized (this) {\n\t\t\treturn isDirty;\n\t\t}\n\t}\n",
    "84948": "\tprotected String getModuleToTestProtocolName() {\n\t\treturn org.apache.derby.iapi.reference.Module.CacheFactory;\n\t}\n",
    "84958": "\tprotected void t_findCachedFail(CacheManager cm, Object key) throws StandardException, T_Fail {\n\t\tCacheable entry = cm.findCached(key);\n\t\tif (entry != null) {\n\t\t\tthrow T_Fail.testFailMsg(\"found cached item unexpectedly\");\n\t\t}\n\t}\n",
    "84959": "\tprotected Cacheable t_findCachedSucceed(CacheManager cm, Object key) throws StandardException, T_Fail {\n\t\tCacheable entry = cm.findCached(key);\n\t\tif (entry == null) {\n\t\t\tthrow T_Fail.testFailMsg(\"expected item to be in cache\");\n\t\t}\n\n\t\tif (!entry.getIdentity().equals(key))\n\t\t\tthrow T_Fail.testFailMsg(\"item returned does not match key\");\n\t\treturn entry;\n\t}\n",
    "84961": "\tprotected void t_findFail(CacheManager cm, Object key) throws T_Fail, StandardException {\n\t\tCacheable entry = cm.find(key);\n\t\tif (entry != null) {\n\t\t\tthrow T_Fail.testFailMsg(\"found item unexpectedly\");\n\t\t}\n\t}\n",
    "84963": "\tprotected Cacheable t_findSucceed(CacheManager cm, Object key) throws T_Fail, StandardException {\n\t\tCacheable entry = cm.find(key);\n\t\tif (entry == null) {\n\t\t\tthrow T_Fail.testFailMsg(\"expected item to be found\");\n\t\t}\n\t\tif (!entry.getIdentity().equals(key))\n\t\t\tthrow T_Fail.testFailMsg(\"item returned does not match key\");\n\n\t\treturn entry;\n\t}\n",
    "84995": "\tprotected boolean FAIL(String msg) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"] FAIL - \" + msg);\n\t\treturn false;\n\t}\n",
    "84996": "\tprotected boolean PASS(String testName) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"] Pass - \"+shortModuleToTestName +\" \" + testName);\n\t\treturn true;\n\t}\n",
    "84997": "\tpublic void REPORT(String msg) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"]     \" + msg);\n\t}\n",
    "85040": "\tprotected void joinSetupTest() throws T_Fail {\n\n\t\tT_Fail.T_ASSERT(factory != null, \"raw store factory not setup \");\n\t\tT_Fail.T_ASSERT(contextService != null, \"Context service not setup \");\n\t\tT_Fail.T_ASSERT(commonContainer != -1, \"common container not setup \");\n\n\t\tt_util = new T_Util(factory, lf, contextService);\n\n\t}\n",
    "85098": "\tpublic Page t_getLastPage(ContainerHandle c) throws T_Fail, StandardException {\n\n\t\tPage page = c.getFirstPage();\n\t\tif (page != null)\n\t\t{\n\t\t\tPage nextPage;\n\t\t\twhile((nextPage = c.getNextPage(page.getPageNumber())) != null)\n\t\t\t{\n\t\t\t\tpage.unlatch();\n\t\t\t\tpage = nextPage;\n\t\t\t}\n\t\t}\n\n\t\treturn page;\n\t}\n",
    "85100": "\tpublic Page t_getPage(ContainerHandle c, long pageNumber) throws T_Fail, StandardException {\n\n\t\tPage page = c.getPage(pageNumber);\n\t\tif (page == null)\n\t\t\tthrow T_Fail.testFailMsg(\"fail to get page \" + pageNumber + \" from container \" + c);\n\n\t\tif (page.getPageNumber() != pageNumber)\n\t\t\tthrow T_Fail.testFailMsg(\"page expected to have page number \" +\n\t\t\t\tpageNumber + \", has \" + page.getPageNumber() + \" Container \" + c);\n\n\t\treturn page;\n\t}\n",
    "85104": "\tpublic Page t_addPage(ContainerHandle c) throws T_Fail, StandardException {\n\n\t\tPage page = c.addPage();\n\n\t\tif (page == null)\n\t\t\tthrow T_Fail.testFailMsg(\"addPage() returned null\");\n\n\t\treturn page;\n\t}\n",
    "85120": "\tpublic void t_genRandomFile(String fileName, String mode, int size) throws T_Fail {\n\n\t\tRandomAccessFile iFile = null;\n\t\ttry {\n\t\t\tiFile = new RandomAccessFile(fileName, mode);\n\t\t\tfor (int i = 0; i < size; i++){\n\t\t\t\tbyte b = (byte) (i & 0xff);\n\t\t\t\tb = (byte) (((b >= ' ') && (b <= '~')) ? b : ' ');\n\t\t\t\tiFile.write(b);\n\t\t\t}\n\t\t\tiFile.close();\n\t\t} catch (FileNotFoundException fnfe) {\n\t\t\tthrow T_Fail.testFailMsg(\"cannot create new file\");\n\t\t} catch (IOException ioe) {\n\t\t\tthrow T_Fail.testFailMsg(\"io error, test failed\");\n\t\t}\n\n\t}\n",
    "85124": "\tpublic FormatableBitSet getValidColumns() {\n\t\treturn validColumns;\n\t} \n",
    "85127": "\tpublic boolean needsRowLocation() {\n\t\treturn false;\n\t}\n",
    "85129": "\tpublic void rowLocation(RowLocation rl) {\n\n\t\trl = null;\n\t}\n",
    "85366": "\tprotected void runTestSet() throws T_Fail {\n\n\t\t// get a utility helper\n\n\t\tContextManager cm1 = contextService.newContextManager();\n\t\tcontextService.setCurrentContextManager(cm1);\n\n\t\ttry {\n\n\t\t\trunCostEstimationTests();\n\t\t\trunAllocationTests();\n\n\t\t} catch (StandardException se) {\n\n\t\t\tcm1.cleanupOnError(se);\n\t\t\tthrow T_Fail.exceptionFail(se);\n\t\t}\n\t\tfinally {\n\n\t\t\tcontextService.resetCurrentContextManager(cm1);\n\t\t}\n\t}\n",
    "85374": "\tprotected void joinSetupTest() throws T_Fail {\n\n\t\tT_Fail.T_ASSERT(factory != null, \"raw store factory not setup \");\n\t\tT_Fail.T_ASSERT(lf != null, \"Lock factory not setup \");\n\t\tT_Fail.T_ASSERT(contextService != null, \"Context service not setup \");\n\n\t\ttestRollback = testRollbackProperty;\n\n\t}\n",
    "85419": "\tprotected void T000() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt1.close();\n\n\n\t\tt1 = t_util.t_startInternalTransaction();\n\n\t\tt1.close();\n\n\t\tt1 = t_util.t_startTransaction();\n\t\tTransaction ti = t_util.t_startInternalTransaction();\n\n\t\tti.close();\n\n\t\tt1.close();\n\n\t\tPASS(\"T000\");\n\t}\n",
    "85422": "\tprotected void T001() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_commit(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T001\");\n\t}\n",
    "85427": "\tprotected void T002() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T002\");\n\t}\n",
    "85432": "\tprotected void T003() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_commit(t1);\n\n\t\tt_util.t_commit(t1);\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T003\");\n\t}\n",
    "85438": "\tprotected void T004() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_abort(t1);\n\n\t\tt_util.t_commit(t1);\n\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T004\");\n\t}\n",
    "85480": "\tprotected void C010(int segment) throws T_Fail, StandardException {\n\n\t\tTransaction t = t_util.t_startTransaction();\n\n\t\tlong cid = t_util.t_addContainer(t, segment);\n\n\t\tt_util.t_commit(t);\n\t\n\t\tContainerHandle c1, c2;\n\n\t\tc1 = t_util.t_openContainer(t, segment, cid, true);\n\t\tc1 = t_util.t_openContainer(t, segment, cid, true);\n\t\tt_util.t_dropContainer(t, segment, cid);\t// cleanup\n\n\n\t\tt_util.t_commit(t);\n\t\tt.close();\n\n\t\tPASS(\"C010\");\n\n\t}\n",
    "85485": "\tprotected void C011() throws T_Fail, StandardException {\n\n\t\tTransaction t = t_util.t_startTransaction();\n\n\t\tlong cid = t_util.t_addContainer(t, 0);\n\n\t\tt_util.t_commit(t);\n\t\n\t\tContainerHandle c1, c2;\n\n\t\tc1 = t_util.t_openContainer(t, 0, cid, false);\n\t\tc1 = t_util.t_openContainer(t, 0, cid, true);\n\n\t\tt_util.t_dropContainer(t, 0, cid);\t// cleanup\n\n\t\tt_util.t_commit(t);\n\t\tt.close();\n\t\tPASS(\"C011\");\n\n\t}\n",
    "86122": "\tprotected Statement createFloatStatementForStateChecking(Connection conn) throws SQLException {\n\t\tStatement s = internalCreateFloatStatementForStateChecking(conn);\n\t\ts.setCursorName(\"StokeNewington\");\n\t\ts.setFetchDirection(ResultSet.FETCH_REVERSE);\n\t\ts.setFetchSize(444);\n\t\ts.setMaxFieldSize(713);\n\t\ts.setMaxRows(19);\n\n\t\tshowStatementState(\"Create \", s);\n\t\treturn s;\n\t}\n",
    "86148": "\tstatic private void expectedException (SQLException se, String expectedSQLState) {\n           if( se.getSQLState() != null && (se.getSQLState().equals(expectedSQLState))) { \n                System.out.println(\"PASS -- expected exception\");\n                while (se != null) {\n                    System.out.println(\"SQLSTATE(\"+se.getSQLState()+\"): \"+se.getMessage());\n                    se = se.getNextException();\n                }\n            } else {\n\t        System.out.println(\"FAIL--Unexpected SQLException: \" +\n\t\t\t\t\t\t\t   \"SQLSTATE(\" +se.getSQLState() + \")\" +\n\t\t\t\t\t\t\t   se.getMessage());\n\t        se.printStackTrace(System.out);\n\t    }\n\t}\n",
    "86149": "     static private void unexpectedSQLException(SQLException se) {\n\t System.out.println(\"FAIL -- Unexpected Exception: \"+ \n\t\t\t\t\t\t\"SQLSTATE(\" +se.getSQLState() +\")\" +\n\t\t\t\t\t\tse.getMessage());\n\t se.printStackTrace(System.out);\n     }\n",
    "86190": "\tprotected void dumpRS(ResultSet rs) throws SQLException {\n\t\tdumpRS(IGNORE_PROC_ID, rs);\n\t}\n",
    "86192": "\tprotected Connection createConnection(String[] args) throws Exception {\n\n\t\tConnection con;\n\n\t\t// use the ij utility to read the property file and\n\t\t// make the initial connection.\n\t\tij.getPropertyArg(args);\n\t\tcon = ij.startJBMS();\n\t\t//con.setAutoCommit(true); // make sure it is true\n\t\tcon.setAutoCommit(false);\n\n\t\treturn con;\n\n\t}\n",
    "86244": "\tpublic void unlatch(Latch heldLatch) {\n\t\tlockTable.unlock(heldLatch, 1);\n\t}\n",
    "86250": "\tprotected boolean setPotentiallyGranted() {\n\t\tif (!potentiallyGranted) {\n\t\t\tpotentiallyGranted = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "86252": "\tprotected void clearPotentiallyGranted() {\n\t\tpotentiallyGranted = false;\n\t}\n",
    "86261": "\tpublic Control shallowClone() {\n\t\treturn this;\n\t}\n",
    "86264": "\tpublic void unlockGroup(Object compatabilitySpace, Object group) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {\n\t\t\t\tD_LockControl.debugLock(\"Lock Unlock Group: \", compatabilitySpace, group);\n\t\t\t}\n\t\t}\n\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn;\n\n\t\tls.unlockGroup(lockTable, group);\n\t}\n",
    "86275": "\tpublic boolean anyoneBlocked() {\n\t\treturn lockTable.anyoneBlocked();\n\t}\n",
    "86278": "\tpublic boolean areLocksHeld(Object compatabilitySpace, Object group) {\n\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn false;\n\n\t\t// there is a window where someone could remove the LockSpace from the \n        // spaces Hashtable, since we do not hold the spaces' monitor. This is \n        // Ok as the LockSpace will have no locks and this method will \n        // correctly return false.\n\n\t\treturn ls.areLocksHeld(group);\n\t}\n",
    "86280": "\tpublic boolean areLocksHeld(Object compatabilitySpace) {\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn false;\n\t\treturn !ls.isEmpty();\n\t}\n",
    "86286": "\tpublic void clearLimit(Object compatabilitySpace, Object group) {\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn;\n\n\t\tls.clearLimit(group);\n\t}\n",
    "86287": "\tpublic ActiveLock firstWaiter() {\n\t\tif ((waiting == null) || waiting.isEmpty())\n\t\t\treturn null;\n\t\treturn (ActiveLock) waiting.get(0);\n\t}\n",
    "86289": "\tpublic Lockable getLockable() {\n\t\treturn ref;\n\t}\n",
    "86301": "\tpublic void addWaiters(Dictionary waiters) {\n\t\t\n\t\tif ((waiting == null) || waiting.isEmpty())\n\t\t\treturn;\n\n\t\tObject previous = this;\n\t\tfor (ListIterator li = waiting.listIterator(); li.hasNext(); ) {\n\n\t\t\tActiveLock waitingLock = ((ActiveLock) li.next());\n\n\t\t\tObject waiter = waitingLock.getCompatabilitySpace();\n\n\t\t\twaiters.put(waiter, waitingLock);\n\t\t\twaiters.put(waitingLock, previous);\n\t\t\tprevious = waitingLock;\n\t\t}\n\t}\n",
    "86311": "\tprivate Object popFrontWaiter(List waiting, LockSet ls) {\n\t\t// Maintain count of waiters\n\t\tls.oneLessWaiter();\n\n\t\t// Remove and return the first lock request\n\t\treturn waiting.remove(0);\n\t}\n",
    "86329": "    private void cpArray( String toCp, int start, int end )\n    {   // build a field in the output string\n        int i = 0;\n        int totalAllowWrite = end - start;\n\n        if( toCp != null )\n        {\n            for( ; i < toCp.length() ; i++ )\n            {\n                if( (totalAllowWrite-i) == 0 )\n                    break;\n\n                outputRow[ i + start ] = toCp.charAt(i);\n            }\n        }\n        for( ; i + start != end; i++ )\n            outputRow[ i + start ] = ' ';\n\n        outputRow[ end ] = SEPARATOR;\n    }\n",
    "86343": "\tpublic void notifyModifyClasspath(String classpath) throws StandardException {\n\n\t\tif (applicationLoader != null) {\n\t\t\tapplicationLoader.modifyClasspath(classpath);\n\t\t}\n\t}\n",
    "86362": "\tprivate InputStream getRawStream(ZipFile zip, String name) {\n\n\t\ttry {\n\t\t\tZipEntry ze = zip.getEntry(name);\n\t\t\tif (ze == null)\n\t\t\t\treturn null;\n\n\t\t\treturn zip.getInputStream(ze);\n\t\t} catch (IOException ioe) {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "86364": "\tprivate InputStream getRawStream(InputStream in, String name) { \n\n\t\tZipInputStream zipIn = null;\n\t\ttry {\n\t\t\tzipIn = new ZipInputStream(in);\n\n\t\t\tZipEntry ze;\n\t\t\twhile ((ze = jf.getNextEntry(zipIn)) != null) {\n\n\t\t\t\tif (ze.getName().equals(name)) {\n\t\t\t\t\tLimitInputStream lis = new LimitInputStream(zipIn);\n\t\t\t\t\tlis.setLimit((int) ze.getSize());\n\t\t\t\t\treturn lis;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzipIn.close();\n\n\t\t} catch (IOException ioe) {\n\t\t\tif (zipIn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipIn.close();\n\t\t\t\t} catch (IOException ioe2) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "86371": "\tprivate HeaderPrintWriter makeStream() {\n\n\t\t// get the header\n\t\tPrintWriterGetHeader header = makeHeader();\n\t\tHeaderPrintWriter hpw = makeHPW(header);\n\n\t\t// If hpw == null then no properties were specified for the stream\n\t\t// so use/create the default stream.\n\t\tif (hpw == null)\n\t\t\thpw = createDefaultStream(header);\n\t\treturn hpw;\n\t}\n",
    "86372": "\tprivate PrintWriterGetHeader makeHeader() {\n\n\t\treturn new BasicGetLogHeader(true, true, (String) null);\n\t}\n",
    "86373": "\tprivate HeaderPrintWriter makeHPW(PrintWriterGetHeader header) {\n\n\t\t// the type of target is based on which property is used\n\t\t// to set it. choices are file, method, field, stream\n\n\t\tString target = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_FILE_PROPERTY);\n\t\tif (target!=null)\n\t\t\treturn makeFileHPW(target, header);\n\n\t\ttarget = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_METHOD_PROPERTY);\n\t\tif (target!=null) \n\t\t\treturn makeMethodHPW(target, header);\n\n\t\ttarget = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_FIELD_PROPERTY);\n\t\tif (target!=null) \n\t\t\treturn makeFieldHPW(target, header);\n\n\t\treturn null;\n\t}\n",
    "86379": "\tprivate HeaderPrintWriter createDefaultStream(PrintWriterGetHeader header) {\n\t\treturn makeFileHPW(\"derby.log\", header);\n\t}\n",
    "86380": "\tprivate HeaderPrintWriter useDefaultStream(PrintWriterGetHeader header) {\n\n\t\treturn new BasicHeaderPrintWriter(System.err, header, false, \"System.err\");\n\t}\n",
    "86384": "\tpublic void keepAfterSearch() {\n\t\tkeepCount++;\n\t\tsetUsed(true);\n\t}\n",
    "86392": "\tpublic Cacheable getEntry() {\n\t\treturn entry;\n\t}\n",
    "86414": "\tpublic void cleanAll() throws StandardException {\n\t\tstat.cleanAll++;\n\t\tcleanCache((Matchable) null);\n\t}\n",
    "86417": "\tpublic void clean(Matchable partialKey) throws StandardException {\n\n\t\tcleanCache(partialKey);\n\t}\n",
    "86422": "\tpublic void shutdown() throws StandardException {\n\n\t\tif (cleaner != null) {\n\t\t\tcleaner.unsubscribe(myClientNumber);\n\t\t\tcleaner = null;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tactive = false;\n\t\t}\n\n\t\tageOut();\n\t\tcleanAll();\n\t\tageOut();\n\t}\n",
    "86461": "\tpublic Object put(Object key, Object value) {\n\t\tObject ref = defaults.put(key, value);\n\t\tif (!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX))\n\t\t\tupdate();\n\t\treturn ref;\n\t}\n",
    "86462": "\tpublic Object remove(Object key) {\n\t\tObject ref = defaults.remove(key);\n\t\tif ((ref != null) &&\n\t\t\t(!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX)))\n\t\t\tupdate();\n\t\treturn ref;\n\t}\n",
    "86474": "\tpublic void shutdown(Object serviceModule) {\n\t\tif (serviceModule == null)\n\t\t\treturn;\n\n\t\tTopService ts = findTopService(serviceModule);\n\t\tif (ts == null)\n\t\t\treturn;\n\n\t\t// shutdown() returns false if the service is already being shutdown\n\t\tboolean removeService = true;\n\t\ttry {\n\t\t\tremoveService = ts.shutdown();\n\t\t} finally {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (removeService) {\n\t\t\t\t\tboolean found = services.removeElement(ts);\n\t\t\t\t\tif (SanityManager.DEBUG) {\n\t\t\t\t\t\tSanityManager.ASSERT(found, \"service was not found \" + serviceModule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "86484": "\tpublic String getServiceName(Object serviceModule) {\n\n\t\tTopService ts = findTopService(serviceModule);\n\n\t\tif (ts == null)\n\t\t\treturn null;\n\n\t\treturn ts.getServiceType().getUserServiceName(ts.getKey().getIdentifier());\n\t}\n",
    "86488": "\tprotected long removeIdentity(CachedItem item) {\n\n        long shrink = 1;\n        \n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(!item.isKept(), \"item is kept\");\n\t\t\tSanityManager.ASSERT(item.isValid(), \"item is not valid\");\n\n\t\t}\n\n        if( useByteCount)\n            shrink = ((SizedCacheable) item.getEntry()).getSize();\n\t\tremove(item.getEntry().getIdentity());\t\t\t\t\n\t\titem.setValidState(false);\n        validItemCount--;\n\t\titem.getEntry().clearIdentity();\n        if( useByteCount)\n        {\n            shrink -= ((SizedCacheable) item.getEntry()).getSize();\n            currentByteCount -= shrink;\n        }\n        return shrink;\n\t}\n",
    "86493": "\tpublic PersistentService getServiceType(Object serviceModule) {\n\t\tTopService ts = findTopService(serviceModule);\n\n\t\tif (ts == null)\n\t\t\treturn null;\n\n\t\treturn ts.getServiceType();\n\t}\n",
    "86522": "\tprotected void report(String message)\t{\n\n\t\tPrintWriter tpw = getTempWriter();\n\n\t\tif (tpw != null)\n\t\t\ttpw.println(message);\n\n\t\tif (systemStreams != null)\n\t\t\tsystemStreams.stream().printlnWithHeader(message);\n\t}\n",
    "86570": "\tprotected void bootServiceProviders() {\n\n\t\tif (serviceProviders == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Enumeration e = serviceProviders.keys(); e.hasMoreElements(); ) {\n\n\t\t\tString serviceType = (String) e.nextElement();\n\t\t\tObject provider = serviceProviders.get(serviceType);\n\n\t\t\t// see if this provider can live in this environment\n\t\t\tif (!BaseMonitor.canSupport(provider, (Properties) null)) {\n\t\t\t\tserviceProviders.remove(serviceType);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n",
    "86574": "\tprotected void bootPersistentServices() {\n\t\tfor (Enumeration e = new ProviderEnumeration( applicationProperties); ; ) {\n\n\t\t\tPersistentService provider = (PersistentService) e.nextElement();\n\t\t\tbootProviderServices(provider);\n\t\t}\n\n\t}\n",
    "86575": "\tpublic int getRelativePC() {\n\t\treturn cout.size() - codeOffset;\n\t}\n",
    "86576": "\tpublic LocalField addField(String javaType, String name, int modifiers) {\n\n\t\tType type = factory.type(javaType);\n\t\t// put it into the class holder right away.\n\t\tClassMember field = classHold.addMember(name, type.vmName(), modifiers);\n\t\tint cpi = classHold.addFieldReference(field);\n\n\t\treturn new BCLocalField(type, cpi);\n\t}\n",
    "86595": "\tpublic String getName() {\n\t\treturn myName;\n\t}\n",
    "86600": "\tpublic void addThrownException(String exceptionClass) {\n\t\t\n\t\t// cannot add exceptions after code generation has started.\n\t\t// Allowing this would cause the method overflow/split to\n\t\t// break as the top-level method would not have the exception\n\t\t// added in the sub method.\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (myCode.getRelativePC() != 0)\n\t\t\t\tSanityManager.THROWASSERT(\"Adding exception after code generation \" + exceptionClass\n\t\t\t\t\t\t+ \" to method \" + getName());\n\t\t}\n\n\t\tif (thrownExceptions == null)\n\t\t\tthrownExceptions = new Vector();\n\t\tthrownExceptions.addElement(exceptionClass);\n\t}\n",
    "86601": "\tpublic void complete() {\n\t\t// write exceptions attribute info\n\t\twriteExceptions();\n\t\t\n\t\t// get the code attribute to put itself into the class\n\t\t// provide the final header information needed\n\t\tmyCode.complete(modClass, myEntry, maxStack, currentVarNum);\n\t}\n",
    "86635": "\tpublic UUIDFactory getUUIDFactory()\t{\n\n\t\treturn uuidFactory;\n\t}\n",
    "86648": "\tpublic ResourceBundle getBundle(String messageId) {\n\t\tContextManager cm;\n\t\ttry {\n\t\t\tcm = ContextService.getFactory().getCurrentContextManager();\n\t\t} catch (ShutdownException se) {\n\t\t\tcm = null;\n\t\t}\n\n\t\tif (cm != null) {\n\t\t\treturn MessageService.getBundleForLocale(cm.getMessageLocale(), messageId);\n\t\t}\n\t\treturn null;\n\t}\n",
    "86663": "\tpublic void getStaticField(String declaringClass, String fieldName, String fieldType) {\n\t\tgetField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);\n\t}\n",
    "86667": "\tpublic void setField(LocalField field) {\n\t\tBCLocalField lf = (BCLocalField) field;\n\t\tType lt = lf.type;\n\n\t\tputField(lf.type, lf.cpi, false);\n\n\t\tif (stackDepth == 0)\n\t\t\toverflowMethodCheck();\n\t}\n",
    "86669": "\tpublic void putField(LocalField field) {\n\t\tBCLocalField lf = (BCLocalField) field;\n\t\tType lt = lf.type;\n\n\t\tputField(lf.type, lf.cpi, true);\n\t}\n",
    "86675": "\tpublic void boot(boolean create, Properties properties) throws StandardException {\n\n\t\tCacheFactory cf =\n\t\t\t(CacheFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);\n\n\t\t/*\n\t\t** The initial and maximum cache sizes are based on experiments\n\t\t** that I did with some of the language tests.  I found that\n\t\t** the size quickly grew to about 40, then continued to grow\n\t\t** slowly after that.\n\t\t**\n\t\t**\t\t\t-\tJeff\n\t\t*/\n\t\tvmTypeIdCache =\n\t\t\tcf.newCacheManager(\n\t\t\t\tthis,\n\t\t\t\t\"VMTypeIdCache\",\n\t\t\t\t64,\n\t\t\t\t256);\n\t}\n",
    "86677": "\tpublic void stop() {\n\t}\n",
    "86700": "\tprotected void TC004all() throws StandardException, T_Fail {\n\t\tint[] modes = {\n\t\t\t0,\n\t\t\tContainerHandle.MODE_DROP_ON_COMMIT,\n\t\t\tContainerHandle.MODE_TRUNCATE_ON_COMMIT\n\t\t};\n\n\t\tfor (int m1 = 0; m1 < modes.length; m1++) {\n\t\t\tfor (int m2 = 0; m2 < modes.length; m2++) {\n\t\t\t\tfor (int m3 = 0; m3 < modes.length; m3++) {\n\n\t\t\t\t\tTC004(m1, m2, m3, false, false);\n\t\t\t\t\tTC004(m1, m2, m3, false, true);\n\t\t\t\t\tTC004(m1, m2, m3, true, false);\n\t\t\t\t\tTC004(m1, m2, m3, true, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n",
    "86718": "  public ResultSetMetaData getMetaData() {\n    return importResultSetMetaData;\n  }\n",
    "86719": "  public int getRow() throws SQLException {\n    return (importReadData.getCurrentRowNumber());\n  }\n",
    "86721": "  public void close() throws SQLException {\n    try {\n\t\tif(importReadData!=null)\n\t\t\timportReadData.closeStream();\n    } catch (Exception ex) {\n\t\tthrow LoadError.unexpectedError(ex);\n    }\n  }\n",
    "86736": "\tprotected ImportReadData getImportReadData() throws Exception {\n\t\treturn new ImportReadData(inputFileName, controlFileReader);\n\t}\n",
    "86758": "  protected void ignoreFirstRow() throws Exception {\n    readNextToken(recordSeparator, 0, recordSeparatorLength, true);\n  }\n",
    "86775": "  public void closeStream() throws Exception {\n    if (streamOpenForReading) {\n       bufferedReader.close();\n       streamOpenForReading = false;\n    }\n  }\n",
    "86834": "  public int getCurrentRowNumber() {\n    return lineNumber;\n  }\n",
    "86844": "\tpublic ResultColumnDescriptor getColumnDescriptor(int position) {\n\t\treturn columns[position-1];\n\t}\n",
    "86861": "\tpublic boolean isActive() {\n\t\treturn active;\n\t}\n",
    "86981": "\tpublic\tint\tgetTypeFormatId()\t{\n\t\treturn majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?\n\t\t\tStoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;\n\t}\n",
    "87063": "\tpublic void setDroppedInSavepointLevel(int droppededInSavepointLevel) {\n    this.droppededInSavepointLevel = droppededInSavepointLevel;\n  }\n",
    "87076": "\tpublic GenericPreparedStatement getPreparedStatement() {\n\t\treturn ps;\n\t}\n",
    "87090": "\tpublic void resetSavePoint() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (SanityManager.DEBUG_ON(\"traceSavepoints\"))\n\t\t\t{\n\t\t\t\tSanityManager.DEBUG_PRINT(\n\t\t\t\t\t\"GenericStatementContext.resetSavePoint()\",\n\t\t\t\t\tinternalSavePointName);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (inUse && setSavePoint)\n\t\t{\t\t\n\t\t\t// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller\n\t\t\tif ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }\n\t\t\t// stage buffer management\n\t\t}\n\t}\n",
    "87117": "\tpublic void setParentRollback() {\n\t\trollbackParentContext = true;\n\t}\n",
    "87118": "\tpublic void setSystemCode() {\n\t\tisSystemCode = true;\n\t}\n",
    "87120": "\tpublic boolean getSystemCode() {\n\t\treturn isSystemCode;\n\t}\n",
    "87135": "\tpublic ExecutionFactory\tgetExecutionFactory() {\n\t\treturn ef;\n\t}\n",
    "87139": "\tpublic OptimizerFactory\tgetOptimizerFactory() {\n\t\treturn of;\n\t}\n",
    "87140": "\tpublic TypeCompilerFactory getTypeCompilerFactory() {\n\t\treturn tcf;\n\t}\n",
    "87141": "\tpublic DataValueFactory\t\tgetDataValueFactory() {\n\t\treturn dvf;\n\t}\n",
    "87144": "\tpublic boolean canSupport(Properties startParams) {\n\n\t\treturn Monitor.isDesiredType( startParams, EngineType.STANDALONE_DB);\n\t}\n",
    "87173": "\tpublic void boot(boolean create, Properties startParams) throws StandardException \n\t{\t\t\n\t\tLanguageConnectionFactory lcf = (LanguageConnectionFactory)  Monitor.findServiceModule(this, LanguageConnectionFactory.MODULE);\n\t\tPropertyFactory pf = lcf.getPropertyFactory();\n\t\tif (pf != null)\n\t\t\tpf.addPropertySetNotification(new LanguageDbPropertySetter());\n\n\t\temptySet = new GenericParameterValueSet(null, 0, false);\n\t}\n",
    "87202": "\tpublic void addActivation(Activation a) {\n\t\tacts.addElement(a);\n\n\t\tif (SanityManager.DEBUG) {\n\n\t\t\tif (SanityManager.DEBUG_ON(\"memoryLeakTrace\")) {\n\n\t\t\t\tif (acts.size() > 20)\n\t\t\t\t\tSystem.out.println(\"memoryLeakTrace:GenericLanguageContext:activations \" + acts.size());\n\t\t\t}\n\t\t}\n\t}\n",
    "87210": "\tprotected void clearProviderDependency(UUID p, Dependency d) {\n\t\tList deps = (List) providers.get(p);\n\n\t\tif (deps == null)\n\t\t\treturn;\n\n\t\tdeps.remove(d);\n\n\t\tif (deps.size() == 0)\n\t\t\tproviders.remove(p);\n\t}\n",
    "87237": "\tpublic UUID getProviderKey() {\n\t\treturn provider.getObjectID();\n\t}\n",
    "87238": "\tpublic Provider getProvider() {\n\t\treturn provider;\n\t}\n",
    "87239": "\tpublic Dependent getDependent() {\n\t\treturn dependent;\n\t}\n",
    "87264": "\tpublic boolean checkNoDeclaredOutputParameters() {\n\n\t\tboolean hasDeclaredOutputParameter = false;\n\t\tfor (int i=0; i<parms.length; i++) {\n\n\t\t\tGenericParameter gp = parms[i];\n\n\t\t\tswitch (gp.parameterMode) {\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_IN:\n\t\t\t\tbreak;\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_IN_OUT:\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_OUT:\n\t\t\t\thasDeclaredOutputParameter = true;\n\t\t\t\tbreak;\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_UNKNOWN:\n\t\t\t\tgp.parameterMode = JDBC30Translation.PARAMETER_MODE_IN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn hasDeclaredOutputParameter;\n\t}\n",
    "87281": "\tpublic OrderByColumn getOrderByColumn(int position) {\n\t\tif (SanityManager.DEBUG)\n\t\tSanityManager.ASSERT(position >=0 && position < size());\n\t\treturn (OrderByColumn) elementAt(position);\n\t}\n",
    "87283": "\tpublic void printSubNodes(int depth) {\n\n\t\tif (SanityManager.DEBUG) \n\t\t{\n\t\t\tfor (int index = 0; index < size(); index++)\n\t\t\t{\n\t\t\t\t( (OrderByColumn) (elementAt(index)) ).treePrint(depth);\n\t\t\t}\n\t\t}\n\t}\n",
    "87297": "\tpublic int getActivationCount() {\n\t\treturn acts.size();\n\t}\n",
    "87307": "\tpublic CursorActivation lookupCursorActivation(String cursorName) {\n\n\t\tint size = acts.size();\n\t\tif (size > 0)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t Activation a = (Activation) acts.elementAt(i);\n\n\t\t\t\t if (!a.isInUse())\n\t\t\t\t {\n\t\t\t\t\tcontinue;\n\t\t\t\t }\n\n\n\n\t\t\t\tString executingCursorName = a.getCursorName();\n\n\t\t\t\t if (cursorName.equals(executingCursorName)) {\n\n\t\t\t\t\tResultSet rs = a.getResultSet();\n\t\t\t\t\tif (rs == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t // if the result set is closed, the the cursor doesn't exist\n\t\t\t\t\t if (rs.isClosed()) {\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t }\n\n\t\t\t\t \treturn (CursorActivation)a;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "87313": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.DataValueDescriptor;\n\t}\n",
    "87439": "\tpublic DataValueFactory getDataValueFactory() {\n\t\treturn dataFactory;\n\t}\n",
    "87443": "\tpublic LanguageFactory getLanguageFactory() {\n\t\treturn langFactory;\n\t}\n",
    "87448": "\tpublic LanguageConnectionFactory getLanguageConnectionFactory() {\n\t\treturn connFactory;\n\t}\n",
    "87479": "\tpublic void emptyCache() {\n\t\t/* We know prepared statements don't become dirty\n\t\t** statementCache.cleanAll(); \n\t\t*/\n\t\tif (statementCache != null)\n\t\t\tstatementCache.ageOut(); \n\t}\n",
    "87554": "\tpublic\tint\t\tgetStatementDepth()\n\t{ return statementDepth; }\n",
    "87621": "\tprivate void finishDDTransaction() throws StandardException {\n\n\t\t/* Was the data dictionary put into write mode? */\n\t\tif (ddWriteMode) {\n\t\t\tDataDictionary dd = getDataDictionary();\n\n\t\t\t/* Tell the data dictionary that the transaction is finished */\n\t\t\tdd.transactionFinished();\n\n\t\t\t/* The data dictionary isn't in write mode any more */\n\t\t\tddWriteMode = false;\n\t\t}\n\t}\n",
    "87664": "\tpublic String toString() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\treturn expression.toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n",
    "87665": "\tpublic void setDescending() {\n\t\tascending = false;\n\t}\n",
    "87666": "\tpublic boolean isAscending() {\n\t\treturn ascending;\n\t}\n",
    "87831": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.ConcatableDataValue;\n\t}\n",
    "87990": "\tpublic String getReceiverInterfaceName() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(receiver!=null,\"can't get receiver interface name until receiver is set\");\n\t\t}\n\n\t\treturn receiver.getTypeCompiler().interfaceName();\n\t}\n",
    "88021": "\tpublic void init(Object field, Object operand) {\n\t\textractField = ((Integer) field).intValue();\n\t\tsuper.init( operand,\n\t\t\t\t\t\"EXTRACT \"+fieldName[extractField],\n\t\t\t\t\tfieldMethod[extractField] );\n\t}\n",
    "88329": "    public\tString\tgetPackageName()\n\t{\treturn\tCodeGeneration.GENERATED_PACKAGE_PREFIX; }\n",
    "88330": "\tpublic String getBaseClassName() {\n\t    return ClassName.BaseActivation;\n\t}\n",
    "88994": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.StringDataValue;\n\t}\n",
    "89015": "\t//public int\tgetLength() throws StandardException {\n\t//\treturn TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;\n\t//}\n",
    "89233": "\tpublic void printSubNodes(int depth) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tsuper.printSubNodes(depth);\n\n\t\t\tprintLabel(depth, \"cursor: \");\n\t\t}\n\t}\n",
    "89234": "\tpublic String toString() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\treturn \"preparedStatement: \" +\n\t\t    \t(preStmt == null? \"no prepared statement yet\\n\" :\n\t\t\t \tpreStmt.toString() + \"\\n\")+\n\t\t\t\tcursorName + \"\\n\" +\n\t\t\t\tsuper.toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n",
    "89467": "\tpublic boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {\n\n\t\tif (requiredMajorVersion == DataDictionary.DD_VERSION_CURRENT) {\n\t\t\trequiredMajorVersion = softwareVersion.majorVersionNumber;\n\t\t}\n\n\t\treturn dictionaryVersion.checkVersion(requiredMajorVersion, feature);\n\t}\n",
    "89612": "\tpublic String getReceiverInterfaceName() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(operand!=null,\n\t\t\t\t\t\t\t\t\"cannot get interface without operand\");\n\t\t}\n\n\t\tif (operatorType != -1)\n\t\t\treturn receiverInterfaceType;\n\t\t\n\t\treturn operand.getTypeCompiler().interfaceName();\n\t}\n",
    "89786": "\tpublic MethodBuilder getExecuteMethod() {\n\t\treturn executeMethod;\n\t}\n",
    "89795": "\tpublic MethodBuilder newGeneratedFun(String returnType, int modifiers) {\n\n\t\treturn newGeneratedFun(returnType, modifiers,\n\t\t\t\t\t\t\t   (String[]) null);\n\t}\n",
    "89803": "\tpublic void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {\n\n\t\tmb.pushThis(); // instance\n\t\tmb.push(exprMethod.getName()); // arg\n\t\tmb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,\n\t\t\t\t\"getMethod\",\n\t\t\t\tClassName.GeneratedMethod,\n\t\t\t\t1\n\t\t\t\t);\n\t}\n",
    "89804": "\tpublic MethodBuilder newUserExprFun() {\n\n\t\tMethodBuilder mb = newExprFun();\n\t\tmb.addThrownException(\"java.lang.Exception\");\n\t\treturn mb;\n\t}\n",
    "89806": "\tpublic void getCurrentDateExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentDate();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, \"getCurrentDate\", \"java.sql.Date\", 0);\n\t}\n",
    "89807": "\tpublic void getCurrentTimeExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentTime();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, \"getCurrentTime\", \"java.sql.Time\", 0);\n\t}\n",
    "89809": "\tpublic void getCurrentTimestampExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentTimestamp();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,\n\t\t\t\"getCurrentTimestamp\", \"java.sql.Timestamp\", 0);\n\t}\n",
    "89823": "\tpublic void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {\n\t\tif (resultSetClosedMethod != null)\n\t\t\tpushMethodReference(mb, resultSetClosedMethod);\n\t\telse\n\t\t\tmb.pushNull(ClassName.GeneratedMethod);\n\t}\n",
    "89827": "\t//private void pushRowArrayReference(MethodBuilder mb)\n\t//{ \t\t\n\t\t// PUSHCOMPILE - cache\n\t//\tmb.pushThis();\n\t//\tmb.getField(ClassName.BaseActivation, \"row\", ClassName.ExecRow + \"[]\");\n\t//}\n",
    "89836": "\tpublic GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {\n\t\tif (gc != null) return gc;\n\n\t\tif (savedBytes != null)\n\t\t{\n\t\t\tByteArray classBytecode = cb.getClassBytecode();\n\n\t\t\t// note: be sure to set the length since\n\t\t\t// the class builder allocates the byte array\n\t\t\t// in big chunks\n\t\t\tsavedBytes.setBytes(classBytecode.getArray());\n\t\t\tsavedBytes.setLength(classBytecode.getLength());\n\t\t}\n\n\t    gc =  cb.getGeneratedClass();\n\n\t\treturn gc; // !! yippee !! here it is...\n\t}\n",
    "89838": "\tpublic void pushThisAsActivation(MethodBuilder mb) {\n\t\t// PUSHCOMPILER - WASCACHED\n\t\tmb.pushThis();\n\t\tmb.upCast(ClassName.Activation);\n\t}\n",
    "89839": "\tpublic void generateNull(MethodBuilder mb, TypeCompiler tc) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.pushNull(tc.interfaceName());\n\t\ttc.generateNull(mb);\n\t}\n",
    "89841": "\tpublic void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.swap(); // need the dvf as the instance\n\t\tmb.cast(tc.interfaceName());\n\t\ttc.generateNull(mb);\n\t}\n",
    "89842": "\tpublic void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.swap(); // need the dvf as the instance\n\t\ttc.generateDataValue(mb, field);\n\t}\n",
    "89962": "\tpublic\tString\t\tgetSQLtext()\n\t{\treturn\tSQLtext; }\n",
    "90128": "\tpublic\tNodeFactory\tgetNodeFactory()\n\t{\treturn lcf.getNodeFactory(); }\n",
    "90195": "\tpublic void addWarning(SQLWarning warning) {\n\t\tif (warnings == null)\n\t\t\twarnings = warning;\n\t\telse\n\t\t\twarnings.setNextWarning(warning);\n\t}\n",
    "90197": "\tpublic SQLWarning getWarnings() {\n\t\treturn warnings;\n\t}\n",
    "90348": "\tpublic void checkReliability(ValueNode sqlNode) throws StandardException {\n        sqlNode.checkReliability( \n                CompilerContext.FUNCTION_CALL_ILLEGAL,\n                SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF\n                );\n\t}\n",
    "90419": "\tpublic void setSingleExecution() {\n\t\tac.setSingleExecution();\n\t}\n",
    "90420": "\tpublic boolean isSingleExecution() {\n\t\treturn ac.isSingleExecution();\n\t}\n",
    "90422": "\tpublic int getNumSubqueries() {\n\t\treturn ac.getNumSubqueries();\n\t}\n",
    "90466": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(source instanceof CursorResultSet, \"source not instance of CursorResultSet\");\n\t\treturn ( (CursorResultSet)source ).getRowLocation();\n\t}\n",
    "90528": "\tpublic void\topenCore() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t    \tSanityManager.ASSERT( ! isOpen, \"CurrentOfResultSet already open\");\n\n\t\t// get the cursor\n\t\tgetCursor();\n\n\t\tnext = false;\n\t    isOpen = true;\n\t}\n",
    "90536": "\tpublic RowLocation getRowLocation()  {\n\t\treturn rowLocation;\n\t}\n",
    "90671": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(source instanceof CursorResultSet, \"source is not CursorResultSet\");\n\t\treturn ( (CursorResultSet)source ).getRowLocation();\n\t}\n",
    "90739": "\tpublic RowLocation getRowLocation() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Join used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90740": "\tpublic ExecRow getCurrentRow() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Join used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90770": "\tpublic boolean\tisClosed() {\n\t    return ( ! isOpen );\n\t}\n",
    "90774": "\tpublic ResultDescription getResultDescription() {\n\t    return resultDescription;\n\t}\n",
    "90797": "\tpublic\tboolean\tupToDate()\n\t{ return true; }\n",
    "90915": "\tpublic ResultDescription getResultDescription() {\n\t    return activation.getResultDescription();\n\t}\n",
    "90917": "\tpublic String getCursorName() {\n\n\t\tString cursorName = activation.getCursorName();\n\t\tif ((cursorName == null) && isForUpdate()) {\n\n\t\t\tactivation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());\n\n\t\t\tcursorName = activation.getCursorName();\n\t\t}\n\n\t\treturn cursorName;\n\t}\n",
    "90924": "\tpublic RowLocation getRowLocation() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"RowResultSet used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90928": "\tpublic ExecRow getCurrentRow() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"RowResultSet used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90977": "\tpublic void\treopenCore() throws StandardException {\n\t\tTransactionController\t\ttc;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(isOpen,\n\t\t\t\t\t\"HashScanResultSet already open\");\n\t\t}\n\n\t\tbeginTime = getCurrentTimeMillis();\n\n\t\tresetProbeVariables();\n\n\t\tnumOpens++;\n\t\topenTime += getElapsedMillis(beginTime);\n\t}\n",
    "90994": "\tpublic boolean isClosed() {\n\t\treturn isClosed;\n\t\t//return true;\n\t}\n",
    "91015": "\tpublic String getCursorName() {\n\t\treturn null;\n\t}\n",
    "91061": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ROW_RS);\n  }\n",
    "91066": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_PR);\n  }\n",
    "91071": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_UPDATE);\n  }\n",
    "91074": "  public Vector getChildren(){\n    return new Vector();\n  }\n",
    "91076": "  public long getTotalTime(){\n    //The method below is the original calculation.  However, the constructor\n    //time was found to be inaccurate, and was therefore removed from the calculation.\n\t  //return constructorTime + openTime + nextTime + closeTime;\n\t  return openTime + nextTime + closeTime;\n  }\n",
    "91077": "  public long getChildrenTime(){\n    long childrenTime = 0;\n    java.util.Enumeration e = getChildren().elements();\n    while (e.hasMoreElements()){\n      childrenTime = childrenTime + ((RealBasicNoPutResultSetStatistics)e.nextElement()).getTotalTime();\n    }\n    return childrenTime;\n  }\n",
    "91080": "  public long getNodeTime(){\n    return getTotalTime() - getChildrenTime();\n  }\n",
    "91088": "  public String getNodeName(){\n\treturn MessageService.getTextMessage(\n\t\t\t\tindexName == null ?\n\t\t\t\tSQLState.RTS_TABLE_SCAN :\n\t\t\t\tSQLState.RTS_INDEX_SCAN);\n  }\n",
    "91097": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_HASH_SCAN);\n  }\n",
    "91104": "  public Vector getChildren(){\n    Vector children = new Vector();\n    children.addElement(sourceResultSetStatistics);\n    return children;\n  }\n",
    "91112": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE_VTI);\n  }\n",
    "91121": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_IRTBR);\n  }\n",
    "91130": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SORT);\n  }\n",
    "91133": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_VTI);\n  }\n",
    "91141": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_INSERT_VTI);\n  }\n",
    "91142": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_MATERIALIZED_RS);\n  }\n",
    "91149": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DISTINCT_SCALAR_AGG);\n  }\n",
    "91150": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SCROLL_INSENSITIVE_RS);\n  }\n",
    "91157": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_NORMALIZE_RS);\n  }\n",
    "91158": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_GROUPED_AGG);\n  }\n",
    "91159": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_JOIN);\n  }\n",
    "91166": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_INSERT);\n  }\n",
    "91175": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ONCE_RS);\n  }\n",
    "91178": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_UNION);\n  }\n",
    "91182": "  public String getNodeName(){\n\t// NOTE: Not internationalizing because \"CURRENT OF\" are keywords.\n    return \"Current Of\";\n  }\n",
    "91187": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ANY_RS);\n  }\n",
    "91188": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE_CASCADE);\n  }\n",
    "91193": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE);\n  }\n",
    "91202": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_HASH_TABLE);\n  }\n",
    "91208": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SCALAR_AGG);\n  }\n",
    "91244": "  public Vector getChildren(){\n    Vector children = new Vector();\n    children.addElement(topResultSetStatistics);\n    return children;\n  }\n",
    "91279": "\tpublic ResultDescription getResultDescription() {\n\t    return source1.getResultDescription();\n\t}\n",
    "91286": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t    switch (whichSource) {\n\t        case 1 : \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.ASSERT(source1 instanceof CursorResultSet, \"source not CursorResultSet\");\n\t\t\t\treturn ((CursorResultSet)source1).getRowLocation();\n\t        case 2 : \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.ASSERT(source2 instanceof CursorResultSet, \"source2 not CursorResultSet\");\n\t\t\t\treturn ((CursorResultSet)source2).getRowLocation();\n\t        default: \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.THROWASSERT( \"Bad source number in union\" );\n\t            return null;\n\t    }\n\t}\n",
    "91292": "\tpublic void forget() {\n\t\tcurrentDatetime = null;\n\t\tcurrentDate = null;\n\t\tcurrentTime = null;\n\t\tcurrentTimestamp = null;\n\t}\n",
    "91330": "\tpublic void markAsTopResultSet()\n\t{ }\n",
    "91411": "\tpublic ExecRow\tgetNextRowCore() throws StandardException {\n\n\t\tcurrentRow = null;\n\t\tbeginTime = getCurrentTimeMillis();\n\t\tif (isOpen) \n\t\t{\n\t\t\tif (!next) \n\t\t\t{\n\t            next = true;\n\t\t\t\tif (currentRow == null)\n\t\t\t\t{\n\t\t\t\t\tif (cachedRow != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentRow = cachedRow;\n\t\t\t\t\t}\n\t\t\t\t\telse if (row != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentRow = (ExecRow) row.invoke(activation);\n\t\t\t\t\t\tif (canCacheRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcachedRow = currentRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trowsReturned++;\n\t\t\t}\n\t\t\tsetCurrentRow(currentRow);\n\n\t\t\tnextTime += getElapsedMillis(beginTime);\n\t    }\n\t    return currentRow;\n\t}\n",
    "91490": "\tpublic String getReferencedTableName()\n\t{ return tableName; }\n",
    "91491": "\tpublic int getReferentialActionUpdateRule()\n\t{ return raUpdateRule; }\n",
    "91493": "\tpublic int getReferentialActionDeleteRule()\n\t{ return raDeleteRule; }\n",
    "91567": "\tprotected void closeActivationAction() throws Exception {\n\t\t// no code to be added here as generated code\n\t\t// will not call super.closeActivationAction()\n\t}\n",
    "91570": "\tpublic boolean isClosed() {\n\t\treturn closed;\n\t}\n",
    "91573": "\tpublic void setSingleExecution() {\n\t\tsingleExecution = true;\n\t}\n",
    "91576": "\tpublic boolean isSingleExecution() {\n\t\treturn singleExecution;\n\t}\n",
    "91579": "\tpublic int getNumSubqueries() {\n\t\treturn numSubqueries;\n\t}\n",
    "91621": "\tpublic String getCursorName() {\n\n\t\treturn isCursorActivation() ? cursorName : null;\n\t}\n",
    "91632": "\tpublic ResultSetFactory getResultSetFactory() {\n\t\treturn rsFactory;\n\t}\n",
    "91636": "\tpublic ExecutionFactory getExecutionFactory() {\n\t\treturn exFactory;\n\t}\n",
    "91638": "\tpublic CursorResultSet getTargetResultSet() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Must be overridden to be used.\");\n\t\treturn null;\n\t}\n",
    "91642": "\tpublic CursorResultSet getCursorResultSet() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Must be overridden to be used.\");\n\t\treturn null;\n\t}\n",
    "91643": "\tpublic void throwIfClosed(String op) throws StandardException {\n\t\tif (closed)\n\t\t\tthrow StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);\n\t}\n",
    "91735": "\tpublic void\treopenCore() throws StandardException {\n\t\tTransactionController\t\ttc;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(isOpen,\n\t\t\t\t\t\"IndexRowToBaseRowResultSet already open\");\n\t\t}\n\n\t\tbeginTime = getCurrentTimeMillis();\n\n\t\tsource.reopenCore();\n\n\t\tnumOpens++;\n\t\topenTime += getElapsedMillis(beginTime);\n\t}\n",
    "91741": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\treturn baseRowLocation;\n\t}\n",
    "91760": "\tpublic Connection getCurrentConnection() throws SQLException {\n\n\t\tConnectionContext cc = \n\t\t\t(ConnectionContext) cm.getContext(ConnectionContext.CONTEXT_ID);\n\n\t\treturn cc.getNestedConnection(true);\n\t}\t\n",
    "91763": "\tpublic int getMaxDynamicResults() {\n\t\treturn 0;\n\t}\n",
    "91880": "\tpublic boolean isValid() {\n\t\treturn isValid;\n\t}\n",
    "91942": "\tpublic int\tgetUpdateMode() {\n\t\treturn updateMode;\n\t}\n",
    "91988": "    public String nativeSQL(String sql) {\n\t\t// we don't massage the strings at all, so this is easy:\n\t\treturn sql;\n\t}\n",
    "91992": "\tpublic void setAutoCommit(boolean autoCommit) throws SQLException {\n\n\t\t// Is this a nested connection\n\t\tif (rootConnection != this) {\n\t\t\tif (autoCommit)\n\t\t\t\tthrow newSQLException(SQLState.NO_AUTO_COMMIT_ON);\n\t\t}\n\n\t\tif (this.autoCommit != autoCommit)\n\t\t\tcommit();\n\n\t\tthis.autoCommit = autoCommit;\n\t}\n",
    "91995": "    public boolean getAutoCommit() {\n\t\treturn autoCommit;\n\t}\n",
    "91998": "    public void commit() throws SQLException {\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\t/*\n\t\t\t** Note that the context stack is\n\t\t\t** needed even for rollback & commit\n\t\t\t*/\n            setupContextStack();\n\n\t\t\ttry\n\t\t\t{\n\t\t    \tgetTR().commit();\n\t\t\t}\n            catch (Throwable t)\n\t\t\t{\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\n\t\t\tneedCommit = false;\n\t\t}\n\t}\n",
    "92002": "    public void rollback() throws SQLException {\n\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\t/*\n\t\t\t** Note that the context stack is\n\t\t\t** needed even for rollback & commit\n\t\t\t*/\n            setupContextStack();\n\t\t\ttry\n\t\t\t{\n\t\t    \tgetTR().rollback();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\t\t\tneedCommit = false;\n\t\t} \n\t}\n",
    "92005": "    public void close() throws SQLException {\n\t\t// JDK 1.4 javadoc indicates close on a closed connection is a no-op\n\t\tif (isClosed())\n\t\t   \treturn;\n\n\n\t\tif (rootConnection == this)\n\t\t{\n\t\t\t/* Throw error to match DB2/JDBC if a tran is pending in non-autocommit mode */\n\t\t\tif (!autoCommit && !transactionIsIdle()) {\n\t\t\t\tthrow newSQLException(SQLState.LANG_INVALID_TRANSACTION_STATE);\n\t\t\t}\n\n\t\t\tclose(exceptionClose);\n\t\t}\n\t\telse\n\t\t\tsetInactive(); // nested connection\n\t}\n",
    "92011": "    public DatabaseMetaData getMetaData() throws SQLException {\n\t\tif (isClosed())\n\t\t\tthrow Util.noCurrentConnection();\n\n\t\tif (dbMetadata == null) {\n\n \t\t\t// There is a case where dbname can be null.\n\t\t\t// Replication client of this method does not have a\n\t\t\t// JDBC connection; therefore dbname is null and this\n\t\t\t// is expected.\n\t\t\t//\n\t\t\tdbMetadata = factory.newEmbedDatabaseMetaData(this, getTR().getUrl());\n\t\t}\n\t\treturn dbMetadata;\n\t}\n",
    "92016": "    public void setCatalog(String catalog) throws SQLException {\n\t\t// silently ignoring this request like the javadoc said.\n\t\treturn;\n\t}\n",
    "92020": "\tpublic String getCatalog() throws SQLException {\n\t\t// we do not have support for Catalog, just return null as\n\t\t// the JDBC specs mentions then.\n\t\treturn null;\n\t}\n",
    "92035": "    protected void needCommit() {\n\t\tif (!needCommit) needCommit = true;\n\t}\n",
    "92070": "\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\n\t\t/*\n\t\t** We mark the activation as not being used and\n\t \t** that is it.  We rely on the connection to sweep\n\t\t** through the activations to find the ones that\n\t\t** aren't in use, and to close them.  We cannot\n\t \t** do a activation.close() here because there are\n\t\t** synchronized methods under close that cannot\n\t\t** be called during finalization.\n\t\t*/\n\t\tif (activation != null) \n\t\t{\n\t\t\tactivation.markUnused();\n\t\t}\n\t}\n",
    "92071": "\tprotected void closeActions() throws SQLException {\n\n\t\t//we release the resource for preparedStatement\n\t\tpreparedStatement = null;\n\n\t\ttry{\n\t\t\tsetupContextStack();\n\t\t} catch (SQLException se) {\n\t\t\t//we may have already committed the transaction in which case\n\t\t\t//setupContextStack will fail, the close should just return\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t    activation.close();\n\t\t\tactivation = null;\n\t\t} catch (Throwable t)\n\t\t{\n\t\t\tthrow handleException(t);\n\t\t} finally {\n\t\t    restoreContextStack();\n\t\t}\n\t}\n",
    "92073": "    public void setNull(int parameterIndex, int sqlType) throws SQLException {\n\n\t\tcheckStatus();\n\n\t\tint jdbcTypeId = getParameterJDBCType(parameterIndex);\n\t\t\n\t\tif (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {\n\n\t\t\tthrow dataTypeConversion(parameterIndex, Util.typeName(sqlType));\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setToNull();\n\t\t} catch (StandardException t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92074": "    public void setBoolean(int parameterIndex, boolean x) throws SQLException {\n\t\t\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (StandardException t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92077": "    public void setByte(int parameterIndex, byte x) throws SQLException {\n\n\t\tcheckStatus();\n\t\ttry {\n\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92079": "    public void setShort(int parameterIndex, short x) throws SQLException {\n\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92081": "    public void setInt(int parameterIndex, int x) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92082": "    public void setLong(int parameterIndex, long x) throws SQLException {\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92084": "    public void setFloat(int parameterIndex, float x) throws SQLException {\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92085": "    public void setDouble(int parameterIndex, double x) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92089": "    public void setString(int parameterIndex, String x) throws SQLException {\n\t\tcheckStatus();\t\t\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92091": "\tpublic void resetFromPool() throws SQLException {\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\tsetupContextStack();\n\t\t\ttry {\n\t\t\t\tgetLanguageConnection().resetFromPool();\n\t\t\t} catch (StandardException t) {\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\t\t}\n\t}\n",
    "92092": "    public void setBytes(int parameterIndex, byte x[]) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92093": "    public void setDate(int parameterIndex, Date x) throws SQLException {\n        setDate( parameterIndex, x, (Calendar) null);\n\t}\n",
    "92095": "    public void setTime(int parameterIndex, Time x) throws SQLException {\n        setTime( parameterIndex, x, (Calendar) null);\n\t}\n",
    "92110": "    public void clearParameters() throws SQLException {\n\t\tcheckStatus();\n\n\t\tParameterValueSet pvs = getParms();\n\t\tif (pvs != null)\n\t\t\tpvs.clearParameters();\n\t}\n",
    "92129": "\tpublic int getColumnCount()\t{\n\t\treturn columnInfo == null ? 0 : columnInfo.length;\n\t}\n",
    "92130": "\tpublic boolean isAutoIncrement(int column) throws SQLException\t{\n\n\t\tResultColumnDescriptor rcd = columnInfo[column - 1];\n\t\treturn rcd.isAutoincrement();\n\t}\n",
    "92132": "\tpublic boolean isCaseSensitive(int column) throws SQLException\t{\n\t  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));\n\t}\n",
    "92133": "\tpublic boolean isSearchable(int column) throws SQLException\t{\n\t\tvalidColumnNumber(column);\n\n\t\t// we have no restrictions yet, so this is always true\n\t\t// might eventually be false for e.g. extra-long columns?\n\t\treturn true;\n\t}\n",
    "92134": "\tpublic boolean isCurrency(int column) throws SQLException\t{\n\n\t\treturn DataTypeUtilities.isCurrency(getColumnTypeDescriptor(column));\n\t}\n",
    "92135": "\tpublic int isNullable(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));\n\t}\n",
    "92136": "\tpublic boolean isSigned(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));\n\t}\n",
    "92138": "\tpublic int getColumnDisplaySize(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));\n\t}\n",
    "92139": "\tpublic String getColumnLabel(int column) throws SQLException {\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getName();\n\n\t\t// we could get fancier than this, but it's simple\n    \treturn (s==null? \"Column\"+Integer.toString(column) : s);\n\t}\n",
    "92140": "\tpublic String getColumnName(int column) throws SQLException\t{\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getName();\n\t\t// database returns null when no column name to differentiate from empty name\n    \treturn (s==null? \"\" : s);\n\n\t}\n",
    "92141": "\tpublic String getSchemaName(int column) throws SQLException\t{\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\n\t\tString s = cd.getSourceSchemaName();\n\t\t// database returns null when no schema name to differentiate from empty name\n\t\treturn (s==null? \"\" : s);\n\t}\n",
    "92142": "\tpublic int getPrecision(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));\n\t}\n",
    "92144": "\tpublic int getScale(int column) throws SQLException\t{\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\t// REMIND -- check it is valid to ask for scale\n\t\treturn dtd.getScale();\n\t}\n",
    "92145": "\tpublic String getTableName(int column) throws SQLException {\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getSourceTableName();\n\n\t\t// database returns null when no table name to differentiate from empty name\n\t\treturn (s==null? \"\" : s);\n\t}\n",
    "92146": "\tpublic String getCatalogName(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\t\treturn \"\";\n\t}\n",
    "92147": "\tpublic int getColumnType(int column) throws SQLException {\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\treturn dtd.getTypeId().getJDBCTypeId();\n\t}\n",
    "92149": "\tpublic String toString() {\n\t\treturn \"SQL Warning: \" + getMessage();\n\t}\n",
    "92150": "\tpublic String getColumnTypeName(int column) throws SQLException\t{\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\treturn dtd.getTypeId().getSQLTypeName();\n\t}\n",
    "92153": "\tpublic boolean isReadOnly(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\n\t\t// we just don't know if it is a base table column or not\n\t\treturn false;\n\t}\n",
    "92157": "\tpublic boolean isWritable(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\t\treturn columnInfo[column - 1].updatableByCursor();\n\t}\n",
    "92160": "\tpublic boolean isDefinitelyWritable(int column) throws SQLException\t{\n\t\tvalidColumnNumber(column);\n\n\t\t// we just don't know if it is a base table column or not\n\t\treturn false;\n\t}\n",
    "92175": "\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\n\t\tif (finalizeActivation != null) {\n\t\t\tfinalizeActivation.markUnused();\n\t\t}\t\t\n\t}\n",
    "92184": "\tpublic int getMaxFieldSize() throws SQLException {\n\t\tcheckStatus();\n\n        return MaxFieldSize;\n\t}\n",
    "92192": "\tpublic void setEscapeProcessing(boolean enable) throws SQLException\t{\n\t\tcheckStatus();\n        // Nothing to do in our server , just ignore it.\n\n\t}\n",
    "92193": "\tpublic int getQueryTimeout() throws SQLException {\n        // Currently Cloudscape does not support any sort of timeout, so always\n        // return 0, which means that timeout is unlimited.\n        return(0);\n\t}\n",
    "92195": "\tpublic void setQueryTimeout(int seconds) throws SQLException {\n\t\tif (seconds != 0)\n\t\t\tthrow Util.notImplemented(\"setQueryTimeout\");\n\t}\n",
    "92196": "\tpublic void cancel() throws SQLException {\n\t\tthrow Util.notImplemented(\"cancel\");\n\t}\n",
    "92198": "\tpublic SQLWarning getWarnings() throws SQLException\t{\n\t\tcheckStatus();\n\t\treturn warnings;\n\t}\n",
    "92199": "\tpublic void clearWarnings() throws SQLException\t{\n\t\tcheckStatus();\n\t\twarnings = null;\n\t}\n",
    "92202": "\tpublic void setCursorName(String name) throws SQLException {\n\t\tcheckStatus();\n\t\tcursorName = name;\n\t}\n",
    "92207": "    public ResultSetMetaData getMetaData() throws SQLException {\n\n\t  checkIfClosed(\"getMetaData\");\t// checking result set closure does not depend\n\t\t\t\t\t\t\t\t// on the underlying connection.  Do this\n\t\t\t\t\t\t\t\t// outside of the connection synchronization.\n\n\t  synchronized (getConnectionSynchronization()) {\n\n\n\t\tif (rMetaData == null) {\n\t\t\t// cache this object and keep returning it\n\t\t\trMetaData = newEmbedResultSetMetaData(resultDescription);\n\t\t}\n\t\treturn rMetaData;\n\t  }\n\t}\n",
    "92226": "\tprotected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {\n\t\treturn execute((String)batchElement, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);\n\t}\n",
    "92241": "\tpublic void transferBatch(EmbedStatement other) throws SQLException {\n\t\t\n\t\tsynchronized (getConnectionSynchronization()) {\n\t\t\tother.batchStatements = batchStatements;\n\t\t\tbatchStatements = null;\n\t\t}\n\t}\n",
    "92266": "\tpublic void printStackTrace() {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace();\n\t\telse\n\t\t\tsuper.printStackTrace();\n\t}\n",
    "92267": "\tpublic void printStackTrace(PrintStream s) {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace(s);\n\t\telse\n\t\t\tsuper.printStackTrace(s);\n\t}\n",
    "92268": "\tpublic void printStackTrace(PrintWriter s) {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace(s);\n\t\telse\n\t\t\tsuper.printStackTrace(s);\n\t}\n",
    "92269": "\tpublic String toString() {\n\t\treturn \"SQL Exception: \" + getMessage();\n\t}\n",
    "92277": "\tpublic String getProperty(String key) {\n\n\t\tString propertyValue = null;\n\t\tTransactionController tc = null;\n\n\t\ttry {\n\n\t\t  if (store != null)\n          {\n            tc = store.getTransaction(\n                ContextService.getFactory().getCurrentContextManager());\n          }\n\n\t\t  propertyValue =\n\t\t\tPropertyUtil.getServiceProperty(tc,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t(String) null);\n\t\t  if (tc != null) {\n\t\t\ttc.commit();\n\t\t\ttc = null;\n\t\t  }\n\n\t\t} catch (StandardException se) {\n\t\t\t// Do nothing and just return\n\t\t}\n\n\t\treturn propertyValue;\n\t}\n",
    "92286": "\tpublic boolean canSupport(Properties properties) {\n\n\t\tif (!requireAuthentication(properties))\n\t\t\treturn false;\n\n\t\t//\n\t\t// We check 2 System/Database properties:\n\t\t//\n\t\t//\n\t\t// - if derby.authentication.provider is set to 'BUILTIN'.\n\t\t//\n\t\t// and in that case we are the authentication service that should\n\t\t// be run.\n\t\t//\n\n\t\tString authenticationProvider = PropertyUtil.getPropertyFromSet(\n\t\t\t\t\tproperties,\n\t\t\t\t\torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);\n\n\t\tif ( (authenticationProvider != null) &&\n\t\t\t (authenticationProvider.length() != 0) &&\n\t\t\t (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,\n\t\t\t\t  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\t// Yep, we're on!\n\t}\n",
    "92289": "\tpublic boolean canSupport(Properties properties) {\n\n\t\tif (!requireAuthentication(properties))\n\t\t\treturn false;\n\n\t\t//\n\t\t// we check 2 things:\n\t\t//\n\t\t// - if derby.connection.requireAuthentication system\n\t\t//   property is set to true.\n\t\t// - if derby.authentication.provider is set to one\n\t\t// of the JNDI scheme we support (i.e. LDAP).\n\t\t//\n\n\t\tauthenticationProvider = PropertyUtil.getPropertyFromSet(\n\t\t\t\t\tproperties,\n\t\t\t\t\t\torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);\n\n\t\t if ( (authenticationProvider != null) &&\n\t\t\t   (StringUtil.SQLEqualsIgnoreCase(authenticationProvider,\n\t\t\t\t  \torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n",
    "92299": "\tprivate void setInitDirContextEnv(Properties dbProps) {\n\n\t\t//\n\t\t// We retrieve JNDI properties set at the database level\t\n\t\t// if any.\n\t\t//\n\t\tinitDirContextEnv = new Properties();\n\n\t\tfor (Enumeration keys = dbProps.propertyNames(); keys.hasMoreElements(); ) {\n\n\t\t\tString key = (String) keys.nextElement();\n\n\t\t\tif (key.startsWith(\"java.naming.\")) {\n\t\t\t\tinitDirContextEnv.put(key, dbProps.getProperty(key));\n\t\t\t}\n\t\t}\n\t}\n",
    "92300": "\tpublic boolean canSupport(Properties properties) {\n\n\t\treturn !requireAuthentication(properties);\n\t}\n",
    "92303": "\tpublic int read() throws IOException {\n\n\t\tif (dummyBytes != 0) {\n\t\t\tdummyBytes--;\n\t\t\treturn 0;\n\t\t}\n\n\t\tint ret = super.read();\n\n\t\tif (ret < 0)\n\t\t\tcheckSufficientData();\n\n\t\treturn ret;\n\t}\n",
    "92305": "\tpublic int read(byte b[], int off, int len) throws IOException {\n\n\t\tint dlen = dummyBytes;\n\n\t\tif (dlen != 0) {\n\t\t\tif (len < dlen)\n\t\t\t\tdlen = len;\n\t\t\tfor (int i = 0; i < dlen; i++) {\n\t\t\t\tb[off+i] = 0;\n\t\t\t}\n\t\t\tdummyBytes -= dlen;\n\n\t\t\toff += dlen;\n\t\t\tlen -= dlen;\n\t\t}\n\n\t\tint realRead = super.read(b, off, len);\n\n\t\tif (realRead < 0)\n\t\t{\n\t\t\tif (dlen != 0)\n\t\t\t\treturn dlen;\n\n\t\t\tcheckSufficientData();\n\n\t\t\treturn realRead;\n\t\t}\n\n\t\treturn dlen + realRead;\n\t}\n",
    "92353": "\tpublic boolean allProceduresAreCallable() {\n\t\treturn true;\n\t}\n",
    "92356": "\tpublic boolean allTablesAreSelectable() {\n\t\treturn true;\n\t}\n",
    "92359": "\tpublic String getUserName() {\n\t\treturn (getEmbedConnection().getTR().getUserName());\n\t}\n",
    "92360": "\tpublic boolean isReadOnly() {\n\t\treturn getLanguageConnectionContext().getDatabase().isReadOnly();\n\t}\n",
    "92364": "\tpublic boolean nullsAreSortedHigh() {\n\t\treturn true;\n\t}\n",
    "92365": "\tpublic boolean nullsAreSortedLow() {\n\t\treturn false;\n\t}\n",
    "92367": "\tpublic boolean nullsAreSortedAtStart() {\n\t\treturn false;\n\t}\n",
    "92369": "\tpublic boolean nullsAreSortedAtEnd() {\n\t\treturn false;\n\t}\n",
    "92372": "\tpublic String getDatabaseProductName() {\n\t\treturn Monitor.getMonitor().getEngineVersion().getProductName();\n\t}\n",
    "92374": "\tpublic String getDatabaseProductVersion() {\n\t\tProductVersionHolder myPVH = Monitor.getMonitor().getEngineVersion();\n\n\t\treturn myPVH.getVersionBuildString(false);\n\t}\n",
    "92376": "\tpublic String getDriverName() {\n\t\treturn \"Apache Derby Embedded JDBC Driver\";\n\t}\n",
    "92380": "\tpublic String getDriverVersion()  {\n\t\treturn getDatabaseProductVersion();\n\t}\n",
    "92381": "\tpublic int getDriverMajorVersion() {\n\t\treturn getEmbedConnection().getLocalDriver().getMajorVersion();\n\t}\n",
    "92383": "\tpublic int getDriverMinorVersion() {\n\t\treturn getEmbedConnection().getLocalDriver().getMinorVersion();\n\t}\n",
    "92386": "\tpublic boolean usesLocalFiles() {\n\t\treturn true;\n\t}\n",
    "92388": "\tpublic boolean usesLocalFilePerTable() {\n\t\treturn true;\n\t}\n",
    "92390": "\tpublic boolean supportsMixedCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92392": "\tpublic boolean storesUpperCaseIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92395": "\tpublic boolean storesLowerCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92397": "\tpublic boolean storesMixedCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92400": "\tpublic boolean supportsMixedCaseQuotedIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92402": "\tpublic boolean storesUpperCaseQuotedIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92404": "\tpublic boolean storesLowerCaseQuotedIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92405": "\tpublic boolean storesMixedCaseQuotedIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92409": "\tpublic String getIdentifierQuoteString() {\n\t\treturn \"\\\"\";\n\t}\n",
    "92411": "\tpublic String getSQLKeywords() {\n\t\treturn \"ALIAS,BIGINT,BOOLEAN,CALL,CLASS,COPY,DB2J_DEBUG,EXECUTE,EXPLAIN,FILE,FILTER,\"\n\t\t\t+  \"GETCURRENTCONNECTION,INDEX,INSTANCEOF,METHOD,NEW,OFF,PROPERTIES,PUBLICATION,RECOMPILE,\"\n\t\t\t+  \"REFRESH,RENAME,RUNTIMESTATISTICS,STATEMENT,STATISTICS,TIMING,WAIT\";\n\t}\n",
    "92412": "\tpublic String getNumericFunctions() {\n\t\treturn \"ABS,SQRT\";\n\t}\n",
    "92415": "\tpublic String getStringFunctions() {\n\t\treturn \"LENGTH,LOWER,LTRIM,RTRIM,SUBSTR,SUBSTRING,UPPER\";\n\t}\n",
    "92418": "\tpublic String getSystemFunctions()  {\n\t\treturn \"CURRENT_USER,getCurrentConnection,runTimeStatistics,SESSION_USER,USER,CURRENT SCHEMA\";\n\t}\n",
    "92420": "\tpublic String getTimeDateFunctions() {\n\t\treturn \"CURDATE,CURTIME,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,EXTRACT\";\n\t}\n",
    "92422": "\tpublic String getSearchStringEscape()  {\n\t\treturn \"\";\n\t}\n",
    "92425": "\tpublic String getExtraNameCharacters()  {\n\t\treturn \"\";\n\t}\n",
    "92427": "\tpublic boolean supportsAlterTableWithAddColumn() {\n\t\treturn true;\n\t}\n",
    "92429": "\tpublic boolean supportsAlterTableWithDropColumn() {\n\t\treturn true;\n\t}\n",
    "92432": "\tpublic boolean supportsColumnAliasing() {\n\t\treturn true;\n\t}\n",
    "92433": "\tpublic boolean nullPlusNonNullIsNull()  {\n\t\treturn true;\n\t}\n",
    "92437": "\tpublic boolean supportsConvert() {\n\t\treturn true;\n\t}\n",
    "92440": "\tpublic boolean supportsConvert(int fromType, int toType) {\n\t\t/*\n\t\t * at the moment we don't support CONVERT at all, so we take the easy\n\t\t * way out.  Eventually we need to figure out how to handle this\n\t\t * cleanly.\n\t\t */\n\t\treturn false;\n\t}\n",
    "92441": "\tpublic boolean supportsTableCorrelationNames()  {\n\t\treturn true;\n\t}\n",
    "92444": "\tpublic boolean supportsDifferentTableCorrelationNames() {\n\t\treturn true;\n\t}\n",
    "92446": "\tpublic boolean supportsExpressionsInOrderBy() {\n\t\treturn false;\n\t}\n",
    "92448": "\tpublic boolean supportsOrderByUnrelated() {\n\t\treturn false;\n\t}\n",
    "92450": "\tpublic boolean supportsGroupBy() {\n\t\treturn true;\n\t}\n",
    "92454": "\tpublic boolean supportsGroupByUnrelated()  {\n\t\treturn true;\n\t}\n",
    "92456": "\tpublic boolean supportsGroupByBeyondSelect() {\n\t\treturn true;\n\t}\n",
    "92458": "\tpublic boolean supportsLikeEscapeClause() {\n\t\treturn true;\n\t}\n",
    "92461": "\tpublic boolean supportsMultipleResultSets()  {\n\t\treturn true;\n\t}\n",
    "92462": "\tpublic boolean supportsMultipleTransactions() {\n\t\treturn true;\n\t}\n",
    "92465": "\tpublic boolean supportsNonNullableColumns()  {\n\t\treturn true;\n\t}\n",
    "92466": "\tpublic boolean supportsMinimumSQLGrammar() {\n\t\treturn true;\n\t}\n",
    "92469": "\tpublic boolean supportsCoreSQLGrammar() {\n\t\treturn false;\n\t}\n",
    "92473": "\tpublic boolean supportsExtendedSQLGrammar() {\n\t\treturn false;\n\t}\n",
    "92474": "\tpublic boolean supportsANSI92EntryLevelSQL() {\n\t\treturn false;\n\t}\n",
    "92477": "\tpublic boolean supportsANSI92IntermediateSQL() {\n\t\treturn false;\n\t}\n",
    "92479": "\tpublic boolean supportsANSI92FullSQL() {\n\t\treturn false;\n\t}\n",
    "92481": "\tpublic boolean supportsIntegrityEnhancementFacility() {\n\t\treturn false;\n\t}\n",
    "92483": "\tpublic boolean supportsOuterJoins() {\n\t\treturn true;\n\t}\n",
    "92486": "\tpublic boolean supportsFullOuterJoins()  {\n\t\treturn false;\n\t}\n",
    "92488": "\tpublic boolean supportsLimitedOuterJoins() {\n\t\treturn true;\n\t}\n",
    "92491": "\tpublic String getSchemaTerm() {\n\t\treturn \"SCHEMA\";\n\t}\n",
    "92494": "\tpublic String getProcedureTerm() {\n\t\treturn \"PROCEDURE\";\n\t}\n",
    "92495": "\tpublic String getCatalogTerm() {\n\t\treturn \"CATALOG\";\n\t}\n",
    "92498": "\tpublic boolean isCatalogAtStart() {\n\t\treturn false;\n\t}\n",
    "92500": "\tpublic String getCatalogSeparator() {\n\t\treturn \"\";\n\t}\n",
    "92502": "\tpublic boolean supportsSchemasInDataManipulation() {\n\t\treturn true;\n\t}\n",
    "92505": "\tpublic boolean supportsSchemasInProcedureCalls() {\n\t\treturn true;\n\t}\n",
    "92508": "\tpublic boolean supportsSchemasInTableDefinitions() {\n\t\treturn true;\n\t}\n",
    "92510": "\tpublic boolean supportsSchemasInIndexDefinitions() {\n\t\treturn true;\n\t}\n",
    "92512": "\tpublic boolean supportsSchemasInPrivilegeDefinitions() {\n\t\treturn true;\n\t}\n",
    "92515": "\tpublic boolean supportsCatalogsInDataManipulation() {\n\t\treturn false;\n\t}\n",
    "92517": "\tpublic boolean supportsCatalogsInProcedureCalls() {\n\t\treturn false;\n\t}\n",
    "92519": "\tpublic boolean supportsCatalogsInTableDefinitions() {\n\t\treturn false;\n\t}\n",
    "92522": "\tpublic boolean supportsCatalogsInIndexDefinitions() {\n\t\treturn false;\n\t}\n",
    "92523": "\tpublic boolean supportsCatalogsInPrivilegeDefinitions() {\n\t\treturn false;\n\t}\n",
    "92527": "\tpublic boolean supportsPositionedDelete() {\n\t\treturn true;\n\t}\n",
    "92529": "\tpublic boolean supportsPositionedUpdate() {\n\t\treturn true;\n\t}\n",
    "92532": "\tpublic boolean supportsSelectForUpdate() {\n\t\treturn true;\n\t}\n",
    "92534": "\tpublic boolean supportsStoredProcedures() {\n\t\treturn true;\n\t}\n",
    "92536": "\tpublic boolean supportsSubqueriesInComparisons() {\n\t\treturn true;\n\t}\n",
    "92539": "\tpublic boolean supportsSubqueriesInExists() {\n\t\treturn true;\n\t}\n",
    "92540": "\tpublic boolean supportsSubqueriesInIns() {\n\t\treturn true;\n\t}\n",
    "92547": "\tpublic boolean supportsCorrelatedSubqueries() {\n\t\treturn true;\n\t}\n",
    "92548": "\tpublic boolean supportsUnion() {\n\t\treturn true;\n\t}\n",
    "92551": "\tpublic boolean supportsUnionAll() {\n\t\treturn true;\n\t}\n",
    "92555": "\tpublic boolean supportsOpenCursorsAcrossRollback() {\n\t\treturn false;\n\t}\n",
    "92558": "\tpublic boolean supportsOpenStatementsAcrossCommit() {\n\t\treturn true;\n\t}\n",
    "92561": "\tpublic boolean supportsOpenStatementsAcrossRollback() {\n\t\treturn false;\n\t}\n",
    "92564": "\tpublic int getMaxBinaryLiteralLength() {\n\t\treturn 0;\n\t}\n",
    "92565": "\tpublic int getMaxCharLiteralLength() {\n\t\treturn 0;\n\t}\n",
    "92568": "\tpublic int getMaxColumnNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92570": "\tpublic int getMaxColumnsInGroupBy() {\n\t\treturn 0;\n\t}\n",
    "92572": "\tpublic int getMaxColumnsInIndex() {\n\t\treturn 0;\n\t}\n",
    "92575": "\tpublic int getMaxColumnsInOrderBy() {\n\t\treturn 0;\n\t}\n",
    "92577": "\tpublic int getMaxColumnsInSelect() {\n\t\treturn 0;\n\t}\n",
    "92580": "\tpublic int getMaxColumnsInTable()  {\n\t\treturn 0;\n\t}\n",
    "92582": "\tpublic int getMaxConnections() {\n\t\treturn 0;\n\t}\n",
    "92585": "\tpublic int getMaxCursorNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92587": "\tpublic int getMaxIndexLength() {\n\t\treturn 0;\n\t}\n",
    "92589": "\tpublic int getMaxSchemaNameLength()  {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92592": "\tpublic int getMaxProcedureNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92593": "\tpublic int getMaxCatalogNameLength()  {\n\t\treturn 0;\n\t}\n",
    "92597": "\tpublic int getMaxRowSize() {\n\t\treturn 0;\n\t}\n",
    "92600": "\tpublic boolean doesMaxRowSizeIncludeBlobs() {\n\t\treturn true;\n\t}\n",
    "92601": "\tpublic int getMaxStatementLength() {\n\t\treturn 0;\n\t}\n",
    "92604": "\tpublic int getMaxStatements() {\n\t\treturn 0;\n\t}\n",
    "92606": "\tpublic int getMaxTableNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92615": "\tpublic int getMaxTablesInSelect() {\n\t\treturn 0;\n\t}\n",
    "92622": "\tpublic int getMaxUserNameLength() {\n\t\treturn Limits.DB2_MAX_USERID_LENGTH;\n\t}\n",
    "92630": "\tpublic int getDefaultTransactionIsolation() {\n\t\treturn java.sql.Connection.TRANSACTION_READ_COMMITTED;\n\t}\n",
    "92639": "\tpublic boolean supportsTransactions()  {\n\t\treturn true;\n\t}\n",
    "92656": "\tpublic boolean supportsDataDefinitionAndDataManipulationTransactions() {\n\t\t\t return true;\n\t}\n",
    "92668": "\tpublic boolean dataDefinitionCausesTransactionCommit() {\n\t\treturn false;\n\t}\n",
    "92676": "\tpublic boolean dataDefinitionIgnoredInTransactions(){\n\t\treturn false;\n\t}\n",
    "92771": "\tpublic ResultSet getSchemas() throws SQLException {\n\t\treturn getSimpleQuery(\"getSchemas\");\n\t}\n",
    "92775": "\tpublic ResultSet getCatalogs() throws SQLException {\n\t\treturn getSimpleQuery(\"getCatalogs\");\n\t}\n",
    "92779": "\tpublic ResultSet getTableTypes() throws SQLException {\n\t\treturn getSimpleQuery(\"getTableTypes\");\n\t}\n",
    "92850": "\tpublic ResultSet getTypeInfo() throws SQLException {\n\t\treturn getSimpleQuery(\"getTypeInfo\");\n\t}\n",
    "92854": "\tpublic ResultSet getTypeInfoForODBC() throws SQLException {\n\t\treturn getSimpleQuery(\"odbc_getTypeInfo\");\n\t}\n",
    "92859": "\tpublic void resetCacheStats(String cacheName) {\n\t\tgetRawStoreXact().resetCacheStats(cacheName);\n\t}\n",
    "93292": "\tpublic void writeExternal_v36(ObjectOutput out) throws IOException {\n\t\tsuper.writeExternal(out);\n\t\tout.writeLong(baseConglomerateId);\n\t\tout.writeInt(rowLocationColumn);\n\t}\n",
    "93320": "\tpublic int getColumnId() {\n\t\treturn columnId;\n\t}\n",
    "93321": "\tpublic DataValueDescriptor getOrderable() {\n\t\treturn value;\n\t}\n",
    "93322": "\tpublic int getOperator() {\n\t\treturn DataValueDescriptor.ORDER_OP_EQUALS;\n\n\t}\n",
    "93324": "\tpublic boolean negateCompareResult() {\n\t\treturn false;\n\t}\n",
    "93326": "    public boolean getUnknownRV() {\n\t\treturn false;\n\t}\n",
    "93543": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;\n\t}\n",
    "93631": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHECKSUM;\n\t}\n",
    "93688": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHECKPOINT;\n\t}\n",
    "93711": "\tpublic long getValueAsLong() {\n\t\treturn makeLogInstantAsLong(fileNumber, filePosition);\n\t}\n",
    "93715": "\tpublic void readExternal(ObjectInput oi) throws IOException, ClassNotFoundException {\n\t\tfileNumber = CompressedNumber.readLong(oi);\n\t\tfilePosition = CompressedNumber.readLong(oi);\n\t}\n",
    "93716": "\tpublic void writeExternal(ObjectOutput oo) throws IOException {\n\t\tCompressedNumber.writeLong(oo,fileNumber);\n\t\tCompressedNumber.writeLong(oo,filePosition);\n\t}\n",
    "93733": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.FILE_STREAM_LOG_FILE;\n\t}\n",
    "93746": "\tpublic int\tgetId() {\n\t\treturn recordId;\n\t}\n",
    "93753": "\tpublic boolean lockerAlwaysCompatible() {\n\t\treturn true;\n\t}\n",
    "93757": "\tpublic boolean equals(Object ref) {\n\n\t\tif (!(ref instanceof RecordId))\n\t\t\treturn false;\n\n\t\tRecordId other = (RecordId) ref;\n\n\t\treturn ((recordId == other.recordId)\n\t\t\t&& pageId.equals(other.pageId));\n\t}\n",
    "93758": "\tpublic int hashCode() {\n\n\t\treturn (int) recordId ^ pageId.hashCode();\n\t}\n",
    "93764": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_INVALIDATE_PAGE;\n\t}\n",
    "93773": "\tpublic void removeContainer() throws StandardException {\n\t\tcontainer.removeContainer();\n\t}\n",
    "93774": "\tpublic Logger getLogger() {\n\n\t\tif (ReadOnlyDB)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn new FileLogger(this);\n\t}\n",
    "93775": "\tpublic ContainerKey getId() {\n\t\treturn identity;\n\t}\n",
    "93777": "\tpublic boolean useContainer() throws StandardException {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(!active);\n\t\t\tSanityManager.ASSERT(container != null);\n\t\t}\n\n\t\t// always set forUpdate to false\n\t\tif (!container.use(this)) {\n\t\t\tcontainer = null;\n\t\t\treturn false;\n\t\t}\n\n\t\tactive = true;\n\n\t\t// watch transaction and close ourseleves just before it completes.\n        if (!hold)\n        {\n            xact.addObserver(this);\n            xact.addObserver(new DropOnCommit(identity, true));\n        }\n\n\t\treturn true;\n\t}\n",
    "93788": "\tpublic Page addPage(int flag) throws StandardException {\n\n\t\tif ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)\n\t\t{\n\t\t\t// start preallocating immediatelly, don't wait for the\n\t\t\t// preallocation threshold to be crossed.  Don't go wild and\n\t\t\t// preallocate a bunch of pages either, use preAllocate for that. \n\t\t\tcontainer.clearPreallocThreshold();\n\t\t}\n\n\t\treturn addPage();\n\t}\n",
    "93879": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_UPDATE;\n\t}\n",
    "93880": "\tpublic int getNextStartColumn() {\n\t\treturn nextColumn;\n\t}\n",
    "93931": "\tpublic Cacheable setIdentity(Object key) throws StandardException {\n\n\t\tContainerKey newIdentity = (ContainerKey) key;\n\n\t\t// if this is an open for a temp container then return an object of that type\n\t\tif (newIdentity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT) {\n\n\t\t\tTempRAFContainer tmpContainer = new TempRAFContainer(dataFactory);\n\t\t\treturn tmpContainer.setIdent(newIdentity);\n\t\t}\n\n\t\treturn setIdent(newIdentity);\n\t}\n",
    "93950": "\tprotected void flushAll() throws StandardException {\n\n\t\tpageCache.clean(identity);\n\n\t\t// now clean myself which will sync all my pages.\n\t\tclean(false);\n\t}\n",
    "93980": "\tpublic boolean isDirty() {\n\n\t\tsynchronized (this) {\n\t\t\treturn isDirty || preDirty;\n\t\t}\n\t}\n",
    "93981": "\tpublic boolean isActuallyDirty() {\n\n\t\tsynchronized (this) {\n\t\t\treturn isDirty;\n\t\t}\n\t\t\n\t}\n",
    "93998": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_REMOVE_FILE;\n\t}\n",
    "94007": "\tprotected void createContainer(ContainerKey newIdentity) throws StandardException {\n\t\t// RESOLVE - probably should throw an error ...\n\t}\n",
    "94008": "\tprotected void readPositionedPage(long pageOffset, byte[] pageData) throws IOException {\n\n\n\t\tInputStream is = null;\n\t\ttry {\n\t\t\t// no need to synchronize as each caller gets a new stream\n\t\t\tis = getInputStream();\n\n\t\t\tInputStreamUtil.skipBytes(is, pageOffset);\n\n\t\t\tInputStreamUtil.readFully(is, pageData, 0, pageSize);\n\n\t\t\tis.close();\n\t\t\tis = null;\n\t\t} finally {\n\t\t\tif (is != null) {\n\t\t\t\ttry {is.close();} catch (IOException ioe) {}\n\t\t\t}\n\t\t}\n\t}\n",
    "94017": "\tpublic InputStream getReplayStream() throws IOException {\n\t\tbh.startReading();\n\t\trecording = false;\n\t\treturn new ByteHolderInputStream(bh);\n\t}\n",
    "94018": "\tpublic ByteHolder getByteHolder() throws IOException {\n\t\treturn bh;\n\t}\n",
    "94020": "\tpublic void clear() throws IOException {\n\t\tbh.clear();\n\t\trecording = true;\n\t}\n",
    "94021": "\tpublic void setInput(InputStream in) {\n\t\tthis.in = in;\n\t}\n",
    "94022": "\tpublic boolean recording() {\n\t\treturn recording;\n\t}\n",
    "94023": "\tpublic int available() throws IOException {\n\t\t// may not have set reading to be true, then,\n\t\t// we are getting available in negative numbers.\n\t\tint remainingBytes = bh.available();\n\t\tremainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;\n\t\treturn remainingBytes;\n\t}\n",
    "94025": "\tpublic int shiftToFront() throws IOException {\n\t\tint bytesShifted = bh.shiftToFront();\n\t\treturn bytesShifted;\n\t}\n",
    "94059": "\tpublic Object getIdentity() {\n\t\treturn identity;\n\t}\n",
    "94087": "\tpublic void unlatch() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(isLatched());\n\t\t}\n\n\t   releaseExclusive();\n\t}\n",
    "94104": "\tpublic boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "94108": "\tpublic boolean lockerAlwaysCompatible() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "94109": "\tpublic void unlockEvent(Latch lockInfo) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\tsynchronized (this) {\n\n\t\t\tif (SanityManager.DEBUG) {\n\t\t\t\tif (nestedLatch != 0)\n\t\t\t\t\tSanityManager.THROWASSERT(\"nestedLatch is non-zero on unlockEvent - value = \" + nestedLatch);\n\t\t\t}\n\n\t\t\towner.deleteObserver(this);\n\t\t\towner = null;\n\t\t\tmyLatch = null;\n\t\t\tif (inClean)\n\t\t\t\tnotifyAll();\n\t\t}\n\t}\n",
    "94115": "\tpublic PageKey getPageId() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(identity != null);\n\t\t}\n\n\t\treturn identity;\n\t}\n",
    "94118": "\tprotected void releaseExclusive() /* throws StandardException */ {\n\n\t\tif (SanityManager.DEBUG) {\n            if (!isLatched())\n            {\n                SanityManager.THROWASSERT(\n                    \"releaseExclusive failed, nestedLatch = \" + nestedLatch);\n            }\n\t\t}\n\n\t\tif (nestedLatch > 0) {\n\t\t\tnestedLatch--;\n\t\t\treturn;\n\t\t}\n\n\t\tRawTransaction t = owner.getTransaction();\n\t\tt.getLockFactory().unlatch(myLatch);\n\t}\n",
    "94122": "\tpublic int setDeleteStatus(int slot, boolean delete) throws StandardException, IOException {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\t// latch check performed in checkSlotOnPage\n\t\t\tcheckSlotOnPage(slot);;\n\t\t}\n\n\t\treturn (getHeaderAtSlot(slot).setDeleted(delete));\n\t}\n",
    "94129": "\tpublic int findRecordById(int recordId, int slotHint) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(isLatched());\n\t\t}\n\n\t\tif (slotHint == FIRST_SLOT_NUMBER)\n\t\t\tslotHint = recordId - RecordHandle.FIRST_RECORD_ID;\n\n\t\tint\tmaxSlot = recordCount();\n\n       if ((slotHint > FIRST_SLOT_NUMBER)        &&\n            (slotHint < maxSlot)                   && \n            (recordId == getHeaderAtSlot(slotHint).getId())) {\n            return(slotHint);\n        } else {\n            for (int slot = FIRST_SLOT_NUMBER; slot < maxSlot; slot++) {\n\t\t\t\tif (recordId == getHeaderAtSlot(slot).getId()) {\n                    return slot;\n\t\t\t\t}\n            }\n        }\n\n\t\treturn -1;\n\t}\n",
    "94292": "\tprotected void letGo(BaseContainerHandle handle) {\n\n\t\tRawTransaction t = handle.getTransaction();\n\n\t\thandle.getLockingPolicy().unlockContainer(t, handle);\n\t}\n",
    "94304": "\tprotected void setDroppedState(boolean isDropped) {\n\t\tthis.isDropped = isDropped;\n\t}\n",
    "94311": "\tpublic void update(Observable obj, Object arg) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (arg == null)\n\t\t\t\tSanityManager.THROWASSERT(\"still on observr list \" + this);\n\t\t}\n\n\t\tif (arg.equals(RawTransaction.COMMIT) || arg.equals(RawTransaction.ABORT)) {\n\n\t\t\tRawTransaction xact = (RawTransaction) obj;\n\n\t\t\ttry {\n\t\t\t\tif (this.isStreamContainer)\n\t\t\t\t\txact.dropStreamContainer(identity.getSegmentId(), identity.getContainerId());\n\t\t\t\telse\n\t\t\t\t\txact.dropContainer(identity);\n\t\t\t} catch (StandardException se) {\n\t\t\t\txact.setObserverException(se);\n\t\t\t}\n\n\t\t\tobj.deleteObserver(this);\n\t\t}\n\t}\n",
    "94332": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_SET_RESERVED_SPACE;\n\t}\n",
    "94378": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHAIN_ALLOC_PAGE;\n\t}\n",
    "94475": "\tpublic StandardException markCorrupt(StandardException originalError) {\n\t\tboolean firsttime = !isCorrupt;\n\n\t\tisCorrupt = true;\n\t\tif (getLogFactory() != null)\n\t\t\tgetLogFactory().markCorrupt(originalError);\n\n\t\t// if firsttime markCorrupt is called, release the JBMS lock so user\n\t\t// can move the database if so desired.\n\t\tif (firsttime)\n\t\t{\n\t\t\t// get rid of everything from the cache without first cleaning them\n\t\t\tif (pageCache != null)\n\t\t\t\tpageCache.discard(null);\n\n\t\t\tif (containerCache != null)\n\t\t\t\tcontainerCache.discard(null);\n\n\t\t\t// don't read in any more pages \n\t\t\tpageCache = null;\n\t\t\tcontainerCache = null;\n\n\t\t\treleaseJBMSLockOnDB();\n\t\t}\n\n\t\treturn originalError;\n\t}\n",
    "94490": "\tpublic String getRootDirectory() {\n\t\treturn dataDirectory;\n\t}\n",
    "94511": "\tprivate boolean handleServiceType( Properties startParams, String type) {\n        try\n        {\n            PersistentService ps = Monitor.getMonitor().getServiceProvider( startParams, type);\n            return ps != null && ps.hasStorageFactory();\n        }\n        catch( StandardException se){ return false;}\n\t}\n",
    "94538": "\tpublic void postRecovery() throws StandardException {\n\n\t\t// hook up the cache cleaner daemon after recovery is finished\n\t\tDaemonService daemon = rawStoreFactory.getDaemon();\n\n\t\tif (daemon == null)\n\t\t\treturn;\n\n\t\tcontainerCache.useDaemonService(daemon);\n\n\t\tpageCache.useDaemonService(daemon);\n\t\tif (postRecoveryRemovedFiles != null) {\n\n            synchronized( this)\n            {\n                actionCode = POST_RECOVERY_REMOVE_ACTION;\n                try\n                {\n                    AccessController.doPrivileged( this);\n                }\n                catch( PrivilegedActionException pae){} // POST_RECOVERY_REMOVE does not throw an exception\n            }\n\t\t\tpostRecoveryRemovedFiles = null;\n\t\t}\n\t}\n",
    "94554": "\tpublic boolean isReadOnly() {\n\t\t// return what the baseDataFileFactory thinks\n\t\treturn readOnly;\n\t}\n",
    "94561": "  final public void methodCallParameterList(Vector parameterList) throws ParseException, StandardException {\n    jj_consume_token(LEFT_PAREN);\n    if (jj_2_30(1)) {\n      methodParameter(parameterList);\n      label_17:\n      while (true) {\n        switch (jj_nt.kind) {\n        case COMMA:\n          ;\n          break;\n        default:\n          jj_la1[145] = jj_gen;\n          break label_17;\n        }\n        jj_consume_token(COMMA);\n        methodParameter(parameterList);\n      }\n    } else {\n      ;\n    }\n    jj_consume_token(RIGHT_PAREN);\n  }\n",
    "94576": "\tprotected void letGo(BaseContainerHandle handle) {\n\t\tsuper.letGo(handle);\n\n\t\tcontainerCache.release(this);\n\t}\n",
    "94584": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_COMPRESS_SPACE;\n\t}\n",
    "94614": "\tprotected void letGo(BaseContainerHandle handle) {\n\n\t\tinUseCount--;\n\t\tsuper.letGo(handle);\n\t}\n",
    "94616": "\tpublic boolean isSingleUser() {\n\t\treturn inUseCount == 1;\n\t}\n",
    "94638": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_UPDATE_FIELD;\n\t}\n",
    "94656": "\tpublic boolean equals(Object other) {\n\t\tif (other instanceof ContainerActionOnCommit) {\n\t\t\tif (!identity.equals(((ContainerActionOnCommit) other).identity))\n\t\t\t\treturn false;\n\n\t\t\t// the class of the types must match as well\n\t\t\treturn getClass().equals(other.getClass());\n\t\t}\n\t\treturn false;\n\t}\n",
    "94716": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_GLOBAL_XACT_ID_NEW;\n\t}\n",
    "94725": "\tpublic void resetCacheStats(String cacheName)  {\n\t\tgetDataFactory().resetCacheStats(cacheName);\n\t}\n",
    "94726": "\tpublic boolean anyoneBlocked() {\n\t\treturn getLockFactory().anyoneBlocked();\n\t}\n",
    "94746": "\tpublic void setTransactionId(GlobalTransactionId extid, TransactionId localid) {\n\n\t\tif (SanityManager.DEBUG) {\n\n\t\t\t//SanityManager.ASSERT(myGlobalId == null, \"my globalId is not null\");\n            if (!(state == IDLE || state == Xact.ACTIVE || \n                  (state== CLOSED && justCreated)))\n            {\n                SanityManager.THROWASSERT(\n                    \"my state is not idle nor active \" + state);\n            }\n\t\t}\n\n\t\tmyGlobalId = extid;\n\t\tmyId = localid;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (SanityManager.DEBUG_ON(\"XATrace\") && extid != null)\n            {\n\t\t\t\tSanityManager.DEBUG(\n                    \"XATrace\",\"setting xid: \" + myId + \" \" + myGlobalId \n\t\t\t\t\t\t\t   + \" state \" + state + \" \" + this);\n\n                SanityManager.showTrace(new Throwable());\n                // Thread.dumpStack();\n            }\n\t\t}\n\n\t}\n",
    "94813": "\tprivate void getLogger() {\n\n\t\tlogger = logFactory.getLogger();\n\t}\n",
    "94898": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_BEGIN_XACT;\n\t}\n",
    "94908": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;\n\t}\n",
    "94991": "\tpublic LockFactory getLockFactory() {\n\t\treturn lockFactory;\n\t}\n",
    "95011": "\tpublic StandardException markCorrupt(StandardException originalError) {\n\t\tlogFactory.markCorrupt(originalError);\n\t\treturn originalError;\n\t}\n",
    "95040": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_XACT_ID;\n\t}\n",
    "95048": "\tpublic boolean canSupport(Properties startParams) {\n\t\treturn true;\n\t}\n",
    "95052": "\tpublic boolean isReadOnly() {\n\t\treturn dataFactory.isReadOnly();\n\t}\n",
    "95131": "\tpublic String getString(int columnNumber)\n\t{\t\t\n\t\tString val = (String)currentRow.get(columnInfo[columnNumber-1].getName());\n\t\twasNull = (val == null);\n\n\t\treturn  val;\n\t}\n",
    "95455": "\tpublic boolean isAutoIncrement(int column) throws SQLException {\n\t\tthrow new SQLException(\"isAutoIncrement\");\n\t}\n",
    "95457": "\tpublic boolean isCaseSensitive(int column) throws SQLException {\n\t\tthrow new SQLException(\"isCaseSensitive\");\n\t}\n",
    "95458": "\tpublic boolean isSearchable(int column) throws SQLException{\n\t\tthrow new SQLException(\"isSearchable\");\n\t}\n",
    "95459": "\tpublic boolean isCurrency(int column) throws SQLException{\n\t\tthrow new SQLException(\"isCurrency\");\n\t}\n",
    "95460": "\tpublic int isNullable(int column) throws SQLException{\n\t\tthrow new SQLException(\"isNullable\");\n\t}\n",
    "95461": "\tpublic boolean isSigned(int column) throws SQLException {\n\t\tthrow new SQLException(\"isSigned\");\n\t}\n",
    "95463": "\tpublic  int getColumnDisplaySize(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnDisplaySize\");\n\t}\n",
    "95465": "\tpublic String getColumnLabel(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnLabel\");\n\t}\n",
    "95466": "\tpublic String getColumnName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnName\");\n\t}\n",
    "95467": "\tpublic  String getSchemaName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getSchemaName\");\n\t}\n",
    "95468": "\tpublic int getPrecision(int column) throws SQLException {\n\t\tthrow new SQLException(\"getPrecision\");\n\t}\n",
    "95469": "\tpublic  int getScale(int column) throws SQLException {\n\t\tthrow new SQLException(\"getScale\");\n\t}\n",
    "95471": "\tpublic  String getTableName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getTableName\");\n\t}\n",
    "95472": "\tpublic String getCatalogName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getCatalogName\");\n\t}\n",
    "95473": "\tpublic  String getColumnTypeName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnTypeName\");\n\t}\n",
    "95474": "\tpublic  boolean isReadOnly(int column) throws SQLException {\n\t\treturn true;\n\t}\n",
    "95475": "\tpublic  boolean isWritable(int column) throws SQLException {\n\t\treturn false;\n\t}\n",
    "95476": "\tpublic boolean isDefinitelyWritable(int column) throws SQLException {\n\t\treturn false;\n\t}\n",
    "95477": "\tpublic String getColumnClassName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnClassName\");\n\t}\n",
    "95612": "\tpublic void skipField(ObjectInput in) throws IOException {\n\n\n\t\tint fieldStatus = StoredFieldHeader.readStatus(in);\n\t\tint fieldDataLength = StoredFieldHeader.readFieldDataLength(in, fieldStatus, slotFieldSize);\n\n\t\tif (fieldDataLength != 0) {\n\t\t\tin.skipBytes(fieldDataLength);\n\t\t}\n\t}\n",
    "95656": "\tprotected void closeCurrentConnectionHandle() throws SQLException {\n\t\tif (currentConnectionHandle != null)\n\t\t{\n\t\t\tVector tmpEventListener = eventListener;\n\t\t\teventListener = null;\n\n\t\t\ttry {\n\t\t\t\tcurrentConnectionHandle.close();\n\t\t\t} finally {\n\t\t\t\teventListener = tmpEventListener;\n\t\t\t}\n\n\t\t\tcurrentConnectionHandle = null;\n\t\t}\n\t}\n",
    "95659": "\tpublic void notifyException(SQLException sqle) {\n\t\tthis.notifyError(sqle);\n\t}\n",
    "95662": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\t}\n",
    "95663": "\tpublic void checkSavepoint() throws SQLException {\n\t}\n",
    "95665": "\tpublic void checkRollback() throws SQLException {\n\t}\n",
    "95666": "\tpublic void checkCommit() throws SQLException {\n\t}\n",
    "95667": "\tpublic boolean closingConnection() throws SQLException {\n\t\tnotifyClose();\n\t\tcurrentConnectionHandle = null;\n\t\treturn false;\n\t}\n",
    "95669": "\tpublic Statement wrapStatement(Statement s) throws SQLException {\n\t\treturn s;\n\t}\n",
    "95670": "\tpublic PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {\n\t\treturn ps;\n\t}\n",
    "95671": "\tpublic CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {\n\t\treturn cs;\n\t}\n",
    "95695": "\tpublic int getLoginTimeout() throws SQLException {\n\t\treturn loginTimeout;\n\t}\n",
    "95696": "\tpublic void setLoginTimeout(int seconds) throws SQLException {\n\t\tloginTimeout = seconds;\n\t}\n",
    "95697": "\tpublic PrintWriter getLogWriter() throws SQLException {\n\t\treturn printer;\n\t}\n",
    "95698": "\tpublic void setLogWriter(PrintWriter out) throws SQLException {\n\t\tprinter = out;\n\t}\n",
    "95703": "\tpublic boolean acceptsURL(String url) throws SQLException {\n\t\treturn getRegisteredDriver().acceptsURL(url);\n\t}\n",
    "95705": "\tpublic int getMajorVersion() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().getMajorVersion());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "95706": "\tpublic int getMinorVersion() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().getMinorVersion());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "95707": "\tpublic boolean jdbcCompliant() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().jdbcCompliant());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "95714": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\t\txaConnection.checkHoldCursors(holdability);\n\t}\n",
    "95718": "\tpublic void checkAutoCommit(boolean autoCommit) throws SQLException {\n\t\tif (autoCommit && (currentXid != null))\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);\n\n\t\tsuper.checkAutoCommit(autoCommit);\n\t}\n",
    "95720": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\n\t\tif (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {\t\t\n\t\t\tif (currentXid != null)\n\t\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);\n\t\t}\n\n\t\tsuper.checkHoldCursors(holdability);\n\t}\n",
    "95723": "\tpublic void checkSavepoint() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);\n\n\t\tsuper.checkSavepoint();\n\t}\n",
    "95724": "\tpublic void checkRollback() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);\n\n\t\tsuper.checkRollback();\n\t}\n",
    "95725": "\tpublic void checkCommit() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);\n\n\t\tsuper.checkCommit();\n\t}\n",
    "95727": "\tpublic Statement wrapStatement(Statement s) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, s);\n\t\treturn sc.applicationStatement;\n\t}\n",
    "95728": "\tpublic PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);\n\t\treturn (PreparedStatement) sc.applicationStatement;\n\t}\n",
    "95730": "\tpublic CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, cs, sql);\n\t\treturn (CallableStatement) sc.applicationStatement;\n\t}\n",
    "95763": "\tpublic String getErrorProperty(String type) {\n\t\treturn getErrorProperty(getMessageId(), type);\n\t}\n",
    "95764": "\tpublic String toString() {\n\t\tString msg = getMessage();\n\n\t\treturn \"ERROR \" + getSQLState() + \": \" + msg;\n\t}\n",
    "95796": "\tpublic ByteArray getFileFormat() throws IOException {\n\n\t\tint classFileSize = 4 + (10 * 2);\n\t\tclassFileSize += cptEstimatedSize;\n\n\t\tif (interfaces != null)\n\t\t\tclassFileSize += (interfaces.length * 2);\n\n\t\tif (field_info != null)\n\t\t\tclassFileSize += field_info.classFileSize();\n\n\t\tif (method_info != null)\n\t\t\tclassFileSize += method_info.classFileSize();\n\n\t\tif (attribute_info != null)\n\t\t\tclassFileSize += attribute_info.classFileSize();\n\n\t\n\t\tClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);\n\n\t\tput(cfo);\n\n\t\treturn new ByteArray(cfo.getData(), 0, cfo.size());\n\n\t}\n",
    "95824": "\tprotected int addEntry(Object key, ConstantPoolEntry item) {\n\n\t\titem.setIndex(cptEntries.size());\n\t\tif (key != null)\n\t\t\tcptHashTable.put(key, item);\n\t\tcptEntries.addElement(item);\n\n\t\tcptEstimatedSize += item.classFileSize();\n\n\t\tif (item.doubleSlot()) {\n\t\t\tcptEntries.addElement(null);\n\t\t\treturn 2;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n",
    "95825": "\tprivate int addDirectEntry(ConstantPoolEntry item) {\n\t\tConstantPoolEntry existingItem = findMatchingEntry(item);\n\t\tif (existingItem != null) {\n\t\t\titem = existingItem;\n\t\t\t//foundCount++;\n\t\t}\n\t\telse {\n\t\t\taddEntry(item.getKey(), item);\n\t\t}\n\t\treturn item.getIndex();\n\t}\n",
    "95826": "\tprivate int addIndexReference(int tag, int i1, int i2) {\n\n\t\t// search for the item using the pre-allocated object \n\t\tsearchIndex.set(tag, i1, i2);\n\n\t\tConstantPoolEntry item = findMatchingEntry(searchIndex);\n\n\t\tif (item == null) {\n\t\t\titem = new CONSTANT_Index_info(tag, i1, i2);\n\t\t\taddEntry(item.getKey(), item);\n\t\t}\n\n\t\treturn item.getIndex();\n\t}\n",
    "95827": "\tpublic int addClassReference(String fullyQualifiedName) {\n\t\tif (ClassHolder.isExternalClassName(fullyQualifiedName)) {\n\t\t\tfullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);\n\t\t\t// System.out.println(\"addClassReference \" + fullyQualifiedName);\n\t\t}\n\n\t\tint name_index = addUtf8Entry(fullyQualifiedName).getIndex();\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);\n\t}\n",
    "95828": "\tprivate int addNameAndType(String name, String descriptor) {\n\t\tint nameIndex = addUtf8Entry(name).getIndex();\n\n\t\tint descriptorIndex = addUtf8Entry(descriptor).getIndex();\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);\n\t}\n",
    "95831": "\tprivate CONSTANT_Utf8_info addUtf8Entry(String value) {\n\n\t\tCONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);\n\n\t\tif (item == null) {\n\n\t\t\titem = new CONSTANT_Utf8_info(value);\n\t\t\taddEntry(value, item);\n\t\t}\n\t\treturn item;\n\t}\n",
    "95833": "\tprivate CONSTANT_Utf8_info addExtraUtf8(String value) {\n\n\t\tCONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);\n\t\taddEntry(null, item);\n\n\t\treturn item;\n\t}\n",
    "95834": "\tprivate int addString(String value) {\n\t\tCONSTANT_Utf8_info sutf = addUtf8Entry(value);\n\t\tint valueIndex = sutf.setAsString();\n\t\tif (valueIndex == 0) {\n\t\t\t// string is already being used as code\n\t\t\tvalueIndex = addExtraUtf8(value).getIndex();\n\t\t\tsutf.setAlternative(valueIndex);\n\t\t}\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);\n\t}\n",
    "95835": "\tprivate int addCodeUtf8(String value) {\n\t\tCONSTANT_Utf8_info sutf = addUtf8Entry(value);\n\t\tint index = sutf.setAsCode();\n\t\tif (index == 0) {\n\t\t\t// code string is already being used as string\n\t\t\tCONSTANT_Utf8_info eutf = addExtraUtf8(value);\n\t\t\teutf.setAsCode(); // ensure the replace will happen\n\t\t\tindex = eutf.getIndex();\n\t\t\tsutf.setAlternative(index);\n\t\t}\n\n\t\treturn index;\n\t}\n",
    "95838": "\tpublic int findClass(String fullyQualifiedName) {\n\t\tString internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);\n\t\tint utf_index = findUtf8(internalName);\n\t\tif (utf_index < 0)\n\t\t\treturn -1;\n\n\t\treturn findIndexIndex(VMDescriptor.CONSTANT_Class,\n\t\t\tutf_index, 0);\n\t}\n",
    "95839": "\tpublic int findNameAndType(String name, String descriptor) {\n\n\t\tint name_index = findUtf8(name);\n\t\tif (name_index < 0)\n\t\t\treturn -1;\n\t\tint descriptor_index = findUtf8(descriptor);\n\t\tif (descriptor_index < 0)\n\t\t\treturn -1;\n\n\t\treturn findIndexIndex(VMDescriptor.CONSTANT_NameAndType,\n\t\t\tname_index, descriptor_index);\n\t}\n",
    "95850": "\tstatic private String makeDesc (String className, int arity, boolean descriptor) {\n\n\t\tif (!descriptor && (arity == 0)) {\n\t\t\treturn className.replace('.','/');\n\t\t}\n\n\t\tStringBuffer desc = new StringBuffer(arity+2+className.length());\n\n\t\tfor (int i=0;i<arity;i++)\n\t\t\tdesc.append(VMDescriptor.C_ARRAY);\n\n\t\tdesc.append(VMDescriptor.C_CLASS);\n\n\t\tdesc.append(className.replace('.','/'));\n\n\t\tdesc.append(VMDescriptor.C_ENDCLASS);\n\n\t\treturn desc.toString();\n\t}\n",
    "95892": "\tprivate void checkInterrupt() {\n\t\tif (shutdown) {\n\t\t\t// system must have changed underneath us\n\t\t\tthrow new ShutdownException();\n\t\t}\n\t}\n",
    "95893": "\tpublic void setLocaleFinder(LocaleFinder finder) {\n\t\tthis.finder = finder;\n\t}\n",
    "95906": "\tpublic ContextManager getCurrentContextManager() {\n\n\t\tThread me = Thread.currentThread();\n\n\t\tObject list = threadContextList.get();\n\n\t\tif (list instanceof ContextManager) {\n\t\t\t\n\t\t\tContextManager cm = (ContextManager) list;\n\t\t\tif (cm.activeThread == me)\n\t\t\t\treturn cm;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (list == null)\n\t\t\treturn null;\n\n\t\tjava.util.Stack stack = (java.util.Stack) list;\n\t\treturn (ContextManager) (stack.peek());\n\n\n\t//\tif (list == null)\n\t//\t\treturn null;\n\n\t\t/*\t\tThread me = Thread.currentThread();\n\t\t\n\t\tsynchronized (this) {\n\t\t\tfor (Iterator i = allContexts.iterator(); i.hasNext(); ) {\n\n\t\t\t\tContextManager cm = (ContextManager) i.next();\n\t\t\t\tif (cm.activeThread == me)\n\t\t\t\t\treturn cm;\n\t\t\t}\n\t\t}\n\t\t//OLDreturn (ContextManager) get(me);\n\t\treturn null;\n*/\t}\n",
    "95924": "\tstatic public void DEBUG_PRINT(String flag, String message) {\n\t\tjava.io.PrintWriter debugStream = GET_DEBUG_STREAM();\n\n\t\tdebugStream.println(\"DEBUG \"+flag+\" OUTPUT: \" + message);\n\t\tdebugStream.flush();\n\t}\n",
    "95931": "\tpublic int getCount() {\n\t\treturn count;\n\t}\n",
    "95933": "\tpublic void setLimit(int limit) {\n\n\t\tcount = 0;\n\n\t\tthis.limit = limit;\n\n\t\treturn;\n\t}\n",
    "95935": "\tpublic  void write(int b) throws IOException {\n\t\t\n\t\tif ((limit >= 0) && ((count + 1) > limit)) {\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tout.write(b);\n\t\tcount++;\n\t}\n",
    "95937": "\tpublic void write(byte b[], int off, int len) throws IOException {\n\n\t\tif ((limit >= 0) && ((count + len) > limit)) {\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tout.write(b, off, len);\n\t\tcount += len;\n\t}\n",
    "95967": "\tpublic void setData(byte[] data) {\n\t\tpageData = data;\n\t\tclearLimit();\n\t}\n",
    "95977": "\tpublic int setLimit(int offset, int length) throws IOException {\n\n\t\tif ((offset < 0) || (length < 0)) {\n\t\t\tstart = end = position = 0;\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tstart = offset;\n\t\tend = offset + length;\n\n\t\tif (end > pageData.length) {\n\t\t\tstart = end = position = 0;\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tposition = start;\n\n\t\treturn length;\n\t}\n",
    "95982": "\tpublic  void write(int b)  {\n\t}\n",
    "95983": "\tpublic void write(byte b[]) {\n\t}\n",
    "95984": "\tpublic void write(byte b[], int off, int len)  {\n\t}\n",
    "96002": "\tpublic void discardLeft(int amountToShrinkBy) {\n\n\t\tSystem.arraycopy(buf, amountToShrinkBy, buf, 0,\n\t\t\tused - amountToShrinkBy);\n\n\t\tposition -= amountToShrinkBy;\n\t\tused -= amountToShrinkBy;\n\t}\n",
    "96022": "\tpublic void setLimit(int length) {\n\t\tremainingBytes = length;\n\t\tlimitInPlace = true;\n\t\treturn;\n\t}\n",
    "96023": "\tpublic int clearLimit() {\n\t\tint leftOver = remainingBytes;\n\t\tlimitInPlace = false;\n\t\tremainingBytes = -1;\n\t\treturn leftOver;\n\t}\n",
    "96038": "\tpublic void clearDefaults() {\n\t\tdefaults = null;\n\t}\n",
    "96055": "\tpublic int getLength() {\n\t\treturn lengthAsBits;\n\t}\n",
    "96104": "\tprivate boolean isLong(int fieldSize, int overflowThreshold) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (overflowThreshold == 0) \n\t\t\t\tSanityManager.THROWASSERT(\"overflowThreshold cannot be 0\");\n\t\t}\n\n\t\t// if a field size is over the threshold, then it becomes a long column\n\t\tint maxThresholdSize = maxFieldSize * overflowThreshold / 100;\n\t\treturn (fieldSize > maxThresholdSize);\n\t}\n",
    "96106": "\tprivate boolean isMethodMoreSpecificOrEqual(Member T, Member U, boolean[] isParam) {\n\n\t\tClass[] TC;\n\t\tClass[] UC;\n\n\t\tif (T instanceof Method) {\n\t\t\tif (!classConvertableFromTo(T.getDeclaringClass(), U.getDeclaringClass(), true))\n\t\t\t\treturn false;\n\n\t\t\tTC = ((Method) T).getParameterTypes();\n\t\t\tUC = ((Method) U).getParameterTypes();\n\t\t} else {\n\t\t\tTC = ((Constructor) T).getParameterTypes();\n\t\t\tUC = ((Constructor) U).getParameterTypes();\n\t\t}\n\n\t\treturn signatureConvertableFromTo(TC, null, UC, isParam, true);\n\t}\n",
    "96124": "\tpublic boolean isAlpha() {\n\t\treturn\t   (majorVersion >= 5)\n\t\t\t\t&& (minorVersion > 2)\n\t\t\t\t&& ((maintVersion / MAINT_ENCODING) == 0);\n\t}\n",
    "96127": "    public int getBuildNumberAsInt(){\n    \tif (buildNumber == null)\n    \t    return -1;\n    \tboolean dubiousCode = false;\n    \tint offset = buildNumber.indexOf('M');\n    \tif (offset == -1)\n    \t    offset = buildNumber.indexOf(':');\n    \telse\n    \t    dubiousCode = true;\n    \tif (offset == -1)\n    \t\toffset = buildNumber.length();\n        else\n            dubiousCode = true;\n    \t\n    \ttry {\n    \t\tint bnai = Integer.parseInt(buildNumber.substring(0, offset));\n    \t\tif (dubiousCode)\n    \t\t    bnai = -bnai;\n    \t\treturn bnai;\n    \t} catch (NumberFormatException nfe) \n     \t{\n     \t\treturn -1;\n    \t}\n    }\n",
    "96130": "\tpublic String getSimpleVersionString() {\n\n\t\treturn ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());\n\t}\n",
    "96156": "\tpublic boolean equals(Object other) {\n\t\tif (other instanceof ByteArray) {\n\t\t\tByteArray ob = (ByteArray) other;\n\t\t\treturn ByteArray.equals(array, offset, length, ob.array, ob.offset, ob.length);\n\t\t}\n\t\treturn false;\n\t}\n",
    "96216": "\tpublic boolean isAutoincAlways(){\n\t\treturn (columnDefaultInfo == null) && isAutoincrement();\n\t}\n",
    "96617": "\tpublic void syncState() throws SQLException {\n\t\tConnection conn = getRealConnection();\n\n\t\tstateIsolationLevel = conn.getTransactionIsolation();\n\t\tstateReadOnly = conn.isReadOnly();\n\t\tstateAutoCommit = conn.getAutoCommit();\n\t\t// jdk13 does not have Connection.getHoldability method and hence using\n\t\t// reflection to cover both jdk13 and higher jdks\n\t\ttry {\n\t\t\tMethod sh = conn.getClass().getMethod(\"getHoldability\", null);\n\t\t\tstateHoldability = ((Integer)sh.invoke(conn, null)).intValue();\n\t\t} catch( Exception e)\n\t\t{\n\t\t\tthrow PublicAPI.wrapStandardException( StandardException.plainWrapException( e));\n\t\t}       \n\t}\n",
    "96664": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_DATE_ID;\n\t}\n",
    "96713": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_LONGINT_ID;\n\t}\n",
    "96791": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_TIMESTAMP_ID;\n\t}\n",
    "96825": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_CHAR_ID;\n\t}\n",
    "96878": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_REF_ID;\n\t}  \n",
    "96913": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_BOOLEAN_ID;\n\t}\n",
    "96983": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_LONGVARCHAR_ID;\n\t}\n",
    "97030": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_INTEGER_ID;\n\t}\n",
    "97229": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_VARCHAR_ID;\n\t}\n",
    "97237": "\tpublic void setInto(ResultSet rs, int position) throws SQLException, StandardException {\n\t\trs.updateObject(position, getObject());\n\t}\n",
    "97249": "\tpublic int\t\t\t\t\ttypePrecedence() {\n\t\treturn -1;\n\t}\n",
    "97253": "        public int getTypeFormatId() {\n                return StoredFormatIds.SQL_NCLOB_ID;\n        }\n",
    "97371": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_REAL_ID;\n\t}\n",
    "97456": "\tpublic DataValueDescriptor getNull() {\n\t\treturn typeId.getNull();\n\t}\n",
    "97504": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_SMALLINT_ID;\n\t}\n",
    "97558": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_CHAR_ID;\n\t}\n",
    "97638": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_DOUBLE_ID;\n\t}\n",
    "97685": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_CLOB_ID;\n\t}\n",
    "97749": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_TIME_ID;\n\t}\n",
    "97807": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_VARCHAR_ID;\n\t}\n",
    "97821": "\tprotected int typeCompare(DataValueDescriptor arg) throws StandardException {\n\t\t\n\t\tBigIntegerDecimal obid = getBID(arg);\n\t\t\n\t\t// need to align scales to perform comparisions\n\t\tint tscale = getDecimalValueScale();\n\t\tint oscale = obid.getDecimalValueScale();\n\t\n\t\tBigInteger tbi = new BigInteger(data2c);\n\t\tBigInteger obi = new BigInteger(obid.data2c);\n\t\t\n\t\tif (tscale < oscale)\n\t\t\ttbi = BigIntegerDecimal.rescale(tbi, oscale - tscale);\n\t\telse if (oscale < tscale)\n\t\t\tobi = BigIntegerDecimal.rescale(obi, tscale - oscale);\n\t\n\t\treturn tbi.compareTo(obi);\n\t}\n",
    "97824": "\tpublic NumberDataValue minus(NumberDataValue result) throws StandardException {\n\t\t\n\t\tif (result == null)\n\t\t\tresult = (NumberDataValue) getNewNull();\n\n\t\tif (isNull())\n\t\t\tresult.setToNull();\n\t\telse\n\t\t{\n\t\t\tBinaryDecimal rbd = (BinaryDecimal) result;\n\t\t\t\n\t\t\tBigInteger bi = new BigInteger(data2c);\n\t\t\t// scale remains unchanged.\n\t\t\trbd.data2c = bi.negate().toByteArray();\n\t\t\trbd.sqlScale = sqlScale;\n\t\t\n\t\t}\n\t\t\t\n\t\treturn result;\n\t}\n",
    "97838": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_LONGVARCHAR_ID;\n\t}\n",
    "97873": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_USERTYPE_ID_V3;\n\t}\n",
    "97957": "\tpublic long getContainerId() {\n\t\treturn containerId;\n\t}\n",
    "97982": "        public boolean  streamStorable() {\n                return isStringTypeId() || isBitTypeId();\n        }\n",
    "97991": "\tpublic void checkLogicalOperationOk() throws StandardException {\n\t}\n",
    "97992": "\tpublic boolean recoveryRollbackFirst() {\n\t\treturn false;\n\t}\n",
    "97994": "\tpublic void setObserverException(StandardException se) {\n\t\tif (observerException == null)\n\t\t\tobserverException = se;\n\t}\n",
    "97995": "\tpublic void notifyObservers(Object arg) {\n\t\tif (countObservers() != 0) {\n\t\t\tsetChanged();\n\t\t\tsuper.notifyObservers(arg);\n\t\t}\n\t}\n",
    "98034": "    public boolean inField() {\n        return false;\n    }\n",
    "98036": "    public boolean inConstructor() {\n        return false;\n    }\n",
    "98037": "    public boolean inMethod() {\n        return false;\n    }\n",
    "98038": "    public boolean inOverview() {\n        return true;\n    }\n",
    "98039": "    public boolean inPackage() {\n        return true;\n    }\n",
    "98040": "    public boolean inType() {\n        return true;\n    }\n",
    "98041": "    public boolean isInlineTag() {\n        return false;\n    }\n",
    "98042": "    public String toString(Tag tag) {\n        return \"\\n<dt><table cellpadding=2 cellspacing=2><tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr>\\n\";\n    }\n",
    "98043": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<table cellpadding=2 cellspacing=2><tr><td>\" + ROWNAME + \"</td><td>\" ;\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"\\n\";\n    }\n",
    "98053": "    public String toString(Tag tag) {\n        return \"<tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr>\\n\";\n    }\n",
    "98054": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<tr><td>\" + ROWNAME + \"</td><td>\";\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"\\n\";\n    }\n",
    "98086": "    public String toString(Tag tag) {\n        return \"<tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr></table>\\n\";\n    }\n",
    "98088": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<tr><td>\" + ROWNAME + \"</td><td>\" ;\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"</table></dt>\\n\";\n    }\n",
    "98104": "\tprivate void doTrace(Throwable t) {\n\t\tif (util.getSystemProperty(\"ij.exceptionTrace\") != null) {\n\t\t\tt.printStackTrace(out);\n\t\t}\n\t\tout.flush();\n\t}\n",
    "98193": "\tpublic void ReInit(Reader s) { \n\t    try {\n\t\t\tsource.close();\n\t\t} catch (IOException ioe) {\n\t\t\t// just be quiet if it is already gone\n\t\t}\n\t\tsource = s;\n\t\tstate = IN_STATEMENT;\n\t\tatEOF = false;\n\t\tpeekEOF = false;\n\t\tpeeked = false;\n\t}\n",
    "98202": "\tprivate boolean whiteSpace(char c) {\n\t\treturn (c == SPACE ||\n\t\t    \tc == TAB ||\n\t\t    \tc == RETURN ||\n\t\t    \tc == NEWLINE ||\n\t\t    \tc == FORMFEED);\n\t}\n",
    "98208": "\tprivate void readString(char stringDelimiter) {\n\t\tstate = IN_STRING;\n\t\tdo {\n\t\t\tchar nextChar = readChar();\n\n\t\t\tif (atEOF()) {\n\t\t\t\tstate = END_OF_INPUT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nextChar == stringDelimiter) {\n\t\t\t\t// we've reached the end of the string\n\t\t\t\tstate = IN_STATEMENT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// still in string\n\t\t} while (state == IN_STRING); // could be while true...\n\t}\n",
    "98217": "\tprivate char readChar() {\n\t\tif (!peeked) peekChar();\n\n\t\tpeeked = false;\n\t\tatEOF = peekEOF;\n\n\t\tif (!atEOF) statement.append(peekChar);\n\n\t\treturn peekChar;\n\t}\n",
    "98218": "\tprivate char peekChar() {\n\t\tpeeked = true;\n\t\tchar c = '\\00';\n\n\t\ttry {\n\t\t    int cInt;\n\n\t\t\t// REMIND: this is assuming a flat ascii source file.\n\t\t\t// will need to beef it up at some future point to\n\t\t\t// understand whether the stream is ascii or something else.\n\t\t\tcInt = source.read();\n\t\t\tpeekEOF = (cInt == -1);\n\t\t\tif (!peekEOF) c = (char)cInt;\n\t\t} catch (IOException ie) {\n\t\t\tthrow ijException.iOException(ie);\n\t\t}\n\n\t\tpeekChar = c;\n\t\treturn c;\n\t}\n",
    "98352": "\tstatic public boolean getPropertyArg(String[] args) throws IOException {\n\t\tString n;\n\t\tInputStream in1;\n\t\tProperties p;\n\n\t\tif ((n = getArg(\"-p\", args))!= null){\n\t\t\tin1 = new FileInputStream(n);\n\t\t\tin1 = new BufferedInputStream(in1);\n\t\t}\n\t\telse if ((n = getArg(\"-pr\", args)) != null) {\n\t\t\tin1 = getResourceAsStream(n);\n\t\t\tif (in1 == null) throw ijException.resourceNotFound();\n\t\t}\n\t\telse\n\t\t\treturn false;\n\n\t\tp = System.getProperties();\n\n\t\t// Trim off excess whitespace in property file, if any, and\n\t\t// then load those properties into 'p'.\n\t\tutil.loadWithTrimmedValues(in1, p);\n\n\t\treturn true;\n\t}\n",
    "98357": "\tstatic public String getFileArg(String[] args) throws IOException {\n\t\tString fileName;\n\t\tint fLocn;\n\t\tboolean foundP = false;\n\n\t\tif (args == null) return null;\n\t\tif ((fileName=getArg(\"-f\",args))!=null) return fileName;\n\t\t//\n\t\t//The first unknown arg is the file\n\t\tfor (int ix=0; ix < args.length; ix++)\n\t\t\tif(args[ix].equals(\"-f\")  ||\n\t\t\t   args[ix].equals(\"-fr\") ||\n\t\t\t   args[ix].equals(\"-ca\")  ||\n\t\t\t   args[ix].equals(\"-car\")  ||\n\t\t\t   args[ix].equals(\"-p\")  ||\n\t\t\t   args[ix].equals(\"-pr\"))\n\t\t\t\tix++; //skip the parameter to these args\n\t\t\telse\n\t\t\t\treturn args[ix];\n\t\treturn null;\n\t}\n",
    "98359": " \tstatic public String getInputResourceNameArg(String[] args) {\n\t\treturn getArg(\"-fr\", args);\n\t}\n",
    "98363": "    static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n\t\treturn startJBMS(null,null);\n\t}\n",
    "98410": "  final public ijResult ProtocolStatement() throws ParseException, SQLException {\n        Token t;\n        String n = null;\n    jj_consume_token(PROTOCOL);\n    t = jj_consume_token(STRING);\n    if (jj_2_56(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                installProtocol(n, stringValue(t.image));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98431": "\tstatic public boolean init() {\n\t\treturn (LocalizedResource.getInstance() != null);\n\t}\n",
    "98433": "\tstatic public void ShowException(PrintWriter out, Throwable e) {\n\t\tif (e == null) return;\n\n\t\tif (e instanceof SQLException)\n\t\t\tShowSQLException(out, (SQLException)e);\n\t\telse\n\t\t\te.printStackTrace(out);\n\t}\n",
    "98434": "\tstatic public void ShowSQLException(PrintWriter out, SQLException e) {\n\t\tString errorCode;\n\n\t\tif (Boolean.getBoolean(\"ij.showErrorCode\")) {\n\t\t\terrorCode = LocalizedResource.getMessage(\"UT_Error0\", LocalizedResource.getNumber(e.getErrorCode()));\n\t\t}\n\t\telse {\n\t\t\terrorCode = \"\";\n\t\t}\n\n\t\twhile (e!=null) {\n\t\t\tString p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage(\"UT_NoSqlst\"));\n\t\t\tString p2 = mapNull(e.getMessage(),LocalizedResource.getMessage(\"UT_NoMessa\"));\n\t\t\tout.println(LocalizedResource.getMessage(\"UT_Error012\", p1, p2,errorCode));\n\t\t\tdoTrace(out, e);\n\t\t\te=e.getNextException();\n\t\t}\n\t}\n",
    "98435": "\tstatic public void ShowWarnings(PrintWriter out, Connection theConnection) {\n\t    try {\n\t\t// GET CONNECTION WARNINGS\n\t\tSQLWarning warning = null;\n\n\t\tif (theConnection != null) {\n\t\t\tShowWarnings(out, theConnection.getWarnings());\n\t\t}\n\n\t\tif (theConnection != null) {\n\t\t\ttheConnection.clearWarnings();\n\t\t}\n\t    } catch (SQLException e) {\n\t\t\tShowSQLException(out, e);\n\t    }\n\t} // ShowWarnings\n",
    "98437": "\tstatic public void ShowWarnings(PrintWriter out, ResultSet rs) {\n\t    try {\n\t\t// GET RESULTSET WARNINGS\n\t\tSQLWarning warning = null;\n\n\t\tif (rs != null) {\n\t\t\tShowWarnings(out, rs.getWarnings());\n\t\t}\n\n\t\tif (rs != null) {\n\t\t\trs.clearWarnings();\n\t\t}\n\t    } catch (SQLException e) {\n\t\t\tShowSQLException(out, e);\n\t    }\n\t} // ShowResultSetWarnings\n",
    "98454": "  final public ijResult SetConnectionStatement() throws ParseException, SQLException {\n        String t;\n    jj_consume_token(SET);\n    jj_consume_token(CONNECTION);\n    t = identifier();\n                if (!currentConnEnv.haveSession(t)) {\n                        {if (true) throw ijException.noSuchConnection(t);}\n                }\n                currentConnEnv.setCurrentSession(t);\n                theConnection = currentConnEnv.getConnection();\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98459": "  final public ijResult ShowConnectionsStatement() throws ParseException, SQLException {\n    jj_consume_token(SHOW);\n    jj_consume_token(CONNECTIONS);\n                {if (true) return showConnectionsMethod(false);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98460": "\tstatic public String mapNull(String s, String nullValue) {\n\t\tif (s==null) return nullValue;\n\t\treturn s;\n\t}\n",
    "98463": "\tstatic public void doTrace(PrintWriter out, Exception e) {\n\t\tif (Boolean.getBoolean(\"ij.exceptionTrace\")) {\n\t\t\te.printStackTrace(out);\n\t\t    out.flush();\n\t\t}\n\t}\n",
    "98466": "  final public ijResult CommitStatement() throws ParseException, SQLException {\n    jj_consume_token(COMMIT);\n    if (jj_2_67(2)) {\n      jj_consume_token(WORK);\n    } else {\n      ;\n    }\n                haveConnection();\n                theConnection.commit();\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98474": "  final public ijResult RollbackStatement() throws ParseException, SQLException {\n    jj_consume_token(ROLLBACK);\n    if (jj_2_68(2)) {\n      jj_consume_token(WORK);\n    } else {\n      ;\n    }\n                haveConnection();\n                theConnection.rollback();\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98587": "    public void shutdown() {\n\ttry{\n\t    for(int i=0;i<sockets.size();i++) {\n\t\t(datain.get(i)).close();\n\t\t(dataout.get(i)).close();\n\t\t(sockets.get(i)).close();\n\t\tSystem.out.println(\"Socket closed\");\n\t    } // end for\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem shutting down\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end shutdown\n",
    "98588": "    public boolean addServer(String IP) {\n\ttry {\n\t    sockets.add(new Socket(IP,port));\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Unable to connect to \"+IP+\":\"+port);\n\t    System.out.println(e);\n\t    return false;\n\t}// end catch\n\treturn true;\n    } // end addServer(String)\n",
    "98589": "    public void addDataStreams(int index) {\n\ttry {\n\t    dataout.add(new DataOutputStream((sockets.get(index)).getOutputStream()));\n\t    datain.add(new DataInputStream((sockets.get(index)).getInputStream()));\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem creating data streams\");\n\t    System.out.println(\"**** ADD CODE TO PROPERLY CLOSE STUFF HERE ****\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end addDataStreams(int)\n",
    "98592": "    public void badCommand(String rcv, String exp) {\n\tSystem.out.println(\"Received \\\"\" + rcv + \"\\\"\");\n\tSystem.out.println(\"Expected \\\"\" + exp + \"\\\"\");\n    } // end badCommand(String,String)\n",
    "98593": "    public int checkOS() {\n\tif(System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")) {\n\t    return 0;\n\t} // end if linux\n\tif(System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n\t    return 1;\n\t}\n\treturn 2;\n    } // end checkOS()\n",
    "98596": "    public boolean lookForConnection() {\n\t/* Wait for client to connect */\n\tCSocket = null;\n\ttry {\n\t    CSocket = SSocket.accept();\n\t    System.out.println(\"CONNECTION ACCEPTED\");\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Unable to accept connection\");\n\t    System.out.println(e);\n\t    return false;\n\t} // end catch\n\n\t/* Add the data streams */\n\ttry {\n\t    din = new DataInputStream(CSocket.getInputStream());\n\t    dout = new DataOutputStream(CSocket.getOutputStream());\n\t    return true;\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem with Data Streams\");\n\t    System.out.println(e);\n\t    return false;\n\t} // end catch\n    } // end lookForConnection()\n",
    "98598": "    public void closeConnection() {\n\ttry {\n\t    din.close();\n\t    dout.close();\n\t    CSocket.close();\n\t    System.out.println(\"CSocket Closed\");\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem closing connection\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end shutdown\n",
    "98599": "    public PointType getPoint() {\n        return point;\n    }\n",
    "98600": "    public void setPoint(PointType value) {\n        this.point = value;\n    }\n",
    "98611": "    public Pos getPos() {\n        return pos;\n    }\n",
    "98612": "    public void setPos(Pos value) {\n        this.pos = value;\n    }\n",
    "98626": "    public void setPointMembers(List<PointMember> pointMembers) {\n        this.pointMembers = pointMembers;\n    }\n",
    "98639": "    public String getSrsName() {\n        return srsName;\n    }\n",
    "98640": "    public void setSrsName(String value) {\n        this.srsName = value;\n    }\n",
    "98650": "    public void set_Geometry(JAXBElement<? extends AbstractGeometryType> value) {\n        this.geometry = ((JAXBElement<? extends AbstractGeometryType> ) value);\n    }\n",
    "98662": "    public MultiCurveType getMultiCurve() {\n        return multiCurve;\n    }\n",
    "98663": "    public void setMultiCurve(MultiCurveType value) {\n        this.multiCurve = value;\n    }\n",
    "98675": "    public AbstractRingPropertyType getExterior() {\n        return exterior;\n    }\n",
    "98677": "    public void setExterior(AbstractRingPropertyType value) {\n        this.exterior = value;\n    }\n",
    "98681": "    public SurfaceInterpolationType getInterpolation() {\n        if (interpolation == null) {\n            return SurfaceInterpolationType.PLANAR;\n        } else {\n            return interpolation;\n        }\n    }\n",
    "98682": "    public void setInterpolation(SurfaceInterpolationType value) {\n        this.interpolation = value;\n    }\n",
    "98684": "    public void setInteriors(List<AbstractRingPropertyType> interiors) {\n        this.interiors = interiors;\n    }\n",
    "98698": "    public String getValue() {\n        return value;\n    }\n",
    "98699": "    public void setValue(String value) {\n        this.value = value;\n    }\n",
    "98701": "    public String getCodeSpace() {\n        return codeSpace;\n    }\n",
    "98702": "    public void setCodeSpace(String value) {\n        this.codeSpace = value;\n    }\n",
    "98732": "    public BoundedBy createBoundedBy() {\n        return new BoundedBy();\n    }\n",
    "98733": "    public LineStringSegmentType createLineStringSegmentType() {\n        return new LineStringSegmentType();\n    }\n",
    "98734": "    public MultiPointType createMultiPointType() {\n        return new MultiPointType();\n    }\n",
    "98735": "    public Segments createSegments() {\n        return new Segments();\n    }\n",
    "98737": "    public MultiSurfacePropertyType createMultiSurfacePropertyType() {\n        return new MultiSurfacePropertyType();\n    }\n",
    "98738": "    public PolygonPatchType createPolygonPatchType() {\n        return new PolygonPatchType();\n    }\n",
    "98739": "    public GeometryPropertyType createGeometryPropertyType() {\n        return new GeometryPropertyType();\n    }\n",
    "98740": "    public MeasureType createMeasureType() {\n        return new MeasureType();\n    }\n",
    "98741": "    public PointType createPointType() {\n        return new PointType();\n    }\n",
    "98742": "    public PolygonType createPolygonType() {\n        return new PolygonType();\n    }\n",
    "98743": "    public CurveType createCurveType() {\n        return new CurveType();\n    }\n",
    "98745": "    public PosList createPosList() {\n        return new PosList();\n    }\n",
    "98747": "    public AbstractRingPropertyType createAbstractRingPropertyType() {\n        return new AbstractRingPropertyType();\n    }\n",
    "98748": "    public PointMember createPointMember() {\n        return new PointMember();\n    }\n",
    "98750": "    public LineStringType createLineStringType() {\n        return new LineStringType();\n    }\n",
    "98751": "    public MultiCurvePropertyType createMultiCurvePropertyType() {\n        return new MultiCurvePropertyType();\n    }\n",
    "98752": "    public MultiSurfaceType createMultiSurfaceType() {\n        return new MultiSurfaceType();\n    }\n",
    "98753": "    public ReferenceType createReferenceType() {\n        return new ReferenceType();\n    }\n",
    "98754": "    public Patches createPatches() {\n        return new Patches();\n    }\n",
    "98755": "    public MultiPointPropertyType createMultiPointPropertyType() {\n        return new MultiPointPropertyType();\n    }\n",
    "98756": "    public MultiGeometryPropertyType createMultiGeometryPropertyType() {\n        return new MultiGeometryPropertyType();\n    }\n",
    "98757": "    public MultiCurveType createMultiCurveType() {\n        return new MultiCurveType();\n    }\n",
    "98759": "    public Pos createPos() {\n        return new Pos();\n    }\n",
    "98761": "    public SurfaceMember createSurfaceMember() {\n        return new SurfaceMember();\n    }\n",
    "98762": "    public SurfaceType createSurfaceType() {\n        return new SurfaceType();\n    }\n",
    "98765": "    public LinearRingType createLinearRingType() {\n        return new LinearRingType();\n    }\n",
    "98766": "    public AbstractFeatureBaseType createAbstractFeatureBaseType() {\n        return new AbstractFeatureBaseType();\n    }\n",
    "98767": "    public AbstractSurfaceType createAbstractSurfaceType() {\n        return new AbstractSurfaceType();\n    }\n",
    "98768": "    public Envelope createEnvelope() {\n        return new Envelope();\n    }\n",
    "98769": "    public Name createName() {\n        return new Name();\n    }\n",
    "98770": "    public CurveMember createCurveMember() {\n        return new CurveMember();\n    }\n",
    "98776": "  final public ijResult JBMSPreparedStatementExec() throws ParseException, SQLException {\n        Token s = null;\n    jj_consume_token(EXECUTE);\n    jj_consume_token(STATEMENT);\n    s = jj_consume_token(STRING);\n                {if (true) return executeImmediate(stringValue(s.image));}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98780": "    public String getType() {\n        if (type == null) {\n            return \"simple\";\n        } else {\n            return type;\n        }\n    }\n",
    "98781": "    public void setType(String value) {\n        this.type = value;\n    }\n",
    "98783": "    public String getHref() {\n        return href;\n    }\n",
    "98784": "    public void setHref(String value) {\n        this.href = value;\n    }\n",
    "98787": "    public String getRole() {\n        return role;\n    }\n",
    "98788": "    public void setRole(String value) {\n        this.role = value;\n    }\n",
    "98791": "    public String getArcrole() {\n        return arcrole;\n    }\n",
    "98792": "    public void setArcrole(String value) {\n        this.arcrole = value;\n    }\n",
    "98795": "    public void setTitle(String value) {\n        this.title = value;\n    }\n",
    "98796": "  final public ijResult F2KExecuteProcedure() throws ParseException, SQLException {\n        Token s = null;\n    jj_consume_token(EXECUTE);\n    jj_consume_token(PROCEDURE);\n    s = jj_consume_token(STRING);\n                haveConnection();\n\n                Statement       aStatement = theConnection.createStatement();\n                String          text = \"execute procedure \" + s;\n\n                aStatement.execute( text );\n\n                {if (true) return new ijStatementResult( aStatement,true );}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98798": "    public String getShow() {\n        return show;\n    }\n",
    "98799": "    public void setShow(String value) {\n        this.show = value;\n    }\n",
    "98801": "    public String getActuate() {\n        return actuate;\n    }\n",
    "98802": "    public void setActuate(String value) {\n        this.actuate = value;\n    }\n",
    "98816": "    public MultiSurfaceType getMultiSurface() {\n        return multiSurface;\n    }\n",
    "98817": "    public void setMultiSurface(MultiSurfaceType value) {\n        this.multiSurface = value;\n    }\n",
    "98842": "    public void setDescription(String value) {\n        this.description = value;\n    }\n",
    "98844": "  final public ijResult AsyncStatement() throws ParseException, SQLException {\n        Token s = null;\n        String n = null;\n    jj_consume_token(ASYNC);\n    n = identifier();\n    s = jj_consume_token(STRING);\n            {if (true) return executeAsync(stringValue(s.image), n);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98847": "    public String getId() {\n        return id;\n    }\n",
    "98848": "    public void setId(String value) {\n        this.id = value;\n    }\n",
    "98861": "    public void set_GeometricAggregate(JAXBElement<? extends AbstractGeometricAggregateType> value) {\n        this.geometricAggregate = ((JAXBElement<? extends AbstractGeometricAggregateType> ) value);\n    }\n",
    "98869": "  final public ijResult WaitForStatement() throws ParseException, SQLException {\n        Token s = null;\n        String n = null;\n    jj_consume_token(WAIT);\n    jj_consume_token(FOR);\n    n = identifier();\n                AsyncStatement as = currentConnEnv.getSession().getAsyncStatement(n);\n                if (as == null) {if (true) throw ijException.noSuchAsyncStatement(n);}\n                try {\n                    as.join(); // we wait for it to finish.\n                } catch (InterruptedException ie) {\n                        {if (true) throw ijException.waitInterrupted(ie);}\n                }\n                {if (true) return as.getResult();}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98893": "    public MultiPointType getMultiPoint() {\n        return multiPoint;\n    }\n",
    "98894": "  final public ijResult RemoveStatement() throws ParseException, SQLException {\n        String i;\n        PreparedStatement ps;\n    jj_consume_token(REMOVE);\n    i = identifier();\n                haveConnection();\n                Session s = currentConnEnv.getSession();\n                ps = (PreparedStatement) s.getPreparedStatement(i);\n                JDBCDisplayUtil.checkNotNull(ps,\"prepared statement \"+i);\n                ps.close();\n                s.removePreparedStatement(i);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98895": "    public void setMultiPoint(MultiPointType value) {\n        this.multiPoint = value;\n    }\n",
    "98907": "    public void setSegments(Segments value) {\n        this.segments = value;\n    }\n",
    "98937": "    public void set_Surface(JAXBElement<? extends AbstractSurfaceType> value) {\n        this.surface = ((JAXBElement<? extends AbstractSurfaceType> ) value);\n    }\n",
    "98949": "    public Envelope getEnvelope() {\n        return envelope;\n    }\n",
    "98950": "    public void setEnvelope(Envelope value) {\n        this.envelope = value;\n    }\n",
    "98964": "    public void set_SurfacePatches(List<JAXBElement<? extends AbstractSurfacePatchType>> surfacePatches) {\n        this.surfacePatches = surfacePatches;\n    }\n",
    "98970": "  final public ijResult AutocommitStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(AUTOCOMMIT);\n    if (jj_2_87(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_88(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                haveConnection();\n                // REMIND: want to warn if unchanged?\n                theConnection.setAutoCommit((on==null?false:true));\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98975": "    public BoundedBy getBoundedBy() {\n        return boundedBy;\n    }\n",
    "98976": "    public void setBoundedBy(BoundedBy value) {\n        this.boundedBy = value;\n    }\n",
    "98988": "    public void setPatches(Patches value) {\n        this.patches = value;\n    }\n",
    "99000": "    public void set_Curve(JAXBElement<? extends AbstractCurveType> value) {\n        this.curve = ((JAXBElement<? extends AbstractCurveType> ) value);\n    }\n",
    "99004": "  final public ijResult NoHoldForConnectionStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(NOHOLDFORCONNECTION);\n                haveConnection();\n                theConnection = utilInstance.setHoldability(theConnection, JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99013": "    public PosList getPosList() {\n        return posList;\n    }\n",
    "99014": "    public void setPosList(PosList value) {\n        this.posList = value;\n    }\n",
    "99016": "    public CurveInterpolationType getInterpolation() {\n        if (interpolation == null) {\n            return CurveInterpolationType.LINEAR;\n        } else {\n            return interpolation;\n        }\n    }\n",
    "99017": "    public void setInterpolation(CurveInterpolationType value) {\n        this.interpolation = value;\n    }\n",
    "99037": "  final public ijResult LocalizedDisplay() throws ParseException {\n        Token on=null;\n    jj_consume_token(LOCALIZEDDISPLAY);\n    if (jj_2_89(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_90(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                LocalizedResource.enableLocalization((on==null?false:true));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99057": "    public void setSurfaceMembers(List<SurfaceMember> surfaceMembers) {\n        this.surfaceMembers = surfaceMembers;\n    }\n",
    "99067": "  final public ijResult ReadOnlyStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(READONLY);\n    if (jj_2_91(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_92(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                haveConnection();\n                theConnection.setReadOnly((on==null?false:true));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99085": "    public void setCurveMembers(List<CurveMember> curveMembers) {\n        this.curveMembers = curveMembers;\n    }\n",
    "99095": "    public double getValue() {\n        return value;\n    }\n",
    "99096": "    public void setValue(double value) {\n        this.value = value;\n    }\n",
    "99098": "    public String getUom() {\n        return uom;\n    }\n",
    "99099": "    public void setUom(String value) {\n        this.uom = value;\n    }\n",
    "99101": "  final public ijResult ElapsedTimeStatement() throws ParseException {\n        Token on=null;\n    jj_consume_token(ELAPSEDTIME);\n    if (jj_2_93(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_94(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                elapsedTime = (on != null);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99137": "    public Pos getLowerCorner() {\n        return lowerCorner;\n    }\n",
    "99138": "    public void setLowerCorner(Pos value) {\n        this.lowerCorner = value;\n    }\n",
    "99139": "  final public ijResult MaximumDisplayWidthStatement() throws ParseException {\n        int       maxWidth;\n    jj_consume_token(MAXIMUMDISPLAYWIDTH);\n    maxWidth = intValue();\n                JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99141": "    public Pos getUpperCorner() {\n        return upperCorner;\n    }\n",
    "99142": "    public void setUpperCorner(Pos value) {\n        this.upperCorner = value;\n    }\n",
    "99156": "    public LinearRingType getLinearRing() {\n        return linearRing;\n    }\n",
    "99157": "    public void setLinearRing(LinearRingType value) {\n        this.linearRing = value;\n    }\n",
    "99172": "    public void set_CurveSegments(List<JAXBElement<? extends AbstractCurveSegmentType>> curveSegments) {\n        this.curveSegments = curveSegments;\n    }\n",
    "99190": "\tpublic void applyRemark(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\n\t\t// first, remove any remarks\n\t\tremoveRemarkFromValue(remark, value);\n\t\t\n\t\t// add the remark\n\t\tvalue.getRemarks().add(remark);\n\t}\n",
    "99191": "\tpublic boolean isRemarkSet(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\t\t\n\t\tfor(TridasRemark aRemark : value.getRemarks()) {\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark)) {\n\t\t\t\t// must test for special 'disabled override'\n\t\t\t\tif(aRemark.isSetInheritedCount() && aRemark.getInheritedCount() < 0)\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n",
    "99192": "\tpublic boolean isRemarkInherited(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\t\t\n\t\tfor(TridasRemark aRemark : value.getRemarks()) {\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark)) {\n\t\t\t\t// get the inherited count from the remark associated with the value\n\t\t\t\treturn (aRemark.isSetInheritedCount() && aRemark.getInheritedCount() > 0) ? true : false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n",
    "99193": "\tpublic void overrideRemark(TridasValue value) {\n\t\tTridasRemark source = asTridasRemark();\n\t\t\n\t\t// create a copy of the remark, as we're going to be modifying it\n\t\tTridasRemark remark = (TridasRemark) source.createCopy();\n\t\tsource.copyTo(remark);\n\n\t\t// first, remove any remarks\n\t\tremoveRemarkFromValue(remark, value);\n\t\t\n\t\t// flag the new remark as disabled\n\t\tremark.setInheritedCount(-1);\n\t\t\n\t\t// add the remark\n\t\tvalue.getRemarks().add(remark);\n\t}\n",
    "99194": "\tpublic void removeRemark(TridasValue value) {\n\t\tremoveRemarkFromValue(asTridasRemark(), value);\n\t}\n",
    "99195": "\tprotected void removeRemarkFromValue(TridasRemark remark, TridasValue value) {\n\t\tListIterator<TridasRemark> remarkIterator = value.getRemarks().listIterator();\n\t\t\n\t\twhile(remarkIterator.hasNext()) {\n\t\t\tTridasRemark aRemark = remarkIterator.next();\n\t\t\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark))\n\t\t\t\tremarkIterator.remove();\n\t\t}\n\t}\n",
    "99207": "    public void setName(String value) {\n        this.name = value;\n    }\n",
    "99213": "    public boolean isIsActive() {\n        return isActive;\n    }\n",
    "99214": "    public void setIsActive(boolean value) {\n        this.isActive = value;\n    }\n",
    "99230": "    public void setMeasurementVariables(List<ControlledVoc> measurementVariables) {\n        this.measurementVariables = measurementVariables;\n    }\n",
    "99242": "    public void setElementShapes(List<ControlledVoc> elementShapes) {\n        this.elementShapes = elementShapes;\n    }\n",
    "99254": "    public String getType() {\n        return type;\n    }\n",
    "99259": "    public String getObject() {\n        return object;\n    }\n",
    "99260": "    public void setObject(String value) {\n        this.object = value;\n    }\n",
    "99281": "    public void setDatingTypes(List<ControlledVoc> datingTypes) {\n        this.datingTypes = datingTypes;\n    }\n",
    "99295": "    public void setCoverageTemporals(List<ControlledVoc> coverageTemporals) {\n        this.coverageTemporals = coverageTemporals;\n    }\n",
    "99306": "    public WSISapwoodDictionary createWSISapwoodDictionary() {\n        return new WSISapwoodDictionary();\n    }\n",
    "99307": "    public WSIParam createWSIParam() {\n        return new WSIParam();\n    }\n",
    "99308": "    public WSIBox createWSIBox() {\n        return new WSIBox();\n    }\n",
    "99310": "    public WSIRequest createWSIRequest() {\n        return new WSIRequest();\n    }\n",
    "99311": "    public WSISearchParams createWSISearchParams() {\n        return new WSISearchParams();\n    }\n",
    "99312": "    public WSIRegionDictionary createWSIRegionDictionary() {\n        return new WSIRegionDictionary();\n    }\n",
    "99313": "    public WSISecurityUserDictionary createWSISecurityUserDictionary() {\n        return new WSISecurityUserDictionary();\n    }\n",
    "99314": "  final public ijResult HelpStatement() throws ParseException {\n    jj_consume_token(HELP);\n                Vector v = new Vector();\n\n                StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage(\"IJ_HelpText\"), \"\\n\");\n                while (st.hasMoreTokens()) {\n                    v.addElement(st.nextToken());\n                }\n\n                {if (true) return new ijVectorResult(v,null);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99315": "    public WSIHeartwoodDictionary createWSIHeartwoodDictionary() {\n        return new WSIHeartwoodDictionary();\n    }\n",
    "99316": "    public WSIRootElement createWSIRootElement() {\n        return new WSIRootElement();\n    }\n",
    "99317": "    public WSINonce createWSINonce() {\n        return new WSINonce();\n    }\n",
    "99318": "    public WSIMessage createWSIMessage() {\n        return new WSIMessage();\n    }\n",
    "99319": "    public WSIBoxDictionary createWSIBoxDictionary() {\n        return new WSIBoxDictionary();\n    }\n",
    "99320": "    public WSIElementAuthenticityDictionary createWSIElementAuthenticityDictionary() {\n        return new WSIElementAuthenticityDictionary();\n    }\n",
    "99321": "    public WSIEntity createWSIEntity() {\n        return new WSIEntity();\n    }\n",
    "99322": "    public WSIHelp createWSIHelp() {\n        return new WSIHelp();\n    }\n",
    "99323": "    public WSIHeader createWSIHeader() {\n        return new WSIHeader();\n    }\n",
    "99324": "    public WSILocationTypeDictionary createWSILocationTypeDictionary() {\n        return new WSILocationTypeDictionary();\n    }\n",
    "99325": "    public WSIAuthenticate createWSIAuthenticate() {\n        return new WSIAuthenticate();\n    }\n",
    "99326": "    public WSIElementTypeDictionary createWSIElementTypeDictionary() {\n        return new WSIElementTypeDictionary();\n    }\n",
    "99327": "    public WSILink createWSILink() {\n        return new WSILink();\n    }\n",
    "99328": "    public WSISampleTypeDictionary createWSISampleTypeDictionary() {\n        return new WSISampleTypeDictionary();\n    }\n",
    "99329": "    public WSIElementShapeDictionary createWSIElementShapeDictionary() {\n        return new WSIElementShapeDictionary();\n    }\n",
    "99330": "    public WSIReadingNoteDictionary createWSIReadingNoteDictionary() {\n        return new WSIReadingNoteDictionary();\n    }\n",
    "99331": "    public WSIDatingTypeDictionary createWSIDatingTypeDictionary() {\n        return new WSIDatingTypeDictionary();\n    }\n",
    "99332": "    public WSICoverageTemporalFoundationDictionary createWSICoverageTemporalFoundationDictionary() {\n        return new WSICoverageTemporalFoundationDictionary();\n    }\n",
    "99333": "    public WSITaxonDictionary createWSITaxonDictionary() {\n        return new WSITaxonDictionary();\n    }\n",
    "99335": "    public WSIContent createWSIContent() {\n        return new WSIContent();\n    }\n",
    "99336": "    public WSIMeasurementVariableDictionary createWSIMeasurementVariableDictionary() {\n        return new WSIMeasurementVariableDictionary();\n    }\n",
    "99337": "    public WSIObjectTypeDictionary createWSIObjectTypeDictionary() {\n        return new WSIObjectTypeDictionary();\n    }\n",
    "99338": "    public SecurityGroup createSecurityGroup() {\n        return new SecurityGroup();\n    }\n",
    "99339": "    public WSICoverageTemporalDictionary createWSICoverageTemporalDictionary() {\n        return new WSICoverageTemporalDictionary();\n    }\n",
    "99340": "    public SecurityUser createSecurityUser() {\n        return new SecurityUser();\n    }\n",
    "99342": "    public EntityType getType() {\n        return type;\n    }\n",
    "99343": "    public void setType(EntityType value) {\n        this.type = value;\n    }\n",
    "99360": "    public void setSqlsAndObjectsAndElements(List<Object> sqlsAndObjectsAndElements) {\n        this.sqlsAndObjectsAndElements = sqlsAndObjectsAndElements;\n    }\n",
    "99377": "    public TridasIdentifier getIdentifier() {\n        return identifier;\n    }\n",
    "99378": "    public void setIdentifier(TridasIdentifier value) {\n        this.identifier = value;\n    }\n",
    "99380": "    public DateTime getCreatedTimestamp() {\n        return createdTimestamp;\n    }\n",
    "99382": "    public void setCreatedTimestamp(DateTime value) {\n        this.createdTimestamp = value;\n    }\n",
    "99384": "    public DateTime getLastModifiedTimestamp() {\n        return lastModifiedTimestamp;\n    }\n",
    "99385": "    public void setLastModifiedTimestamp(DateTime value) {\n        this.lastModifiedTimestamp = value;\n    }\n",
    "99388": "    public String getComments() {\n        return comments;\n    }\n",
    "99389": "    public void setComments(String value) {\n        this.comments = value;\n    }\n",
    "99391": "    public String getTrackingLocation() {\n        return trackingLocation;\n    }\n",
    "99393": "    public void setTrackingLocation(String value) {\n        this.trackingLocation = value;\n    }\n",
    "99396": "    public String getCurationLocation() {\n        return curationLocation;\n    }\n",
    "99397": "    public void setCurationLocation(String value) {\n        this.curationLocation = value;\n    }\n",
    "99399": "    public Integer getSampleCount() {\n        return sampleCount;\n    }\n",
    "99400": "    public void setSampleCount(Integer value) {\n        this.sampleCount = value;\n    }\n",
    "99405": "    public void setSamples(List<TridasSample> samples) {\n        this.samples = samples;\n    }\n",
    "99422": "    public void setElementTypes(List<ControlledVoc> elementTypes) {\n        this.elementTypes = elementTypes;\n    }\n",
    "99434": "    public void setRegions(List<ControlledVoc> regions) {\n        this.regions = regions;\n    }\n",
    "99445": "    public void setDictionaries(WSIRequest.Dictionaries value) {\n        this.dictionaries = value;\n    }\n",
    "99446": "  final public ijResult XA_DataSourceStatement() throws ParseException, SQLException {\n        Token dbname = null;\n        Token shut = null;\n        String create = null;\n    jj_consume_token(XA_DATASOURCE);\n    dbname = jj_consume_token(STRING);\n    if (jj_2_105(2)) {\n      if (jj_2_103(2)) {\n        shut = jj_consume_token(SHUTDOWN);\n      } else if (jj_2_104(2)) {\n        create = identifier();\n      } else {\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      ;\n    }\n                xahelper.XADataSourceStatement(this, dbname, shut, create);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99454": "  final public ijResult XA_ConnectStatement() throws ParseException, SQLException {\n        Token userT = null;\n        Token passwordT = null;\n        String n = null;\n    jj_consume_token(XA_CONNECT);\n    if (jj_2_106(2)) {\n      jj_consume_token(USER);\n      userT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_107(2)) {\n      jj_consume_token(PASSWORD);\n      passwordT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_108(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.XAConnectStatement(this, userT, passwordT, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99460": "  final public ijResult XA_DisconnectStatement() throws ParseException, SQLException {\n        String n = null;\n    jj_consume_token(XA_DISCONNECT);\n    if (jj_2_109(2)) {\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.XADisconnectStatement(this, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99468": "  final public ijResult XA_CommitStatement() throws ParseException, SQLException {\n        Token onePhase=null;\n        Token twoPhase=null;\n        int xid = 0;\n    jj_consume_token(XA_COMMIT);\n    if (jj_2_110(2)) {\n      onePhase = jj_consume_token(XA_1PHASE);\n    } else if (jj_2_111(2)) {\n      twoPhase = jj_consume_token(XA_2PHASE);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    xid = intValue();\n                xahelper.CommitStatement(this, onePhase, twoPhase, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99475": "  final public ijResult XA_EndStatement() throws ParseException, SQLException {\n        int flag = 0;\n        int xid = 0;\n    jj_consume_token(XA_END);\n    flag = xatmflag();\n    xid = intValue();\n                xahelper.EndStatement(this, flag, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99480": "    public WSIAuthenticate getAuthenticate() {\n        return authenticate;\n    }\n",
    "99481": "  final public ijResult XA_ForgetStatement() throws ParseException, SQLException {\n        int xid = 0;\n    jj_consume_token(XA_FORGET);\n    xid = intValue();\n                xahelper.ForgetStatement(this, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99482": "    public void setAuthenticate(WSIAuthenticate value) {\n        this.authenticate = value;\n    }\n",
    "99485": "    public WSISearchParams getSearchParams() {\n        return searchParams;\n    }\n",
    "99487": "    public void setSearchParams(WSISearchParams value) {\n        this.searchParams = value;\n    }\n",
    "99488": "  final public ijResult XA_GetConnectionStatement() throws ParseException, SQLException {\n        String n = \"XA\";\n    jj_consume_token(XA_GETCONNECTION);\n    if (jj_2_112(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                theConnection = xahelper.XAGetConnectionStatement(this, n);\n                currentConnEnv.addSession(theConnection, n);\n\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99491": "    public CorinaRequestType getType() {\n        return type;\n    }\n",
    "99493": "    public void setType(CorinaRequestType value) {\n        this.type = value;\n    }\n",
    "99495": "    public CorinaRequestFormat getFormat() {\n        return format;\n    }\n",
    "99498": "    public void setFormat(CorinaRequestFormat value) {\n        this.format = value;\n    }\n",
    "99500": "    public String getParentEntityID() {\n        return parentEntityID;\n    }\n",
    "99502": "    public void setParentEntityID(String value) {\n        this.parentEntityID = value;\n    }\n",
    "99503": "  final public ijResult XA_RecoverStatement() throws ParseException, SQLException {\n        int flag = 0;\n    jj_consume_token(XA_RECOVER);\n    flag = xatmflag();\n                {if (true) return xahelper.RecoverStatement(this, flag);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99505": "    public void setProjects(List<TridasProject> projects) {\n        this.projects = projects;\n    }\n",
    "99507": "    public void setObjects(List<TridasObject> objects) {\n        this.objects = objects;\n    }\n",
    "99508": "    public void setElements(List<TridasElement> elements) {\n        this.elements = elements;\n    }\n",
    "99509": "  final public ijResult XA_RollbackStatement() throws ParseException, SQLException {\n        int xid = 0;\n    jj_consume_token(XA_ROLLBACK);\n    xid = intValue();\n                xahelper.RollbackStatement(this, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99512": "    public void setRadiuses(List<TridasRadius> radiuses) {\n        this.radiuses = radiuses;\n    }\n",
    "99513": "    public void setMeasurementSeries(List<TridasMeasurementSeries> measurementSeries) {\n        this.measurementSeries = measurementSeries;\n    }\n",
    "99516": "  final public ijResult XA_StartStatement() throws ParseException, SQLException {\n        int flag = 0;\n        int xid = 0;\n    jj_consume_token(XA_START);\n    flag = xatmflag();\n    xid = intValue();\n                xahelper.StartStatement(this, flag, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99517": "    public void setDerivedSeries(List<TridasDerivedSeries> derivedSeries) {\n        this.derivedSeries = derivedSeries;\n    }\n",
    "99518": "    public void setUsers(List<SecurityUser> users) {\n        this.users = users;\n    }\n",
    "99519": "    public void setBoxes(List<WSIBox> boxes) {\n        this.boxes = boxes;\n    }\n",
    "99521": "    public void setEntities(List<WSIEntity> entities) {\n        this.entities = entities;\n    }\n",
    "99535": "  final public ijResult CP_DataSourceStatement() throws ParseException, SQLException {\n        Token dbname = null;\n        Token protocol = null;\n    jj_consume_token(CP_DATASOURCE);\n    dbname = jj_consume_token(STRING);\n    if (jj_2_125(2)) {\n      jj_consume_token(PROTOCOL);\n      protocol = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n                xahelper.CPDataSourceStatement(this, dbname, protocol);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99543": "  final public ijResult CP_ConnectStatement() throws ParseException, SQLException {\n        Token userT = null;\n        Token passwordT = null;\n        String n = null;\n    jj_consume_token(CP_CONNECT);\n    if (jj_2_126(2)) {\n      jj_consume_token(USER);\n      userT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_127(2)) {\n      jj_consume_token(PASSWORD);\n      passwordT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_128(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.CPConnectStatement(this, userT, passwordT, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99549": "  final public ijResult CP_GetConnectionStatement() throws ParseException, SQLException {\n        String n = \"Pooled\";\n    jj_consume_token(CP_GETCONNECTION);\n    if (jj_2_129(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                theConnection = xahelper.CPGetConnectionStatement(this, n);\n                currentConnEnv.addSession(theConnection, n);\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99557": "    public void setTaxons(List<ControlledVoc> taxons) {\n        this.taxons = taxons;\n    }\n",
    "99562": "  final public ijResult CP_DisconnectStatement() throws ParseException, SQLException {\n        String n = null;\n    jj_consume_token(CP_DISCONNECT);\n    if (jj_2_130(2)) {\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.CPDisconnectStatement(this, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99572": "    public void setObjectTypes(List<ControlledVoc> objectTypes) {\n        this.objectTypes = objectTypes;\n    }\n",
    "99601": "    public void setRemarks(List<TridasRemark> remarks) {\n        this.remarks = remarks;\n    }\n",
    "99613": "    public void setLocationTypes(List<ControlledVoc> locationTypes) {\n        this.locationTypes = locationTypes;\n    }\n",
    "99625": "    public void setSapwoods(List<ControlledVoc> sapwoods) {\n        this.sapwoods = sapwoods;\n    }\n",
    "99639": "    public Integer getCode() {\n        return code;\n    }\n",
    "99640": "    public void setCode(Integer value) {\n        this.code = value;\n    }\n",
    "99642": "    public void setContent(List<Object> content) {\n        this.content = content;\n    }\n",
    "99668": "    public void setHeartwoods(List<ControlledVoc> heartwoods) {\n        this.heartwoods = heartwoods;\n    }\n",
    "99679": "    public void setMemberOf(SecurityUser.MemberOf value) {\n        this.memberOf = value;\n    }\n",
    "99686": "    public String getUsername() {\n        return username;\n    }\n",
    "99687": "    public void setUsername(String value) {\n        this.username = value;\n    }\n",
    "99690": "    public String getFirstName() {\n        return firstName;\n    }\n",
    "99691": "    public void setFirstName(String value) {\n        this.firstName = value;\n    }\n",
    "99693": "    public String getLastName() {\n        return lastName;\n    }\n",
    "99694": "    public void setLastName(String value) {\n        this.lastName = value;\n    }\n",
    "99704": "    public void setPassword(String value) {\n        this.password = value;\n    }\n",
    "99720": "        public void setSecurityGroups(List<SecurityGroup> securityGroups) {\n            this.securityGroups = securityGroups;\n        }\n",
    "99734": "    public void setUser(WSIHeader.User value) {\n        this.user = value;\n    }\n",
    "99737": "    public String getWsVersion() {\n        return wsVersion;\n    }\n",
    "99739": "    public void setWsVersion(String value) {\n        this.wsVersion = value;\n    }\n",
    "99743": "    public String getClientVersion() {\n        return clientVersion;\n    }\n",
    "99744": "    public void setClientVersion(String value) {\n        this.clientVersion = value;\n    }\n",
    "99746": "    public XMLGregorianCalendar getRequestDate() {\n        return requestDate;\n    }\n",
    "99748": "    public void setRequestDate(XMLGregorianCalendar value) {\n        this.requestDate = value;\n    }\n",
    "99752": "    public void setQueryTime(WSIHeader.QueryTime value) {\n        this.queryTime = value;\n    }\n",
    "99755": "    public String getRequestUrl() {\n        return requestUrl;\n    }\n",
    "99756": "    public void setRequestUrl(String value) {\n        this.requestUrl = value;\n    }\n",
    "99760": "    public CorinaRequestType getRequestType() {\n        return requestType;\n    }\n",
    "99762": "    public void setRequestType(CorinaRequestType value) {\n        this.requestType = value;\n    }\n",
    "99764": "    public CorinaRequestStatus getStatus() {\n        return status;\n    }\n",
    "99765": "    public void setStatus(CorinaRequestStatus value) {\n        this.status = value;\n    }\n",
    "99774": "    public WSINonce getNonce() {\n        return nonce;\n    }\n",
    "99775": "    public void setNonce(WSINonce value) {\n        this.nonce = value;\n    }\n",
    "99779": "    public void setMessages(List<WSIMessage> messages) {\n        this.messages = messages;\n    }\n",
    "99780": "    public void setTimings(List<WSIHeader.Timing> timings) {\n        this.timings = timings;\n    }\n",
    "99802": "        public String getUnit() {\n            return unit;\n        }\n",
    "99804": "        public void setUnit(String value) {\n            this.unit = value;\n        }\n",
    "99827": "        public String getLabel() {\n            return label;\n        }\n",
    "99829": "        public void setLabel(String value) {\n            this.label = value;\n        }\n",
    "99860": "        public String getFirstname() {\n            return firstname;\n        }\n",
    "99862": "        public void setFirstname(String value) {\n            this.firstname = value;\n        }\n",
    "99866": "        public String getLastname() {\n            return lastname;\n        }\n",
    "99867": "        public void setLastname(String value) {\n            this.lastname = value;\n        }\n",
    "99888": "    public void setCoverageTemporalFoundations(List<ControlledVoc> coverageTemporalFoundations) {\n        this.coverageTemporalFoundations = coverageTemporalFoundations;\n    }\n",
    "99902": "    public void setElementAuthenticities(List<ControlledVoc> elementAuthenticities) {\n        this.elementAuthenticities = elementAuthenticities;\n    }\n",
    "99917": "    public String getSeq() {\n        return seq;\n    }\n",
    "99918": "    public void setSeq(String value) {\n        this.seq = value;\n    }\n",
    "99931": "    public SearchParameterName getName() {\n        return name;\n    }\n",
    "99932": "    public void setName(SearchParameterName value) {\n        this.name = value;\n    }\n",
    "99934": "    public SearchOperator getOperator() {\n        return operator;\n    }\n",
    "99935": "    public void setOperator(SearchOperator value) {\n        this.operator = value;\n    }\n",
    "99951": "    public WSIHeader getHeader() {\n        return header;\n    }\n",
    "99952": "    public void setHeader(WSIHeader value) {\n        this.header = value;\n    }\n",
    "99954": "    public WSIHelp getHelp() {\n        return help;\n    }\n",
    "99956": "    public void setHelp(WSIHelp value) {\n        this.help = value;\n    }\n",
    "99959": "    public WSIContent getContent() {\n        return content;\n    }\n",
    "99960": "    public void setContent(WSIContent value) {\n        this.content = value;\n    }\n",
    "99962": "    public WSIRequest getRequest() {\n        return request;\n    }\n",
    "99963": "    public void setRequest(WSIRequest value) {\n        this.request = value;\n    }\n",
    "99974": "    public Object getAny() {\n        return any;\n    }\n",
    "99975": "    public void setAny(Object value) {\n        this.any = value;\n    }\n",
    "99989": "    public void setAll(WSISearchParams.All value) {\n        this.all = value;\n    }\n",
    "99993": "    public SearchReturnObject getReturnObject() {\n        return returnObject;\n    }\n",
    "99994": "    public void setReturnObject(SearchReturnObject value) {\n        this.returnObject = value;\n    }\n",
    "99996": "    public Integer getLimit() {\n        return limit;\n    }\n",
    "99997": "    public void setLimit(Integer value) {\n        this.limit = value;\n    }\n",
    "99999": "    public Integer getSkip() {\n        return skip;\n    }\n",
    "100000": "    public void setSkip(Integer value) {\n        this.skip = value;\n    }\n",
    "100002": "    public boolean isIncludeChildren() {\n        return includeChildren;\n    }\n",
    "100003": "    public void setIncludeChildren(boolean value) {\n        this.includeChildren = value;\n    }\n",
    "100009": "    public void setParams(List<WSIParam> params) {\n        this.params = params;\n    }\n",
    "100038": "    public void setSampleTypes(List<ControlledVoc> sampleTypes) {\n        this.sampleTypes = sampleTypes;\n    }\n",
    "100054": "    public String getCnonce() {\n        return cnonce;\n    }\n",
    "100055": "    public void setCnonce(String value) {\n        this.cnonce = value;\n    }\n",
    "100058": "    public String getSnonce() {\n        return snonce;\n    }\n",
    "100059": "    public void setSnonce(String value) {\n        this.snonce = value;\n    }\n",
    "100062": "    public String getHash() {\n        return hash;\n    }\n",
    "100064": "    public void setHash(String value) {\n        this.hash = value;\n    }\n",
    "100109": "    public String getPref() {\n\treturn pref;\n    }\n",
    "100364": "\tpublic void clear() {\n\t\tset(null);\n\t}\n",
    "100365": "\tpublic void set(T value) {\n\t\t\n\t\t// special case for nulls (unset)\n\t\tif(value == null) {\n\t\t\tApp.prefs.setPref(prefName, null);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tswitch(underlyingType) {\n\t\tcase STRING:\n\t\t\tApp.prefs.setPref(prefName, (String) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase COLOR:\n\t\t\tApp.prefs.setColorPref(prefName, (Color) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase DIMENSION:\n\t\t\tApp.prefs.setDimensionPref(prefName, (Dimension) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase BOOLEAN:\n\t\t\tApp.prefs.setBooleanPref(prefName, (Boolean) value);\n\t\t\tbreak;\n\n\t\tcase INTEGER:\n\t\t\tApp.prefs.setIntPref(prefName, (Integer) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase FONT:\n\t\t\tApp.prefs.setFontPref(prefName, (Font) value);\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "100367": "\tpublic T get() {\n\t\treturn get(defaultValue);\n\t}\n",
    "100398": "\tpublic void setValue(OBJTYPE value) {\n\t\t// same value? ignore it\n\t\tif(prefValue == value)\n\t\t\treturn;\n\t\t\n\t\t// they equal the same thing? ignore it\n\t\tif(prefValue != null && prefValue.equals(value))\n\t\t\treturn;\n\t\t\n\t\tvalueModified = true;\n\t\tprefValue = value;\n\t\t\n\t\tif(autocommit)\n\t\t\tcommit();\n\t}\n",
    "100399": "\tpublic OBJTYPE getValue() {\n\t\treturn (OBJTYPE) prefValue;\n\t}\n",
    "100405": "    public int intValue() {\n        // i pity th' fool who tries to use intvalue!\n        throw new UnsupportedOperationException();\n    }\n",
    "100406": "    public boolean isYearOne() {\n        return (y == 1);\n    }\n",
    "100407": "    public Year add(int dy) {\n        // copy, and convert to zys\n        int r = y;\n        if (r < 0)\n            r++;\n\n        // add dy\n        r += dy;\n\n        // convert back, and return\n        if (r <= 0)\n            r--;\n        return Years.valueOf(r);\n    }\n",
    "100408": "    public int diff(Year y2) {\n        // copy, and convert to zys\n        int i1 = y;\n        if (i1 < 0)\n            i1++;\n\n        int i2 = y2.y;\n        if (i2 < 0)\n            i2++;\n\n        // subtract, and return\n        return i1 - i2;\n    }\n",
    "100409": "    public int mod(int m) {\n        int r = y % m;\n        if (r < 0)\n            r += m;\n        return r;\n    }\n",
    "100410": "    public int row() {\n        int z = y / 10;\n        if (y<0 && y%10!=0)\n            z--;\n        return z;\n    }\n",
    "100411": "    public int column() {\n        return mod(10);\n    }\n",
    "100412": "    public int compareTo(Year o2) {\n        return this.y - o2.y;\n    }\n",
    "100420": "    public String getDefaultExtension() {\n\treturn \".out\";\n    }\n",
    "100496": "\tprivate void quickVerify(BufferedReader r) throws IOException {\n\t\tr.mark(4096);\n\n\t\tString firstLine = r.readLine();\n\t\tif(firstLine == null || !firstLine.startsWith(\"<?xml\"))\n\t\t\tthrow new WrongFiletypeException();\n\t\t\n\t\tr.reset();\n\t}\n",
    "100500": "    public Sample load(BufferedReader r) throws IOException {\n        throw new WrongFiletypeException();\n    }\n",
    "100503": "    public String getDefaultExtension() {\n\treturn \".txt\";\n    }\n",
    "100639": "\tprivate void checkRemeasurable() {\n\t\t// enable if it's a valid index into both datasets!\n\t\tYear y = dv1.getSelectedYear();\n\t\tint col = dv1.myTable.getSelectedColumn();\n\t\tint idx = y.diff(s1.getStart());\n\t\tbtnRemeasure.setEnabled(col > 0 && col < 11 && idx >= 0 && idx < s1.getData().size() && idx < s2.getData().size());\t\t\n\t}\n",
    "100671": "\tprivate void performRedateInPlace(TridasDating dating) {\n\t\tsample.postEdit(Redate.redate(sample, range, dating));\n\t}\n",
    "100728": "        public void setSelection(int row, int col) {\n            if(row == -1)\n            \trow = lastRow;\n            if(col == -1)\n            \tcol = lastCol;\n\n            if(row < 0 || row >= table.getRowCount())\n            \treturn;\n            \n            if(col < 0 || col > table.getColumnCount())\n            \treturn;\n            \n            lastRow = row;\n        \ttable.setRowSelectionInterval(row, row);\n        \t\n        \tlastCol = col;\n        \ttable.setColumnSelectionInterval(col, col);\n        \t\n        \tdoReconciliation();\n        \tscrollToVisible(table, row, col);\n        }\n",
    "100752": "\tprivate void initButtons() {\n\t\t// cancel == close\n\t\tcancel = Builder.makeButton(\"general.cancel\");\n\t\tcancel.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent ae) {\n\t\t\t\tdispose();\n\t\t\t}\n\t\t});\n\n\t\t// ok == apply\n\t\tok = Builder.makeButton(\"general.ok\");\n\t\tok.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent ae) {\n\t\t\t\t// nothing to do?\n\t\t\t\tif (r.equals(s.getRange())) {\n\t\t\t\t\tdispose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(applyTruncation())\n\t\t\t\t\tdispose();\n\t\t\t}\n\t\t});\n\t}\n",
    "100773": "\tprivate void updateResult() {\n\t\tString rangeAndSpan;\n\t\tif (r == null) {\n\t\t\trangeAndSpan = I18n.getText(\"error\");\n\t\t\tcellModifier.updateRange(s.getRange());\n\t\t}\n\t\telse {\n\t\t\trangeAndSpan = r + \" (n=\" + r.span() + \")\";\n\t\t\tcellModifier.updateRange(r);\n\t\t}\n\n\t\tresult.setText(I18n.getText(\"truncate.afterTruncating\") + \": \" + rangeAndSpan);\n\t}\n",
    "100776": "    public int height(Graphics g) {\n        return height;\n    }\n",
    "100779": "    public float getLatitudeAsDegrees() {\n        return latitude / 3600f;\n    }\n",
    "100780": "\tpublic void setFont(Font f) {\n\t\tthis.font = f;\n\t}\n",
    "100781": "    public float getLongitudeAsDegrees() {\n        return longitude / 3600f;\n    }\n",
    "100784": "    public void setLatitudeAsDegrees(float degrees) {\n        int seconds = Math.round(degrees * 3600);\n        if (seconds < MIN_LATITUDE)\n            seconds = MIN_LATITUDE;\n        else if (seconds > MAX_LATITUDE)\n            seconds = MAX_LATITUDE;\n        this.latitude = seconds;\n    }\n",
    "100786": "    public void setLongitudeAsDegrees(float degrees) {\n        int seconds = Math.round(degrees * 3600);\n\n        // need to make sure the longitude is between -180 and 179 degrees.\n        // 180 degrees, for example, gets sent back down to -180.\n        // if i were doing degrees, i'd add 180, mod 360, sub 180.\n        // so just do that in seconds.\n        seconds += 180 * 3600;\n        seconds %= 360 * 3600;\n        if (seconds <= 0)\n            seconds += 180 * 3600;\n        else\n            seconds -= 180 * 3600;\n        \n        this.longitude = seconds;\n    }\n",
    "100788": "    public int getLatitudeAsSeconds() {\n        return latitude;\n    }\n",
    "100789": "    public int getLongitudeAsSeconds() {\n        return longitude;\n    }\n",
    "100791": "    public void setLatitudeAsSeconds(int seconds) {\n        if (seconds < MIN_LATITUDE)\n            seconds = MIN_LATITUDE;\n        else if (seconds > MAX_LATITUDE)\n            seconds = MAX_LATITUDE;\n        this.latitude = seconds;\n    }\n",
    "100793": "    public void setLongitudeAsSeconds(int seconds) {\n        // make sure longitude is between -180 and 179 degrees.\n        // see setLongitudeAsDegrees().\n        seconds += 180 * 3600;\n        seconds %= 360 * 3600;\n        if (seconds <= 0)\n            seconds += 180 * 3600;\n        else\n            seconds -= 180 * 3600;\n\n        // PERF: make sure these are computed at compile-time, not run-time.\n\n        // FIXME: extract method normalizeLongitude() (lat, too, while you're at it)\n\n        this.longitude = seconds;\n    }\n",
    "100804": "    public boolean containsOnlyNumbers(String str) {\n        \n        //It can't contain only numbers if it's null or empty...\n        if (str == null || str.length() == 0)\n            return false;\n        \n        for (int i = 0; i < str.length(); i++) {\n\n            //If we find a non-digit character we return false.\n            if (!Character.isDigit(str.charAt(i)))\n                return false;\n        }\n        \n        return true;\n    }\n",
    "100851": "\tprotected void repaintParent() {\n\t\tif(listener != null)\n\t\t\tlistener.cellModifierChanged(this);\n\t}\n",
    "100862": "\tpublic int getRowCount() {\n\t\t// these need to be updated when the user inserts/deletes\n\t\tcountRows();\n\n\t\t// compute num rows\n\t\tint n = row_max - row_min + 1;\n\n\t\t// always give a blank space for more data entry; if the last year\n\t\t// is the last year of this decade, we'll need another decade\n\t\tif (s.getRange().getEnd().column() == 9)\n\t\t\tn++;\n\n\t\treturn n;\n\t}\n",
    "100863": "\tpublic int getColumnCount() {\n\t\treturn 12;\n\t}\n",
    "100878": "\tprivate Icon lazyLoadIcon(String iconName) {\n\t\tif(iconName == null)\n\t\t\treturn null;\n\t\t\n\t\tIcon icon = lazyIconMap.get(iconName);\n\t\tif(icon == null) {\n\t\t\t// lazy-load the icon\n\t\t\ticon = Builder.getIcon(iconName, 16);\n\t\t\tlazyIconMap.put(iconName, icon);\n\t\t}\n\t\t\n\t\treturn icon;\t\t\n\t}\n",
    "100879": "\tprivate Icon getTridasIcon(NormalTridasRemark remark) {\n\t\treturn lazyLoadIcon(Remarks.getTridasRemarkIcons().get(remark));\n\t}\n",
    "100880": "\tprivate Icon getCorinaIcon(String remark) {\n\t\treturn lazyLoadIcon(Remarks.getCorinaRemarkIcons().get(remark));\n\t}\n",
    "100898": "\t\tprivate void populateFromObject(TridasObject obj) {\n\t\t\tList<TridasObject> flatObjects = new ArrayList<TridasObject>();\n\n\t\t\t// start out with the toplevel object\n\t\t\tflatObjects.add(obj);\n\t\t\t\n\t\t\t// if it has children, keep traversing\n\t\t\twhile(obj.isSetObjects()) {\n\t\t\t\tobj = obj.getObjects().get(0);\n\t\t\t\tflatObjects.add(obj);\n\t\t\t}\n\t\t\n\t\t\tobject = obj;\n\t\t\tobjectArray = flatObjects.toArray(new TridasObject[0]);\n\t\t\t\n\t\t\tif(!object.isSetElements())\n\t\t\t\treturn;\n\t\t\t\n\t\t\telement = object.getElements().get(0);\n\t\t\t\n\t\t\tif(!element.isSetSamples())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tsample = element.getSamples().get(0);\n\t\t\t\n\t\t\tbox = loadBoxFromSample(sample);\n\t\t}\n",
    "100934": "\tpublic Year getSelectedYear() {\n\t\treturn ((DecadalModel) myModel).getYear(myTable.getSelectedRow(),\n\t\t\t\tmyTable.getSelectedColumn());\n\t}\n",
    "100935": "\tprivate Image lazyLoadIcon(String iconName) {\n\t\tif(iconName == null)\n\t\t\treturn null;\n\t\t\n\t\tImage icon = lazyIconMap.get(iconName);\n\t\tif(icon == null) {\n\t\t\t// lazy-load the icon\n\t\t\ticon = Builder.getITextImageIcon(iconName);\n\n\t\t\tlazyIconMap.put(iconName, icon);\n\t\t}\n\t\t\n\t\treturn icon;\t\t\n\t}\n",
    "100940": "\tprivate Image getTridasIcon(NormalTridasRemark remark) {\n\t\treturn lazyLoadIcon(Remarks.getTridasRemarkIcons().get(remark));\n\t}\n",
    "100943": "\tprivate Image getCorinaIcon(String remark) {\n\t\t\n\t\tString iconName = Remarks.getCorinaRemarkIcons().get(remark);\n\t\t\n\t\treturn lazyLoadIcon(iconName);\n\t}\n",
    "100980": "\tpublic void addCellModifier(TableCellModifier modifier) {\n\t\tmyCellRenderer.addModifier(modifier);\n\t\t\n\t\t// repaint the table on notification\n\t\tmodifier.setListener(new TableCellModifierListener() {\n\t\t\tpublic void cellModifierChanged(TableCellModifier modifier) {\n\t\t\t\tmyTable.repaint();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// repaint now, to be safe\n\t\tmyTable.repaint();\n\t}\n",
    "100987": "\tpublic void removeCellModifier(TableCellModifier modifier) {\n\t\tmyCellRenderer.removeModifier(modifier);\n\t\tmodifier.setListener(null);\n\t\tmyTable.repaint();\n\t}\n",
    "101142": "\tprivate void makeMenusHeavyweight() {\n\t\tJMenuBar menus = getJMenuBar();\n\t\t\n\t\tfor(int i = 0; i < menus.getMenuCount(); i++)\n\t\t\tmenus.getMenu(i).getPopupMenu().setLightWeightPopupEnabled(false);\n\t}\n",
    "101178": "\tpublic void setLoadProperty(String propertyName, Object value) {\n\t\tif(loadProperties == null)\n\t\t\tloadProperties = new HashMap<String, Object>();\n\t\t\n\t\tloadProperties.put(propertyName, value);\n\t}\n",
    "101179": "\tpublic void setSaveProperty(String propertyName, Object value) {\n\t\tif(saveProperties == null)\n\t\t\tsaveProperties = new HashMap<String, Object>();\n\t\t\n\t\tsaveProperties.put(propertyName, value);\n\t}\n",
    "101195": "\tpublic SampleDataView getSampleDataView() {\n\t\treturn dataView;\n\t}\n",
    "101202": "\tpublic String getMetaString(String key) {\n\t\tObject o = meta.get(key);\n\t\t\n\t\treturn (o == null) ? null : o.toString();\n\t}\n",
    "101204": "\tprivate TridasValues createEmptyRingWidths() {\n\t\tTridasValues values = new TridasValues();\n\t\t\n\t\t// set default units\n\t\tTridasUnit units = new TridasUnit();\t\t\n\t\tunits.setNormalTridas(NormalTridasUnit.HUNDREDTH_MM);\n\t\tvalues.setUnit(units);\n\t\t\n\t\t// set as ring widths\n\t\tTridasVariable variable = new TridasVariable();\n\t\tvariable.setNormalTridas(NormalTridasVariable.RING_WIDTH);\n\t\tvalues.setVariable(variable);\n\n\t\t// populate the list of values (empty)\n\t\tvalues.getValues();\n\t\t\n\t\treturn values;\n\t}\t\n",
    "101208": "\tprivate TridasValues createEmptyWeiserjahre() {\n\t\tTridasValues values = new TridasValues();\n\t\t\n\t\tvalues.setUnitless(new TridasUnitless());\n\t\t\n\t\t// set as Weiserjahre\n\t\tvalues.setVariable(WEISERJAHRE_VARIABLE);\n\n\t\t// populate the list of values (empty)\n\t\tvalues.getValues();\n\t\t\n\t\treturn values;\n\t}\t\n",
    "101214": "\tpublic SampleType getSampleType() {\n\t\treturn sampleType;\n\t}\n",
    "101215": "\tpublic void setSampleType(SampleType sampleType) {\n\t\tthis.sampleType = sampleType;\n\t}\n",
    "101216": "\tpublic ITridasSeries getSeries() {\n\t\treturn series;\n\t}\n",
    "101217": "\tpublic void setSeries(ITridasSeries series) {\n\t\tthis.series = series;\n\n\t\t// update our sample type to reflect what's going on\n\t\tif(series instanceof ITridasDerivedSeries) {\n\t\t\tif(!sampleType.isDerived())\n\t\t\t\tsampleType = SampleType.UNKNOWN_DERIVED;\n\t\t}\n\t\telse if(sampleType.isDerived())\n\t\t\tsampleType = SampleType.UNKNOWN;\n\t}\n",
    "101218": "\tpublic TridasValue getValueForYear(Year y) {\n\t\treturn getValueForYear(tridasValuesMap.get(NormalTridasVariable.RING_WIDTH), y);\n\t}\n",
    "101219": "\tpublic CorinaMetadata meta() {\n\t\tif(metadata == null)\n\t\t\tmetadata = new BaseSampleMetadata(this);\n\t\t\n\t\treturn metadata;\n\t}\n",
    "101220": "\tpublic String getDisplayTitle() {\n\t\treturn getMeta(\"title\", String.class);\n\t}\t\n",
    "101223": "\tpublic TridasValue getValueForYear(TridasValues values, Year y) {\n\t\tRange range = getRange();\n\n\t\tif(!range.contains(y))\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\n\t\tint idx = y.diff(range.getStart());\n\t\treturn values.getValues().get(idx);\t\t\n\t}\n",
    "101224": "\tpublic TridasIdentifier getIdentifier() {\n\t\treturn (series != null) ? series.getIdentifier() : null;\n\t}\n",
    "101231": "\tpublic void clearModified() {\n\t\tmodified = false;\n\t}\n",
    "101239": "\tpublic String getName() {\n\t\treturn loader.getName();\n\t}\n",
    "101240": "\tpublic String getShortName() {\n\t\treturn loader.getShortName();\n\t}\n",
    "101242": "\tpublic int compareTo(Element o) {\n\t\tif(o == this)\n\t\t\treturn 0;\n\t\t\n\t\treturn o.getName().compareTo(getName());\n\t}\n",
    "101249": "\tpublic Sample load() throws IOException {\n\t\tSample s = Files.load(filename);\n\n\t\tif(s==null) return null;\n\t\t\n\t\ts.setLoader(this);\n\t\t\n\t\t// lazily-load this...?\n\t\ttype = s.getSampleType();\n\t\t\n\t\t// we loaded it, so tell our open menu...\n\t\t// Don't do this here, it affects imports!\n\t\t//OpenRecent.sampleOpened(this);\n\t\t\n\t\treturn s;\n\t}\n",
    "101252": "\tpublic int countRings() {\n\t\t// it's not a sum, so the number of rings is just the length\n\t\t// (if (null count) (length data) ...\n\t\tList<Number> data = getData();\n\t\t\n\t\tif (!hasCount())\n\t\t\treturn data.size();\n\n\t\tList<Integer> count = getCount();\n\n\t\t// it's a sum, so the number of rings is the sum of the number\n\t\t// of measurements for each year\n\t\t// ... (apply '+ count))\n\t\tint n = 0, size = count.size();\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tn += count.get(i);\n\t\treturn n;\n\t}\n",
    "101256": "\tpublic String getRelativeFilename() {\n\t\t// no basename or folder? return relative path...\n\t\tif(basename == null || folder == null)\n\t\t\treturn filename;\n\t\t\n\t\treturn \"?\" + folder + \":\" + basename;\n\t}\n",
    "101265": "\tpublic SampleType getSampleType() {\n\t\treturn type;\n\t}\n",
    "101267": "\tpublic void addAll(ElementList src) {\n\t\tfor(Element e : src) {\n\t\t\tadd(e);\n\t\t\tif(src.activeMap.containsKey(e))\n\t\t\t\tactiveMap.put(e, src.activeMap.get(e));\n\t\t}\n\t}\n",
    "101271": "\tpublic ElementList toActiveList() {\n\t\tElementList activeList = new ElementList();\n\t\t\n\t\tfor(Element e : this)\n\t\t\tif(isActive(e))\n\t\t\t\tactiveList.add(e);\n\t\t\n\t\treturn activeList;\n\t}\n",
    "101284": "\tpublic float getScale() {\n\t\treturn (isIndexed() ? 0.1f : 1.0f);\n\t}\n",
    "101287": "\tpublic Year getStart() {\n\t\treturn getRange().getStart();\n\t}\n",
    "101296": "\tpublic boolean isAbsolutelyDated() {\n\t\tITridasSeries series = getSeries();\n\t\t\n\t\t// no interpretation or no dating -> Relative dating\n\t\tif(!series.isSetInterpretation() || !series.getInterpretation().isSetDating())\n\t\t\treturn false;\n\t\t\n\t\tswitch(series.getInterpretation().getDating().getType()) {\n\t\tcase ABSOLUTE:\n\t\tcase DATED___WITH___UNCERTAINTY:\n\t\tcase RADIOCARBON:\n\t\t\treturn true;\n\t\t\t\n\t\tcase RELATIVE:\n\t\t\treturn false;\n\t\t\t\n\t\tdefault:\n\t\t\tnew Bug(new IllegalArgumentException(\"Dating type \" + \n\t\t\t\t\tseries.getInterpretation().getDating() + \" not supported\"));\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "101300": "\tpublic boolean isIndexed() {\n\t\tswitch(super.getSampleType()) {\n\t\tcase INDEX:\n\t\t\treturn true; // nice and easy\n\n\t\t// we don't know? guess. and save our guess.\n\t\tcase UNKNOWN:\n\t\t\tString type = (String) getMeta(\"format\");\n\t\t\tif (type != null && Character.toUpperCase(type.charAt(0)) == 'I') {\n\t\t\t\tsetSampleType(SampleType.INDEX);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\t\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "101302": "\tpublic boolean isModified() {\n\t\treturn modified;\n\t}\n",
    "101306": "\tpublic boolean isSummed() {\n\t\tswitch(super.getSampleType()) {\n\t\tcase SUM:\n\t\t\treturn true; // nice and easy\n\n\t\t// we don't know? guess.\n\t\t// why is this \"or?\"\n\t\tcase UNKNOWN: {\n\t\t\tif (elements != null || hasCount()) {\n\t\t\t\tsetSampleType(SampleType.SUM);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "101312": "\tpublic boolean hasCount() {\n\t\treturn ringwidths.hasCount();\n\t}\n",
    "101320": "\tpublic void setModified() {\n\t\tmodified = true;\n\t}\n",
    "101330": "\tpublic String toSimpleString() {\n\t\tString name = getDisplayTitle();\n\t\tif (isModified()) // not aqua-ish, but how to do it the real way?\n\t\t\tname = \"* \" + name;\n\t\treturn name;\n\t}\n",
    "101352": "  public void setProgress(int value) {\n    v = value;\n    if (value >= max) {\n      close();\n    } else if (value >= lastDisp + reportDelta) {\n      lastDisp = value;\n      if (popped) {\n        notifyStateChanged();\n      } else {\n        long T = System.currentTimeMillis();\n        long dT = (int)(T-T0);\n        if (dT >= millisToDecideToPopup) {\n          int predictedCompletionTime;\n          if (value > min) {\n            predictedCompletionTime = (int)(dT *\n                                            (max - min) /\n                                            (value - min));\n          } else {\n            predictedCompletionTime = millisToPopup;\n          }\n          if (predictedCompletionTime >= millisToPopup) {\n            popped = true;\n            notifyDisplay();\n          }\n        }\n      }\n    }\n  }\n",
    "101353": "  public void close() {\n    if (!popped) return;\n    popped = false;\n    notifyClosed();\n  }\n",
    "101355": "  public int getMinimum() {\n    return min;\n  }\n",
    "101356": "  public void setMinimum(int m) {\n    min = m;\n  }\n",
    "101357": "  public int getMaximum() {\n    return max;\n  }\n",
    "101358": "  public void setMaximum(int m) {\n    max = m;\n  }\n",
    "101361": "  public void setMillisToDecideToPopup(int millisToDecideToPopup) {\n    this.millisToDecideToPopup = millisToDecideToPopup;\n  }\n",
    "101362": "  public int getMillisToDecideToPopup() {\n    return millisToDecideToPopup;\n  }\n",
    "101363": "  public void setMillisToPopup(int millisToPopup) {\n    this.millisToPopup = millisToPopup;\n  }\n",
    "101365": "  public int getMillisToPopup() {\n    return millisToPopup;\n  }\n",
    "101367": "  public void setNote(String note) {\n    this.note = note;\n    if (popped) {\n      notifyStateChanged();\n    }\n  }\n",
    "101368": "  public String getNote() {\n    return note;\n  }\n",
    "101369": "\tpublic void setSortColumn(Integer sortColumn) {\n\t\tif (sortColumn != null)\n\t\t\tthis.sortColumn = sortColumn;\n\t\telse\n\t\t\tthis.sortColumn = -1;\n\t}\n",
    "101371": "\tpublic void setReversed(boolean reversed) {\n\t\tthis.reversed = reversed;\n\t}\n",
    "101372": "\tpublic boolean isReversed() {\n\t\treturn reversed;\n\t}\n",
    "101550": "    protected void addLabelMenu() {\n    \t\n    \tJMenu labelmenu = Builder.makeMenu(\"menus.admin.labels\", \"label.png\");\n\n    \t\n    \tJMenuItem boxlabel = Builder.makeMenuItem(\"menus.admin.boxlabels\",\n                \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.boxLabelDialog()\", \"box.png\");\n        labelmenu.add(boxlabel);\n    \t\n        JMenuItem samplelabel = Builder.makeMenuItem(\"menus.admin.samplelabels\",\n                \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.sampleLabelDialog()\", \"sample.png\");\n        labelmenu.add(samplelabel);   \n        add(labelmenu);\n    }\n",
    "101551": "\t protected void addReportsMenu() {\n\t \t\n\t \tJMenu reportmenu = Builder.makeMenu(\"menus.admin.reports\", \"prosheet.png\");\n\t \t\n\t \t\n\t    JMenuItem prosheet = Builder.makeMenuItem(\"menus.admin.prosheet\",\n\t            \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.proSheetPrintingDialog()\", \"prosheet.png\");\n\t    reportmenu.add(prosheet); \n\t \tadd(reportmenu);\n\t }\n",
    "101553": "\tprotected void addUserGroupMenu() {\n\t\t\n\t  \tJMenuItem usergroup = Builder.makeMenuItem(\"menus.admin.usersandgroups\",\n\t            \"edu.cornell.dendro.corina.admin.UserGroupAdmin.main()\", \"edit_group.png\");\n\t\n\t\tusergroup.setEnabled(true);\n\t\tadd(usergroup);\n\t}\n",
    "101555": "\tprotected void addCurationMenu() {\n\t\t\n\t \tJMenu curationmenu = Builder.makeMenu(\"menus.admin.curation\", \"curation.png\");\n\t \t\n\t \t\n\t    JMenuItem findsample = Builder.makeMenuItem(\"menus.admin.findsample\",\n\t            \"edu.cornell.dendro.corina.admin.SampleCuration.showDialog()\", \"findsample.png\");\n\t    curationmenu.add(findsample); \n\t    \n\t    \n\t    JMenuItem inventory = Builder.makeMenuItem(\"menus.admin.inventory\",\n\t            \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.proSheetPrintingDialog()\");\n\t    inventory.setEnabled(false);\n\t    curationmenu.add(inventory); \n\t    \n\t \tadd(curationmenu);\n\t}\n",
    "101557": "    protected void addHelpMenu() {\n    \t\n\t// See if we have access to mozilla libs\n\ttry {\n\t\t// this loads the DLL...\n\t\tClass.forName(\"org.mozilla.browser\");\n\t}\n\tcatch (Exception e) {\n\t\t// driver not installed...\n\t\tSystem.out.println(\"No mozilla - no help\");\n\t\tSystem.out.println(e.toString());\n\t\treturn;\n\t}\n\tcatch (Error e) {\n\t\t// native interface not installed...\n\t\tSystem.out.println(\"No mozilla - no help\");\n\t\tSystem.out.println(e.toString());\n\t\treturn;\n\t}\n\t\n\t// Mozilla present so add help menu\n\tadd(Builder.makeMenuItem(\"menus.help.corina_help\",\n\t\t\t\t \"edu.cornell.dendro.corina.gui.HelpWiki.showHelp()\", \"help.png\"));\n    }\n",
    "101558": "    protected void addSystemInfoMenu() {\n        add(Builder.makeMenuItem(\"menus.help.system_info\",\n                                 \"edu.cornell.dendro.corina.util.PropertiesWindow.showPropertiesWindow()\", \"system.png\"));\n    }\n",
    "101561": "    protected void addAboutMenu() {\n      JMenuItem menuitem = Builder.makeMenuItem(\"menus.about\");\n      menuitem.setAction(ABOUT_ACTION);\n      add(menuitem);\n    }\n",
    "101565": "    public int getUpperValue() {\n        return getValue() + getExtent();\n    }\n",
    "101567": "    public void setUpperValue(int value) {\n        // Compute new extent.\n        int lowerValue = getValue();\n        int newExtent = Math.min(Math.max(0, value - lowerValue), getMaximum() - lowerValue);\n        \n        // Set extent to set upper value.\n        setExtent(newExtent);\n    }\n",
    "101603": "    private void paintLowerThumb(Graphics g) {\n        Rectangle knobBounds = thumbRect;\n        int w = knobBounds.width;\n        int h = knobBounds.height;      \n        \n        // Create graphics copy.\n        Graphics2D g2d = (Graphics2D) g.create();\n\n        // Create default thumb shape.\n        Shape thumbShape = createThumbShape(w - 1, h - 1);\n\n        // Draw thumb.\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n            RenderingHints.VALUE_ANTIALIAS_ON);\n        g2d.translate(knobBounds.x, knobBounds.y);\n\n        g2d.setColor(Color.GRAY);\n        g2d.fill(thumbShape);\n\n        g2d.setColor(Color.GRAY);\n        g2d.draw(thumbShape);\n        \n        // Dispose graphics.\n        g2d.dispose();\n    }\n",
    "101605": "    private void paintUpperThumb(Graphics g) {\n        Rectangle knobBounds = upperThumbRect;\n        int w = knobBounds.width;\n        int h = knobBounds.height;      \n        \n        // Create graphics copy.\n        Graphics2D g2d = (Graphics2D) g.create();\n\n        // Create default thumb shape.\n        Shape thumbShape = createThumbShape(w - 1, h - 1);\n\n        // Draw thumb.\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n            RenderingHints.VALUE_ANTIALIAS_ON);\n        g2d.translate(knobBounds.x, knobBounds.y);\n\n        g2d.setColor(Color.GRAY);\n        g2d.fill(thumbShape);\n\n        g2d.setColor(Color.GRAY);\n        g2d.draw(thumbShape);\n\n        // Dispose graphics.\n        g2d.dispose();\n    }\n",
    "101607": "    private Shape createThumbShape(int width, int height) {\n        // Use circular shape.\n        Ellipse2D shape = new Ellipse2D.Double(0, 0, width, height);\n        return shape;\n    }\n",
    "101609": "    private void setUpperThumbLocation(int x, int y) {\n        Rectangle upperUnionRect = new Rectangle();\n        upperUnionRect.setBounds(upperThumbRect);\n\n        upperThumbRect.setLocation(x, y);\n\n        SwingUtilities.computeUnion(upperThumbRect.x, upperThumbRect.y, upperThumbRect.width, upperThumbRect.height, upperUnionRect);\n        slider.repaint(upperUnionRect.x, upperUnionRect.y, upperUnionRect.width, upperUnionRect.height);\n    }\n",
    "101653": "\tprivate void checkValid() {\n\t\tboolean isValid = isDataValid();\n\t\t\n\t\tif(valid == isValid)\n\t\t\treturn;\n\t\t\n\t\tboolean oldValid = valid;\n\t\tvalid = isValid;\n\t\t\n\t\t// change background color and repaint accordingly\n\t\tsetBackground(valid ? validColor : invalidColor);\n\t\trepaint();\n\n\t\tproperties.firePropertyChange(PARAMETER_VALID_PROPERTY, oldValid, valid);\t\t\n\t}\n",
    "101655": "\tpublic SearchParameterName getParameterName() {\n\t\tObject o = cboSearchField.getSelectedItem();\n\t\t\n\t\tif(o instanceof SearchParameterName)\n\t\t\treturn (SearchParameterName) o;\n\t\t\n\t\treturn null;\n\t}\n",
    "101656": "\tpublic SearchOperator getOperator() {\n\t\treturn (SearchOperator) cboSearchOperator.getSelectedItem();\n\t}\n",
    "101658": "\tpublic String getValue() {\n\t\tString value = txtSearchText.getText();\n\t\t\n\t\treturn (value.length() > 0) ? value : null;\n\t}\n",
    "101663": "\tpublic void addSearchParameterPropertyChangeListener(PropertyChangeListener listener) {\n\t\tproperties.addPropertyChangeListener(listener);\n\t}\n",
    "101664": "\tpublic void removeSearchParameterPropertyChangeListener(PropertyChangeListener listener) {\n\t\tproperties.removePropertyChangeListener(listener);\n\t}\n",
    "101683": "\tpublic void setNonce(String nonce, String seq) {\n\t\tserverNonce = nonce;\n\t\tserverNonceSeq = seq;\n\t}\n",
    "101713": "    protected void doInitComponents(){\n    \t// Dynamic components\n\t    btnAdd = new javax.swing.JButton();\n\t    btnRemove = new javax.swing.JButton();\n\t    tblAvailMeas = new javax.swing.JTable();\n\t    tblChosenMeas = new javax.swing.JTable();\n\t    // Standard components\n    \tinitComponents();\n    \t\n    \t// Hide ribbon \n\t    panelRibbon.setVisible(false);\n\t    \n\t    // Hide preview button\n\t    btnPreview.setVisible(false);\n\n\t    // Make sure components are using I18n\n        internationalizeComponents();\n         \n    }\n",
    "101719": "    public void playBarcodeBeep(){\n\t\tAudioClip beep;\n\t\ttry {\t\n\t\t\t// play this to indicate measuring is on...\n\t\t\tbeep = Applet.newAudioClip(getClass().getClassLoader().getResource(\"edu/cornell/dendro/corina_resources/Sounds/checkout.wav\"));\n\t\t\tif(beep != null)\n\t\t\t\tbeep.play();\n\t\t} catch (Exception ae) { \n\t\t\tSystem.out.println(\"Failed to play sound\");\n\t\t\tSystem.out.println(ae.getMessage());\n\t\t\t}\n\t\t\n    }\n",
    "101731": "    private void setupSearch() {\n    \tsearchPanel = new SearchPanel(new SearchSupport());\n    \tthis.browseSearchPane.setComponentAt(1, searchPanel);\n    }\n",
    "101732": "\tprivate void rebuild() {\n\t\t// delete the layout\n\t\tpanel.removeAll();\n\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\t\n\t\tc.gridx = 0;\n\t\tc.gridy = 0;\n\t\tc.ipady = 4;\n\t\t\n\t\t// now, add everything to our layout\n\t\tfor(SearchParameterPanel searchPanel : parameters) {\n\t\t\tpanel.add(searchPanel, c);\n\t\t\tc.gridy++;\n\t\t}\n\t\t\n\t\tc.anchor = GridBagConstraints.LINE_START;\n\t\tpanel.add(addButton, c);\n\t\t\n\t\t// revalidate our panel, we changed the layout\n\t\tpanel.revalidate();\t\t\n\t}\n",
    "101733": "\tprivate void rebuildQuery() {\n\t\tSearchParameters search = new SearchParameters(SearchReturnObject.MEASUREMENT_SERIES);\n\n\t\t// don't include children\n\t\tsearch.setIncludeChildren(false);\n\t\t\n\t\tfor(SearchParameterPanel searchPanel : parameters) {\n\t\t\tif(!searchPanel.isDataValid())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tsearch.addSearchConstraint(searchPanel.getParameterName(), searchPanel.getOperator(), \n\t\t\t\t\tsearchPanel.getValue());\n\t\t}\n\t\t\n\t\t// empty search? don't change anything...\n\t\tif(!search.isSetParams())\n\t\t\treturn;\n\t\t\n\t\tstartSearch(search);\n\t}\n",
    "101744": "\tpublic void reSort() {\n\t\t// nothing to sort by :(\n\t\tif(lastSortedCol < 0)\n\t\t\treturn;\n\t\t\n\t\tint col = lastSortedCol;\n\t\tboolean reverse = headerRenderer.isReversed();\n\t\t\n\t\tlastSortedCol = -1;\n\t\tsortOnColumn(col, reverse);\n\t}\n",
    "101745": "\tpublic void sortOnColumn(int col, boolean reverse) {\n\t\tif(col == lastSortedCol) {\n\t\t\tCollections.reverse(model.getElements());\n\t\t\theaderRenderer.setReversed(!headerRenderer.isReversed());\n\t\t}\n\t\telse {\n\t\t\tCollections.sort(model.getElements(), new ElementListTableColumnComparator(model, col));\n\t\t\t\n\t\t\theaderRenderer.setSortColumn(col);\n\t\t\theaderRenderer.setReversed(false);\n\t\t\t\n\t\t\tlastSortedCol = col;\n\t\t\t\n\t\t\tif(reverse)\n\t\t\t\tCollections.reverse(model.getElements());\n\t\t}\n\t\n\t\t\n\t\t// notify the model and repaint the header\n\t\tmodel.fireTableDataChanged();\n\t\ttable.getTableHeader().repaint();\n\t\t\n\t}\n",
    "101755": "    public Dimension minimumLayoutSize(Container parent) {\n        return getLayoutSize(parent, false);\n    }\n",
    "101756": "    public Dimension preferredLayoutSize(Container parent) {\n        return getLayoutSize(parent, true);\n    }\n",
    "101757": "    public void addLayoutComponent(String name, Component comp) {\n        // do nothing\n    }\n",
    "101758": "    public void removeLayoutComponent(Component comp) {\n        // do nothing\n    }\n",
    "101821": "\tprotected void setCapsNoWhitespace(JTextField field) {\n\t\tfield.addKeyListener(new KeyAdapter() {\n\t\t\tpublic void keyTyped(KeyEvent ke) {\n\t\t\t\tchar k = ke.getKeyChar();\n\t\t\t\t\n\t\t\t\t// don't allow any whitespace\n\t\t\t\tif(Character.isWhitespace(k)) {\n\t\t\t\t\tke.consume(); // om nom nom nom!\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// force uppercase\n\t\t\t\tke.setKeyChar(Character.toUpperCase(k));\n\t\t\t}\n\t\t});\n\t}\n",
    "101828": "\tprotected void setSelectAllOnFocus(JTextField field) {\n\t\tfinal JTextField glue = field;\n\t\t\n\t\tfield.addFocusListener(new FocusAdapter() {\n\t\t\tpublic void focusGained(FocusEvent fe) {\n\t\t\t\tglue.selectAll();\n\t\t\t}\n\t\t});\n\t}\n",
    "101831": "\tprivate void setMaxHeight(Component comp) {\n\t\tDimension d = comp.getPreferredSize();\n\t\tcomp.setMaximumSize(new Dimension(Short.MAX_VALUE, d.height));\n\t}\n",
    "101832": "\tprotected void colorField(JComponent field, boolean isValid) {\n\t\tif(isValid) {\n\t\t\tfield.setBackground(UIManager.getLookAndFeelDefaults().getColor(\"TextField.background\"));\n\t\t} else {\n\t\t\tfield.setBackground(new Color(255, 255, 200));\n\t\t}\n\t}\n",
    "101846": "    public void preVisibleNotify() {\n\t\t// finally, if we have any defaults, apply them to our editor panel\n\t\tObject o;\n\t\tif((o = wizardParent.getDefaultsForClass(contentClass)) != null) {\n\t\t\tsetDefaultSelectionFrom((OBJT) o); // apply them to our combobox, perhaps?\n\t\t\tmyPanel.setDefaultsFrom((OBJT) o); // and fill in our editor pane\n\t\t}\n    }\n",
    "101851": "    public OBJT getPanelObject() {\n    \tObject selection = cboExistingList.getSelectedItem();\n    \t\n    \tif(selection == null)\n    \t\tthrow new IllegalStateException(\"GetPanelObject() has no object?\");\n    \t\n    \tif(!selection.getClass().equals(contentClass)) {\n    \t\tthrow new IllegalStateException(\"GetPanelObject() not content class, instead it's \" + selection.getClass().toString());\n    \t}\n    \t\n    \treturn (OBJT) selection;\n    }\n",
    "101854": "    public void preVisibleNotify() {\n\t\t// if we have any defaults, apply them\n\t\tObject o;\n\t\tif((o = parent.getDefaultsForClass(contentClass)) != null) \n\t\t\tsetDefaultsFrom((Sample) o);\n    }\n",
    "101855": "    private void checkEverythingValid() {\n    \tif(btnExisting.isSelected()) {\n    \t\tcheckComboValid();\n    \t\t\n    \t\tif(ourFormValidated)\n    \t\t\tsetPanelValid(true);\n    \t\telse\n    \t\t\tsetPanelValid(false);\n    \t}\n    \telse if(btnNew.isSelected()) {    \t\t\n    \t\tif(childFormValidated)\n    \t\t\tsetPanelValid(true);\n    \t\telse\n    \t\t\tsetPanelValid(false);\n    \t}\n    }\n",
    "101856": "    private void checkComboValid() {\n\t\t// do we have a valid selection in the combo box?\n\t\tObject obj = cboExistingList.getSelectedItem();\n\t\tif(obj != null && obj.getClass().equals(contentClass))\n\t\t\tourFormValidated = true;\n\t\telse\n\t\t\tourFormValidated = false;\n    }\n",
    "101862": "    public boolean isPanelValid() {\n    \treturn panelValid;\n    }\n",
    "101873": "\tpublic void notifyChildFormStateChanged() {\n\t\tchildFormValidated = myPanel.isFormValidated();\n\t\t\n\t\tcheckEverythingValid();\n\t}\n",
    "101889": "    public void addElement(Element e) {\n\t\tif(!selectedElements.contains(e))\n\t\t\tselectedElements.add(e);\n\t\telse\n\t\t\treturn;\n\t\n\t\tchosenSorter.reSort();\n\t\t\n\t\t// tell the table it's changed!\n\t\t((ElementListTableModel)tblChosenMeas.getModel()).fireTableDataChanged();\n\n\t\t// verify a selected element\n\t\tif(selectedElements.size() > minimumSelectedElements)\n\t\t\tbtnOk.setEnabled(true);\n\t\telse\n\t\t\tbtnOk.setEnabled(false);    \t\n    }\n",
    "101891": "\tprotected void setNewObject(OBJT obj) {\n\t\tthis.newObject = obj;\n\t}\n",
    "101893": "    public TridasEntityBase getPanelObject() {\n    \treturn null;\n    }\n",
    "101896": "\tpublic void populate() {\n\t\t\n\t}\n",
    "101897": "    public void deleteElement(Element e) {\n   \t\tdeleteElementFromModel(e, ((ElementListTableModel)tblChosenMeas.getModel()));\n   \t\tdeleteElementFromModel(e, ((ElementListTableModel)tblAvailMeas.getModel()));    \t\n    }\n",
    "101898": "\tpublic void populate(String parentPrefix) {\n\t\t\n\t}\n",
    "101899": "\tprotected boolean createOrUpdateObject(IntermediateResource resource) {\n\t\tPrototypeLoadDialog dlg = new PrototypeLoadDialog(resource);\n\t\t\n\t\t// start our query (remotely)\n\t\tresource.query();\t\t\n\t\t\n\t\tdlg.setVisible(true);\n\t\t\n\t\tif(!dlg.isSuccessful()) {\n\t\t\tJOptionPane.showMessageDialog(this, \"Could not create: \" + dlg.getFailException(), \n\t\t\t\t\t\"Failed to create\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t\telse\t\t\t\t\n\t\t\tsucceeded = true;\n\n\t\treturn succeeded;\n\t}\n",
    "101901": "\tpublic boolean didSucceed() {\n\t\treturn succeeded;\n\t}\n",
    "101902": "\tprotected void setFieldValidateButtons(JTextField field) {\n\t\tfield.getDocument().addDocumentListener(new DocumentListener() {\n\t\t\tpublic void changedUpdate(DocumentEvent e) {\n\t\t\t\t// hello stupid bug.. this isn't used on JTextFields for some awful reason\n\t\t\t}\n\n\t\t\tpublic void removeUpdate(DocumentEvent e) {\n\t\t\t\tvalidateForm();\n\t\t\t}\n\n\t\t\tpublic void insertUpdate(DocumentEvent e) {\n\t\t\t\tvalidateForm();\n\t\t\t}\n\t\t});\n\t}\n",
    "101908": "\tpublic String getLocalName() {\n\t\treturn null;\n\t}\n",
    "101909": "\tpublic void commit() {\n\t\tSystem.out.println(\"Commit not yet implemented :(\");\n\t}\n",
    "101913": "\tprotected void notifyWizard() {\n\t\tif(wizardToNotify != null)\n\t\t\twizardToNotify.notifyChildFormStateChanged();\n\t}\n",
    "101918": "    public boolean isSelectedElement(Element e) {\n    \treturn selectedElements.contains(e);\n    }\n",
    "101922": "\tpublic void setUpdateObject(OBJT obj) {\n\t\tif(obj instanceof TridasEntityBase) {\n\t\t\tif(((TridasEntityBase) obj).isNew())\n\t\t\t\tthrow new IllegalArgumentException(\"Trying to create an update dialog for a new resource!\");\n\t\t}\n\t\t\n\t\tupdatingObject = obj;\n\t}\n",
    "101924": "\tprotected void assimilateUpdateObject(OBJT obj) {\n\t\tif(updatingObject == null)\n\t\t\treturn;\n\t\t\n\t\t((TridasEntityBase) obj).assimilateIntermediateObject((TridasEntityBase) updatingObject);\n\t}\n",
    "101926": "\tprotected void validateForm() {\n\t\t\n\t}\n",
    "101929": "    public void setMinimumSelectedElements(int value) {\n    \tminimumSelectedElements = value;\n    }\n",
    "101935": "    public void selectSiteByCode(String code) {\n    \tTridasObjectEx site = App.tridasObjects.findObjectBySiteCode(code);\n    \t\n    \tif(site != null)\n    \t\tlstSites.setSelectedValue(site, true);\n    }\n",
    "101945": "    public JPanel getExtraButtonPanel() {\n    \treturn extraButtonPanel;\n    }\n",
    "101960": "    public Object getDefaultsForClass(Class<?> clazz) {\n    \treturn defaultsMap.get(clazz);\n    }\n",
    "101975": "\t\tprivate void showSearchLabel(boolean shouldShow) {\n\t\t\tif (shouldShow == false) {\n\t\t\t\tsearchInfoLabel.setVisible(false);\n\t\t\t\tgetLayeredPane().remove(searchInfoLabel);\n\t\t\t\tgetLayeredPane().validate();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPoint workPt = workArea.getLocation();\n\t\t\tworkPt = SwingUtilities.convertPoint(workArea, workPt, null);\n\t\t\tsearchInfoLabel.setBounds(workPt.x, workPt.y, workArea.getWidth(), 100);\n\t\t\tsearchInfoLabel.setVisible(true);\n\n\t\t\tgetLayeredPane().add(searchInfoLabel,\n\t\t\t\t\tnew Integer(JLayeredPane.POPUP_LAYER - 1), 0);\n\t\t\tgetLayeredPane().validate();\n\t\t}\n",
    "102153": "\tpublic String getSeriesName() {\n\t\treturn seriesName.getText();\n\t}\n",
    "102160": "\tpublic boolean testAndComplainRequired(EnumSet<Fields> valuesRequired) {\n\t\tif(valuesRequired.contains(Fields.NAME) && !hasSeriesName()) {\n\t\t\tcomplain(I18n.getText(\"general.seriesCode\"));\n\t\t\tseriesName.requestFocusInWindow();\n\t\t\treturn false;\n\t\t}\n\n\t\tif(valuesRequired.contains(Fields.VERSION) && !hasVersion()) {\n\t\t\tcomplain(I18n.getText(\"general.version\"));\n\t\t\tversionName.requestFocusInWindow();\n\t\t\treturn false;\n\t\t}\n\n\t\tif(valuesRequired.contains(Fields.JUSTIFICATION) && !hasJustification()) {\n\t\t\tcomplain(I18n.getText(\"general.justification\"));\n\t\t\tjustification.requestFocusInWindow();\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "102238": "\tpublic void perform(Object source) {\n\t\tActionEvent ae = new ActionEvent(source == null ? this : source,\n\t\t\t\tActionEvent.ACTION_PERFORMED,\n\t\t\t\t(String) getValue(Action.ACTION_COMMAND_KEY));\n\t\tactionPerformed(ae);\n\t}\n",
    "102239": "\tprotected void selectionStateChanged(boolean newSelectedState) {\n\t\t// by default, we don't care :)\n\t}\n",
    "102240": "\tpublic void connectToggleableButton(AbstractButton button, Boolean defaultValue) {\n\t\tif(buttonAdapters == null)\n\t\t\tbuttonAdapters = new ArrayList<ButtonSelectionActionAdapter>();\n\t\t\n\t\tbuttonAdapters.add(new ButtonSelectionActionAdapter(button, defaultValue));\n\t}\n",
    "102242": "\tpublic void connectToggleableButton(AbstractButton button) {\n\t\tconnectToggleableButton(button, null);\n\t}\n",
    "102262": "\tpublic void setScoreClass(Class<?> clazz) {\n\t\tshownCrossdateClass = clazz;\n\n\t\t// update the cross\n\t\tif(pairing != null)  {\t\t\t\n\t\t\tcross = pairing.getCrossForClass(clazz);\n\t\t\tif(cross != null)\n\t\t\t\tupdateTable();\n\t\t}\n\t\t\n\t\tfireTableDataChanged();\n\t}\n",
    "102264": "    private ElementList showOpenDialog(Frame parent, boolean modal, ElementList preexistingElements) {\n    \tDBBrowser dbb = new DBBrowser(parent, modal, true) {\n\t\t\t@Override\n\t\t\tprotected boolean finish() {\n\t\t\t\treturn (loadAllElements() && super.finish());\n\t\t\t}\n\t\t};\n\t\t\n\t\treturn doOpenDialog(dbb, preexistingElements);\n    }\n",
    "102271": "\tpublic int getFullestBucket() {\n\t\t// computed lazily; -1 means \"not computed\"\n\t\t// (because no bucket can contain -1 things, of course)\n\t\tif (fullest == -1) {\n\t\t\tfor (int i = 0; i < buckets.length; i++)\n\t\t\t\tfullest = Math.max(fullest, buckets[i]);\n\t\t}\n\t\treturn fullest;\n\t}\n",
    "102273": "\tpublic int getNumberOfBuckets() {\n\t\treturn buckets.length;\n\t}\n",
    "102274": "\tpublic String getBucketRange(int bucket) {\n\t\t// build memo, if necessary\n\t\tif (memo == null)\n\t\t\tmemo = new String[buckets.length];\n\n\t\t// compute result for cache, if necessary\n\t\tif (memo[bucket] == null) {\n\t\t\tboolean isInfty = (hasInfty && bucket == buckets.length - 1);\n\t\t\tfloat a = low + step * bucket;\n\t\t\tfloat b = (isInfty ? Float.POSITIVE_INFINITY : low + step\n\t\t\t\t\t* (bucket + 1));\n\t\t\tmemo[bucket] = format.format(a) + \" - \" + format.format(b);\n\t\t\t// \"-\" should really be \"\\u2014\",\n\t\t\t// but my printer can't handle that yet,\n\t\t\t// so yours likely can't, either. :-(\n\t\t}\n\n\t\t// return it\n\t\treturn memo[bucket];\n\t}\n",
    "102275": "\tpublic float getBucketMin(int bucket) {\n\t\treturn low + step * bucket;\n\t}\n",
    "102276": "\tpublic int getBucketItems(int bucket) {\n\t\treturn buckets[bucket];\n\t}\n",
    "102278": "\tpublic String getName() {\n\t\treturn I18n.getText(\"statistics.tscore\");\n\t}\n",
    "102279": "\tpublic String getFormat() {\n\t\treturn App.prefs.getPref(\"corina.cross.tscore.format\", \"0.00\");\n\t}\n",
    "102291": "\tpublic Pairing getPairing(int row, int col) throws NoSuchPairingException {\n\t\tPairing pairing = pairings.get(keyForRowCol(row, col));\n\t\t\n\t\tif(pairing == null)\n\t\t\tthrow new NoSuchPairingException(row, col);\n\t\t\n\t\treturn pairing;\n\t}\n",
    "102297": "\tprivate Pairing findPairing(Pairing pairing) {\n\t\tfor(Pairing p : pairings.values())\n\t\t\tif(p.equals(pairing))\n\t\t\t\treturn p;\n\t\t\n\t\treturn null;\n\t}\n",
    "102301": "\tpublic ElementList getAllFixed() {\n\t\treturn fixed; // FIXME: exposes internal representation!\n\t}\n",
    "102302": "\tpublic ElementList getAllMoving() {\n\t\treturn moving; // FIXME: exposes internal representation!\n\t}\n",
    "102310": "\tpublic Cross makeCross() throws IOException, IllegalArgumentException {\n\t\treturn Cross.makeCross(algorithms[crossNr], getFixed(), getMoving());\n\t\t// (PERF: this is inefficient for the d-score, but not\n\t\t// horrible.  the i/o problem is much worse than the extra\n\t\t// computation time.)\n\t}\n",
    "102311": "\tpublic void setAlgorithms(String algorithms[]) {\n\t\t// make copy\n\t\tint n = algorithms.length;\n\t\tthis.algorithms = new String[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tthis.algorithms[i] = algorithms[i];\n\t}\n",
    "102312": "\tpublic void nextPairing() {\n\t\tif (crossNr < algorithms.length - 1) {\n\t\t\tcrossNr++;\n\t\t} else if (pairingNr < pairings.size() - 1) {\n\t\t\tpairingNr++;\n\t\t\tcrossNr = 0;\n\t\t}\n\t}\n",
    "102314": "\tpublic void prevPairing() {\n\t\tif (crossNr > 0) {\n\t\t\tcrossNr--;\n\t\t} else if (pairingNr > 0) {\n\t\t\tpairingNr--;\n\t\t\tcrossNr = algorithms.length - 1;\n\t\t}\n\t}\n",
    "102315": "\tpublic boolean isFirst() {\n\t\treturn (pairingNr == 0 && crossNr == 0);\n\t}\n",
    "102318": "\tpublic boolean isLast() {\n\t\treturn (pairingNr == pairings.size() - 1 && crossNr == algorithms.length - 1);\n\t}\n",
    "102353": "\tpublic Pageable print(PageFormat pageFormat) {\n\t\treturn grid.makeHardcopy(pageFormat);\n\t}\n",
    "102376": "\tpublic void graphChanged(GrapherEvent evt) {\n\t\tif(evt.getEventType() == GrapherEvent.Type.XOFFSET_CHANGED) {\n\t\t\tif(graphSamples.size() == 2)\n\t\t\t\tstatus.setMovingRange(graphSamples.get(1).getRange());\n\t\t}\n\t}\n",
    "102412": "\tpublic Printable print() {\n\t\treturn table.print();\n\t}\n",
    "102436": "    public void setCrossdate(Cross crossdate) {\n\tthis.crossdate = crossdate;\n\n\tupdateTable();\n    }\n",
    "102445": "\tpublic int size() {\n\t\treturn num;\n\t}\n",
    "102447": "\tpublic Cell getCell(int row, int column) {\n\t\t// (cells are immutable, so this is safe.)\n\t\treturn cell[row][column];\n\t}\n",
    "102454": "\tpublic Exception getError() {\n\t\treturn error;\n\t}\n",
    "102457": "\tpublic Preview getPreview() {\n\t\treturn new GridPreview(this);\n\t}\n",
    "102549": "  public void graphSelectedCrossdate() {\n    // get the row\n    int row = table.getSelectedRow();\n\n    // get the year (== end-date of moving sample)\n    HighScore score = (HighScore) crossdate.getHighScores().getScores().get(row);\n    Year y = score.movingRange.getEnd();\n\n    // new cross at this offset\n    new GraphWindow(crossdate, y);\n  }\n",
    "102598": "    public void graphSelectedCrossdate() {\n\t// get the (row,col) of the click\n\tint row = table.getSelectedRow();\n\tint col = table.getSelectedColumn();\n\n\t// get the year (== end-date of moving sample)\n\tYear y = ((ScoresTableModel) table.getModel()).getYear(row, col);\n\n\t// blank spot (TODO: better to just look for empty cell?)\n\tif (!crossdate.getRange().contains(y))\n\t    return;\n\tif (col == 0)\n\t    return;\n\tif ((row + crossdate.getRange().getStart().row() == 0) && (col == 1))\n\t    return;\n\n\t// new graph at this place\n\tnew GraphWindow(crossdate, y);\n    }\n",
    "102611": "\tpublic Float getScoreAt(int row, int col) {\n\t\t// for the year column\n\t\tif (col == 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// check for year zero\n\t\t\tif ((row + row_min == 0) && (col == 1))\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tYear year = getYear(row, col);\n\n\t\t\tif (cross.getRange().contains(year))\n\t\t\t\treturn cross.getScore(year);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t}\n",
    "102613": "\tpublic Range getSecondaryRangeForCell(int row, int col) {\n\t\tif(col == 0)\n\t\t\treturn null; // nothing in this column\n\t\t\n\t\t// check for year zero\n\t\tif ((row + row_min == 0) && (col == 1))\n\t\t\treturn null;\n\n\t\t// I think the logic behind this makes sense... but it makes my head hurt\n\t\tYear year = getYear(row, col);\n\t\t// essentially, redate the moving's end to the year in this row,col\n\t\treturn cross.getMoving().getRange().redateEndTo(year);\n\t}\n",
    "102615": "\tpublic Sample getSecondaryForCell(int row, int col) {\n\t\tRange newRange = getSecondaryRangeForCell(row, col);\n\t\t\n\t\tif(newRange == null)\n\t\t\treturn null;\n\t\t\n\t\tSample redate = new Sample();\n\t\t\n\t\tSample.copy(pairing.getSecondary(), redate);\n\t\tredate.setRange(newRange);\n\t\t\n\t\treturn redate;\n\t}\n",
    "102620": "\tpublic Integer getOverlapAt(Range newRange) {\n\t\treturn (newRange == null) ? null : newRange.overlap(cross.getFixed().getRange());\t\t\n\t}\n",
    "102637": "\tpublic String getName() {\n\t\treturn I18n.getText(\"statistics.rvalue\");\n\t}\n",
    "102639": "\tpublic String getFormat() {\n\t\treturn App.prefs.getPref(\"corina.cross.rvalue.format\", \"0.00\");\n\t}\n",
    "102645": "\tprivate float mean(float array[]) {\n\t\t// (/ (reduce '+ array) (length array))\n\t\tfloat s = 0.0f;\n\t\tfor (int i = 0; i < array.length; i++)\n\t\t\ts += array[i];\n\t\treturn s / array.length;\n\n\t\t// what if array.length==0? -- only happens if one sample has no data (possible?)\n\t}\n",
    "102658": "\tprotected float getScore(int index) {\n\t\treturn data[index];\n\t}\n",
    "102662": "\tpublic float getScore(Year year) {\n\t\tint index = year.diff(range.getStart());\n\t\treturn data[index];\n\t}\n",
    "102665": "\tpublic int getScoreSignifigance(Year year) {\n\t\tint index = year.diff(range.getStart());\n\t\treturn signifigance[index];\n\t}\n",
    "102671": "\tpublic Sample getFixed() {\n\t\treturn fixed;\n\t}\n",
    "102674": "\tpublic Sample getMoving() {\n\t\treturn moving;\n\t}\n",
    "102677": "\tpublic boolean isFinished() {\n\t\treturn finished;\n\t}\n",
    "102692": "\tprotected void preamble() {\n\t\t// nothing need be done by default\n\n\t\t// DELETE ME!\n\t}\n",
    "102701": "\tpublic Sample getSecondaryForRow(int row) {\n\t\tif(row < 0 || row > getRowCount())\n\t\t\treturn null;\n\n\t\tSample redate = new Sample();\n\n\t\tSample.copy(pairing.getSecondary(), redate);\n\t\tredate.setRange(scores.get(row).range);\n\t\t\n\t\treturn redate;\n\t}\n",
    "102703": "\tpublic Range getSecondaryRangeForRow(int row) {\n\t\tif(row < 0 || row > getRowCount())\n\t\t\treturn null;\n\n\t\treturn new Range(scores.get(row).range.getStart(), scores.get(row).range.getEnd());\n\t}\t\n",
    "102769": "    public void save(Sample sample) throws SQLException {\n\tconnection.setAutoCommit(false);\n\n\tsaveSample(sample);\n\n\tconnection.commit();\n\tconnection.setAutoCommit(true);\n    }\n",
    "102773": "    public void dump(String folder) throws SQLException {\n\t// connection.setAutoCommit(false);\n\n\tFile f = new File(folder);\n\n\tif (f.isDirectory()) {\n\t    importFolder(f);\n\t} else {\n\t    importFile(f);\n\t}\n\n\t// connection.commit();\n\t// connection.setAutoCommit(true);\n    }\n",
    "102828": "    public XMLBody setPretty(boolean pretty) {\n    \tthis.pretty = pretty;\n    \t\n    \treturn this;\n    }\n",
    "102907": "\tpublic PageFormat getPageFormat() {\n\t\treturn pageFormat;\n\t}\n",
    "102909": "\tpublic void setPageFormat(PageFormat pageFormat) {\n\t\tthis.pageFormat = pageFormat;\n\t}\n",
    "102910": "\tpublic void setPageOrientation(int orientation) {\n\t\tpageFormat.setOrientation(orientation);\n\t}\n",
    "102913": "\tpublic void print(boolean showDialog) throws PrinterException {\n\t\tif(!showDialog || printJob.printDialog()) {\n\t\t\t// set the minimum margins for this paper (java defaults to 1\"... wtf?)\n\t\t\tpageFormat = minimumMarginsFormat(pageFormat);\n\t\t\t\n\t\t\tprintJob.print();\n\t\t}\n\t}\n",
    "102966": "    @Override\n\tpublic void mousePressed(MouseEvent e) { // mac\n\tmaybeShowPopup(e);\n    }\n",
    "102967": "    @Override\n\tpublic void mouseReleased(MouseEvent e) { // win32\n\tmaybeShowPopup(e);\n    }\n",
    "102971": "    public void showPopup(MouseEvent e) {\n\t// if table, and this row not selected, select this row\n\tif (e.getSource() instanceof JTable) {\n\t    JTable table = (JTable) e.getSource();\n\t    int row = table.rowAtPoint(e.getPoint());\n\t    if (row!=-1 && !table.isRowSelected(row))\n\t\ttable.setRowSelectionInterval(row, row);\n\t}\n\n\t// show popup\n\tif (popup != null)\n\t    popup.show(e.getComponent(), e.getX(), e.getY());\n    }\n",
    "102997": "    public void changedUpdate(DocumentEvent e) {\n\tupdate(e);\n    }\n",
    "102999": "    public void insertUpdate(DocumentEvent e) {\n\tupdate(e);\n    }\n",
    "103001": "    public void removeUpdate(DocumentEvent e) {\n\tupdate(e);\n    }\n",
    "103011": "\tpublic void replaceContents(Collection<? extends E> c) {\n\t\tif(!isEmpty())\n\t\t\tclear();\n\t\taddAll(c);\n\t}\n",
    "103018": "\tpublic String getFilename() {\n\t\tString fn = (String) s.getMeta(\"filename\");\n\t\tArrayList<String> segments = new ArrayList<String>();\n\t\tFile f = new File(fn);\n\t\tint depth = 0;\n\t\t\n\t\tfn = f.getName();\n\t\tdo {\n\t\t\tsegments.add(fn);\n\t\t\t\n\t\t\tf = f.getParentFile();\n\t\t\tfn = f.getName();\n\t\t\tdepth++;\n\t\t} while((fn.length() == 3 || fn.equalsIgnoreCase(\"forest\") || depth == 1) && fn.toLowerCase().indexOf(\"data\") == -1);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i = segments.size() - 1; i >= 0; i--) {\n\t\t\tif(sb.length() != 0)\n\t\t\t\tsb.append(File.separator);\n\t\t\tsb.append(segments.get(i));\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n",
    "103029": "\tpublic String toString() {\n\t\ttry {\n\t\t\tTransformer xformer = TransformerFactory.newInstance().newTransformer();\n\t\t\tDOMSource source = new DOMSource(domElement);\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tStreamResult result = new StreamResult(sw);\n\t\t\t\n\t\t\txformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, showXmlDeclaration ? \"no\" : \"yes\");\n\t\t\txformer.setOutputProperty(OutputKeys.INDENT, pretty ? \"yes\" : \"no\");\n\t\t\t\n\t\t\txformer.transform(source, result);\n\t\t\t\n\t\t\treturn sw.toString();\n\t\t} catch (Exception e) {\n\t\t\treturn \"<error: \" + e.getMessage() + \" >\";\n\t\t}\n\t}\n",
    "103033": "\tpublic Object getElementAt(int index) {\n\t\treturn this.get(index);\n\t}\n",
    "103035": "\tpublic int getSize() {\n\t\treturn this.size();\n\t}\n",
    "103038": "\tpublic void addListDataListener(ListDataListener listener) {\n\t\tif (listDataListeners == null) {\n\t\t\tlistDataListeners = new ArrayList<ListDataListener>();\n\t\t}\n\t\tif (!listDataListeners.contains(listener)) {\n\t\t\tlistDataListeners.add(listener);\n\t\t}\n\t}\n",
    "103041": "\tpublic void removeListDataListener(ListDataListener listener) {\n\t\tif (listDataListeners != null) {\n\t\t\tlistDataListeners.remove(listener);\n\t\t}\n\t}\n",
    "103043": "\tpublic String toString() {\n\t\treturn bug.toString();\n\t}\n",
    "103054": "    public int compare(Object o1, Object o2) {\n\treturn compare((String) o1, (String) o2);\n    }\n",
    "103093": "    @Override\n\tpublic void write(char[] cbuf, int off, int len) {        \n        for (int i=off; i<off+len; i++) {\n            char c = cbuf[i];\n            if (c != '\\r')\n                super.write(c);\n        }\n    }\n",
    "103096": "    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n",
    "103101": "    public void debug(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_DEBUG)) {\n            log(SimpleLog.LOG_LEVEL_DEBUG, message, null);\n        }\n    }\n",
    "103108": "    public void debug(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_DEBUG)) {\n            log(SimpleLog.LOG_LEVEL_DEBUG, message, t);\n        }\n    }\n",
    "103109": "\tpublic Year getStart() {\n\t\treturn start;\n\t}\n",
    "103110": "\tpublic Year getEnd() {\n\t\treturn end;\n\t}\n",
    "103111": "    public void trace(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_TRACE)) {\n            log(SimpleLog.LOG_LEVEL_TRACE, message, null);\n        }\n    }\n",
    "103112": "\tpublic Range redateStartTo(Year y) {\n\t\treturn redateBy(y.diff(start));\n\t}\n",
    "103113": "\tpublic Range redateBy(int dy) {\n\t\treturn new Range(start.add(dy), end.add(dy));\n\t}\n",
    "103114": "    public void trace(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_TRACE)) {\n            log(SimpleLog.LOG_LEVEL_TRACE, message, t);\n        }\n    }\n",
    "103116": "\tpublic int span() {\n\t\treturn end.diff(start) + 1;\n\t}\n",
    "103118": "    public void info(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {\n            log(SimpleLog.LOG_LEVEL_INFO,message,null);\n        }\n    }\n",
    "103119": "\tpublic int rows() {\n\t\treturn getEnd().row() - getStart().row() + 1;\n\t}\n",
    "103121": "    public void info(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {\n            log(SimpleLog.LOG_LEVEL_INFO, message, t);\n        }\n    }\n",
    "103122": "\tpublic String toStringWithSpan() {\n\t\treturn \"(\" + start + \" - \" + end + \", n=\" + span() + \")\";\n\t\t// use \\u2014 EM DASH?\n\t}\n",
    "103123": "    public void warn(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_WARN)) {\n            log(SimpleLog.LOG_LEVEL_WARN, message, null);\n        }\n    }\n",
    "103124": "\tpublic boolean contains(Year y) {\n\t\treturn (start.compareTo(y) <= 0) && (y.compareTo(end) <= 0);\n\t}\n",
    "103125": "\tpublic boolean contains(Range r) {\n\t\treturn contains(r.start) && contains(r.end);\n\t}\n",
    "103126": "    public void warn(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_WARN)) {\n            log(SimpleLog.LOG_LEVEL_WARN, message, t);\n        }\n    }\n",
    "103127": "\tpublic boolean startOfRow(Year y) {\n\t\treturn y.equals(start) || y.column() == 0 || y.isYearOne();\n\t}\n",
    "103129": "\tpublic boolean endOfRow(Year y) {\n\t\treturn y.equals(end) || y.column() == 9;\n\t}\n",
    "103130": "    public void error(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_ERROR)) {\n            log(SimpleLog.LOG_LEVEL_ERROR, message, null);\n        }\n    }\n",
    "103131": "\tpublic int overlap(Range r) {\n\t\treturn intersection(r).span();\n\t}\n",
    "103133": "\tpublic Range intersection(Range r) {\n\t\treturn new Range(Year.max(start, r.start), Year.min(end, r.end));\n\t}\n",
    "103134": "\tpublic Range union(Range r) {\n\t\treturn new Range(Year.min(start, r.start), Year.max(end, r.end));\n\t}\n",
    "103135": "    public void error(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_ERROR)) {\n            log(SimpleLog.LOG_LEVEL_ERROR, message, t);\n        }\n    }\n",
    "103138": "    public void fatal(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_FATAL)) {\n            log(SimpleLog.LOG_LEVEL_FATAL, message, null);\n        }\n    }\n",
    "103139": "\tpublic int compareTo(Range r2) {\n\n\t\tint c1 = end.compareTo(r2.end);\n\t\tif (c1 != 0)\n\t\t\treturn c1;\n\n\t\t// negative, because fallback puts longest samples first\n\t\tint c2 = -start.compareTo(r2.start);\n\t\treturn c2;\n\t}\n",
    "103141": "    public void fatal(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_FATAL)) {\n            log(SimpleLog.LOG_LEVEL_FATAL, message, t);\n        }\n    }\n",
    "103156": "        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n",
    "103183": "        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n",
    "103194": "        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n",
    "103213": "\tpublic String saveSingleSample(Sample exportee, String format) {\n\t\t\n\t\t// use the default title...\t\t\n\t\tString title = I18n.getText(\"export\") + \" \" + exportee.getDisplayTitle();\n\t\t\n\t\treturn saveSingleSample(exportee, format, title);\n\t}\n",
    "103221": "\tpublic String savePackedSample(List slist, String format) {\n\t\treturn savePackedSample(slist, format, I18n.getText(\"export\"));\n\t}\n",
    "103232": "\tpublic List saveMultiSample(List slist, String format) {\n\t\treturn saveMultiSample(slist, format, \"Choose an Export Folder\");\n\t}\n",
    "103334": "\tpublic void scaleToFitHeight() {\n\t\tscaleToFitHeight(1);\n\t}\n",
    "103346": "\tpublic void setDefault() {\n\t\tGraphPrefs.PLOT_AGENT.set(this);\n\t}\n",
    "103347": "\tpublic String getI18nTag() \n\t{\t\t\n\t\tif(this.toString().equals(PlotAgent.SEMILOG.toString())) return \"graph.agent_semilog\";\n\t\telse if (this.toString().equals(PlotAgent.STANDARD.toString()))\treturn \"graph.agent_standard\";\n\t\telse if (this.toString().equals(PlotAgent.TOOTHED.toString())) return \"graph.agent_toothed\";\n\t\telse return null;\n\t\t\n\t}\n",
    "103425": "    public void setAgent(PlotAgent agent) { \n    \tif(canChangeAgent)\n    \t\tgraphAgent = agent; \n    }\n",
    "103430": "    public void setHighlighted(boolean highlighted) {\n    \tthis.highlighted = highlighted;\n    }\n",
    "103432": "    public boolean isHighlighted() {\n    \treturn highlighted;\n    }\n",
    "103433": "    public CorinaGraphPlotter getPlotter() {\n    \treturn graphAgent.getPlotter();\n    }\n",
    "103445": "\tpublic GraphInfo getPrinter() {\n\t\treturn new GraphInfo(this, true);\n\t}\n",
    "103448": "\tpublic void resetColors() {\n\t\tif (!printing) {\n\t\t\tbackgroundColor = GraphPrefs.BACKGROUND.get();\n\t\t\tforeColor = GraphPrefs.FOREGROUND.get();\n\t\t\tmajorLineColor = GraphPrefs.MAJOR_LINE.get();\n\t\t\tminorLineColor = ColorUtils.blend(majorLineColor, backgroundColor);\n\t\t\tmidLineColor = ColorUtils.blend(majorLineColor, minorLineColor);\n\t\t} else {\n\t\t\tbackgroundColor = GraphPrefs.BACKGROUND_PRINT.get();\n\t\t\tforeColor = GraphPrefs.FOREGROUND_PRINT.get();\n\t\t\tmajorLineColor = GraphPrefs.MAJOR_LINE_PRINT.get();\n\t\t\tminorLineColor = ColorUtils.blend(majorLineColor, backgroundColor);\n\t\t\tmidLineColor = ColorUtils.blend(majorLineColor, minorLineColor);\t\t\t\n\t\t}\n\t}\n",
    "103498": "\tpublic Graph getGraph() {\n\t\treturn graph;\n\t}\n",
    "103500": "\tpublic Type getEventType() {\n\t\treturn eventType;\n\t}\n",
    "103552": "\tpublic int getGraphHeight(JPanel panel) {\n\t\treturn printing ? this.printHeight : panel.getHeight();\n\t}\n",
    "103668": "    private void compute() {\n        // i put this in run(), so it could be threaded, but is it worth it?\n        // -- for 100yr sample x 10 indexes, 900mhz athlon: 30-40ms.\n        // so no, it's probably not worth it.\n        // TODO: put this in the constructor.\n        for (int i=0; i<indexes.size(); i++)\n            (indexes.get(i)).run();\n    }\n",
    "103691": "\tprivate void legacyApplyIndex(Index index) {\n\t\tindex.apply();\n\n\t\t// undo (index implements undoable)\n\t\tsample.postEdit(index);\n\n\t\t// also: clear filename, set modified\n\t\tsample.setModified();\n\t\tsample.removeMeta(\"filename\"); // BUG: this should be in\n\t\t\t\t\t\t\t\t\t\t// Index.apply()\n\t\t// (otherwise undo doesn't put the filename back)\n\n\t\t// tell editor, and close\n\t\tsample.fireSampleDataChanged();\n\t\tsample.fireSampleMetadataChanged();\t\t\n\t}\n",
    "103716": "\tpublic String getName() {\n\t\tString tag = ixFunction.getI18nTag();\n\t\tString trailer = ixFunction.getI18nTagTrailer();\n\t\t\n\t\tif(trailer == null)\n\t\t\treturn I18n.getText(tag);\n\t\t\n\t\treturn MessageFormat.format(I18n.getText(tag),\n\t\t\t\tnew Object[] { trailer });\n\t\t/*\n\t\tString fqdn = getClass().getName();\n\t\tint dotIndex = fqdn.lastIndexOf(\".\");\n\t\treturn fqdn.substring(dotIndex + 1);\n\t\t*/\n\t}\n",
    "103779": "\tpublic boolean isList() {\n\t\treturn hasSetValues;\n\t}\n",
    "103833": "\tpublic void setMasterList(List<? extends Number> masterList) {\n\t\tif(masterList == null)\n\t\t\tthrow new NullPointerException();\n\t\t\n\t\tthis.masterList = masterList;\n\t}\n",
    "103835": "\tpublic void setData(List<Number> in) {\n\t\tdata = (in != null) ? new HookableNumericArrayList<Number>(this, in)\n\t\t\t\t: new HookableNumericArrayList<Number>(this);\n\t\tvalues.clear();\n\n\t\tfor (int i = 0, len = values.size(); i < len; i++) {\n\t\t\tTridasValue value = new TridasValue();\n\n\t\t\tvalue.setValue(data.get(i).toString());\n\t\t\t//value.setIndex(Integer.toString(i));\n\n\t\t\tvalues.add(value);\n\t\t}\n\n\t\tif (usesCounts) {\n\t\t\tcount.setMasterList(data);\n\t\t\tcheckCountsValid();\n\n\t\t\tif (countsValid)\n\t\t\t\tcopyOverCounts();\n\t\t}\n\t}\n",
    "103838": "\tpublic void setCount(List<Integer> in) {\n\t\tif(!usesCounts) {\n\t\t\tif(in == null || in.isEmpty())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tfor(int i = 0, len = in.size(); i < len; i++) {\n\t\t\t\tInteger v = in.get(i);\n\t\t\t\t\n\t\t\t\tif(v != null && v != 1) \n\t\t\t\t\tthrow new IllegalArgumentException(\"Counts contains a non-trival count\");\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcount = (in != null) ? new HookableCountArrayList(this, in, data)\n\t\t\t\t: new HookableCountArrayList(this, data);\n\t\tcheckCountsValid();\n\t\t\n\t\tif(countsValid)\n\t\t\tcopyOverCounts();\n\t\telse\n\t\t\tclearCounts();\n\t}\n",
    "103839": "\tprotected int actualSize() {\n\t\treturn super.size();\n\t}\n",
    "103840": "\tprotected boolean actualIsEmpty() {\n\t\treturn super.isEmpty();\n\t}\n",
    "103857": "\tprivate String wjForIndex(int index) {\n\t\treturn incr.get(index) + \"/\" + decr.get(index);\n\t}\n",
    "103863": "\tprivate void recursiveAdd(TridasObjectEx obj, ListViews view) {\n\t\tview.allObjects.add(obj);\n\t\tview.bySiteCode.put(obj.getLabCode(), obj);\n\t\t\n\t\tif(obj.hasChildren()) {\n\t\t\tfor(TridasObjectEx child : ListUtil.subListOfType(obj.getObjects(), TridasObjectEx.class))\n\t\t\t\trecursiveAdd(child, view);\n\t\t}\n\t}\n",
    "103868": "\tpublic TridasObjectEx findObjectBySiteCode(String siteCode) {\n\t\tsynchronized(data) {\n\t\t\treturn data.bySiteCode.get(siteCode);\n\t\t}\n\t}\n",
    "103884": "\tprivate String getKey(ITridas parentObject) {\n\t\tXmlRootElement root = parentObject.getClass().getAnnotation(XmlRootElement.class);\n\t\tTridasIdentifier identifier = parentObject.getIdentifier();\n\t\t\t\n\t\tif(root != null)\n\t\t\treturn root.name() + \":\" + identifier.toString();\n\t\telse\n\t\t\treturn parentObject.getClass().getName() + \":\" + identifier.toString();\n\t}\n",
    "103891": "\tpublic void replaceChildProperty(TridasEntityProperty oldProp, TridasEntityProperty newProp) {\n\t\tint nProps = childProperties.size();\n\t\tfor(int i = 0; i < nProps; i++) {\n\t\t\tif(childProperties.get(i) == oldProp)\n\t\t\t\tchildProperties.set(i, newProp);\n\t\t}\n\t}\n",
    "103897": "\tprivate void selectNull() {\n\t\tTridasLocationGeometry oldGeometry = geometry;\n\t\tlabel.setValue(null);\n\t\tgeometry = null;\n\t\t\n\t\tfirePropertyChange(oldGeometry, geometry);\n\t}\n",
    "103899": "\tprivate void selectGeometry() {\n\t\tTridasLocationGeometry oldGeometry = geometry;\n\t\tLocationGeometry dialog = new LocationGeometry();\n\t\t\n\t\t// show the dialog...\n\t\tdialog.showDialog(SwingUtilities.getWindowAncestor(editor), geometry);\n\t\t\n\t\t// cancelled...\n\t\tif(!dialog.hasResults())\n\t\t\treturn;\n\t\t\n\t\tgeometry = dialog.getGeometry();\n\t\tlabel.setValue(geometry);\n\t\tfirePropertyChange(oldGeometry, geometry);\n\t}\n",
    "103918": "\tpublic boolean representsEnumType() {\n\t\treturn clazz.isEnum();\n\t}\n",
    "103948": "\tpublic void setType(Class<?> clazz, Field field) {\n\t\tthis.clazz = clazz;\t\t\n\t}\n",
    "103956": "\tpublic void writeToObject(Object object) {\n\t\ttry {\n\t\t\tMethod method = BeanUtils.getWriteMethod(object.getClass(),\n\t\t\t\t\tgetName(), getType());\n\t\t\tif (method != null) {\n\t\t\t\tmethod.invoke(object, new Object[] { getExternalTranslatedValue(getValue()) });\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n",
    "103964": "\tprotected Object getExternalTranslatedValue(Object value) {\n\t\treturn value;\n\t}\n",
    "103966": "\tprivate void cleanupPopup(boolean resetFilter) {\n\t\tif(isPopupShowing) {\n\t\t\tsearchPanel.setVisible(false);\n\t\t\tisPopupShowing = false;\n\t\t}\n\t\t\n\t\tif(resetFilter) {\n\t\t\tfilter.setFilterText(\"\");\n\t\t\tmodel.setFilter(filter);\n\t\t}\n\t}\n",
    "103967": "\tprotected Object getInternalTranslatedValue(Object value) {\n\t\treturn value;\n\t}\n",
    "103979": "\tpublic TridasLocationGeometry getGeometry() {\n\t\tif(!hasResults)\n\t\t\tthrow new IllegalStateException();\n\t\t\n\t\tTridasLocationGeometry geometry = new TridasLocationGeometry();\n\t\tPointType point = new PointType();\n\t\tgeometry.setPoint(point);\n\t\t\n\t\t// TODO: Actually implement detecting this and putting in the right standards\n\t\tpoint.setSrsName(\"EPSG:4326\");\n\t\t\n\t\tPos pos = new Pos();\n\t\tpoint.setPos(pos);\n\t\t\n\t\tpos.getValues().add(Double.valueOf(spnDDLong.getValue().toString()));\n\t\tpos.getValues().add(Double.valueOf(spnDDLat.getValue().toString()));\n\t\t\n\t\treturn geometry;\n\t}\n",
    "103981": "\tprivate void searchFieldChanged() {\n\t\tfilter.setFilterText(searchField.getText());\n\t\tmodel.setFilter(filter);\n\t}\n",
    "104003": "\tpublic void setEmptyGraphText(String emptyGraphText) {\n\t\tthis.emptyGraphText = emptyGraphText;\n\t}\n",
    "104014": "\tprivate void paintNoGraphs(Graphics g) {\n\t\tGraphics2D g2 = (Graphics2D) g;\n\n\t\tComposite oldComposite = g2.getComposite();\n\t\tFont oldFont = g2.getFont();\n\t\t\n\t\tg2.setColor(Color.blue.darker());\n\t\tg2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.4f));\n\t\tg2.setFont(g2.getFont().deriveFont(72.0f));\n\t\t\n\t\tint width = g2.getFontMetrics().stringWidth(emptyGraphText);\n\t\t\n\t\tfloat x = (float)((getWidth() / 2) - (width / 2)); \n\t\tfloat y = (float)(getHeight() / 2);\n\n\t\tg2.drawString(emptyGraphText, x, y);\n\t\t\n\t\tg2.setComposite(oldComposite);\n\t\tg2.setFont(oldFont);\n\t}\n",
    "104052": "\tpublic void clearSites() {\n\t\tthis.siteCodes.clear();\n\t\tthis.siteTitles.clear();\n\t}\n",
    "104054": "\tprivate ImageIcon scaleIcon20x20(ImageIcon icon) {\n\t\treturn new ImageIcon(icon.getImage().getScaledInstance(20, 20, Image.SCALE_SMOOTH));\n\t}\n",
    "104066": "\tprivate int compare(String o1, String o2) {\n\t\t// nicely handle nulls\n\t\tif (o1 == null && o2 == null)\n\t\t\treturn 0;\n\n\t\t// nulls go last\n\t\tif (o1 == null)\n\t\t\treturn 1;\n\t\tif (o2 == null)\n\t\t\treturn -1;\n\n\t\tInteger i1 = null, i2 = null;\n\t\ttry {\n\t\t\ti1 = Integer.valueOf(o1);\n\t\t} catch (NumberFormatException nfe) {\n\t\t}\n\t\t\n\t\ttry {\n\t\t\ti2 = Integer.valueOf(o2);\n\t\t} catch (NumberFormatException nfe) {\n\t\t}\n\n\t\t// both strings, string compare!\n\t\tif (i1 == null && i2 == null)\n\t\t\treturn o1.compareToIgnoreCase(o2);\n\n\t\t// strings go last\n\t\tif (i1 == null)\n\t\t\treturn 1;\n\t\tif (i2 == null)\n\t\t\treturn -1;\n\n\t\t// flat out integers!\n\t\treturn i1.compareTo(i2);\n\t}\n",
    "104073": "\tpublic boolean isTopLevelObject() {\n\t\treturn (parentObject == null);\n\t}\n",
    "104075": "\tpublic TridasObjectEx getParent() {\n\t\treturn parentObject;\n\t}\n",
    "104076": "\tpublic boolean hasChildren() {\n\t\treturn isSetObjects();\n\t}\n",
    "104077": "\tpublic boolean hasLabCode() {\n\t\treturn (labCode != null);\n\t}\n",
    "104081": "\tpublic void setPlotAgent(PlotAgent agent) {\n\t\tthis.plotAgent = agent;\n\t}\n",
    "104083": "\tpublic String toTitleString() {\n\t\tif(labCode == null || labCode.equals(title))\n\t\t\treturn title;\n\t\t\n\t\treturn \"[\" + labCode + \"] \" + title;\n\t}\n",
    "104101": "\tprotected PreprocessResult preprocessQuery(INTYPE object) throws ResourceException, UserCancelledException {\n\t\treturn PreprocessResult.SUCCESS;\n\t}\n",
    "104102": "\tprivate void doQuerySucceeded(INTYPE object) {\n\t\ttry {\n\t\t\t// Call our (potentially overridden) querySucceeded method\n\t\t\tquerySucceeded(object);\n\t\t} finally {\n\t\t\t// Notify listeners that everything went well\n\t\t\t// no matter what!\n\t\t\tfireResourceEvent(new ResourceEvent(this, ResourceEvent.RESOURCE_QUERY_COMPLETE, object));\n\t\t}\n\t}\n",
    "104103": "\tprivate void chooseOrCancelUIUpdate() {\n\t\t// disable/enable editing\n\t\teditEntity.setEnabled(!changingTop);\n\t\ttopChooser.setEnabled(changingTop);\n\t\tchangeButton.setText(changingTop ? OK_STATE : CHANGE_STATE);\n\t\tcancelChangeButton.setVisible(changingTop);\t\t\n\t}\n",
    "104104": "\tprivate void doQueryFailed(Exception e) {\n\t\ttry {\n\t\t\t// Call our (potentially overridden) queryFailed method\n\t\t\tqueryFailed(e);\n\t\t} finally {\t\n\t\t\t// Notify listeners that our query failed\n\t\t\t// No matter what!\n\t\t\tfireResourceEvent(new ResourceEvent(this, ResourceEvent.RESOURCE_QUERY_FAILED, e));\n\t\t}\n\t}\n",
    "104106": "\tprotected void querySucceeded(INTYPE object) {\n\t}\n",
    "104107": "\tprivate void changeButtonPressed() {\n\t\t\n\t\t// Make sure we populate our combobox with everything from the server\n\t\tpopulateComboAndSelect(true);\n\t\t\n\t\tif(topChooser.getSelectedItem() == EntityListComboBox.NEW_ITEM)\n\t\t\tpropertiesTable.setPreviewText(I18n.getText(\"general.choose\").toUpperCase());\n\t\telse\n\t\t\tpropertiesTable.setPreviewText(I18n.getText(\"general.preview\").toUpperCase());\n\t\tpropertiesTable.setPreviewing(true);\n\t\t\n\t\t// we're starting to change...\n\t\tchangingTop = true;\n\n\t\tchooseOrCancelUIUpdate();\n\t}\n",
    "104108": "\tprotected void queryFailed(Exception e) {\n\t\tSystem.err.println(\"Failed to query resource \" + resourceName);\n\t\te.printStackTrace();\n\t\t\n\t\tif(e instanceof ResourceException && e.getCause() != null) {\n\t\t\tSystem.err.println(\"Caused by:\");\n\t\t\te.getCause().printStackTrace();\n\t\t}\n\t}\n",
    "104109": "\tpublic void query() {\n\t\tqueryThread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tqueryWait();\n\t\t\t\t\n\t\t\t\tqueryThread = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tqueryThread.start();\n\t}\n",
    "104115": "\tprotected void populateNewEntity(EditType type, ITridas entity) {\n\t\tentity.setTitle(\"New \" + type.displayTitle);\n\t}\n",
    "104117": "\tpublic void setOwnerWindow(Window window) {\n\t\tthis.ownerWindow = window;\n\t}\n",
    "104119": "\tpublic Window getOwnerWindow() {\n\t\treturn this.ownerWindow;\n\t}\n",
    "104121": "\tpublic void setUseVerticalScrollbar(boolean useVerticalScrollbar) {\n\t\tthis.useVerticalScrollbar = useVerticalScrollbar;\n\t}\n",
    "104128": "\tpublic void setProperty(String propertyName, Object value) {\n\t\t// lazy-create properties\n\t\tif(properties == null) \n\t\t\tproperties = new HashMap<String, Object>();\n\t\t\n\t\tproperties.put(propertyName, value);\n\t}\n",
    "104130": "\tpublic void setProperties(Map<String, ? extends Object> newProperties) {\n\t\t// lazy-create properties\n\t\tif(properties == null) \n\t\t\tproperties = new HashMap<String, Object>();\n\t\t\n\t\tproperties.putAll(newProperties);\n\t}\n",
    "104132": "\tpublic boolean hasProperty(String propertyName) {\n\t\tif(properties == null)\n\t\t\treturn false;\n\t\t\n\t\treturn properties.containsKey(propertyName);\n\t}\n",
    "104133": "\tpublic void setValidateSchema(Schema schema) {\n\t\tthis.validateSchema = schema;\n\t}\n",
    "104141": "\tprotected void setAssociatedResult(T associatedResult) {\n\t\tthis.associatedResult = associatedResult;\n\t}\n",
    "104144": "\tpublic T getAssociatedResult() {\n\t\tif(associatedResult == null)\n\t\t\tthrow new IllegalStateException(\"getAssociatedResult() has a null result\");\n\t\t\n\t\treturn associatedResult;\n\t}\n",
    "104146": "\tprivate void sortList(List<? extends ITridas> list) {\n\t\t// Sort list intelligently\n\t\tTridasComparator numSorter = new TridasComparator(TridasComparator.Type.TITLES, \n\t\t\t\tTridasComparator.NullBehavior.NULLS_LAST, \n\t\t\t\tTridasComparator.CompareBehavior.AS_NUMBERS_THEN_STRINGS);\n\t\t\n\t\tCollections.sort(list, numSorter);\t\t\n\t}\n",
    "104160": "\tpublic int getNumericCode() {\n\t\treturn numericCode;\n\t}\n",
    "104162": "\tprotected ITridas getCreateOrUpdateEntity() {\n\t\treturn createOrUpdateEntity;\n\t}\n",
    "104164": "\tprivate ITridas entityInList(ITridas entity, List<?> list) {\n\t\tfor(Object o : list) {\n\t\t\tif(o instanceof ITridas) {\n\t\t\t\tITridas otherEntity = (ITridas) o;\n\t\t\t\t\n\t\t\t\tif(matchEntities(entity, otherEntity))\n\t\t\t\t\treturn otherEntity;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "104167": "\tpublic String getServerNonce() {\n\t\treturn srvNonce;\n\t}\n",
    "104168": "\tpublic String getServerNonceSeq() {\n\t\treturn seq;\n\t}\n",
    "104169": "\tprivate String md5(String in) {\n\t\ttry {\n\t\t\tMessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\t\t\n\t\t\tdigest.update(in.getBytes());\n\t\t\t\n\t\t\treturn StringUtils.bytesToHex(digest.digest());\n\t\t} catch (Exception e) {\n\t\t\tnew Bug(e);\n\t\t\treturn \"<error>\";\n\t\t}\t\n\t}\n",
    "104175": "\tpublic Sample getSample(TridasIdentifier identifier) {\n\t\tfor(BaseSample bs : getAssociatedResult()) {\n\t\t\tif(bs.getSeries().getIdentifier().equals(identifier)) {\n\t\t\t\tif(!(bs instanceof Sample))\n\t\t\t\t\tthrow new IllegalStateException(\"Found identifier but no sample??\");\n\t\t\t\t\n\t\t\t\treturn (Sample) bs;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "104189": "\tprotected void setQueryType(CorinaRequestType queryType) {\n\t\tthis.queryType = queryType;\n\t}\n",
    "104192": "\tprivate void populateComboAndSelect(boolean goRemote) {\n\t\t// get the list of stuff that goes in the box\n\t\tList<? extends ITridas> entityList = getEntityList(goRemote);\n\t\t\n\t\ttopChooser.setList(entityList);\n\n\t\t// select what we already have, if it exists\n\t\tITridas selectedEntity = currentMode.getEntity(s);\n\t\t\n\t\t// otherwise, try to choose something nicely\n\t\tif(selectedEntity == null)\n\t\t\tselectedEntity = suggestSelectedEntity(currentMode, entityList);\n\t\t\n\t\tselectInCombo(selectedEntity);\t\t\n\t}\n",
    "104193": "\tprivate String WSIMessageAsString(WSIMessage msg) {\n\t\tStringBuffer sb = new StringBuffer();\n\n\t\tfor (Object o : msg.getContent()) {\n\t\t\tif (o instanceof String)\n\t\t\t\tsb.append((String) o);\n\t\t\telse if (o instanceof org.w3c.dom.Element) {\n\t\t\t\tsb.append(new DomToString((org.w3c.dom.Element) o, false));\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n",
    "104194": "\tpublic void addSearchForAll() {\n\t\tif(hasConstraints || hasAllConstraint)\n\t\t\tthrow new IllegalArgumentException(\"Cannot have both search constraints and all constraint/multiple all constraints\");\n\t\tthis.setAll(new All());\n\t\tasText += \"[all]\";\n\t\thasAllConstraint = true;\n\t}\n",
    "104205": "\tprivate void save(Object obj) {\n\t\tif(myResource == null)\n\t\t\treturn;\n\t\t\n\t\ttry {\n\t\t\tMarshaller marshaller = getJAXBContext().createMarshaller();\n\t\t\tNamespacePrefixMapper nspm = getNamespacePrefixMapper();\n\n\t\t\tmarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n\t\t\tif (nspm != null)\n\t\t\t\tmarshaller.setProperty(\"com.sun.xml.bind.namespacePrefixMapper\", nspm);\n\t\t\t\n\t\t\tmarshaller.marshal(obj, getCacheFile());\n\t\t} catch (JAXBException e) {\n\t\t\tSystem.err.println(\"Couldn't save cache for \"\n\t\t\t\t\t+ myResource.getResourceName() + \": \" + e.getMessage());\n\t\t}\n\t}\n",
    "104207": "\tpublic void fromCookieStore(CookieStore cs) {\n\t\tboolean storeChanged = false;\n\t\t\n\t\tfor(Cookie c : cs.getCookies()) {\n\t\t\tString hv = hashCookie(c);\n\t\t\tWSCookieWrapper cw = cookies.get(hv);\n\t\t\t\n\t\t\t// cookie already exists and is unchanged\n\t\t\tif(cw != null && cw.equals(c))\n\t\t\t\tcontinue;\n\n\t\t\t// (re-)wrap a cookie\n\t\t\tcookies.put(hv, new WSCookieWrapper(c));\n\t\t\tstoreChanged = true;\n\t\t\t\n\t\t\tSystem.out.println(\"New Cookie: \" + hv);\n\t\t}\n\t\t\n\t\tif(storeChanged) {\n\t\t\tWSCookieStoreHandler.save(this);\n\t\t}\n\t}\t\n",
    "104209": "\tprotected ITridas suggestSelectedEntity(EditType mode, List<? extends ITridas> list) {\n\t\tif(list.size() == 1)\n\t\t\treturn list.get(0);\n\t\t\n\t\treturn null;\n\t}\n",
    "104221": "\tpublic INTYPE query() throws IOException {\n\t\treturn doRequest();\n\t}\n",
    "104223": "\tprivate String getStackTrace() {\n\t\tPureStringWriter sw = new PureStringWriter();\n\t\tPrintWriter pw = new PrintWriter(sw);\n\t\tnew Throwable().printStackTrace(pw);\n\t\treturn sw.toString();\n\t}\n",
    "104224": "\tprotected Schema getValidationSchema() {\n\t\treturn null;\n\t}\n",
    "104225": "\tprotected JAXBContext getJAXBContext() throws JAXBException {\n\t\treturn JAXBContext.newInstance();\n\t}\n",
    "104226": "\tprivate void disableBelowEnableAbove(EditType type) {\n\t\tboolean enabled = true;\n\t\t\n\t\tfor(EditType t : EditType.values()) {\n\t\t\tt.enableAssociatedButton(enabled);\n\t\t\t\n\t\t\tif(t == type)\n\t\t\t\tenabled = false;\n\t\t}\n\t}\n",
    "104228": "\tprotected NamespacePrefixMapper getNamespacePrefixMapper() {\n\t\treturn null;\n\t}\n",
    "104229": "\tpublic void setRequestObject(OUTTYPE reqObj) {\n\t\tthis.sendingObject = reqObj;\n\t}\n",
    "104232": "\tprivate AbstractButton addButton(final EditType type) {\n \t\tAction action = new AbstractAction(type.getTitle(), type.getIcon()) {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\t\t\t\t\n\t\t\t\tbuttonAction(type);\n\t\t\t}\n\t\t};\n\t\t\n\t\tJToggleButton button = new JToggleButton(action);\n\t\ttype.associateButton(button);\n\t\t\n\t\treturn button;\n\t}\n",
    "104235": "\tpublic Dimension getPreferredSize(Dimension parentPreferredDimensions, Dimension scrollExtentDimensions) {\n\t\tparentPreferredDimensions.height = scrollExtentDimensions.height;\n\t\t\n\t\treturn parentPreferredDimensions;\t\t\n\t}\n",
    "104238": "\tpublic String getFolder() {\n\t\treturn folder;\n\t}\n",
    "104248": "\t\tpublic ITridas getEntity(Sample s) {\n\t\t\tif(this == DERIVED_SERIES || this == MEASUREMENT_SERIES)\n\t\t\t\treturn s.getSeries();\n\t\t\t\n\t\t\treturn s.getMeta(metadataTag, ITridas.class);\n\t\t}\n",
    "104253": "\t\tpublic void horizontalScrollbarStatusChanged() {\n\t\t\tensureScrollerExists();\n\t\t\t\n\t\t\tif (!gInfo.isShowBaselines())\n\t\t\t\tscroller.getHorizontalScrollBar().removeAdjustmentListener(this);\n\t\t\telse\n\t\t\t\tscroller.getHorizontalScrollBar().addAdjustmentListener(this);\t\t\t\n\t\t}\n",
    "104255": "\t\tpublic void associateButton(AbstractButton button) {\n\t\t\tassociatedButton = button;\n\t\t}\n",
    "104256": "\t\tpublic AbstractButton getButton() {\n\t\t\treturn associatedButton;\n\t\t}\n",
    "104258": "\t\tpublic void verticalAxisStatusChanged() {\n\t\t\tensureScrollerExists();\n\n\t\t\tif (gInfo.isShowVertAxis()) {\n\t\t\t\tvertaxis = new Axis(gInfo, PlotAgent.getDefault().getAxisType(), GrapherPanel.this);\n\t\t\t\tscroller.setRowHeaderView(vertaxis);\n\t\t\t} else {\n\t\t\t\tscroller.setRowHeaderView(null);\n\t\t\t}\t\t\t\n\t\t}\n",
    "104259": "\t\tpublic void enableAssociatedButton(boolean enabled) {\n\t\t\tif(this == DERIVED_SERIES || this == MEASUREMENT_SERIES || this == BOX)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif(associatedButton != null) {\n\t\t\t\tassociatedButton.setEnabled(enabled);\n\t\t\t}\n\t\t}\n",
    "104262": "\t\tpublic void propertyChanged() {\n\t\t\thasChanged = true;\n\t\t}\n",
    "104265": "\tpublic void addGrapherListener(GrapherListener listener) {\n\t\tgrapherListeners.add(GrapherListener.class, listener);\n\t}\n",
    "104268": "\tpublic void removeGrapherListner(GrapherListener listener) {\n\t\tgrapherListeners.remove(GrapherListener.class, listener);\n\t}\n",
    "104274": "    public File getFolder() {\n        // note: it's immutable, so this is safe.\n        return folder;\n    }\n",
    "104275": "    public File getTopLevel() {\n        // note: it's immutable, so this is safe.\n        return toplevel;\n    }\n",
    "104282": "    public void addChangeListener(ChangeListener listener) {\n        if (!listeners.contains(listener))\n            listeners.add(listener);\n    }\n",
    "104284": "    public void removeChangeListener(ChangeListener listener) {\n        listeners.remove(listener);\n    }\n",
    "104286": "\t\tpublic EditType previous() {\n\t\t\tswitch(this) {\n\t\t\tcase ELEMENT:\n\t\t\t\treturn OBJECT;\n\t\t\tcase SAMPLE:\n\t\t\t\treturn ELEMENT;\n\t\t\tcase RADIUS:\n\t\t\t\treturn SAMPLE;\n\t\t\tcase MEASUREMENT_SERIES:\n\t\t\t\treturn RADIUS;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n",
    "104290": "\t\tpublic EditType next() {\n\t\t\tswitch(this) {\n\t\t\tcase OBJECT:\n\t\t\t\treturn ELEMENT;\n\t\t\tcase ELEMENT:\n\t\t\t\treturn SAMPLE;\n\t\t\tcase SAMPLE:\n\t\t\t\treturn RADIUS;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n",
    "104305": "\tpublic void propertyChange(PropertyChangeEvent evt) {\n\t\tObject n;\n\t\tif(evt.getOldValue() == null && (n = evt.getNewValue()) != null && n.toString().equals(\"\"))\n\t\t\treturn;\n\t\t\n\t\tif(currentMode == null)\n\t\t\tthrow new IllegalStateException(\"Property changed with null mode??\");\n\n\t\tcurrentMode.propertyChanged();\n\t}\n",
    "104319": "    public void setSortColumn(String sortColumn) {\n        if (sortColumn == null)\n            throw new NullPointerException();\n    \n        this.sortColumn = sortColumn;\n    }\n",
    "104381": "    protected void addNewFolderMenuItem() {\n        JMenuItem newFolder = Builder.makeMenuItem(\"new_folder\", /*WRITEME:*/false);\n         // TODO: create new folder\n         // TODO: select it, and start editing its name inline (need renaming first!)\n         // -- what if i'm not displaying folders in the browser?  dialog?  no, edit on top ... what if it's a popup?\n         // TODO: undoable, as long as nothing has been created/moved inside it\n        // -- in which case moving/creating something inside it is undoable, and then this is undoable.\n        add(newFolder);\n    }\n",
    "104411": "    protected void addPageSetupMenuItem() {\n        JMenuItem setup = Builder.makeMenuItem(\"page_setup...\");\n        setup.addActionListener(new AbstractAction() { // REFACTOR: this taken verbatim from XMenubar\n            public void actionPerformed(ActionEvent ae) {\n                // make printer job, if none exists yet\n                if (printJob == null)\n                    printJob = PrinterJob.getPrinterJob();\n\n                // get page format\n                pageFormat = printJob.pageDialog(pageFormat);\n            }\n        });\n        add(setup);\n    }\n",
    "104430": "\tpublic void batchAddStatements(Statement s, String newVMeasurementResultID) throws SQLException {\n\t\tString header = \"INSERT into tblVMeasurementReadingResult (VMeasurementResultID,RelYear,Reading) VALUES ('\";\n\t\tint truncateLength = header.length();\n\t\tStringBuffer b = new StringBuffer(header);\t\t\n\t\t\n\t\tint len = output.size();\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tb.setLength(truncateLength);\n\t\t\t\n\t\t\tb.append(newVMeasurementResultID);\n\t\t\tb.append(\"',\");\n\t\t\tb.append(relYear.get(i));\n\t\t\tb.append(',');\n\t\t\tb.append(output.get(i).intValue());\n\t\t\tb.append(\")\");\n\t\t\ts.addBatch(b.toString());\n\t\t}\n\t}\n",
    "104433": "\tpublic void cleanup() throws SQLException {\n\t\tIterator<String> i = queries.keySet().iterator();\n\t\t\n\t\twhile(i.hasNext()) {\n\t\t\tStatementQueryHolder sq = queries.get(i.next());\n\t\t\tif(sq != null)\n\t\t\t\tsq.cleanup();\n\t\t}\n\t}\n",
    "104437": "\tpublic Row getSelectedRow() throws NoSuchElementException {\n\t\tint selection = table.getSelectedRow();\n\t\tif (selection != -1)\n\t\t\treturn (Row) visibleFiles.get(selection);\n\t\telse\n\t\t\tthrow new NoSuchElementException();\n\t}\n",
    "104438": "\tprivate void acquireVMeasurementResult(UUID VMeasurementID, boolean safe) throws SQLException {\n\t\tif(safe) {\n\t\t\t// If we have an error, clean up any mess we made, but pass along the exception.\n\t\t\tSavepoint beforeCreation = dbq.getConnection().setSavepoint();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tresult = recursiveGetVMeasurementResult(VMeasurementID, null, null, 0);\n\t\t\t} catch (SQLException sql) {\n\t\t\t\tdbq.getConnection().rollback(beforeCreation);\n\t\t\t\tthrow sql;\n\t\t\t} finally {\n\t\t\t\tdbq.getConnection().releaseSavepoint(beforeCreation);\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\telse\n\t\t\tresult = recursiveGetVMeasurementResult(VMeasurementID, null, null, 0);\n\t}\n",
    "104454": "\tpublic Iterator getSelectedRows() {\n\t\treturn new Iterator() {\n\t\t\tint rows[] = table.getSelectedRows();\n\n\t\t\tint i = 0;\n\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn (i < rows.length);\n\t\t\t}\n\n\t\t\tpublic Object next() throws NoSuchElementException {\n\t\t\t\tif (i < rows.length)\n\t\t\t\t\treturn visibleFiles.get(i++);\n\t\t\t\telse\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t};\n\t}\n",
    "104482": "\tpublic void doIndex() {\n\t\tSystem.out.println(\"Starting index function \" + getI18nTag());\n\t\tif(input == null)\n\t\t\tthrow new IllegalArgumentException(\"Index function has not been properly initilaized\");\n\t\tif(alreadyIndexed)\n\t\t\tthrow new IllegalArgumentException(\"Index function has already been run\");\n\t\telse\n\t\t\talreadyIndexed = true;\n\t\t\n\t\tindex();\n\t}\n",
    "104509": "    public String getAddressLine1() {\n        return addressLine1;\n    }\n",
    "104513": "    public void setAddressLine1(String value) {\n        this.addressLine1 = value;\n    }\n",
    "104519": "    public String getAddressLine2() {\n        return addressLine2;\n    }\n",
    "104520": "    public void setAddressLine2(String value) {\n        this.addressLine2 = value;\n    }\n",
    "104521": "    public ControlledVoc getType() {\n        return type;\n    }\n",
    "104523": "    public String getCityOrTown() {\n        return cityOrTown;\n    }\n",
    "104524": "    public void setType(ControlledVoc value) {\n        this.type = value;\n    }\n",
    "104525": "    public void setCityOrTown(String value) {\n        this.cityOrTown = value;\n    }\n",
    "104529": "    public String getStateProvinceRegion() {\n        return stateProvinceRegion;\n    }\n",
    "104530": "    public void setStateProvinceRegion(String value) {\n        this.stateProvinceRegion = value;\n    }\n",
    "104533": "    public String getPostalCode() {\n        return postalCode;\n    }\n",
    "104534": "    public void setPostalCode(String value) {\n        this.postalCode = value;\n    }\n",
    "104538": "    public String getCountry() {\n        return country;\n    }\n",
    "104540": "    public void setCountry(String value) {\n        this.country = value;\n    }\n",
    "104542": "    public SeriesLinksWithPreferred getLinkSeries() {\n        return linkSeries;\n    }\n",
    "104545": "    public void setLinkSeries(SeriesLinksWithPreferred value) {\n        this.linkSeries = value;\n    }\n",
    "104559": "    public XMLGregorianCalendar getValue() {\n        return value;\n    }\n",
    "104560": "    public void setValue(XMLGregorianCalendar value) {\n        this.value = value;\n    }\n",
    "104561": "    public ControlledVoc getTaxon() {\n        return taxon;\n    }\n",
    "104563": "    public Certainty getCertainty() {\n        return certainty;\n    }\n",
    "104564": "    public void setCertainty(Certainty value) {\n        this.certainty = value;\n    }\n",
    "104566": "    public void setTaxon(ControlledVoc value) {\n        this.taxon = value;\n    }\n",
    "104575": "    public TridasShape getShape() {\n        return shape;\n    }\n",
    "104578": "    public void setShape(TridasShape value) {\n        this.shape = value;\n    }\n",
    "104580": "    public NormalTridasRemark getNormalTridas() {\n        return normalTridas;\n    }\n",
    "104583": "    public void setNormalTridas(NormalTridasRemark value) {\n        this.normalTridas = value;\n    }\n",
    "104585": "    public Integer getInheritedCount() {\n        return inheritedCount;\n    }\n",
    "104586": "    public TridasDimensions getDimensions() {\n        return dimensions;\n    }\n",
    "104587": "    public void setInheritedCount(Integer value) {\n        this.inheritedCount = value;\n    }\n",
    "104589": "    public void setDimensions(TridasDimensions value) {\n        this.dimensions = value;\n    }\n",
    "104597": "    public String getAuthenticity() {\n        return authenticity;\n    }\n",
    "104600": "    public void setAuthenticity(String value) {\n        this.authenticity = value;\n    }\n",
    "104604": "    public NormalTridasDatingType getType() {\n        return type;\n    }\n",
    "104606": "    public void setType(NormalTridasDatingType value) {\n        this.type = value;\n    }\n",
    "104611": "    public TridasLocation getLocation() {\n        return location;\n    }\n",
    "104617": "    public void setLocation(TridasLocation value) {\n        this.location = value;\n    }\n",
    "104624": "    public String getProcessing() {\n        return processing;\n    }\n",
    "104627": "    public void setProcessing(String value) {\n        this.processing = value;\n    }\n",
    "104634": "    public String getMarks() {\n        return marks;\n    }\n",
    "104637": "    public void setMarks(String value) {\n        this.marks = value;\n    }\n",
    "104642": "    public Double getAltitude() {\n        return altitude;\n    }\n",
    "104645": "    public void setAltitude(Double value) {\n        this.altitude = value;\n    }\n",
    "104654": "    public TridasSlope getSlope() {\n        return slope;\n    }\n",
    "104658": "    public void setSlope(TridasSlope value) {\n        this.slope = value;\n    }\n",
    "104664": "    public NormalTridasVariable getNormalTridas() {\n        return normalTridas;\n    }\n",
    "104665": "    public void setNormalTridas(NormalTridasVariable value) {\n        this.normalTridas = value;\n    }\n",
    "104666": "    public TridasSoil getSoil() {\n        return soil;\n    }\n",
    "104673": "    public void setSoil(TridasSoil value) {\n        this.soil = value;\n    }\n",
    "104680": "    public BigInteger getValue() {\n        return value;\n    }\n",
    "104681": "    public void setValue(BigInteger value) {\n        this.value = value;\n    }\n",
    "104683": "    public TridasBedrock getBedrock() {\n        return bedrock;\n    }\n",
    "104688": "    public DatingSuffix getSuffix() {\n        return suffix;\n    }\n",
    "104689": "    public void setBedrock(TridasBedrock value) {\n        this.bedrock = value;\n    }\n",
    "104690": "    public void setSuffix(DatingSuffix value) {\n        this.suffix = value;\n    }\n",
    "104705": "    public TridasDating getDating() {\n        return dating;\n    }\n",
    "104707": "    public void setDating(TridasDating value) {\n        this.dating = value;\n    }\n",
    "104710": "    public Year getFirstYear() {\n        return firstYear;\n    }\n",
    "104712": "    public void setFirstYear(Year value) {\n        this.firstYear = value;\n    }\n",
    "104715": "    public Year getLastYear() {\n        return lastYear;\n    }\n",
    "104716": "    public void setLastYear(Year value) {\n        this.lastYear = value;\n    }\n",
    "104718": "    public void setFiles(List<TridasFile> files) {\n        this.files = files;\n    }\n",
    "104720": "    public TridasDatingReference getDatingReference() {\n        return datingReference;\n    }\n",
    "104721": "    public void setDatingReference(TridasDatingReference value) {\n        this.datingReference = value;\n    }\n",
    "104722": "    public void setGenericFields(List<TridasGenericField> genericFields) {\n        this.genericFields = genericFields;\n    }\n",
    "104730": "    public Year getPithYear() {\n        return pithYear;\n    }\n",
    "104731": "    public void setPithYear(Year value) {\n        this.pithYear = value;\n    }\n",
    "104734": "    public Year getDeathYear() {\n        return deathYear;\n    }\n",
    "104736": "    public void setDeathYear(Year value) {\n        this.deathYear = value;\n    }\n",
    "104739": "    public String getProvenance() {\n        return provenance;\n    }\n",
    "104741": "    public void setProvenance(String value) {\n        this.provenance = value;\n    }\n",
    "104744": "    public void setStatFoundations(List<TridasStatFoundation> statFoundations) {\n        this.statFoundations = statFoundations;\n    }\n",
    "104764": "    public BigDecimal getStatValue() {\n        return statValue;\n    }\n",
    "104766": "    public void setStatValue(BigDecimal value) {\n        this.statValue = value;\n    }\n",
    "104772": "    public BigDecimal getSignificanceLevel() {\n        return significanceLevel;\n    }\n",
    "104774": "    public void setSignificanceLevel(BigDecimal value) {\n        this.significanceLevel = value;\n    }\n",
    "104777": "    public String getUsedSoftware() {\n        return usedSoftware;\n    }\n",
    "104779": "    public void setUsedSoftware(String value) {\n        this.usedSoftware = value;\n    }\n",
    "104797": "    public TridasCategory getCategory() {\n        return category;\n    }\n",
    "104798": "    public Date getMeasuringDate() {\n        return measuringDate;\n    }\n",
    "104800": "    public void setMeasuringDate(Date value) {\n        this.measuringDate = value;\n    }\n",
    "104801": "    public void setCategory(TridasCategory value) {\n        this.category = value;\n    }\n",
    "104805": "    public Date getDerivationDate() {\n        return derivationDate;\n    }\n",
    "104806": "    public String getInvestigator() {\n        return investigator;\n    }\n",
    "104807": "    public void setDerivationDate(Date value) {\n        this.derivationDate = value;\n    }\n",
    "104808": "    public void setInvestigator(String value) {\n        this.investigator = value;\n    }\n",
    "104813": "    public TridasWoodCompleteness getWoodCompleteness() {\n        return woodCompleteness;\n    }\n",
    "104814": "    public String getPeriod() {\n        return period;\n    }\n",
    "104816": "    public void setWoodCompleteness(TridasWoodCompleteness value) {\n        this.woodCompleteness = value;\n    }\n",
    "104817": "    public void setPeriod(String value) {\n        this.period = value;\n    }\n",
    "104821": "    public String getAnalyst() {\n        return analyst;\n    }\n",
    "104822": "    public Date getRequestDate() {\n        return requestDate;\n    }\n",
    "104823": "    public void setAnalyst(String value) {\n        this.analyst = value;\n    }\n",
    "104824": "    public void setRequestDate(Date value) {\n        this.requestDate = value;\n    }\n",
    "104828": "    public String getDendrochronologist() {\n        return dendrochronologist;\n    }\n",
    "104829": "    public String getCommissioner() {\n        return commissioner;\n    }\n",
    "104830": "    public void setDendrochronologist(String value) {\n        this.dendrochronologist = value;\n    }\n",
    "104831": "    public void setCommissioner(String value) {\n        this.commissioner = value;\n    }\n",
    "104836": "    public TridasMeasuringMethod getMeasuringMethod() {\n        return measuringMethod;\n    }\n",
    "104838": "    public void setMeasuringMethod(TridasMeasuringMethod value) {\n        this.measuringMethod = value;\n    }\n",
    "104849": "    public SeriesLinks getLinkSeries() {\n        return linkSeries;\n    }\n",
    "104851": "    public void setLinkSeries(SeriesLinks value) {\n        this.linkSeries = value;\n    }\n",
    "104857": "    public String getObjective() {\n        return objective;\n    }\n",
    "104860": "    public void setObjective(String value) {\n        this.objective = value;\n    }\n",
    "104863": "    public void setTypes(List<ControlledVoc> types) {\n        this.types = types;\n    }\n",
    "104864": "    public String getStandardizingMethod() {\n        return standardizingMethod;\n    }\n",
    "104867": "    public void setStandardizingMethod(String value) {\n        this.standardizingMethod = value;\n    }\n",
    "104868": "    public void setLaboratories(List<TridasLaboratory> laboratories) {\n        this.laboratories = laboratories;\n    }\n",
    "104870": "    public void setReferences(List<String> references) {\n        this.references = references;\n    }\n",
    "104873": "    public String getAuthor() {\n        return author;\n    }\n",
    "104874": "    public void setResearches(List<TridasResearch> researches) {\n        this.researches = researches;\n    }\n",
    "104875": "    public void setAuthor(String value) {\n        this.author = value;\n    }\n",
    "104880": "    public String getVersion() {\n        return version;\n    }\n",
    "104882": "    public void setVersion(String value) {\n        this.version = value;\n    }\n",
    "104887": "    public TridasInterpretationUnsolved getInterpretationUnsolved() {\n        return interpretationUnsolved;\n    }\n",
    "104889": "    public void setInterpretationUnsolved(TridasInterpretationUnsolved value) {\n        this.interpretationUnsolved = value;\n    }\n",
    "104895": "    public TridasInterpretation getInterpretation() {\n        return interpretation;\n    }\n",
    "104898": "    public void setInterpretation(TridasInterpretation value) {\n        this.interpretation = value;\n    }\n",
    "104901": "    public TridasIdentifier createTridasIdentifier() {\n        return new TridasIdentifier();\n    }\n",
    "104904": "    public TridasFile createTridasFile() {\n        return new TridasFile();\n    }\n",
    "104907": "    public SeriesLink createSeriesLink() {\n        return new SeriesLink();\n    }\n",
    "104911": "    public Integer getMissingHeartwoodRingsToPith() {\n        return missingHeartwoodRingsToPith;\n    }\n",
    "104912": "    public TridasCoverage createTridasCoverage() {\n        return new TridasCoverage();\n    }\n",
    "104913": "    public void setMissingHeartwoodRingsToPith(Integer value) {\n        this.missingHeartwoodRingsToPith = value;\n    }\n",
    "104916": "    public String getMissingHeartwoodRingsToPithFoundation() {\n        return missingHeartwoodRingsToPithFoundation;\n    }\n",
    "104917": "    public void setMissingHeartwoodRingsToPithFoundation(String value) {\n        this.missingHeartwoodRingsToPithFoundation = value;\n    }\n",
    "104920": "    public TridasSlope createTridasSlope() {\n        return new TridasSlope();\n    }\n",
    "104921": "    public ComplexPresenceAbsence getPresence() {\n        return presence;\n    }\n",
    "104922": "    public void setPresence(ComplexPresenceAbsence value) {\n        this.presence = value;\n    }\n",
    "104926": "    public TridasPith createTridasPith() {\n        return new TridasPith();\n    }\n",
    "104932": "    public ControlledVoc createControlledVoc() {\n        return new ControlledVoc();\n    }\n",
    "104939": "    public TridasVocabulary createTridasVocabulary() {\n        return new TridasVocabulary();\n    }\n",
    "104940": "    public String getContent() {\n        return content;\n    }\n",
    "104941": "    public void setContent(String value) {\n        this.content = value;\n    }\n",
    "104944": "    public PresenceAbsence getPresence() {\n        return presence;\n    }\n",
    "104945": "    public void setPresence(PresenceAbsence value) {\n        this.presence = value;\n    }\n",
    "104948": "    public TridasElement createTridasElement() {\n        return new TridasElement();\n    }\n",
    "104957": "    public TridasBedrock createTridasBedrock() {\n        return new TridasBedrock();\n    }\n",
    "104967": "    public TridasLaboratory createTridasLaboratory() {\n        return new TridasLaboratory();\n    }\n",
    "104969": "    public void setValues(List<TridasValues> values) {\n        this.values = values;\n    }\n",
    "104975": "    public TridasProject createTridasProject() {\n        return new TridasProject();\n    }\n",
    "104979": "    public TridasSoil createTridasSoil() {\n        return new TridasSoil();\n    }\n",
    "104984": "    public TridasLastRingUnderBark createTridasLastRingUnderBark() {\n        return new TridasLastRingUnderBark();\n    }\n",
    "104987": "    public TridasHeartwood createTridasHeartwood() {\n        return new TridasHeartwood();\n    }\n",
    "104992": "    public TridasValues createTridasValues() {\n        return new TridasValues();\n    }\n",
    "104995": "    public TridasDerivedSeries createTridasDerivedSeries() {\n        return new TridasDerivedSeries();\n    }\n",
    "104999": "    public TridasMeasurementSeriesPlaceholder createTridasMeasurementSeriesPlaceholder() {\n        return new TridasMeasurementSeriesPlaceholder();\n    }\n",
    "105002": "    public TridasAddress createTridasAddress() {\n        return new TridasAddress();\n    }\n",
    "105011": "    public TridasValue createTridasValue() {\n        return new TridasValue();\n    }\n",
    "105019": "    public TridasGenericField createTridasGenericField() {\n        return new TridasGenericField();\n    }\n",
    "105026": "    public TridasLocation createTridasLocation() {\n        return new TridasLocation();\n    }\n",
    "105037": "    public Year createYear() {\n        return new Year();\n    }\n",
    "105042": "    public PolygonType getPolygon() {\n        return polygon;\n    }\n",
    "105043": "    public void setPolygon(PolygonType value) {\n        this.polygon = value;\n    }\n",
    "105046": "    public TridasMeasuringMethod createTridasMeasuringMethod() {\n        return new TridasMeasuringMethod();\n    }\n",
    "105055": "    public Date createDate() {\n        return new Date();\n    }\n",
    "105062": "    public TridasObject createTridasObject() {\n        return new TridasObjectEx();\n    }\n",
    "105066": "    public TridasWoodCompleteness createTridasWoodCompleteness() {\n        return new TridasWoodCompleteness();\n    }\n",
    "105072": "    public SeriesLinks createSeriesLinks() {\n        return new SeriesLinks();\n    }\n",
    "105076": "    public TridasSample createTridasSample() {\n        return new TridasSample();\n    }\n",
    "105080": "    public TridasLocationGeometry createTridasLocationGeometry() {\n        return new TridasLocationGeometry();\n    }\n",
    "105085": "    public TridasVariable createTridasVariable() {\n        return new TridasVariable();\n    }\n",
    "105089": "    public String getCreator() {\n        return creator;\n    }\n",
    "105090": "    public TridasStatFoundation createTridasStatFoundation() {\n        return new TridasStatFoundation();\n    }\n",
    "105091": "    public void setCreator(String value) {\n        this.creator = value;\n    }\n",
    "105096": "    public TridasUnitless createTridasUnitless() {\n        return new TridasUnitless();\n    }\n",
    "105097": "    public String getOwner() {\n        return owner;\n    }\n",
    "105098": "    public void setOwner(String value) {\n        this.owner = value;\n    }\n",
    "105100": "    public TridasRemark createTridasRemark() {\n        return new TridasRemark();\n    }\n",
    "105103": "    public TridasCoverage getCoverage() {\n        return coverage;\n    }\n",
    "105104": "    public void setCoverage(TridasCoverage value) {\n        this.coverage = value;\n    }\n",
    "105105": "    public TridasBark createTridasBark() {\n        return new TridasBark();\n    }\n",
    "105110": "    public TridasInterpretationUnsolved createTridasInterpretationUnsolved() {\n        return new TridasInterpretationUnsolved();\n    }\n",
    "105114": "    public TridasDating createTridasDating() {\n        return new TridasDating();\n    }\n",
    "105118": "    public TridasCategory createTridasCategory() {\n        return new TridasCategory();\n    }\n",
    "105123": "    public TridasSapwood createTridasSapwood() {\n        return new TridasSapwood();\n    }\n",
    "105127": "    public TridasDatingReference createTridasDatingReference() {\n        return new TridasDatingReference();\n    }\n",
    "105132": "    public TridasMeasurementSeries createTridasMeasurementSeries() {\n        return new TridasMeasurementSeries();\n    }\n",
    "105136": "    public TridasRadiusPlaceholder createTridasRadiusPlaceholder() {\n        return new TridasRadiusPlaceholder();\n    }\n",
    "105140": "    public TridasUnit createTridasUnit() {\n        return new TridasUnit();\n    }\n",
    "105145": "    public TridasDimensions createTridasDimensions() {\n        return new TridasDimensions();\n    }\n",
    "105149": "    public TridasTridas createTridasTridas() {\n        return new TridasTridas();\n    }\n",
    "105153": "    public TridasInterpretation createTridasInterpretation() {\n        return new TridasInterpretation();\n    }\n",
    "105156": "    public TridasRadius createTridasRadius() {\n        return new TridasRadius();\n    }\n",
    "105160": "    public DateTime createDateTime() {\n        return new DateTime();\n    }\n",
    "105163": "    public Integer getNrOfSapwoodRings() {\n        return nrOfSapwoodRings;\n    }\n",
    "105164": "    public void setNrOfSapwoodRings(Integer value) {\n        this.nrOfSapwoodRings = value;\n    }\n",
    "105168": "    public TridasShape createTridasShape() {\n        return new TridasShape();\n    }\n",
    "105169": "    public TridasLastRingUnderBark getLastRingUnderBark() {\n        return lastRingUnderBark;\n    }\n",
    "105170": "    public void setLastRingUnderBark(TridasLastRingUnderBark value) {\n        this.lastRingUnderBark = value;\n    }\n",
    "105173": "    public Integer getMissingSapwoodRingsToBark() {\n        return missingSapwoodRingsToBark;\n    }\n",
    "105174": "    public void setMissingSapwoodRingsToBark(Integer value) {\n        this.missingSapwoodRingsToBark = value;\n    }\n",
    "105175": "    public TridasResearch createTridasResearch() {\n        return new TridasResearch();\n    }\n",
    "105178": "    public String getMissingSapwoodRingsToBarkFoundation() {\n        return missingSapwoodRingsToBarkFoundation;\n    }\n",
    "105179": "    public void setMissingSapwoodRingsToBarkFoundation(String value) {\n        this.missingSapwoodRingsToBarkFoundation = value;\n    }\n",
    "105181": "    public SeriesLinksWithPreferred createSeriesLinksWithPreferred() {\n        return new SeriesLinksWithPreferred();\n    }\n",
    "105184": "    public Integer getAngle() {\n        return angle;\n    }\n",
    "105186": "    public void setAngle(Integer value) {\n        this.angle = value;\n    }\n",
    "105189": "    public Integer getAzimuth() {\n        return azimuth;\n    }\n",
    "105190": "    public void setAzimuth(Integer value) {\n        this.azimuth = value;\n    }\n",
    "105212": "    public TridasUnit getUnit() {\n        return unit;\n    }\n",
    "105213": "    public void setUnit(TridasUnit value) {\n        this.unit = value;\n    }\n",
    "105217": "    public BigDecimal getHeight() {\n        return height;\n    }\n",
    "105221": "    public void setHeight(BigDecimal value) {\n        this.height = value;\n    }\n",
    "105227": "    public BigDecimal getWidth() {\n        return width;\n    }\n",
    "105231": "    public void setWidth(BigDecimal value) {\n        this.width = value;\n    }\n",
    "105235": "    public TridasLocationGeometry getLocationGeometry() {\n        return locationGeometry;\n    }\n",
    "105236": "    public BigDecimal getDepth() {\n        return depth;\n    }\n",
    "105237": "    public void setLocationGeometry(TridasLocationGeometry value) {\n        this.locationGeometry = value;\n    }\n",
    "105238": "    public void setDepth(BigDecimal value) {\n        this.depth = value;\n    }\n",
    "105242": "    public NormalTridasLocationType getLocationType() {\n        return locationType;\n    }\n",
    "105243": "    public BigDecimal getDiameter() {\n        return diameter;\n    }\n",
    "105244": "    public void setLocationType(NormalTridasLocationType value) {\n        this.locationType = value;\n    }\n",
    "105245": "    public void setDiameter(BigDecimal value) {\n        this.diameter = value;\n    }\n",
    "105248": "    public String getLocationPrecision() {\n        return locationPrecision;\n    }\n",
    "105251": "    public void setLocationPrecision(String value) {\n        this.locationPrecision = value;\n    }\n",
    "105254": "    public String getLocationComment() {\n        return locationComment;\n    }\n",
    "105256": "    public void setLocationComment(String value) {\n        this.locationComment = value;\n    }\n",
    "105261": "    public TridasAddress getAddress() {\n        return address;\n    }\n",
    "105263": "    public void setAddress(TridasAddress value) {\n        this.address = value;\n    }\n",
    "105273": "    public NormalTridasUnit getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105275": "    public void setNormalTridas(NormalTridasUnit value) {\n        this.normalTridas = value;\n    }\n",
    "105286": "    public Integer getCount() {\n        return count;\n    }\n",
    "105290": "    public void setCount(Integer value) {\n        this.count = value;\n    }\n",
    "105311": "    public String getNormalStd() {\n        return normalStd;\n    }\n",
    "105313": "    public void setNormalStd(String value) {\n        this.normalStd = value;\n    }\n",
    "105318": "    public String getNormalId() {\n        return normalId;\n    }\n",
    "105321": "    public void setNormalId(String value) {\n        this.normalId = value;\n    }\n",
    "105327": "    public String getNormal() {\n        return normal;\n    }\n",
    "105330": "    public void setNormal(String value) {\n        this.normal = value;\n    }\n",
    "105336": "    public String getLang() {\n        return lang;\n    }\n",
    "105339": "    public void setLang(String value) {\n        this.lang = value;\n    }\n",
    "105351": "    public SeriesLink getPreferredSeries() {\n        return preferredSeries;\n    }\n",
    "105353": "    public void setPreferredSeries(SeriesLink value) {\n        this.preferredSeries = value;\n    }\n",
    "105382": "    public BigDecimal getAzimuth() {\n        return azimuth;\n    }\n",
    "105383": "    public void setXLink(SeriesLink.XLink value) {\n        this.xLink = value;\n    }\n",
    "105384": "    public void setAzimuth(BigDecimal value) {\n        this.azimuth = value;\n    }\n",
    "105388": "    public void setIdRef(SeriesLink.IdRef value) {\n        this.idRef = value;\n    }\n",
    "105419": "        public Object getRef() {\n            return ref;\n        }\n",
    "105423": "        public void setRef(Object value) {\n            this.ref = value;\n        }\n",
    "105429": "    public Double getDepth() {\n        return depth;\n    }\n",
    "105431": "    public void setDepth(Double value) {\n        this.depth = value;\n    }\n",
    "105459": "    public void setProjectCategory(TridasVocabulary.ProjectCategory value) {\n        this.projectCategory = value;\n    }\n",
    "105475": "    public void setProjectType(TridasVocabulary.ProjectType value) {\n        this.projectType = value;\n    }\n",
    "105484": "    public String getDomain() {\n        return domain;\n    }\n",
    "105485": "    public void setDomain(String value) {\n        this.domain = value;\n    }\n",
    "105502": "    public TridasVariable getVariable() {\n        return variable;\n    }\n",
    "105503": "    public void setVariable(TridasVariable value) {\n        this.variable = value;\n    }\n",
    "105505": "    public void setObjectType(TridasVocabulary.ObjectType value) {\n        this.objectType = value;\n    }\n",
    "105512": "    public TridasUnitless getUnitless() {\n        return unitless;\n    }\n",
    "105513": "    public void setUnitless(TridasUnitless value) {\n        this.unitless = value;\n    }\n",
    "105519": "    public void setValues(List<TridasValue> values) {\n        this.values = values;\n    }\n",
    "105532": "    public void setElementType(TridasVocabulary.ElementType value) {\n        this.elementType = value;\n    }\n",
    "105549": "    public Date getSamplingDate() {\n        return samplingDate;\n    }\n",
    "105550": "    public void setSampleType(TridasVocabulary.SampleType value) {\n        this.sampleType = value;\n    }\n",
    "105552": "    public void setSamplingDate(Date value) {\n        this.samplingDate = value;\n    }\n",
    "105555": "    public String getPosition() {\n        return position;\n    }\n",
    "105557": "    public void setPosition(String value) {\n        this.position = value;\n    }\n",
    "105562": "    public String getState() {\n        return state;\n    }\n",
    "105564": "    public void setState(String value) {\n        this.state = value;\n    }\n",
    "105565": "    public void setDerivedSeriesType(TridasVocabulary.DerivedSeriesType value) {\n        this.derivedSeriesType = value;\n    }\n",
    "105576": "    public Boolean isKnots() {\n        return knots;\n    }\n",
    "105583": "    public void setKnots(Boolean value) {\n        this.knots = value;\n    }\n",
    "105597": "    public NormalTridasShape getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105599": "    public void setNormalTridas(NormalTridasShape value) {\n        this.normalTridas = value;\n    }\n",
    "105602": "    public void setElementTaxon(TridasVocabulary.ElementTaxon value) {\n        this.elementTaxon = value;\n    }\n",
    "105612": "    public TridasRadiusPlaceholder getRadiusPlaceholder() {\n        return radiusPlaceholder;\n    }\n",
    "105620": "    public void setRadiusPlaceholder(TridasRadiusPlaceholder value) {\n        this.radiusPlaceholder = value;\n    }\n",
    "105634": "    public void setElementShape(TridasVocabulary.ElementShape value) {\n        this.elementShape = value;\n    }\n",
    "105635": "    public NormalTridasCategory getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105636": "    public void setNormalTridas(NormalTridasCategory value) {\n        this.normalTridas = value;\n    }\n",
    "105652": "    public String getCoverageTemporal() {\n        return coverageTemporal;\n    }\n",
    "105653": "    public void setCoverageTemporal(String value) {\n        this.coverageTemporal = value;\n    }\n",
    "105656": "    public String getCoverageTemporalFoundation() {\n        return coverageTemporalFoundation;\n    }\n",
    "105657": "    public void setCoverageTemporalFoundation(String value) {\n        this.coverageTemporalFoundation = value;\n    }\n",
    "105665": "    public void setMeasurementSeriesMeasuringMethod(TridasVocabulary.MeasurementSeriesMeasuringMethod value) {\n        this.measurementSeriesMeasuringMethod = value;\n    }\n",
    "105672": "    public Integer getRingCount() {\n        return ringCount;\n    }\n",
    "105673": "    public void setRingCount(Integer value) {\n        this.ringCount = value;\n    }\n",
    "105677": "    public Double getAverageRingWidth() {\n        return averageRingWidth;\n    }\n",
    "105678": "    public void setAverageRingWidth(Double value) {\n        this.averageRingWidth = value;\n    }\n",
    "105681": "    public Integer getNrOfUnmeasuredInnerRings() {\n        return nrOfUnmeasuredInnerRings;\n    }\n",
    "105683": "    public void setNrOfUnmeasuredInnerRings(Integer value) {\n        this.nrOfUnmeasuredInnerRings = value;\n    }\n",
    "105685": "    public void setValuesVariable(TridasVocabulary.ValuesVariable value) {\n        this.valuesVariable = value;\n    }\n",
    "105687": "    public Integer getNrOfUnmeasuredOuterRings() {\n        return nrOfUnmeasuredOuterRings;\n    }\n",
    "105689": "    public void setNrOfUnmeasuredOuterRings(Integer value) {\n        this.nrOfUnmeasuredOuterRings = value;\n    }\n",
    "105692": "    public TridasPith getPith() {\n        return pith;\n    }\n",
    "105693": "    public void setPith(TridasPith value) {\n        this.pith = value;\n    }\n",
    "105697": "    public TridasHeartwood getHeartwood() {\n        return heartwood;\n    }\n",
    "105698": "    public TridasMeasurementSeriesPlaceholder getMeasurementSeriesPlaceholder() {\n        return measurementSeriesPlaceholder;\n    }\n",
    "105699": "    public void setMeasurementSeriesPlaceholder(TridasMeasurementSeriesPlaceholder value) {\n        this.measurementSeriesPlaceholder = value;\n    }\n",
    "105700": "    public void setHeartwood(TridasHeartwood value) {\n        this.heartwood = value;\n    }\n",
    "105705": "    public TridasSapwood getSapwood() {\n        return sapwood;\n    }\n",
    "105707": "    public void setValuesRemark(TridasVocabulary.ValuesRemark value) {\n        this.valuesRemark = value;\n    }\n",
    "105709": "    public void setSapwood(TridasSapwood value) {\n        this.sapwood = value;\n    }\n",
    "105714": "    public TridasBark getBark() {\n        return bark;\n    }\n",
    "105716": "    public void setBark(TridasBark value) {\n        this.bark = value;\n    }\n",
    "105733": "    public void setLocationType(TridasVocabulary.LocationType value) {\n        this.locationType = value;\n    }\n",
    "105743": "    public void setSeries(List<SeriesLink> series) {\n        this.series = series;\n    }\n",
    "105773": "    public NormalTridasMeasuringMethod getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105774": "    public void setNormalTridas(NormalTridasMeasuringMethod value) {\n        this.normalTridas = value;\n    }\n",
    "105775": "    public void setName(TridasLaboratory.Name value) {\n        this.name = value;\n    }\n",
    "105780": "    public void setGlobalUnit(TridasVocabulary.GlobalUnit value) {\n        this.globalUnit = value;\n    }\n",
    "105795": "    public TridasVocabulary getVocabulary() {\n        return vocabulary;\n    }\n",
    "105796": "    public void setVocabulary(TridasVocabulary value) {\n        this.vocabulary = value;\n    }\n",
    "105817": "    public SeriesLink getLinkSeries() {\n        return linkSeries;\n    }\n",
    "105818": "    public void setLinkSeries(SeriesLink value) {\n        this.linkSeries = value;\n    }\n",
    "105831": "        public String getAcronym() {\n            return acronym;\n        }\n",
    "105835": "        public void setAcronym(String value) {\n            this.acronym = value;\n        }\n",
    "105886": "  public String toString() {\n    return \"Average: \" + getAverage() + \" Measurements: \" + count;\n  }\n",
    "105917": "public class OnDemandDrawStrategy implements DrawStrategy {\n  public void init(Component parent) { /* nothing */ }\n\n  public void resize(Dimension d) { /* nothing */ }\n\n  public void startDraw(Graphics g, Layer layer) { /* nothing */ }\n\n  public void draw(Graphics g, Layer layer) {\n    layer.draw(g, g.getClipBounds(), false);\n  }\n\n  public void endDraw(Graphics g, Layer layer) { /* nothing */ }\n\n  public void destroy() { /* nothing */ }\n}",
    "105979": "    public String parseSource(final String source) {\n\n        try {\n            Document doc = new Document(source);\n            parseSource(doc);\n            return doc.get();\n        } catch (BadLocationException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n",
    "105981": "    public void parseSource(final IDocument source) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, null);\n        CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "105983": "    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);\n        CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "106061": "    private boolean returnsVoid(final MethodDeclaration assertedMethod) {\n        boolean returnsVoid = assertedMethod.getReturnType2() == null\n                                       ||\n                              (assertedMethod.getReturnType2().isPrimitiveType()\n                                       &&\n                              ((PrimitiveType) assertedMethod.getReturnType2()).getPrimitiveTypeCode().equals(PrimitiveType.VOID));\n        return returnsVoid;\n    }\n",
    "106063": "        public void setShapes(List<TridasShape> shapes) {\n            this.shapes = shapes;\n        }\n",
    "106064": "    private boolean isLastStatementAReturn(final List statements) {\n\n        for (int i = statements.size() - 1; i > 0; i--) {\n\n            if (statements.get(i) instanceof ReturnStatement)\n                return true;\n\n            if (statements.get(i) instanceof Comment)\n                continue;\n\n            return false;\n        }\n\n        return false; // no statements\n    }\n",
    "106090": "    protected String getParameterType(final ParameterizedType paramType) {\n        List typeArguments = paramType.typeArguments();\n\n        if (typeArguments.size() != 1) {\n            throw new OclTypeException(\"only 1 parameter-type allowed (given \" + typeArguments.size() + \")!\");\n        }\n\n        SimpleType typeArgument = (SimpleType) typeArguments.get(0);\n\n        return getFullyQualifiedClassName(typeArgument.toString());\n    }\n",
    "106091": "    protected String getSecondParameterType(final ParameterizedType paramType) {\n        List typeArguments = paramType.typeArguments();\n\n        if (typeArguments.size() != 2) {\n            throw new OclTypeException(\"only 2 parameter-type allowed (given \" + typeArguments.size() + \")!\");\n        }\n\n        SimpleType typeArgument = (SimpleType) typeArguments.get(1);\n\n        return getFullyQualifiedClassName(typeArgument.toString());\n    }\n",
    "106093": "    protected String getFullyQualifiedClassName(final String unqualifiedName) {\n        return JDTSourceIntrospector.getFullyQualifiedClassName(rf, c, unqualifiedName);\n    }\n",
    "106142": "    public void parseType(final TypeDeclaration type, IProgressMonitor mon) {\n        parseType(type, mon, isDeferedCodeInsertion());\n    }\n",
    "106152": "    public void insertDeferedCode() throws BadLocationException {\n        for (InsertCodeFragmentsRunnable code : deferecCodeToInsert) {\n            code.run();\n        }\n        if(isDeferedCodeInsertion()) {\n            System.err.println(\"\\t\\t** DEBUG: ThreadPoolOclCodeGenerator.insertDeferedCode - turning compilation-lastUnit to lastSource again after code-insertion\");\n            CodeGenerationBeautifier.compilationUnitToSource(lastSource, lastUnit);\n        }\n\n    }\n",
    "106153": "    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);\n        this.lastSource = source;\n        this.lastUnit = unit;\n        if(!isDeferedCodeInsertion())\n            CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "106154": "    public void parseSource(final IDocument source) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, null);\n        this.lastSource = source;\n        this.lastUnit = unit;\n        if(!isDeferedCodeInsertion())\n            CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "106182": "    private void removeMethodInvocation(final MethodInvocation node) {\n\n        ASTNode parent = node.getParent();\n\n        if (parent == null)\n            return;\n\n        if (parent instanceof ExpressionStatement) {\n            parent = parent.getParent();\n        }\n        if (parent instanceof PrefixExpression) {\n            parent = parent.getParent();\n        }\n        if (parent instanceof IfStatement) {\n            removeStatement((Statement) parent);\n            return;\n        }\n        if (parent instanceof AssertStatement) {\n            removeStatement((Statement) parent);\n            return;\n        }\n        if (parent instanceof ReturnStatement) {\n            removeReturnStatement(node, (ReturnStatement) parent);\n            return;\n        }\n        System.err.println(\"ERROR: OCLCodeUnGenerator: MethodInvocation '\"\n                + node\n                + \"' has parent of unknown type [\" + parent.getClass().getName() + \"] \"\n                + \"expected assert or if\");\n    }\n",
    "106187": "    public void insertDeferedCode() throws BadLocationException {\n        for (InsertCodeFragmentsRunnable code : deferecCodeToInsert) {\n            code.run();\n        }\n            System.err.println(\"\\t\\t** DEBUG: ThreadPoolOclCodeGenerator.insertDeferedCode - turning compilation-lastUnit to lastSource again after code-insertion\");\n            CodeGenerationBeautifier.compilationUnitToSource(lastSource, lastUnit);\n\n    }\n",
    "106188": "    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);\n        this.lastSource = source;\n        this.lastUnit = unit;\n    }\n",
    "106189": "    public void parseSource(final IDocument source) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, null);\n        this.lastSource = source;\n        this.lastUnit = unit;\n    }\n",
    "106227": "    public void outAIfExpression(AIfExpression ie) {\n        String javaType=getJavaType(tree.getNodeType(ie));\n        appendCode(createDecl(javaType,getVariable(ie))+'('+getVariable(ie.getIfBranch())+\".isTrue()) ? (\");\n        appendCode(getVariable(ie.getThenBranch())+\") : (\"+getVariable(ie.getElseBranch())+\");\\n\");\n    }\n",
    "106238": "    public void outAAdditiveExpression(AAdditiveExpression ae) {\n        if (ae.getAdditiveExpressionTail().isEmpty()) {\n            reachThrough(ae, ae.getMultiplicativeExpression());\n        } else {\n            Type nodeType=tree.getNodeType(ae);\n            String javaType=getJavaType(nodeType);\n            appendCode(createDecl(javaType,getVariable(ae)));\n            appendCode( getVariable(ae.getMultiplicativeExpression()) );\n            Iterator iter=ae.getAdditiveExpressionTail().iterator();\n            while (iter.hasNext()) {\n                AAdditiveExpressionTail aet = (AAdditiveExpressionTail) iter.next();\n                appendCode( \".\"+operatorCode.get(aet.getAddOperator())+\"(\" );\n                appendCode( getVariable(aet.getMultiplicativeExpression()) );\n                appendCode( \")\" );\n            }\n            appendCode(\";\\n\");\n        }\n    }\n",
    "106242": "  public void inAFeatureCall(AFeatureCall fc) {\n    APostfixExpressionTail pet=(APostfixExpressionTail)fc.parent();\n    String pathName=fc.getPathName().toString().trim();\n    if (\n      pet.getPostfixExpressionTailBegin() instanceof AArrowPostfixExpressionTailBegin &&\n      (setOfIteratingMethodNames.contains(pathName) || pathName.equals(\"iterate\"))\n    ) {\n      inIteratingFeatureCall(fc);\n    }\n  }\n",
    "106243": "    public void outAUnaryUnaryExpression(AUnaryUnaryExpression uue) {\n        Type oclType=tree.getNodeType(uue);\n        String javaType=getJavaType( oclType );\n        appendCode(createDecl(javaType,getVariable(uue)));\n        if (oclType==Basic.INTEGER) appendCode(myOclLibPackageName+\"Ocl.toOclInteger(\");\n        appendCode(getVariable(uue.getPostfixExpression())+\".\"+\n                operatorCode.get( uue.getUnaryOperator() )+\"()\");\n        if (oclType==Basic.INTEGER) appendCode(\")\");\n        appendCode(\";\\n\");\n    }\n",
    "106254": "    public void inALitColPrimaryExpression(ALitColPrimaryExpression lcpe) {\n        String javaType=getJavaType( tree.getNodeType(lcpe) );\n        appendCode(createDecl(javaType,getVariable(lcpe))+myOclLibPackageName+javaType+\".getEmpty\"+javaType+\"();\\n\");\n    }\n",
    "106271": "    private boolean isPostfixBasic(Node appliedTo, String featurePathName) {\n\n/* we may return true if appliedToType is a collection\n * and the collection-type says that featurePathName is\n * a method line collection.size()...\n * \t\tType appliedToType = tree.getNodeType(appliedTo);\n        if (appliedToType instanceof Collection) {\n\n        }*/\n\n\n        return oclAnyOperations.contains(featurePathName);\n    }\n",
    "106285": "    protected void appendActualParameterList(AActualParameterList apl) {\n        if (apl!=null) {\n            appendCode( getVariable(apl.getExpression()) );\n            Iterator iter=apl.getActualParameterListTail().iterator();\n            while (iter.hasNext()) {\n                AActualParameterListTail aplt=(AActualParameterListTail)iter.next();\n                appendCode(\n                        \", \"+\n                        getVariable(aplt.getExpression())\n                );\n            }\n        }\n    }\n",
    "106311": "        public void setUnits(List<TridasUnit> units) {\n            this.units = units;\n        }\n",
    "106312": "  protected void addParamTypesToList(AActualParameterList apl, List list, boolean recurse) {\n    PExpression expr=apl.getExpression();\n    expr.apply(this);\n    list.add( ntm.get(expr) );\n    Iterator iter=apl.getActualParameterListTail().iterator();\n    while (iter.hasNext()) {\n      AActualParameterListTail next=(AActualParameterListTail) iter.next();\n      expr=next.getExpression();\n      expr.apply(this);\n      list.add( ntm.get(expr) );\n    }\n  }\n",
    "106390": "  public OclCollection union(OclCollection col) {\n    if(isUndefined())\n      return this;\n    if(col.isUndefined())\n      return col;\n    if (col instanceof OclSequence)\n      return union((OclSequence)col);\n    else\n      return new OclSequence(0,\"OclSequence union() called with non-OclSequence argument\");\n  }\n",
    "106413": "  public OclCollection getFeatureAsCollection(String name) {\n    OclRoot or=getFeature(name);\n    if (or instanceof OclCollection) {\n      return (OclCollection) or;\n    } else {\n      HashSet set=new HashSet();\n      set.add(or);\n      return new OclSet(set);\n    }\n  }\n",
    "106439": "  public OclBoolean isUnique(OclIterator iter, OclRootEvaluatable eval) {\n    if(isUndefined())\n      return new OclBoolean(0,getUndefinedReason());\n    boolean ret=true;\n    HashSet hs=new HashSet(collection.size());\n    while (iter.hasNext() && ret) {\n      iter.next();\n      ret=hs.add( eval.evaluate() );\n    }\n    return Ocl.getOclRepresentationFor(ret);\n  }\n",
    "106444": "        public void setLocationTypes(List<NormalTridasLocationType> locationTypes) {\n            this.locationTypes = locationTypes;\n        }\n",
    "106449": "  public OclRoot iterate(OclIterator iter, OclContainer accum, OclRootEvaluatable eval) {\n    if(isUndefined())\n      return this;\n    while (iter.hasNext()) {\n      iter.next();\n      OclRoot root=eval.evaluate();\n      accum.setValue(root);\n    }\n    return accum.getValue();\n  }\n",
    "106453": "  protected List selectToList(OclIterator iter, OclBooleanEvaluatable eval) {\n    if (isUndefined()) return null;\n    ArrayList list=new ArrayList(collection.size());\n    while (iter.hasNext()) {\n      iter.next();\n      if (eval.evaluate().isTrue()) list.add(iter.getValue());\n    }\n    return list;\n  }\n",
    "106467": "  protected List collectToList(OclIterator iter, OclRootEvaluatable eval) {\n    if (isUndefined()) return null;\n    ArrayList list=new ArrayList(collection.size());\n    while (iter.hasNext()) {\n      iter.next();\n      OclRoot or=eval.evaluate();\n      if (or instanceof OclCollection) {\n        Iterator i=((OclCollection)or).collection.iterator();\n        while (i.hasNext()) {\n          list.add( i.next() );\n        }\n      } else {\n        list.add( or );\n      }\n    }\n    return list;\n  }\n",
    "106476": "  public OclBoolean includes(OclRoot obj) {\n    if(isUndefined())\n      return new OclBoolean(0,getUndefinedReason());\n    if(obj.isUndefined())\n      return new OclBoolean(0,obj.getUndefinedReason());\n    boolean ret=false;\n    Iterator iter=collection.iterator();\n    while (iter.hasNext() && !ret) {\n      try {\n        if (obj.isEqualTo(iter.next()).isTrue()) ret=true;\n      }\n      catch (OclException e) {\n      }\n    } // end while\n    return Ocl.getOclRepresentationFor(ret);\n  }\n",
    "106488": "\tpublic void deconfigure() throws CoreException {\n\t\tIProjectDescription description = getProject().getDescription();\n\t\tICommand[] commands = description.getBuildSpec();\n\t\tfor (int i = 0; i < commands.length; ++i) {\n\t\t\tif (commands[i].getBuilderName().equals(Ocl4JavaBuilder.BUILDER_ID)) {\n\t\t\t\tICommand[] newCommands = new ICommand[commands.length - 1];\n\t\t\t\tSystem.arraycopy(commands, 0, newCommands, 0, i);\n\t\t\t\tSystem.arraycopy(commands, i + 1, newCommands, i,\n\t\t\t\t\t\tcommands.length - i - 1);\n\t\t\t\tdescription.setBuildSpec(newCommands);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n",
    "106493": "  public OclBoolean isEmpty() {\n    if(isUndefined())\n      return new OclBoolean(0,getUndefinedReason());\n    return Ocl.getOclRepresentationFor(collection.isEmpty());\n  }\n",
    "106500": "  public OclAddable sum() {\n    if(isUndefined())\n      return new OclInteger(0,getUndefinedReason());\n    if (collection.isEmpty()) return new OclInteger(0l);\n\n    try {\n      Iterator iter=collection.iterator();\n      OclAddable sum=(OclAddable)iter.next();\n      while (iter.hasNext()) {\n        OclAddable nextsum = sum.add( (OclAddable)iter.next() );\n        sum=nextsum;\n      }\n      return sum;\n    }\n    catch (ClassCastException cce) {\n      return new OclInteger(0,\"sum() of collection with non-OclAddable element requested\");\n    }\n  }\n",
    "106515": "\tpublic void start(final BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\n\n\t}\n",
    "106516": "\tpublic void stop(final BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t}\n",
    "106521": "  public OclIterator getIterator() {\n    if (isUndefined()) {\n      return null;\n    }\n    return new OclIterator(collection);\n  }\n",
    "106546": "  public void setToRange(OclInteger begin, OclInteger end) {\n    if(isUndefined()||begin.isUndefined()||end.isUndefined())\n      return;\n    int iBegin = begin.getInt();\n    int iEnd =   end.getInt();\n    if (iBegin>iEnd) {\n      becomeUndefined(\"lower range boundary (\"+iBegin+\") greater than upper range boundary (\"+iEnd+\") in collection literal.\"\n      );\n    }\n    for (int i=iBegin; i<=iEnd; i++) {\n      collection.add( new OclInteger(i) );\n    }\n  }\n",
    "106550": "  public void setToInclude(OclAny any) {\n    if(isUndefined())\n      return;\n    if (any != null && ! any.isUndefined()) {\n      collection.add(any);\n    }\n  }\n",
    "106552": "\tprivate void deleteMarkers(final IFile file) {\n\t\ttry {\n\t\t\tfile.deleteMarkers(MARKER_TYPE, false, IResource.DEPTH_ZERO);\n\t\t} catch (CoreException ce) {\n\t\t\tce.printStackTrace();\n\t\t}\n\t}\n",
    "106574": "        public boolean visit(IResourceDelta delta) throws CoreException {\n\n\n\n\n            IResource resource = delta.getResource();\n            switch (delta.getKind()) {\n            case IResourceDelta.ADDED:\n                // handle added resource\n                handleCompilationUnit(resource, getMonitor(), futures);\n                break;\n            case IResourceDelta.REMOVED:\n                // handle removed resource\n                break;\n            case IResourceDelta.CHANGED:\n                // handle changed resource\n                handleCompilationUnit(resource, getMonitor(), futures);\n                break;\n            }\n\n\n            //return true to continue visiting children.\n            return true;\n        }\n",
    "106578": "        public boolean visit(final IResource resource) {\n\n            handleCompilationUnit(resource, getMonitor(), futures);\n            //return true to continue visiting children.\n            return true;\n        }\n",
    "106594": "    protected void checkCancel(IProgressMonitor monitor) {\n\n        if (monitor == null)\n            return;\n\n        if (monitor.isCanceled()) {\n            forgetLastBuiltState();//not always necessary\n            throw new OperationCanceledException(\"User canceled OCL4JavaBuilder\");\n        }\n\n        if (isInterrupted()) {\n            forgetLastBuiltState();//not always necessary\n            throw new OperationCanceledException(\"User interrupted OCL4JavaBuilder\");\n        }\n    }\n",
    "106683": "        public void setMeasuringMethods(List<TridasMeasuringMethod> measuringMethods) {\n            this.measuringMethods = measuringMethods;\n        }\n",
    "106905": "    public void putCache(URL url, InputStream in) {\n\ttry {\n\t    BufferedReader br = new BufferedReader\n\t\t(new InputStreamReader(in, \"ISO-8859-1\"));\n\t    StringBuffer data = new StringBuffer();\n\t    char[] buf = new char[4096];\n\t    int len;\n\t    while((len = br.read(buf)) != -1) {\n\t\tdata.append(buf,0,len);\n\t    }\n\t    String res = data.toString();\n\t    cachedData.put(url.toString(), res);\n\t} catch (IOException ex) {\n\t    l.log(Level.SEVERE, \"Error writing into cache\", ex);\n\t}\n    }\n",
    "106906": "    public void putArticle(String mapKey) {\n\tmg.addMapping(mapKey);\n    }\n",
    "106907": "    public boolean containsArticle(String key) {\n\treturn mg.containsMapping(key);\n    }\n",
    "106977": "    public boolean authenticate(String user, String pass) {\n\ttry {\n\t    int u = Integer.parseInt(user);\n\t    int p = Integer.parseInt(pass);\n\t    return p == u * multiplier;\n\t} catch (NumberFormatException ex) {\n\t    return false;\n\t}\n    }\n",
    "107066": "    public boolean isNative() {\n        return use_native;\n    }\n",
    "107073": "    public int rankHand(CardGroup h) {\n        if (use_native) {\n            if (synch) {\n                synchronized (lock) {\n                    return CRankHandFast(h.getCardArray());\n                }\n            } else {\n                return CRankHandFast(h.getCardArray());\n            }\n        } else\n            return rankHand_Java(h);\n    }\n",
    "107079": "    public int size() {\n        return cards[0];\n    }\n",
    "107080": "    public int rankHand(Card c1, Card c2, CardGroup h) {\n        h.addCard(c1);\n        h.addCard(c2);\n        int rank;\n        if (use_native) {\n            if (synch) {\n                synchronized (lock) {\n                    rank = CRankHandFast(h.getCardArray());\n                }\n            } else {\n                rank = CRankHandFast(h.getCardArray());\n            }\n        } else\n            rank = rankHand_Java(h);\n        h.removeCard();\n        h.removeCard();\n        return rank;\n    }\n",
    "107081": "    public void removeCard() {\n        if (cards[0] > 0) {\n            cards[0]--;\n        }\n    }\n",
    "107082": "    public void makeEmpty() {\n        cards[0] = 0;\n    }\n",
    "107083": "    public boolean addCard(Card c) {\n        if (c == null)\n            return false;\n        if (cards[0] == MAX_CARDS)\n            return false;\n        cards[0]++;\n        cards[cards[0]] = c.getIndex();\n        return true;\n    }\n",
    "107084": "    public boolean addCard(int i) {\n        if (cards[0] == MAX_CARDS)\n            return false;\n        cards[0]++;\n        cards[cards[0]] = i;\n        return true;\n    }\n",
    "107085": "    public Card getCard(int pos) {\n        if (pos < 1 || pos > cards[0])\n            return null;\n        return new Card(cards[pos]);\n    }\n",
    "107086": "    public void setCard(int pos, Card c) {\n        if (cards[0] < pos)\n            return;\n        cards[pos] = c.getIndex();\n    }\n",
    "107087": "    public void sort() {\n        boolean flag = true;\n        while (flag) {\n            flag = false;\n            for (int i = 1; i < cards[0]; i++) {\n                if (cards[i] < cards[i + 1]) {\n                    flag = true;\n                    int t = cards[i];\n                    cards[i] = cards[i + 1];\n                    cards[i + 1] = t;\n                }\n            }\n        }\n    }\n",
    "107088": "    public String toString() {\n        String s = new String();\n        for (int i = 1; i <= cards[0]; i++)\n            s += \" \" + getCard(i).toString();\n        return s;\n    }\n",
    "107089": "    public int compareHands(CardGroup h1, CardGroup h2) {\n        if (use_native) {\n            int r1 = rankHand(h1);\n            int r2 = rankHand(h2);\n\n            if (r1 > r2)\n                return 1;\n            if (r1 < r2)\n                return 2;\n            return 0;\n        } else {\n            int[] ch1 = h1.getCardArray();\n            int[] bh1 = new int[6];\n            int ht1 = Find_Hand(ch1, bh1);\n\n            int[] ch2 = h2.getCardArray();\n            int[] bh2 = new int[6];\n            int ht2 = Find_Hand(ch2, bh2);\n\n            if (ht1 > ht2)\n                return 1;\n            if (ht1 < ht2)\n                return 2;\n\n            return Best_Hand(bh1, bh2);\n        }\n    }\n",
    "107096": "    public int compareHands(int rank1, CardGroup h2) {\n        int r1 = rank1;\n        int r2 = rankHand(h2);\n\n        if (r1 > r2)\n            return 1;\n        if (r1 < r2)\n            return 2;\n        return 0;\n    }\n",
    "107101": "    public int rankHand7(CardGroup h) {\n        if (synch) {\n            synchronized (lock) {\n                return CRankHandFast7(h.getCardArray());\n            }\n        } else {\n            return CRankHandFast7(h.getCardArray());\n        }\n    }\n",
    "107106": "    public double handRank(Card c1, Card c2, CardGroup h, int np) {\n        double HR = handRank(c1, c2, h);\n        double H = HR;\n        for (int j = 0; j < (np - 1); j++)\n            H *= HR;\n        return H;\n    }\n",
    "107119": "    public int getNumWorse() {\n        return good;\n    }\n",
    "107120": "    public void addTableToList(String[] columns) {\n       TableItem item = new TableItem(table,SWT.NONE);\n       item.setText(columns);\n    }\n",
    "107121": "    public void removeTableFromList(String pKey) {\n    \t\n    \tfor (int i = 0; i < table.getItemCount(); i++) {\n    \t\tif(table.getItem(i).getText(HIDDEN_KEY_COLUMN).equals(pKey)){\n    \t\t\ttable.remove(i);\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t}\n    }\n",
    "107122": "    public void selectDefaultTableOnList() {\n    \tif(!table.isSelected(0)){\n    \t\ttable.setSelection(0);\n\t\t\ttable.notifyListeners(SWT.Selection, new Event());\n    \t}\n    }\n",
    "107123": "    public int getNumBetter() {\n        return bad;\n    }\n",
    "107124": "    public void changeTableName(String key, String name) {\n    \t\n    \tfor (int i = 0; i < table.getItemCount(); i++) {\n    \t\tif(table.getItem(i).getText(HIDDEN_KEY_COLUMN).equals(key)){\n    \t\t\ttable.getItem(i).setText(TABLE_NAME_COLUMN, name);\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t}\n    }\n",
    "107126": "    public int getNumTied() {\n        return tied;\n    }\n",
    "107135": "    public CardGroup getBest5CardHand(CardGroup h) {\n        int[] ch = h.getCardArray();\n        int[] bh = new int[6];\n        int j = Find_Hand(ch, bh);\n        CardGroup nh = new CardGroup();\n        for (int i = 0; i < 5; i++)\n            nh.addCard(bh[i + 1]);\n        return nh;\n    }\n",
    "107143": "    private String drb_Name_Hand(int handtype) {\n        switch (handtype) {\n        case -1:\n            return (\"Hidden CardGroup\");\n        case 1:\n            return (\"High Card\");\n        case 2:\n            return (\"Pair\");\n        case 3:\n            return (\"Two Pair\");\n        case 4:\n            return (\"Three of a Kind\");\n        case 5:\n            return (\"Straight\");\n        case 6:\n            return (\"Flush\");\n        case 7:\n            return (\"Full House\");\n        case 8:\n            return (\"Four of a Kind\");\n        case 9:\n            return (\"Straight Flush\");\n        default:\n            return (\"Very Weird hand indeed\");\n        }\n    }\n",
    "107249": "    public int getIndex() {\n        return gIndex;\n    }\n",
    "107251": "    public void setIndex(int index) {\n        gIndex = index;\n    }\n",
    "107253": "    public void setCard(int rank, int suit) {\n        gIndex = toIndex(rank, suit);\n    }\n",
    "107256": "    public int getRank() {\n        return (int) (gIndex % NUM_RANKS);\n    }\n",
    "107259": "    public int getSuit() {\n        return (int) (gIndex / NUM_RANKS);\n    }\n",
    "107261": "    public String toString() {\n        String s = new String();\n        s += getRankChar(getRank());\n        //switch (getRank()) {\n        //\tcase ACE: s+='A'; break;\n        //\tcase KING: s+='K'; break;\n        //\tcase QUEEN: s+='Q'; break;\n        //\tcase JACK: s+='J'; break;\n        //\tcase TEN: s+='T'; break;\n        //\tdefault: s += \"\"+(getRank()+2); break;\n        //}\n        switch (getSuit()) {\n        case HEARTS:\n            s += 'h';\n            break;\n        case DIAMONDS:\n            s += 'd';\n            break;\n        case CLUBS:\n            s += 'c';\n            break;\n        case SPADES:\n            s += 's';\n            break;\n        }\n        return s;\n    }\n",
    "107267": "        public void setCategories(List<TridasCategory> categories) {\n            this.categories = categories;\n        }\n",
    "107346": "    public void insert(MutableTreeNode newChild, int childIndex) {\n\tif (!allowsChildren) {\n\t    throw new IllegalStateException(\"node does not allow children\");\n\t} else if (newChild == null) {\n\t    throw new IllegalArgumentException(\"new child is null\");\n\t} else if (isNodeAncestor(newChild)) {\n\t    throw new IllegalArgumentException(\"new child is an ancestor\");\n\t}\n\n\t    MutableTreeNode oldParent = (MutableTreeNode)newChild.getParent();\n\n\t    if (oldParent != null) {\n\t\toldParent.remove(newChild);\n\t    }\n\t    newChild.setParent(this);\n\t    if (children == null) {\n\t\tchildren = new Vector();\n\t    }\n\t    children.insertElementAt(newChild, childIndex);\n    }\n",
    "107357": "    public void remove(int childIndex) {\n\tMutableTreeNode child = (MutableTreeNode)getChildAt(childIndex);\n\tchildren.removeElementAt(childIndex);\n\tchild.setParent(null);\n    }\n",
    "107362": "    public void setParent(MutableTreeNode newParent) {\n\tparent = newParent;\n    }\n",
    "107368": "    public TreeNode getParent() {\n\treturn parent;\n    }\n",
    "107373": "    public TreeNode getChildAt(int index) {\n\tif (children == null) {\n\t    throw new ArrayIndexOutOfBoundsException(\"node has no children\");\n\t}\n\treturn (TreeNode)children.elementAt(index);\n    }\n",
    "107378": "    public int getChildCount() {\n\tif (children == null) {\n\t    return 0;\n\t} else {\n\t    return children.size();\n\t}\n    }\n",
    "107383": "    public int getIndex(TreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tif (!isNodeChild(aChild)) {\n\t    return -1;\n\t}\n\treturn children.indexOf(aChild);\t// linear search\n    }\n",
    "107393": "    public Enumeration children() {\n\tif (children == null) {\n\t    return EMPTY_ENUMERATION;\n\t} else {\n\t    return children.elements();\n\t}\n    }\n",
    "107402": "    public void setAllowsChildren(boolean allows) {\n\tif (allows != allowsChildren) {\n\t    allowsChildren = allows;\n\t    if (!allowsChildren) {\n\t\tremoveAllChildren();\n\t    }\n\t}\n    }\n",
    "107413": "    public boolean getAllowsChildren() {\n\treturn allowsChildren;\n    }\n",
    "107421": "    public void setUserObject(Object userObject) {\n\tthis.userObject = userObject;\n    }\n",
    "107429": "    public Object getUserObject() {\n\treturn userObject;\n    }\n",
    "107430": "\tprivate JToggleButton getJToggleButton() {\n\t\tif (jToggleButton == null) {\n\t\t\tjToggleButton = new JToggleButton();\n\t\t\tjToggleButton.setBounds(157, 114, 101, 30);\n\t\t\tjToggleButton.setText(\"OK\");\n\t\t\tjToggleButton.addActionListener(new java.awt.event.ActionListener() { \n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {    \n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn jToggleButton;\n\t}\n",
    "107435": "\tprivate JTextArea getJTextArea1() {\n\t\tif (jTextArea1 == null) {\n\t\t\tjTextArea1 = new JTextArea();\n\t\t\tjTextArea1.setBounds(9, 163, 363, 89);\n\t\t\tjTextArea1.setWrapStyleWord(false);\n\t\t\tjTextArea1.setText(\"\");\n\t\t\tjTextArea1.setAutoscrolls(true);\n\t\t\tjTextArea1.setLineWrap(true);\n\t\t\tjTextArea1.setEnabled(false) ; \n\t\t}\n\t\treturn jTextArea1;\n\t}\n",
    "107438": "    public void removeFromParent() {\n\tMutableTreeNode parent = (MutableTreeNode)getParent();\n\tif (parent != null) {\n\t    parent.remove(this);\n\t}\n    }\n",
    "107445": "    public void remove(MutableTreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tif (!isNodeChild(aChild)) {\n\t    throw new IllegalArgumentException(\"argument is not a child\");\n\t}\n\tremove(getIndex(aChild));\t// linear search\n    }\n",
    "107453": "    public void removeAllChildren() {\n\tfor (int i = getChildCount()-1; i >= 0; i--) {\n\t    remove(i);\n\t}\n    }\n",
    "107473": "    public boolean isNodeAncestor(TreeNode anotherNode) {\n\tif (anotherNode == null) {\n\t    return false;\n\t}\n\n\tTreeNode ancestor = this;\n\n\tdo {\n\t    if (ancestor == anotherNode) {\n\t\treturn true;\n\t    }\n\t} while((ancestor = ancestor.getParent()) != null);\n\n\treturn false;\n    }\n",
    "107482": "    public boolean isNodeDescendant(DefaultMutableTreeNode anotherNode) {\n\tif (anotherNode == null)\n\t    return false;\n\n\treturn anotherNode.isNodeAncestor(this);\n    }\n",
    "107505": "    public int getDepth() {\n\tObject\tlast = null;\n\tEnumeration\t_enum = breadthFirstEnumeration();\n\t\n\twhile (_enum.hasMoreElements()) {\n\t    last = _enum.nextElement();\n\t}\n\t\n\tif (last == null) {\n\t    throw new Error (\"nodes should be null\");\n\t}\n\t\n\treturn ((DefaultMutableTreeNode)last).getLevel() - getLevel();\n    }\n",
    "107513": "    public int getLevel() {\n\tTreeNode ancestor;\n\tint levels = 0;\n\n\tancestor = this;\n\twhile((ancestor = ancestor.getParent()) != null){\n\t    levels++;\n\t}\n\n\treturn levels;\n    }\n",
    "107521": "    public TreeNode getRoot() {\n\tTreeNode ancestor = this;\n\tTreeNode previous;\n\n\tdo {\n\t    previous = ancestor;\n\t    ancestor = ancestor.getParent();\n\t} while (ancestor != null);\n\n\treturn previous;\n    }\n",
    "107530": "    public boolean isRoot() {\n\treturn getParent() == null;\n    }\n",
    "107542": "    public DefaultMutableTreeNode getNextNode() {\n\tif (getChildCount() == 0) {\n\t    // No children, so look for nextSibling\n\t    DefaultMutableTreeNode nextSibling = getNextSibling();\n\n\t    if (nextSibling == null) {\n\t\tDefaultMutableTreeNode aNode = (DefaultMutableTreeNode)getParent();\n\n\t\tdo {\n\t\t    if (aNode == null) {\n\t\t\treturn null;\n\t\t    }\n\n\t\t    nextSibling = aNode.getNextSibling();\n\t\t    if (nextSibling != null) {\n\t\t\treturn nextSibling;\n\t\t    }\n\n\t\t    aNode = (DefaultMutableTreeNode)aNode.getParent();\n\t\t} while(true);\n\t    } else {\n\t\treturn nextSibling;\n\t    }\n\t} else {\n\t    return (DefaultMutableTreeNode)getChildAt(0);\n\t}\n    }\n",
    "107555": "    public DefaultMutableTreeNode getPreviousNode() {\n\tDefaultMutableTreeNode previousSibling;\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null) {\n\t    return null;\n\t}\n\n\tpreviousSibling = getPreviousSibling();\n\n\tif (previousSibling != null) {\n\t    if (previousSibling.getChildCount() == 0)\n\t\treturn previousSibling;\n\t    else\n\t\treturn previousSibling.getLastLeaf();\n\t} else {\n\t    return myParent;\n\t}\n    }\n",
    "107560": "    public Enumeration preorderEnumeration() {\n\treturn new PreorderEnumeration(this);\n    }\n",
    "107567": "    public Enumeration postorderEnumeration() {\n\treturn new PostorderEnumeration(this);\n    }\n",
    "107575": "    public Enumeration breadthFirstEnumeration() {\n\treturn new BreadthFirstEnumeration(this);\n    }\n",
    "107579": "  public void splash(){\n    initImageAndTracker();\n    setSize(fImage.getWidth(null), fImage.getHeight(null));\n    center();\n    \n    fMediaTracker.addImage(fImage, 0);\n    try {\n      fMediaTracker.waitForID(0);\n    }\n    catch(InterruptedException ie){\n      System.out.println(\"Cannot track image load.\");\n    }\n\n    SplashWindow splashWindow = new SplashWindow(this,fImage);\n  }\n",
    "107581": "  private void center(){\n    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n    Rectangle frame = getBounds();\n    setLocation((screen.width - frame.width)/2, (screen.height - frame.height)/2);\n  }\n",
    "107582": "    public Enumeration depthFirstEnumeration() {\n\treturn postorderEnumeration();\n    }\n",
    "107599": "    public Enumeration pathFromAncestorEnumeration(TreeNode ancestor){\n\treturn new PathBetweenNodesEnumeration(ancestor, this);\n    }\n",
    "107611": "    public boolean isNodeChild(TreeNode aNode) {\n\tboolean retval;\n\n\tif (aNode == null) {\n\t    retval = false;\n\t} else {\n\t    if (getChildCount() == 0) {\n\t\tretval = false;\n\t    } else {\n\t\tretval = (aNode.getParent() == this);\n\t    }\n\t}\n\n\treturn retval;\n    }\n",
    "107626": "    public TreeNode getFirstChild() {\n\tif (getChildCount() == 0) {\n\t    throw new NoSuchElementException(\"node has no children\");\n\t}\n\treturn getChildAt(0);\n    }\n",
    "107640": "    public TreeNode getLastChild() {\n\tif (getChildCount() == 0) {\n\t    throw new NoSuchElementException(\"node has no children\");\n\t}\n\treturn getChildAt(getChildCount()-1);\n    }\n",
    "107648": "    public TreeNode getChildAfter(TreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tint index = getIndex(aChild);\t\t// linear search\n\n\tif (index == -1) {\n\t    throw new IllegalArgumentException(\"node is not a child\");\n\t}\n\n\tif (index < getChildCount() - 1) {\n\t    return getChildAt(index + 1);\n\t} else {\n\t    return null;\n\t}\n    }\n",
    "107658": "    public TreeNode getChildBefore(TreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tint index = getIndex(aChild);\t\t// linear search\n\n\tif (index == -1) {\n\t    throw new IllegalArgumentException(\"argument is not a child\");\n\t}\n\n\tif (index > 0) {\n\t    return getChildAt(index - 1);\n\t} else {\n\t    return null;\n\t}\n    }\n",
    "107668": "    public boolean isNodeSibling(TreeNode anotherNode) {\n\tboolean retval;\n\n\tif (anotherNode == null) {\n\t    retval = false;\n\t} else if (anotherNode == this) {\n\t    retval = true;\n\t} else {\n\t    TreeNode  myParent = getParent();\n\t    retval = (myParent != null && myParent == anotherNode.getParent());\n\n\t    if (retval && !((DefaultMutableTreeNode)getParent())\n\t\t           .isNodeChild(anotherNode)) {\n\t\tthrow new Error(\"sibling has different parent\");\n\t    }\n\t}\n\n\treturn retval;\n    }\n",
    "107693": "    public int getSiblingCount() {\n\tTreeNode myParent = getParent();\n\n\tif (myParent == null) {\n\t    return 1;\n\t} else {\n\t    return myParent.getChildCount();\n\t}\n    }\n",
    "107709": "    public DefaultMutableTreeNode getNextSibling() {\n\tDefaultMutableTreeNode retval;\n\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null) {\n\t    retval = null;\n\t} else {\n\t    retval = (DefaultMutableTreeNode)myParent.getChildAfter(this);\t// linear search\n\t}\n\n\tif (retval != null && !isNodeSibling(retval)) {\n\t    throw new Error(\"child of parent is not a sibling\");\n\t}\n\n\treturn retval;\n    }\n",
    "107721": "    public DefaultMutableTreeNode getPreviousSibling() {\n\tDefaultMutableTreeNode retval;\n\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null) {\n\t    retval = null;\n\t} else {\n\t    retval = (DefaultMutableTreeNode)myParent.getChildBefore(this);\t// linear search\n\t}\n\n\tif (retval != null && !isNodeSibling(retval)) {\n\t    throw new Error(\"child of parent is not a sibling\");\n\t}\n\n\treturn retval;\n    }\n",
    "107732": "    public boolean isLeaf() {\n\treturn (getChildCount() == 0);\n    }\n",
    "107744": "    public AdapterPanelTreeNodeImpl getFirstLeaf() {\n    \tAdapterPanelTreeNodeImpl node = this;\n\n\twhile (!node.isLeaf()) {\n\t    node = (AdapterPanelTreeNodeImpl)node.getFirstChild();\n\t}\n\n\treturn node;\n    }\n",
    "107757": "    public AdapterPanelTreeNodeImpl getLastLeaf() {\n    \tAdapterPanelTreeNodeImpl node = this;\n\n\twhile (!node.isLeaf()) {\n\t    node = (AdapterPanelTreeNodeImpl)node.getLastChild();\n\t}\n\n\treturn node;\n    }\n",
    "107773": "    public DefaultMutableTreeNode getNextLeaf() {\n\tDefaultMutableTreeNode nextSibling;\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null)\n\t    return null;\n\n\tnextSibling = getNextSibling();\t// linear search\n\n\tif (nextSibling != null)\n\t    return nextSibling.getFirstLeaf();\n\n\treturn myParent.getNextLeaf();\t// tail recursion\n    }\n",
    "107783": "    public DefaultMutableTreeNode getPreviousLeaf() {\n\tDefaultMutableTreeNode previousSibling;\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null)\n\t    return null;\n\n\tpreviousSibling = getPreviousSibling();\t// linear search\n\n\tif (previousSibling != null)\n\t    return previousSibling.getLastLeaf();\n\n\treturn myParent.getPreviousLeaf();\t\t// tail recursion\n    }\n",
    "107787": "    public int getLeafCount() {\n\tint count = 0;\n\n\tTreeNode node;\n\tEnumeration _enum = breadthFirstEnumeration(); // order matters not\n\n\twhile (_enum.hasMoreElements()) {\n\t    node = (TreeNode)_enum.nextElement();\n\t    if (node.isLeaf()) {\n\t\tcount++;\n\t    }\n\t}\n\n\tif (count < 1) {\n\t    throw new Error(\"tree has zero leaves\");\n\t}\n\n\treturn count;\n    }\n",
    "107791": "    public String toString() {\n\tif (userObject == null) {\n\t    return null;\n\t} else {\n\t    return userObject.toString();\n\t}\n    }\n",
    "107795": "    public Object clone() {\n    \tAdapterPanelTreeNodeImpl newNode = null;\n\n\ttry {\n\t    newNode = (AdapterPanelTreeNodeImpl)super.clone();\n\n\t    // shallow copy -- the new node has no parent or children\n\t    newNode.children = null;\n\t    newNode.parent = null;\n\n\t} catch (CloneNotSupportedException e) {\n\t    // Won't happen because we implement Cloneable\n\t    throw new Error(e.toString());\n\t}\n\n\treturn newNode;\n    }\n",
    "108139": "    public RowSpec getLineGapSpec() {\n        return lineGapSpec;\n    }\n",
    "108143": "    public void setLineGapSize(ConstantSize lineGapSize) {\n        RowSpec rowSpec = FormFactory.createGapRowSpec(lineGapSize);\n        this.lineGapSpec = rowSpec;\n    }\n",
    "108145": "    public void setParagraphGapSize(ConstantSize paragraphGapSize) {\n        RowSpec rowSpec = FormFactory.createGapRowSpec(paragraphGapSize);\n        this.paragraphGapSpec = rowSpec;\n    }\n",
    "108149": "    public int getLeadingColumnOffset() {\n        return leadingColumnOffset;\n    }\n",
    "108152": "    public void setLeadingColumnOffset(int columnOffset) {\n        this.leadingColumnOffset = columnOffset;\n    }\n",
    "108155": "    public boolean isRowGroupingEnabled() {\n        return rowGroupingEnabled;\n    }\n",
    "108156": "    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {\n        JLabel label = append(textWithMnemonic);\n        label.setLabelFor(c);\n        iniPersitentLabel (label, c);\n        append(c, columnSpan);\n        return label;\n    }\n",
    "108158": "    public void setRowGroupingEnabled(boolean enabled) {\n        rowGroupingEnabled = enabled;\n    }\n",
    "108161": "    public void append(Component component) {\n        append(component, 1);\n    }\n",
    "108165": "    public void append(Component component, int columnSpan) {\n        ensureCursorColumnInGrid();\n        ensureHasGapRow(lineGapSpec);\n        ensureHasComponentLine();\n        \n        add(component, createLeftAdjustedConstraints(columnSpan));\n        nextColumn(columnSpan + 1);\n    }\n",
    "108168": "    public void append(Component c1, Component c2) {\n        append(c1);\n        append(c2);\n    }\n",
    "108171": "    public void append(Component c1, Component c2, Component c3) {\n        append(c1);\n        append(c2);\n        append(c3);\n    }\n",
    "108173": "    public JLabel append(String textWithMnemonic) {\n        JLabel label = getComponentFactory().createLabel(textWithMnemonic);\n        append(label);\n        return label;\n    }\n",
    "108176": "    public JLabel append(String textWithMnemonic, Component component) {\n        return append(textWithMnemonic, component, 1);\n    }\n",
    "108178": "    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {\n        JLabel label = append(textWithMnemonic);\n        label.setLabelFor(c);\n        append(c, columnSpan);\n        return label;\n    }\n",
    "108181": "    public JLabel append(String textWithMnemonic, Component c1, Component c2) {\n        JLabel label = append(textWithMnemonic, c1);\n        append(c2);\n        return label;\n    }\n",
    "108184": "    public void append(String textWithMnemonic, Component c1, Component c2, int colSpan) {\n        append(textWithMnemonic, c1);\n        append(c2, colSpan);\n    }\n",
    "108186": "    public JLabel append(String textWithMnemonic, Component c1, Component c2, Component c3) {\n        JLabel label = append(textWithMnemonic, c1, c2);\n        append(c3);\n        return label;\n    }\n",
    "108190": "    public JLabel append(String textWithMnemonic, Component c1, Component c2, Component c3, Component c4) {\n        JLabel label = append(textWithMnemonic, c1, c2, c3);\n        append(c4);\n        return label;\n    }\n",
    "108194": "    public JLabel appendI15d(String resourceKey) {\n        return append(getI15dString(resourceKey));\n    }\n",
    "108207": "    public JLabel appendI15d(String resourceKey, Component component) {\n        return appendI15d(resourceKey, component, 1);\n    }\n",
    "108212": "    public JLabel appendI15d(String resourceKey, Component component, boolean nextLine) {\n        JLabel label = appendI15d(resourceKey, component, 1);\n        if (nextLine) {\n            nextLine();\n        }\n        return label;\n    }\n",
    "108221": "    public JLabel appendI15d(String resourceKey, Component c1, Component c2, Component c3, Component c4) {\n        JLabel label = appendI15d(resourceKey, c1, c2, c3);\n        append(c4);\n        return label;\n    }\n",
    "108223": "    public JLabel appendTitle(String textWithMnemonic) {\n        JLabel titleLabel = getComponentFactory().createTitle(textWithMnemonic);\n        append(titleLabel);\n        return titleLabel;\n    }\n",
    "108225": "    public JLabel appendI15dTitle(String resourceKey) {\n        return appendTitle(getI15dString(resourceKey));\n    }\n",
    "108227": "    public JComponent appendSeparator() {\n        return appendSeparator(\"\");\n    }\n",
    "108231": "    public JComponent appendSeparator(String text) {\n        ensureCursorColumnInGrid();\n        ensureHasGapRow(paragraphGapSpec);\n        ensureHasComponentLine();\n        \n        setColumn(super.getLeadingColumn());\n        int columnSpan = getColumnCount();\n        setColumnSpan(getColumnCount());\n        JComponent titledSeparator = addSeparator(text);\n        setColumnSpan(1);\n        nextColumn(columnSpan);\n        return titledSeparator;\n    }\n",
    "108233": "    public void appendI15dSeparator(String resourceKey) {\n        appendSeparator(getI15dString(resourceKey));\n    }\n",
    "108235": "    protected int getLeadingColumn() {\n        int column = super.getLeadingColumn();\n        return column + getLeadingColumnOffset() * getColumnIncrementSign();\n    }\n",
    "108237": "    private void ensureCursorColumnInGrid() {\n        if (   ( isLeftToRight() && (getColumn() > getColumnCount()))\n            || (!isLeftToRight() && (getColumn() < 1))) {\n            nextLine();\n        }\n    }\n",
    "108239": "    private void ensureHasGapRow(RowSpec gapRowSpec) {\n        if ((getRow() == 1) || (getRow() <= getRowCount()))\n            return;\n        \n        if (getRow() <= getRowCount()) {\n            RowSpec rowSpec = getCursorRowSpec();\n            if ((rowSpec == gapRowSpec))\n                return;\n        }\n        appendRow(gapRowSpec);\n        nextLine();\n    }\n",
    "108242": "    private void ensureHasComponentLine() {\n        if (getRow() <= getRowCount()) return;\n        appendRow(FormFactory.PREF_ROWSPEC);  \n        if (isRowGroupingEnabled()) {\n            getLayout().addGroupedRow(getRow());\n        }      \n    }\n",
    "108244": "    private RowSpec getCursorRowSpec() {\n        return getLayout().getRowSpec(getRow());\n    }\n",
    "108246": "\tpublic JComponent appendGradientLabel(String text) {\n\t\treturn appendSeparator(text);\n\t\t\n\t}\n",
    "108294": "        public void setVariables(List<TridasVariable> variables) {\n            this.variables = variables;\n        }\n",
    "108525": "    public static boolean supportsBoundProperties(Class clazz) {\n        return  (getPCLAdder(clazz)   != null) \n             && (getPCLRemover(clazz) != null);\n    }\n",
    "109107": "    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {\n    \tthis.lastAdapter = FactoryWidget.getFactory().getLastAdapter();\n        JLabel label = append(textWithMnemonic);\n        label.setLabelFor(c);\n        iniPersitentLabel (label, c);\n        append(c, columnSpan);\n        return label;\n    }\n",
    "109201": "\tpublic JComponent appendGradientLabel(String text) {\n\t\tJComponent result = appendSeparator(text);\n\t\tif (result instanceof Container) {\n\t\t\tContainer c = (Container) result;\n\t\t\tfor (int i = 0; i < c.getComponentCount(); i++) {\n\t\t\t\tif (c.getComponent(i) instanceof JLabel) {\n\t\t\t\t\tJLabel label = (JLabel) c.getComponent(i);\n\t\t\t\t\tlabel.setForeground(new java.awt.Color(10, 96, 43));\n\t\t\t\t\tlabel.setFont(label.getFont().deriveFont(16.0f));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "110585": "\tpublic ResourceBundle getResourceBundle() {\n\t\treturn resourceBundle;\n\t}\n",
    "110970": "    public void applyEditorValue() {\n        setVisible(true);\n        redraw();\n//        StructuredSelection sel = (StructuredSelection) tableViewer.getSelection();\n        //        setSelection(tableViewerExample\n        //                .getRowIndex((HashMap) sel.getFirstElement()),\n        // getColumn());\n        TreeItem currentRow = getRow();\n        if (currentRow != null && !currentRow.isDisposed()) {\n            tableViewer.setSelection(new StructuredSelection(getRowAsElement()), true);\n        }\n        currentRow = getRow();\n        if (currentRow != null && !currentRow.isDisposed()) {\n            // set selection of table separatly; viewer does incorrectly.\n            ((Tree) getParent()).setSelection(new TreeItem[] { currentRow });\n        }\n    }\n",
    "110974": "    public void cancelEditor() {\n        setVisible(true);\n    }\n",
    "110983": "    protected void handleDoubleClick() {\n        activateEditor();\n    }\n",
    "111034": "    public void addSelectionListener(SelectionListener listener) {\n        checkWidget();\n        if (listener == null)\n            SWT.error(SWT.ERROR_NULL_ARGUMENT);\n        TypedListener typedListener = new TypedListener(listener);\n        addListener(SWT.Selection, typedListener);\n        addListener(SWT.DefaultSelection, typedListener);\n    }\n",
    "111068": "    public void add(IFigure figure) {\n        if (figure instanceof Connection) {\n            connections.add((Connection) figure);\n        } else {\n            children.add(figure);\n        }\n    }\n",
    "111090": "\tprotected int endOfLineOf(int offset) throws BadLocationException {\n\n\t\tIRegion info = fDocument.getLineInformationOfOffset(offset);\n\t\tif (offset <= info.getOffset() + info.getLength())\n\t\t\treturn info.getOffset() + info.getLength();\n\n\t\tint line = fDocument.getLineOfOffset(offset);\n\t\ttry {\n\t\t\tinfo = fDocument.getLineInformation(line + 1);\n\t\t\treturn info.getOffset() + info.getLength();\n\t\t} catch (BadLocationException x) {\n\t\t\treturn fDocument.getLength();\n\t\t}\n\t}\n",
    "111140": "    public void removeSelectionListener(SelectionListener listener) {\n        checkWidget();\n        if (listener == null) {\n            SWT.error(SWT.ERROR_NULL_ARGUMENT);\n        }\n        removeListener(SWT.Selection, listener);\n        removeListener(SWT.DefaultSelection, listener);\n    }\n",
    "111158": "    public int getColumn() {\n        checkWidget();\n        return column == null ? 0 : table.indexOf(column);\n    }\n",
    "111164": "    public TreeItem getRow() {\n        checkWidget();\n        return row;\n    }\n",
    "111307": "\tpublic void addModuleData(String iModuleName, CheckoutModuleData iCheckoutModuleData) {\n\t\tcheckoutModuleDataMap.put(iModuleName, iCheckoutModuleData);\n\t}\n",
    "111311": "\tpublic void removeModuleData(String iModuleName) {\n\t\tcheckoutModuleDataMap.remove(iModuleName);\n\t}\n",
    "111347": "\tpublic boolean isCorrect() {\n\n\t\tIterator moduleDataIterator = checkoutModuleDataMap.values().iterator();\n\t\twhile (moduleDataIterator.hasNext()) {\n\t\t\tCheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();\n\t\t\tif (!lCheckoutModuleData.isCorrect()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "111351": "\tpublic void setFieldstoUnverified() {\n\t\tIterator moduleDataIterator = checkoutModuleDataMap.values().iterator();\n\t\twhile (moduleDataIterator.hasNext()) {\n\t\t\tCheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();\n\t\t\tlCheckoutModuleData.setFieldstoUnverified();\n\t\t}\n\t}\n",
    "111355": "\tpublic int getMaxStep() {\n\t\tint currentMaxStep;\n\t\tint res = 0;\n\t\tIterator moduleDataIterator = checkoutModuleDataMap.values().iterator();\n\t\twhile (moduleDataIterator.hasNext()) {\n\t\t\tCheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();\n\t\t\tcurrentMaxStep = lCheckoutModuleData.getMaxStep();\n\t\t\tif (currentMaxStep >= res) {\n\t\t\t\tres = currentMaxStep;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n",
    "111357": "\tpublic CheckoutModuleData getModuleData(String iKey) {\n\t\treturn (CheckoutModuleData) checkoutModuleDataMap.get(iKey);\n\t}\n",
    "111361": "\tpublic Iterator getModulesIterator() {\n\t\tif (checkoutModuleMap != null) {\n\t\t\treturn checkoutModuleMap.values().iterator();\n\t\t} else {\n\t\t\treturn (Iterator) null;\n\t\t}\n\t}\n",
    "111367": "\tpublic void addInitError(Map iMap) {\n\t\tinitErrors.add(iMap);\n\t}\n",
    "111371": "\tpublic void clearInitErrors() {\n\t\tinitErrors.clear();\n\t}\n",
    "111373": "\tpublic void setLabel(Locale iLocale, String iString) {\n\t\tthis.labelMap.remove(iLocale);\n\t\tthis.labelMap.put(iLocale, iString);\n\t}\n",
    "111376": "\tpublic boolean isInitialized() {\n\t\treturn ((initErrors == null) || (initErrors.size() == 0));\n\t}\n",
    "111378": "\tpublic String getLabel(Locale iLocale) {\n\t\tif (this.labelMap != null) return (String) this.labelMap.get(iLocale.getLanguage());\n\t\telse return null;\n\t}\n",
    "111385": "\tpublic void setAskedStep(int iStep) {\n\t\tthis.askedStep = iStep;\n\t}\n",
    "111386": "\tpublic void setMessage(Map iMap) {\n\t\tmessageMap = iMap;\n\t}\n",
    "111387": "\tpublic int getAskedStep() {\n\t\treturn this.askedStep;\n\t}\n",
    "111389": "\tpublic String getMessage(Locale iLocale) {\n\t\treturn (String) this.messageMap.get(iLocale);\n\t}\n",
    "111390": "\tpublic void setExternalPayment(String iExternalPayment) {\n\t\texternalPayment = iExternalPayment;\n\t}\n",
    "111392": "\tpublic String getExternalPayment() {\n\t\treturn externalPayment;\n\t}\n",
    "111395": "\tpublic void setOrderLogStatus(String iLog) {\n\t\torderLogStatus = iLog;\n\t}\n",
    "111396": "\tpublic void setStatus(Integer iStatus) {\n\t\tstatus = iStatus;\n\t}\n",
    "111398": "\tpublic void unsetOrderLogStatus() {\n\t\torderLogStatus = null;\n\t}\n",
    "111399": "\tpublic Integer getStatus() {\n\t\treturn status;\n\t}\n",
    "111400": "\tpublic String getOrderLogStatus() {\n\t\treturn orderLogStatus;\n\t}\n",
    "111402": "\tpublic void setType(String iType) {\n\t\tif (\"group\".equals(this.type)){\n\t\t\tfor (int i = 0; i < group.size(); i++) {\n\t\t\t\tCheckoutModuleDataField lCheckoutDataField = (CheckoutModuleDataField) group.get(i);\n\t\t\t\tlCheckoutDataField.setType(iType);\n\t\t\t}\n\t\t} else {\n\t\t\ttype = iType;\n\t\t}\n\n\t}\n",
    "111403": "\tpublic void setOrderNumber(Integer iOrderNumber) {\n\t\torderNumber = iOrderNumber;\n\t}\n",
    "111406": "\tpublic Integer getOrderNumber() {\n\t\treturn orderNumber;\n\t}\n",
    "111431": "\tpublic String toString(StringBuffer uStringBuffer) {\n\t\tuStringBuffer.setLength(0);\n\t\tuStringBuffer.append(humanReadableKey);\n\t\tuStringBuffer.append('.');\n\t\tuStringBuffer.append(representationSecurityLevel);\n\t\tuStringBuffer.append('.');\n\t\tuStringBuffer.append(getData());\n\t\tuStringBuffer.append('.');\n\t\tuStringBuffer.append(comesFromSession);\n\t\treturn uStringBuffer.toString();\n\t}\n",
    "111456": "\tpublic Viewer getDocumentViewer(DocumentData ioDocumentData) {\n\t\tThingDocumentData lThingDocumentData = (ThingDocumentData) ioDocumentData;\n\t\tViewer lViewer = null;\n\t\tif (lThingDocumentData.isEditable()) {\n\t\t\tlViewer = new ThingDocumentViewer(lThingDocumentData, this, this);\n\t\t}\n\t\treturn lViewer;\n\t}\n",
    "111462": "\tpublic String getOntologyName() {\n\t\treturn \"thing\";\n\t}\n",
    "111468": "\tpublic Object getData(Viewer iViewer, Connection ioConnection, StringBuffer uStringBuffer) throws SQLException {\n\t\treturn null;\n\t}\n",
    "111500": "\tpublic void init() throws ServletException {\n\t\tServletConfig lServletConfig = getServletConfig();\n\t\tfor (Enumeration lEnum = lServletConfig.getInitParameterNames();lEnum.hasMoreElements();) {\n\t\t\t//System.out.println(lEnum);\n\t\t\tString ltmpStringjs = (String) lEnum.nextElement();\n\t\t\t//test if ltmpStringjs begins with javascript.xxx\n\t\t\tif (ltmpStringjs.startsWith(\"javascript.\")){\n\t\t\t\tString ltmpStringjsvalue = lServletConfig.getInitParameter(ltmpStringjs);\n\t\t\t\t//convert ltmpStringjs javascript.value in value\n\t\t\t\tltmpStringjs = ltmpStringjs.replaceAll(\"javascript.\",\"\");\n\t\t\t\t//add to jsMap\n\t\t\t\tjsMap.put(ltmpStringjs,ltmpStringjsvalue);\n\t\t\t}\n\t\t}\n\t}\n",
    "111537": "\tpublic String setInvoiceHeader() {\n\n\t\tString invoiceHeader = \t\"Distribution Fusion 3 inc.\\n\" +\n\t\t\t\t\t\t\t\t\"Electronic Trading System\\n\\n\" +\n\t\t\t\t\t\t\t\t\"Invoice no.: \\n\" +\n\t\t\t\t\t\t\t\t\"Date : \" + today +\n\t\t\t\t\t\t\t\t\"\\n\\nTrading partner : \" + \"HMV North America\" +\n\t\t\t\t\t\t\t\t\"reference : \" +\n\t\t\t\t\t\t\t\t\"Content type :   EDI\\n\\n\";\n\n\t\treturn invoiceHeader;\n\t}\n",
    "111728": "\tpublic Collection getPurchaseOrderItemRelations()  {\n\t\treturn purchaseOrderItemRelations;\n\t}\n",
    "111967": "    static public Object convert(String dataislandPrimitiveName, Object value) {\n        return convert(dataislandPrimitiveName, value, null);\n    }\n",
    "112013": "    static public void localize(Collection localizableObjectCollection, org.dataisland.primitives.bean.LocalizationContext localizationContext) throws LocalizationException {\n        for (Iterator i = localizableObjectCollection.iterator(); i.hasNext();) {\n            Object lCurrentObject = i.next();\n\n            if (lCurrentObject instanceof Collection) {\n                localize((Collection) lCurrentObject, localizationContext);\n            } else if (lCurrentObject instanceof org.dataisland.primitives.bean.Localizable) {\n                localize((org.dataisland.primitives.bean.Localizable) lCurrentObject, localizationContext);\n            }\n        }\n    }\n",
    "112042": "    public int compareTo(Object o) {\n        if (!(o instanceof Datatype)) {\n            throw new IllegalArgumentException(\"The object to be compared must be a Datatype object\");\n        }\n        return -1;\n    }\n",
    "112048": "    public int compareTo(Object o) {\n    \t\tif (!(o instanceof Money)) {\n            throw new IllegalArgumentException(\"The object to be compared must be a Money object\");\n        }\n        \n        Money obj = (Money) o;\n        \n        if (amount != null) {\n            return amount.compareTo(obj.getAmount());\n        }\n\n        return -1;\n            \n    }\n",
    "112082": "\tpublic DataIsland getDataIsland() {\n\t\treturn dataIsland;\n\t}\n",
    "112083": "\tpublic Object getData() {\n\t\treturn data;\n\t}\n",
    "112084": "\tpublic void setDocumentType(DocumentType iDocumentType) {\n\t\tthis.documentType = iDocumentType;\n\t\tstring = null;\n\t}\n",
    "112085": "\tpublic Date getLastModified() {\n\t\treturn lastModified;\n\t}\n",
    "112088": "\tpublic DocumentType getDocumentType() {\n\t\treturn documentType;\n\t}\n",
    "112089": "\tpublic View getView() {\n\t\treturn view;\n\t}\n",
    "112091": "\tpublic Locale getLocale() {\n\t\tView view = getView();\n\t\tif(view == null) return null;\n\t\treturn view.getLocale();\n\t}\n",
    "112093": "\tpublic void setLocale(Locale iLocale) {\n\t\tthis.locale = iLocale;\n\t\tstring = null;\n\t}\n",
    "112094": "\tpublic DocumentType getDocumentType() {\n\t\tView view = getView();\n\t\tif(view == null) return null;\n\t\treturn view.getDocumentType();\n\t}\n",
    "112095": "\tpublic void setDataIsland(DataIsland iDataIsland) {\n\t\tdataIsland = iDataIsland;\n\t}\n",
    "112097": "\tpublic void setData(Object iData) {\n\t\tdata = iData;\n\t}\n",
    "112098": "\tpublic Locale getLocale() {\n\t\treturn locale;\n\t}\n",
    "112099": "\tpublic void setLastModified(Date iLastModified) {\n\t\tif(iLastModified == null) throw new IllegalArgumentException(\"The last changed date object cannot be null\");\n\t\tlastModified = iLastModified;\n\t}\n",
    "112100": "\tpublic void setKey(String iKey) {\n\t\tkey = iKey;\n\t}\n",
    "112101": "\tpublic void setMode(String iMode) {\n\t\tthis.mode = iMode;\n\t\tstring = null;\n\t}\n",
    "112103": "\tpublic void setView(View iView) {\n\t\tif(iView == null) throw new IllegalArgumentException(\"The view object cannot be null\");\n\t\t//else if(iView.getLocale() == null) throw new IllegalArgumentException(\"The view's locale cannot be null\");\n\t\telse if(iView.getDocumentType() == null) throw new IllegalArgumentException(\"The view's document type cannot be null\");\n\t\tview = iView;\n\t}\n",
    "112105": "\tpublic String getMode() {\n\t\treturn mode;\n\t}\n",
    "112112": "\tpublic String toString() {\n\t\tif(string == null) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tif(locale != null) sb.append(locale).append('.');\n\t\t\tsb.append(documentType);\n\t\t\tstring = sb.toString();\n\t\t}\n\t\treturn string;\n\t}\n",
    "112119": "\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof View)  {\n\t\t\tView view = (View) obj;\n\t\t\tif(Misc.match(view.documentType, this.documentType) && Misc.match(view.locale, this.locale))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "112125": "\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n",
    "112148": "\tstatic public View getXMLView(Locale locale) {\n\t\treturn new View(DocumentType.XML, locale);\n\t}\n",
    "112161": "\tstatic public List getLocales(List iViews) {\n\t\tif(iViews == null) return null;\n\t\tVector locales = new Vector();\n\t\tIterator viewIterator = iViews.iterator();\n\t\twhile(viewIterator.hasNext()) {\n\t\t\tView view = (View) viewIterator.next();\n\t\t\tif(!locales.contains(view.getLocale())) locales.add(view.getLocale());\n\t\t}\n\t\tif(locales.size() == 0) locales = null;\n\t\treturn locales;\n\t}\n",
    "112222": "\tprivate void init(Writer oWriter) {\n\t\tif(oWriter == null) throw new IllegalArgumentException(\"The writer cannot be null\");\n\t\tsetOutput(oWriter);\n\t}\n",
    "112223": "\tstatic public boolean match(Object o1, Object o2) {\n\t\tif(o1 == null) {\n\t\t\tif(o2 == null) return true;\n\t\t} else if(o2 != null) {\n\t\t\tif(o1.equals(o2)) return true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "112224": "\tprivate void reset() {\n\t\toutput = null;\n\t\tprefixTable.clear();\n\t\tforcedDeclTable.clear();\n\t\tdoneDeclTable.clear();\n\t\telementLevel = 0;\n\t\tnsSupport.reset();\n\t\tprefixCounter = 0;\n\t}\n",
    "112227": "    public String getQuery() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tString result = getQuery(sb);\n\t\tsb.setLength(0);\n\t\treturn result;\n    }\n",
    "112228": "\tpublic void setOutput(Writer oWriter) {\n\t\toutput = oWriter;\n\t}\n",
    "112236": "\tpublic void init(Map iParameters) {\n\t}\n",
    "112249": "\tpublic IncluderContext getIncluderContext(ServletContext ioServletContext) {\n\t\tIncluderContext lIncluderContext = null;\n\t\tsynchronized(INCLUDER_CONTEXT_KEY) {\n\t\t\tlIncluderContext = (IncluderContext) ioServletContext.getAttribute(INCLUDER_CONTEXT_KEY);\n\t\t\tif(lIncluderContext == null) {\n\t\t\t\tlIncluderContext = new IncluderContext();\n\t\t\t\tlIncluderContext.init(ioServletContext.getRealPath(\"/WEB-INF/includes\"));\n\t\t\t\tioServletContext.setAttribute(INCLUDER_CONTEXT_KEY, lIncluderContext);\n\t\t\t}\n\t\t}\n\t\treturn lIncluderContext;\n\t}\n",
    "112269": "\tpublic ContentHandler getContentHandler() {\n\t\tif(this.ch == null && this.os != null) {\n\t\t\tString lMIMEType = getMIMEDocumentType();\n\t\t\tif(lMIMEType != null) setContentHandler(ApacheSerializer.getContentHandler(lMIMEType, this.os));\n\t\t}\n\t\treturn this.ch;\n\t}\n",
    "112277": "\tpublic View getBestView(Vector iViews) {\n\t\treturn View.getBestView(getPreferredDocumentTypes(), getPreferredLocales(), iViews);\n\t}\n",
    "112278": "\tpublic Locale getBestLocale(List iLocales) {\n\t\treturn Misc.getBestLocale(getPreferredLocales(), iLocales);\n\t}\n",
    "112282": "\tpublic ContentHandler getContentHandler() {\n\t\treturn this.ch;\n\t}\n",
    "112299": "\tstatic public void removeReservedParameter(String iParameterName) {\n\t\treservedParameter.remove(iParameterName);\n\t}\n",
    "112304": "\tpublic void setName(String iName) {\n\t\tthis.name = iName;\n\t}\n",
    "112308": "\tpublic boolean equals(Object iO) {\n\t\t if (iO != null) {\n\t\t \tDocumentType documentType = (DocumentType) iO;\n\t\t \tif(documentType.name == null) {\n\t\t \t\tif(name == null) return true;\n\t\t \t} else if(name == null) {\n\t\t \t\tif(documentType.name == null) return true;\n\t\t \t} else if(name.equals(documentType.name)) return true;\n\t\t }\n\t\t return false;\n\t}\n",
    "112309": "\tpublic String toString() {\n\t\treturn getName();\n\t}\n",
    "112330": "\tpublic File getRepositoryDirectory() {\n\t\treturn repositoryDirectory;\n\t}\n",
    "112336": "\tpublic void setRepositoryDirectory(File iRepositoryDirectory) {\n\t\tif(iRepositoryDirectory != null && iRepositoryDirectory.isDirectory() && iRepositoryDirectory.canRead()) {\n\t\t\tthis.repositoryDirectory = iRepositoryDirectory;\n\t\t\tthis.stylesheets = null;\n\t\t} else this.repositoryDirectory = null;\n\t\trefreshStylesheets();\n\t}\n",
    "112338": "\tpublic File getResolverRepositoryDirectory() {\n\t\treturn resolverRepositoryDirectory;\n\t}\n",
    "112339": "\tpublic void setRepositoryDirectory(File repositoryDirectory) {\n\t\tif(repositoryDirectory != null && (repositoryDirectory.isDirectory() || repositoryDirectory.mkdirs()) && repositoryDirectory.canRead()) {\n\t\t\ttry {\n\t\t\t\tthis.repositoryDirectory = repositoryDirectory.getCanonicalFile();\n\t\t\t\tclear();\n\t\t\t} catch(IOException ioe) {\n\t\t\t\tclear();\n\t\t\t\tthis.repositoryDirectory = null;\n\t\t\t}\n\t\t} else {\n\t\t\tclear();\n\t\t\tthis.repositoryDirectory = null;\n\t\t}\n\t}\n",
    "112342": "\tpublic void setResolverRepositoryDirectory(File iResolverRepositoryDirectory) {\n\t\tif(iResolverRepositoryDirectory != null && iResolverRepositoryDirectory.isDirectory() && iResolverRepositoryDirectory.canRead()) {\n\t\t\tthis.resolverRepositoryDirectory = iResolverRepositoryDirectory;\n\t\t\tif(transformerURIResolver == null) transformerURIResolver = new TransformerURIResolver();\n\t\t\ttry {\n\t\t\t\ttransformerURIResolver.setRootDirectory(resolverRepositoryDirectory);\n\t\t\t} catch (IOException lIOException) {\n\t\t\t\tRuntimeException lRuntimeException = new RuntimeException(\"Bad transformer resolver repository directory :\\n\" + this.resolverRepositoryDirectory.getAbsolutePath() + \"\\n\" + lIOException.getMessage(), lIOException);\n\t\t\t\tthrow lRuntimeException;\n\t\t\t}\n\t\t} else this.resolverRepositoryDirectory = null;\n\t\trefreshStylesheets();\n\t}\n",
    "112492": "    static public void parseQueryParameters(String query, Map parameters) {\n\t\tStringTokenizer st = new StringTokenizer(query, \"&\");\n\t\tString key, value, pair;\n\t\twhile(st.hasMoreTokens()) {\n\t\t    pair = (String)st.nextToken();\n\t\t    int pos = pair.indexOf('=');\n\t\t    if (pos != -1) {\n\t\t\t\tkey = pair.substring(0, pos);\n\t\t\t\tvalue = pair.substring(pos+1, pair.length());\n\t\t\t\tparameters.put(key, value);\n\t\t    } else parameters.put(pair, null);\n\t\t}\n    }\n",
    "113156": "    public Group saveGroup(Group group) throws DataIslandCMSException {\n        if (\"\".equals(group.getId())) group.setId(null);\n\n        try {\n\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Process persistance (create : if no persisted object previously existed, update otherwise)\n                // Schedule the value object for persistence\n                session.saveOrUpdate(group);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n\n\n        return group;\n    }\n",
    "113160": "    public List fetchGroupList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {\n        List groups = null;\n        // Initialize the hibernate session\n        Session session = currentSession();\n\n        try {\n            // Fetch session from hibernate\n            groups = session.createCriteria(Group.class).list();\n            LocalizationUtils.localize(groups, localizationContext);\n        } catch (Exception e) {\n            throw new DataIslandCMSException(e);\n        } finally {\n            // Close the hibernate session\n            closeSession();\n        }\n        return groups;\n    }\n",
    "113162": "    public void deleteGroup(Group group) throws DataIslandCMSException {\n        try {\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Schedule for deletion\n                session.delete(group);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n    }\n",
    "113171": "    public Role saveRole(Role role) throws DataIslandCMSException {\n        if (\"\".equals(role.getId())) role.setId(null);\n\n        try {\n\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n\n                // Schedule the value object for persistence\n                session.saveOrUpdate(role);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n\n\n        return role;\n    }\n",
    "113174": "    public List fetchRoleList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {\n        List roles = null;\n        // Initialize the hibernate session\n        Session session = currentSession();\n\n        try {\n            // Fetch session from hibernate\n            roles = session.createCriteria(Role.class).list();\n            LocalizationUtils.localize(roles, localizationContext);\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        } finally {\n            // Close the hibernate session\n            closeSession();\n        }\n        return roles;\n    }\n",
    "113176": "    public void deleteRole(Role role) throws DataIslandCMSException {\n        try {\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Schedule for deletion\n                session.delete(role);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n    }\n",
    "113185": "    public List fetchUserList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {\n        List users = null;\n        // Initialize the hibernate session\n        Session session = currentSession();\n\n        try {\n            // Fetch session from hibernate\n            users = session.createCriteria(User.class).list();\n            LocalizationUtils.localize(users, localizationContext);\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        } finally {\n            // Close the hibernate session\n            closeSession();\n        }\n        return users;\n    }\n",
    "113188": "    public void deleteUser(org.dataisland.cms.bean.User user) throws DataIslandCMSException {\n        try {\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Schedule for deletion\n                session.delete(user);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n    }\n",
    "113197": "    public Object unmarshal(Object obj, IUnmarshallingContext uctx) throws JiBXException {\n\n        // make sure we're at the appropriate start tag\n        UnmarshallingContext ctx = (UnmarshallingContext)uctx;\n        \n        if (!ctx.isAt(m_uri, m_name)) {\n            ctx.throwStartTagNameError(m_uri, m_name);\n        }\n\n        String refid = ctx.attributeText(m_uri, REFID_ATTRIBUTE_NAME);\n\n        ctx.parsePastEndTag(m_uri, m_name);\n\n        return ctx.findDefinedID(refid, m_index);\n    }\n",
    "113217": "    static public Role loadFormIntoRole(ActionForm actionForm, HttpServletRequest httpServletRequest) throws LocalizationException {\n        Role role = new Role();\n        LocalizationUtils.localize(role, StrutsLocalizationUtils.getCompositeLocalizationContext(httpServletRequest, WEB_CONTEXT_LOCALIZATION_CONTEXT_KEY));\n        DynaValidatorForm roleForm = (DynaValidatorForm) actionForm;\n        role.setId((String) roleForm.get(\"id\"));\n        role.setHumanReadableKey((String) roleForm.get(\"humanReadableKey\"));\n        role.setName((String) roleForm.get(\"name\"));\n        role.setDescriptions(LocalizationUtils.getLocaleKeyedMap((SortedMap) roleForm.get(\"description\")));\n        return role;\n    }\n",
    "113226": "    static public void populate(ActionForm actionForm, org.dataisland.cms.bean.Group group) {\n        DynaValidatorForm groupDeleteForm = (DynaValidatorForm) actionForm;\n        groupDeleteForm.set(\"id\", group.getId());\n        groupDeleteForm.set(\"name\", group.getName());\n    }\n",
    "113229": "    static public void populate(ActionForm actionForm, Role role) throws LocalizationException {\n        DynaValidatorForm roleDeleteForm = (DynaValidatorForm) actionForm;\n        roleDeleteForm.set(\"id\", role.getId());\n        roleDeleteForm.set(\"name\", role.getName());\n    }\n",
    "113262": "    static public void populate(ActionForm actionForm, org.dataisland.cms.bean.User user) {\n        DynaValidatorForm userDeleteForm = (DynaValidatorForm) actionForm;\n        userDeleteForm.set(\"id\", user.getId());\n        userDeleteForm.set(\"name\", user.getName());\n    }\n",
    "113265": "    static public Set getRolesFromIdArray(String[] roleIds, HttpServletRequest httpServletRequest) throws DataIslandCMSException, LocalizationException {\n        Set roles = new HashSet();\n\n        for (int i = 0; i < roleIds.length; i++) {\n            try {\n                roles.add(RolePersistenceFacade.getInstance().fetchRole(roleIds[i], StrutsLocalizationUtils.getCompositeLocalizationContext(httpServletRequest, WEB_CONTEXT_LOCALIZATION_CONTEXT_KEY)));\n            } catch (org.dataisland.cms.exception.RoleNotFoundException rnfe) {\n                throw new DataIslandCMSException(\"The role to be linked to the group does not exist.\", rnfe);\n            }\n        }\n        return roles;\n    }\n",
    "113292": "    public void setId(String id) {\n        this.id = id;\n    }\n",
    "113294": "    public void setPassword(String password) {\n        this.password = password;\n    }\n",
    "113296": "    public String getLogin() {\n        return login;\n    }\n",
    "113297": "    public void setLogin(String login) {\n        this.login = login;\n    }\n",
    "113301": "    public Group getGroup() {\n        return group;\n    }\n",
    "113303": "    public void setGroup(Group group) {\n        this.group = group;\n    }\n",
    "113305": "    public String getEmail() {\n        return email;\n    }\n",
    "113307": "    public void setEmail(String email) {\n        this.email = email;\n    }\n",
    "113308": "    public boolean isSystem() {\n        return system;\n    }\n",
    "113309": "    public void setSystem(boolean system) {\n        this.system = system;\n    }\n",
    "113310": "    static public ContextStack getContextStack(String contextStackKey, HttpServletRequest httpServletRequest) {\n        //Get Context Stack\n        String contextStackIdString = httpServletRequest.getParameter(contextStackKey);\n        String contextStackId = (String) ConvertUtils.convert(contextStackIdString, String.class);\n        return (ContextStack) httpServletRequest.getSession().getAttribute(contextStackId);\n    }\n",
    "113330": "    public void setContextStackIDInRequest(String contextStackKey, HttpServletRequest httpServletRequest) {\n        // Get Stack\n        String contextStackId = (String) httpServletRequest.getAttribute(contextStackKey);\n\n        if (contextStackId == null) {\n            String contextStackIdString = httpServletRequest.getParameter(contextStackKey);\n            contextStackId = (String) ConvertUtils.convert(contextStackIdString, String.class);\n            // Set context stack key in request\n            if(contextStackId != null) {\n                httpServletRequest.setAttribute(contextStackKey, contextStackId);\n            }\n        }\n    }\n",
    "113347": "    public Set getRoles() {\n        return roles;\n    }\n",
    "113348": "    public String getHumanReadableKey() {\n        return humanReadableKey;\n    }\n",
    "113349": "    public void setRoles(Set roles) {\n        if (roles == null)\n            this.roles.clear();\n        else\n            this.roles = roles;\n    }\n",
    "113464": "   public void addRequestServiceContext(ServiceContext serviceContext) {\n      addServiceContext(serviceContext);\n   }\n",
    "113470": "   public InvocationResponse exec(String interfaceName, String methodName, Object[] arguments, String[] argumentTypes, ServiceContext[] contextList) {\n      return interceptorCtrl.exec(interfaceName, methodName, arguments, argumentTypes, contextList);\n   }\n",
    "113473": "   public Throwable sendingException() {\n      return this.sendingException;\n   }\n",
    "113474": "   public Object server() {\n      return this.server;\n   }\n",
    "113475": "   public void addReplyServiceContext(ServiceContext serviceContext) {\n      addServiceContext(serviceContext);\n   }\n",
    "113478": "   public Remote remoteLookup(String name) throws RMINamingException {\n\n      // no caching - only a single Remote here\n      DemoServerInterface serverStubProxy = (DemoServerInterface)\n         RMIReplicationManager.getInstance().newInterceptor(demoServerObj, name);\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         return serverStubProxy;\n      } else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "113480": "   public Remote stubLookup(String name) {\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         try {\n            return (Remote) UnicastRemoteObject.toStub(demoServerObj);  // **** preserve the stub semantics\n         }\n         catch (NoSuchObjectException ex) {\n            ex.printStackTrace();\n         }\n      }\n\n      return null;\n   }\n",
    "113481": "   public Remote serverObjectLookup(String name) {\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         return demoServerObj;\n      }\n\n      return null;\n   }\n",
    "113488": "   public Remote remoteLookup(String name) throws RMINamingException, RemoteException {\n\n      if (name.equals(\"JRMPDemoServer\")) {\n         return serverStubProxy;\n      } else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "113495": "   public Remote lookup(String name) throws RMINamingException {\n\n      Remote remote;\n      try {\n         remote = Naming.lookup(name);\n      } catch (Exception ex) {\n         throw new RMINamingException(\"JRMP naming lookup error\", ex);  // a simple conversion\n      }\n\n      return remote;\n   }\n",
    "113496": "   public Throwable getCause() {\n      return causeException;\n   }\n",
    "113499": "   public RMINamingInterface getNamingInterfaceDelegate() {\n\n      return this.delegate;\n   }\n",
    "113513": "   public boolean isContextId(int id) {\n\n      if (contextId == id) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "113514": "   public int xid() {\n\n      return xid;\n   }\n",
    "113515": "   public int getContextId() {\n\n      return contextId;\n   }\n",
    "113517": "   public Object getContextData() {\n\n      return contextData;\n   }\n",
    "113520": "   protected Object initialValue() {\n\n      return null;\n   }\n",
    "113521": "   public String toObjectId() {\n\n      return \"ServiceContext: <\" + Integer.toString(contextId) + \"> \" + super.toString();\n   }\n",
    "113523": "   protected void preDispatch() throws ChannelException {\n\n   }\n",
    "113525": "   protected void processSetStateEvent(SetStateEvent event) {\n   }\n",
    "113526": "   protected void processGetStateEvent(GetStateEvent event) {\n   }\n",
    "113528": "   private void startDispatchThread() {\n      dispatchThread = \n         new MessageDispatchThread(\"RMI Multicast Dispatch Thread: \" + groupName);\n      dispatchThread.setDaemon(true);\n      dispatchThread.start();\n   }\n",
    "113537": "   protected void stateSync() {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if (channel.getLocalAddress().equals(coordinator)) {   // double validation\n         try {\n            if (log.isTraceEnabled()) log.trace(\"sending state sync\");\n\n            ServerObjectStates stateMap = getServerStates();\n\n            synchronized (requestIdLock) {\n               stateMap.setRequestId(requestId);\n            }\n\n            channel.send(null, null, stateMap);  // as a normal message\n         }\n         catch (Exception ex) {\n            if (log.isErrorEnabled())  log.error(\"stateSync failed\", ex);\n         }\n      }\n   }\n",
    "113545": "   public void viewAccepted(View new_view) {\n\n      super.viewAccepted(new_view);\n\n      if (grpCoordinatorListener != null) {     // re-entry is not a concern here\n         if (channel.getLocalAddress().equals(new_view.getMembers().get(0))) {\n            grpCoordinatorListener.becomeGroupCoordinator();\n         }\n      }\n   }\n",
    "113546": "   public void viewAccepted(View new_view) {\n\n      if (log.isDebugEnabled())  log.debug(\"** View=\" + new_view + \" (size=\" + new_view.size() + \")\");\n\n      if (vsync) {\n         synchronized (outboundMsgQueueLock) {\n            if (outboundMsgQueue != null) {\n               Serializable msg;\n               for (Iterator i = outboundMsgQueue.iterator(); i.hasNext(); ) {\n                  try {\n                     msg = (Serializable) i.next();\n                     if (msg instanceof Message)\n                        channel.send((Message) msg);   //  maybe a unicast\n                     else\n                        channel.send(null, null, msg);\n\n                     if (log.isTraceEnabled()) log.trace(\"send queue msg\");\n                  }\n                  catch (ChannelException ex) {\n                     if (log.isErrorEnabled())  log.error(\"exception\", ex);\n                  }\n               }\n               outboundMsgQueue = null;  // reset\n            }\n         }\n      }\n   }\n",
    "113547": "   protected ServerObjectStates getServerStates() throws Exception {\n\n      ServerObjectStates stateMap = new ServerObjectStates();\n\n      String[] servers = localNaming.serverObjects();\n      String name;\n      Remote server;\n      byte[] serverState;\n\n      // non atomic for server object state fetching !?? (FIFO + server determinism)\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         server = localNaming.serverObjectLookup(name);\n         if (server != null) {   // do whatever available\n            if (server instanceof Checkpointable) {\n               serverState = ((Checkpointable) server).getState();\n               stateMap.setServerObjectState(name, serverState);\n            }\n         }\n      }\n\n      return stateMap;\n   }\n",
    "113549": "   public void suspect(Address suspected_mbr) {\n\n   }\n",
    "113550": "   protected void setServerStates(ServerObjectStates stateMap) throws Exception {\n\n      String[] servers = stateMap.serverObjectNames();\n      String name;\n      Remote server;\n      byte[] serverState;\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         serverState = stateMap.getServerObjectState(name);\n         if (serverState != null) {   // do whatever available\n            server = localNaming.serverObjectLookup(name);\n            if (server != null) {\n               if (server instanceof Checkpointable) {\n                  ((Checkpointable) server).setState(serverState);\n               }\n            }\n         }\n      }\n   }\n",
    "113551": "   public void block() {\n      if (vsync) {\n         if (log.isDebugEnabled())  log.debug(\"** VSYNC block ...\");\n\n         synchronized (outboundMsgQueueLock) {\n\n            outboundMsgQueue = new ArrayList();  // also server as a flag\n\n            // jgroups: this will eat unicast too !!\n            channel.blockOk();\n         }\n      }\n   }\n",
    "113552": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"receiveRequestServiceContexts: \" + requestInfo);\n\n   }\n",
    "113553": "   public void receiveRequest(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"receiveRequest: \" + requestInfo);\n\n   }\n",
    "113555": "   public void sendReply(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"sendReply: \" + requestInfo);\n\n   }\n",
    "113557": "   public void sendException(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"sendException: \" + requestInfo);\n\n   }\n",
    "113561": "   public void setRequestId(FTRequestServiceContext requestId) {\n      this.requestId = requestId;\n   }\n",
    "113563": "      private long assignId() {\n\n         int id = nextId++;\n\n         if (nextId == Integer.MAX_VALUE) {   // wrap around\n\n            nextId = 1;\n         }\n\n         return id;\n      }\n",
    "113566": "   protected void processMsg(Message msg) throws Throwable {\n\n      synchronized (syncedLock) {\n         if (! stateSynced) {\n            if (log.isDebugEnabled())  log.debug(\"ignore message, wait for join state sync\");\n            return;\n         }\n      }\n\n      super.processMsg(msg);\n   }\n",
    "113570": "   protected void processGetStateEvent(GetStateEvent event) {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if ( channel.getLocalAddress().equals(coordinator)) {\n\n         try {\n            ServerObjectStates stateMap = getServerStates();\n\n            channel.returnState(Util.objectToByteBuffer(stateMap));\n\n            if (log.isDebugEnabled())  log.debug(\"sent state sync\");\n         }\n         catch (Exception ex) {    // let the new member hang\n            if (log.isErrorEnabled())  log.error(\"GetStateEvent failed\", ex);\n         }\n      }\n      else {\n         if (log.isDebugEnabled())  log.debug(\"ignore unexpected GetStateEvent: \" + event);\n      }\n   }\n",
    "113571": "   public void receiveReply(ClientRequestInfo requestInfo) {\n\n      // ignore\n   }\n",
    "113572": "   protected void preDispatch() throws ChannelException {\n      channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n   }\n",
    "113573": "   public void receiveException(ClientRequestInfo requestInfo) {\n\n      // ignore\n   }\n",
    "113577": "   public void receiveReply(ClientRequestInfo requestInfo) {\n      return;\n   }\n",
    "113579": "   public void receiveException(ClientRequestInfo requestInfo) {\n      return;\n   }\n",
    "113580": "   public void receiveReply(ClientRequestInfo requestInfo) {\n      trace(\"client: receiveReply: \" + requestInfo.toString());\n   }\n",
    "113581": "   public void receiveException(ClientRequestInfo requestInfo) {\n      trace(\"client: receiveException: \" + requestInfo.toString());\n   }\n",
    "113582": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      ServiceContext[] contexts = requestInfo.operationContexts();\n      ServiceContext cxt;\n      if (contexts != null) {\n         for (int i = 0; i < contexts.length; i ++) {\n            cxt = contexts[i];\n            if (cxt.isContextId(ServiceContext.TRANSACTION_CONTEXT_ID)) {\n               Current.setServiceContext(cxt);\n            }\n         }\n      }\n   }\n",
    "113583": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      trace(\"server: receiveRequestServiceContexts: \" + requestInfo.toString());\n   }\n",
    "113584": "   public void receiveRequest(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113585": "   public void receiveRequest(ServerRequestInfo requestInfo) {\n      trace(\"server: receiveRequest: \" + requestInfo.toString());\n   }\n",
    "113586": "   public void sendReply(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113587": "   public void sendReply(ServerRequestInfo requestInfo) {\n      trace(\"server: sendReply: \" + requestInfo.toString());\n   }\n",
    "113588": "   public void sendException(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113589": "   public void sendException(ServerRequestInfo requestInfo) {\n      trace(\"server: sendException: \" + requestInfo.toString());\n   }\n",
    "113591": "   public void writeExternal(ObjectOutput out) throws IOException {\n      out.writeObject(remoteStub);\n\n      out.writeObject(serverInterceptorRemote);\n\n      // for now, we make this a copy. It helps runtime exception mgt\n      // some optimization is possible\n   }\n",
    "113594": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      this.remoteStub = (Remote) in.readObject();\n      this.serverInterceptorRemote = (ServerInterceptorRemoteInterface) in.readObject();\n   }\n",
    "113599": "   public ServiceContext checkRequestServiceContext(int contextId) {\n\n      ServiceContext result = null;\n\n      if (operationContexts != null) {\n\n         int num = operationContexts.length;\n         ServiceContext c;\n         for (int i = 0; i < num; i ++ ) {\n            c = operationContexts[i];\n            if (c.contextId == contextId) {\n               result = c;\n               ServiceContext[] newContexts = new ServiceContext[num - 1];\n               System.arraycopy(operationContexts, 0, newContexts, 0, i);\n               if (i < num -1)\n                  System.arraycopy(operationContexts, i+1, newContexts, i , num-i-1);\n               operationContexts = newContexts;\n               break;        // no duplication checking\n            }\n         }\n      }\n\n      return result;\n   }\n",
    "113602": "   protected ServiceContext getServiceContext(int contextId) {\n\n      return ContextUtil.getServiceContext(operationContexts, contextId);\n   }\n",
    "113603": "   protected void addServiceContext(ServiceContext serviceContext) {\n\n      operationContexts = ContextUtil.addServiceContext(operationContexts, serviceContext);\n   }\n",
    "113614": "   public void removeClientRequestInterceptor(String name) {\n\n      synchronized (clientInterceptorList) {\n         clientInterceptorList.remove(name);\n      }\n   }\n",
    "113615": "   public void writeExternal(ObjectOutput out) throws IOException {\n      super.writeExternal(out);\n      out.writeObject(remoteKey);\n      out.writeObject(props);\n   }\n",
    "113616": "   public ClientRMIInterceptor getClientRequestInterceptor(String name) {\n\n      synchronized (clientInterceptorList) {\n         return (ClientRMIInterceptor) clientInterceptorList.get(name);\n      }\n   }\n",
    "113617": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      super.readExternal(in);\n      this.remoteKey = (String) in.readObject();\n      this.props = (Properties) in.readObject();\n   }\n",
    "113618": "   public String getPropert(String name) {\n      return props.getProperty(name);\n   }\n",
    "113620": "   public void setPropert(String name, String value) {\n      props.setProperty(name, value);\n   }\n",
    "113621": "   public void removeServerRequestInterceptor(String name) {\n\n      synchronized (serverInterceptorList) {\n         serverInterceptorList.remove(name);\n      }\n   }\n",
    "113622": "   public String getRemoteKey() {\n      return remoteKey;\n   }\n",
    "113623": "   public ServerRMIInterceptor getServerRequestInterceptor(String name) {\n\n      synchronized (serverInterceptorList) {\n         return (ServerRMIInterceptor) serverInterceptorList.get(name);\n      }\n   }\n",
    "113626": "   public void addClientMessageInterceptor(ClientRMIMessageInterceptor interceptor) {\n\n      synchronized (this) {\n         clientMsgInterceptor = interceptor;\n      }\n   }\n",
    "113628": "   private void processExecReflectionException(Exception ex) throws InvocationTargetException {\n\n      // the cause exception has to be a runtime exception\n      throw new InvocationTargetException(new IllegalArgumentException(\"Interceptor Service.exec() failed: \" + ex));\n   }\n",
    "113629": "   public void removeClientMessageInterceptor(String name) {\n\n      synchronized (this) {\n         clientMsgInterceptor = null;\n      }\n   }\n",
    "113630": "   public ClientRMIMessageInterceptor getClientMessageInterceptor(String name) {\n\n      synchronized (this) {\n         return this.clientMsgInterceptor;\n      }\n   }\n",
    "113633": "   public ClientRMIMessageInterceptor getClientMessageInterceptor() {\n\n      synchronized (this) {\n         return this.clientMsgInterceptor;\n      }\n   }\n",
    "113636": "   public void addServerMessageInterceptor(ServerRMIMessageInterceptor interceptor) {\n\n      synchronized (this) {\n         serverMsgInterceptor = interceptor;\n      }\n   }\n",
    "113639": "   public void removeServerMessageInterceptor(String name) {\n\n      synchronized (this) {\n         serverMsgInterceptor = null;\n      }\n   }\n",
    "113642": "   public ServerRMIMessageInterceptor getServerMessageInterceptor(String name) {\n\n      synchronized (this) {\n         return this.serverMsgInterceptor;\n      }\n   }\n",
    "113646": "   public ServerRMIMessageInterceptor getServerMessageInterceptor() {\n\n      synchronized (this) {\n         return this.serverMsgInterceptor;\n      }\n   }\n",
    "113676": "   public Remote lookup(String name) throws RMINamingException, RemoteException {\n\n      if (name.equals(\"JRMPDemoServer\")) {\n         return serverStubProxy;\n      }\n      else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "113696": "   public boolean isServiceId(int id) {\n\n      if (serviceId == id) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "113697": "   public int getServiceId() {\n\n      return serviceId;\n   }\n",
    "113702": "   public String toObjectId() {\n\n      return \"ServiceContext: <\" + Integer.toString(serviceId) + \"> \" + super.toString();\n   }\n",
    "113717": "   protected void processMsg(Message msg) throws Throwable {\n\n      Object msgObj;\n      msgObj = msg.getObject();\n\n      if (msgObj instanceof InvocationResponse) {\n\n         synchronized (rspLock) {\n            rsp = (InvocationResponse) msgObj;   // todo: concurrent access\n            rspLock.notify();\n         }\n      }\n\n      // possible issues ??\n      if (msgObj != null)\n         System.out.println(\"***  obj is \" + msgObj.getClass() +\n            \", hdrs are\" + msg.printObjectHeaders());\n      else\n         System.out.println(\"***  hdrs are \" + msg.printObjectHeaders());\n   }\n",
    "113719": "   public InvocationResponse invoke(ClientRequestInfo requestInfo) throws ChannelException {\n\n      channel.send(null, null, (Serializable) requestInfo);\n\n      InvocationResponse result = null;\n\n      synchronized (rspLock) {\n         while (rsp == null) {\n            try {\n               rspLock.wait();\n            }\n            catch (InterruptedException ex) {\n               // shadow any interrupt\n               // rspLock.notify();\n            }\n         }\n         result = rsp;\n         rsp = null; // no further request-response correlation here - single-thread client ?!\n      }\n\n      return result;\n   }\n",
    "113725": "   public void receiveException(ClientRequestInfo requestInfo) {\n\n      // never invoked in this case\n   }\n",
    "113729": "   public void sendRequest(ClientRequestInfo requestInfo) {\n      trace(\"client: sendRequest: \" + requestInfo.toString());\n   }\n",
    "113733": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      ServiceContext[] contexts = requestInfo.operationContexts();\n      ServiceContext cxt;\n      if (contexts != null) {\n         for (int i = 0; i < contexts.length; i ++) {\n            cxt = contexts[i];\n            if (cxt.isServiceId(ServiceContext.TRANSACTION_CONTEXT_ID)) {\n               Current.setServiceContext(cxt);\n            }\n         }\n      }\n   }\n",
    "113749": "   public ServiceContext checkRequestServiceContext(int serviceId) {\n\n      ServiceContext result = null;\n\n      if (operationContexts != null) {\n\n         int num = operationContexts.length;\n         ServiceContext c;\n         for (int i = 0; i < num; i ++ ) {\n            c = operationContexts[i];\n            if (c.serviceId == serviceId) {\n               result = c;\n               ServiceContext[] newContexts = new ServiceContext[num - 1];\n               System.arraycopy(operationContexts, 0, newContexts, 0, i);\n               if (i < num -1)\n                  System.arraycopy(operationContexts, i+1, newContexts, i , num-i-1);\n               operationContexts = newContexts;\n               break;        // no duplication checking\n            }\n         }\n      }\n\n      return result;\n   }\n",
    "113751": "   protected ServiceContext getServiceContext(int serviceId) {\n\n      return ContextUtil.getServiceContext(operationContexts, serviceId);\n   }\n",
    "113766": "   public void writeExternal(ObjectOutput out) throws IOException {\n      super.writeExternal(out);\n      out.writeObject(props);\n   }\n",
    "113768": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      super.readExternal(in);\n      this.props = (Properties) in.readObject();\n   }\n",
    "113811": "   protected ServiceContext getServiceContext(int serviceId) {\n\n      if (operationContexts == null) {\n         return null;\n      }\n      else {\n         ServiceContext c;\n         for (int i = 0; i < operationContexts.length; i ++ ) {\n            c = operationContexts[i];\n            if (c.serviceId == serviceId) {\n               return (ServiceContext) c.clone();\n            }\n         }\n         return null; // otherwise\n      }\n   }\n",
    "113812": "   public void removeClientRequestInterceptor(String name) {\n\n      synchronized (interceptorList) {\n         interceptorList.remove(name);\n      }\n   }\n",
    "113813": "   protected void addServiceContext(ServiceContext serviceContext) {\n\n      if (operationContexts != null) {\n\n         int num = operationContexts.length;\n         ServiceContext c;\n\n         for (int i = 0; i < num; i ++ ) {\n            c = operationContexts[i];\n            if (c.serviceId == serviceContext.serviceId) {\n               operationContexts[i] = serviceContext;\n               return; // replace\n            }\n         }\n\n         // append\n         ServiceContext[] result = new ServiceContext[num + 1];\n         System.arraycopy(operationContexts, 0, new ServiceContext[num + 1], 0, num);\n         result[num] = serviceContext;  // last one\n         operationContexts = result;\n      }\n      else {\n         operationContexts = new ServiceContext[1];\n         operationContexts[0] = serviceContext;\n      }\n   }\n",
    "113817": "   public void sendRequest(ClientRequestInfo requestInfo) {\n\n      // update the clientRequestInfo\n      requestInfo.addRequestServiceContext(Current.getServiceContext(ServiceContext.TRANSACTION_CONTEXT_ID));\n   }\n",
    "113906": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113922": "   public void sendRequest(ClientRequestInfo requestInfo) {\n      // ignore\n   }\n",
    "113937": "   public void viewAccepted(View new_view) {\n\n      if (log.isDebugEnabled())  log.debug(\"** View=\" + new_view + \" (size=\" + new_view.size() + \")\");\n\n      if (vsync) {\n         synchronized (outboundMsgQueueLock) {\n            if (outboundMsgQueue != null) {\n               for (Iterator i = outboundMsgQueue.iterator(); i.hasNext(); ) {\n                  try {\n                     channel.send(null, null, (Serializable) i.next());\n                  }\n                  catch (ChannelException ex) {\n                     if (log.isErrorEnabled())  log.error(\"exception\", ex);\n                  }\n               }\n               outboundMsgQueue = null;  // reset\n            }\n         }\n      }\n   }\n",
    "113945": "   public void block() {\n      if (vsync) {\n         if (log.isDebugEnabled())  log.debug(\"** VSYNC block ...\");\n         synchronized (outboundMsgQueueLock) {\n            outboundMsgQueue = new ArrayList();  // also server as a flag\n            channel.blockOk();   // jgroups: this will eat unicast too !!\n         }\n      }\n   }\n",
    "114218": "   protected void processStateSync(ServerObjectStateMap stateMap) {\n      try {\n         setServerStates(stateMap);\n\n         synchronized(msgBuffer) {\n            msgBuffer.clear();   // no partial state-sync\n         }\n      }\n      catch (Exception ex) {     // keep the buffer\n         if (log.isErrorEnabled())  log.error(\"SetStateEvent failed\", ex);\n      }\n   }\n",
    "114219": "   protected void stateSync() {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if (channel.getLocalAddress().equals(coordinator)) {   // double validation\n         try {\n            if (log.isTraceEnabled()) log.trace(\"sending state sync\");\n            ServerObjectStateMap stateMap = getServerStates();\n            channel.send(null, null, stateMap);  // as a normal message\n         }\n         catch (Exception ex) {\n            if (log.isErrorEnabled())  log.error(\"stateSync failed\", ex);\n         }\n      }\n   }\n",
    "114233": "   protected ServerObjectStateMap getServerStates() throws Exception {\n\n      ServerObjectStateMap stateMap = new ServerObjectStateMap();\n\n      String[] servers = localNaming.serverObjects();\n      String name;\n      Remote server;\n      byte[] serverState;\n\n      // non atomic for server object state fetching !?? (FIFO + server determinism)\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         server = localNaming.serverObjectLookup(name);\n         if (server != null) {   // do whatever available\n            if (server instanceof Checkpointable) {\n               serverState = ((Checkpointable) server).getState();\n               stateMap.setServerObjectState(name, serverState);\n            }\n         }\n      }\n\n      return stateMap;\n   }\n",
    "114237": "   protected void setServerStates(ServerObjectStateMap stateMap) throws Exception {\n\n      String[] servers = stateMap.serverObjectNames();\n      String name;\n      Remote server;\n      byte[] serverState;\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         serverState = stateMap.getServerObjectState(name);\n         if (serverState != null) {   // do whatever available\n            server = localNaming.serverObjectLookup(name);\n            if (server != null) {\n               if (server instanceof Checkpointable) {\n                  ((Checkpointable) server).setState(serverState);\n               }\n            }\n         }\n      }\n   }\n",
    "114250": "   protected void processGetStateEvent(GetStateEvent event) {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if ( channel.getLocalAddress().equals(coordinator)) {\n\n         try {\n            ServerObjectStateMap stateMap = getServerStates();\n\n            channel.returnState(Util.objectToByteBuffer(stateMap));\n         }\n         catch (Exception ex) {    // let the new member hang\n            if (log.isErrorEnabled())  log.error(\"GetStateEvent failed\", ex);\n         }\n      }\n      else {\n         if (log.isDebugEnabled())  log.debug(\"unexpected GetStateEvent: \" + event);\n      }\n   }\n",
    "114339": "   public void writeExternal(ObjectOutput out) throws IOException {\n      out.writeObject(serviceStub);\n\n      out.writeObject(interceptorRemote);\n      // for now, we make this a copy. It helps runtime exception mgt\n      // some optimization is possible\n   }\n",
    "114343": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      this.serviceStub = (Remote) in.readObject();\n      this.interceptorRemote = (ServerInterceptorRemoteInterface) in.readObject();\n   }\n",
    "114411": "   public void writeExternal(ObjectOutput out) throws IOException {\n      super.writeExternal(out);\n   }\n",
    "114415": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      super.readExternal(in);\n   }\n",
    "114539": "   public Remote remoteLookup(String name) throws RMINamingException {\n      return remoteLookup(name, null);\n   }\n",
    "114544": "   public Remote remoteLookup(String name) throws RMINamingException {\n\n      // no caching - only a single Remote here\n      DemoServerInterface serverStubProxy = (DemoServerInterface)\n         RMIReplicationManager.getInstance().newInterceptor(demoServerObj, name);  // not really a remoteStub here - same effect\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         return serverStubProxy;\n      } else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "114549": "   public String objectGroupId(String name) {\n      return null;  // default\n   }\n",
    "114557": "   public void comesNewGroupCoordinator() {\n      \n   }\n",
    "114560": "   public void comesNewGroupCoordinator() {\n\n      try {\n         OpenGroupManagerRemoteInterface coordinatorOpenGrpMgr =\n            (OpenGroupManagerRemoteInterface) Naming.lookup(\"//\" + namingHost + \"/OpenGroupManager\");\n\n         OpenGroupManager.getInstance().registerWithCoordinator(coordinatorOpenGrpMgr, serverId, openGrpMgrStub);\n      }\n      catch (Exception e) {\n         System.out.println(\"Register OpenGroupMgr proxy with coordinator err: \" + e.getMessage());\n         e.printStackTrace();\n      }\n\n      // todo: add re-try\n   }\n",
    "114576": "    public Exception getNextException() {\n        return nextException;\n    }\n",
    "114578": "    public void setLogTarget(PrintStream target) {\n        logTarget = target;\n    }\n",
    "114579": "    public PrintStream getLogTarget() {\n        return logTarget;\n    }\n",
    "114583": "    public void printStackTrace(Throwable e) {\n\n        // Yes, we print the stack trace for an originating\n        // exception, but nothing else.\n        // If e is not a remote exception\n        // or if e.detail is null\n        // or if e.detail is not an EJBException\n        // Print the stack\n        // Otherwise the stack has already been printed, don't print.\n        if (!(e instanceof RemoteException)\n                || ((RemoteException) e).detail == null) {\n//                ||!(((RemoteException) e).detail instanceof EJBException)) {\n            e.printStackTrace(logTarget);\n        }\n    }\n",
    "114593": "    public void printStackTrace(Throwable e) {\n\n        if (debugLevel > 3) {\n            e.printStackTrace(logTarget);\n        } else {\n            super.printStackTrace(e);\n        }\n    }\n",
    "114632": "   public ServerObjectNamingInterface getLocalServerObjectNaming() {\n      return this.localNaming;\n   }\n",
    "114648": "   public boolean checkObjectGroup(String grpId) {\n      if (grpId == null) {\n         return true;   // default\n      }\n\n      synchronized (queueMap) {\n         return queueMap.containsKey(grpId);\n      }\n   }\n",
    "114649": "   public Queue checkObjectGroupQueue(String grpId) {\n      if (grpId == null) {\n         return DEFAULT_QUEUE;\n      }\n\n      synchronized (queueMap) {\n         if (queueMap.containsKey(grpId)) {\n            return (Queue) queueMap.get(grpId);\n         }\n         else {\n            Queue q = new Queue();\n            queueMap.put(grpId, q);\n            return q;\n         }\n      }\n   }\n",
    "114652": "   public boolean clearObjectGroupQueue(String grpId) {\n      if (grpId == null) {\n         return false;   // ignore\n      }\n\n      synchronized (queueMap) {\n         if (queueMap.containsKey(grpId)) {\n            Queue q = (Queue) queueMap.get(grpId);\n            //q.purge();             // triggered from delivery thread now\n            if (q.isEmpty()) {\n               queueMap.remove(grpId);\n               return true;\n            }\n            else {\n               return false;   // let the delivery thread run\n            }\n         }\n         else {\n            return false;   //ignore\n         }\n      }\n   }\n",
    "114657": "   public void viewAccepted(View new_view) {\n\n      super.viewAccepted(new_view);\n\n      if (grpCoordinatorListener != null) {     // re-entry is not a concern here\n         if (channel.getLocalAddress().equals(new_view.getMembers().get(0))) {\n            grpCoordinatorListener.becomesGroupCoordinator();\n         }\n         else {\n            // todo: only fire when there's actually a coordinator change - same above !!\n            grpCoordinatorListener.comesNewGroupCoordinator();\n         }\n      }\n   }\n",
    "114665": "   protected void setServerStates(ServerObjectStates stateMap) throws Exception {\n\n      String[] servers = stateMap.serverObjectNames();\n      String name;\n      Remote server;\n      byte[] serverState;\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         serverState = stateMap.getServerObjectState(name);\n         if (serverState != null) {   // do whatever available\n            server = localNaming.serverObjectLookup(name);\n            if (server != null) {     // equivalently a registration - no object-group for now\n               if (server instanceof Checkpointable) {\n                  ((Checkpointable) server).setState(serverState);\n               }\n            }\n         }\n      }\n   }\n",
    "114671": "      public void quit() {\n         stopped = true;       // todo: clean it up\n      }\n",
    "114682": "   protected void preDispatch() throws ChannelException {\n      // channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);  - deprecated since 2.3\n   }\n",
    "114702": "   public void registerProxyStub(String serverId, Remote mgrProxyStub) throws RemoteException {\n\n      stubMap.put(serverId, mgrProxyStub);\n   }\n",
    "114832": "\tpublic int read(byte[] _buffer) throws IOException {\n\t\tint pos = 0;\n\t\twhile (pos < _buffer.length) {\n\t\t\tpos += read(_buffer, pos, _buffer.length - pos);\n\t\t}\n\t\treturn pos;\n\t}\n",
    "114855": "\tpublic void copyInto(double[] anArray) {\n\t\tSystem.arraycopy(elementData, 0, anArray, 0, elementCount);\n\t}\n",
    "114860": "\tpublic void trimToSize() {\n\t\tint oldCapacity = elementData.length;\n\t\tif (elementCount < oldCapacity) {\n\t\t\tdouble[] oldData = elementData;\n\t\t\telementData = new double[elementCount];\n\t\t\tSystem.arraycopy(oldData, 0, elementData, 0, elementCount);\n\t\t}\n\t}\n",
    "114869": "\tpublic void ensureCapacity(int minCapacity) {\n\t\tensureCapacityHelper(minCapacity);\n\t}\n",
    "114873": "\tprotected boolean lessThan(float a, float b) {\n\t\treturn a < b;\n\t}\n",
    "114874": "\tprivate void ensureCapacityHelper(int minCapacity) {\n\t\tint oldCapacity = elementData.length;\n\t\tif (minCapacity > oldCapacity) {\n\t\t\tdouble[] oldData = elementData;\n\t\t\tint newCapacity = (capacityIncrement > 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2);\n\t\t\tif (newCapacity < minCapacity) {\n\t\t\t\tnewCapacity = minCapacity;\n\t\t\t}\n\t\t\telementData = new double[newCapacity];\n\t\t\tSystem.arraycopy(oldData, 0, elementData, 0, elementCount);\n\t\t}\n\t}\n",
    "114882": "\tpublic String toString() {\n\t\treturn new String(buf, 0, count);\n\t}\n",
    "114883": "\tpublic void setSize(int newSize) {\n\t\tif (newSize > elementCount) {\n\t\t\tensureCapacityHelper(newSize);\n\t\t}\n\t\telse {\n\t\t\tfor (int i = newSize; i < elementCount; i++) {\n\t\t\t\telementData[i] = 0;\n\t\t\t}\n\t\t}\n\t\telementCount = newSize;\n\t}\n",
    "114886": "\tpublic String toString(String enc) throws UnsupportedEncodingException {\n\t\treturn new String(buf, 0, count, enc);\n\t}\n",
    "114889": "\tpublic String toString(int hibyte) {\n\t\treturn new String(buf, hibyte, 0, count);\n\t}\n",
    "114890": "\tpublic int capacity() {\n\t\treturn elementData.length;\n\t}\n",
    "114892": "\tpublic void close() throws IOException {\n\t}\n",
    "114900": "\tpublic int size() {\n\t\treturn elementCount;\n\t}\n",
    "114902": "    public void setBody(AbstractMP3FragmentBody body) {\n        this.body = body;\n    }\n",
    "114903": "    public AbstractMP3FragmentBody getBody() {\n        return this.body;\n    }\n",
    "114905": "    public boolean equals(Object obj) {\n        if ((obj instanceof AbstractMP3Fragment) == false) {\n            return false;\n        }\n\n        AbstractMP3Fragment object = (AbstractMP3Fragment) obj;\n\n        if (this.getIdentifier().equals(object.getIdentifier()) == false) {\n            return false;\n        }\n\n        if (this.body.equals(object.body) == false) {\n            return false;\n        }\n\n        return super.equals(obj);\n    }\n",
    "114906": "\tpublic boolean isEmpty() {\n\t\treturn elementCount == 0;\n\t}\n",
    "114908": "\tpublic boolean contains(double elem) {\n\t\treturn indexOf(elem, 0) >= 0;\n\t}\n",
    "114910": "\tpublic int indexOf(double elem) {\n\t\treturn indexOf(elem, 0);\n\t}\n",
    "114913": "\tpublic int indexOf(double elem, int index) {\n\t\tfor (int i = index; i < elementCount; i++)\n\t\t\tif (elem == elementData[i])\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}\n",
    "114916": "\tpublic int lastIndexOf(double elem) {\n\t\treturn lastIndexOf(elem, elementCount - 1);\n\t}\n",
    "114917": "\tpublic int lastIndexOf(double elem, int index) {\n\t\tif (index >= elementCount)\n\t\t\tthrow new IndexOutOfBoundsException(index + \" >= \" + elementCount);\n\n\t\tfor (int i = index; i >= 0; i--)\n\t\t\tif (elem == elementData[i])\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}\n",
    "114920": "\tpublic double elementAt(int index) {\n\t\tif (index >= elementCount) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n\t\t}\n\t\t/* Since try/catch is free, except when the exception is thrown,\n\t\t   put in this extra try/catch to catch negative indexes and\n\t\t   display a more informative error message.  This might not\n\t\t   be appropriate, especially if we have a decent debugging\n\t\t   environment - JP. */\n\t\ttry {\n\t\t\treturn elementData[index];\n\t\t}\n\t\tcatch (ArrayIndexOutOfBoundsException e) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" < 0\");\n\t\t}\n\t}\n",
    "114922": "    public void setFilenameTag(FilenameTag filenameTag) {\n        this.filenameTag = filenameTag;\n    }\n",
    "114923": "\tpublic double firstElement() {\n\t\tif (elementCount == 0) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn elementData[0];\n\t}\n",
    "114924": "\tpublic double lastElement() {\n\t\tif (elementCount == 0) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn elementData[elementCount - 1];\n\t}\n",
    "114926": "    public FilenameTag getFilenameTag() {\n        return this.filenameTag;\n    }\n",
    "114927": "\tpublic void setElementAt(double obj, int index) {\n\t\tif (index >= elementCount) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n\t\t}\n\t\telementData[index] = obj;\n\t}\n",
    "114929": "\tpublic void removeElementAt(int index) {\n\t\tif (index >= elementCount) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n\t\t}\n\t\telse if (index < 0) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index);\n\t\t}\n\t\tint j = elementCount - index - 1;\n\t\tif (j > 0) {\n\t\t\tSystem.arraycopy(elementData, index + 1, elementData, index, j);\n\t\t}\n\t\telementCount--;\n\t\telementData[elementCount] = 0; /* to let gc do its work */\n\t}\n",
    "114930": "    public void setFrameAcrossTags(AbstractID3v2Frame frame) {\n        ID3v2_4 id3v1 = null;\n        ID3v2_4 lyrics3 = null;\n\n        if (this.id3v1tag != null) {\n            id3v1 = new ID3v2_4(this.id3v1tag);\n            id3v1.setFrame(frame);\n            this.id3v1tag.overwrite(id3v1);\n        }\n\n        if (this.id3v2tag != null) {\n            id3v2tag.setFrame(frame);\n        }\n\n        if (this.lyrics3tag != null) {\n            lyrics3 = new ID3v2_4(this.lyrics3tag);\n            lyrics3.setFrame(frame);\n            this.lyrics3tag = new Lyrics3v2(lyrics3);\n        }\n\n        if (this.filenameTag != null) {\n            filenameTag.setFrame(frame);\n        }\n    }\n",
    "114934": "\tpublic void insertElementAt(double obj, int index) {\n\t\tif (index >= elementCount + 1) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" > \" + elementCount);\n\t\t}\n\t\tensureCapacityHelper(elementCount + 1);\n\t\tSystem.arraycopy(elementData, index, elementData, index + 1, elementCount - index);\n\t\telementData[index] = obj;\n\t\telementCount++;\n\t}\n",
    "114936": "\tpublic void addElement(double obj) {\n\t\tensureCapacityHelper(elementCount + 1);\n\t\telementData[elementCount++] = obj;\n\t}\n",
    "114940": "\tpublic boolean removeElement(double obj) {\n\t\tint i = indexOf(obj);\n\t\tif (i >= 0) {\n\t\t\tremoveElementAt(i);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "114942": "\tpublic void removeAllElements() {\n\t\t// Let gc do its work\n\t\tfor (int i = 0; i < elementCount; i++)\n\t\t\telementData[i] = 0;\n\n\t\telementCount = 0;\n\t}\n",
    "114944": "\tpublic Object clone() {\n\t\ttry {\n\t\t\tDoubleVector v = (DoubleVector) super.clone();\n\t\t\tv.elementData = new double[elementCount];\n\t\t\tSystem.arraycopy(elementData, 0, v.elementData, 0, elementCount);\n\t\t\treturn v;\n\t\t}\n\t\tcatch (CloneNotSupportedException e) {\n\t\t\t// this shouldn't happen, since we are Cloneable\n\t\t\tthrow new InternalError();\n\t\t}\n\t}\n",
    "114945": "    public void setID3v1Tag(AbstractMP3Tag mp3tag) {\n        id3v1tag = new ID3v1_1(mp3tag);\n    }\n",
    "114947": "\tpublic double get(int index) {\n\t\tif (index >= elementCount)\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index);\n\n\t\treturn elementData[index];\n\t}\n",
    "114950": "\tpublic double set(int index, double element) {\n\t\tif (index >= elementCount)\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index);\n\n\t\tdouble oldValue = elementData[index];\n\t\telementData[index] = element;\n\t\treturn oldValue;\n\t}\n",
    "114952": "\tpublic boolean add(double o) {\n\t\tensureCapacityHelper(elementCount + 1);\n\t\telementData[elementCount++] = o;\n\t\treturn true;\n\t}\n",
    "114953": "    public ID3v1 getID3v1Tag() {\n        return id3v1tag;\n    }\n",
    "114954": "\tpublic boolean remove(double o) {\n\t\treturn removeElement(o);\n\t}\n",
    "114956": "    public void setID3v2Tag(AbstractMP3Tag mp3tag) {\n        id3v2tag = new ID3v2_4(mp3tag);\n    }\n",
    "114957": "\tpublic void add(int index, double element) {\n\t\tinsertElementAt(element, index);\n\t}\n",
    "114962": "\tpublic void clear() {\n\t\tremoveAllElements();\n\t}\n",
    "114964": "\tpublic boolean equals(Object o) {\n\t\treturn super.equals(o);\n\t}\n",
    "114965": "    public AbstractID3v2 getID3v2Tag() {\n        return id3v2tag;\n    }\n",
    "114966": "\tprotected void removeRange(int fromIndex, int toIndex) {\n\t\tint numMoved = elementCount - toIndex;\n\t\tSystem.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved);\n\n\t\t// Let gc do its work\n\t\tint newElementCount = elementCount - (toIndex - fromIndex);\n\t\twhile (elementCount != newElementCount)\n\t\t\telementData[--elementCount] = 0;\n\t}\n",
    "114978": "    public void setLyrics3Tag(AbstractMP3Tag mp3tag) {\n        lyrics3tag = new Lyrics3v2(mp3tag);\n    }\n",
    "115001": "    public AbstractLyrics3 getLyrics3Tag() {\n        return lyrics3tag;\n    }\n",
    "115062": "    public Lyrics3v2Field getField(String identifier) {\n        return (Lyrics3v2Field) fieldMap.get(identifier);\n    }\n",
    "115072": "    public void setId3v2PaddingMultiplier(float mult) {\n        if (mult > 1) {\n            id3v2PaddingMultiplier = mult;\n        }\n    }\n",
    "115077": "    public float getId3v2PaddingMultiplier() {\n        return id3v2PaddingMultiplier;\n    }\n",
    "115081": "    public boolean isUnsynchronized() {\n        return getUnsynchronizedFragments().size() > 0;\n    }\n",
    "115082": "    public void setId3v2PaddingSize(int size) {\n        if (size >= 0) {\n            id3v2PaddingSize = size;\n        }\n    }\n",
    "115087": "    public int getId3v2PaddingSize() {\n        return id3v2PaddingSize;\n    }\n",
    "115125": "    public String getBriefDescription() {\n        String            str = \"\";\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n\n            if ((object.toString() != null) && (object.toString().length() > 0)) {\n                str += (object.getIdentifier() + \"=\\\"\" + object.toString() + \"\\\"; \");\n            }\n        }\n\n        return str;\n    }\n",
    "115126": "    public String getDescription() {\n        String            str = \"\";\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n            str += (object.getIdentifier() + \" = \" + object.toString() + \"\\n\");\n        }\n\n        return str.trim();\n    }\n",
    "115127": "    public void setObject(String identifier, Object obj) {\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n\n            if (object.getIdentifier().equals(identifier)) {\n                object.setValue(obj);\n            }\n        }\n    }\n",
    "115128": "    public Object getObject(String identifier) {\n        AbstractMP3Object object;\n        Object            obj = null;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n\n            if (object.getIdentifier().equals(identifier)) {\n                obj = object.getValue();\n            }\n        }\n\n        return obj;\n    }\n",
    "115132": "    public boolean isSubsetOf(Object obj) {\n        if ((obj instanceof AbstractMP3FragmentBody) == false) {\n            return false;\n        }\n\n        ArrayList superset = ((AbstractMP3FragmentBody) obj).objectList;\n\n        for (int i = 0; i < objectList.size(); i++) {\n            if (((AbstractMP3Object) objectList.get(i)).getValue() != null) {\n                if (superset.contains(objectList.get(i)) == false) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n",
    "115133": "    public boolean equals(Object obj) {\n        if ((obj instanceof AbstractMP3FragmentBody) == false) {\n            return false;\n        }\n\n        AbstractMP3FragmentBody object = (AbstractMP3FragmentBody) obj;\n\n        if (this.objectList.equals(object.objectList) == false) {\n            return false;\n        }\n\n        return super.equals(obj);\n    }\n",
    "115134": "    public Iterator iterator() {\n        return objectList.iterator();\n    }\n",
    "115138": "    public String toString() {\n        String            str = getIdentifier() + \"\\n\";\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n            str += (object.getIdentifier() + \" = \" + object.toString() + \"\\n\");\n        }\n\n        return str;\n    }\n",
    "115143": "    public boolean hasFilenameTag() {\n        return (filenameTag != null);\n    }\n",
    "115147": "    public void equals() {\n        /**\n         * @todo Implement this java.lang.Object method\n         */\n        throw new java.lang.UnsupportedOperationException(\"Method equals() not yet implemented.\");\n    }\n",
    "115149": "    public boolean hasID3v1Tag() {\n        return (id3v1tag != null);\n    }\n",
    "115153": "    public void setLanguage(String lang) {\n        if (TagConstant.languageIdToString.containsKey(lang)) {\n            language = lang;\n        }\n    }\n",
    "115161": "    public boolean hasID3v2Tag() {\n        return (id3v2tag != null);\n    }\n",
    "115166": "    public String getLanguage() {\n        return language;\n    }\n",
    "115177": "    public boolean hasLyrics3Tag() {\n        return (lyrics3tag != null);\n    }\n",
    "115225": "    public void setLyrics3SaveField(String id, boolean save) {\n        this.lyrics3SaveFieldMap.put(id, new Boolean(save));\n    }\n",
    "115240": "    public boolean getLyrics3SaveField(String id) {\n        return ((Boolean) lyrics3SaveFieldMap.get(id)).booleanValue();\n    }\n",
    "115281": "    private int getFrameSize() {\n        if (this.frequency == 0) {\n            return 0;\n        }\n\n        int size = 0;\n        int paddingByte;\n\n        if (padding) {\n            paddingByte = 1;\n        } else {\n            paddingByte = 0;\n        }\n\n        if (this.layer == 3) { // Layer I\n            size = (int) ((((12 * this.bitRate) / this.frequency) + paddingByte) * 4);\n        } else {\n            size = (int) (((144 * this.bitRate) / this.frequency) + paddingByte);\n        }\n\n        //if (protection) size += 2;\n        return size;\n    }\n",
    "115338": "    public void setPlayCounterSize(byte size) {\n        if (size > 0) {\n            playCounterSize = size;\n        }\n    }\n",
    "115356": "    public byte getPlayCounterSize() {\n        return playCounterSize;\n    }\n",
    "115377": "    public void setTextEncoding(byte enc) {\n        if ((enc >= 0) && (enc <= 3)) {\n            textEncoding = enc;\n        }\n    }\n",
    "115386": "    public byte getTextEncoding() {\n        return textEncoding;\n    }\n",
    "115399": "    public void setTimeStampFormat(byte tsf) {\n        if ((tsf == 1) || (tsf == 2)) {\n            timeStampFormat = tsf;\n        }\n    }\n",
    "115416": "    public byte getTimeStampFormat() {\n        return timeStampFormat;\n    }\n",
    "115660": "    public void setTimeStamp(long timeStamp, byte timeStampFormat) {\n        /**\n         * @todo convert both types of formats\n         */\n        timeStamp = timeStamp / 1000;\n        minute    = timeStamp / 60;\n        second    = timeStamp % 60;\n    }\n",
    "115693": "    static public boolean isMatchingParenthesis(String str) {\n        if (str != null) {\n            TagOptionSingleton option = TagOptionSingleton.getInstance();\n            int                length = str.length();\n            char               ch;\n\n            for (int i = 0; i < length; i++) {\n                ch = str.charAt(i);\n\n                if (option.isCloseParenthesis(\"\" + ch)) {\n                    return false;\n                }\n\n                if (option.isOpenParenthesis(\"\" + ch)) {\n                    i = findMatchingParenthesis(str, i);\n\n                    if (i < 0) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "115696": "    public String composeFilename() {\n        String filename = \"\";\n\n        if (beforeComposite != null) {\n            filename += (beforeComposite.composeFilename() + \" \");\n        }\n\n        if (afterComposite != null) {\n            filename += afterComposite.composeFilename();\n        }\n\n        return filename.trim();\n    }\n",
    "115699": "    public void setComposite(AbstractFilenameComposite composite) {\n        this.composite = composite;\n    }\n",
    "115701": "    static public long getWholeNumber(Object value) {\n        long number;\n\n        if (value instanceof String) {\n            number = Long.parseLong((String) value);\n        } else if (value instanceof Byte) {\n            number = ((Byte) value).byteValue();\n        } else if (value instanceof Short) {\n            number = ((Short) value).shortValue();\n        } else if (value instanceof Integer) {\n            number = ((Integer) value).intValue();\n        } else if (value instanceof Long) {\n            number = ((Long) value).longValue();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported value class: \" + value.getClass().getName());\n        }\n\n        return number;\n    }\n",
    "115703": "    public AbstractFilenameComposite getComposite() {\n        return composite;\n    }\n",
    "115709": "    public void setId3v2FrameBodyClass(Class id3v2FrameBodyClass) {\n        this.id3v2FrameBodyClass = id3v2FrameBodyClass;\n    }\n",
    "115710": "    public void setFrame(AbstractID3v2Frame frame) {\n        if (frame != null) {\n            if (id3tag == null) {\n                id3tag = new ID3v2_4();\n            }\n\n            id3tag.setFrame(frame);\n\n            if (composite != null) {\n                composite.setFrame(frame);\n            }\n        }\n    }\n",
    "115711": "    public Class getId3v2FrameBodyClass() {\n        return id3v2FrameBodyClass;\n    }\n",
    "115712": "    public AbstractID3v2Frame getFrame(String identifier) {\n        if (id3tag != null) {\n            return id3tag.getFrame(identifier);\n        }\n\n        return null;\n    }\n",
    "115713": "    public void setToken(String token) {\n        this.token = token.trim();\n    }\n",
    "115716": "    public String getToken() {\n        return token;\n    }\n",
    "115717": "    public void setId3tag(ID3v2_4 id3tag) {\n        this.id3tag = id3tag;\n\n        if (id3tag != null) {\n            Iterator iterator = id3tag.iterator();\n\n            while (iterator.hasNext()) {\n                composite.setFrame((AbstractID3v2Frame) iterator.next());\n            }\n\n            if (composite != null) {\n                composite.matchAgainstTag(id3tag);\n            }\n        }\n    }\n",
    "115718": "    public String composeFilename() {\n        return token;\n    }\n",
    "115720": "    public ID3v2_4 getId3tag() {\n        return id3tag;\n    }\n",
    "115721": "    public Iterator iterator() {\n        return new FilenameTokenIterator(this);\n    }\n",
    "115728": "    public String toString() {\n        return id3v2FrameBodyClass + \": \" + token;\n    }\n",
    "115731": "    public boolean hasNext() {\n        boolean nextFlag = false;\n\n        if (beforeIterator != null) {\n            nextFlag = nextFlag || beforeIterator.hasNext();\n        }\n\n        if (afterIterator != null) {\n            nextFlag = nextFlag || afterIterator.hasNext();\n        }\n\n        return nextFlag;\n    }\n",
    "115732": "    public Object next() {\n        if ((beforeIterator != null) && beforeIterator.hasNext()) {\n            return beforeIterator.next();\n        } else if ((afterIterator != null) && afterIterator.hasNext()) {\n            return afterIterator.next();\n        } else {\n            throw new NoSuchElementException(\"Iteration has no more elements.\");\n        }\n    }\n",
    "115734": "    public void remove() {\n        /**\n         * @todo Implement this java.util.Iterator method\n         */\n        throw new java.lang.UnsupportedOperationException(\"Method remove() not yet implemented.\");\n    }\n",
    "115737": "    public boolean hasNext() {\n        boolean nextFlag = false;\n\n        if (beforeIterator != null) {\n            nextFlag = nextFlag || beforeIterator.hasNext();\n        }\n\n        if (middleIterator != null) {\n            nextFlag = nextFlag || middleIterator.hasNext();\n        }\n\n        if (afterIterator != null) {\n            nextFlag = nextFlag || afterIterator.hasNext();\n        }\n\n        return nextFlag;\n    }\n",
    "115739": "    public Object next() {\n        if ((beforeIterator != null) && beforeIterator.hasNext()) {\n            return beforeIterator.next();\n        } else if ((middleIterator != null) && middleIterator.hasNext()) {\n            return middleIterator.next();\n        } else if ((afterIterator != null) && afterIterator.hasNext()) {\n            return afterIterator.next();\n        }\n\n        throw new NoSuchElementException(\"Iteration has no more elements.\");\n    }\n",
    "115742": "    public void setOriginalToken(String originalToken) {\n        this.originalToken = originalToken;\n    }\n",
    "115743": "    public String getOriginalToken() {\n        return originalToken;\n    }\n",
    "115744": "    public boolean hasNext() {\n        return returnedToken == false;\n    }\n",
    "115746": "    public Object next() {\n        if (returnedToken == false) {\n            returnedToken = true;\n\n            return filenameToken;\n        }\n\n        throw new NoSuchElementException(\"Iteration has no more elements.\");\n    }\n",
    "115748": "    static public String replaceEOLNwithCRLF(String text) {\n        String newText = null;\n\n        if (text != null) {\n            newText = \"\";\n\n            int oldPos = 0;\n            int newPos = text.indexOf('\\n');\n\n            while (newPos >= 0) {\n                newText += (text.substring(oldPos, newPos) + TagConstant.CRLF);\n                oldPos = ++newPos;\n                newPos = text.indexOf('\\n', oldPos);\n            }\n\n            newText += text.substring(oldPos);\n        }\n\n        return newText;\n    }\n",
    "115751": "    public void setMiddleComposite(AbstractFilenameComposite middleComposite) {\n        this.middleComposite = middleComposite;\n    }\n",
    "115753": "    public AbstractFilenameComposite getMiddleComposite() {\n        return middleComposite;\n    }\n",
    "115754": "    public void setOpenDelimiter(String openDelimiter) {\n        this.openDelimiter = openDelimiter;\n    }\n",
    "115756": "    public String getOpenDelimiter() {\n        return openDelimiter;\n    }\n",
    "115757": "    public String composeFilename() {\n        String filename = \"\";\n\n        if (beforeComposite != null) {\n            filename += beforeComposite.composeFilename();\n        }\n\n        filename += (\" \" + openDelimiter);\n\n        if (middleComposite != null) {\n            filename += middleComposite.composeFilename();\n        }\n\n        filename += (TagOptionSingleton.getInstance().getCloseParenthesis(openDelimiter) + \" \");\n\n        if (afterComposite != null) {\n            filename += afterComposite.composeFilename();\n        }\n\n        return filename;\n    }\n",
    "115761": "    public Iterator iterator() {\n        return new FilenameParenthesisIterator(this);\n    }\n",
    "115763": "    public void matchAgainstKeyword(Class id3v2FrameBodyClass) {\n        if (AbstractID3v2FrameBody.class.isAssignableFrom(id3v2FrameBodyClass)) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n\n            if (middleComposite != null) {\n                middleComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n        }\n    }\n",
    "115765": "    public void matchAgainstTag(AbstractMP3Tag matchTag) {\n        if (matchTag != null) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstTag(matchTag);\n            }\n\n            if (middleComposite != null) {\n                middleComposite.matchAgainstTag(matchTag);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstTag(matchTag);\n            }\n        }\n    }\n",
    "115771": "    static public String stripChar(String str, char ch) {\n        if (str != null) {\n            char[] buffer = new char[str.length()];\n            int    next = 0;\n\n            for (int i = 0; i < str.length(); i++) {\n                if (str.charAt(i) != ch) {\n                    buffer[next++] = str.charAt(i);\n                }\n            }\n\n            return new String(buffer, 0, next);\n        } else {\n            return null;\n        }\n    }\n",
    "115775": "    public void setAfterComposite(AbstractFilenameComposite afterComposite) {\n        this.afterComposite = afterComposite;\n    }\n",
    "115776": "    public AbstractFilenameComposite getAfterComposite() {\n        return afterComposite;\n    }\n",
    "115777": "    public void setBeforeComposite(AbstractFilenameComposite beforeComposite) {\n        this.beforeComposite = beforeComposite;\n    }\n",
    "115778": "    static public void updateCompositeFromAllOption(AbstractFilenameComposite composite) {\n        Iterator iterator = TagOptionSingleton.getInstance().getKeywordIterator();\n\n        while (iterator.hasNext()) {\n            composite.matchAgainstKeyword((Class) iterator.next());\n        }\n    }\n",
    "115779": "    public AbstractFilenameComposite getBeforeComposite() {\n        return beforeComposite;\n    }\n",
    "115780": "    public void setDelimiter(String delimiter) {\n        this.delimiter = delimiter;\n    }\n",
    "115781": "    static public void updateCompositeFromAllTag(AbstractFilenameComposite composite, MP3File mp3File) {\n        composite.matchAgainstTag(mp3File.getID3v1Tag());\n        composite.matchAgainstTag(mp3File.getID3v2Tag());\n        composite.matchAgainstTag(mp3File.getLyrics3Tag());\n    }\n",
    "115782": "    public String getDelimiter() {\n        return delimiter;\n    }\n",
    "115786": "    public String composeFilename() {\n        String filename = \"\";\n\n        if (beforeComposite != null) {\n            filename += beforeComposite.composeFilename();\n        }\n\n        filename += (delimiter + \" \");\n\n        if (afterComposite != null) {\n            filename += afterComposite.composeFilename();\n        }\n\n        return filename;\n    }\n",
    "115791": "    public Iterator iterator() {\n        return new FilenameDelimiterIterator(this);\n    }\n",
    "115794": "    public void matchAgainstKeyword(Class id3v2FrameBodyClass) {\n        if (AbstractID3v2FrameBody.class.isAssignableFrom(id3v2FrameBodyClass)) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n        }\n    }\n",
    "115797": "    public void matchAgainstTag(AbstractMP3Tag matchTag) {\n        if (matchTag != null) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstTag(matchTag);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstTag(matchTag);\n            }\n        }\n    }\n",
    "115820": "    static private StringBuffer capitalizeWord(String word, boolean keepUppercase) {\n        if (word == null) {\n            return null;\n        }\n\n        StringBuffer wordBuffer = new StringBuffer();\n        int          index = 0;\n\n        if (keepUppercase && word.toUpperCase().equals(word)) {\n            wordBuffer.append(word);\n        } else {\n            word = word.toLowerCase();\n\n            int  len = word.length();\n            char ch;\n            ch = word.charAt(index);\n\n            while (((ch < 'a') || (ch > 'z')) && (index < (len - 1))) {\n                ch = word.charAt(++index);\n            }\n\n            if (index < len) {\n                wordBuffer.append(word.substring(0, index));\n                wordBuffer.append((char) (ch + uppercase));\n                wordBuffer.append(word.substring(index + 1));\n            } else {\n                wordBuffer.append(word);\n            }\n        }\n\n        return wordBuffer;\n    }\n",
    "116237": "    public DocPosition adjustPosition(int adjustment){\n        position += adjustment;\n        return this;\n    }\n",
    "116238": "    public boolean equals(Object obj){\n        if (obj instanceof DocPosition){\n            DocPosition d = (DocPosition)(obj);\n            if (this.position == d.position){\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n",
    "116241": "    public String toString(){\n        return \"\" + position;\n    }\n",
    "116242": "    public boolean equals(Object obj){\n    \treturn this == obj;\n    }\n",
    "116243": "    public int compare(Object o1, Object o2){\n        if (o1 instanceof DocPosition && o2 instanceof DocPosition){\n            DocPosition d1 = (DocPosition)(o1);\n            DocPosition d2 = (DocPosition)(o2);\n            return (d1.getPosition() - d2.getPosition());\n        } else if (o1 instanceof DocPosition){\n            return -1;\n        } else if (o2 instanceof DocPosition){\n            return 1;\n        } else if (o1.hashCode() < o2.hashCode()){\n            return -1;\n        } else if (o2.hashCode() > o1.hashCode()){\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n",
    "116248": "\tpublic void run() {\n\t\twhile(document.get() != null) {\n\t\t\ttry {\n\t\t\t\tRecolorEvent re;\n\t\t\t\tsynchronized (eventsLock) {\n\t\t\t\t\t// get the next event to process - stalling until the\n\t\t\t\t\t// event becomes available\n\t\t\t\t\twhile(events.isEmpty() && document.get() != null) {\n\t\t\t\t\t\t// stop waiting after a second in case document\n\t\t\t\t\t\t// has been cleared.\n\t\t\t\t\t\teventsLock.wait(1000);\n\t\t\t\t\t}\n\t\t\t\t\tre = (RecolorEvent) events.removeFirst();\n\t\t\t\t}\n\t\t\t\tprocessEvent(re.position, re.adjustment);\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch(Exception ex) { }\n\t\t}\n\t}\n",
    "116263": "\tpublic void colorAll() {\n\t\tcolor(0, getLength());\n\t}\n",
    "116264": "\tpublic void color(int position, int adjustment) {\n\t\tcolorer.color(position, adjustment);\n\t}\n",
    "116268": "    public void update(int position, int adjustment){\n        if (position < this.position){\n            if (this.position < position - adjustment){\n                this.position = position;\n            } else {\n                this.position += adjustment;\n            }\n        }\n    }\n",
    "116269": "    public void close() {\n    }\n",
    "116271": "    public void mark(int readAheadLimit){\n        mark = position;\n    }\n",
    "116272": "    public boolean markSupported(){\n        return true;\n    }\n",
    "116273": "    public int read(){\n        if (position < document.getLength()){\n            try {\n                char c = document.getText((int)position, 1).charAt(0);\n                position++;\n                return c;\n            } catch (BadLocationException x){\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n    }\n",
    "116275": "    public int read(char[] cbuf){\n        return read(cbuf, 0, cbuf.length);\n    }\n",
    "116276": "    public int read(char[] cbuf, int off, int len){\n        if (position < document.getLength()){\n            int length = len;\n            if (position + length >= document.getLength()){\n                length = document.getLength() - (int)position;\n            }\n            if (off + length >= cbuf.length){\n                length = cbuf.length - off;\n            }\n            try {\n                String s = document.getText((int)position, length);\n                position += length;\n                for (int i=0; i<length; i++){\n                    cbuf[off+i] = s.charAt(i);\n                }\n                return length;\n            } catch (BadLocationException x){\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n    }\n",
    "116281": "    public long skip(long n){\n        if (position + n <= document.getLength()){\n            position += n;\n            return n;\n        } else {\n            long oldPos = position;\n            position = document.getLength();\n            return (document.getLength() - oldPos);\n        }\n    }\n",
    "116283": "    public void seek(long n){\n        if (n <= document.getLength()){\n            position = n;\n        } else {\n            position = document.getLength();\n        }\n    }\n",
    "116287": "    public boolean isReservedWord(){\n        return((id >> 8) == 0x1);\n    }\n",
    "116291": "    public boolean isIdentifier(){\n        return((id >> 8) == 0x2);\n    }\n",
    "116294": "    public boolean isLiteral(){\n        return((id >> 8) == 0x3);\n    }\n",
    "116299": "    public boolean isSeparator(){\n        return((id >> 8) == 0x4);\n    }\n",
    "116302": "    public boolean isOperator(){\n        return((id >> 8) == 0x5);\n    }\n",
    "116309": "    public boolean isComment(){\n        return((id >> 8) == 0xD);\n    }\n",
    "116315": "    public boolean isWhiteSpace(){\n        return((id >> 8) == 0xE);\n    }\n",
    "116320": "    public boolean isError(){\n        return((id >> 8) == 0xF);\n    }\n",
    "116325": "    public String getDescription(){\n        if (isReservedWord()){\n            return(\"reservedWord\");\n        } else if (id == METHOD){\n            return(\"method\");\n        } else if (isIdentifier()){\n            return(\"identifier\");\n        } else if (isLiteral()){\n            return(\"literal\");\n        } else if (isSeparator()){\n            return(\"separator\");\n        } else if (isOperator()){\n            return(\"operator\");\n        } else if (isComment()){\n            return(\"comment\");\n        } else if (isWhiteSpace()){\n            return(\"whitespace\");\n        } else if (isError()){\n            return(\"error\");\n        } else {\n            return(\"unknown\");\n        }\n    }\n",
    "116711": "    public void close() {\n\ttry {\n            file.close();\n            file = null;\n        }\n        catch (Exception e) { }\n    }\n",
    "116716": "    public Country getCountry(String ipAddress) {\n\tInetAddress addr;\n\ttry {\n\t    addr = InetAddress.getByName(ipAddress);\n\t}\n\tcatch (UnknownHostException e) {\n            return UNKNOWN_COUNTRY;\n\t}\n\treturn getCountry(bytesToLong(addr.getAddress()));\n    }\n",
    "116721": "    public boolean isPremium() {\n        return info.indexOf(\"FREE\") < 0;\n    }\n",
    "116722": "    public Date getDate() {\n        for (int i=0; i<info.length()-9; i++) {\n            if (Character.isWhitespace(info.charAt(i))) {\n                String dateString = info.substring(i+1, i+9);\n                try {\n                    synchronized (formatter) {\n                        return formatter.parse(dateString);\n                    }\n                }\n                catch (ParseException pe) {  }\n                break;\n            }\n        }\n        return null;\n    }\n",
    "116724": "    public Country getCountry(InetAddress ipAddress) {\n        return getCountry(bytesToLong(ipAddress.getAddress()));\n    }\n",
    "116727": "    public String getCode() {\n        return code;\n    }\n",
    "116733": "    public Country getCountry(long ipAddress) {\n        if (file == null) {\n            throw new IllegalStateException(\"Database has been closed.\");\n        }\n        int ret = seekCountry(ipAddress) - COUNTRY_BEGIN;\n        if (ret == 0) {\n            return UNKNOWN_COUNTRY;\n        }\n        else {\n            return new Country(countryCode[ret], countryName[ret]);\n        }\n    }\n",
    "116854": "\tpublic void init(IStructuredSelection selection) {\n\t\tIJavaElement jelem= getInitialJavaElement(selection);\n\t\tinitContainerPage(jelem);\n\t\tinitTypePage(jelem);\n\t\tdoStatusUpdate();\n\t}\n",
    "117158": "\tpublic void start(BundleContext context) throws Exception {\n\t    System.out.println(\"Starting JMX Console UI\");\n\t\tsuper.start(context);\n\t\tbundleContext = context;\n\t}\n",
    "117161": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tgetPreferences().flush();\n\t}\n",
    "117164": "\tpublic Preferences getPreferences() {\n\t\tIPreferencesService service = Platform.getPreferencesService();\n\t\tIEclipsePreferences root = service.getRootNode();\n\t\treturn root.node(InstanceScope.SCOPE).node(getBundle().getSymbolicName());\n\t}\n",
    "117170": "\tpublic void addChild(NodeAbstract child) {\n\t\tchildren.add(child);\t\n\t\tchild.setParent(this);\n\t}\n",
    "117172": "\tpublic void removeChild(NodeAbstract child) {\n\t\tchildren.remove(child);\n\t\tchild.setParent(null);\n\t}\n",
    "117175": "\tpublic boolean hasChildren() {\n\t\treturn children.size() > 0;\n\t}\n",
    "117177": "\tpublic void removeAllChildren () {\n\t\tchildren.clear();\n\t}\n",
    "117186": "\tpublic void setParent(NodeAbstract parent) {\n\t\tthis.parent = parent;\n\t}\n",
    "117188": "\tpublic NodeAbstract getParent() {\n\t\treturn parent;\n\t}\n",
    "117194": "\tpublic Object getAdapter(Class key) {\n\t    if (key.equals(NodeAbstract.class))\n\t        return this;\n\t\treturn null;\n\t}\n",
    "117197": "\tpublic void addServer(NodeServer server) {\n\t    modelChangedEventDisabled = true;\n\t\taddChild(server);\n\t\tpersistServer(server);\n\t\tmodelChangedEventDisabled = false;\n\t\temitModelChangeEvent(this);\t\t\n\t}\n",
    "117204": "\tpublic void removeServer(NodeServer server) {\n\t\t\n\t\tmodelChangedEventDisabled = true;\n\n\t\ttry { \n\t    //    server.disconnect();\n\t    } catch (Exception e) {}\n\t\tremoveChild(server);\n\t\ttry {\n\t\t    Preferences modelPrefs = getModelPrefNode();\n\t\t\tmodelPrefs.node(server.getName()).removeNode();\n        } catch (BackingStoreException e) {\n            System.out.println(\"Unable to save the model to disk: \" + e.getMessage());\n        }\n\n\t\tmodelChangedEventDisabled = false;\n\t\temitModelChangeEvent(this);\t\n\t}\n",
    "117208": "\tpublic void refresh() throws Exception {\n\t\tmodelChangedEventDisabled = true;\n\t\tObject[] servers = getChildren();\n\t\tfor (int i = 0; i < servers.length;  i++) {\n//\t\t\t((ChatAppsServer) servers[i]).refresh();\n\t\t}\n\t\tmodelChangedEventDisabled = false;\n\t\temitModelChangeEvent(this);\n\t}\n",
    "117220": "\tpublic void createPartControl(Composite parent) {\n\t\t// Create the tree viewer\n\t\tviewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);\n\t\tcontent = new ViewContentProvider(getViewSite(), model);\n\t\tviewer.setContentProvider(content);\n\t\tviewer.setLabelProvider(new ViewLabelProvider());\n//\t\tviewer.setSorter(new NameSorter());\n\t\tviewer.setInput(getViewSite());\n\t\t\n\t\t// Register with the model change listener\n\t\tmodel.addModelChangeListener(this);\n\t\t\n\t\t// Build the GUI\n\t\tmakeActions();\n\t\thookContextMenu();\n\t\thookSelectionChangedAction();\n\t\tcontributeToActionBars();\n\t}\n",
    "117229": "\tprivate void hookContextMenu() {\n\t\tMenuManager menuMgr = new MenuManager(\"#PopupMenu\");\n\t\tmenuMgr.setRemoveAllWhenShown(true);\n\t\tmenuMgr.addMenuListener(new IMenuListener() {\n\t\t\tpublic void menuAboutToShow(IMenuManager manager) {\n\t\t\t\tServerView.this.fillContextMenu(manager);\n\t\t\t}\n\t\t});\n\t\tMenu menu = menuMgr.createContextMenu(viewer.getControl());\n\t\tviewer.getControl().setMenu(menu);\n\t\tgetSite().registerContextMenu(menuMgr, viewer);\n\t}\n",
    "117242": "\tprivate void contributeToActionBars() {\n\t\tIActionBars bars = getViewSite().getActionBars();\n\t\tfillLocalPullDown(bars.getMenuManager());\n\t\tfillLocalToolBar(bars.getToolBarManager());\n\t}\n",
    "117247": "\tprotected Control createContents(Composite parent) {\n\t\tIProject project = (IProject) (this.getElement().getAdapter(IProject.class));\n\t\tchatappsProject = ChatAppsPlugin.getChatAppsProject(project);  \n\t\t\t\t\n\t\tComposite composite = new Composite(parent, SWT.NULL);\n\t\tcomposite.setLayout(new GridLayout(3, false));\n\t\tcomposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n\n\t\tcreateDomainName(composite);\n\t\tcreateFacadeClass(composite);\n\t\treturn composite;\n\t}\n",
    "117250": "\tprivate void fillLocalPullDown(IMenuManager manager) {\n\t\tmanager.add((Action) actionMap.get(AddServerAction.ID));\n//\t\tmanager.add((Action) actionMap.get(RemoveAction.ID));\n//\t\tmanager.add((Action) actionMap.get(RefreshAction.ID));\n\t\tmanager.add(new Separator());\n\t}\n",
    "117252": "\tpublic boolean performOk() {\n\t\ttry {\n\t\t\tchatappsProject.setDomainName(txtDomainName.getText());\n\t\t\tchatappsProject.setFacadeClass(txtFacadeClass.getText());\n\t\t\tchatappsProject.saveProperties();\n\t\t} catch (Exception ex) {\n\t\t\tChatAppsPlugin.log(ex.getMessage());\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "117262": "\tprivate void fillLocalToolBar(IToolBarManager manager) {\n\t\tmanager.add((Action) actionMap.get(AddServerAction.ID));\n\t\tmanager.add(new Separator());\n\t}\n",
    "117271": "\tprivate void hookSelectionChangedAction() {\n\t\tfinal IWorkbenchPart workbenchPart = this;\n\t\tviewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\t\t\tpublic void selectionChanged(SelectionChangedEvent sce) {\n\t\t\t    Iterator iter = actionMap.values().iterator();\n\t\t\t    while (iter.hasNext()) \n\t\t\t        ((BaseAction) iter.next()).checkState();\n\t\t\t}\n\t\t});\n\t}\n",
    "117280": "\tprivate void showMessage(String message) {\n\t\tMessageDialog.openInformation(viewer.getControl().getShell(),\n\t\t\t\t\"JMX Server View\", message);\n\t}\n",
    "117282": "\tpublic void setCompletionProposalAutoActivationCharacters(char[] activationSet) {\n\t\tfProposalAutoActivationSet= activationSet;\n\t}\n",
    "117284": "\tpublic void addServer (NodeServer server) {\n\t\tmodel.addServer(server);\n\t}\n",
    "117285": "\tpublic void restrictProposalsToVisibility(boolean restrict) {\n\t\tHashtable options= JavaCore.getOptions();\n\t\tObject value= options.get(VISIBILITY);\n\t\tif (value instanceof String) {\n\t\t\tString newValue= restrict ? ENABLED : DISABLED;\n\t\t\tif ( !newValue.equals(value)) {\n\t\t\t\toptions.put(VISIBILITY, newValue);\n\t\t\t\tJavaCore.setOptions(options);\n\t\t\t}\n\t\t}\n\t}\n",
    "117288": "\tpublic void orderProposalsAlphabetically(boolean order) {\n\t\tfComparator.setOrderAlphabetically(order);\n\t}\n",
    "117289": "\tpublic void dispose() {\n//\t\tmodel.removeModelChangeListener(this);\n\t\tsuper.dispose();\n\t}\n",
    "117290": "\tpublic void restrictProposalsToMatchingCases(boolean restrict) {\n\t\t// not yet supported\n\t}\n",
    "117293": "\tpublic void setFocus() {\n\t\tviewer.getControl().setFocus();\n\t}\n",
    "117448": "    public  void checkState () {}\n",
    "117574": "    public void createInitialLayout(IPageLayout layout) {\n        defineActions(layout);\n        defineLayout(layout);\n    }\n",
    "117883": "\tpublic void actionPerformed(ActionEvent e) {\n\n\t\ttry {\t\t\n\t\t\tBrowserLauncher.openURL(\"http://www.jgpd.com/\");\t\t\n\t\t} catch (Exception ex){\n\t\t\tJOptionPane.showMessageDialog(graphpad, ex.toString(), Translator.getString(\"Error\"), JOptionPane.ERROR_MESSAGE );\n\t\t}\n\t\t\n\t}\n",
    "117886": "\tpublic void actionPerformed(ActionEvent e) {\n\n\t\ttry {\t\t\n\t\t\tBrowserLauncher.openURL(\"http://sourceforge.net/tracker/?func=add&group_id=90011&atid=592210\");\t\t\n\t\t} catch (Exception ex){\n\t\t\tJOptionPane.showMessageDialog(graphpad, ex.toString(), Translator.getString(\"Error\"), JOptionPane.ERROR_MESSAGE );\n\t\t}\n\t\t\n\t}\n",
    "117898": "\tpublic void clear() {\n\t\trootNode.removeAllChildren();\n\t\ttreeModel.reload();\n\t}\n",
    "117901": "\tpublic void removeCurrentNode() {\n\t\tTreePath currentSelection = tree.getSelectionPath();\n\t\tif (currentSelection != null) {\n\t\t\tDefaultMutableTreeNode currentNode = (DefaultMutableTreeNode)\n\t\t\t\t\t\t (currentSelection.getLastPathComponent());\n\t\t\tMutableTreeNode parent = (MutableTreeNode)(currentNode.getParent());\n\t\t\tif (parent != null) {\n\t\t\t\ttreeModel.removeNodeFromParent(currentNode);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} \n\n\t\t// Either there was no selection, or the root was selected.\n\t\t// FIXME\n\t}\n",
    "117904": "\tpublic DefaultMutableTreeNode addObject(Object child) {\n\t\tDefaultMutableTreeNode parentNode = null;\n\t\tTreePath parentPath = tree.getSelectionPath();\n\n\t\tif (parentPath == null) {\n\t\t\tparentNode = rootNode;\n\t\t} else {\n\t\t\tparentNode = (DefaultMutableTreeNode)\n\t\t\t\t\t\t (parentPath.getLastPathComponent());\n\t\t}\n\n\t\treturn addObject(parentNode, child, true);\n\t}\n",
    "117949": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tif (EDIT.equals(e.getActionCommand())) {\n\t\t\t//The user has clicked the cell, so\n\t\t\t//bring up the dialog.\n//\t\t\tbutton.setBackground(currentColor);\n//\t\t\tcolorChooser.setColor(currentColor);\n\t\t\t//Set up the dialog that the button brings up.\n\t\t\tdialog = new File_PackageWizard(frame, // owner frame\n\t\t\t\t\t\t\t\t\t\t\tnew String(\"File Selection Wizard\"),\n\t\t\t\t\t\t\t\t\t\t\t600,  // width\n\t\t\t\t\t\t\t\t\t\t\t350,  // height\n\t\t\t\t\t\t\t\t\t\t\t5,   // number of wizard screens\n\t\t\t\t\t\t\t\t\t\t\tthis);\n\t\t\tdialog.setModal(true);\n\t\t\tdialog.setVisible(true);\n\n\t\t\t//Make the renderer reappear.\n\t\t\tfireEditingStopped();\n\n\t\t}\n\t}\n",
    "118318": "\tpublic Object clone() {\n\t\tJGpdGraphCell c = (JGpdGraphCell) super.clone();\n\t\treturn c;\n\t}\n",
    "118322": "\tprotected Object cloneUserObject() {\n\t\tif (userObject instanceof ValueChangeHandler)\n\t\t\treturn ((ValueChangeHandler) userObject).clone();\n\t\treturn userObject;\n\t}\n",
    "118327": "    public String toString() {\n        return \"Spring Embedded\";\n    }\n",
    "118332": "    public LayoutAlgorithm getLayoutAlgorithm() {\n        return new SpringEmbeddedLayoutAlgorithm();\n    }\n",
    "118338": "    protected boolean isTrue(String boolValue){\n        if( boolValue != null ){\n            if( \"TRUE\".equals(boolValue.toUpperCase()) ){\n                return true;\n            }\n            else if( \"FALSE\".equals(boolValue.toUpperCase()) ){\n                return false;\n            }\n        }\n        return false;\n    }\n",
    "118341": "    private void action_cancel() {\n        setVisible(false);\n        dispose();\n        canceled = true;\n    }\n",
    "118352": "    public boolean isCanceled() {\n        return canceled;\n    }\n",
    "118354": "    private boolean initialize(){\n        \n        dlgProgress.setVisible(true);\n        dlgProgress.setMessage(phaseName[PHASE_INITIALISATION]);\n        \n        int length = cellList.size();\n        \n        for( int i = 0; i < length; i++ ){\n            \n            CellView view = (CellView) cellList.get(i);\n            \n            initializeVertice(view);\n            \n            if( updateProgressDialog(PHASE_INITIALISATION,\n                                     i,\n                                     length) )\n                                     \n                return true; // canceled        \n        }\n        \n        for( int i = 0; i < applyCellList.size(); i++ )\n            computeLastImpulse( (CellView) applyCellList.get(i) );\n            \n        return false;    //not canceled\n    }\n",
    "118360": "    private void initializeVertice(CellView view){\n            Map attributes = view.getAttributes();\n            if( attributes == null )\n                attributes = new Hashtable();\n                \n            attributes.put(KEY_CAPTION,KEY_CAPTION);\n            \n            initPosition(view);                       \n\n            if( isCluster(view) ){\n                attributes.put(KEY_TEMPERATURE,\n                               new Double(clusterInitTemperature));\n            }\n            else attributes.put(KEY_TEMPERATURE,\n                                new Double(initTemperature));\n            \n            attributes.put(KEY_SKEWGAUGE,  new Double(0.0));\n            attributes.put(KEY_CURRENT_IMPULSE,new Point2D.Double());\n            attributes.put(KEY_LAST_IMPULSE   ,new Point2D.Double());\n    }\n",
    "118368": "    private boolean updateProgressDialog(int phase, int round, int maxRound){\n        \n        int lowValue = 0;\n        if( phase != 0 ) \n            lowValue = phaseLength[phase-1];\n        \n        int maxValue = phaseLength[phase];\n        \n        int width = maxValue - lowValue;\n        \n        int value = lowValue+(int)(width*((double)round/(double)maxRound));\n        \n        dlgProgress.setValue(value);\n        \n        return dlgProgress.isCanceled();\n    }\n",
    "118372": "    private void computeCurrentImpulse(CellView view){\n        \n        //gets the impulse for view\n        Point2D.Double impulse = computeImpulse(view);\n        \n        //set result into node\n        view.getAttributes().put(KEY_CURRENT_IMPULSE,impulse);\n    }\n",
    "118377": "    private void computeLastImpulse(CellView view){\n        \n        //gets the impulse for view\n        Point2D.Double impulse = computeImpulse(view);\n        \n        //set result into node\n        view.getAttributes().put(KEY_LAST_IMPULSE,impulse);\n    }\n",
    "118393": "    private void closeDialog() {\n        action_cancel();\n    }\n",
    "118400": "    private void removeTemporaryLayoutDataFromCells(){\n        \n        for( int i = 0; i < cellList.size(); i++ )\n            ((CellView)cellList.get(i)).getAttributes().clear();\n    }\n",
    "118410": "    private void correctCoordinates(){\n        Rectangle boundingBox = getBoundingBox();\n        if( boundingBox != null ){\n            for( int i = 0; i < cellList.size(); i++ ){\n                CellView view = (CellView) cellList.get(i);\n                Point2D.Double pos = getPosition(view);\n                Point2D.Double newPos = new Point2D.Double(\n                                                      pos.x-boundingBox.getX(),\n                                                      pos.y-boundingBox.getY());\n                view.getAttributes().put(KEY_POSITION,newPos);\n            }\n        }\n    }\n",
    "118414": "    private Rectangle getBoundingBox(){\n        return getBoundingBox(cellList);\n    }\n",
    "118421": "    private double getTemperature(int index, ArrayList list){\n        \n        Double temperature = (Double) getAttribute(index,KEY_TEMPERATURE,list);\n        return temperature.doubleValue();\n    }\n",
    "118438": "    protected ArrayList getAdditionalForces(VertexView view){\n        return new ArrayList();\n    }\n",
    "118453": "    protected void computeClusterPosition(VertexView cluster){\n        ArrayList clusteredVertices = (ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);\n        Point2D.Double clusterPos = computeBarycenter(clusteredVertices);\n        cluster.getAttributes().put(KEY_POSITION,clusterPos);\n    }\n",
    "118459": "    protected boolean isCluster(CellView cell){\n        if( cell.getAttributes().containsKey(KEY_IS_CLUSTER)){\n            if( isTrue((String)cell.getAttributes().get(KEY_IS_CLUSTER))){\n                return true;\n            }\n            else {\n                System.err.println(\"FATAL ERROR: CELL CANNOT CLEARLY BE IDENTIFIED AS A CLUSTER!!!\");\n                return false;\n            }        \n        }\n        else return false;        \n    }\n",
    "118473": "\tprotected double fa(double x, double k) {\n\t\tdouble force = (x * x / k);\n\t\treturn force;\n\t}\n",
    "118475": "\tprotected double fr(double x, double k) {\n\t\tdouble force = (k * k) / x;\n\t\treturn force;\n\t}\n",
    "118476": "\tprotected double norm(Rectangle p) {\n\t\tdouble x = p.x;\n\t\tdouble y = p.y;\n\t\tdouble norm = Math.sqrt(x * x + y * y);\n\t\treturn norm;\n\t}\n",
    "118485": "    private void action_ok() {\n        try {\n            Integer.parseInt(horizontalSpacingTextField.getText());\n            Integer.parseInt(verticalSpacingTextField.getText());\n        } catch (Exception e) {\n\t\t\tString message = Translator.getString(\"Error.SpacingMustBeNumbers\"/*#Finished:Original=\"Spacing must be numbers\"*/);\n            JOptionPane.showMessageDialog(this, message, Translator.getString(\"Error\"), JOptionPane.INFORMATION_MESSAGE);\n            return;\n        }\n        setVisible(false);\n        dispose();\n        canceled = false;\n    }\n",
    "118486": "    public boolean canceled() {\n        return canceled;\n    }\n",
    "118487": "    public String getIndention() {\n        return horizontalSpacingTextField.getText().trim();\n    }\n",
    "118488": "    public String getVerticalSpacing() {\n        return verticalSpacingTextField.getText().trim();\n    }\n",
    "118489": "    public void setIndention(String text) {\n        horizontalSpacingTextField.setText(text);\n    }\n",
    "118490": "    public void setVerticalSpacing(String text) {\n        verticalSpacingTextField.setText(text);\n    }\n",
    "118506": "    public boolean performOptimization(ArrayList applyList, ArrayList allCellList, ArrayList allEdgeList, Properties config, ProgressDialog dialog){\n        cellList  = allCellList;\n        applyCellList = applyList;\n        edgeList = allEdgeList;\n        \n        presetConfig = config;\n        \n        dlgProgress = dialog;\n        initProgressValue = dialog.getValue();\n\n        loadConfiguration(CONFIG_KEY_RUN);\n        \n        init(false);\n        boolean isCancled = run();\n        \n        return isCancled;\n    }\n",
    "118512": "    protected void loadAdditionalConfiguration(int configSwitch){\n    }\n",
    "118524": "    private void removeTemporaryData(){\n        for( int i = 0; i < applyCellList.size(); i++ )\n            ((CellView)applyCellList.get(i)).getAttributes().clear();        \n    }\n",
    "118530": "    private boolean run(){\n        boolean isCancled = false;\n        while( round <= maxRounds && !isCancled)\n            isCancled = performRound();\n        return isCancled;\n    }\n",
    "118539": "    protected double getAdditionalCosts(int cfConfig, double[] lambda){\n        return 0.0;\n    }\n",
    "118542": "    private boolean getBolzmanBreak(double oldEnergy, double newEnergy){\n        return Math.random() < Math.pow(Math.E,(oldEnergy-newEnergy)/temperature);\n    }\n",
    "118544": "    private int getMaxRoundsByTemperature(double actualTemperature){\n        return (int)Math.ceil( Math.log(minTemperature/actualTemperature) /\n                                Math.log(tempScaleFactor));\n    }\n",
    "118568": "    private ArrayList getRelevantEdges(CellView except){\n        ArrayList relevantEdgeList = new ArrayList();\n        for( int i = 0; i < edgeList.size(); i++ ){\n            CellView view = ((EdgeView)edgeList.get(i)).getSource().getParentView();\n            if( view != except &&\n                applyCellList.contains(view) ){\n                relevantEdgeList.add(edgeList.get(i));\n            }\n            else {\n                view = ((EdgeView)edgeList.get(i)).getTarget().getParentView();\n                if( view != except &&\n                    applyCellList.contains(view) ){\n                    relevantEdgeList.add(edgeList.get(i));\n                }\n            }\n        }\n        return relevantEdgeList;\n    }\n",
    "118570": "    private void setPosition(CellView view, Point2D.Double pos){\n        setAttribute(view,KEY_POSITION,pos);\n    }\n",
    "118574": "    private void setPosition(int index, double x, double y){\n        setPosition((CellView)applyCellList.get(index),x,y);\n    }\n",
    "118579": "    private void setPosition(CellView view, double x, double y){\n        setPosition(view,new Point2D.Double(x,y));\n    }\n",
    "118582": "    private void setAttribute(CellView view,String key, Object obj){\n        if( view.getAttributes() == null )\n            view.setAttributes(new Hashtable());\n        Map attributes = view.getAttributes();\n        attributes.put(key,obj);\n    }\n",
    "118584": "    private Object getAttribute(CellView view, String key){\n        return view.getAttributes().get(key);\n    }\n",
    "118591": "    protected ArrayList getRelativesFrom(ArrayList list, CellView view){\n        ArrayList relatives = getRelatives(view);\n        ArrayList result    = new ArrayList();\n        for( int i = 0; i < relatives.size(); i++ )\n            if( list.contains(relatives.get(i)) )\n                result.add(relatives.get(i));\n        return result;\n    }\n",
    "118684": "        protected void init() {\n                // netbeans\n                initComponents();\n\n                // fill the list\n                fillList();\n\n                // select the first one\n                try {\n                        lstLayoutControllers.setSelectedIndex(0);\n                } catch (Exception e) {\n                }\n        }\n",
    "118685": "        protected void fillList() {\n                try {\n                        DefaultListModel model = new DefaultListModel();\n                        Iterator all = LayoutRegistry.registeredLayoutControllers();\n\n                        while (all.hasNext()) {\n                                LayoutController controller = (LayoutController) all.next();\n                                model.addElement(controller);\n                        }\n                        \n                        \n                        lstLayoutControllers.setModel(model);\n                } catch (Exception e) {\n                        e.printStackTrace();\n                }\n        }\n",
    "118686": "        protected void cancel() {\n                canceled = true;\n                setVisible(false);\n                dispose();\n        }\n",
    "118687": "        protected void finish() {\n                canceled = false;\n                setVisible(false);\n                dispose();\n        }\n",
    "118689": "        protected void configure() {\n                try {\n                        LayoutController controller =\n                                (LayoutController) lstLayoutControllers.getSelectedValue();\n                        if (!controller.isConfigurable()) {\n                                String message = Translator.getString(\"Error.ThisLayoutCannotBeConfigured\"); /*#Finished: \"This Layout cannot be configured.\"*/\n                                JOptionPane.showMessageDialog(\n                                        this,\n                                        message,\n                                        null,\n                                        JOptionPane.INFORMATION_MESSAGE);\n                                return;\n                        }\n                        controller.configure();\n                } catch (Exception e) {\n                        e.printStackTrace();\n                }\n        }\n",
    "118692": "        public LayoutController getSelectedLayoutController() {\n                try {\n                        return (LayoutController) lstLayoutControllers.getSelectedValue();\n                } catch (Exception e) {\n                        return null;\n                }\n        }\n",
    "118703": "        protected void closeDialog(\n                java.awt.event.WindowEvent evt) { //GEN-FIRST:event_closeDialog\n                cancel();\n        } //GEN-LAST:event_closeDialog\n",
    "118722": "\tprotected void displayEdgeCrossesValues(Vector levels) {\n\t\tSystem.out.println(\"----------------Edge Crosses Indicator Values\"\n\t\t/*#Frozen*/\n\t\t);\n\n\t\tfor (int i = 0; i < levels.size() - 1; i++) {\n\t\t\t// Get the current level\n\t\t\tVector currentLevel = (Vector) levels.get(i);\n\t\t\tSystem.out.print(\"Level (\" + i + \"):\" /*#Frozen*/\n\t\t\t);\n\t\t\tfor (int j = 0; j < currentLevel.size(); j++) {\n\t\t\t\tCellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);\n\n\t\t\t\tSystem\n\t\t\t\t\t.out\n\t\t\t\t\t.print(\n\t\t\t\t\t\tNumberFormat.getNumberInstance().format(\n\t\t\t\t\t\t\tsourceWrapper.getEdgeCrossesIndicator())\n\t\t\t\t\t\t+ \" - \" /*#Frozen*/\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n",
    "118724": "\tprotected void displayGridPositions(Vector levels) {\n\n\t\tSystem.out.println(\"----------------GridPositions\" /*#Frozen*/\n\t\t);\n\n\t\tfor (int i = 0; i < levels.size() - 1; i++) {\n\t\t\t// Get the current level\n\t\t\tVector currentLevel = (Vector) levels.get(i);\n\t\t\tSystem.out.print(\"Level (\" + i + \"):\" /*#Frozen*/\n\t\t\t);\n\t\t\tfor (int j = 0; j < currentLevel.size(); j++) {\n\t\t\t\tCellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);\n\t\t\t\tSystem\n\t\t\t\t\t.out\n\t\t\t\t\t.print(\n\t\t\t\t\t\tNumberFormat.getNumberInstance().format(\n\t\t\t\t\t\t\tsourceWrapper.getGridPosition())\n\t\t\t\t\t\t+ \" - \" /*#Frozen*/\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n",
    "118725": "\tprotected void displayPriorities(Vector levels) {\n\n\t\tSystem.out.println(\"----------------down Priorities\" /*#Frozen*/\n\t\t);\n\n\t\tfor (int i = 0; i < levels.size() - 1; i++) {\n\t\t\t// Get the current level\n\t\t\tVector currentLevel = (Vector) levels.get(i);\n\t\t\tSystem.out.print(\"Level (\" + i + \"):\" /*#Frozen*/\n\t\t\t);\n\t\t\tfor (int j = 0; j < currentLevel.size(); j++) {\n\t\t\t\tCellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);\n\t\t\t\tSystem.out.print(sourceWrapper.getPriority() +\n\t\t\t\t/*\" (\" +\n\t\t\t\t                   sourceWrapper.nearestDownNeighborLevel + \") \" +*/\n\t\t\t\t\" - \" /*#Frozen*/\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n",
    "118735": "\tprotected void updateProgress4Movements() {\n\t\t// adds the current loop count\n\t\tmovements.add(new Integer(movementsCurrentLoop));\n\t\titeration++;\n\n\t\t// if the current loop count is higher than the max movements count\n\t\t// memorize the new max\n\t\tif (movementsCurrentLoop > movementsMax) {\n\t\t\tmovementsMax = movementsCurrentLoop;\n\t\t}\n\n\t\t// Calculate the new progress\n\t\tif (movements.size() > 1) {\n\t\t\tdlgProgress.setValue(movements.size() - 1);\n\t\t}\n\t}\n",
    "118773": "\tpublic void setMinimum(int min) {\n\t\tpbProgressSum.setMinimum(min);\n\t}\n",
    "118774": "\tpublic void setMaximum(int max) {\n\t\tpbProgressSum.setMaximum(max);\n\t}\n",
    "118775": "\tpublic void setToMaximum() {\n\t\tsetValue(pbProgressSum.getMaximum());\n\t}\n",
    "118776": "\tpublic boolean isDataFlavorSupported(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = getTransferDataFlavors();\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118777": "\tpublic void setValue(int value) {\n\t\tpbProgressSum.setValue(value);\n\n\t\tlblProgressSumVal.setText(\n\t\t\tjava.text.NumberFormat.getInstance().format(\n\t\t\t\tMath.round(pbProgressSum.getPercentComplete() * 100))\n\t\t\t\t+ \"%\");\n\t}\n",
    "118780": "\tpublic int getValue() {\n\t\treturn pbProgressSum.getValue();\n\t}\n",
    "118782": "\tpublic void setMessage(String message) {\n\t\tlblMessage.setText(message);\n\t}\n",
    "118784": "\tpublic boolean isCanceled() {\n\t\treturn isCanceled;\n\t}\n",
    "118785": "\tprotected boolean isHTMLFlavor(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = htmlFlavors;\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118786": "\tpublic void setCancelVisible(boolean visible) {\n\t\tcmdCancel.setVisible(visible);\n\t}\n",
    "118787": "\tprotected boolean isHTMLSupported() {\n\t\treturn false;\n\t}\n",
    "118788": "\tpublic void setCancelEnabled(boolean enabled) {\n\t\tcmdCancel.setEnabled(enabled);\n\t}\n",
    "118789": "\tpublic JButton getCancelButton() {\n\t\treturn cmdCancel;\n\t}\n",
    "118790": "\tprotected String getHTMLData() {\n\t\treturn null;\n\t}\n",
    "118791": "\tprotected void saveComponentState(JComponent c) {\n\t}\n",
    "118792": "\tprotected boolean isPlainFlavor(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = plainFlavors;\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118794": "\tprotected void restoreComponentState(JComponent c) {\n\t}\n",
    "118795": "\tprotected boolean isPlainSupported() {\n\t\treturn false;\n\t}\n",
    "118796": "\tprotected void restoreComponentStateForDrop(JComponent c) {\n\t}\n",
    "118797": "\tprotected void updateInsertionLocation(JComponent c, Point p) {\n\t}\n",
    "118798": "\tprotected String getPlainData() {\n\t\treturn null;\n\t}\n",
    "118799": "\tprivate void initPropertiesIfNecessary() {\n\t\tif (timer == null) {\n\t\t\tToolkit t = Toolkit.getDefaultToolkit();\n\t\t\tInteger initial = new Integer(100);\n\t\t\tInteger interval = new Integer(100);\n\n\t\t\ttry {\n\t\t\t\tinitial =\n\t\t\t\t\t(Integer) t.getDesktopProperty(\n\t\t\t\t\t\t\"DnD.Autoscroll.initialDelay\");\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinterval =\n\t\t\t\t\t(Integer) t.getDesktopProperty(\"DnD.Autoscroll.interval\");\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\ttimer = new Timer(interval.intValue(), this);\n\n\t\t\ttimer.setCoalesce(true);\n\t\t\ttimer.setInitialDelay(initial.intValue());\n\n\t\t\ttry {\n\t\t\t\thysteresis =\n\t\t\t\t\t((Integer) t\n\t\t\t\t\t\t.getDesktopProperty(\"DnD.Autoscroll.cursorHysteresis\"))\n\t\t\t\t\t\t.intValue();\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}\n",
    "118800": "\tprotected boolean isStringFlavor(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = stringFlavors;\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118806": "\tprivate void cleanup() {\n\t\tif (timer != null) {\n\t\t\ttimer.stop();\n\t\t}\n\t\tcomponent = null;\n\t\tlastPosition = null;\n\t}\n",
    "118807": "\tprotected void setModel(GraphModel model) {\n\t\tcancelEditing(graph);\n\t\tif (graphModel != null && graphModelListener != null)\n\t\t\tgraphModel.removeGraphModelListener(graphModelListener);\n\t\tgraphModel = model;\n\t\tif (graphModel != null && graphModelListener != null)\n\t\t\tgraphModel.addGraphModelListener(graphModelListener);\n\t\tif (graphModel != null) // jmv : to avoid NullPointerException \n\t\t\tupdateSize();\n\t}\n",
    "118808": "\tprotected JFrame createFrame() {\n\t\t/*\n\t\tJFrame frame = new JFrameP() {\n\t\t\tpublic String getInstanceID() {\n\t\t\t\treturn this.getClass().getName();\n\t\t\t}\n\t\t\tpublic String getNameSpace() {\n\t\t\t\treturn \"JGraphPad\";\n\t\t\t}\n\t\t};\n\t\t*/\n\t\tGPFrame gpframe = new GPFrame();\n\t\tgpframe.setName(\"MainGraphpad\");\n\n\t\treturn gpframe;\n\t}\n",
    "118812": "\tprotected void setGraphLayoutCache(GraphLayoutCache view) {\n\t\tcancelEditing(graph);\n\t\tif (graphLayoutCache != null && graphViewObserver != null)\n\t\t\tgraphLayoutCache.deleteObserver(graphViewObserver);\n\t\tgraphLayoutCache = view;\n\t\tif (graphLayoutCache != null && graphViewObserver != null)\n\t\t\tgraphLayoutCache.addObserver(graphViewObserver);\n\t\tupdateSize();\n\t}\n",
    "118816": "\tprotected void setMarquee(BasicMarqueeHandler marqueeHandler) {\n\t\tmarquee = marqueeHandler;\n\t}\n",
    "118817": "\tpublic ActionMap getCurrentActionMap() {\n\t\treturn currentActionMap;\n\t}\n",
    "118820": "\tpublic Frame getFrame() {\n\t\tfor (Container p = getParent(); p != null; p = p.getParent()) {\n\t\t\tif (p instanceof Frame) {\n\t\t\t\treturn (Frame) p;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "118821": "\tprotected void setSelectionModel(GraphSelectionModel newLSM) {\n\t\tcancelEditing(graph);\n\t\tif (graphSelectionListener != null && graphSelectionModel != null)\n\t\t\tgraphSelectionModel.removeGraphSelectionListener(\n\t\t\t\tgraphSelectionListener);\n\t\tgraphSelectionModel = newLSM;\n\t\tif (graphSelectionModel != null && graphSelectionListener != null)\n\t\t\tgraphSelectionModel.addGraphSelectionListener(\n\t\t\t\tgraphSelectionListener);\n\t\tif (graph != null)\n\t\t\tgraph.repaint();\n\t}\n",
    "118825": "\tpublic CellHandle getHandle(JGraph graph) {\n\t\treturn handle;\n\t}\n",
    "118827": "\tpublic void error(String message) {\n\t\tJOptionPane.showMessageDialog(\n\t\t\tthis,\n\t\t\tmessage,\n\t\t\tappTitle,\n\t\t\tJOptionPane.ERROR_MESSAGE);\n\t}\n",
    "118828": "\tpublic GPGraph getCurrentGraph() {\n\t\tGPDocument doc = getCurrentDocument();\n\t\tif (doc == null)\n\t\t\treturn null;\n\t\treturn doc.getGraph();\n\t}\n",
    "118829": "\tprotected Object getFocusedCell() {\n\t\tif (focus != null)\n\t\t\treturn focus.getCell();\n\t\treturn null;\n\t}\n",
    "118833": "\tpublic ModelExportImpl getExportModel() {\n\t\tGPDocument doc = getCurrentDocument();\n\t\tif (doc == null)\n\t\t\treturn null;\n\t\treturn doc.getExportModel();\n\t}\n",
    "118836": "\tpublic JInternalFrame getCurrentInternalFrame() {\n\t\tGPInternalFrame internalFrame =\n\t\t\t(GPInternalFrame) desktop.getSelectedFrame();\n\t\tif (internalFrame == null) {\n\t\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\t\tif (frames.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tframes[0].setSelected(true);\n\t\t\t\t\tinternalFrame = (GPInternalFrame) frames[0];\n\t\t\t\t} catch (PropertyVetoException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internalFrame == null)\n\t\t\treturn null;\n\t\treturn internalFrame;\n\t}\n",
    "118837": "\tpublic Point getInsertionLocation() {\n\t\treturn insertionLocation;\n\t}\n",
    "118839": "\tpublic GPDocument getCurrentDocument() {\n\t\tGPInternalFrame internalFrame =\n\t\t\t(GPInternalFrame) desktop.getSelectedFrame();\n\t\tif (internalFrame == null) {\n\t\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\t\tif (frames.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tframes[0].setSelected(true);\n\t\t\t\t\tinternalFrame = (GPInternalFrame) frames[0];\n\t\t\t\t} catch (PropertyVetoException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internalFrame == null)\n\t\t\treturn null;\n\t\treturn internalFrame.getDocument();\n\t}\n",
    "118841": "\tpublic AbstractActionDefault getEditUndoAction() {\n\t\treturn (AbstractActionDefault) currentActionMap.get(\n\t\t\tUtilities.getClassNameWithoutPackage(EditUndo.class));\n\t}\n",
    "118842": "\tpublic void setInsertionLocation(Point p) {\n\t\tinsertionLocation = p;\n\t}\n",
    "118843": "\tpublic AbstractActionDefault getEditRedoAction() {\n\t\treturn (AbstractActionDefault) currentActionMap.get(\n\t\t\tUtilities.getClassNameWithoutPackage(EditRedo.class));\n\t}\n",
    "118856": "\tpublic void addGPInternalFrame(GPInternalFrame f) {\n\t\tdesktop.add(f);\n\t\ttry {\n\t\t\tf.setSelected(true);\n\t\t} catch (Exception ex) {\n\t\t}\n\t\tdoc2InternalFrame.put(f.getDocument(), f);\n\t}\n",
    "118862": "\tpublic void removeGPInternalFrame(GPInternalFrame f) {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf.setVisible(false);\n\t\tdesktop.remove(f);\n\t\tdoc2InternalFrame.remove(f.getDocument());\n\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\tif (frames.length > 0) {\n\t\t\ttry {\n\t\t\t\tframes[0].setSelected(true);\n\t\t\t} catch (PropertyVetoException e) {\n\t\t\t}\n\t\t}\n\t}\n",
    "118867": "\tpublic void exit() {\n\n\t\tif (!isApplet()) {\n\t\t\tSystem.exit(0);\n\t\t} else {\n\t\t\tgetApplet().exit(this);\n\t\t}\n\t}\n",
    "118868": "\tpublic void selectCellForEvent(Object cell, MouseEvent event) {\n\t\t// Toggle selection\n\t\tif (isToggleSelectionEvent(event))\n\t\t\ttoggleSelectionCellForEvent(cell, event);\n\n\t\t// Select cell\n\t\telse if (isAddToSelectionEvent(event))\n\t\t\tgraph.addSelectionCell(cell);\n\t\telse\n\t\t\tgraph.setSelectionCell(cell);\n\t}\n",
    "118871": "\tpublic void setApplet(JGraphpad applet) {\n\t\tthis.applet = applet;\n\t}\n",
    "118874": "\tpublic JGraphpad getApplet() {\n\t\treturn applet;\n\t}\n",
    "118876": "\tprotected void toggleSelectionCellForEvent(Object cell, MouseEvent event) {\n\t\tif (graph.isCellSelected(cell))\n\t\t\tgraph.removeSelectionCell(cell);\n\t\telse\n\t\t\tgraph.addSelectionCell(cell);\n\t}\n",
    "118878": "\tpublic boolean isApplet() {\n\t\treturn (applet != null);\n\t}\n",
    "118881": "\tpublic void addDocument(GraphModelProvider graphModelProvider) {\n\t\taddDocument(null, graphModelProvider, null, null, null);\n\t}\n",
    "118884": "\tpublic boolean isAddToSelectionEvent(MouseEvent e) {\n\t\treturn e.isShiftDown();\n\t}\n",
    "118891": "\tpublic boolean isToggleSelectionEvent(MouseEvent event) {\n\t\treturn (event.isControlDown());\n\t}\n",
    "118899": "\tpublic Object getCell() {\n\t\treturn cells[0];\n\t}\n",
    "118901": "\tpublic boolean isAddedCell() {\n\t\treturn areNew[0];\n\t}\n",
    "118902": "\tpublic boolean isAddedCell(Object cell) {\n\t\tfor (int counter = cells.length - 1; counter >= 0; counter--)\n\t\t\tif (cells[counter].equals(cell))\n\t\t\t\treturn areNew[counter];\n\t\tthrow new IllegalArgumentException(\"cell is not a cell identified by the GraphSelectionEvent\");\n\t}\n",
    "118903": "\tpublic boolean isAddedCell(int index) {\n\t\tif (cells == null || index < 0 || index >= cells.length) {\n\t\t\tthrow new IllegalArgumentException(\"index is beyond range of added cells identified by GraphSelectionEvent\");\n\t\t}\n\t\treturn areNew[index];\n\t}\n",
    "118904": "\tpublic Object cloneWithSource(Object newSource) {\n\t\t// Fix for IE bug - crashing\n\t\treturn new GraphSelectionEvent(newSource, cells, areNew);\n\t}\n",
    "118905": "\tpublic GraphModelChange getChange() {\n\t\treturn change;\n\t}\n",
    "118907": "\tpublic GPBarFactory getBarFactory() {\n\t\treturn barFactory;\n\t}\n",
    "118909": "\tpublic boolean isForceMarqueeEvent(MouseEvent event) {\n\t\tif (marquee != null)\n\t\t\treturn marquee.isForceMarqueeEvent(event);\n\t\treturn false;\n\t}\n",
    "118910": "\tpublic void setBarFactory(GPBarFactory barFactory) {\n\t\tthis.barFactory = barFactory;\n\t}\n",
    "118912": "\tpublic boolean isConstrainedMoveEvent(MouseEvent event) {\n\t\tif (event != null)\n\t\t\treturn event.isShiftDown();\n\t\treturn false;\n\t}\n",
    "118913": "\tpublic GraphUI getUI() {\n\t\treturn (GraphUI) ui;\n\t}\n",
    "118914": "\tpublic JGpdMarqueeHandler getMarqueeHandler() {\n\t\treturn marqueeHandler;\n\t}\n",
    "118916": "\tpublic void setUI(GraphUI ui) {\n\t\tif ((GraphUI) this.ui != ui) {\n\t\t\tsettingUI = true;\n\t\t\ttry {\n\t\t\t\tsuper.setUI(ui);\n\t\t\t} finally {\n\t\t\t\tsettingUI = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "118917": "\tpublic boolean isEditing(JGraph graph) {\n\t\treturn (editingComponent != null);\n\t}\n",
    "118920": "\tpublic void updateUI() {\n\t\tsetUI(new org.jgraph.plaf.basic.BasicGraphUI());\n\t\tinvalidate();\n\t}\n",
    "118922": "\tpublic boolean stopEditing(JGraph graph) {\n\t\tif (editingComponent != null && cellEditor.stopCellEditing()) {\n\t\t\tcompleteEditing(false, false, true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "118924": "\tpublic boolean intersects(Graphics g, CellView value, Rectangle r) {\n\t\tif (value instanceof EdgeView && g != null && value != null) {\n            setView(value);\n            Graphics2D g2 = (Graphics2D) g;\n            boolean hit = g2.hit(r, view.getShape(), true);\n\t\t\tif (hit)\n\t\t\t\treturn true;\n\t\t\tRectangle rect = view.getLabelBounds();\n\t\t\tif (rect != null)\n\t\t\t\treturn rect.intersects(r);\n\t\t}\n\t\treturn false;\n\t}\n",
    "118925": "\tpublic Rectangle getBounds(CellView value) {\n\t\tif (value instanceof EdgeView && value != null) {\n            setView(value);\n\t\t\tRectangle r = getPaintBounds(view);\n\t\t\tRectangle label = getLabelBounds(view);\n\t\t\tif (label != null)\n\t\t\t\tr = r.union(label);\n\t\t\tint b = (int) Math.ceil(lineWidth);\n\t\t\tr.x = r.x - b;\n\t\t\tr.y = r.y - b;\n\t\t\tr.width = r.width + 2 * b;\n\t\t\tr.height = r.height + 2 * b;\n\t\t\treturn r;\n\t\t}\n\t\treturn null;\n\t}\n",
    "118926": "\tpublic String getUIClassID() {\n\t\treturn uiClassID;\n\t}\n",
    "118927": "\tpublic Rectangle getLabelBounds(EdgeView view) {\n        setView(view);\n\t\tPoint p = getLabelPosition(this.view);\n\t\tDimension d = getLabelSize(this.view);\n\t\tif (p != null && d != null) {\n\t\t\tp.translate(-d.width / 2, -d.height / 2);\n\t\t\treturn new Rectangle(p.x, p.y, d.width + 1, d.height + 1);\n\t\t}\n\t\treturn null;\n\t}\n",
    "118929": "\tpublic void cancelEditing(JGraph graph) {\n\t\tif (editingComponent != null)\n\t\t\tcompleteEditing(false, true, false);\n\t\t// Escape key is handled by the KeyHandler.keyPressed inner class method\n\t}\n",
    "118930": "\tpublic Dimension getLabelSize(EdgeView view) {\n        setView(view);\n\t\tObject label = view.getGraph().convertValueToString(view);\n\t\tif (label != null && label.toString().length() > 0) {\n\t\t\tfontGraphics.setFont(\n\t\t\t\tGraphConstants.getFont(view.getAllAttributes()));\n\t\t\tmetrics = fontGraphics.getFontMetrics();\n\t\t\tint sw = metrics.stringWidth(label.toString());\n\t\t\tint sh = metrics.getHeight();\n\t\t\treturn new Dimension(sw, sh);\n\t\t}\n\t\treturn null;\n\t}\n",
    "118932": "\tpublic Map cloneCells(Object[] cells) {\n\t\treturn graphModel.cloneCells(cells);\n\t}\n",
    "118934": "\tpublic Rectangle getPaintBounds(EdgeView view) {\n        setView(view);\n\t\treturn view.getShape().getBounds();\n\t}\n",
    "118935": "\tpublic void startEditingAtCell(JGraph graph, Object cell) {\n\t\tgraph.scrollCellToVisible(cell);\n\t\tif (cell != null)\n\t\t\tstartEditing(cell, null);\n\t}\n",
    "118938": "\tpublic Object getFirstCellForLocation(int x, int y) {\n\t\treturn getNextCellForLocation(null, x, y);\n\t}\n",
    "118941": "\tpublic Object getEditingCell(JGraph graph) {\n\t\treturn editingCell;\n\t}\n",
    "118943": "\tpublic Object getNextCellForLocation(Object current, int x, int y) {\n\t\tx /= scale;\n\t\ty /= scale; // FIX: Consistency with other methods?\n\t\tCellView cur = graphLayoutCache.getMapping(current, false);\n\t\tCellView cell = getNextViewAt(cur, x, y);\n\t\tif (cell != null)\n\t\t\treturn cell.getCell();\n\t\treturn null;\n\t}\n",
    "118945": "\tpublic void validate() {\n\t}\n",
    "118947": "\tpublic Rectangle getCellBounds(Object cell) {\n\t\tCellView view = graphLayoutCache.getMapping(cell, false);\n\t\tif (view != null)\n\t\t\treturn view.getBounds();\n\t\treturn null;\n\t}\n",
    "118948": "\tpublic void revalidate() {\n\t}\n",
    "118949": "\tpublic void repaint(long tm, int x, int y, int width, int height) {\n\t}\n",
    "118950": "\tpublic void repaint(Rectangle r) {\n\t}\n",
    "118951": "\tpublic Rectangle getCellBounds(Object[] cells) {\n\t\tif (cells != null && cells.length > 0) {\n\t\t\tRectangle ret = getCellBounds(cells[0]);\n\t\t\tif (ret != null) {\n\t\t\t\tret = new Rectangle(ret);\n\t\t\t\tfor (int i = 1; i < cells.length; i++) {\n\t\t\t\t\tRectangle r = getCellBounds(cells[i]);\n\t\t\t\t\tif (r != null)\n\t\t\t\t\t    SwingUtilities.computeUnion(\n\t\t\t\t\t\tr.x,\n\t\t\t\t\t\tr.y,\n\t\t\t\t\t\tr.width,\n\t\t\t\t\t\tr.height,\n\t\t\t\t\t\tret);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "118953": "\tprotected void prepareForUIInstall() {\n\t\t// Data member initializations\n\t\tstopEditingInCompleteEditing = true;\n\t\tpreferredSize = new Dimension();\n\t\tsetGraphLayoutCache(graph.getGraphLayoutCache());\n\t\tsetModel(graph.getModel());\n\t}\n",
    "118957": "\tpublic CellView getNextViewAt(CellView current, int x, int y) {\n\t\tObject[] sel =\n\t\t\tgraphLayoutCache.order(getSelectionModel().getSelectables());\n\t\tCellView[] cells = graphLayoutCache.getMapping(sel);\n\t\tCellView cell = getNextViewAt(cells, current, x, y);\n\t\treturn cell;\n\t}\n",
    "118959": "\tprotected void completeUIInstall() {\n\t\t// Custom install code\n\t\tsetSelectionModel(graph.getSelectionModel());\n\t\tupdateSize();\n\t}\n",
    "118964": "\tprotected void installDefaults() {\n\t\tif (graph.getBackground() == null\n\t\t\t|| graph.getBackground() instanceof UIResource) {\n\t\t\tgraph.setBackground(UIManager.getColor(\"Tree.background\"));\n\t\t}\n\t\tif (graph.getFont() == null || graph.getFont() instanceof UIResource)\n\t\t\tgraph.setFont(UIManager.getFont(\"Tree.font\"));\n\t\t// Set JGraph's laf-specific colors\n\t\tgraph.setMarqueeColor(UIManager.getColor(\"Table.gridColor\"));\n\t\tgraph.setHandleColor(\n\t\t\tUIManager.getColor(\"MenuItem.selectionBackground\"));\n\t\tgraph.setLockedHandleColor(UIManager.getColor(\"MenuItem.background\"));\n\t\tgraph.setGridColor(UIManager.getColor(\"Tree.selectionBackground\"));\n\t\tgraph.setOpaque(true);\n\t}\n",
    "118966": "\tpublic Object getPortForLocation(int x, int y) {\n\t\tPortView view = getPortViewAt(x, y);\n\t\tif (view != null)\n\t\t\treturn view.getCell();\n\t\treturn null;\n\t}\n",
    "118970": "\tpublic void mouseDragged(MouseEvent e) {\n\t\tif (!e.isConsumed() && startPoint != null) {\n\t\t\tif (!(e.getSource() instanceof JGraph))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"MarqueeHandler cannot handle event from unknown source: \"\n\t\t\t\t\t\t+ e);\n\t\t\tJGraph graph = (JGraph) e.getSource();\n\t\t\tGraphics g = graph.getGraphics();\n\t\t\tColor bg = graph.getBackground();\n\t\t\tColor fg = graph.getMarqueeColor();\n\t\t\tg.setColor(fg);\n\t\t\tg.setXORMode(bg);\n\t\t\toverlay(g);\n\t\t\tcurrentPoint = e.getPoint();\n\t\t\tmarqueeBounds = new Rectangle(startPoint);\n\t\t\tmarqueeBounds.add(currentPoint);\n\t\t\tg.setColor(bg);\n\t\t\tg.setXORMode(fg);\n\t\t\toverlay(g);\n\t\t\te.consume();\n\t\t}\n\t}\n",
    "118972": "\tpublic void paint(Graphics g) {\n\t\toverlay(g);\n\t}\n",
    "118974": "\tpublic void mousePressed(MouseEvent e) {\n\t\tif (!e.isConsumed()) {\n\t\t\tif (!(e.getSource() instanceof JGraph))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"MarqueeHandler cannot handle event from unknown source: \"\n\t\t\t\t\t\t+ e);\n\t\t\tJGraph graph = (JGraph) e.getSource();\n\t\t\tstartPoint = e.getPoint();\n\t\t\tmarqueeBounds = new Rectangle(startPoint);\n\t\t\tpreviousCursor = graph.getCursor();\n\t\t\tgraph.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n\t\t\te.consume();\n\t\t}\n\t}\n",
    "118976": "\tpublic Point getCurrentPoint() {\n\t\treturn currentPoint;\n\t}\n",
    "118977": "\tpublic Rectangle getMarqueeBounds() {\n\t\treturn marqueeBounds;\n\t}\n",
    "118978": "\tpublic PortView getPortViewAt(int x, int y) {\n\t\tRectangle r =\n\t\t\tnew Rectangle(\n\t\t\t\tx - tolerance,\n\t\t\t\ty - tolerance,\n\t\t\t\t2 * tolerance,\n\t\t\t\t2 * tolerance);\n\t\tPortView[] ports = graphLayoutCache.getPorts();\n\t\tfor (int i = ports.length - 1; i >= 0; i--)\n\t\t\tif (ports[i] != null && ports[i].intersects(getGraphics(), r))\n\t\t\t\treturn ports[i];\n\t\treturn null;\n\t}\n",
    "118979": "\tpublic Cursor getPreviousCursor() {\n\t\treturn previousCursor;\n\t}\n",
    "118980": "\tpublic Point getStartPoint() {\n\t\treturn startPoint;\n\t}\n",
    "118981": "\tpublic void setCurrentPoint(Point currentPoint) {\n\t\tthis.currentPoint = currentPoint;\n\t}\n",
    "118982": "\tpublic void setMarqueeBounds(Rectangle marqueeBounds) {\n\t\tthis.marqueeBounds = marqueeBounds;\n\t}\n",
    "118983": "\tprotected void installKeyboardActions() {\n\t\tInputMap km =\n\t\t\tgetInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\t\tSwingUtilities.replaceUIInputMap(\n\t\t\tgraph,\n\t\t\tJComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,\n\t\t\tkm);\n\t\tkm = getInputMap(JComponent.WHEN_FOCUSED);\n\t\tSwingUtilities.replaceUIInputMap(graph, JComponent.WHEN_FOCUSED, km);\n\t\tSwingUtilities.replaceUIActionMap(graph, createActionMap());\n\t}\n",
    "118984": "\tpublic void setPreviousCursor(Cursor previousCursor) {\n\t\tthis.previousCursor = previousCursor;\n\t}\n",
    "118985": "\tpublic void setStartPoint(Point startPoint) {\n\t\tthis.startPoint = startPoint;\n\t}\n",
    "118987": "\tpublic void refresh(boolean createDependentViews) {\n\t\tsuper.refresh(createDependentViews);\n\t\t// Sync Source- and Targetport\n\t\tif (points != null) {\n\t\t\tObject modelSource = getModel().getSource(cell);\n\t\t\tObject modelTarget = getModel().getTarget(cell);\n\t\t\tsetSource(mapper.getMapping(modelSource, createDependentViews));\n\t\t\tsetTarget(mapper.getMapping(modelTarget, createDependentViews));\n\t\t\t// Re-Route\n\t\t\tEdge.Routing routing = GraphConstants.getRouting(allAttributes);\n\t\t\tif (routing != null)\n\t\t\t\trouting.route(this, points);\n\t\t}\n\t}\n",
    "118988": "\tpublic String convertValueToString(Object value) {\n\t\tCellView view =\n\t\t\t(value instanceof CellView)\n\t\t\t\t? (CellView) value\n\t\t\t\t: getGraphLayoutCache().getMapping(value, false);\n\t\tif (view != null) {\n\t\t\tObject newValue = GraphConstants.getValue(view.getAllAttributes());\n\t\t\tif (newValue != null)\n\t\t\t\tvalue = newValue;\n\t\t\telse\n\t\t\t\tvalue = view.getCell();\n\t\t}\n\t\tif (value instanceof DefaultMutableTreeNode\n\t\t\t&& ((DefaultMutableTreeNode) value).getUserObject() != null)\n\t\t\treturn ((DefaultMutableTreeNode) value).getUserObject().toString();\n\t\telse if (value != null)\n\t\t\treturn value.toString();\n\t\treturn null;\n\t}\n",
    "118989": "\tpublic void update() {\n\t\tsuper.update();\n\t\tpoints = GraphConstants.getPoints(allAttributes);\n\t\tlabelPosition = GraphConstants.getLabelPosition(allAttributes);\n\t\tEdge.Routing routing = GraphConstants.getRouting(allAttributes);\n\t\tif (routing != null)\n\t\t\trouting.route(this, points);\n\t\t// Synchronize Points and PortViews\n\t\tif (getModel().getSource(cell) != null)\n\t\t\tsetSource(getSource());\n\t\tif (getModel().getTarget(cell) != null)\n\t\t\tsetTarget(getTarget());\n\t\t// Clear cached shapes\n\t\tbeginShape = null;\n\t\tendShape = null;\n\t\tlineShape = null;\n\t\tsharedPath = null;\n\t\tcachedBounds = null;\n\t\tcachedLabelBounds = null;\n\t}\n",
    "118990": "\tpublic boolean intersects(Graphics g, Rectangle rect) {\n\t\treturn getEdgeRenderer().intersects(g, this, rect);\n\t}\n",
    "118991": "\tprotected void installComponents() {\n\t\tif ((rendererPane = createCellRendererPane()) != null)\n\t\t\tgraph.add(rendererPane);\n\t}\n",
    "118992": "\tpublic Rectangle getBounds() {\n\t\tif (cachedBounds != null) {\n\t\t\treturn cachedBounds;\n\t\t} else {\n\t\t\treturn cachedBounds = getEdgeRenderer().getBounds(this);\n\t\t}\n\t}\n",
    "118994": "\tpublic EdgeRenderer getEdgeRenderer() {\n\t\treturn (EdgeRenderer) getRenderer();\n\t}\n",
    "118995": "\tpublic Point snap(Point p) {\n\n\t\tif (gridEnabled && p != null) {\n\n\t\t\tdouble sgs = (double) gridSize * getScale();\n\n\t\t\tp.x = (int) Math.round(Math.round(p.x / sgs) * sgs);\n\t\t\tp.y = (int) Math.round(Math.round(p.y / sgs) * sgs);\n\n\t\t}\n\n\t\treturn p;\n\n\t}\n",
    "118996": "\tpublic CellViewRenderer getRenderer() {\n\t\treturn renderer;\n\t}\n",
    "118997": "\tpublic CellHandle getHandle(GraphContext context) {\n\t\treturn new EdgeHandle(this, context);\n\t}\n",
    "118998": "\tprotected TransferHandler createTransferHandler() {\n\t\treturn new GraphTransferHandler();\n\t}\n",
    "118999": "\tpublic CellView getSource() {\n\t\treturn source;\n\t}\n",
    "119000": "\tpublic Dimension snap(Dimension d) {\n\n\t\tif (gridEnabled && d != null) {\n\n\t\t\tdouble sgs = (double) gridSize * getScale();\n\n\t\t\td.width = 1 + (int) Math.round(Math.round(d.width / sgs) * sgs);\n\t\t\td.height = 1 + (int) Math.round(Math.round(d.height / sgs) * sgs);\n\n\t\t}\n\n\t\treturn d;\n\n\t}\n",
    "119001": "\tpublic void setSource(CellView sourceView) {\n\t\tsource = sourceView;\n\t\tif (source != null)\n\t\t\tpoints.set(0, source);\n\t\telse\n\t\t\tpoints.set(0, getPoint(0));\n\t\tinvalidate();\n\t}\n",
    "119002": "\tpublic CellView getTarget() {\n\t\treturn target;\n\t}\n",
    "119003": "\tpublic void setTarget(CellView targetView) {\n\t\ttarget = targetView;\n\t\tint n = points.size() - 1;\n\t\tif (target != null)\n\t\t\tpoints.set(n, target);\n\t\telse\n\t\t\tpoints.set(n, getPoint(n));\n\t\tinvalidate();\n\t}\n",
    "119004": "\tprotected PropertyChangeListener createPropertyChangeListener() {\n\t\treturn new PropertyChangeHandler();\n\t}\n",
    "119005": "\tpublic Point getLabelPosition() {\n\t\treturn labelPosition;\n\t}\n",
    "119006": "\tpublic Point toScreen(Point p) {\n\t\tif (p == null)\n\t\t\treturn null;\n\n\t\tp.x = (int) Math.round(p.x * scale);\n\t\tp.y = (int) Math.round(p.y * scale);\n\t\treturn p;\n\t}\n",
    "119007": "\tpublic void setLabelPosition(Point pos) {\n\t\tlabelPosition.setLocation(pos);\n\t\tinvalidate();\n\t}\n",
    "119008": "\tpublic int getPointCount() {\n\t\treturn points.size();\n\t}\n",
    "119010": "\tpublic Point getPoint(int index) {\n\t\tObject obj = points.get(index);\n\t\tif (obj instanceof PortView)\n\t\t\t// Port Location Seen From This Edge\n\t\t\treturn ((PortView) obj).getLocation(this);\n\t\telse if (obj instanceof CellView)\n\t\t\treturn ((CellView) obj).getBounds().getLocation();\n\t\telse if (obj instanceof Point)\n\t\t\t// Regular Point\n\t\t\treturn (Point) obj;\n\t\treturn null;\n\t}\n",
    "119011": "\tprotected MouseListener createMouseListener() {\n\t\treturn new MouseHandler();\n\t}\n",
    "119012": "\tpublic void setPoint(int index, Point p) {\n\t\tpoints.set(index, p);\n\t\tinvalidate();\n\t}\n",
    "119013": "\tpublic Point fromScreen(Point p) {\n\t\tif (p == null)\n\t\t\treturn null;\n\n\t\tp.x = (int) Math.round(p.x / scale);\n\t\tp.y = (int) Math.round(p.y / scale);\n\t\treturn p;\n\t}\n",
    "119015": "\tpublic void removePoint(int index) {\n\t\tpoints.remove(index);\n\t\tinvalidate();\n\t}\n",
    "119016": "\tpublic boolean isAddPointEvent(MouseEvent event) {\n\t\treturn SwingUtilities.isRightMouseButton(event);\n\t}\n",
    "119017": "\tpublic Rectangle toScreen(Rectangle rect) {\n\t\tif (rect == null)\n\t\t\treturn null;\n\n\t\trect.x *= scale;\n\t\trect.y *= scale;\n\t\trect.width *= scale;\n\t\trect.height *= scale;\n\t\treturn rect;\n\t}\n",
    "119018": "\tprotected KeyListener createKeyListener() {\n\t\treturn new KeyHandler();\n\t}\n",
    "119023": "\tpublic Rectangle fromScreen(Rectangle rect) {\n\t\tif (rect == null)\n\t\t\treturn null;\n\n\t\trect.x /= scale;\n\t\trect.y /= scale;\n\t\trect.width /= scale;\n\t\trect.height /= scale;\n\t\treturn rect;\n\t}\n",
    "119024": "\tprotected GraphSelectionListener createGraphSelectionListener() {\n\t\treturn new GraphSelectionHandler();\n\t}\n",
    "119028": "\tpublic CellView createView(Object cell, CellMapper map) {\n\t\tCellView view = null;\n\t\tif (graphModel.isPort(cell))\n\t\t\tview = createPortView(cell, map);\n\t\telse if (graphModel.isEdge(cell))\n\t\t\tview = createEdgeView(cell, map);\n\t\telse\n\t\t\tview = createVertexView(cell, map);\n\t\tmap.putMapping(cell, view);\n\t\tview.refresh(true); // Create Dependent Views\n\t\tview.update();\n\t\treturn view;\n\t}\n",
    "119030": "\tprotected CellEditorListener createCellEditorListener() {\n\t\treturn new CellEditorHandler();\n\t}\n",
    "119034": "\tpublic void updateAutoSize(CellView view) {\n\t\tif (view != null && !isEditing()\n\t\t\t&& GraphConstants.isAutoSize(view.getAllAttributes())) {\n\t\t\tRectangle bounds = view.getBounds();\n\t\t\tif (bounds != null) {\n\t\t\t\tDimension d = getUI().getPreferredSize(this, view);\n\t\t\t\tbounds.setSize(d);\n\t\t\t}\n\t\t}\n\t}\n",
    "119035": "\t\tpublic void mouseMoved(MouseEvent event) {\n\t\t\tfor (int i = 0; i < r.length; i++)\n\t\t\t\tif (r[i].contains(event.getPoint())) {\n\t\t\t\t\tgraph.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n\t\t\t\t\tevent.consume();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif (loc.contains(event.getPoint())\n\t\t\t\t&& graph.isMoveable()\n\t\t\t\t&& GraphConstants.isMoveable(edge.getAllAttributes())) {\n\t\t\t\tgraph.setCursor(new Cursor(Cursor.HAND_CURSOR));\n\t\t\t\tevent.consume();\n\t\t\t}\n\t\t}\n",
    "119036": "\tprotected ComponentListener createComponentListener() {\n\t\treturn new ComponentHandler();\n\t}\n",
    "119039": "\tprotected EdgeView createEdgeView(Object e, CellMapper cm) {\n\t\tif (e instanceof Edge)\n\t\t\treturn createEdgeView((Edge) e, cm);\n\t\telse\n\t\t\treturn new EdgeView(e, this, cm);\n\t}\n",
    "119041": "\tprotected CellRendererPane createCellRendererPane() {\n\t\treturn new CellRendererPane();\n\t}\n",
    "119043": "\tprotected PortView createPortView(Object p, CellMapper cm) {\n\t\tif (p instanceof Port)\n\t\t\treturn createPortView((Port) p, cm);\n\t\telse\n\t\t\treturn new PortView(p, this, cm);\n\t}\n",
    "119045": "\tpublic JGraph getGraph() {\n\t\treturn graph;\n\t}\n",
    "119046": "\tpublic GraphModel getModel() {\n\t\treturn graph.getModel();\n\t}\n",
    "119047": "\tprotected Observer createGraphViewObserver() {\n\t\treturn new GraphViewObserver();\n\t}\n",
    "119048": "\tpublic CellMapper getMapper() {\n\t\treturn mapper;\n\t}\n",
    "119049": "\tpublic Object getCell() {\n\t\treturn cell;\n\t}\n",
    "119051": "\tprotected EdgeView createEdgeView(Edge e, CellMapper cm) {\n\t\treturn new EdgeView(e, this, cm);\n\t}\n",
    "119053": "\tpublic void update() {\n\t\tupdateAllAttributes();\n\t\t// Notify Parent\n\t\tchildUpdated();\n\t}\n",
    "119054": "\tprotected void updateAllAttributes() {\n\t\tallAttributes = getModel().getAttributes(cell);\n\t\tif (allAttributes != null) {\n\t\t\tallAttributes = GraphConstants.cloneMap(allAttributes);\n\t\t} else\n\t\t\tallAttributes = GraphConstants.createMap();\n\t\tallAttributes.putAll(attributes);\n\t}\n",
    "119056": "\tpublic CellView getParentView() {\n\t\treturn parent;\n\t}\n",
    "119057": "\tprotected GraphModelListener createGraphModelListener() {\n\t\treturn new GraphModelHandler();\n\t}\n",
    "119058": "\tpublic void removeFromParent() {\n\t\tif (parent instanceof AbstractCellView) {\n\t\t\tjava.util.List list = ((AbstractCellView) parent).childViews;\n\t\t\tlist.remove(this);\n\t\t}\n\t}\n",
    "119060": "\tpublic boolean isLeaf() {\n\t\treturn childViews.isEmpty();\n\t}\n",
    "119061": "\tprotected PortView createPortView(Port p, CellMapper cm) {\n\t\treturn new PortView(p, this, cm);\n\t}\n",
    "119062": "\tpublic Map getAttributes() {\n\t\treturn attributes;\n\t}\n",
    "119063": "\tpublic Map getAllAttributes() {\n\t\treturn allAttributes;\n\t}\n",
    "119064": "\tpublic Map setAttributes(Map change) {\n\t\tMap undo = GraphConstants.applyMap(change, attributes);\n\t\tupdate();\n\t\treturn undo;\n\t}\n",
    "119069": "\tprotected VertexView createVertexView(Object v, CellMapper cm) {\n\t\treturn new VertexView(v, this, cm);\n\t}\n",
    "119070": "\tpublic boolean intersects(Graphics g, Rectangle rect) {\n\t\tif (isLeaf()) {\n\t\t\tRectangle bounds = getBounds();\n\t\t\tif (bounds != null)\n\t\t\t\treturn bounds.intersects(rect);\n\t\t} else { // Check If Children Intersect\n\t\t\tIterator it = childViews.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t\tif (((CellView) it.next()).intersects(g, rect))\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "119072": "\tpublic GraphCellEditor getEditor() {\n\t\treturn cellEditor;\n\t}\n",
    "119073": "\tpublic Iterator edges() {\n\t\treturn edges.iterator();\n\t}\n",
    "119074": "\tpublic boolean addEdge(Object edge) {\n\t\treturn edges.add(edge);\n\t}\n",
    "119075": "\tpublic boolean removeEdge(Object edge) {\n\t\treturn edges.remove(edge);\n\t}\n",
    "119076": "\tpublic Set getEdges() {\n\t\treturn new HashSet(edges);\n\t}\n",
    "119077": "\tpublic void setEdges(Set edges) {\n\t\tthis.edges = new HashSet(edges);\n\t}\n",
    "119078": "\tpublic Port getAnchor() {\n\t\treturn anchor;\n\t}\n",
    "119079": "\tpublic void setAnchor(Port port) {\n\t\tanchor = port;\n\t}\n",
    "119080": "\tpublic int getEditClickCount() {\n\t\treturn editClickCount;\n\t}\n",
    "119081": "\tpublic Object clone() {\n\t\tDefaultPort c = (DefaultPort) super.clone();\n\t\tc.edges = new HashSet();\n\t\treturn c;\n\t}\n",
    "119092": "\tpublic void setEditClickCount(int count) {\n\t\teditClickCount = count;\n\t}\n",
    "119101": "\tpublic boolean isDropEnabled() {\n\t\treturn dropEnabled;\n\t}\n",
    "119102": "\tpublic int getRootCount() {\n\t\treturn roots.size();\n\t}\n",
    "119104": "\tpublic Object getRootAt(int index) {\n\t\treturn roots.get(index);\n\t}\n",
    "119105": "\tpublic int getIndexOfRoot(Object root) {\n\t\treturn roots.indexOf(root);\n\t}\n",
    "119106": "\tpublic void setDropEnabled(boolean flag) {\n\t\tdropEnabled = flag;\n\t}\n",
    "119107": "\tpublic boolean contains(Object node) {\n\t\tObject parentNode = null;\n\t\twhile ((parentNode = getParent(node))\n\t\t\t!= null)\n\t\t\tnode = parentNode;\n\t\treturn roots.contains(node);\n\t}\n",
    "119108": "\tprotected void uninstallComponents() {\n\t\tif (rendererPane != null)\n\t\t\tgraph.remove(rendererPane);\n\t}\n",
    "119109": "\tpublic Map getAttributes(Object node) {\n\t\tif (node instanceof GraphCell)\n\t\t\treturn ((GraphCell) node).getAttributes();\n\t\treturn null;\n\t}\n",
    "119110": "\tpublic boolean isDragEnabled() {\n\t\treturn dragEnabled;\n\t}\n",
    "119111": "\tpublic Object getSource(Object edge) {\n\t\tif (edge instanceof Edge)\n\t\t\treturn ((Edge) edge).getSource();\n\t\treturn null;\n\t}\n",
    "119113": "\tpublic Object getTarget(Object edge) {\n\t\tif (edge instanceof Edge)\n\t\t\treturn ((Edge) edge).getTarget();\n\t\treturn null;\n\t}\n",
    "119115": "\tpublic void setDragEnabled(boolean flag) {\n\t\tdragEnabled = flag;\n\t}\n",
    "119116": "\tpublic boolean acceptsSource(Object edge, Object port) {\n\t\treturn true;\n\t}\n",
    "119117": "\tpublic boolean acceptsTarget(Object edge, Object port) {\n\t\treturn true;\n\t}\n",
    "119120": "\tpublic Iterator edges(Object port) {\n\t\tif (port instanceof Port)\n\t\t\treturn ((Port) port).edges();\n\t\treturn emptyIterator;\n\t}\n",
    "119123": "\tpublic void setMoveable(boolean flag) {\n\t\tmoveable = flag;\n\t}\n",
    "119124": "\tprotected void paintBackground(Graphics g) {\n\t\tif (graph.isGridVisible())\n\t\t\tpaintGrid(graph.getGridSize(), g, g.getClipBounds());\n\t}\n",
    "119126": "\tpublic boolean isBendable() {\n\t\treturn bendable;\n\t}\n",
    "119127": "\tpublic Object getParent(Object child) {\n\t\tif (child != null && child instanceof TreeNode)\n\t\t\treturn ((TreeNode) child).getParent();\n\t\treturn null;\n\t}\n",
    "119130": "\tpublic int getIndexOfChild(Object parent, Object child) {\n\t\tif (parent == null || child == null)\n\t\t\treturn -1;\n\t\treturn ((TreeNode) parent).getIndex((TreeNode) child);\n\t}\n",
    "119133": "\tpublic void setBendable(boolean flag) {\n\t\tbendable = flag;\n\t}\n",
    "119134": "\tprotected void paintForeground(Graphics g) {\n\t\tif (graph.isPortsVisible())\n\t\t\tpaintPorts(g, graphLayoutCache.getPorts());\n\t}\n",
    "119135": "\tpublic int getChildCount(Object parent) {\n\t\tif (parent instanceof TreeNode)\n\t\t\treturn ((TreeNode) parent).getChildCount();\n\t\treturn 0;\n\t}\n",
    "119136": "\tpublic boolean isLeaf(Object node) {\n\t\tif (asksAllowsChildren && node instanceof TreeNode)\n\t\t\treturn !((TreeNode) node).getAllowsChildren();\n\t\treturn ((TreeNode) node).isLeaf();\n\t}\n",
    "119137": "\tpublic boolean isConnectable() {\n\t\treturn connectable;\n\t}\n",
    "119140": "\tpublic void setConnectable(boolean flag) {\n\t\tconnectable = flag;\n\t}\n",
    "119141": "\tpublic void remove(Object[] roots) {\n\t\tGraphModelEdit edit = createRemoveEdit(roots);\n\t\tif (edit != null) {\n\t\t\tedit.execute();\n\t\t\tpostEdit(edit);\n\t\t}\n\t}\n",
    "119144": "\tprotected void updateHandle() {\n\t\tif (graphLayoutCache != null) {\n\t\t\tObject[] cells = graphLayoutCache.order(graph.getSelectionCells());\n\t\t\tif (cells != null && cells.length > 0)\n\t\t\t\thandle = createHandle(createContext(graph, cells));\n\t\t\telse\n\t\t\t\thandle = null;\n\t\t}\n\t}\n",
    "119145": "\tpublic boolean isDisconnectable() {\n\t\treturn disconnectable;\n\t}\n",
    "119146": "\tpublic void toBack(Object[] cells) {\n\t\tGraphModelLayerEdit edit =\n\t\t\tcreateLayerEdit(cells, GraphModelLayerEdit.BACK);\n\t\tif (edit != null) {\n\t\t\tedit.execute();\n\t\t\tpostEdit(edit);\n\t\t}\n\t}\n",
    "119147": "\tpublic void toFront(Object[] cells) {\n\t\tGraphModelLayerEdit edit =\n\t\t\tcreateLayerEdit(cells, GraphModelLayerEdit.FRONT);\n\t\tif (edit != null) {\n\t\t\tedit.execute();\n\t\t\tpostEdit(edit);\n\t\t}\n\t}\n",
    "119149": "\tpublic void setDisconnectable(boolean flag) {\n\t\tdisconnectable = flag;\n\t}\n",
    "119152": "\tpublic boolean isCloneable() {\n\t\treturn cloneable;\n\t}\n",
    "119153": "\tpublic CellHandle createHandle(GraphContext context) {\n\t\tif (context != null && !context.isEmpty() && graph.isEnabled())\n\t\t\treturn new RootHandle(context);\n\t\treturn null;\n\t}\n",
    "119154": "\tprotected GraphModelEdit createRemoveEdit(Object[] cells) {\n\t\t// Remove from GraphStructure\n\t\tConnectionSet cs = ConnectionSet.create(this, cells, true);\n\t\t// Remove from Group Structure\n\t\tParentMap pm = ParentMap.create(this, cells, true, false);\n\t\t// Construct Edit\n\t\t//GraphModelEdit edit = new GraphModelEdit(cells, cs, pm);\n\t\tGraphModelEdit edit = createEdit(null, cells, null, cs, pm);\n\t\tif (edit != null)\n\t\t\tedit.end();\n\t\treturn edit;\n\t}\n",
    "119156": "\tpublic void setCloneable(boolean flag) {\n\t\tcloneable = flag;\n\t}\n",
    "119157": "\tpublic void updateSize() {\n\t\tvalidCachedPreferredSize = false;\n\t\tgraph.graphDidChange();\n\t\tupdateHandle();\n\t}\n",
    "119161": "\tpublic boolean isSizeable() {\n\t\treturn sizeable;\n\t}\n",
    "119164": "\tpublic void setSizeable(boolean flag) {\n\t\tsizeable = flag;\n\t}\n",
    "119165": "\tprotected ConnectionSet handleConnectionSet(ConnectionSet cs) {\n\t\tif (cs != null) {\n\t\t\tConnectionSet csundo = new ConnectionSet();\n\t\t\tIterator it = cs.connections();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tConnectionSet.Connection c =\n\t\t\t\t\t(ConnectionSet.Connection) it.next();\n\t\t\t\tObject edge = c.getEdge();\n\t\t\t\tif (c.isSource())\n\t\t\t\t\tcsundo.connect(edge, getSource(edge), true);\n\t\t\t\telse\n\t\t\t\t\tcsundo.connect(edge, getTarget(edge), false);\n\t\t\t\thandleConnection(c);\n\t\t\t}\n\t\t\treturn csundo;\n\t\t}\n\t\treturn null;\n\t}\n",
    "119166": "\tpublic void setPreferredMinSize(Dimension newSize) {\n\t\tpreferredMinSize = newSize;\n\t}\n",
    "119167": "\tprotected void handleConnection(ConnectionSet.Connection c) {\n\t\tObject edge = c.getEdge();\n\t\tObject old = (c.isSource()) ? getSource(edge) : getTarget(edge);\n\t\tObject port = c.getPort();\n\t\tif (port != old) {\n\t\t\tconnect(edge, old, c.isSource(), true);\n\t\t\tif (contains(port) && contains(edge))\n\t\t\t\tconnect(edge, port, c.isSource(), false);\n\t\t}\n\t}\n",
    "119168": "\tpublic boolean isDisconnectOnMove() {\n\t\treturn disconnectOnMove && disconnectable;\n\t}\n",
    "119170": "\tpublic Dimension getPreferredMinSize() {\n\t\tif (preferredMinSize == null)\n\t\t\treturn null;\n\t\treturn new Dimension(preferredMinSize);\n\t}\n",
    "119172": "\tpublic void addGraphModelListener(GraphModelListener l) {\n\t\tlistenerList.add(GraphModelListener.class, l);\n\t}\n",
    "119173": "\tpublic void setSelectNewCells(boolean flag) {\n\t\tselectNewCells = flag;\n\t}\n",
    "119175": "\tpublic void removeGraphModelListener(GraphModelListener l) {\n\t\tlistenerList.remove(GraphModelListener.class, l);\n\t}\n",
    "119176": "\tpublic boolean isSelectNewCells() {\n\t\treturn selectNewCells;\n\t}\n",
    "119177": "\tpublic Dimension getPreferredSize(JComponent c) {\n\t\tDimension pSize = this.getPreferredMinSize();\n\n\t\tif (!validCachedPreferredSize)\n\t\t\tupdateCachedPreferredSize();\n\t\tif (graph != null) {\n\t\t\tif (pSize != null)\n\t\t\t\treturn new Dimension(\n\t\t\t\t\tMath.max(pSize.width, preferredSize.width),\n\t\t\t\t\tMath.max(pSize.height, preferredSize.height));\n\t\t\treturn new Dimension(preferredSize.width, preferredSize.height);\n\t\t} else if (pSize != null)\n\t\t\treturn pSize;\n\t\telse\n\t\t\treturn new Dimension(0, 0);\n\t}\n",
    "119180": "\tpublic void setDisconnectOnMove(boolean flag) {\n\t\tdisconnectOnMove = flag;\n\t}\n",
    "119181": "\tpublic Dimension getMinimumSize(JComponent c) {\n\t\tif (this.getPreferredMinSize() != null)\n\t\t\treturn this.getPreferredMinSize();\n\t\treturn new Dimension(0, 0);\n\t}\n",
    "119182": "\t\tprotected void handleEmptyGroups(Object[] groups) {\n\t\t\tif (groups != null && groups.length > 0) {\n\t\t\t\tif (remove == null)\n\t\t\t\t\tremove = new Object[] {\n\t\t\t\t};\n\t\t\t\tObject[] tmp = new Object[remove.length + groups.length];\n\t\t\t\tSystem.arraycopy(remove, 0, tmp, 0, remove.length);\n\t\t\t\tSystem.arraycopy(groups, 0, tmp, remove.length, groups.length);\n\t\t\t\tremove = tmp;\n\t\t\t}\n\t\t}\n",
    "119184": "\tpublic boolean isGridEnabled() {\n\t\treturn gridEnabled;\n\t}\n",
    "119185": "\tpublic Dimension getMaximumSize(JComponent c) {\n\t\tif (graph != null)\n\t\t\treturn getPreferredSize(graph);\n\t\tif (this.getPreferredMinSize() != null)\n\t\t\treturn this.getPreferredMinSize();\n\t\treturn new Dimension(0, 0);\n\t}\n",
    "119187": "\t\tpublic Object getSource() {\n\t\t\treturn DefaultGraphModel.this;\n\t\t}\n",
    "119188": "\tpublic void setGridEnabled(boolean flag) {\n\t\tgridEnabled = flag;\n\t}\n",
    "119189": "\t\tpublic Map getPreviousAttributes() {\n\t\t\treturn previousAttributes;\n\t\t}\n",
    "119190": "\tprotected void completeEditing() {\n\t\t/* If should invoke stopCellEditing, try that */\n\t\tif (graph.getInvokesStopCellEditing()\n\t\t\t&& stopEditingInCompleteEditing\n\t\t\t&& editingComponent != null) {\n\t\t\tcellEditor.stopCellEditing();\n\t\t}\n\t\t/* Invoke cancelCellEditing, this will do nothing if stopCellEditing\n\t\t   was succesful. */\n\t\tcompleteEditing(false, true, false);\n\t}\n",
    "119192": "\tpublic int getTolerance() {\n\t\treturn tolerance;\n\t}\n",
    "119193": "\t\tpublic ConnectionSet getConnectionSet() {\n\t\t\treturn connectionSet;\n\t\t}\n",
    "119195": "\tpublic void setTolerance(int size) {\n\t\ttolerance = size;\n\t}\n",
    "119197": "\t\tpublic ParentMap getParentMap() {\n\t\t\treturn parentMap;\n\t\t}\n",
    "119199": "\tpublic int getHandleSize() {\n\t\treturn handleSize;\n\t}\n",
    "119202": "\tpublic void setHandleSize(int size) {\n\t\thandleSize = size;\n\t}\n",
    "119203": "\t\tpublic void redo() throws CannotRedoException {\n\t\t\tsuper.redo();\n\t\t\texecute();\n\t\t}\n",
    "119205": "\t\tpublic void undo() throws CannotUndoException {\n\t\t\tsuper.undo();\n\t\t\texecute();\n\t\t}\n",
    "119206": "\tpublic int getMinimumMove() {\n\t\treturn minimumMove;\n\t}\n",
    "119208": "\t\tprotected void startTimer() {\n\t\t\tif (timer == null) {\n\t\t\t\ttimer = new Timer(200, this);\n\t\t\t\ttimer.setRepeats(true);\n\t\t\t}\n\t\t\ttimer.start();\n\t\t}\n",
    "119210": "\tpublic void setMinimumMove(int pixels) {\n\t\tminimumMove = pixels;\n\t}\n",
    "119212": "\t\tprotected JScrollPane getScrollPane() {\n\t\t\tComponent c = graph.getParent();\n\n\t\t\twhile (c != null && !(c instanceof JScrollPane))\n\t\t\t\tc = c.getParent();\n\t\t\tif (c instanceof JScrollPane)\n\t\t\t\treturn (JScrollPane) c;\n\t\t\treturn null;\n\t\t}\n",
    "119215": "\tpublic Color getGridColor() {\n\t\treturn gridColor;\n\t}\n",
    "119217": "\t\tpublic void actionPerformed(ActionEvent ae) {\n\t\t\tif (scrollBar == null || !scrollBar.getValueIsAdjusting()) {\n\t\t\t\tif (timer != null)\n\t\t\t\t\ttimer.stop();\n\t\t\t\tupdateSize();\n\t\t\t\ttimer = null;\n\t\t\t\tscrollBar = null;\n\t\t\t}\n\t\t}\n",
    "119219": "\tpublic void setGridColor(Color newColor) {\n\t\tgridColor = newColor;\n\t}\n",
    "119222": "\tpublic Color getHandleColor() {\n\t\treturn handleColor;\n\t}\n",
    "119224": "\t\tpublic void addImplicitEdit(UndoableEdit edit) {\n\t\t\t// ignore\t\n\t\t}\n",
    "119225": "\tpublic void setHandleColor(Color newColor) {\n\t\thandleColor = newColor;\n\t}\n",
    "119228": "\t\tpublic void putViews(GraphLayoutCache view, CellView[] cellViews) {\n\t\t\t// ignore\n\t\t}\n",
    "119229": "\tpublic Color getLockedHandleColor() {\n\t\treturn lockedHandleColor;\n\t}\n",
    "119231": "\t\tpublic void valueChanged(GraphSelectionEvent event) {\n\t\t\t//cancelEditing(graph);\n\t\t\tupdateHandle();\n\t\t\tObject[] cells = event.getCells();\n\t\t\tif (cells != null && cells.length <= MAXCLIPCELLS) {\n\t\t\t\tRectangle r = graph.toScreen(graph.getCellBounds(cells));\n\t\t\t\tif (r != null) {\n\t\t\t\t\tint hsize = graph.getHandleSize();\n\t\t\t\t\tr.grow(hsize, hsize); //padding to paint handles\n\t\t\t\t\tupdateHandle();\n\t\t\t\t\tgraph.repaint(r);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgraph.repaint();\n\t\t}\n",
    "119232": "\t\tprotected List getParentList(Object cell) {\n\t\t\tList list = null;\n\t\t\tif (cell instanceof DefaultMutableTreeNode) {\n\t\t\t\tObject parent = ((DefaultMutableTreeNode) cell).getParent();\n\t\t\t\tif (parent instanceof DefaultGraphCell)\n\t\t\t\t\tlist = ((DefaultGraphCell) parent).getChildren();\n\t\t\t\telse\n\t\t\t\t\tlist = roots;\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n",
    "119233": "\tpublic void setLockedHandleColor(Color newColor) {\n\t\tlockedHandleColor = newColor;\n\t}\n",
    "119235": "\t\tpublic void editingStopped(ChangeEvent e) {\n\t\t\tcompleteEditing(false, false, true);\n\t\t}\n",
    "119237": "\tpublic Color getMarqueeColor() {\n\t\treturn marqueeColor;\n\t}\n",
    "119240": "\t\tpublic void editingCanceled(ChangeEvent e) {\n\t\t\tcompleteEditing(false, false, false);\n\t\t}\n",
    "119241": "\tpublic void setMarqueeColor(Color newColor) {\n\t\tmarqueeColor = newColor;\n\t}\n",
    "119243": "\tpublic void setBorderSelectionColor(Color newColor) {\n\t\tborderSelectionColor = newColor;\n\t}\n",
    "119244": "\tpublic Color getBorderSelectionColor() {\n\t\treturn borderSelectionColor;\n\t}\n",
    "119246": "\tpublic void setFont(Font font) {\n\t\tthis.font = font;\n\t}\n",
    "119247": "\tpublic Color getHighlightColor() {\n\t\treturn highlightColor;\n\t}\n",
    "119248": "\tpublic Font getFont() {\n\t\treturn font;\n\t}\n",
    "119250": "\tpublic Object getCellEditorValue() {\n\t\treturn realEditor.getCellEditorValue();\n\t}\n",
    "119251": "\tpublic boolean isCellEditable(EventObject event) {\n\t\tboolean retValue = false;\n\n\t\tif (!realEditor.isCellEditable(event))\n\t\t\treturn false;\n\t\tif (canEditImmediately(event))\n\t\t\tretValue = true;\n\t\tif (retValue)\n\t\t\tprepareForEditing();\n\t\treturn retValue;\n\t}\n",
    "119252": "\tpublic boolean shouldSelectCell(EventObject event) {\n\t\treturn realEditor.shouldSelectCell(event);\n\t}\n",
    "119253": "\tpublic void setHighlightColor(Color newColor) {\n\t\thighlightColor = newColor;\n\t}\n",
    "119254": "\tpublic boolean stopCellEditing() {\n\t\tif (realEditor.stopCellEditing()) {\n\t\t\tif (editingComponent != null)\n\t\t\t\teditingContainer.remove(editingComponent);\n\t\t\teditingComponent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "119256": "\tpublic void cancelCellEditing() {\n\t\trealEditor.cancelCellEditing();\n\t\tif (editingComponent != null)\n\t\t\teditingContainer.remove(editingComponent);\n\t\teditingComponent = null;\n\t}\n",
    "119257": "\tpublic void addCellEditorListener(CellEditorListener l) {\n\t\trealEditor.addCellEditorListener(l);\n\t}\n",
    "119259": "\tpublic void removeCellEditorListener(CellEditorListener l) {\n\t\trealEditor.removeCellEditorListener(l);\n\t}\n",
    "119260": "\tpublic void valueChanged(GraphSelectionEvent e) {\n\t\tif (graph != null) {\n\t\t\tif (graph.getSelectionCount() == 1)\n\t\t\t\tlastCell = graph.getSelectionCell();\n\t\t\telse\n\t\t\t\tlastCell = null;\n\t\t}\n\t}\n",
    "119261": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tif (graph != null)\n\t\t\tgraph.startEditingAtCell(lastCell);\n\t}\n",
    "119263": "\tpublic double getScale() {\n\t\treturn scale;\n\t}\n",
    "119264": "\tprotected void setGraph(JGraph newGraph) {\n\t\tif (graph != newGraph) {\n\t\t\tif (graph != null)\n\t\t\t\tgraph.removeGraphSelectionListener(this);\n\t\t\tgraph = newGraph;\n\t\t\tif (graph != null)\n\t\t\t\tgraph.addGraphSelectionListener(this);\n\t\t}\n\t}\n",
    "119266": "\tprotected boolean shouldStartEditingTimer(EventObject event) {\n\t\tif ((event instanceof MouseEvent)\n\t\t\t&& SwingUtilities.isLeftMouseButton((MouseEvent) event)) {\n\t\t\tMouseEvent me = (MouseEvent) event;\n\n\t\t\treturn (\n\t\t\t\tme.getClickCount() == 1 && inHitRegion(me.getX(), me.getY()));\n\t\t}\n\t\treturn false;\n\t}\n",
    "119268": "\tprotected boolean inHitRegion(int x, int y) {\n\t\tif (lastCell != null && graph != null) {\n\t\t\tRectangle bounds = graph.getCellBounds(lastCell);\n\n\t\t\tif (bounds != null\n\t\t\t\t&& x <= (bounds.x + offsetX)\n\t\t\t\t&& y <= (bounds.y + offsetY)\n\t\t\t\t&& offsetX < (bounds.width - 5)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "119270": "\tpublic void setScale(double newValue) {\n\t\tif (newValue > 0) {\n\t\t\tdouble oldValue = this.scale;\n\t\t\tscale = newValue;\n\t\t\tfirePropertyChange(SCALE_PROPERTY, oldValue, newValue);\n\t\t}\n\t}\n",
    "119271": "\tprotected void prepareForEditing() {\n\t\teditingContainer.add(editingComponent);\n\t}\n",
    "119272": "\tprotected Container createContainer() {\n\t\treturn new EditorContainer();\n\t}\n",
    "119276": "\tpublic int getGridSize() {\n\t\treturn gridSize;\n\t}\n",
    "119279": "\t\tpublic Border getBorder() {\n\t\t\treturn border;\n\t\t}\n",
    "119283": "\tpublic int getGridMode() {\n\t\treturn gridMode;\n\t}\n",
    "119284": "\t\tpublic void paint(Graphics g) {\n\t\t\tDimension size = getSize();\n\n\t\t\t// Then the icon.\n\t\t\tif (editingIcon != null) {\n\t\t\t\tint yLoc = 0;\n\t\t\t\tint xLoc = 0;\n\t\t\t\teditingIcon.paintIcon(this, g, xLoc, yLoc);\n\t\t\t}\n\n\t\t\t// Border selection color\n\t\t\tColor background = getBorderSelectionColor();\n\t\t\tif (background != null) {\n\t\t\t\tg.setColor(background);\n\t\t\t\tg.drawRect(0, 0, size.width - 1, size.height - 1);\n\t\t\t}\n\t\t\tsuper.paint(g);\n\t\t}\n",
    "119285": "\t\tpublic void doLayout() {\n\t\t\tif (editingComponent != null) {\n\t\t\t\tDimension cSize = getSize();\n\t\t\t\tint h = (int) editingComponent.getPreferredSize().getHeight();\n\t\t\t\teditingComponent.setBounds(\n\t\t\t\t\toffsetX,\n\t\t\t\t\toffsetY,\n\t\t\t\t\tcSize.width - offsetX,\n\t\t\t\t\th);\n\t\t\t}\n\t\t}\n",
    "119287": "\t\tpublic Dimension getPreferredSize() {\n\t\t\tif (editingComponent != null) {\n\t\t\t\tDimension pSize = editingComponent.getPreferredSize();\n\n\t\t\t\tpSize.width += offsetX + 2;\n\t\t\t\tpSize.height += offsetY + 2;\n\n\t\t\t\t// Make sure width is at least 50.\n\t\t\t\t// and height at least 20\n\t\t\t\tint iwidth = 50;\n\t\t\t\tif (editingIcon != null) {\n\t\t\t\t\tiwidth = Math.max(editingIcon.getIconWidth(), iwidth);\n\t\t\t\t}\n\t\t\t\tpSize.height = Math.max(pSize.height, 24); // Offset 4\n\t\t\t\tpSize.width = Math.max(pSize.width, iwidth);\n\t\t\t\treturn pSize;\n\t\t\t}\n\t\t\treturn new Dimension(0, 0);\n\t\t}\n",
    "119288": "\t\tpublic void mouseMoved(MouseEvent e) {\n\t\t\tif (previousCursor == null)\n\t\t\t\tpreviousCursor = graph.getCursor();\n\t\t\tif (graph != null && graph.isEnabled()) {\n\t\t\t\tif (marquee != null)\n\t\t\t\t\tmarquee.mouseMoved(e);\n\t\t\t\tif (handle != null)\n\t\t\t\t\thandle.mouseMoved(e);\n\t\t\t\tif (!e.isConsumed() && previousCursor != null) {\n\t\t\t\t\tgraph.setCursor(previousCursor);\n\t\t\t\t\tpreviousCursor = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "119289": "\tpublic void update() {\n\t\tsuper.update();\n\t\tbounds = GraphConstants.getBounds(allAttributes);\n\t\tgroupBounds = null;\n\t}\n",
    "119291": "\tpublic void setGridSize(int newSize) {\n\t\tint oldValue = this.gridSize;\n\n\t\tthis.gridSize = newSize;\n\t\tfirePropertyChange(GRID_SIZE_PROPERTY, oldValue, newSize);\n\t}\n",
    "119292": "\tpublic Rectangle getBounds() {\n\t\tif (!isLeaf()) {\n\t\t\tif (groupBounds == null)\n\t\t\t\tupdateGroupBounds();\n\t\t\treturn groupBounds;\n\t\t}\n\t\treturn bounds;\n\t}\n",
    "119298": "\tpublic void setGridMode(int mode) {\n\t\tif (mode == DOT_GRID_MODE\n\t\t\t|| mode == CROSS_GRID_MODE\n\t\t\t|| mode == LINE_GRID_MODE) {\n\t\t\tgridMode = mode;\n\t\t\trepaint();\n\t\t}\n\t}\n",
    "119300": "\tpublic CellHandle getHandle(GraphContext context) {\n\t\tif (GraphConstants.isSizeable(getAllAttributes())\n\t\t\t&& context.getGraph().isSizeable())\n\t\t\treturn new SizeHandle(this, context);\n\t\treturn null;\n\t}\n",
    "119301": "\tpublic Point getCenterPoint() {\n\t\tRectangle r = getBounds();\n\t\treturn new Point((int) r.getCenterX(), (int) r.getCenterY());\n\t}\n",
    "119302": "\tpublic Point getPerimeterPoint(Point source, Point p) {\n\t\treturn renderer.getPerimeterPoint(this, source, p);\n\t}\n",
    "119305": "\tpublic boolean isGridVisible() {\n\t\treturn gridVisible;\n\t}\n",
    "119309": "\t\tpublic void mouseMoved(MouseEvent event) {\n\t\t\tif (vertex != null) {\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tif (r[i].contains(event.getPoint())) {\n\t\t\t\t\t\tgraph.setCursor(new Cursor(cursors[i]));\n\t\t\t\t\t\tevent.consume();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "119310": "\t\tpublic void mousePressed(MouseEvent event) {\n\t\t\tif (!graph.isSizeable())\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\tif (r[i].contains(event.getPoint())) {\n\t\t\t\t\tSet set = new HashSet();\n\t\t\t\t\tset.add(vertex.getCell());\n\t\t\t\t\tcontextViews = context.createTemporaryContextViews(set);\n\t\t\t\t\tObject[] all =\n\t\t\t\t\t\tAbstractCellView.getDescendantViews(\n\t\t\t\t\t\t\tnew CellView[] { vertex });\n\t\t\t\t\tif (all.length\n\t\t\t\t\t\t>= org.jgraph.plaf.basic.BasicGraphUI.MAXHANDLES)\n\t\t\t\t\t\tcachedBounds = new Rectangle(initialBounds);\n\t\t\t\t\tevent.consume();\n\t\t\t\t\tindex = i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "119312": "\tpublic void setGridVisible(boolean flag) {\n\t\tboolean oldValue = gridVisible;\n\n\t\tgridVisible = flag;\n\t\tfirePropertyChange(GRID_VISIBLE_PROPERTY, oldValue, flag);\n\t}\n",
    "119318": "\tpublic void addConnections(CellView[] views) {\n\t\tfor (int i = 0; i < views.length; i++) {\n\t\t\tif (views[i] instanceof EdgeView) {\n\t\t\t\tEdgeView edgeView = (EdgeView) views[i];\n\t\t\t\tObject edge = edgeView.getCell();\n\t\t\t\tCellView sourceView = edgeView.getSource();\n\t\t\t\tCellView targetView = edgeView.getTarget();\n\t\t\t\tObject source = null;\n\t\t\t\tif (sourceView != null)\n\t\t\t\t\tsource = sourceView.getCell();\n\t\t\t\tObject target = null;\n\t\t\t\tif (targetView != null)\n\t\t\t\t\ttarget = targetView.getCell();\n\t\t\t\tconnect(edge, source, target);\n\t\t\t}\n\t\t}\n\t}\n",
    "119319": "\tpublic boolean isPortsVisible() {\n\t\treturn portsVisible;\n\t}\n",
    "119320": "\tpublic void connect(Object edge, Object source, Object target) {\n\t\tconnect(edge, source, true);\n\t\tconnect(edge, target, false);\n\t}\n",
    "119321": "\tpublic void connect(Object edge, Object port, boolean source) {\n\t\tConnection c = new Connection(edge, port, source);\n\t\tconnections.remove(c);\n\t\tconnections.add(c);\n\t\tedges.add(edge);\n\t}\n",
    "119322": "\tpublic void disconnect(Object edge) {\n\t\tdisconnect(edge, true);\n\t\tdisconnect(edge, false);\n\t}\n",
    "119323": "\tpublic void disconnect(Object edge, boolean source) {\n\t\tconnections.add(new Connection(edge, null, source));\n\t\tedges.add(edge);\n\t}\n",
    "119324": "\tpublic boolean isEmpty() {\n\t\treturn connections.isEmpty();\n\t}\n",
    "119325": "\tpublic int size() {\n\t\treturn connections.size();\n\t}\n",
    "119327": "\tpublic Iterator connections() {\n\t\treturn connections.iterator();\n\t}\n",
    "119328": "\tpublic Set getChangedEdges() {\n\t\treturn edges;\n\t}\n",
    "119329": "\tpublic void setPortsVisible(boolean flag) {\n\t\tboolean oldValue = portsVisible;\n\n\t\tportsVisible = flag;\n\t\tfirePropertyChange(PORTS_VISIBLE_PROPERTY, oldValue, flag);\n\t}\n",
    "119330": "\tpublic ConnectionSet clone(Map map) {\n\t\tConnectionSet cs = new ConnectionSet();\n\t\tIterator it = connections();\n\t\twhile (it.hasNext()) {\n\t\t\t// Shortcut Vars\n\t\t\tConnection c = (Connection) it.next();\n\t\t\tObject edge = map.get(c.getEdge());\n\t\t\tObject port = c.getPort();\n\t\t\tif (port != null)\n\t\t\t\tport = map.get(port);\n\t\t\t// New Port\n\t\t\tif (edge != null && port != null)\n\t\t\t\tcs.connect(edge, port, c.isSource());\n\t\t\t// Old Port\n\t\t\telse if (edge != null)\n\t\t\t\tcs.connect(edge, c.getPort(), c.isSource());\n\t\t}\n\t\treturn cs;\n\t}\n",
    "119331": "\t\tpublic Object getEdge() {\n\t\t\treturn edge;\n\t\t}\n",
    "119332": "\t\tpublic Object getPort() {\n\t\t\treturn port;\n\t\t}\n",
    "119333": "\t\tpublic boolean isSource() {\n\t\t\treturn isSource;\n\t\t}\n",
    "119334": "\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Connection) {\n\t\t\t\tConnection other = (Connection) obj;\n\t\t\t\treturn (\n\t\t\t\t\tother.getEdge().equals(edge)\n\t\t\t\t\t\t&& other.isSource() == isSource);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "119335": "\t\tpublic int hashCode() {\n\t\t\treturn edge.hashCode();\n\t\t}\n",
    "119336": "\tpublic boolean isAntiAliased() {\n\t\treturn antiAliased;\n\t}\n",
    "119347": "\tpublic void setAntiAliased(boolean newValue) {\n\t\tboolean oldValue = this.antiAliased;\n\n\t\tthis.antiAliased = newValue;\n\t\tfirePropertyChange(ANTIALIASED_PROPERTY, oldValue, newValue);\n\t}\n",
    "119348": "\tpublic void setSelectionMode(int mode) {\n\t\tint oldMode = selectionMode;\n\n\t\tselectionMode = mode;\n\t\tif (selectionMode != GraphSelectionModel.MULTIPLE_GRAPH_SELECTION\n\t\t\t&& selectionMode != GraphSelectionModel.SINGLE_GRAPH_SELECTION)\n\t\t\tselectionMode = GraphSelectionModel.MULTIPLE_GRAPH_SELECTION;\n\t\tif (oldMode != selectionMode && changeSupport != null)\n\t\t\tchangeSupport.firePropertyChange(\n\t\t\t\tSELECTION_MODE_PROPERTY,\n\t\t\t\tnew Integer(oldMode),\n\t\t\t\tnew Integer(selectionMode));\n\t}\n",
    "119350": "\tpublic int getSelectionMode() {\n\t\treturn selectionMode;\n\t}\n",
    "119351": "\tpublic void setChildrenSelectable(boolean flag) {\n\t\tchildrenSelectable = flag;\n\t}\n",
    "119352": "\tpublic boolean isChildrenSelectable() {\n\t\treturn childrenSelectable;\n\t}\n",
    "119353": "\tpublic boolean isEditable() {\n\t\treturn editable;\n\t}\n",
    "119354": "\tprotected boolean isChildrenSelectable(Object cell) {\n\t\treturn childrenSelectable;\n\t}\n",
    "119355": "\tpublic void setSelectionCell(Object cell) {\n\t\tif (cell == null)\n\t\t\tsetSelectionCells(null);\n\t\telse\n\t\t\tsetSelectionCells(new Object[] { cell });\n\t}\n",
    "119357": "\t\tpublic void mouseMoved(MouseEvent event) {\n\t\t\tif (!event.isConsumed() && handles != null)\n\t\t\t\tfor (int i = handles.length - 1;\n\t\t\t\t\ti >= 0 && !event.isConsumed();\n\t\t\t\t\ti--)\n\t\t\t\t\tif (handles[i] != null)\n\t\t\t\t\t\thandles[i].mouseMoved(event);\n\t\t}\n",
    "119358": "\tpublic void addSelectionCell(Object cell) {\n\t\tif (cell != null)\n\t\t\taddSelectionCells(new Object[] { cell });\n\t}\n",
    "119359": "\tpublic void addSelectionCells(Object[] cells) {\n\t\tif (cells != null) {\n\t\t\tif (selectionMode == GraphSelectionModel.SINGLE_GRAPH_SELECTION)\n\t\t\t\tsetSelectionCells(cells);\n\t\t\telse {\n\t\t\t\tVector change = new Vector();\n\t\t\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\t\t\tif (cells[i] != null) {\n\t\t\t\t\t\tboolean newness = select(selection, cells[i]);\n\t\t\t\t\t\tif (newness) {\n\t\t\t\t\t\t\tchange.addElement(\n\t\t\t\t\t\t\t\tnew CellPlaceHolder(cells[i], true));\n\t\t\t\t\t\t\tObject parent =\n\t\t\t\t\t\t\t\tgraph.getModel().getParent(cells[i]);\n\t\t\t\t\t\t\tif (parent != null)\n\t\t\t\t\t\t\t\tchange.addElement(\n\t\t\t\t\t\t\t\t\tnew CellPlaceHolder(parent, false));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (change.size() > 0)\n\t\t\t\t\tnotifyCellChange(change);\n\t\t\t}\n\t\t}\n\t}\n",
    "119360": "\tpublic void setEditable(boolean flag) {\n\t\tboolean oldValue = this.editable;\n\n\t\tthis.editable = flag;\n\t\tfirePropertyChange(EDITABLE_PROPERTY, oldValue, flag);\n\t}\n",
    "119361": "\tpublic void removeSelectionCell(Object cell) {\n\t\tif (cell != null)\n\t\t\tremoveSelectionCells(new Object[] { cell });\n\t}\n",
    "119362": "\tpublic void removeSelectionCells(Object[] cells) {\n\t\tif (cells != null) {\n\t\t\tVector change = new Vector();\n\t\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\t\tif (cells[i] != null) {\n\t\t\t\t\tboolean removed = deselect(cells[i]);\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tchange.addElement(new CellPlaceHolder(cells[i], false));\n\t\t\t\t\t\tObject parent = graph.getModel().getParent(cells[i]);\n\t\t\t\t\t\tif (parent != null)\n\t\t\t\t\t\t\tchange.addElement(\n\t\t\t\t\t\t\t\tnew CellPlaceHolder(parent, false));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (change.size() > 0)\n\t\t\t\tnotifyCellChange(change);\n\t\t}\n\t}\n",
    "119363": "\tpublic Object getSelectionCell() {\n\t\tif (selection != null && selection.size() > 0)\n\t\t\treturn selection.toArray()[0];\n\t\treturn null;\n\t}\n",
    "119365": "\tpublic int getSelectionCount() {\n\t\treturn (selection == null) ? 0 : selection.size();\n\t}\n",
    "119366": "\tpublic GraphModel getModel() {\n\t\treturn graphModel;\n\t}\n",
    "119367": "\tpublic boolean isCellSelected(Object cell) {\n\t\tint count = getSelectedChildCount(cell);\n\t\treturn (count == SELECTED);\n\t}\n",
    "119369": "\tpublic boolean isChildrenSelected(Object cell) {\n\t\tint count = getSelectedChildCount(cell);\n\t\treturn (count > 0);\n\t}\n",
    "119370": "\tpublic boolean isSelectionEmpty() {\n\t\treturn (selection.isEmpty());\n\t}\n",
    "119371": "\t\tprotected CellView findViewForPoint(Point pt) {\n\t\t\tint snap = graph.getTolerance();\n\t\t\tRectangle r =\n\t\t\t\tnew Rectangle(pt.x - snap, pt.y - snap, 2 * snap, 2 * snap);\n\t\t\tfor (int i = 0; i < views.length; i++)\n\t\t\t\tif (views[i].intersects(graph.getGraphics(), r))\n\t\t\t\t\treturn views[i];\n\t\t\treturn null;\n\t\t}\n",
    "119372": "\tpublic void setModel(GraphModel newModel) {\n\t\tGraphModel oldModel = graphModel;\n\n\t\tgraphModel = newModel;\n\t\tfirePropertyChange(GRAPH_MODEL_PROPERTY, oldModel, graphModel);\n\t\t// FIX: Use Listener\n\t\tif (graphLayoutCache != null\n\t\t\t&& graphLayoutCache.getModel() != graphModel)\n\t\t\tgraphLayoutCache.setModel(graphModel);\n\t\tinvalidate();\n\t}\n",
    "119373": "\tpublic void clearSelection() {\n\t\tif (selection != null) {\n\t\t\tVector change = new Vector();\n\t\t\tIterator it = cellStates.entrySet().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\tchange.addElement(new CellPlaceHolder(entry.getKey(), false));\n\t\t\t}\n\t\t\tselection.clear();\n\t\t\tcellStates.clear();\n\t\t\tif (change.size() > 0)\n\t\t\t\tnotifyCellChange(change);\n\t\t}\n\t}\n",
    "119374": "\tprotected int getSelectedChildCount(Object cell) {\n\t\tif (cell != null) {\n\t\t\tInteger state = (Integer) cellStates.get(cell);\n\t\t\tif (state == null) {\n\t\t\t\tstate = UNSELECTED;\n\t\t\t\tcellStates.put(cell, state);\n\t\t\t}\n\t\t\treturn state.intValue();\n\t\t}\n\t\treturn 0;\n\t}\n",
    "119375": "\tprotected void setSelectedChildCount(Object cell, int count) {\n\t\tInteger i = new Integer(count);\n\t\tcellStates.put(cell, i);\n\t}\n",
    "119377": "\tpublic GraphLayoutCache getGraphLayoutCache() {\n\t\treturn graphLayoutCache;\n\t}\n",
    "119379": "\tpublic void addGraphSelectionListener(GraphSelectionListener x) {\n\t\tlistenerList.add(GraphSelectionListener.class, x);\n\t}\n",
    "119380": "\tpublic void removeGraphSelectionListener(GraphSelectionListener x) {\n\t\tlistenerList.remove(GraphSelectionListener.class, x);\n\t}\n",
    "119381": "\tpublic void setGraphLayoutCache(GraphLayoutCache newLayoutCache) {\n\t\tGraphLayoutCache oldLayoutCache = graphLayoutCache;\n\n\t\tgraphLayoutCache = newLayoutCache;\n\t\tfirePropertyChange(\n\t\t\tGRAPH_LAYOUT_CACHE_PROPERTY,\n\t\t\toldLayoutCache,\n\t\t\tgraphLayoutCache);\n\t\t// FIX: Use Listener\n\t\tif (graphLayoutCache != null\n\t\t\t&& graphLayoutCache.getModel() != getModel())\n\t\t\tgraphLayoutCache.setModel(getModel());\n\t\tinvalidate();\n\t}\n",
    "119383": "\tprotected void fireValueChanged(GraphSelectionEvent e) {\n\t\t// Guaranteed to return a non-null array\n\t\tObject[] listeners = listenerList.getListenerList();\n\t\t// TreeSelectionEvent e = null;\n\t\t// Process the listeners last to first, notifying\n\t\t// those that are interested in this event\n\t\tfor (int i = listeners.length - 2; i >= 0; i -= 2) {\n\t\t\tif (listeners[i] == GraphSelectionListener.class) {\n\t\t\t\t// Lazily create the event:\n\t\t\t\t// if (e == null)\n\t\t\t\t// e = new ListSelectionEvent(this, firstIndex, lastIndex);\n\t\t\t\t ((GraphSelectionListener) listeners[i + 1]).valueChanged(e);\n\t\t\t}\n\t\t}\n\t}\n",
    "119384": "\tprotected void notifyCellChange(Vector changedCells) {\n\t\tint cCellCount = changedCells.size();\n\t\tboolean[] newness = new boolean[cCellCount];\n\t\tObject[] cells = new Object[cCellCount];\n\t\tCellPlaceHolder placeholder;\n\n\t\tfor (int counter = 0; counter < cCellCount; counter++) {\n\t\t\tplaceholder = (CellPlaceHolder) changedCells.elementAt(counter);\n\t\t\tnewness[counter] = placeholder.isNew;\n\t\t\tcells[counter] = placeholder.cell;\n\t\t}\n\n\t\tGraphSelectionEvent event =\n\t\t\tnew GraphSelectionEvent(this, cells, newness);\n\n\t\tfireValueChanged(event);\n\t}\n",
    "119385": "\tpublic Object clone() throws CloneNotSupportedException {\n\t\tDefaultGraphSelectionModel clone =\n\t\t\t(DefaultGraphSelectionModel) super.clone();\n\t\tclone.changeSupport = null;\n\t\tif (selection != null)\n\t\t\tclone.selection = new ArrayList(selection);\n\t\tclone.listenerList = new EventListenerList();\n\t\treturn clone;\n\t}\n",
    "119386": "\tpublic BasicMarqueeHandler getMarqueeHandler() {\n\t\treturn marquee;\n\t}\n",
    "119389": "\t\tpublic boolean isNew() {\n\t\t\treturn isNew;\n\t\t}\n",
    "119390": "\t\tpublic void setCell(Object cell) {\n\t\t\tthis.cell = cell;\n\t\t}\n",
    "119391": "\tpublic void setMarqueeHandler(BasicMarqueeHandler newMarquee) {\n\t\tBasicMarqueeHandler oldMarquee = marquee;\n\n\t\tmarquee = newMarquee;\n\t\tfirePropertyChange(MARQUEE_HANDLER_PROPERTY, oldMarquee, newMarquee);\n\t\tinvalidate();\n\t}\n",
    "119393": "\t\tpublic void setNew(boolean isNew) {\n\t\t\tthis.isNew = isNew;\n\t\t}\n",
    "119395": "\tpublic int getDescendantCount() {\n\t\treturn cellCount;\n\t}\n",
    "119397": "\tpublic boolean contains(Object node) {\n\t\treturn cellSet.contains(node);\n\t}\n",
    "119398": "\tpublic CellView getMapping(Object cell, boolean create) {\n\t\tif (cell != null) {\n\t\t\tCellView view = (CellView) views.get(cell);\n\t\t\tif (view != null)\n\t\t\t\treturn view;\n\t\t\telse if (contains(cell))\n\t\t\t\treturn createMapping(cell);\n\t\t\telse\n\t\t\t\treturn graphLayoutCache.getMapping(cell, false);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119399": "\tpublic void setInvokesStopCellEditing(boolean newValue) {\n\t\tboolean oldValue = invokesStopCellEditing;\n\n\t\tinvokesStopCellEditing = newValue;\n\t\tfirePropertyChange(\n\t\t\tINVOKES_STOP_CELL_EDITING_PROPERTY,\n\t\t\toldValue,\n\t\t\tnewValue);\n\t}\n",
    "119402": "\tpublic void putMapping(Object cell, CellView view) {\n\t\tviews.put(cell, view);\n\t}\n",
    "119403": "\tpublic void setFactory(CellViewFactory factory) {\n\t\tthis.factory = factory;\n\t}\n",
    "119405": "\tpublic boolean getInvokesStopCellEditing() {\n\t\treturn invokesStopCellEditing;\n\t}\n",
    "119407": "\tpublic CellViewFactory getFactory() {\n\t\treturn factory;\n\t}\n",
    "119408": "\tpublic void setModel(GraphModel model) {\n\t\troots.clear();\n\t\tmapping.clear();\n\t\thiddenSet.clear();\n\t\tvisibleSet.clear();\n\t\tgraphModel = model;\n\t\tObject[] cells = DefaultGraphModel.getRoots(model);\n\t\tif (!isPartial())\n\t\t\tinsertRoots(getMapping(cells, true));\n\t\t// AutoSize for Existing Cells\n\t\tif (cells != null)\n\t\t\tfor (int i = 0; i < cells.length; i++)\n\t\t\t\tfactory.updateAutoSize(getMapping(cells[i], false));\n\t\t// Update PortView Cache\n\t\tupdatePorts();\n\t}\n",
    "119410": "\tpublic boolean isCellEditable(Object cell) {\n\t\tif (cell != null) {\n\t\t\tCellView view = graphLayoutCache.getMapping(cell, false);\n\t\t\tif (view != null) {\n\t\t\t\treturn isEditable()\n\t\t\t\t&& GraphConstants.isEditable(view.getAllAttributes());\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "119413": "\tprotected void updatePorts() {\n\t\tObject[] roots = DefaultGraphModel.getRoots(graphModel);\n\t\tSet set = DefaultGraphModel.getDescendants(graphModel, roots);\n\t\tif (set != null) {\n\t\t\tObject[] all = set.toArray(); //order(set.toArray());\n\t\t\tArrayList result = new ArrayList();\n\t\t\tfor (int i = 0; i < all.length; i++) {\n\t\t\t\tif (graphModel.isPort(all[i])) {\n\t\t\t\t\tCellView portView = getMapping(all[i], false);\n\t\t\t\t\tif (portView != null) {\n\t\t\t\t\t\tresult.add(portView);\n\t\t\t\t\t\tportView.refresh(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tports = new PortView[result.size()];\n\t\t\tresult.toArray(ports);\n\t\t}\n\t}\n",
    "119414": "\tpublic String getToolTipText(MouseEvent event) {\n\t\tif (event != null) {\n\t\t\tObject cell = getFirstCellForLocation(event.getX(), event.getY());\n\t\t\tString s = convertValueToString(cell);\n\t\t\treturn (s != null && s.length() > 0) ? s : null;\n\t\t}\n\t\treturn null;\n\t}\n",
    "119418": "\tpublic void setSelectionModel(GraphSelectionModel selectionModel) {\n\t\tif (selectionModel == null)\n\t\t\tselectionModel = EmptySelectionModel.sharedInstance();\n\n\t\tGraphSelectionModel oldValue = this.selectionModel;\n\n\t\t// Remove Redirector From Old Selection Model\n\t\tif (this.selectionModel != null && selectionRedirector != null)\n\t\t\tthis.selectionModel.removeGraphSelectionListener(\n\t\t\t\tselectionRedirector);\n\n\t\tthis.selectionModel = selectionModel;\n\n\t\t// Add Redirector To New Selection Model\n\t\tif (selectionRedirector != null)\n\t\t\tthis.selectionModel.addGraphSelectionListener(selectionRedirector);\n\n\t\tfirePropertyChange(\n\t\t\tSELECTION_MODEL_PROPERTY,\n\t\t\toldValue,\n\t\t\tthis.selectionModel);\n\t}\n",
    "119423": "\tpublic GraphSelectionModel getSelectionModel() {\n\t\treturn selectionModel;\n\t}\n",
    "119426": "\tpublic void clearSelection() {\n\t\tgetSelectionModel().clearSelection();\n\t}\n",
    "119429": "\tpublic void insertRoots(CellView[] views) {\n\t\tif (views != null) {\n\t\t\trefresh(views, true);\n\t\t\tfor (int i = 0; i < views.length; i++) {\n\t\t\t\tif (views[i] != null\n\t\t\t\t\t&& getMapping(views[i].getCell(), false) != null) {\n\t\t\t\t\tCellView parentView = views[i].getParentView();\n\t\t\t\t\tObject parent =\n\t\t\t\t\t\t(parentView != null) ? parentView.getCell() : null;\n\t\t\t\t\tif (!(views[i] instanceof PortView)\n\t\t\t\t\t\t&& !roots.contains(views[i])\n\t\t\t\t\t\t&& parent == null) {\n\t\t\t\t\t\troots.add(views[i]);\n\t\t\t\t\t\t// Remove children for non-partial views?\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "119430": "\tpublic boolean isSelectionEmpty() {\n\t\treturn getSelectionModel().isSelectionEmpty();\n\t}\n",
    "119431": "\tpublic CellView getMapping(Object cell, boolean create) {\n\t\tif (cell == null)\n\t\t\treturn null;\n\t\tCellView view = (CellView) mapping.get(cell);\n\t\tif (view == null && create) {\n\t\t\tview = (CellView) hiddenSet.get(cell);\n\t\t\tif (view != null && isVisible(cell)) {\n\t\t\t\tputMapping(cell, view);\n\t\t\t\thiddenSet.remove(cell);\n\t\t\t} else\n\t\t\t\tview = factory.createView(cell, this);\n\t\t}\n\t\treturn view;\n\t}\n",
    "119433": "\tpublic void putMapping(Object cell, CellView view) {\n\t\t// Remove isVisible-condition?\n\t\tif (cell != null && view != null && isVisible(cell))\n\t\t\tmapping.put(cell, view);\n\t}\n",
    "119434": "\tpublic void addGraphSelectionListener(GraphSelectionListener tsl) {\n\t\tlistenerList.add(GraphSelectionListener.class, tsl);\n\t\tif (listenerList.getListenerCount(GraphSelectionListener.class) != 0\n\t\t\t&& selectionRedirector == null) {\n\t\t\tselectionRedirector = new GraphSelectionRedirector();\n\t\t\tselectionModel.addGraphSelectionListener(selectionRedirector);\n\t\t}\n\t}\n",
    "119435": "\tpublic CellView removeMapping(Object cell) {\n\t\tif (cell != null) {\n\t\t\tCellView view = (CellView) mapping.remove(cell);\n\t\t\treturn view;\n\t\t}\n\t\treturn null;\n\t}\n",
    "119439": "\tpublic void removeGraphSelectionListener(GraphSelectionListener tsl) {\n\t\tlistenerList.remove(GraphSelectionListener.class, tsl);\n\t\tif (listenerList.getListenerCount(GraphSelectionListener.class) == 0\n\t\t\t&& selectionRedirector != null) {\n\t\t\tselectionModel.removeGraphSelectionListener(selectionRedirector);\n\t\t\tselectionRedirector = null;\n\t\t}\n\t}\n",
    "119443": "\tprotected void fireValueChanged(GraphSelectionEvent e) {\n\t\t// Guaranteed to return a non-null array\n\t\tObject[] listeners = listenerList.getListenerList();\n\t\t// Process the listeners last to first, notifying\n\t\t// those that are interested in this event\n\t\tfor (int i = listeners.length - 2; i >= 0; i -= 2) {\n\t\t\tif (listeners[i] == GraphSelectionListener.class) {\n\t\t\t\t((GraphSelectionListener) listeners[i + 1]).valueChanged(e);\n\t\t\t}\n\t\t}\n\t}\n",
    "119447": "\tpublic void setSelectionCell(Object cell) {\n\t\tgetSelectionModel().setSelectionCell(cell);\n\t}\n",
    "119451": "\tpublic void setSelectionCells(Object[] cells) {\n\t\tgetSelectionModel().setSelectionCells(cells);\n\t}\n",
    "119455": "\tpublic void addSelectionCell(Object cell) {\n\t\tgetSelectionModel().addSelectionCell(cell);\n\t}\n",
    "119459": "\tpublic void addSelectionCells(Object[] cells) {\n\t\tgetSelectionModel().addSelectionCells(cells);\n\t}\n",
    "119462": "\tpublic void removeSelectionCell(Object cell) {\n\t\tgetSelectionModel().removeSelectionCell(cell);\n\t}\n",
    "119465": "\tpublic void remove(Object[] roots) {\n\t\tgraphModel.remove(roots);\n\t}\n",
    "119466": "\tpublic Object getSelectionCell() {\n\t\treturn getSelectionModel().getSelectionCell();\n\t}\n",
    "119469": "\tpublic void toBack(Object[] cells) {\n\t\tif (cells != null && cells.length > 0) {\n\t\t\tif (isOrdered()) {\n\t\t\t\tCellView[] views = getMapping(cells, false);\n\t\t\t\tGraphViewLayerEdit edit =\n\t\t\t\t\tnew GraphViewLayerEdit(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tviews,\n\t\t\t\t\t\tGraphViewLayerEdit.BACK);\n\t\t\t\tgraphModel.edit(null, null, null, new UndoableEdit[] { edit });\n\t\t\t} else\n\t\t\t\tgraphModel.toBack(cells);\n\t\t}\n\t}\n",
    "119470": "\tpublic int getSelectionCount() {\n\t\treturn getSelectionModel().getSelectionCount();\n\t}\n",
    "119472": "\tpublic void toFront(Object[] cells) {\n\t\tif (cells != null && cells.length > 0) {\n\t\t\tif (isOrdered()) {\n\t\t\t\tCellView[] views = getMapping(cells, false);\n\t\t\t\tGraphViewLayerEdit edit =\n\t\t\t\t\tnew GraphViewLayerEdit(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tviews,\n\t\t\t\t\t\tGraphViewLayerEdit.FRONT);\n\t\t\t\tgraphModel.edit(null, null, null, new UndoableEdit[] { edit });\n\t\t\t} else\n\t\t\t\tgraphModel.toFront(cells);\n\t\t}\n\t}\n",
    "119473": "\tpublic boolean isCellSelected(Object cell) {\n\t\treturn getSelectionModel().isCellSelected(cell);\n\t}\n",
    "119478": "\tpublic void scrollCellToVisible(Object cell) {\n\t\tRectangle bounds = getCellBounds(cell);\n\t\tif (bounds != null) {\n\t\t\tbounds = new Rectangle(bounds);\n\t\t\tscrollRectToVisible(toScreen(bounds));\n\t\t}\n\t}\n",
    "119479": "\t\tpublic Object getSource() {\n\t\t\treturn GraphLayoutCache.this;\n\t\t}\n",
    "119481": "\tpublic void scrollPointToVisible(Point p) {\n\t\tif (p != null) {\n\t\t\tRectangle bounds = new Rectangle(p);\n\t\t\tif (bounds != null)\n\t\t\t\tscrollRectToVisible(bounds);\n\t\t}\n\t}\n",
    "119486": "\tpublic boolean isEditing() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\treturn graph.isEditing(this);\n\t\treturn false;\n\t}\n",
    "119490": "\tpublic boolean stopEditing() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\treturn graph.stopEditing(this);\n\t\treturn false;\n\t}\n",
    "119493": "\tpublic void cancelEditing() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\tgraph.cancelEditing(this);\n\t}\n",
    "119496": "\t\tpublic Object getSource() {\n\t\t\treturn changeSource;\n\t\t}\n",
    "119497": "\tpublic void startEditingAtCell(Object cell) {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\tgraph.startEditingAtCell(this, cell);\n\t}\n",
    "119498": "\t\tpublic Map getAttributes() {\n\t\t\treturn null;\n\t\t}\n",
    "119499": "\t\tprotected void saveComponentState(JComponent comp) {\n\t\t}\n",
    "119500": "\tpublic Object getEditingCell() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\treturn graph.getEditingCell(this);\n\t\treturn null;\n\t}\n",
    "119501": "\t\tpublic void redo() throws CannotRedoException {\n\t\t\tsuper.redo();\n\t\t\tupdateNext();\n\t\t\texecute();\n\t\t}\n",
    "119504": "\t\tprotected void restoreComponentState(JComponent comp) {\n\t\t\tif (handle != null)\n\t\t\t\thandle.mouseDragged(null);\n\t\t}\n",
    "119505": "\tpublic void graphDidChange() {\n\t\trevalidate();\n\t\trepaint();\n\t}\n",
    "119506": "\t\tpublic void execute() {\n\t\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\t\tList list = getParentList(cells[i]);\n\t\t\t\tif (list != null) {\n\t\t\t\t\tprev[i] = list.indexOf(cells[i]);\n\t\t\t\t\tif (prev[i] >= 0) {\n\t\t\t\t\t\tlist.remove(prev[i]);\n\t\t\t\t\t\tint n = next[i];\n\t\t\t\t\t\tif (n == FRONT)\n\t\t\t\t\t\t\tn = list.size();\n\t\t\t\t\t\telse if (n == BACK)\n\t\t\t\t\t\t\tn = 0;\n\t\t\t\t\t\tlist.add(n, cells[i]);\n\t\t\t\t\t\tnext[i] = prev[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateListeners();\n\t\t}\n",
    "119507": "\t\tprotected void updateInsertionLocation(JComponent comp, Point p) {\n\t\t\tsetInsertionLocation(p);\n\t\t\tif (handle != null) {\n\t\t\t\t// How to fetch the shift state?\n\t\t\t\tint mod =\n\t\t\t\t\t(dropAction == TransferHandler.COPY)\n\t\t\t\t\t\t? InputEvent.CTRL_MASK\n\t\t\t\t\t\t: 0;\n\t\t\t\thandle.mouseDragged(\n\t\t\t\t\tnew MouseEvent(comp, 0, 0, mod, p.x, p.y, 1, false));\n\t\t\t}\n\t\t}\n",
    "119510": "\t\tprotected List getParentList(Object view) {\n\t\t\tif (view instanceof CellView) {\n\t\t\t\tCellView parent = ((CellView) view).getParentView();\n\t\t\t\tList list = null;\n\t\t\t\tif (parent == null)\n\t\t\t\t\tlist = ((GraphLayoutCache) changeSource).roots;\n\t\t\t\telse if (parent instanceof AbstractCellView)\n\t\t\t\t\tlist = ((AbstractCellView) parent).childViews;\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n",
    "119513": "\tpublic Map getHiddenSet() {\n\t\treturn hiddenSet;\n\t}\n",
    "119515": "\tpublic boolean isHideEdgesOnBecomeInvisible() {\n\t\treturn hideEdgesOnBecomeInvisible;\n\t}\n",
    "119516": "\t\tstatic public EmptySelectionModel sharedInstance() {\n\t\t\treturn sharedInstance;\n\t\t}\n",
    "119518": "\tpublic boolean isHideEdgesOnHide() {\n\t\treturn hideEdgesOnHide;\n\t}\n",
    "119520": "\t\tpublic void setSelectionCells(Object[] cells) {\n\t\t}\n",
    "119521": "\tpublic boolean isRememberCellViews() {\n\t\treturn rememberCellViews;\n\t}\n",
    "119523": "\tpublic boolean isShowAllEdgesForVisibleVertices() {\n\t\treturn showAllEdgesForVisibleVertices;\n\t}\n",
    "119524": "\t\tpublic void addSelectionCells(Object[] cells) {\n\t\t}\n",
    "119525": "\tpublic boolean isShowEdgesOnShow() {\n\t\treturn showEdgesOnShow;\n\t}\n",
    "119527": "\t\tpublic void removeSelectionCells(Object[] cells) {\n\t\t}\n",
    "119530": "\tpublic void setHideEdgesOnBecomeInvisible(boolean hideEdgesOnBecomeInvisible) {\n\t\tthis.hideEdgesOnBecomeInvisible = hideEdgesOnBecomeInvisible;\n\t}\n",
    "119531": "\t\tpublic void valueChanged(GraphSelectionEvent e) {\n\t\t\tGraphSelectionEvent newE;\n\n\t\t\tnewE = (GraphSelectionEvent) e.cloneWithSource(JGraph.this);\n\t\t\tfireValueChanged(newE);\n\t\t}\n",
    "119532": "\tpublic void setHideEdgesOnHide(boolean hideEdgesOnHide) {\n\t\tthis.hideEdgesOnHide = hideEdgesOnHide;\n\t}\n",
    "119533": "\tpublic Dimension getPreferredScrollableViewportSize() {\n\t\treturn getPreferredSize();\n\t}\n",
    "119534": "\tpublic void setRememberCellViews(boolean rememberCellViews) {\n\t\tthis.rememberCellViews = rememberCellViews;\n\t}\n",
    "119536": "\tpublic void setShowAllEdgesForVisibleVertices(boolean showAllEdgesForVisibleVertices) {\n\t\tthis.showAllEdgesForVisibleVertices = showAllEdgesForVisibleVertices;\n\t}\n",
    "119539": "\tpublic void setShowEdgesOnShow(boolean showEdgesOnShow) {\n\t\tthis.showEdgesOnShow = showEdgesOnShow;\n\t}\n",
    "119542": "\tpublic void paint(Graphics g) {\n\t\ttry {\n\t\t\t//if (preview && !isDoubleBuffered)\n\t\t\t//\tsetOpaque(false);\n\t\t\tsuper.paint(g);\n\t\t\tpaintSelectionBorder(g);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t// JDK Bug: Zero length string passed to TextLayout constructor\n\t\t}\n\t}\n",
    "119543": "\tprotected void paintSelectionBorder(Graphics g) {\n\t\t((Graphics2D) g).setStroke(GraphConstants.SELECTION_STROKE);\n\t\tif (childrenSelected)\n\t\t\tg.setColor(graph.getGridColor());\n\t\telse if (hasFocus && selected)\n\t\t\tg.setColor(graph.getLockedHandleColor());\n\t\telse if (selected)\n\t\t\tg.setColor(graph.getHighlightColor());\n\t\tif (childrenSelected || selected) {\n\t\t\tDimension d = getSize();\n\t\t\tg.drawRect(0, 0, d.width - 1, d.height - 1);\n\t\t}\n\t}\n",
    "119552": "\tpublic boolean getScrollableTracksViewportWidth() {\n\t\tif (getParent() instanceof JViewport) {\n\t\t\treturn (\n\t\t\t\t((JViewport) getParent()).getWidth()\n\t\t\t\t\t> getPreferredSize().width);\n\t\t}\n\t\treturn false;\n\t}\n",
    "119561": "\tpublic boolean getScrollableTracksViewportHeight() {\n\t\tif (getParent() instanceof JViewport) {\n\t\t\treturn (\n\t\t\t\t((JViewport) getParent()).getHeight()\n\t\t\t\t\t> getPreferredSize().height);\n\t\t}\n\t\treturn false;\n\t}\n",
    "119564": "\tpublic boolean isHideGroups() {\n\t\treturn hideGroups;\n\t}\n",
    "119565": "\tpublic void setHideGroups(boolean hideGroups) {\n\t\tthis.hideGroups = hideGroups;\n\t}\n",
    "119567": "\tpublic ConnectionSet getConnectionSet() {\n\t\treturn cs;\n\t}\n",
    "119569": "\tpublic Map getAttributeMap() {\n\t\treturn attributeMap;\n\t}\n",
    "119572": "\tprotected String paramString() {\n\t\tString editableString = (editable ? \"true\" : \"false\");\n\t\tString invokesStopCellEditingString =\n\t\t\t(invokesStopCellEditing ? \"true\" : \"false\");\n\t\treturn super.paramString()\n\t\t\t+ \",editable=\"\n\t\t\t+ editableString\n\t\t\t+ \",invokesStopCellEditing=\"\n\t\t\t+ invokesStopCellEditingString;\n\t}\n",
    "119574": "\tpublic boolean isPlainSupported() {\n\t\treturn (cells != null && cells.length == 1);\n\t}\n",
    "119575": "\tpublic String getPlainData() {\n\t\tif (cells[0] instanceof DefaultGraphCell) {\n\t\t\tObject obj = ((DefaultGraphCell) cells[0]).getUserObject();\n\t\t\tif (obj != null)\n\t\t\t\treturn obj.toString();\n\t\t}\n\t\treturn cells[0].toString();\n\t}\n",
    "119576": "\tpublic void undo(Object source) {\n\t\tif (source == null || !isInProgress())\n\t\t\tsuper.undo();\n\t\telse {\n\t\t\tUndoableEdit edit = editToBeUndone(source);\n\t\t\t//System.out.println(\"undoTo edit=\"+edit);\n\t\t\tif (edit == null)\n\t\t\t\tthrow new CannotUndoException();\n\t\t\tundoTo(edit);\n\t\t}\n\t}\n",
    "119577": "\tpublic boolean isHTMLSupported() {\n\t\treturn isPlainSupported();\n\t}\n",
    "119579": "\tpublic String getHTMLData() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tbuf.append(\"<html><body><p>\");\n\t\tbuf.append(getPlainData());\n\t\tbuf.append(\"</p></body></html>\");\n\t\treturn buf.toString();\n\t}\n",
    "119580": "\tprotected UndoableEdit nextEditToBeUndone(UndoableEdit current) {\n\t\tif (current == null)\n\t\t\treturn editToBeUndone();\n\t\telse {\n\t\t\tint index = edits.indexOf(current) - 1;\n\t\t\tif (index >= 0)\n\t\t\t\treturn (UndoableEdit) edits.get(index);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119582": "\tpublic void redo(Object source) {\n\t\tif (source == null || !isInProgress())\n\t\t\tsuper.redo();\n\t\telse {\n\t\t\tUndoableEdit edit = editToBeRedone(source);\n\t\t\t//System.out.println(\"redoTo edit=\"+edit);\n\t\t\tif (edit == null)\n\t\t\t\tthrow new CannotRedoException();\n\t\t\tredoTo(edit);\n\t\t}\n\t}\n",
    "119583": "\tpublic Object getSource() {\n\t\treturn source;\n\t}\n",
    "119585": "\tpublic Object getTarget() {\n\t\treturn target;\n\t}\n",
    "119586": "\tprotected UndoableEdit nextEditToBeRedone(UndoableEdit current) {\n\t\tif (current == null)\n\t\t\treturn editToBeRedone();\n\t\telse {\n\t\t\tint index = edits.indexOf(current) + 1;\n\t\t\tif (index < edits.size())\n\t\t\t\treturn (UndoableEdit) edits.get(index);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119587": "\tpublic void setSource(Object port) {\n\t\tsource = port;\n\t}\n",
    "119588": "\tpublic void addEntry(Object child, Object parent) {\n\t\tif (child != null) {\n\t\t\tentries.add(new Entry(child, parent));\n\t\t\t// Update Changed Nodes\n\t\t\tchangedNodes.add(child);\n\t\t\tif (parent != null)\n\t\t\t\tchangedNodes.add(parent);\n\t\t}\n\t}\n",
    "119589": "\tpublic void setTarget(Object port) {\n\t\ttarget = port;\n\t}\n",
    "119590": "\tpublic int size() {\n\t\treturn entries.size();\n\t}\n",
    "119591": "\tpublic Object clone() {\n\t\tDefaultEdge c = (DefaultEdge) super.clone();\n\t\tc.source = null;\n\t\tc.target = null;\n\t\treturn c;\n\t}\n",
    "119593": "\tpublic Iterator entries() {\n\t\treturn entries.iterator();\n\t}\n",
    "119596": "\tpublic Set getChangedNodes() {\n\t\treturn changedNodes;\n\t}\n",
    "119597": "\tpublic CellView getParentView() {\n\t\tCellView parent = super.getParentView();\n\t\tif (parent == null)\n\t\t\tparent = lastParent;\n\t\telse\n\t\t\tlastParent = parent;\n\t\treturn parent;\n\t}\n",
    "119598": "\tpublic ParentMap clone(Map map) {\n\t\tParentMap pm = new ParentMap();\n\t\tIterator it = entries();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry e = (Entry) it.next();\n\t\t\tObject child = map.get(e.getChild());\n\t\t\tObject parent = map.get(e.getParent());\n\t\t\tif (child == null)\n\t\t\t\tchild = e.getChild();\n\t\t\tif (parent == null)\n\t\t\t\tparent = e.getParent();\n\t\t\tif (child != null && parent != null)\n\t\t\t\tpm.addEntry(child, parent);\n\t\t}\n\t\treturn pm;\n\t}\n",
    "119599": "\tpublic Rectangle getBounds() {\n\t\tRectangle bounds = new Rectangle(getLocation(null));\n\t\tbounds.x = bounds.x - size / 2;\n\t\tbounds.y = bounds.y - size / 2;\n\t\tbounds.width = bounds.width + size;\n\t\tbounds.height = bounds.height + size;\n\t\treturn bounds;\n\t}\n",
    "119600": "\t\tpublic Object getChild() {\n\t\t\treturn child;\n\t\t}\n",
    "119602": "\t\tpublic Object getParent() {\n\t\t\treturn parent;\n\t\t}\n",
    "119606": "\tprotected Point getNextPoint(EdgeView edge) {\n\t\tint n = edge.getPointCount();\n\t\tif (n > 1) {\n\t\t\tif (edge.getSource() == this)\n\t\t\t\treturn getEdgePoint(edge, 1);\n\t\t\telse if (edge.getTarget() == this)\n\t\t\t\treturn getEdgePoint(edge, n - 2);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119607": "\tpublic void setUserObject(Object obj) {\n\t\tif (userObject instanceof ValueChangeHandler) {\n\t\t\t((ValueChangeHandler) userObject).valueChanged(obj);\n\t\t} else\n\t\t\tsuper.setUserObject(obj);\n\t\tobj = getUserObject();\n\t\tif (obj == null)\n\t\t\tGraphConstants.setValue(attributes, \"\");\n\t\telse\n\t\t\tGraphConstants.setValue(attributes, obj);\n\t}\n",
    "119608": "\tprotected Point getEdgePoint(EdgeView view, int index) {\n\t\tObject obj = view.points.get(index);\n\t\tif (obj instanceof Point)\n\t\t\treturn (Point) obj;\n\t\telse if (obj instanceof PortView) {\n\t\t\tVertexView vertex = (VertexView) ((CellView) obj).getParentView();\n\t\t\tif (vertex != null)\n\t\t\t\treturn vertex.getCenterPoint();\n\t\t}\n\t\treturn null;\n\t}\n",
    "119609": "\tpublic List getChildren() {\n\t\tif (children == null)\n\t\t\treturn Collections.EMPTY_LIST;\n\t\treturn children;\n\t}\n",
    "119615": "\tpublic void setAttributes(Map attributes) {\n\t\tthis.attributes = attributes;\n\t}\n",
    "119617": "\tpublic Object clone() {\n\t\tDefaultGraphCell c = (DefaultGraphCell) super.clone();\n\t\tc.attributes = new Hashtable(attributes);\n\t\tc.userObject = cloneUserObject();\n\t\treturn c;\n\t}\n",
    "119620": "\tpublic String getToolTipText(MouseEvent event) {\n\t\tif (linkHandler.isHoveringOverHyperlink() && (linkHandler.getHoveredURL() != null)) {\n\t\t\t// have to manually toggle tooltip enabled status to prevent empty\n\t\t\t// tooltip from appearing when not hovering over url\n\t\t\tToolTipManager.sharedInstance().setEnabled(true);\n\t\t\treturn linkHandler.getHoveredURL();\n\t\t}\n\t\telse {\n\t\t\tToolTipManager.sharedInstance().setEnabled(false);\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "119621": "\tpublic void setRect(String key, Rectangle r) {\n\t\tString val = r.getX() + \",\" + r.getY() + \",\" + r.getWidth() + \",\" + r.getHeight();\n\t\tthis.setProperty(key, val);\n\t}\n",
    "119624": "\tpublic Point getToolTipLocation(MouseEvent event) {\n\t\treturn new Point(event.getX() + 10, event.getY() + 25);\n\t}\n",
    "119625": "\tpublic Rectangle getRect(String key) {\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint width = 0;\n\t\tint height = 0;\n\t\tString rect = this.getProperty(key);\n\t\ttry {\n\t\t\tStringTokenizer st = new StringTokenizer(rect, \",\");\n\t\t\t     x = (int)Double.parseDouble(st.nextToken());\n\t\t\t     y = (int)Double.parseDouble(st.nextToken());\n\t\t\t width = (int)Double.parseDouble(st.nextToken());\n\t\t\theight = (int)Double.parseDouble(st.nextToken());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Rectangle(x, y, width, height);\n\t}\n",
    "119626": "\tpublic boolean isHoveringOverHyperlink() {\n\t\treturn linkHandler.isHoveringOverHyperlink();\n\t}\n",
    "119627": "\tpublic void save() {\n\t\tUtilities.writePropertiesToFile((Frame)null, this, file,  \"---User Properties--- output from UserProperties.java\");\n\t}\n",
    "119628": "\tpublic String getHoveredURL() {\n\t\treturn linkHandler.getHoveredURL();\n\t}\n",
    "119630": "\t\tpublic boolean isHoveringOverHyperlink() {\n\t\t\t// check if pane is editable as caller could have changed editability after\n\t\t\t// hyperlinkUpdate was fired causing indeterminability in hovering status\n\t\t\tif (pane.isEditable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn isHovering;\n\t\t\t}\n\t\t}\n",
    "119631": "\tprotected void finalize() throws Throwable {\n\t\tLocaleChangeAdapter.removeContainer(this);\n\t\tPositionManager.removeComponent(this);\n\t\tsuper.finalize();\n\t}\n",
    "119632": "\t\tpublic String getHoveredURL() {\n\t\t\treturn hoveredURLString;\n\t\t}\n",
    "119633": "\tpublic void setName(String name) {\n\t\tsuper.setName(name);\n\t\tPositionManager.updateComponent(this);\n\t\tLocaleChangeAdapter.updateComponent(this);\n\t}\n",
    "119636": "\tpublic void validate() {\n\t\tLocaleChangeAdapter.updateContainer(this);\n\t\tsuper.validate();\n\t}\n",
    "119638": "\tpublic void registerDefaultEscAction() {\n\t\tregisterEscAction(new GPEscAction());\n\t}\n",
    "119640": "\tpublic void registerEscAction(Action action) {\n\t\tthis.getRootPane().registerKeyboardAction(\n\t\t\taction,\n\t\t\tescKeystroke,\n\t\t\tJComponent.WHEN_IN_FOCUSED_WINDOW);\n\t}\n",
    "119642": "\tpublic void unregisterEscAction() {\n\t\tthis.getRootPane().unregisterKeyboardAction(escKeystroke);\n\n\t}\n",
    "119644": "\tpublic void setEscButton(JButton button){\n\t\tregisterEscAction(new GPEscAction(button));\n\t}\n",
    "119647": "\tpublic void setDefaultButton(JButton button){\n\t\tgetRootPane().setDefaultButton(button);\n\t}\n",
    "119649": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(e.getSource().getClass());\n\n\t\t// is the esc button set?\n\t\tif (button != null){\n\t\t\tbutton.doClick();\n\t\t\treturn;\n\t\t}\n\t\t\t \n\n\t\t// is it an internal frame?\n\t\ttry {\n\t\t\tJInternalFrame jif =\n\t\t\t\t(JInternalFrame) SwingUtilities.getAncestorOfClass(\n\t\t\t\t\tJInternalFrame.class,\n\t\t\t\t\t(Component) e.getSource());\n\t\t\tif (jif != null) {\n\t\t\t\tjif.dispose();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tSystem.err.println(ex);\n\t\t}\n\n\t\t// is it an window?\n\t\ttry {\n\t\t\tWindow w =\n\t\t\t\t(Window) SwingUtilities.getAncestorOfClass(\n\t\t\t\t\tWindow.class,\n\t\t\t\t\t(Component) e.getSource());\n\t\t\tif (w != null) {\n\t\t\t\tw.dispose();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tSystem.err.println(ex);\n\t\t}\n\n\t}\n",
    "119653": "\tprotected void finalize() throws Throwable {\n\t\tPositionManager.removeComponent(this);\n\t\tsuper.finalize();\n\t}\n",
    "119661": "\tpublic void localeChanged(LocaleChangeEvent e) {\n\t\tVector copy;\n\t\tsynchronized (containers) {\n\t\t\tcopy = (Vector) containers.clone();\n\t\t}\n\t\tEnumeration oEnum = copy.elements();\n\t\twhile (oEnum.hasMoreElements()) {\n\t\t\tupdateContainer((Container) oEnum.nextElement());\n\t\t}\n\t}\n",
    "119664": "\tpublic Enumeration getKeys() {\n\t\treturn properNames.keys();\n\t}\n",
    "119666": "\tpublic String getString(String key) {\n\t\treturn (String) properNames.get(key);\n\t}\n",
    "119670": "\tpublic void setBounds(Rectangle r) {\n\t\tthis.setBounds(r.x, r.y, r.width, r.height);\n\t}\n",
    "119672": "\tpublic void propertyChange(PropertyChangeEvent evt) {\n\t\tif (evt.getSource() == null)\n\t\t\treturn;\n\n\t\tif (evt.getPropertyName() == JSplitPane.DIVIDER_LOCATION_PROPERTY\n\t\t\t&& ((Integer) evt.getOldValue()).intValue() != -1) {\n\n\t\t\tif (evt.getSource() instanceof JSplitPane) {\n\t\t\t\ttry {\n\t\t\t\t\tJSplitPane jsp = (JSplitPane) evt.getSource();\n\t\t\t\t\tPositionManager.setIntPos(\n\t\t\t\t\t\tjsp,\n\t\t\t\t\t\tPositionManager.DIVIDER_LOCATION,\n\t\t\t\t\t\tjsp.getDividerLocation());\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tSystem.err.println(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "119673": "\tpublic void setLocation(Point p) {\n\t\tthis.setLocation(p.x, p.y);\n\t}\n",
    "119674": "\tpublic void setSnapSelectedView(boolean snapSelectedView) {\n\t\tthis.snapSelectedView = snapSelectedView;\n\t}\n",
    "119675": "\tpublic void setSize(Dimension d) {\n\t\tthis.setSize(d.width, d.height);\n\t}\n",
    "119680": "\tpublic void show() {\n\t\tinit();\n\n\t\tif (hasBeenVisibleAtLeastOnce == false) {\n\t\t\t// set default location to be centered\n\t\t\t// this'buttonSelect implementation of setBounds will deal with checking for persisted value\n\t\t\tDimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\t\t\tint x = (screenSize.width - this.getWidth()) / 2;\n\t\t\tint y = (screenSize.height - this.getHeight()) / 2;\n\t\t\tthis.setBounds(x, y, this.getWidth(), this.getHeight());\n\t\t}\n\n\t\thasBeenVisibleAtLeastOnce = true;\n\t\tsuper.show();\n\t}\n",
    "119694": "\tpublic void hide() {\n\t\tinit();\n\t\t//Before hiding frame, set properties inside UserProperties then save UserProperties to file in hard disk\n\t\tguiProperties.setRect(property_bounds, this.getBounds());\n\t\tguiProperties.save();\n\t\tsuper.hide();\n\t}\n",
    "119697": "\tprotected void init() {\n\n\t\t// check if not already init'd\n\t\tif (guiProperties == null) {\n\t\t\tguiProperties = UserProperties.getInstance(nameSpace);\n\t\t}\n\n      \t}\n",
    "119701": "\tpublic GPDocument getDocument() {\n\t\treturn document;\n\t}\n",
    "119704": "\tpublic void setDocument(GPDocument document) {\n\t\tthis.remove(this.document);\n\t\tthis.document = document;\n\t\tthis.add(this.document);\n\t\t//this.pack();\n\t}\n",
    "119715": "\tpublic void hide() {\n\t\tinit();\n\t\tguiProperties.setRect(property_bounds, this.getBounds());\n\t\tguiProperties.save();\n\t\tsuper.hide();\n\t}\n",
    "119731": "\tpublic URL getFilename() {\n\t\treturn file;\n\t}\n",
    "119734": "\tpublic void setFilename(URL filename) {\n\t\tthis.file = filename;\n\t\tupdateFrameTitle();\n\t}\n",
    "119750": "\tpublic GPGraph getGraph() {\n\t\treturn graph;\n\t}\n",
    "119752": "\tpublic FileFilter getFileFilter() {\n\t\treturn fileFilter;\n\t}\n",
    "119759": "\tpublic JComponent getWriteAccessory() {\n\t    return null; //compZipSelect;\n\t}\n",
    "119760": "\tprotected GPGraphUI getGraphUI() {\n\t\treturn (GPGraphUI) graph.getUI();\n\t}\n",
    "119762": "\tpublic GraphLayoutCache getGraphLayoutCache() {\n\t\treturn graph.getGraphLayoutCache();\n\t}\n",
    "119768": "\tpublic Hashtable getWriteProperties(JComponent accessory) {\n\t\tHashtable properties = new Hashtable();\n\t\tif (!(accessory instanceof JCheckBox)){\n\t\t\treturn properties;\n\t\t}\n\t\tproperties.put(COMPRESS_WITH_ZIP, new Boolean(((JCheckBox)accessory).isSelected() ));\n\t\treturn properties;\n\t}\n",
    "119805": "\tpublic void updatePageFormat() {\n\t\tPageFormat f = graph.getPageFormat();\n\t\tcolumnRule.setActiveOffset((int) (f.getImageableX()));\n\t\trowRule.setActiveOffset((int) (f.getImageableY()));\n\t\tcolumnRule.setActiveLength((int) (f.getImageableWidth()));\n\t\trowRule.setActiveLength((int) (f.getImageableHeight()));\n\t\tif (graph.isPageVisible()) {\n\t\t\tint w = (int) (f.getWidth());\n\t\t\tint h = (int) (f.getHeight());\n\t\t\tgraph.setMinimumSize(new Dimension(w + 5, h + 5));\n\t\t} else\n\t\t\tgraph.setMinimumSize(null);\n\t\tinvalidate();\n\t\t// Execute fitAction...\n\t\tcomponentResized(null);\n\t\tgraph.repaint();\n\t}\n",
    "119831": "\tpublic GraphUndoManager getGraphUndoManager() {\n\t\treturn graphUndoManager;\n\t}\n",
    "119834": "\tpublic void setGraphUndoManager(GraphUndoManager graphUndoManager) {\n\t\tthis.graphUndoManager = graphUndoManager;\n\t}\n",
    "119837": "\tpublic void delete() {\n\t\tif (selected != null && fullLibraryAccess) {\n\t\t\tGraphCellsComponent tmp = selected;\n\t\t\tGPTransferable t = tmp.getTransferable();\n\t\t\tpanel.getGraph().getModel().remove(t.getCells());\n\t\t\tpanel.remove(tmp);\n\t\t\tsetSelected(null);\n\t\t\tpanel.revalidate();\n\t\t\trepaint();\n\t\t}\n\t}\n",
    "119838": "\tpublic void resetGraphUndoManager() {\n\t\tgraphUndoManager.discardAllEdits();\n\t}\n",
    "119840": "\t\tprotected Transferable createTransferable(JComponent c) {\n\t\t\tif (selected != null) {\n\t\t\t\tdragging = true;\n\t\t\t\treturn selected.getTransferable();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n",
    "119841": "\tpublic GPGraphpad getGraphpad() {\n\t\treturn graphpad;\n\t}\n",
    "119845": "\tpublic void setGraphpad(GPGraphpad graphpad) {\n\t\tthis.graphpad = graphpad;\n\t}\n",
    "119849": "\tpublic Touch getTouch() {\n\t\treturn touch;\n\t}\n",
    "119852": "\tpublic void setTouch(Touch touch) {\n\t\tthis.touch = touch;\n\t}\n",
    "119858": "\t\tpublic void undoableEditHappened(UndoableEditEvent e) {\n\t\t\tif (addEdits)\n\t\t\t\tdocument.getGraphUndoManager().addEdit(e.getEdit());\n\t\t\tdocument.getGraphpad() .getEditUndoAction().update();\n\t\t\tdocument.getGraphpad() .getEditRedoAction().update();\n\t\t}\n",
    "119859": "\tpublic ActionMap getActionMap() {\n\t\treturn actionMap;\n\t}\n",
    "119861": "\tpublic void setActionMap(ActionMap actionMap) {\n\t\tthis.actionMap = actionMap;\n\t}\n",
    "119862": "  public Locale getOldLocale(){\n    return this.oldLocale;\n  }\n",
    "119863": "  public Locale getNewLocale(){\n    return this.newLocale;\n  }\n",
    "119864": "  public void addProperNameProvider(ProperNameProvider provider){\n    properNameProvider.add(provider);\n\n    Enumeration keys = provider.getKeys();\n    while (keys.hasMoreElements()){\n      String key = (String)keys.nextElement();\n      String value = provider.getString(key);\n      if (key != null && value != null){\n        defaultNames.put(key, value);\n      }\n    }\n  }\n",
    "119866": "  public void removeProperNameProvider(ProperNameProvider provider){\n    properNameProvider.remove(provider);\n    requeryDefaultNames();\n  }\n",
    "119869": "  public Enumeration getKeys() {\n    return defaultNames.elements();\n  }\n",
    "119870": "  public Object handleGetObject(String key) {\n    return defaultNames.get(key);\n  }\n",
    "119873": "\tpublic String getFindPattern() {\n\t\treturn findPattern;\n\t}\n",
    "119877": "\tpublic void setFindPattern(String findPattern) {\n\t\tthis.findPattern = findPattern;\n\t}\n",
    "119881": "\tpublic Object getLastFound() {\n\t\treturn lastFound;\n\t}\n",
    "119884": "\tpublic void setLastFound(Object lastFound) {\n\t\tthis.lastFound = lastFound;\n\t}\n",
    "119888": "\tpublic JDialog getOverviewDialog() {\n\t\treturn overviewDialog;\n\t}\n",
    "119891": "\tpublic boolean isGroup(Object cell) {\n\t\t// Map the Cell to its View\n\t\tCellView view = getGraphLayoutCache().getMapping(cell, false);\n\t\tif (view != null)\n\t\t\treturn !view.isLeaf();\n\t\treturn false;\n\t}\n",
    "119892": "\tpublic void setOverviewDialog(JDialog overviewDialog) {\n\t\tthis.overviewDialog = overviewDialog;\n\t}\n",
    "119893": "\tpublic boolean isVertex(Object object) {\n\t\tif (!(object instanceof Port) && !(object instanceof Edge))\n\t\t\treturn !isGroup(object) && object != null;\n\t\treturn false;\n\t}\n",
    "119896": "\tpublic GPSplitPane getSplitPane() {\n\t\treturn splitPane;\n\t}\n",
    "119900": "\tpublic void setSplitPane(GPSplitPane splitPane) {\n\t\tthis.splitPane = splitPane;\n\t}\n",
    "119904": "\tpublic JScrollPane getScrollPane() {\n\t\treturn scrollPane;\n\t}\n",
    "119908": "\tpublic void setScrollPane(JScrollPane scrollPane) {\n\t\tthis.scrollPane = scrollPane;\n\t}\n",
    "119909": "\tpublic String getToolTipText(MouseEvent event) {\n\t\tif (event != null) {\n\t\t\tObject cell = getFirstCellForLocation(event.getX(), event.getY());\n\t\t\tif (cell != null) {\n\t\t\t\tString tmp = convertValueToString(cell);\n\t\t\t\tString s = \"<html>\";\n\t\t\t\tif (tmp != null && tmp.length() > 0)\n\t\t\t\t\ts = s + \"<strong>\" + tmp + \"</strong><br>\";\n\t\t\t\treturn s + getToolTipForCell(cell) + \"</html>\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "119913": "\tpublic Rule getColumnRule() {\n\t\treturn columnRule;\n\t}\n",
    "119914": "\tpublic void updateUI() {\n\t\tsetUI(new GPGraphUI());\n\t\tinvalidate();\n\t}\n",
    "119919": "\tpublic Rule getRowRule() {\n\t\treturn rowRule;\n\t}\n",
    "119920": "\tpublic boolean isNeighbour(Object v1, Object v2) {\n\t\tObject[] edges = getEdgesBetween(v1, v2);\n\t\treturn (edges != null && edges.length > 0);\n\t}\n",
    "119926": "\tprotected void processWindowEvent(WindowEvent e) {\n\t\t//\n\t\tif (e.getID() == WindowEvent.WINDOW_CLOSING) {\n\t\t\t// only close the window when we are not in embedded mode\n\t\t\t// release resources and exit if we are not running embedded, buttonImage.buttonEdge., as\n\t\t\t// part of another application\n\t\t\t//super.processWindowEvent(buttonEdge);\n\t\t\tthis.dispose() ;\n\t\t}\n\t}\n",
    "119927": "\tpublic void setColumnRule(Rule columnRule) {\n\t\tthis.columnRule = columnRule;\n\t}\n",
    "119934": "\tpublic void setRowRule(Rule rowRule) {\n\t\tthis.rowRule = rowRule;\n\t}\n",
    "119940": "\tpublic boolean isEnableTooltips() {\n\t\treturn enableTooltips;\n\t}\n",
    "119947": "\tpublic void setEnableTooltips(boolean enableTooltips) {\n\t\tthis.enableTooltips = enableTooltips;\n\n\t\tif (this.enableTooltips)\n\t\t\tToolTipManager.sharedInstance().registerComponent(graph);\n\t\telse\n\t\t\tToolTipManager.sharedInstance().unregisterComponent(graph);\n\t}\n",
    "119950": "\tpublic void setTextArea(JTextArea ta) {\n\t\tcurrentWindow = ta;\n\t}\n",
    "119952": "\tprivate void clearWindow() {\n\t\tcurrentWindow.setText(\"\");\n\t}\n",
    "119953": "\tpublic GPInternalFrame getInternalFrame() {\n\t\treturn internalFrame;\n\t}\n",
    "119956": "\tpublic void print(boolean b) {\n\t\tif (showOrig)\n\t\t\torig.print(b);\n\t\tif (b)\n\t\t\ttarget.append(\"true\"/*#Frozen*/);\n\t\telse\n\t\t\ttarget.append(\"false\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119958": "\tpublic void println(boolean b) {\n\t\tif (showOrig)\n\t\t\torig.println(b);\n\n\t\tif (b)\n\t\t\ttarget.append(\"true\\n\"/*#Frozen*/);\n\t\telse\n\t\t\ttarget.append(\"false\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119959": "\tprotected void setInternalFrame(GPInternalFrame internalFrame) {\n\t\tthis.internalFrame = internalFrame;\n\t}\n",
    "119960": "\t\t\tprotected Container createContainer() {\n\t\t\t\treturn new MultiLinedEditor.ModifiedEditorContainer();\n\t\t\t}\n",
    "119961": "\tpublic void print(char c) {\n\t\tif (showOrig)\n\t\t\torig.print(c);\n\n\t\tchar[] tmp = new char[1];\n\t\ttmp[0] = c;\n\t\ttarget.append(new String(tmp));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119962": "\tpublic void println(char c) {\n\t\tif (showOrig)\n\t\t\torig.println(c);\n\n\t\tchar[] tmp = new char[2];\n\t\ttmp[0] = c;\n\t\ttmp[1] = '\\n';\n\t\ttarget.append(new String(tmp));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119965": "\tpublic void print(char[] s) {\n\t\tif (showOrig)\n\t\t\torig.print(s);\n\n\t\ttarget.append(new String(s));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119966": "\tpublic void println(char[] s) {\n\t\tif (showOrig)\n\t\t\torig.println(s);\n\n\t\ttarget.append(new String(s) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119968": "\tpublic void print(double d) {\n\t\tif (showOrig)\n\t\t\torig.print(d);\n\n\t\ttarget.append(Double.toString(d));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119971": "\tpublic void println(double d) {\n\t\tif (showOrig)\n\t\t\torig.println(d);\n\n\t\ttarget.append(Double.toString(d) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119972": "\tpublic void print(float f) {\n\t\tif (showOrig)\n\t\t\torig.print(f);\n\n\t\ttarget.append(Float.toString(f));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119973": "\tpublic Hashtable getWriteProperties() {\n\t\treturn writeProperties;\n\t}\n",
    "119974": "\tpublic GraphModelProvider getGraphModelProvider() {\n\t\treturn graphModelProvider;\n\t}\n",
    "119975": "\tpublic void println(float f) {\n\t\tif (showOrig)\n\t\t\torig.println(f);\n\n\t\ttarget.append(Float.toString(f) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119976": "\tpublic void print(int i) {\n\t\tif (showOrig)\n\t\t\torig.print(i);\n\n\t\ttarget.append(Integer.toString(i));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119977": "\tpublic void setWriteProperties(Hashtable writeProperties) {\n\t\tthis.writeProperties = writeProperties;\n\t}\n",
    "119979": "\tpublic void println(int i) {\n\t\tif (showOrig)\n\t\t\torig.println(i);\n\n\t\ttarget.append(Integer.toString(i) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119980": "\tpublic GraphNetworkModel getNetworkModel() {\n\t\treturn networkModel;\n\t}\n",
    "119984": "\tpublic void print(long l) {\n\t\tif (showOrig)\n\t\t\torig.print(l);\n\n\t\ttarget.append(Long.toString(l));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119986": "\tpublic void println(long l) {\n\t\tif (showOrig)\n\t\t\torig.println(l);\n\n\t\ttarget.append(Long.toString(l) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119989": "\tpublic void setNetworkModel(GraphNetworkModel networkModel) {\n\t\tthis.networkModel = networkModel;\n\t}\n",
    "119990": "\tpublic void print(Object o) {\n\t\tif (showOrig)\n\t\t\torig.print(o);\n\n\t\ttarget.append(o.toString());\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119994": "\tpublic void println(Object o) {\n\t\tif (showOrig)\n\t\t\torig.println(o);\n\n\t\ttarget.append(o.toString() + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119997": "\tpublic void print(String s) {\n\t\tif (showOrig)\n\t\t\torig.print(s);\n\n\t\ttarget.append(s);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "120002": "\tpublic void println(String s) {\n\t\tif (showOrig)\n\t\t\torig.println(s);\n\n\t\ttarget.append(s + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "120005": "\tpublic void println() {\n\t\tif (showOrig)\n\t\t\torig.println();\n\n\t\ttarget.append(new String(\"\\n\"/*#Frozen*/));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "120016": "\tpublic String getBarKey() {\n\t\treturn barKey;\n\t}\n",
    "120017": "\tpublic String getBarValue() {\n\t\treturn barValue;\n\t}\n",
    "120020": "\tpublic int getPos() {\n\t\treturn pos;\n\t}\n",
    "120021": "\tpublic void setBarKey(String barKey) {\n\t\tthis.barKey = barKey;\n\t}\n",
    "120022": "\tpublic void setBarValue(String barValue) {\n\t\tthis.barValue = barValue;\n\t}\n",
    "120024": "\tpublic void setPos(int pos) {\n\t\tthis.pos = pos;\n\t}\n",
    "120025": "\tpublic String toString(){\n\t\tStringBuffer b = new StringBuffer();\n\t\tb.append(\"GPBarEntry: barKey=\");\n\t\tb.append(barKey);\n\t\tb.append(\"; pos=\");\n\t\tb.append(pos);\n\t\tb.append(\"; barValue=\");\n\t\tb.append(barValue);\n\t\treturn b.toString() ;\n\t}\n",
    "120039": "\tpublic JMenuBar createMenubar() {\n\t\tJMenuBar mb = new JMenuBar();\n\n\t\tString[] menuKeys = tokenize(MENUBAR, Translator.getString(MENUBAR));\n\t\tfor (int i = 0; i < menuKeys.length; i++) {\n\t\t\tString itemKey = Translator.getString(menuKeys[i] + SUFFIX_MENU);\n\t\t\tif (itemKey == null) {\n\t\t\t\tSystem.err.println(\n\t\t\t\t\t\"Can't find MenuKey: '\"\n\t\t\t\t\t\t+ menuKeys[i]\n\t\t\t\t\t\t+ \"'. I'm ignoring the MenuKey!\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] itemKeys = tokenize(menuKeys[i], itemKey);\n\t\t\tJMenu m = createMenu(menuKeys[i], itemKeys);\n\t\t\tif (m != null)\n\t\t\t\tmb.add(m);\n\t\t}\n\t\treturn mb;\n\t}\n",
    "120043": "\tpublic JPopupMenu createGraphPopupMenu() {\n\t\treturn createPopupMenu(GRAPH_POPUP);\n\t}\n",
    "120046": "\tpublic JPopupMenu createLibraryPopupMenu() {\n\t\treturn createPopupMenu(LIBRARY_POPUP);\n\t}\n",
    "120049": "\tprotected JPopupMenu createPopupMenu(String key) {\n\t\tJPopupMenu pop = new JPopupMenu();\n\t\tString[] itemKeys = tokenize(key, Translator.getString(key));\n\t\tfor (int i = 0; i < itemKeys.length; i++) {\n\t\t\tif (itemKeys[i].equals(\"-\")) {\n\t\t\t\tpop.addSeparator();\n\t\t\t} else {\n\t\t\t\tComponent[] mi = createMenuItem(itemKeys[i]);\n\t\t\t\tfor (int j = 0; j < mi.length; j++) {\n\t\t\t\t\tpop.add(mi[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLocaleChangeAdapter.updateContainer(pop);\n\n\t\treturn pop;\n\t}\n",
    "120050": "\t\tpublic Map diffMap(Map oldState, Map newState) {\n\t\t\tMap diff = new Hashtable();\n\t\t\tIterator it = newState.entrySet().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\tObject key = entry.getKey();\n\t\t\t\tObject newValue = entry.getValue();\n\t\t\t\tObject oldValue = oldState.get(key);\n\t\t\t\tif (oldValue == null || !oldValue.equals(newValue))\n\t\t\t\t\tdiff.put(key, newValue);\n\t\t\t}\n\t\t\treturn diff;\n\t\t}\n",
    "120052": "\tprotected JMenu createMenu(String key) {\n\n\t\treturn createMenu(key, tokenize(key, Translator.getString(key)));\n\t}\n",
    "120114": "\tpublic void update() {\n\t\tEnumeration enumerator = abstractButtons.elements();\n\t\twhile (enumerator.hasMoreElements()) {\n\t\t\tAbstractButton button = (AbstractButton) enumerator.nextElement();\n\t\t\tbutton.setSelected(isSelected(button.getActionCommand()));\n\t\t}\n\t}\n",
    "120116": "\tpublic String getPresentationText(String actionCommand) {\n\t\tif (actionCommand == null)\n\t\t\treturn null;\n\t\t\t\n\t\tfor (int i = 0; i < lookAndFeels.length ; i++){\n\t\t\tif (lookAndFeels[i].getClassName().equals(actionCommand)){\n\t\t\t\treturn lookAndFeels[i].getName() ;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn actionCommand;\n\t}\n",
    "120142": "\tpublic String openDialog(String message, String extension, String desc) {\n\t\treturn dialog(message, true, extension, desc);\n\t}\n",
    "120146": "\tpublic String saveDialog(String message, String extension, String desc) {\n\t\treturn dialog(message, false, extension, desc);\n\t}\n",
    "120150": "\t\tpublic boolean accept(File file) {\n\t\t\treturn file.isDirectory()\n\t\t\t\t|| file.getName().toLowerCase().endsWith(fullExt);\n\t\t}\n",
    "120153": "\t\tpublic String getDescription() {\n\t\t\treturn desc;\n\t\t}\n",
    "120173": "\tprotected ListCellRenderer getItemListCellRenderer() {\n\t\treturn null;\n\t};\n",
    "120176": "\tprotected String getItemPresentationText(Object item) {\n\t\treturn item.toString();\n\t}\n",
    "120191": "\tpublic JToggleButton getButtonActivity() {\n\t\treturn buttonActivity;\n\t}\n",
    "120201": "\tpublic void update() {\n\t\tsuper.update();\n\n\t\tEnumeration enumerator = abstractButtons.elements();\n\t\twhile (enumerator.hasMoreElements()) {\n\t\t\tAbstractButton button = (AbstractButton) enumerator.nextElement();\n\t\t\tbutton.setSelected(isSelected(button.getActionCommand()));\n\t\t}\n\t}\n",
    "120202": "\tpublic void removeAbstractButton(AbstractButton button){\n\t\tabstractButtons.remove(button);\n\t}\n",
    "120210": "\tpublic JToggleButton getButtonDecision() {\n\t\treturn buttonDecision;\n\t}\n",
    "120225": "\tpublic JToggleButton getButtonStart() {\n\t\treturn buttonStart;\n\t}\n",
    "120244": "\tpublic JToggleButton getButtonEnd() {\n\t\treturn buttonEnd;\n\t}\n",
    "120265": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tString name =\n\t\t\tJOptionPane.showInputDialog(Translator.getString(\"URLDialog\", new Object[]{\"foo.gpd\"}));\n\n\t\t// canceled?\n\t\tif (name == null)\n\t\t\treturn;\n\n\t\t// open the graphpad\n\t\ttry {\n\t\t\tgraphpad.addDocument(new URL(name));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tJOptionPane.showMessageDialog(\n\t\t\t\tgraphpad,\n\t\t\t\tex.getLocalizedMessage(),\n\t\t\t\tTranslator.getString(\"Error\"),\n\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n",
    "120268": "\tpublic JToggleButton getButtonSplit() {\n\t\treturn buttonSplit;\n\t}\n",
    "120277": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tJInternalFrame[] ajif = graphpad.getAllFrames();\n\n\t\tfor (int i = 0; i < ajif.length; i++) {\n\t\t\ttry {\n\t\t\t\tajif[i].setMaximum(true);\n\t\t\t} catch (java.beans.PropertyVetoException pvex) {\n\n\t\t\t}\n\t\t}\n\t}\n",
    "120281": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tJInternalFrame[] ajif = graphpad.getAllFrames();\n\n\t\tfor (int i = 0; i < ajif.length; i++) {\n\t\t\ttry {\n\t\t\t\tajif[i].setIcon(true);\n\t\t\t} catch (java.beans.PropertyVetoException pvex) {\n\t\t\t\t// do nothing\n\t\t\t}\n\t\t}\n\t}\n",
    "120291": "\tpublic JToggleButton getButtonJoin() {\n\t\treturn buttonJoin;\n\t}\n",
    "120313": "\tpublic JToggleButton getButtonEdge() {\n\t\treturn buttonEdge;\n\t}\n",
    "120314": "\tpublic String getURL(GPGraph graph, Object cell) {\n\t\tif (cell instanceof DefaultGraphCell) {\n\t\t\tfinal Object userObject = ((DefaultGraphCell) cell).getUserObject();\n\t\t\tif (userObject instanceof GPUserObject) {\n\t\t\t\tObject url = ((GPUserObject) userObject).getProperty(GPUserObject.keyURI);\n\t\t\t\tif (url != null)\n\t\t\t\t\treturn url.toString();\n\t\t\t}\n\t\t}\n\t\treturn cell.toString();\n\t}\n",
    "120316": "\tpublic String getLabel(GPGraph graph, Object cell) {\n\t\treturn graph.convertValueToString(cell.toString());\n\t}\n",
    "120320": "\tpublic String getName() {\n\t\treturn (String) getValue(NAME);\n\t}\n",
    "120331": "\tpublic JToggleButton getButtonLine() {\n\t\treturn buttonLine;\n\t}\n",
    "120337": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tGPInternalFrame gpframe = (GPInternalFrame) this.getSelectedItem(e);\n\t\tgpframe.toFront();\n\t\ttry {\n\t\t\tgpframe.setSelected(true);\n\t\t} catch (PropertyVetoException pve) {\n\t\t}\n\t}\n",
    "120339": "\tprotected JMenu getMenuBarComponent() {\n\t\tJMenu menu = new JMenu(this);\n\t\tmenu.setName(getName());\n\t\tmenus.add(menu);\n\t\treturn menu;\n\t}\n",
    "120340": "\tpublic String getPresentationText(String actionCommand) {\n\t\treturn actionCommand;\n\t}\n",
    "120343": "\tpublic void update(){\n\t\tsuper.update() ;\n\n\t\tJInternalFrame[] iframes = graphpad.getAllFrames();\n\n\t\tfor (int j = 0; j < menus.size(); j++) {\n\t\t\tJMenu menu = (JMenu) menus.get(j);\n\t\t\tmenu.removeAll();\n\n\t\t\tfor (int i = 0; i < iframes.length; i++) {\n\t\t\t\tGPInternalFrame internalFrame = (GPInternalFrame) iframes[i];\n\t\t\t\tmenu.add(\n\t\t\t\t\tgetMenuComponent(\n\t\t\t\t\t\tinternalFrame.getDocument().getFrameTitle(),\n\t\t\t\t\t\tinternalFrame));\n\t\t\t}\n\t\t}\n\t}\n",
    "120344": "\tprotected Component getMenuComponent(String actionCommand) {\n\t\tJMenuItem item = new JMenuItem(this);\n\t\tGPBarFactory.fillMenuButton(item, getName(), actionCommand);\n\t\tString presentationText = getPresentationText(actionCommand);\n\t\tif (presentationText != null)\n\t\t\titem.setText(presentationText);\n\n\t\treturn item;\n\t}\n",
    "120346": "\tpublic JToggleButton getButtonSelect() {\n\t\treturn buttonSelect;\n\t}\n",
    "120348": "\tprotected Component getToolComponent(String actionCommand) {\n\t\tAbstractButton b = new JButton(this) {\n\t\t\tpublic float getAlignmentY() {\n\t\t\t\treturn 0.5f;\n\t\t\t}\n\t\t};\n\t\treturn GPBarFactory.fillToolbarButton(\n\t\t\tb,\n\t\t\tgetName(),\n\t\t\tactionCommand);\n\t}\n",
    "120354": "\tpublic void update() {\n\t\tif (graphpad.getCurrentDocument() == null)\n\t\t\tsetEnabled(false);\n\t\telse\n\t\t\tsetEnabled(true);\n\t}\n",
    "120357": "\tpublic String getPresentationText(String actionCommand) {\n\t\treturn null;\n\t}\n",
    "120363": "\tpublic JToggleButton getButtonText() {\n\t\treturn buttonText;\n\t}\n",
    "120382": "\tpublic JToggleButton getButtonZoomArea() {\n\t\treturn buttonZoomArea;\n\t}\n",
    "120385": "\tpublic String getMessage() {\n\t\treturn message.getText() ;\n\t}\n",
    "120386": "\tpublic String getPresentationName() {\n\t\treturn \"Default Graph Model\";\n\t}\n",
    "120388": "\tpublic String getScale() {\n\t\treturn scale.getText() ;\n\t}\n",
    "120392": "\tpublic void setMessage(String message) {\n\t\tthis.message.setText(message);\n\t}\n",
    "120394": "\tpublic void setScale(String scale) {\n\t\tthis.scale.setText(scale);\n\t}\n",
    "120395": "\tpublic GraphModel createCleanGraphModel() {\n\t\treturn new DefaultGraphModel();\n\t}\n",
    "120397": "\tpublic boolean isMutateAbleTo(Class otherGraphModelClass) {\n\t\treturn false;\n\t}\n",
    "120404": "\tpublic void addPort(Object vertex, Object port) {\n\t\tif (port instanceof DefaultPort) {\n\t\t\tif (vertex instanceof DefaultMutableTreeNode) {\n\t\t\t\t((DefaultMutableTreeNode) vertex).add((DefaultPort) port);\n\t\t\t}\n\t\t}\n\t}\n",
    "120408": "\tpublic GPGraph createCleanGraph(GraphModel model) {\n\t\tGPGraph graph = new GPGraph(model);\n\t\t// TODO: Remove this code when VM is fixed on Mac OS X\n\t\tif (System.getProperty(\"os.name\").equals(\"Mac OS X\")) {\n\t\t\tString s = Translator.getString(\"doubleBufferedOnMacOSX\");\n\t\t\tif (s != null)\n\t\t\t\tgraph.setDoubleBuffered(Boolean.getBoolean(s));\n\t\t}\n\t\treturn graph;\n\t}\n",
    "120412": "\tpublic GraphModelProvider getSelectedGraphModelProvider(){\n\t\tif (lstGraphModelProviders.getModel() .getSize() == 0)\n\t\t\treturn null;\n\t\treturn (GraphModelProvider)lstGraphModelProviders.getSelectedValue() ;\n\t}\n",
    "120426": "\tpublic int getAnswer() {\n\t\treturn answer;\n\t}\n",
    "120432": "\tpublic void show(){\n\n\t\tif (lstGraphModelProviders .getModel() .getSize() <= 1)\n\t\t\treturn;\n\t\telse\n\t\t\tsuper.show();\n\t}\n",
    "120538": "\tprotected Object cloneUserObject() {\n\t\treturn userObject;\n\t}\n",
    "120540": "\tpublic CellHandle getHandle(GraphContext context) {\n\t\tif (GraphConstants.isSizeable(getAllAttributes())\n\t\t\t\t&& context.getGraph().isSizeable())\n\t\t\treturn new JGpdSizeHandle(this, context);\n\t\treturn null;\n\t}\n",
    "120684": "\tpublic void removeGPInternalFrame(GPInternalFrame f) {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf.setVisible(false);\n\t\tdesktop.remove(f);\n\t\tdoc2InternalFrame.remove(f.getDocument());\n\t\tf.cleanUp();\n\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\tif (frames.length > 0) {\n\t\t\ttry {\n\t\t\t\tframes[0].setSelected(true);\n\t\t\t} catch (PropertyVetoException e) {\n\t\t\t}\n\t\t}\n\t}\n",
    "120743": "\tpublic GPMarqueeHandler getMarqueeHandler() {\n\t\treturn marqueeHandler;\n\t}\n",
    "121353": "\tprotected JMenu getMenuBarComponent() {\n//\t\tJMenu menu = new JMenu(this);\n//\t\tmenu.setName(getName());\n//\t\tmenus.add(menu);\n\t\treturn null; //menu;\n\t}\n",
    "121420": "\tpublic GPGraph createCleanGraph(GraphModel model) {\n\t\tGPGraph graph = new GPGraph(model);\n\t\t// TODO: Remove this code when VM is fixed on Mac OS X\n\t\tif (System.getProperty(\"os.name\").equals(\"Mac OS X\")) {\n\t\t\tString s = Translator.getString(\"doubleBufferedOnMacOSX\");\n\t\t\tif (s != null)\n\t\t\t\tgraph.setDoubleBuffered(Boolean.getBoolean(s));\n\t\t}\n\t\tgraph.setDragEnabled(true);\n\t\treturn graph;\n\t}\n",
    "121484": "  public void pprop(String name, Object value) {\n    LogoList listTemp = new LogoList();\n    boolean found = false;\n\n    while (!data.empty()) {\n      String pname = (String) data.first();\n      data.butFirstF();\n      Object pValue = data.first();\n      data.butFirstF();\n\n      if (pname.equalsIgnoreCase(name)) {\n        listTemp.fputF(value);\n        listTemp.fputF(name);\n        found = true;\n      } else {\n        listTemp.fputF(pValue);\n        listTemp.fputF(pname);\n      }\n    }\n\n    if (!found) {\n      listTemp.fputF(value);\n      listTemp.fputF(name);\n    }\n\n    data = listTemp;\n  }\n",
    "121487": "  public void rprop(String name) {\n    LogoList listTemp = new LogoList();\n\n    while (!data.empty()) {\n      String pname = (String) data.first();\n      data.butFirstF();\n      Object pValue = data.first();\n      data.butFirstF();\n\n      // copy to new list only if not what we're removing\n      if (!pname.equalsIgnoreCase(name)) {\n        listTemp.fputF(pValue);\n        listTemp.fputF(pname);\n      }\n    }\n\n    data = listTemp;\n  }\n",
    "121488": "  public Object gprop(String name) {\n    LogoList listTemp = data.duplicate();\n\n    while (!listTemp.empty()) {\n      String pname = (String) listTemp.first();\n      listTemp.butFirstF();\n      Object value = listTemp.first();\n      listTemp.butFirstF();\n\n      if (pname.equalsIgnoreCase(name))\n        return value;\n    }\n\n    return null;\n  }\n",
    "121492": "  public LogoList lprops() {\n    LogoList listTemp = new LogoList();\n    LogoList outList = new LogoList();\n\n    while (!data.empty()) {\n      String name = (String) data.first();\n      data.butFirstF();\n      Object value = data.first();\n      data.butFirstF();\n\n      listTemp.fputF(value);\n      listTemp.fputF(name);\n\n      outList.fputF(name);\n    }\n\n    data = listTemp;\n\n    return outList;\n  }\n",
    "121494": "  public String toString() {\n    return data.toString();\n  }\n",
    "121497": "  public LogoMap duplicate() {\n    return new LogoMap(data);\n  }\n",
    "121502": "  public void fputF(Object o) {\n    head = new LogoLink(o, head);\n  }\n",
    "121505": "  public LogoList fput(Object o) {\n    LogoList out = this.duplicate();\n    out.fputF(o);\n    return out;\n  }\n",
    "121508": "  public void lputF(Object o) {\n    if (empty()) {\n      head = new LogoLink(o);\n    } else {\n      LogoLink cur = head;\n      while (cur.next != null) {\n        cur = cur.next;\n      }\n      cur.next = new LogoLink(o);\n    }\n  }\n",
    "121512": "  public LogoList lput(Object o) {\n    LogoList out = this.duplicate();\n    out.lputF(o);\n    return out;\n  }\n",
    "121516": "  public boolean empty() {\n    return head == null;\n  }\n",
    "121518": "  public Object first() {\n    if (!empty()) {\n      return head.data;\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"First does not like [] as input.\");\n      else throw new RuntimeException(\"Cannot use first on an empty list.\");\n    }\n  }\n",
    "121522": "  public Object last() {\n    if (!empty()) {\n      LogoLink cur = head;\n      while (cur.next != null)\n        cur = cur.next;\n      return cur.data;\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"Last does not like [] as input.\");\n      else throw new RuntimeException(\"Cannot use last on an empty list\");\n    }\n  }\n",
    "121524": "  public LogoList butFirst() {\n    LogoList out = duplicate();\n    out.butFirstF();\n    return out;\n  }\n",
    "121526": "  public LogoList butLast() {\n    LogoList out = duplicate();\n    out.butLastF();\n    return out;\n  }\n",
    "121527": "  protected void init(String file, OutputStream out) throws IOException {\n    filename = file;\n    output = new PrintStream(out);\n    tempRead = File.createTempFile(\"file1\",\".temp\");\n    tempWrite = File.createTempFile(\"file2\",\".temp\");\n  }\n",
    "121528": "  public LogoList butFirstF() {\n    if (!empty()) {\n      head = head.next;\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"butfirst does not like \" + this.toString() +\n                                   \" as input.\");\n      else throw new RuntimeException(\"Cannot use butfirst on an empty list\");\n    }\n\n    return this;\n  }\n",
    "121531": "  public LogoList butLastF() {\n    if (!empty()) {\n      if (head.next == null) {\n        // means head is the last one, remove it\n        head = null;\n      } else {\n        LogoLink cur = head;\n        while (cur.next.next != null)\n          cur = cur.next;\n        cur.next = null;\n      }\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"butlast does not like [] as input.\");\n      else throw new RuntimeException(\"Cannot use butlast on an empty list\");\n    }\n\n    return this;\n  }\n",
    "121533": "  public int count() {\n    if (empty()) {\n      return 0;\n    } else {\n      int count = 1;\n      LogoLink cur = head;\n\n      while (cur.next != null) {\n        count++;\n        cur = cur.next;\n      }\n\n      return count;\n    }\n  }\n",
    "121535": "  protected void preparse(File file) throws IOException {\n    File tRead = tempRead;\n    try {\n      debug(\"preparsing \" + tempRead.getAbsolutePath() + \" to \" +\n            tempWrite.getAbsolutePath());\n      prepareFiles(file, tempWrite, true);\n      tempOut.println(\"#inserted \" + file.getAbsolutePath());\n\n      String line = tempIn.readLine();\n      while (line != null) {\n\n        if (line.indexOf(\"//\") > 0) {\n          line = line.substring(0, line.indexOf(\"//\"));\n        }\n\n        if (line.length() > 0) {\n          tempOut.println(line);\n        }\n\n        line = tempIn.readLine();\n      }\n\n      debug(\"Preparsed \" + filename);\n    } catch (IOException ex) {\n      tempRead = tRead; // make sure this runs\n      throw ex;\n    }\n    tempRead = tRead;\n  }\n",
    "121539": "  public LogoList duplicate() {\n    LogoList out = new LogoList();\n\n    out.copyListToMemory(head);\n\n    return out;\n  }\n",
    "121543": "  public String toString() {\n    StringBuffer out = new StringBuffer(\"[\");\n\n    LogoLink cur = head;\n\n    while (cur != null) {\n      if (cur.data != null)\n        out.append(cur.data.toString());\n      else out.append(\" \");\n      if (cur.next != null) out.append(\" \");\n\n      cur = cur.next;\n    }\n\n    out.append(\"]\");\n    return out.toString();\n  }\n",
    "121546": "  public void removeAll(Object o) {\n    LogoList copy = duplicate();\n    this.clean();\n\n    while (!copy.empty()) {\n      if (copy.first() != o)\n        fput(copy.first());\n      copy.butFirstF();\n    }\n\n    copy = duplicate();\n    clean();\n    while (!copy.empty()) {\n      fput(copy.first());\n      copy.butFirstF();\n    }\n\n  }\n",
    "121548": "  public void doList(ForEachListener fel) {\n    LogoLink cur = head;\n    while (cur != null) {\n      fel.doFor(cur.data);\n      cur = cur.next;\n    }\n  }\n",
    "121551": "  public boolean contains(Object o) {\n    LogoLink cur = head;\n    boolean found = false;\n\n    while (cur != null && !found) {\n      found = cur.data == o || (cur.data != null && cur.data.equals(o));\n\n      if (o instanceof String && cur.data instanceof String) {\n        found |= ((String)o).equalsIgnoreCase((String)cur.data);\n      }\n\n      cur = cur.next;\n    }\n\n    return found;\n  }\n",
    "121552": "  public void clean() {\n    head = null;\n  }\n",
    "121554": "  protected String writeType(String value, String type) {\n    if (type.matches(\"CHAR\\\\(\\\\d+\\\\).*\") || type.matches(\"VARCHAR.*\")) {\n      return \"'\" + value.trim().replaceAll(\"\\'\",\"\\\\'\") + \"'\";\n//      return \"STRING\";\n    } else {\n//      return type;\n      return value.trim();\n    }\n  }\n",
    "121567": "  protected boolean FSM_compilerDirective(String line) {\n    for(int i = 0; i < line.length(); i++) {\n      if (line.charAt(i) == '#') {\n        return true;\n      } else if (line.charAt(i) == ' ' || line.charAt(i) == '\\t') {\n        // do nothing, its is still possible\n      } else {\n        // proven wrong\n        return false;\n      }\n    }\n    return false;\n  }\n",
    "121585": "  public void debug(String text) {\n    if (debugOn) debugStream.println(text);\n  }\n",
    "121607": "\tprivate JPanel getJContentPane() {\n\t\tif (jContentPane == null) {\n\t\t\tjContentPane = new JPanel();\n\t\t\tjContentPane.setLayout(new BorderLayout());\n\t\t\tjContentPane.add(getJPanel(), java.awt.BorderLayout.CENTER);\n\t\t}\n\t\treturn jContentPane;\n\t}\n",
    "121610": "\tprivate JMenuBar getJJMenuBar() {\n\t\tif (jJMenuBar == null) {\n\t\t\tjJMenuBar = new JMenuBar();\n\t\t\tjJMenuBar.add(getFileMenu());\n\t\t\tjJMenuBar.add(getHelpMenu());\n\t\t}\n\t\treturn jJMenuBar;\n\t}\n",
    "121612": "\tprivate JMenu getFileMenu() {\n\t\tif (fileMenu == null) {\n\t\t\tfileMenu = new JMenu();\n\t\t\tfileMenu.setText(\"File\");\n\t\t\tfileMenu.add(getExitMenuItem());\n\t\t}\n\t\treturn fileMenu;\n\t}\n",
    "121614": "\tprivate JMenu getHelpMenu() {\n\t\tif (helpMenu == null) {\n\t\t\thelpMenu = new JMenu();\n\t\t\thelpMenu.setText(\"Help\");\n\t\t\thelpMenu.add(getAboutMenuItem());\n\t\t}\n\t\treturn helpMenu;\n\t}\n",
    "121616": "\tprivate JMenuItem getExitMenuItem() {\n\t\tif (exitMenuItem == null) {\n\t\t\texitMenuItem = new JMenuItem();\n\t\t\texitMenuItem.setText(\"Exit\");\n\t\t\texitMenuItem.addActionListener(new ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn exitMenuItem;\n\t}\n",
    "121620": "\tprivate JMenuItem getAboutMenuItem() {\n\t\tif (aboutMenuItem == null) {\n\t\t\taboutMenuItem = new JMenuItem();\n\t\t\taboutMenuItem.setText(\"About\");\n\t\t\taboutMenuItem.addActionListener(new ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tJOptionPane\n\t\t\t\t\t\t\t.showMessageDialog(\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\"MPGCalculator \\n\\nBy Yann Laviolette, Stratag\ufffdme Ing\ufffdnierie Conseil\\n(c) 2005 - Under GPL Licence\",\n\t\t\t\t\t\t\t\t\t\"About\", JOptionPane.INFORMATION_MESSAGE);\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn aboutMenuItem;\n\t}\n",
    "121627": "\tprivate JTextField getTxtDistance() {\n\t\tif (txtDistance == null) {\n\t\t\ttxtDistance = new JTextField();\n\t\t\ttxtDistance.setPreferredSize(new java.awt.Dimension(10, 20));\n\t\t\ttxtDistance.setSize(new java.awt.Dimension(85, 20));\n\t\t\ttxtDistance.setHorizontalAlignment(javax.swing.JTextField.RIGHT);\n\t\t\ttxtDistance.setLocation(new java.awt.Point(100, 30));\n\t\t}\n\t\treturn txtDistance;\n\t}\n",
    "121629": "\tprivate JTextField getTxtConsumption() {\n\t\tif (txtConsumption == null) {\n\t\t\ttxtConsumption = new JTextField();\n\t\t\ttxtConsumption.setLocation(new java.awt.Point(100, 60));\n\t\t\ttxtConsumption.setHorizontalAlignment(javax.swing.JTextField.RIGHT);\n\t\t\ttxtConsumption.setSize(new java.awt.Dimension(85, 20));\n\t\t}\n\t\treturn txtConsumption;\n\t}\n",
    "121631": "\tprivate JComboBox getCboDistanceUnit() {\n\t\tif (cboDistanceUnit == null) {\n\t\t\tcboDistanceUnit = new JComboBox();\n\t\t\tcboDistanceUnit.setMaximumRowCount(2);\n\t\t\tcboDistanceUnit.setSize(new java.awt.Dimension(85, 20));\n\t\t\tcboDistanceUnit.setLocation(new java.awt.Point(200, 30));\n\t\t}\n\t\treturn cboDistanceUnit;\n\t}\n",
    "121633": "\tprivate JComboBox getCboConsumptionUnit() {\n\t\tif (cboConsumptionUnit == null) {\n\t\t\tcboConsumptionUnit = new JComboBox();\n\t\t\tcboConsumptionUnit.setLocation(new java.awt.Point(200, 60));\n\t\t\tcboConsumptionUnit.setSize(new java.awt.Dimension(85, 20));\n\t\t}\n\t\treturn cboConsumptionUnit;\n\t}\n",
    "121636": "\tprivate JButton getBttnCalculate() {\n\t\tif (bttnCalculate == null) {\n\t\t\tbttnCalculate = new JButton();\n\t\t\tbttnCalculate.setBounds(new java.awt.Rectangle(114, 113, 88, 23));\n\t\t\tbttnCalculate\n\t\t\t\t\t.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n\t\t\tbttnCalculate.setToolTipText(\"Calculates the consumption\");\n\t\t\tbttnCalculate.setText(\"Calculate\");\n\n\t\t\tbttnCalculate\n\t\t\t\t\t.addActionListener(new java.awt.event.ActionListener() {\n\t\t\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {\n\t\t\t\t\t\t\tcontroller.calculate(txtDistance.getText(),\n\t\t\t\t\t\t\t\t\t(String) cboDistanceUnit.getSelectedItem(),\n\t\t\t\t\t\t\t\t\ttxtConsumption.getText(),\n\t\t\t\t\t\t\t\t\t(String) cboConsumptionUnit\n\t\t\t\t\t\t\t\t\t\t\t.getSelectedItem());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\treturn bttnCalculate;\n\t}\n",
    "121639": "\tpublic double calculateMpgKmL(double distanceInKm, double numberOfLiters) {\n\t\tdouble distanceInMiles = distanceInKm * Constants.kmToMile;\n\t\tdouble numberOfGallons = numberOfLiters * Constants.lToGal;\n\n\t\treturn distanceInMiles / numberOfGallons;\n\n\t}\n",
    "121642": "\tpublic double calculateMpgKmGal(double distanceInKm, double numberOfGallons) {\n\t\tdouble distanceInMiles = distanceInKm * Constants.kmToMile;\n\t\treturn distanceInMiles / numberOfGallons;\n\t}\n",
    "121643": "  protected String writeType(String value, String type) {\n    if (type.matches(\"CHAR\\\\(\\\\d+\\\\).*\")\n        || type.matches(\"VARCHAR.*\")\n        || type.matches(\"BLOB.*\")) {\n      return \"'\" + value.trim().replaceAll(\"\\'\",\"\\\\'\") + \"'\";\n//      return \"STRING\";\n    } else {\n//      return type;\n      return value.trim();\n    }\n  }\n",
    "121645": "\tpublic double calculateMpgML(double distanceInMiles, double numberOfLiters) {\n\t\tdouble numberOfGallons = numberOfLiters * Constants.lToGal;\n\n\t\treturn distanceInMiles / numberOfGallons;\n\n\t}\n",
    "121648": "\tpublic double calculateL100KmKmL(double distanceInKm, double numberOfLiters) {\n\t\treturn (numberOfLiters * 100) / distanceInKm;\n\t}\n",
    "121661": "\tpublic void show() {\n\t\tdialog.show();\n\t}\n",
    "121663": "\tpublic void setCurrent(int aCurrent) {\n\t\tcurrent = aCurrent;\n\t}\n",
    "121664": "\tpublic int getCurrent() {\n\t\treturn current;\n\t}\n",
    "121665": "\tpublic boolean show() {\n\t\tdialog.pack();\n\t\tif (result) {\n\t\t\tmYes.getFocus();\n\t\t} else {\n\t\t\tmNo.getFocus();\n\t\t}\n\n\t\tdialog.show();\n\t\treturn result;\n\t}\n",
    "121666": "\tpublic void setDoCancel(ActionListener aDoCancel) {\n\t\tdoCancel = aDoCancel;\n\t}\n",
    "121670": "\tpublic void setMax(int aMax) {\n\t\tmax = aMax;\n\t}\n",
    "121673": "\tpublic int getMax() {\n\t\treturn max;\n\t}\n",
    "121675": "\tpublic void setMessage(String aMessage) {\n\t\tmessage = aMessage;\n\t\tif (msgLabel != null) {\n\t\t\tmsgLabel.setText(message);\n\t\t\twindow.pack();\n\t\t\t//window.show();\n\t\t}\n\t}\n",
    "121678": "\tpublic String getMessage() {\n\t\treturn message;\n\t}\n",
    "121682": "\tpublic void setMin(int aMin) {\n\t\tmin = aMin;\n\t}\n",
    "121685": "\tpublic int getMin() {\n\t\treturn min;\n\t}\n",
    "121687": "\tpublic void close() {\n\t\tif (window != null) {\n\t\t\twindow.close();\n\t\t}\n\t}\n",
    "121699": "\tpublic void setTitle(String aTitle) {\n\t\ttitle = aTitle;\n\t}\n",
    "121707": "\tpublic void setBackground(short background) {\n\t\tverifyColor(background);\n\t\t_background = background;\n\t\t//initChtype();\n\t}\n",
    "121714": "\tpublic void setBlackWhiteAttribute(short blackWhiteAttribute) {\n\t\t_blackWhiteAttribute = blackWhiteAttribute;\n\t}\n",
    "121722": "\tpublic void setColorAttribute(short colorAttribute) {\n\t\t_colorAttribute = colorAttribute;\n\t}\n",
    "121729": "\tpublic void setForeground(short foreground) {\n\t\tverifyColor(foreground);\n\t\t_foreground = foreground;\n\t\t//initChtype();\n\t}\n",
    "121732": "\tpublic short getForeground() {\n\t\treturn _foreground;\n\t}\n",
    "121735": "\tpublic String toString() {\n\t\tif (Toolkit.hasColors()) {\n\t\t\treturn \"[background=\" + getColorName(_background) + \", foreground=\" + getColorName(_foreground) + \"]\";\n\t\t}\n\n\t\treturn \"[modi=\" + getModusName(_blackWhiteAttribute) + \"]\";\n\t}\n",
    "121739": "\tprivate String getColorName(short index) {\n\t\tswitch (index) {\n\t\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\t\treturn \"BLACK\";\n\t\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\t\treturn \"WHITE\";\n\t\t\t\t\t\tcase GREEN:\n\t\t\t\t\t\t\treturn \"GREEN\";\n\t\t\t\t\t\tcase YELLOW:\n\t\t\t\t\t\t\treturn \"YELLOW\";\n\t\t\t\t\t\tcase MAGENTA:\n\t\t\t\t\t\t\treturn \"MAGENTA\";\n\t\t\t\t\t\tcase CYAN:\n\t\t\t\t\t\t\treturn \"CYAN\";\n\t\t\t\t\t\tcase BLUE:\n\t\t\t\t\t\t\treturn \"BLUE\";\n\t\t\t\t\t\tcase RED:\n\t\t\t\t\t\t\treturn \"RED\";\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn \"UNKNOWN COLOR\";\n\t\t}\n\t}\n",
    "121743": "\tpublic FileFilter generateFileFilter(String filterString) {\n\t\treturn new DefaultFileFilter(filterString);\n\t}\n",
    "121745": "\tprivate String getModusName(short index) {\n\t\tswitch (index) {\n\t\t\t\t\t\tcase NORMAL:\n\t\t\t\t\t\t\treturn \"NORMAL\";\n\t\t\t\t\t\tcase REVERSE:\n\t\t\t\t\t\t\treturn \"REVERSE\";\n\t\t\t\t\t\tcase BOLD:\n\t\t\t\t\t\t\treturn \"BOLD\";\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn \"UNKNOWN MODUS\";\n\t\t}\n\t}\n",
    "121751": "\tprivate void verifyAttribute(short attribute) {\n\t\tif ((attribute != NORMAL) && (attribute != REVERSE) && (attribute != BOLD)) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown color attribute:\" + attribute);\n\t\t}\n\t}\n",
    "121756": "\tprivate void verifyColor(short color) {\n\t\tif ((color != BLACK) && (color != RED) && (color != GREEN) && (color != YELLOW) && (color != BLUE) && (color != MAGENTA) && (color != CYAN)\n\t\t\t\t && (color != WHITE)) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown color:\" + color);\n\t\t}\n\t}\n",
    "121787": "\tpublic void setBorderColors(CharColor aColors) {\n\t\t_theme.setColor(Theme.COLOR_WINDOW_BORDER, aColors);\n\t\trepaint();\n\t}\n",
    "121793": "\tpublic CharColor getBorderColors() {\n\t\treturn _theme.getColor(Theme.COLOR_WINDOW_BORDER);\n\t}\n",
    "121806": "\tpublic void setClosingChar(InputChar character) {\n\t\t_closingChar = character;\n\t}\n",
    "121812": "\tpublic InputChar getClosingChar() {\n\t\treturn _closingChar;\n\t}\n",
    "121814": "\tpublic CharColor getDefaultBorderColors() {\n\t\treturn getTheme().getColor(Theme.COLOR_WINDOW_BORDER);\n\t}\n",
    "121817": "\tpublic CharColor getDefaultTitleColors() {\n\t\treturn getTheme().getColor(Theme.COLOR_WINDOW_TITLE);\n\t}\n",
    "121830": "\tpublic void setRootPanel(Panel root) {\n\t\t_root = root;\n\t\t_root.setWindow(this);\n\t\trepaint();\n\t}\n",
    "121831": "\tpublic void setSeparatorString(String value) {\n\t\t_separatorString = value;\n\t}\n",
    "121832": "\tpublic String getSeparatorString() {\n\t\treturn _separatorString;\n\t}\n",
    "121833": "\tpublic void addSeparator(int index) {\n\t\tadd(index, SEPARATOR);\n\t}\n",
    "121834": "\tpublic void addSeparator() {\n\t\taddSeparator(getItemsCount());\n\t}\n",
    "121836": "\tprotected String getItemRepresentation(String item) {\n\t\tif (item == SEPARATOR) {\n\t\t\treturn getSeparatorString();\n\t\t}\n\n\t\treturn item;\n\t}\n",
    "121838": "\tprotected Rectangle getPreferredSize() {\n\t\treturn new Rectangle(getMaxItemLength() + 2, getItemsCount() + 2);\n\t}\n",
    "121839": "\tpublic Panel getRootPanel() {\n\t\t//Ein kommentar\n\t\treturn _root;\n\t}\n",
    "121840": "\tprotected boolean isSelectable(int index) {\n\t\treturn (!(getItem(index) == SEPARATOR));\n\t}\n",
    "121841": "\tprotected boolean handleInput(InputChar ch) {\n\t\tif (!ch.equals(getChangeStatusChar())) {\n\t\t\treturn super.handleInput(ch);\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "121843": "\tprivate int getMaxItemLength() {\n\t\tint result = 0;\n\n\t\tfor (int i = 0; i < getItemsCount(); i++) {\n\t\t\tint length = getItemRepresentation((getItem(i))).length();\n\t\t\tresult = (length > result) ? length : result;\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "121847": "\tpublic void setShadow(boolean value) {\n\t\t_hasShadow = value;\n\t\trepaint();\n\t}\n",
    "121852": "\tpublic boolean hasShadow() {\n\t\treturn _hasShadow;\n\t}\n",
    "121858": "\tpublic void setTitleColors(CharColor aColors) {\n\t\t_theme.setColor(Theme.COLOR_WINDOW_TITLE, aColors);\n\t\trepaint();\n\t}\n",
    "121863": "\tpublic CharColor getTitleColors() {\n\t\treturn _theme.getColor(Theme.COLOR_WINDOW_TITLE);\n\t}\n",
    "121868": "\tpublic void setVisible(boolean aVisible) {\n\t\tif (aVisible != isVisible()) {\n\t\t\tif (aVisible) {\n\t\t\t\tshow();\n\t\t\t} else {\n\t\t\t\thide();\n\t\t\t}\n\t\t}\n\t}\n",
    "121875": "\tpublic boolean isVisible() {\n\t\treturn _visible;\n\t}\n",
    "121880": "\tpublic void addListener(WindowListener listener) {\n\t\t_listenerManager.addListener(listener);\n\t}\n",
    "121887": "\tpublic void close() {\n\t\thide();\n\t\t_closed = true;\n\t\tWindowManager.removeWindow(this);\n\t}\n",
    "121893": "\tpublic void hide() {\n\t\t_visible = false;\n\t\tWindowManager.doWindowVisibilityChange(this);\n\t}\n",
    "121895": "\tpublic CharColor getBorderColors() {\n\t\treturn _colors;\n\t}\n",
    "121896": "\tpublic void setBorderColors(CharColor colors) {\n\t\t_colors = colors;\n\t}\n",
    "121898": "\tprotected CharColor getDefaultBorderColors() {\n\t\treturn __defaultBorderColors;\n\t}\n",
    "121899": "\tprotected Rectangle getClientArea() {\n\t\tRectangle rect = (Rectangle) getSize().clone();\n\t\trect.setLocation(1, 1);\n\t\trect.setWidth(rect.getWidth() - 2);\n\t\trect.setHeight(rect.getHeight() - 2);\n\n\t\treturn rect;\n\t}\n",
    "121900": "\tpublic void moveToTheTop() {\n\t\tWindowManager.moveToTop(this);\n\t}\n",
    "121903": "\tpublic void pack() {\n\t\tcutIfNeeded();\n\t\tconfigureRootPanel();\n\t\t_root.pack();\n\t\tloadFocusableChilds();\n\t\tloadShortcuts();\n\t}\n",
    "121908": "\tpublic void removeListener(WindowListener listener) {\n\t\t_listenerManager.removeListener(listener);\n\t}\n",
    "121911": "\tpublic void show() {\n\t\tif (!isVisible()) {\n\t\t\tWindowManager.createWindow(this);\n\t\t\tpack();\n\t\t\t_visible = true;\n\t\t\tWindowManager.doWindowVisibilityChange(this);\n\t\t}\n\t}\n",
    "121919": "\tprotected Rectangle getRectangle() {\n\t\treturn _rect;\n\t}\n",
    "121922": "\tprotected Rectangle getClipRectangle() {\n\t\tif (hasShadow()) {\n\t\t\treturn new Rectangle(_rect.getX(), _rect.getY(), _rect.getWidth() + 1, _rect.getHeight() + 1);\n\t\t}\n\n\t\treturn _rect;\n\t}\n",
    "121925": "\tprotected void activate() {\n\t\t_listenerManager.handleEvent(new WindowEvent(this, WindowEvent.ACTIVATED));\n\t}\n",
    "121928": "\tprotected void changeFocus(int aWidgetIndex) {\n\t\tif (aWidgetIndex != _currentIndex) {\n\t\t\tif (isFocusableIndex(_currentIndex)) {\n\t\t\t\t((Widget) _focusableChildren.get(_currentIndex)).setFocus(false);\n\t\t\t}\n\n\t\t\t_currentIndex = aWidgetIndex;\n\n\t\t\tif (isFocusableIndex(aWidgetIndex)) {\n\t\t\t\t((Widget) _focusableChildren.get(aWidgetIndex)).setFocus(true);\n\t\t\t}\n\t\t}\n\t}\n",
    "121931": "\tprotected void changeFocus(Widget aWidget) {\n\t\tchangeFocus(_focusableChildren.indexOf(aWidget));\n\t}\n",
    "121935": "\tprotected void changeFocus() {\n\t\t//changeFocus(Math.min(Math.max(0, _currentIndex + 1), _focusableChildren.size() - 1));\n\t\tif (_currentIndex >= _focusableChildren.size() - 1 || _currentIndex < -1) {\n\t\t\tchangeFocus(0);\n\t\t} else {\n\t\t\tchangeFocus(_currentIndex + 1);\n\t\t}\n\t}\n",
    "121943": "\tprotected void closed() {\n\t\t_closed = true;\n\t\t_listenerManager.handleEvent(new WindowEvent(this, WindowEvent.CLOSED));\n\t}\n",
    "121948": "\tprotected void deactivate() {\n\t\t_listenerManager.handleEvent(new WindowEvent(this, WindowEvent.DEACTIVATED));\n\t}\n",
    "121967": "\tprotected void paint() {\n\t\tdrawThingsIfNeeded();\n\t\t_root.paint();\n\t}\n",
    "121986": "\tprotected void resize(int width, int height) {\n\t\t_rect.setWidth(width);\n\t\t_rect.setHeight(height);\n\t}\n",
    "121994": "\tprivate Widget getCurrentWidget() {\n\t\tif (isFocusableIndex(_currentIndex)) {\n\t\t\treturn ((Widget) _focusableChildren.elementAt(_currentIndex));\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "121999": "\tprivate InputChar getDefaultClosingChar() {\n\t\treturn __defaultClosingChar;\n\t}\n",
    "122003": "\tprivate InputChar getDefaultFocusChangeChar() {\n\t\treturn __defaultFocusChangeChar;\n\t}\n",
    "122009": "\tprivate boolean isFocusableIndex(int aIdx) {\n\t\treturn (aIdx >= 0) && (aIdx < _focusableChildren.size());\n\t}\n",
    "122010": "\tpublic String getText() {\n\t\treturn _label;\n\t}\n",
    "122011": "\tpublic void setText(String aText) {\n\t\t_label = aText;\n\t\tif (_label == null) {\n\t\t\t_label = \"\";\n\t\t}\n\t}\n",
    "122012": "\tprotected Rectangle getPreferredSize() {\n\t\tString[] mLines = TextUtils.wrapLines(_label, Integer.MAX_VALUE);\n\n\t\tint mWide = 0;\n\t\tfor (int mIdx = 0; mIdx < mLines.length; mIdx++) {\n\t\t\tmWide = Math.max(mWide, mLines[mIdx].length());\n\t\t}\n\n\t\treturn new Rectangle(mWide, mLines.length);\n\t}\n",
    "122013": "\tprotected void doPaint() {\n\t\tToolkit.printString(_label, getRectangle(), getColors());\n\t}\n",
    "122015": "    public void setLabel(String aLabel) {\n        _label = aLabel;\n    }\n",
    "122018": "\tprivate boolean isShortCut(InputChar inp) {\n\t\treturn (_shortCutsList.indexOf(inp) != -1);\n\t}\n",
    "122023": "    public void setShortCutColors(CharColor aColor) {\n        setColors(Theme.COLOR_WIDGET_SHORTCUT, aColor);\n    }\n",
    "122024": "    public void addListener(ActionListener listener) {\n        _listenerManager.addListener(listener);\n    }\n",
    "122026": "\tprivate Widget getWidgetByShortCut(InputChar inp) {\n\t\treturn (Widget) _shortCutsTable.get(inp);\n\t}\n",
    "122027": "    public void removeListener(ActionListener listener) {\n        _listenerManager.removeListener(listener);\n    }\n",
    "122028": "    public void setShortCut(char c) {\n        _shortCut = new InputChar(c);\n    }\n",
    "122029": "    protected Rectangle getPreferredSize() {\n        return new Rectangle(_label.length() + 4, 1);\n    }\n",
    "122032": "    protected Vector getShortCutsList() {\n        if (getShortCut() == null) {\n            return null;\n        }\n        Vector result = new Vector();\n        result.add(getShortCut());\n        return result;\n    }\n",
    "122033": "\tprivate void configureRootPanel() {\n\t\tif (_root == null) {\n\t\t\t_root = new Panel();\n\t\t}\n\n\t\tint x = _rect.getX();\n\t\tint y = _rect.getY();\n\t\tint width = _rect.getWidth();\n\t\tint height = _rect.getHeight();\n\n\t\tif (_border) {\n\t\t\tx++;\n\t\t\ty++;\n\t\t\twidth -= 2;\n\t\t\theight -= 2;\n\t\t}\n\n\t\t_root.setSize(new Rectangle(width, height));\n\t\t_root.setX(x);\n\t\t_root.setY(y);\n\t}\n",
    "122034": "    protected boolean isFocusable() {\n        return true;\n    }\n",
    "122035": "    protected boolean handleInput(InputChar ch) {\n        if ((ch.equals(__actionChar)) || ((getShortCut() != null) && (getShortCut().equals(ch)))) {\n            doAction();\n            return true;\n        }\n\n        return false;\n    }\n",
    "122036": "    protected void focus() {\n        doPaint();\n    }\n",
    "122038": "    protected void unfocus() {\n        doPaint();\n    }\n",
    "122039": "    private InputChar getShortCut() {\n        return _shortCut;\n    }\n",
    "122041": "    private void drawShortCutIfNeeded() {\n        InputChar shortCut = getShortCut();\n        if (shortCut != null) {\n            String c = shortCut.toString();\n            if (_label != null) {\n                int index = _label.toLowerCase().indexOf(c.toLowerCase());\n                if (index != - 1) {\n                    Toolkit.printString(_label.substring(index, index + 1), getAbsoluteX() + index + 2, getAbsoluteY(), getShortCutColors());\n\n                }\n            }\n        }\n    }\n",
    "122042": "    private void doAction() {\n        _listenerManager.handleEvent(new ActionEvent(this));\n    }\n",
    "122048": "\tprivate void drawThingsIfNeeded() {\n\t\tif (_border) {\n\t\t\tToolkit.drawBorder(_rect, getBorderColors());\n\t\t}\n\n\t\tpaintTitle();\n\t}\n",
    "122057": "\tprivate void loadFocusableChilds() {\n\t\t_focusableChildren = _root.getListOfFocusables();\n\t\tif (!isFocusableIndex(_currentIndex)) {\n\t\t\tchangeFocus();\n\t\t}\n\t}\n",
    "122063": "\tprivate void loadShortcuts() {\n\t\t_shortCutsList.clear();\n\t\t_shortCutsTable.clear();\n\n\t\tVector list = _root.getListOfWidgetsWithShortCuts();\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tWidget widget = (Widget) list.elementAt(i);\n\t\t\tVector shortCuts = widget.getShortCutsList();\n\t\t\t_shortCutsList.addAll(shortCuts);\n\n\t\t\tfor (int j = 0; j < shortCuts.size(); j++) {\n\t\t\t\t_shortCutsTable.put(shortCuts.elementAt(j), widget);\n\t\t\t}\n\t\t}\n\t}\n",
    "122067": "\tprivate void paintTitle() {\n\t\tif (_title != null) {\n\t\t\tToolkit.printString(_title, _rect.getX() + ((_rect.getWidth() - _title.length()) / 2), _rect.getY(), getTitleColors());\n\t\t}\n\t}\n",
    "122076": "\tpublic void setTitle(String aTitle) {\n\t\t_title = aTitle;\n\t\trepaint();\n\t}\n",
    "122080": "\tpublic int compare(Object obj1, Object obj2) {\n\t\tif (obj1 instanceof Widget && obj2 instanceof Widget) {\n\t\t\tWidget widget1 = (Widget) obj1;\n\t\t\tWidget widget2 = (Widget) obj2;\n\n\t\t\tif (isBelow(widget1, widget2)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (isAbove(widget1, widget2) || isLeft(widget1, widget2)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (isRight(widget1, widget2)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn obj2.hashCode() - obj1.hashCode();\n\t}\n",
    "122096": "   public int getPageOffset(int index) {\n\t   return index-getPageStartIndex(getPageNumber(index));\n   }\n",
    "122256": "    public void ejbCreate() {\n        objectkeyHome = lookupObjectkeyBean();\n    }\n",
    "122309": "    public void ejbCreate() {\n        objectKeyFacade = lookupObjectkeyFacadeBean();\n        projectHome = lookupProjectBean();\n        taskHome = lookupTaskBean();\n        usercommentsHome = lookupUsercommentsBean();\n    }\n",
    "122333": "    public void ejbCreate() {\n        objectKeyFacade = lookupObjectkeyFacadeBean();\n        accountHome = lookupAccountBean();\n    }\n",
    "122380": "    public void switchState() {\n        if (state == CCW) {\n            state = CW;\n        } else {\n            state = CCW;\n        }\n    }\n",
    "122407": "    public double getOccupancy(String state) {\n        double ligand = getLigandConcentration();\n        return ligand / (getDissociationConstant(state) + ligand);\n    }\n",
    "122426": "    public Concentration getConcentration(double volume) {\n        return new Concentration(this.getMolecularType(),\n            level / (volume * Molecule.AVOGADRO));\n    }\n",
    "122505": "    public void setRngSeed(long seed) {\n    }\n",
    "122532": "    private void applyGramSchmidtIfNecessary() {\n        rotationsCount++;\n\n        if (!this.isOrthogonal()) {\n            // TODO: generate an error (RotationMatrixNotOrthogonalError). This should be done in RotationMatrix.\n            System.out.println(\"WARNING: Orientation not orthogonal after \" +\n                rotationsCount + \" rotations. \" +\n                \"Consider decreasing the rotationsCountThreshold. (See tests in OrientationTest.java)\");\n        }\n\n        if (rotationsCount >= rotationsCountThreshold) {\n            this.gramSchmidt();\n            rotationsCount = 0;\n        }\n    }\n",
    "122539": "\tpublic void updateReceptorsDynamicValues() {\n\t\tCollection c = cell.getReceptors().getDissociationConstants().keySet();\n\t\tIterator i = c.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tString s = (String) i.next();\n\t\t\tthis.setDynamicValue(s, cell.getReceptors().getOccupancy(s));\n\t\t}\n\t}\n",
    "122760": "    public void switchState() {\n        if (state == BUNDLED) {\n            state = APART;\n        } else {\n            state = BUNDLED;\n        }\n    }\n",
    "122776": "  public void setModel(SimModel model) {\n    this.model = model;\n    if (model != null) {\n      model.setup();\n    }\n  }\n",
    "122783": "  public SimModel getModel() {\n    return this.model;\n  }\n",
    "122788": "  public int getCellWidth() {\n    return DisplayConstants.CELL_WIDTH;\n  }\n",
    "122793": "  public void setCellWidth(int cellSize) {\n    if (runThread == null)\n      DisplayConstants.CELL_WIDTH = cellSize;\n  }\n",
    "122797": "  public int getCellHeight() {\n    return DisplayConstants.CELL_HEIGHT;\n  }\n",
    "122801": "  public void setCellHeight(int cellSize) {\n    if (runThread == null)\n      DisplayConstants.CELL_HEIGHT = cellSize;\n  }\n",
    "122806": "  public int getCellDepth() {\n    return DisplayConstants.CELL_DEPTH;\n  }\n",
    "122811": "  public void setCellDepth(int cellSize) {\n    if (runThread == null)\n      DisplayConstants.CELL_DEPTH = cellSize;\n  }\n",
    "122813": "    @Test public void testPCall() {\n        PCall call = new PCall() {\n            public void runCode() {\n                setName(CompSettings.getDateString());\n            }\n\n            public Engine engine() {\n                return null; // EngineTypes.GRTE.getEngine();\n            }\n\n            public void finalCode() {\n                log.info(this + \" OK\");\n            }\n        };\n        call.execute();\n        call.execute();\n        call.execute();\n        QueuedExecutor exec = (QueuedExecutor) call.getExecutor();\n        try {\n            Thread.sleep(1000);\n            exec.shutdownNow();\n            Thread.sleep(600);\n        } catch (InterruptedException e) {\n            log.error(\"\", e);\n        }\n        // EngineTypes.GRTE.getEngine().shutdown();\n    }\n",
    "122818": "  public void setSchedule(Schedule schedule) {\n    this.schedule = schedule;\n    setupSchedule();\n  }\n",
    "122822": "  public Schedule getSchedule() {\n    return schedule;\n  }\n",
    "122824": "  public long getCurrentTime() {\n\n    return (long) time; // + timeMod);\n  }\n",
    "122828": "  public double getCurrentTimeDouble() {\n\n    return time; // + timeMod;\n  }\n",
    "122830": "    @Test public void testCalc() {\n\n        CalcEngine parser = new CalcEngine();\n        parser.putVariable(\"s\", new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n        double[] res;\n        try {\n\n            parser.parseString(\"d=trend(100);\");\n            res = parser.getVariable(\"D\");\n            Assert.assertEquals(res[99], 100, 0);\n\n            parser.parseString(\"d = s+2\");\n            res = parser.getVariable(\"D\");\n            Assert.assertEquals(res[3], 6, 0);\n\n            parser.parseString(\"d = s|1;A= log  (d )\");\n            res = parser.getVariable(\"a\");\n            Assert.assertEquals(res[9], 0, 0);\n\n        } catch (ParseException ex) {\n            throw new RuntimeException(ex.toString());\n        }\n\n    }\n",
    "122831": "  public void setRandomSeed(long seed) {\n    model.setRngSeed(seed);\n  }\n",
    "122833": "    @Test public void testTypes() {\n        Assert.assertEquals(TSTypes.valueOf(\"DETERMINISTIC\"), TSTypes.DETERMINISTIC);\n        Assert.assertEquals(TSTypes.valueOf(\"dETERMINISTIc\"), TSTypes.DETERMINISTIC);\n        Assert.assertEquals(TSTypes.valueOf(\"ENDOGENOUS\"), TSTypes.ENDOGENOUS);\n        Assert.assertEquals(TSTypes.valueOf(\"eNDOGEnOUS\"), TSTypes.ENDOGENOUS);\n        Assert.assertEquals(TSTypes.valueOf(\"EXOGENOUS\"), TSTypes.EXOGENOUS);\n        Assert.assertEquals(TSTypes.valueOf(\"EXOgENOUs\"), TSTypes.EXOGENOUS);\n    }\n",
    "122835": "  public long getRandomSeed() {\n    return model.getRngSeed();\n  }\n",
    "122841": "  public void startSim() {\n    // necessary to make pauseAt persist over the course of\n    // several runs.\n    setPauseAt(pauseAt);\n\n    fireSimEvent(new SimEvent(this, SimEvent.START_EVENT));\n\n    if (runThread == null) {\n      if (executeBegin) beginModel();\n      schedule = model.getSchedule();\n      setupSchedule();\n    }\n    if (schedule == null) {\n      SimUtilities.showMessage(\"No schedule to run\");\n      System.exit(0);\n    } else if (!go) {\n      go = true;\n      pauseSim = false;\n      doStep = false;\n      if (runThread == null) {\n        runThread = new Thread(simRun);\n        runThread.start();\n      }\n    } else if (go) {\n      pauseSim = false;\n      doStep = false;\n      notifyMonitor();\n    }\n  }\n",
    "122844": "  protected void notifyMonitor() {\n    synchronized (monitor) {\n      monitor.notify();\n    }\n  }\n",
    "122853": "  public Hashtable getModelParameters() {\n    Hashtable props = new Hashtable(23);\n    if (model != null) {\n      model.clearPropertyListeners();\n      try {\n        props = ParameterUtility.getModelProperties(model);\n      } catch (Exception ex) {\n        SimUtilities.showError(\"Error retrieving model properties\", ex);\n        System.exit(0);\n      }\n    }\n\n    return props;\n  }\n",
    "122859": "  public void pauseSim() {\n    pauseSim = true;\n  }\n",
    "122863": "  public void stopSim() {\n    go = false;\n    doStep = false;\n    pauseSim = false;\n    notifyMonitor();\n  }\n",
    "122864": "    @Test public void testTSEquals() {\n\n        double[] newObs = new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        TSDate date = new TSDate(1960.1, 4);\n        TS ts1 = new TS(newObs, \"test_series\", date);\n        TS ts2 = new TS(newObs, \"test_series\", date);\n\n        Assert.assertEquals(ts1, ts2);\n        Assert.assertEquals(ts2, ts1);\n\n        Assert.assertEquals(ts1.hashCode(), ts2.hashCode());\n\n    }\n",
    "122865": "  public boolean isBatch() {\n    return false;\n  }\n",
    "122869": "  public void addSimEventListener(SimEventListener l) {\n    listenerList.add(l);\n  }\n",
    "122870": "  public void removeSimEventListener(SimEventListener l) {\n    listenerList.remove(l);\n  }\n",
    "122874": "  public void fireSimEvent(SimEvent evt) {\n    ArrayList copy;\n    synchronized(listenerList) {\n      copy = (ArrayList)listenerList.clone();\n    }\n\n    for (int i = 0, n = copy.size(); i < n; i++) {\n      SimEventListener l = (SimEventListener)copy.get(i);\n      l.simEventPerformed(evt);\n    }\n  }\n",
    "122876": "  public void putPersistentObj(Object key, Object val) {\n    persistentObj.put(key, val);\n  }\n",
    "122880": "  public Object getPersistentObj(Object key) {\n    return persistentObj.get(key);\n  }\n",
    "122943": "    @Test public void testJHelpContextMgr() {\n        File file = new File(\"testdata/\" + JHelpContextMgr.helpIDFile);\n        JHelpContextMgr newMgr = null;\n\n        ObjectReader constructor = new ObjectReader();\n\n        try {\n            newMgr = (JHelpContextMgr) constructor.read(new FileInputStream(\n                    file));\n\n        } catch (Throwable t) {\n            log.error(\"Error in XML deserialization\", t);\n        }\n        Assert.assertEquals(newMgr.getID(\"com.jstatcom.io.TSImportPanel\"),\n                \"jstatcom.impdata\");\n        JHelpContextMgr.register(new JPanel());\n    }\n",
    "122991": "    private void decreaseCapacity() {\n        if (_size >= _capacity - C0)\n            throw new IllegalStateException();\n        final int c = _capacity;\n        _capacity -= C0;\n        if (c < C1) {\n            _elems1[(c >> R1)] = null;\n            _elems2 = null;\n            _elems3 = null;\n        } else if (c < C2) {\n            _elems2[(c >> R2)][(c >> R1) & M1] = null;\n            _elems3 = null;\n        } else {\n            _elems3[(c >> R3)][(c >> R2) & M2][(c >> R1) & M1] = null;\n        }\n    }\n",
    "122997": "    public int hashCode() {\n        final FastComparator comp = this.getValueComparator();\n        int h = 1;\n        for (Node n = _head, end = _tail; (n = n._next) != end;) {\n            h = 31 * h + comp.hashCodeOf(n._value);\n        }\n        return h;\n    }\n",
    "123095": "    public void lock() {\n        Thread caller = Thread.currentThread();\n        synchronized (this) {\n            if (caller == _owner) {\n                _count++;\n            } else {\n                try {\n                    while (_owner != null) {\n                        this.wait();\n                    }\n                    _owner = caller;\n                    _count = 1;\n                } catch (InterruptedException exception) {\n                    return;\n                }\n            }\n        }\n    }\n",
    "123097": "    public boolean tryLock() {\n        synchronized (this) {\n            if (_owner == null) {\n                lock();\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n",
    "123098": "    public void unlock() {\n        synchronized (this) {\n            if (Thread.currentThread() == _owner) {\n                if (--_count == 0) {\n                    _owner = null;\n                    this.notify();\n                }\n            } else {\n                throw new IllegalMonitorStateException(\n                        \"Current thread does not hold this lock\");\n            }\n        }\n    }\n",
    "123099": "    public Thread getOwner() {\n        synchronized (this) {\n            return _owner;\n        }\n    }\n",
    "123114": "    public FastComparator getValueComparator() {\n        return _valueComp;\n    }\n",
    "123115": "    public boolean add( E value) {\n        throw new UnsupportedOperationException();\n    }\n",
    "123117": "    public boolean remove(Object value) {\n        final FastComparator valueComp = this.getValueComparator();\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            if (valueComp.areEqual(value, valueOf(r))) {\n                delete(r);\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "123118": "    public void clear() {\n        // Removes last record until empty.\n        for (Record head = head(), r = tail().getPrevious(); r != head; r = r\n                .getPrevious()) {\n            delete(r);\n        }\n    }\n",
    "123120": "    public boolean isShared() {\n        return _isShared;\n    }\n",
    "123121": "    public boolean contains(Object value) {\n        final FastComparator valueComp = this.getValueComparator();\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            if (valueComp.areEqual(value, valueOf(r)))\n                return true;\n        }\n        return false;\n    }\n",
    "123123": "    public boolean addAll(Collection <? extends E> c) {\n        if (c instanceof FastCollection)\n            return addAll((FastCollection) c);\n        boolean modified = false;\n        Iterator <? extends E> itr = c.iterator();\n        int pos = c.size();\n        while (--pos >= 0) {\n            if (add(itr.next())) {\n                modified = true;\n            }\n        }\n        return modified;\n    }\n",
    "123125": "    public FastComparator getKeyComparator() {\n        return _keyComparator;\n    }\n",
    "123126": "    public boolean containsAll(Collection <?> c) {\n        if (c instanceof FastCollection)\n            return containsAll((FastCollection) c);\n        Iterator <?> itr = c.iterator();\n        int pos = c.size();\n        while (--pos >= 0) {\n            if (!contains(itr.next())) {\n                return false;\n            }\n        }\n        return true;\n    }\n",
    "123129": "    public FastComparator getValueComparator() {\n        return _values.getValueComparator();\n    }\n",
    "123132": "    public boolean removeAll(Collection <?> c) {\n        boolean modified = false;\n        // Iterates from the tail and removes the record if present in c. \n        for (Record head = head(), r = tail().getPrevious(), previous; r != head; r = previous) {\n            previous = r.getPrevious(); // Saves previous.\n            if (c.contains(valueOf(r))) {\n                delete(r);\n                modified = true;\n            }\n        }\n        return modified;\n    }\n",
    "123133": "    public boolean retainAll(Collection <?> c) {\n        boolean modified = false;\n        // Iterates from the tail and remove the record if not present in c. \n        for (Record head = head(), r = tail().getPrevious(), previous; r != head; r = previous) {\n            previous = r.getPrevious(); // Saves previous.\n            if (!c.contains(valueOf(r))) {\n                delete(r);\n                modified = true;\n            }\n        }\n        return modified;\n    }\n",
    "123134": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        } else if (obj instanceof Map) {\n            Map <?,?> that = (Map) obj;\n            if (this.size() == that.size()) {\n                final Set thatEntrySet = that.entrySet();\n                for (Entry e = _head, end = _tail; (e = e._next) != end;) {\n                    if (!thatEntrySet.contains(e)) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n",
    "123135": "    public Text toText() {\n        final Text sep = Text.valueOf(\", \");\n        Text text = Text.valueOf('[');\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            text = text.concat(Text.valueOf(valueOf(r)));\n            if (r.getNext() != end) {\n                text = text.concat(sep);\n            }\n        }\n        return text.concat(Text.valueOf(']'));\n    }\n",
    "123137": "    public boolean equals(Object obj) {\n        if (this instanceof List)\n            return equalsList(obj);\n        return obj == this\n                || (obj instanceof Collection\n                        && ((Collection) obj).size() == size() && containsAll((Collection) obj));\n    }\n",
    "123138": "    public int hashCode() {\n        int code = 0;\n        for (Entry e = _head, end = _tail; (e = e._next) != end;) {\n            code += e.hashCode();\n        }\n        return code;\n    }\n",
    "123141": "    public int hashCode() {\n        if (this instanceof List)\n            return hashCodeList();\n        final FastComparator valueComp = this.getValueComparator();\n        int hash = 0;\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            hash += valueComp.hashCodeOf(valueOf(r));\n        }\n        return hash;\n    }\n",
    "123144": "    public Text toText() {\n        return _entrySet.toText();\n    }\n",
    "123199": "    public  V putDefault( K key,  V defaultValue) {\n        return ( V ) ((FastMap) _mapRef.getDefault()).put(key,\n                defaultValue);\n    }\n",
    "123200": "    public int size() {\n        return ((FastMap) _mapRef.get()).size();\n    }\n",
    "123202": "    public boolean isEmpty() {\n        return ((FastMap) _mapRef.get()).isEmpty();\n    }\n",
    "123203": "    public boolean containsKey(Object key) {\n        return ((FastMap) _mapRef.get()).containsKey(key);\n    }\n",
    "123204": "    public boolean containsValue(Object value) {\n        return ((FastMap) _mapRef.get()).containsValue(value);\n    }\n",
    "123205": "    public  V get(Object key) {\n        return ( V ) ((FastMap) _mapRef.get()).get(key);\n    }\n",
    "123206": "    public  V put( K key,  V value) {\n        return ( V ) localMap().put(key, value);\n    }\n",
    "123207": "    public void putAll(Map <? extends K, ? extends V> map) {\n        localMap().putAll(map);\n    }\n",
    "123209": "    public  V remove(Object key) {\n        return put(( K )key, null);\n    }\n",
    "123211": "    public void clear() {\n        FastMap localMap = localMap();\n        for (FastMap.Entry e = localMap.head(), end = localMap.tail(); (e = (FastMap.Entry) e.getNext()) != end;) {\n            e.setValue(null);\n        }\n    }\n",
    "123245": "\tpublic int read(InputStream in) throws IOException {\n\t\tByteBuffer buffer = getByteBuffer();\n\t\tif (buffer.hasArray()) {\n\t\t\tint offset = buffer.arrayOffset() + getByteBufferPosition();\n\t\t\treturn in.read(buffer.array(), offset, size());\n\t\t} else {\n\t\t\tsynchronized (buffer) {\n\t\t\t\tif (_bytes == null) {\n\t\t\t\t\t_bytes = new byte[size()];\n\t\t\t\t}\n\t\t\t\tint bytesRead = in.read(_bytes);\n\t\t\t\tbuffer.position(getByteBufferPosition());\n\t\t\t\tbuffer.put(_bytes);\n\t\t\t\treturn bytesRead;\n\t\t\t}\n\t\t}\n\t}\n",
    "123247": "\tpublic void write(OutputStream out) throws IOException {\n\t\tByteBuffer buffer = getByteBuffer();\n\t\tif (buffer.hasArray()) {\n\t\t\tint offset = buffer.arrayOffset() + getByteBufferPosition();\n\t\t\tout.write(buffer.array(), offset, size());\n\t\t} else {\n\t\t\tsynchronized (buffer) {\n\t\t\t\tif (_bytes == null) {\n\t\t\t\t\t_bytes = new byte[size()];\n\t\t\t\t}\n\t\t\t\tbuffer.position(getByteBufferPosition());\n\t\t\t\tbuffer.get(_bytes);\n\t\t\t\tout.write(_bytes);\n\t\t\t}\n\t\t}\n\t}\n",
    "123249": "\tpublic String toString() {\n\t\tfinal int size = size();\n\t\tStringBuffer sb = new StringBuffer(size * 3);\n\t\tfinal ByteBuffer buffer = getByteBuffer();\n\t\tfinal int start = getByteBufferPosition();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tint b = buffer.get(start + i) & 0xFF;\n\t\t\tsb.append(HEXA[b >> 4]);\n\t\t\tsb.append(HEXA[b & 0xF]);\n\t\t\tsb.append(((i & 0xF) == 0xF) ? '\\n' : ' ');\n\t\t}\n\t\treturn sb.toString();\n\t}\n",
    "123255": "\tpublic boolean isUnion() {\n\t\treturn false;\n\t}\n",
    "123260": "\tpublic ByteOrder byteOrder() {\n\t\treturn (_outer != null) ? _outer.byteOrder() : ByteOrder.BIG_ENDIAN;\n\t}\n",
    "123266": "    private void addEntry(int hash,  K key,  V value) {\n        // Updates size.\n        if ((_size++ >> R0) >= _entries.length) { // Check if entry table too small. \n            increaseEntryTable();\n        }\n\n        if (_tail._next == null) {\n            increaseCapacity();\n        }\n        final Entry newTail = _tail._next;\n        // Setups entry parameters.\n        _tail._key = key;\n        _tail._value = value;\n        _tail._keyHash = hash;\n        _tail._table = _entries;\n\n        // Connects to bucket.\n        final int index = (hash >> R0) & (_entries.length - 1);\n        Entry[] tmp = _entries[index];\n        if (tmp == NULL_BLOCK) {\n            newBlock(index);\n            tmp = _entries[index];\n        }\n        Entry beside = tmp[hash & M0];\n        _tail._beside = beside;\n        tmp[hash & M0] = _tail;\n\n        // Moves tail forward.\n        _tail = newTail;\n    }\n",
    "123268": "\tpublic boolean isPacked() {\n\t\treturn (_outer != null) ? _outer.isPacked() : false;\n\t}\n",
    "123298": "    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.writeInt(_size);\n        stream.writeInt(_entries.length);\n\n        stream.writeBoolean(_isShared);\n        stream.writeObject(_keyComparator);\n        stream.writeObject(_values.getValueComparator());\n\n        for (Entry e = _head, end = _tail; (e = e._next) != end;) {\n            stream.writeObject(e._key);\n            stream.writeObject(e._value);\n        }\n    }\n",
    "123301": "    @Test public void testJSCSArray2() {\n\n        JSCSArray sArray = new JSCSArray(\"test\");\n\n        String[][] test = new String[5][5];\n        test[2][3] = \"1.345e-20\";\n        test[1][1] = \"Double.NaN\";\n        test[2][4] = \"Double.POSITIVE_INFINITY\";\n        test[1][3] = \"-1233433\";\n\n        sArray = new JSCSArray(\"test\", test);\n        Assert.assertEquals(sArray.isEqual(sArray.copy()), true);\n        Assert.assertEquals(UStringArray.compareStringArrays(sArray.stringArray(),\n                test), true);\n\n    }\n",
    "123302": "        public boolean equals(Object that) {\n            if (that instanceof Map.Entry) {\n                Map.Entry entry = (Map.Entry) that;\n                return _key.equals(entry.getKey())\n                        && ((_value != null) ? _value.equals(entry.getValue())\n                                : (entry.getValue() == null));\n            } else {\n                return false;\n            }\n        }\n",
    "123305": "        public int hashCode() {\n            return _key.hashCode() ^ ((_value != null) ? _value.hashCode() : 0);\n        }\n",
    "123308": "    @Test public void testJSCSArray3() {\n\n        String[][] test = new String[5][5];\n        test[2][3] = \"1.345e-20\";\n        test[1][1] = \"Double.NaN\";\n        test[2][4] = \"Double.POSITIVE_INFINITY\";\n        test[1][3] = \"-1233433\";\n        JSCSArray sArray = new JSCSArray(\"test\", test);\n\n        Assert.assertEquals(sArray.stringAt(0, 0), null);\n        Assert.assertEquals(sArray.stringAt(2, 3), \"1.345e-20\");\n\n    }\n",
    "123355": "    public Utf8ByteBufferWriter setByteBuffer(ByteBuffer byteBuffer) {\n        if (_byteBuffer != null)\n            throw new IllegalStateException(\"Writer not closed or reset\");\n        _byteBuffer = byteBuffer;\n        return this;\n    }\n",
    "123356": "    public void write(char c) throws IOException {\n        if ((c < 0xd800) || (c > 0xdfff)) {\n            write((int) c);\n        } else if (c < 0xdc00) { // High surrogate.\n            _highSurrogate = c;\n        } else { // Low surrogate.\n            int code = ((_highSurrogate - 0xd800) << 10) + (c - 0xdc00)\n                    + 0x10000;\n            write(code);\n        }\n    }\n",
    "123357": "    public void write(int code) throws IOException {\n        if ((code & 0xffffff80) == 0) {\n            _byteBuffer.put((byte) code);\n        } else { // Writes more than one byte.\n            write2(code);\n        }\n    }\n",
    "123360": "    public void write(char cbuf[], int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = cbuf[i++];\n            if (c < 0x80) {\n                _byteBuffer.put((byte) c);\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123361": "    public void write(String str, int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = str.charAt(i++);\n            if (c < 0x80) {\n                _byteBuffer.put((byte) c);\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123362": "    public void write(CharSequence csq) throws IOException {\n        final int length = csq.length();\n        for (int i = 0; i < length;) {\n            char c = csq.charAt(i++);\n            if (c < 0x80) {\n                _byteBuffer.put((byte) c);\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123363": "    public void flush() throws IOException {\n        if (_byteBuffer == null) {\n            throw new IOException(\"Writer closed\");\n        }\n    }\n",
    "123367": "    public Utf8ByteBufferReader setByteBuffer(ByteBuffer byteBuffer) {\n        if (_byteBuffer != null)\n            throw new IllegalStateException(\"Reader not closed or reset\");\n        _byteBuffer = byteBuffer;\n        return this;\n    }\n",
    "123368": "    public boolean ready() throws IOException {\n        if (_byteBuffer != null) {\n            return _byteBuffer.hasRemaining();\n        } else {\n            throw new IOException(\"Reader closed\");\n        }\n    }\n",
    "123370": "    public int read() throws IOException {\n        if (_byteBuffer != null) {\n            if (_byteBuffer.hasRemaining()) {\n                byte b = _byteBuffer.get();\n                return (b >= 0) ? b : read2(b);\n            } else {\n                return -1;\n            }\n        } else {\n            throw new IOException(\"Reader closed\");\n        }\n    }\n",
    "123374": "    public void read(Appendable dest) throws IOException {\n        if (_byteBuffer == null)\n            throw new IOException(\"Reader closed\");\n        while (_byteBuffer.hasRemaining()) {\n            byte b = _byteBuffer.get();\n            if (b >= 0) {\n                dest.append((char) b); // Most common case.\n            } else {\n                int code = read2(b);\n                if (code < 0x10000) {\n                    dest.append((char) code);\n                } else if (code <= 0x10ffff) { // Surrogates.\n                    dest.append((char) (((code - 0x10000) >> 10) + 0xd800));\n                    dest.append((char) (((code - 0x10000) & 0x3ff) + 0xdc00));\n                } else {\n                    throw new CharConversionException(\"Cannot convert U+\"\n                            + Integer.toHexString(code)\n                            + \" to char (code greater than U+10FFFF)\");\n                }\n            }\n        }\n    }\n",
    "123377": "    public Utf8StreamWriter setOutputStream(OutputStream out) {\n        if (_outputStream != null)\n            throw new IllegalStateException(\"Writer not closed or reset\");\n        _outputStream = out;\n        return this;\n    }\n",
    "123380": "    public void write(int code) throws IOException {\n        if ((code & 0xffffff80) == 0) {\n            _bytes[_index] = (byte) code;\n            if (++_index >= _bytes.length) {\n                flushBuffer();\n            }\n        } else { // Writes more than one byte.\n            write2(code);\n        }\n    }\n",
    "123382": "    public void write(char cbuf[], int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = cbuf[i++];\n            if (c < 0x80) {\n                _bytes[_index] = (byte) c;\n                if (++_index >= _bytes.length) {\n                    flushBuffer();\n                }\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123383": "    public void write(String str, int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = str.charAt(i++);\n            if (c < 0x80) {\n                _bytes[_index] = (byte) c;\n                if (++_index >= _bytes.length) {\n                    flushBuffer();\n                }\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123384": "    public void write(CharSequence csq) throws IOException {\n        final int length = csq.length();\n        for (int i = 0; i < length;) {\n            char c = csq.charAt(i++);\n            if (c < 0x80) {\n                _bytes[_index] = (byte) c;\n                if (++_index >= _bytes.length) {\n                    flushBuffer();\n                }\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123385": "    public void flush() throws IOException {\n        flushBuffer();\n        _outputStream.flush();\n    }\n",
    "123389": "    private void flushBuffer() throws IOException {\n        if (_outputStream == null)\n            throw new IOException(\"Stream closed\");\n        _outputStream.write(_bytes, 0, _index);\n        _index = 0;\n    }\n",
    "123391": "    public Utf8StreamReader setInputStream(InputStream inStream) {\n        if (_inputStream != null)\n            throw new IllegalStateException(\"Reader not closed or reset\");\n        _inputStream = inStream;\n        return this;\n    }\n",
    "123392": "    public boolean ready() throws IOException {\n        if (_inputStream == null)\n            throw new IOException(\"Stream closed\");\n        return ((_end - _start) > 0) || (_inputStream.available() != 0);\n    }\n",
    "123395": "    public int read() throws IOException {\n        byte b = _bytes[_start];\n        return ((b >= 0) && (_start++ < _end)) ? b : read2();\n    }\n",
    "123411": "    public void setMinimum( T value) {\n        synchronized (ID_TO_VALUE) {\n            if (value instanceof Comparable) {\n                Object prevValue = get();\n                if (((Comparable) value).compareTo(prevValue) > 0) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else if (value instanceof Integer) {\n                Object prevValue = get();\n                if (((Integer) value).intValue() > ((Integer) prevValue)\n                        .intValue()) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n",
    "123414": "    public void setMaximum( T value) {\n        synchronized (ID_TO_VALUE) {\n            if (value instanceof Comparable) {\n                Object prevValue = get();\n                if (((Comparable) value).compareTo(prevValue) < 0) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else if (value instanceof Integer) {\n                Object prevValue = get();\n                if (((Integer) value).intValue() < ((Integer) prevValue)\n                        .intValue()) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n",
    "123415": "    public String toString() {\n        return String.valueOf(this.get());\n    }\n",
    "123416": "    public boolean contains(char c) {\n        final int i = c >> 6;\n        return i < _mapping.length ? (_mapping[i] & (1L << (c & 63))) != 0\n                : false;\n    }\n",
    "123417": "    public CharSet plus(CharSet that) {\n        if (that._mapping.length > this._mapping.length)\n            return that.plus(this);\n        CharSet result = this.copy();\n        for (int i = that._mapping.length; --i >= 0;) {\n            result._mapping[i] |= that._mapping[i];\n        }\n        return result;\n    }\n",
    "123418": "    public CharSet minus(CharSet that) {\n        CharSet result = this.copy();\n        for (int i = MathLib.min(this._mapping.length, that._mapping.length); --i >= 0;) {\n            result._mapping[i] &= ~that._mapping[i];\n        }\n        return result;\n    }\n",
    "123420": "    public String toString() {\n        TextBuilder tb = TextBuilder.newInstance();\n        tb.append('{');\n        int length = _mapping.length << 6;\n        for (int i = 0; i < length; i++) {\n            if (this.contains((char) i)) {\n                if (tb.length() > 1) {\n                    tb.append(',');\n                    tb.append(' ');\n                }\n                tb.append('\\'');\n                tb.append((char) i);\n                tb.append('\\'');\n            }\n        }\n        tb.append('}');\n        return tb.toString();\n    }\n",
    "123421": "    private CharSet copy() {\n        CharSet charSet = new CharSet(new long[this._mapping.length]);\n        for (int i = _mapping.length; --i >= 0;) {\n            charSet._mapping[i] = _mapping[i];\n        }\n        return charSet;\n    }\n",
    "123443": "    public TextBuilder append(Text text) {\n        if (text == null)\n            return append(\"null\");\n        final int length = text.length();\n        for (int i = 0; i < length;) {\n            append(text.charAt(i++));\n        }\n        return this;\n    }\n",
    "123456": "    public Text toText() {\n        return Text.valueOf(getClass().getName()).concat(Text.valueOf('@'))\n                .concat(Text.valueOf(System.identityHashCode(this), 16));\n    }\n",
    "123460": "    protected void recycle() {\n        if (((_pool != null) && _pool.isLocal())) {\n            _pool.recycle(this);\n        }\n    }\n",
    "123479": "    public void clear() {\n        if (_inner != null)\n            _inner.clear();\n        _inner = null;\n    }\n",
    "123484": "    public void clear() {\n        super.clear();\n        for (int i = ObjectFactory.Count; i > 0;) {\n            ObjectPool pool = _pools[--i];\n            if (pool != ObjectPool.NULL) {\n                pool.clearAll();\n            }\n        }\n        _inUsePoolsLength = 0;\n    }\n",
    "123500": "    public  T object() {\n        final PoolContext poolContext = Context.poolContext(Thread\n                .currentThread());\n        return (poolContext == null) ? create() : ( T ) poolContext\n                .getLocalPool(_index).next();\n    }\n",
    "123503": "    protected void cleanup( T obj) {\n        throw new UnsupportedOperationException();\n    }\n",
    "123522": "    public void clear() {\n        if (_threads != null) {\n            for (int i=0; i < _threads.length; i++) {\n                _threads[i].terminate();\n            }\n            _threads = null;\n        }        \n    }\n",
    "123538": "    public Throwable getCause() {\n        return _cause;\n    }\n",
    "123540": "    public void clear() {\n        super.clear();\n        _references.clear();\n    }\n",
    "123549": "    public Text toText() {\n        return Text.valueOf(this.get());\n    }\n",
    "123551": "    public String toString() {\n        return \"Concurrent-\" + super.toString();\n    }\n",
    "123557": "    public void terminate() {\n        synchronized (this) {\n            _terminate = true;\n            this.notify();\n        }\n    }\n",
    "123558": "    public void set( T value) {\n        LocalContext ctx = Context.current().inheritedLocalContext;\n        if (ctx != null) {\n            FastMap references = ctx._references;\n            references.put(this, value);\n            _hasBeenLocallyOverriden = true;\n            return;\n        }\n        // No local context, sets default value.\n        _defaultValue = value;\n    }\n",
    "123559": "    public  T getDefault() {\n        return _defaultValue;\n    }\n",
    "123561": "    public  T getLocal() {\n        LocalContext ctx = Context.current().inheritedLocalContext;\n        return (ctx != null) ? ( T ) ctx._references.get(this)\n                : _defaultValue;\n    }\n",
    "123562": "    public void setDefault( T defaultValue) {\n        _defaultValue = defaultValue;\n    }\n",
    "123563": "    public void setContentHandler(ContentHandler handler) {\n        if (handler != null) {\n            _contentHandler = handler;\n        } else {\n            throw new NullPointerException();\n        }\n    }\n",
    "123565": "\tpublic WriterHandler setWriter(Writer writer) {\n\t\t_writer = writer;\n\t\treturn this;\n\t}\n",
    "123566": "    public ContentHandler getContentHandler() {\n        return (_contentHandler == DEFAULT_HANDLER) ? null : _contentHandler;\n    }\n",
    "123567": "\tpublic void setIndent(CharSequence indent) {\n\t\t_indent = indent;\n\t}\n",
    "123569": "\tpublic void setProlog(CharSequence prolog) {\n\t\t_prolog = prolog;\n\t}\n",
    "123571": "    public void setErrorHandler(ErrorHandler handler) {\n        if (handler != null) {\n            _errorHandler = handler;\n        } else {\n            throw new NullPointerException();\n        }\n    }\n",
    "123574": "    public ErrorHandler getErrorHandler() {\n        return (_errorHandler == DEFAULT_HANDLER) ? null : _errorHandler;\n    }\n",
    "123578": "    public void parse(InputStream in) throws IOException, SAXException {\n        _pullParser.setInput(in);\n        parseAll();\n    }\n",
    "123583": "    public void parse(ByteBuffer byteBuffer) throws IOException, SAXException {\n        _pullParser.setInput(byteBuffer);\n        parseAll();\n    }\n",
    "123586": "    public void parse(Reader reader) throws IOException, SAXException {\n        _pullParser.setInput(reader);\n        parseAll();\n    }\n",
    "123605": "    public void warning (SAXParseException e) throws SAXException {}\n",
    "123606": "    public void setEntityResolver(EntityResolver resolver) {\n        _entityResolver = resolver;\n    }\n",
    "123608": "    public void error (SAXParseException e) throws SAXException {}\n",
    "123609": "    public void fatalError (SAXParseException e) throws SAXException {\n\tthrow e;\n    }\n",
    "123613": "    public EntityResolver getEntityResolver() {\n        return _entityResolver;\n    }\n",
    "123620": "    public void setDTDHandler(DTDHandler handler) {\n        _dtdHandler = handler;\n    }\n",
    "123625": "    public DTDHandler getDTDHandler() {\n        return _dtdHandler;\n    }\n",
    "123750": "    public void reset() {\n        _length = 0;\n    }\n",
    "123753": "    public TextBuilder newAttribute(String qName) {\n        addAttribute(qName, null);\n        TextBuilder tb = _textBuilders[_length - 1];\n        _values[_length - 1] = tb;\n        tb.reset();\n        return tb;\n    }\n",
    "123754": "    public void remove(int index) {\n        _qNames[index] = _qNames[--_length];\n        _values[index] = _values[_length];\n        TextBuilder tmp = _textBuilders[_length];\n        _textBuilders[_length] = _textBuilders[index];\n        _textBuilders[index] = tmp;\n    }\n",
    "123755": "    private CharSequence toCharSeq(Object str) {\n        if (str instanceof CharSequence)\n            return (CharSequence) str;\n        return Text.valueOf((String) str);\n    }\n",
    "123757": "    public String toString() {\n        Text text = Text.valueOf('[');\n        final Text equ = Text.valueOf('=');\n        final Text sep = Text.valueOf(\", \");\n        for (int i = 0; i < _length;) {\n            text = text.concat(Text.valueOf(_qNames[i]).concat(equ).concat(\n                    Text.valueOf(_values[i])));\n            if (++i != _length) {\n                text = text.concat(sep);\n            }\n        }\n        return text.concat(Text.valueOf(']')).toString();\n    }\n",
    "123759": "    public void setNamespace(String prefix, String uri) {\n        if ((prefix.length() == 1) && (prefix.charAt(0) == 'j'))\n            throw new IllegalArgumentException(\"Prefix: \\\"j\\\" is reserved.\");        \n        _namespaces.addLast(toCharSeq(prefix));\n        _namespaces.addLast(toCharSeq(uri));\n        if (prefix.length() == 0) { // Default namespace mapped\n            // Use javolution uri for all classes without namespace\n            // (default namespace cannot be used anymore).\n            _xml._packagePrefixes.addLast(\"j\");\n            _xml._packagePrefixes.addLast(\"\");\n        }\n    }\n",
    "123760": "    public void setPackagePrefix(String prefix, String packageName) {\n        setNamespace(prefix, \"java:\" + packageName);\n        _xml._packagePrefixes.addLast(prefix);\n        _xml._packagePrefixes.addLast(packageName);\n    }\n",
    "123761": "    public void write( T  obj, Writer writer) throws IOException {\n        try {\n            _writerHandler.setWriter(writer);\n            write(obj, _writerHandler);\n        } catch (SAXException e) {\n            if (e.getException() instanceof IOException) {\n                throw (IOException) e.getException();\n            }\n        } finally {\n            _writerHandler.reset();\n        }\n    }\n",
    "123763": "    public void write( T  obj, OutputStream out) throws IOException {\n        try {\n            _utf8StreamWriter.setOutputStream(out);\n            _writerHandler.setWriter(_utf8StreamWriter);\n            write(obj, _writerHandler);\n        } catch (SAXException e) {\n            if (e.getException() instanceof IOException) {\n                throw (IOException) e.getException();\n            }\n        } finally {\n            _utf8StreamWriter.reset();\n            _writerHandler.reset();\n        }\n    }\n",
    "123769": "    public void reset() {\n        _xml.reset();\n        _namespaces.clear();\n        _xml._packagePrefixes.clear();\n        _areReferencesEnabled = false;\n        _expandReferences = false;\n        _isClassIdentifierEnabled = true;\n    }\n",
    "123771": "    public void setReferencesEnabled(boolean enabled) {\n        _areReferencesEnabled = enabled;\n    }\n",
    "123773": "    public void setExpandReferences(boolean value) {\n        _expandReferences  = value;\n    }\n",
    "123775": "    public void setClassIdentifierEnabled(boolean enabled) {\n        _isClassIdentifierEnabled = enabled;\n    }\n",
    "123777": "    public void setRootName(String name) {\n        _rootName = name;\n    }\n",
    "123778": "    public  T  read(Reader reader) throws XmlException {\n        _xml._parser.setInput(reader);\n        return ( T ) parse();\n    }\n",
    "123779": "    public  T  read(InputStream in) throws XmlException {\n        _xml._parser.setInput(in);\n        return ( T ) parse();\n    }\n",
    "123780": "    public  T  read(ByteBuffer byteBuffer) throws XmlException {\n        _xml._parser.setInput(byteBuffer);\n        return ( T ) parse();\n    }\n",
    "123783": "    public void reset() {\n        _xml.reset();\n    }\n",
    "123791": "    public int length() {\n        return length;\n    }\n",
    "123792": "    public char charAt(int index) {\n        if ((index < 0) || (index >= length))\n            throw new IndexOutOfBoundsException(\"index: \" + index);\n        return data[offset + index];\n    }\n",
    "123793": "    public CharSequence subSequence(int start, int end) {\n        if ((start < 0) || (end < 0) ||\n                 (start > end) || (end > this.length())) \n            throw new IndexOutOfBoundsException();\n        CharSequenceImpl chars = (CharSequenceImpl) FACTORY.object();\n        chars.data = data;\n        chars.offset = offset + start;\n        chars.length = end - start;\n        return chars;\n    }\n",
    "123794": "    public String toString() {\n        return new String(data, offset, length);\n    }\n",
    "123795": "    public int hashCode() {\n        int h = 0;\n        for (int i = 0, j = offset; i < length; i++) {\n            h = 31 * h + data[j++];\n        }\n        return h;\n    }\n",
    "123797": "    public boolean equals(Object that) {\n        if (that instanceof CharSequenceImpl) {\n            return equals((CharSequenceImpl) that);\n        } else if (that instanceof String) { // J2ME: String not a CharSequence.\n            return equals((String) that);\n        } else if (that instanceof CharSequence) {\n            return equals((CharSequence) that);\n        } else {\n            return false;\n        }\n    }\n",
    "123798": "    public boolean equals(CharSequenceImpl that) {\n        if (that == null)\n            return false;\n        if (this.length != that.length)\n            return false;\n        final char[] thatData = that.data;\n        final int end = offset + length;\n        for (int i = offset, j = that.offset; i < end;) {\n            if (data[i++] != thatData[j++])\n                return false;\n        }\n        return true;\n    }\n",
    "123799": "    public boolean equals(String str) {\n        if (str == null)\n            return false;\n        if (length != str.length())\n            return false;\n        for (int i = 0, j = offset; i < length;) {\n            if (data[j++] != str.charAt(i++))\n                return false;\n        }\n        return true;\n    }\n",
    "123800": "    public boolean equals(CharSequence chars) {\n        if (chars == null)\n            return false;\n        if (this.length != chars.length())\n            return false;\n        for (int i = 0, j = offset; i < length;) {\n            if (data[j++] != chars.charAt(i++))\n                return false;\n\n        }\n        return true;\n    }\n",
    "123804": "    public CharSequenceImpl getDefault() {\n        return _default;\n    }\n",
    "123805": "    public int getNamespaceCount(int depth) {\n        if (depth > _depth)\n            return _nspCounts[_depth];\n        return _nspCounts[depth];\n    }\n",
    "123807": "    public CharSequenceImpl getNamespacePrefix(int pos) {\n        return _namespaces[pos << 1];\n    }\n",
    "123808": "    public CharSequenceImpl getNamespaceUri(int pos) {\n        return _namespaces[(pos << 1) + 1];\n    }\n",
    "123810": "    public CharSequenceImpl getNamespaceUri(String prefix) {\n        if (prefix == null)\n            return _default;\n        for (int i = _nspCounts[_depth] + _mapCount; i > 0;) {\n            CharSequenceImpl pfx = _namespaces[--i << 1];\n            if ((pfx != null) && pfx.equals(prefix))\n                return _namespaces[(i << 1) + 1];\n        }\n        if (XML_PREFIX.equals(prefix))\n            return XML_URI;\n        if (XMLNS_PREFIX.equals(prefix))\n            return XMLNS_URI;\n        return null;\n    }\n",
    "123811": "    public void map(CharSequenceImpl prefix, CharSequenceImpl uri) {\n        final int i = (_nspCounts[_depth] + _mapCount++) << 1;\n        if (i + 1 >= _namespaces.length) resize();\n        _namespaces[i] = prefix;\n        _namespaces[i + 1] = uri;\n        if (prefix == null) { // Maps default namespace.\n            _default = uri;\n        }\n    }\n",
    "123813": "    public void flush() {\n        if (_mapCount != 0) {\n            push();\n            pop();\n        }\n    }\n",
    "123814": "    public void setInput(ByteBuffer byteBuffer) {\n        if (_reader != null)\n            throw new IllegalStateException(\"Parser not reset.\");\n        _byteBufferReader.setByteBuffer(byteBuffer);\n        _inputEncoding = \"UTF-8\";\n        setInput(_byteBufferReader);\n    }\n",
    "123815": "    public void push() {\n        if (++_depth >= _nspCounts.length) resize();\n        _nspCounts[_depth] = _nspCounts[_depth - 1] + _mapCount;\n        _mapCount = 0;\n    }\n",
    "123816": "    public void pop() {\n        _mapCount = 0;\n        final int oldCount = _nspCounts[_depth];\n        final int newCount = _nspCounts[--_depth];\n        for (int i = oldCount; i > newCount;) {\n            if (_namespaces[--i << 1] == null) { // Unmaps default namespace.\n                _default = CharSequenceImpl.EMPTY;\n                for (int j = i; j > 0;) { // Searches current default.\n                    if (_namespaces[--j << 1] == null) {\n                        _default = _namespaces[(j << 1) + 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n",
    "123818": "    private void resize() {\n        final int size = _nspCounts.length; // = _namepaces.length;\n        int[] tmp0 = new int[size * 2];\n        System.arraycopy(_nspCounts, 0, tmp0, 0, size);\n        _nspCounts = tmp0;\n        CharSequenceImpl[] tmp1 = new CharSequenceImpl[size * 2];\n        System.arraycopy(_namespaces, 0, tmp1, 0, size);\n        _namespaces = tmp1;\n        SIZE.setMinimum(new Integer(_namespaces.length));\n    }\n",
    "123821": "    public void setInput(InputStream in) {\n        if (_reader != null)\n            throw new IllegalStateException(\"Parser not reset.\");\n        _inputStreamReader.setInputStream(in);\n        _inputEncoding = \"UTF-8\";\n        setInput(_inputStreamReader);\n    }\n",
    "123846": "    public XmlInputStream setInputStream(InputStream in) {\n        if (_xmlReader._inputStream != null)\n            throw new IllegalStateException(\"Stream not closed or reset\");\n        _xmlReader._inputStream = in;\n        return this;\n    }\n",
    "123847": "    public  T  readObject() throws IOException {\n        try {\n            return _objectReader.read(_xmlReader);\n        } finally {\n           _xmlReader.resume();\n        }\n    }\n",
    "123851": "    public int read() throws IOException {\n        if (_xmlReader._start < _xmlReader._end) {\n            return _xmlReader._bytes[_xmlReader._start++];\n        } else { // Use the reader buffer.\n            return _xmlReader.fillBuffer() ?\n                 _xmlReader._bytes[_xmlReader._start++] : -1;\n        }\n    }   \n",
    "123856": "        public void resume() {\n            _isHalted = false;\n        }\n",
    "123859": "    public Attributes getSaxAttributes() {\n        return _attributes;\n    }\n",
    "123870": "    public Class objectClass() {\n        return _objectClass;\n    }\n",
    "123873": "    public ContentHandler formatter() {\n        return _formatHandler;\n    }\n",
    "123877": "    public XmlOutputStream setOutputStream(OutputStream out) {\n        if (_outputStream != null)\n            throw new IllegalStateException(\"Stream not closed or reset\");\n        _outputStream = out;\n        return this;\n    }\n",
    "123878": "    public void writeObject( T  obj) throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _objectWriter.write(obj, _outputStreamProxy);\n        _outputStream.write(END_XML);\n        _outputStream.flush();\n    }\n",
    "123880": "    public void write(int b) throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _outputStream.write(b);\n    }\n",
    "123881": "    public void flush() throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _outputStream.flush();\n    }\n",
    "123883": "    public void write(byte b[], int off, int len) throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _outputStream.write(b, off, len);\n    }\n",
    "123892": "    public String defaultName() {\n        return null;\n    }\n",
    "123895": "    public int offset() {\n        return _offset;\n    }\n",
    "123898": "    public void add(Object obj, String qName, Class clazz) {\n        if (obj == null)\n            return;\n        try {\n            // Flushes outer start element if any.\n            if (_elemName != null)\n                flushStart();\n\n            // Formats the specified object.\n            CharSequence elemName = _elemName = toCharSeq(qName);\n            format(obj, XmlFormat.getInstance(clazz));\n            if (_elemName != null)\n                flushStart();\n            _formatHandler.endElement(Text.EMPTY, elemName, elemName);\n\n        } catch (SAXException e) {\n            throw new XmlException(e);\n        }\n    }\n",
    "123899": "    public char charAt(int index) {\n        if (index >= _length)\n            throw new IndexOutOfBoundsException();\n        return _chars[index];\n    }\n",
    "123900": "    public CharSequence subSequence(int start, int end) {\n        if ((start < 0) || (start > end) || (end > _length))\n            throw new IndexOutOfBoundsException();\n        return CharacterData.valueOf(_chars, _offset + start, end - start);\n    }\n",
    "123902": "    public String identifier(boolean isReference) {\n        return isReference ? \"j:ref\" : \"j:id\";\n    }\n",
    "123903": "    public void addNotify() {\n        super.addNotify();\n\n        Component parent = getParent();\n        if (parent != null && parent instanceof EqPanel)\n            equationPanelParent = (EqPanel) parent;\n\n        // this method must be called in a new thread, otherwise problems might\n        // result (the real dangerous thing is to run updateLayout() in the\n        // same command stack as addNotify()\n        Runnable thread = new Runnable() {\n            public void run() {\n                updateLagsSymbol();\n            }\n        };\n        SwingUtilities.invokeLater(thread);\n\n    }\n",
    "123904": "    public TextBuilder newAttribute(String name) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        return _formatAttributes.newAttribute(name);\n    }\n",
    "123907": "    public int getColumnWidth() {\n        return ((EqTermDefault) allTerms.get(0)).getColumnWidth();\n    }\n",
    "123908": "    public T allocate(XmlElement xml) {\n        return null;\n    }\n",
    "123909": "    public MouseListener getMouseListenerCoeff() {\n        return ((EqTermDefault) allTerms.get(0)).getMouseListenerCoeff();\n    }\n",
    "123910": "    public void setAttribute(String name, CharSequence value) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        if (value == null)\n            return;\n        _formatAttributes.addAttribute(name, value);\n    }\n",
    "123912": "    public int getPrecision() {\n        return ((EqTermDefault) allTerms.get(0)).getPrecision();\n    }\n",
    "123913": "    public TableCellRenderer getRendererCoeff() {\n        return ((EqTermDefault) allTerms.get(0)).getRendererCoeff();\n    }\n",
    "123915": "    public void setAttribute(String name, String value) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        if (value == null)\n            return;\n        CharSequence csqValue = toCharSeq(value);\n        _formatAttributes.addAttribute(name, csqValue);\n    }\n",
    "123916": "    public int getStartLag() {\n        return -1 * ((EqTermDefault) allTerms.get(0)).getLagIndex();\n    }\n",
    "123917": "\tpublic void addColumn(TableColumn tc) {\n\t\tif (part < 0) {\n\t\t\tsuper.addColumn(tc);\n\t\t} else { // display only columns for the given lag\n\t\t\tint i = tc.getModelIndex();\n\t\t\tif ((part * n) <= i && i < ((part + 1) * n))\n\t\t\t\tsuper.addColumn(tc);\n\t\t}\n\t}\n",
    "123918": "\tpublic int getIndex() {\n\t\treturn part;\n\t}\n",
    "123919": "\tpublic int getNumberOfColumns() {\n\t\treturn n;\n\t}\n",
    "123921": "\tpublic void setIndex(int arg) {\n\t\tif (part != arg)\n\t\t\tpart = arg;\n\n\t}\n",
    "123923": "\tpublic void setNumberOfColumns(int arg) {\n\t\tn = Math.max(0, arg);\n\t}\n",
    "123924": "    public String getSymbolNameCoeff() {\n        return ((EqTermDefault) allTerms.get(0)).getSymbolNameCoeff();\n    }\n",
    "123925": "    public JSCNArray getJSCNArraySubsetRes() {\n        if (subsetResDef == null)\n            return null;\n\n        SymbolTable sTable = getSymbolTable();\n        if (sTable == null) // not explicitely set\n            sTable = getSymbolScope().getSymbolTable(this);\n\n        if (sTable != null)\n            return sTable.get(subsetResDef).getJSCNArray();\n\n        return null;\n    }\n",
    "123926": "    public SubMatModel getSubMatModel() {\n        return subMatrixModel;\n    }\n",
    "123927": "    public String getSymbolNameSubsetRes() {\n        if (subsetResDef == null)\n            return null;\n\n        return subsetResDef.name;\n    }\n",
    "123928": "    public String getSymbolNameLags() {\n        if (lagsDef == null)\n            return null;\n\n        return lagsDef.name;\n    }\n",
    "123929": "    private void makeVisible() {\n        int c = getColumnCount();\n        boolean b = isVisible();\n        if (c < 1 && b)\n            setVisible(false);\n        if (c > 0 && !b)\n            setVisible(true);\n    }\n",
    "123930": "    public void setColumnCount(int arg) {\n        if (subMatrixModel == null) {\n            subMatrixModel = new SubMatModel(0);\n            subMatrixModel.setNumberOfColumns(arg);\n            super.setColumnModel(subMatrixModel);\n        } else {\n            int oldCols = getColumnCount();\n            if (oldCols != arg) {\n                subMatrixModel.setNumberOfColumns(arg);\n                createDefaultColumnsFromModel();\n            }\n        }\n        makeVisible();\n\n    }\n",
    "123932": "    public void setColumnModel(TableColumnModel newModel) {\n        if (subMatrixModel != null)\n            throw new IllegalStateException(\"No submatrix model set.\");\n\n        super.setColumnModel(newModel);\n    }\n",
    "123933": "    public String getSymbolNameSubsetRes() {\n        return ((EqTermDefault) allTerms.get(0)).getSymbolNameSubsetRes();\n    }\n",
    "123934": "    public void setAttribute(String name, boolean value) {\n        newAttribute(name).append(value);\n    }\n",
    "123935": "    public void setIndex(int arg) {\n        if (subMatrixModel == null) {\n            subMatrixModel = new SubMatModel(arg);\n            super.setColumnModel(subMatrixModel);\n        } else\n            subMatrixModel.setIndex(arg);\n\n    }\n",
    "123936": "    public void setSymbolNameSubsetRes(String newSymbolNameSubsetRes) {\n        if (newSymbolNameSubsetRes == null) {\n            subsetResDef = null;\n            return;\n        }\n\n        subsetResDef = new JSCTypeDef(newSymbolNameSubsetRes, JSCTypes.NARRAY);\n\n        SymbolTable sTable = getSymbolTable();\n        if (sTable == null) // not explicitely set\n            sTable = getSymbolScope().getSymbolTable(this);\n\n        if (sTable != null) {\n            sTable.get(subsetResDef).addSymbolListener(new SymbolListener() {\n                public void valueChanged(SymbolEvent evt) {\n                    resizeAndRepaint();\n                }\n            });\n        }\n    }\n",
    "123937": "    public String getSymbolNameVariables() {\n        return ((EqTermDefault) allTerms.get(0)).getSymbolNameVariables();\n    }\n",
    "123939": "    public void setVisible(boolean aFlag) {\n        boolean oldValue = isVisible();\n        super.setVisible(aFlag);\n        firePropertyChange(\"visible\", oldValue, isVisible());\n    }\n",
    "123941": "    public void tableChanged(TableModelEvent e) {\n        super.tableChanged(e);\n        makeVisible();\n    }\n",
    "123942": "    public JPopupMenu getTablePopup() {\n        return tablePopup;\n    }\n",
    "123943": "\tpublic int getColumnWidth() {\n\t\treturn alpha.getColumnWidth();\n\t}\n",
    "123945": "    public boolean isEditable() {\n        return ((EqTermDefault) allTerms.get(0)).isEditable();\n    }\n",
    "123946": "\tpublic MouseListener getMouseListenerCoeff() {\n\t\treturn mouseListenerCoeff;\n\t}\n",
    "123947": "    public void setAttribute(String name, int value) {\n        newAttribute(name).append(value);\n    }\n",
    "123948": "\tpublic int getPrecision() {\n\t\treturn alpha.getPrecision();\n\t}\n",
    "123950": "\tpublic TableCellRenderer getRendererCoeff() {\n\t\treturn alpha.getCellRenderer();\n\t}\n",
    "123951": "    public void propertyChange(java.beans.PropertyChangeEvent evt) {\n        if (evt.getSource().equals(allTerms.get(0))\n                && evt.getPropertyName() == \"visible\") {\n            // also sets term visible/invisible\n            setDataAvailable(((Boolean) evt.getNewValue()).booleanValue());\n        }\n    }\n",
    "123952": "\tpublic String getSymbolNameAlphaCoeff() {\n\t\treturn alpha.getSymbolName();\n\t}\n",
    "123953": "\tpublic String getSymbolNameAlphaSubsetRes() {\n\t\treturn alpha.getSymbolNameSubsetRes();\n\t}\n",
    "123954": "    public void setColumnWidth(int colWidth) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setColumnWidth(colWidth);\n    }\n",
    "123955": "\tpublic String getSymbolNameBetaCoeff() {\n\t\treturn ecTerm1.getSymbolNameCoeff();\n\t}\n",
    "123957": "\tpublic String getSymbolNameBetaDetCoeff() {\n\t\treturn ecTerm2.getSymbolNameCoeff();\n\t}\n",
    "123958": "\tpublic String getSymbolNameBetaDetSubsetRes() {\n\t\treturn ecTerm2.getSymbolNameSubsetRes();\n\t}\n",
    "123959": "    public void setEditable(boolean isEditable) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setEditable(isEditable);\n    }\n",
    "123960": "    public void setAttribute(String name, long value) {\n        newAttribute(name).append(value);\n    }\n",
    "123961": "\tpublic String getSymbolNameBetaSubsetRes() {\n\t\treturn ecTerm1.getSymbolNameSubsetRes();\n\t}\n",
    "123962": "\tpublic String getSymbolNameDetVarNames() {\n\t\treturn ecTerm2.getSymbolNameVariables();\n\t}\n",
    "123963": "    public void setLeadingSignVisible(boolean isVisible) {\n        ((EqTermDefault) allTerms.get(0)).setLeadingSignVisible(isVisible);\n    }\n",
    "123965": "\tpublic String getSymbolNameEndVarNames() {\n\t\treturn ecTerm1.getSymbolNameVariables();\n\t}\n",
    "123966": "\tpublic boolean isEditable() {\n\t\treturn alpha.isEditable();\n\t}\n",
    "123967": "    public void setSymbolScope(Scope scope) {\n        super.setSymbolScope(scope);\n        for (int i = 0; i < allTerms.size(); i++)\n            allTerms.get(i).setSymbolScope(scope);\n        updateLagsSymbol();\n    }\n",
    "123969": "\tpublic void setColumnWidth(int colWidth) {\n\t\talpha.setColumnWidth(colWidth);\n\t\tecTerm1.setColumnWidth(colWidth);\n\t\tecTerm2.setColumnWidth(colWidth);\n\t}\n",
    "123972": "\tpublic void setEditable(boolean isEditable) {\n\t\talpha.setEditable(isEditable);\n\t\tecTerm1.setEditable(isEditable);\n\t\tecTerm2.setEditable(isEditable);\n\t}\n",
    "123973": "    public void setMouseListenerCoeff(MouseListener listener) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setMouseListenerCoeff(listener);\n    }\n",
    "123974": "\tpublic void setLeadingSignVisible(boolean isVisible) {\n\t\tleadingSign.setVisible(isVisible);\n\t}\n",
    "123975": "\tpublic void setSymbolScope(Scope scope) {\n\t\tsuper.setSymbolScope(scope);\n\t\tecTerm1.setSymbolScope(scope);\n\t\tecTerm2.setSymbolScope(scope);\n\t\talpha.setSymbolScope(scope);\n\t}\n",
    "123976": "    public void setPrecision(int precision) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setPrecision(precision);\n    }\n",
    "123977": "\tpublic void setMouseListenerCoeff(MouseListener arg) {\n\t\tif (mouseListenerCoeff != null) {\n\t\t\talpha.removeMouseListener(mouseListenerCoeff);\n\t\t\tecTerm1.removeMouseListener(mouseListenerCoeff);\n\t\t\tecTerm2.removeMouseListener(mouseListenerCoeff);\n\t\t}\n\t\tmouseListenerCoeff = arg;\n\t\tif (mouseListenerCoeff != null) {\n\t\t\talpha.addMouseListener(mouseListenerCoeff);\n\t\t\tecTerm1.addMouseListener(mouseListenerCoeff);\n\t\t\tecTerm2.addMouseListener(mouseListenerCoeff);\n\t\t}\n\t}\n",
    "123978": "    public CharSequence getQName() {\n        return _elemQName;\n    }\n",
    "123979": "\tpublic void setPrecision(int precision) {\n\t\talpha.setPrecision(precision);\n\t\tecTerm1.setPrecision(precision);\n\t\tecTerm2.setPrecision(precision);\n\t}\n",
    "123980": "    public void setRendererCoeff(TableCellRenderer renderer) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setRendererCoeff(renderer);\n    }\n",
    "123981": "\tpublic void setRendererCoeff(TableCellRenderer renderer) {\n\t\talpha.setCellRenderer(renderer);\n\t\tecTerm1.setRendererCoeff(renderer);\n\t\tecTerm2.setRendererCoeff(renderer);\n\t}\n",
    "123983": "\tpublic void setSymbolNameAlphaCoeff(String symbolName) {\n\t\talpha.setSymbolName(symbolName);\n\t}\n",
    "123984": "    public void setStartLag(int startLag) {\n        if (startLag < 0)\n            throw new IllegalArgumentException(\"Start lag \" + startLag\n                    + \" < 0.\");\n        ((EqTermDefault) allTerms.get(0)).setLagIndex(-1 * startLag);\n    }\n",
    "123986": "\tpublic void setSymbolNameAlphaSubsetRes(String symbolName) {\n\t\talpha.setSymbolNameSubsetRes(symbolName);\n\t}\n",
    "123987": "\tpublic void setSymbolNameBetaCoeff(String symbolName) {\n\t\tecTerm1.setSymbolNameCoeff(symbolName);\n\t}\n",
    "123988": "    public void setSymbolNameCoeff(String symbolName) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setSymbolNameCoeff(symbolName);\n    }\n",
    "123989": "\tpublic void setSymbolNameBetaDetCoeff(String symbolName) {\n\t\tecTerm2.setSymbolNameCoeff(symbolName);\n\t}\n",
    "123991": "\tpublic void setSymbolNameBetaDetSubsetRes(String symbolName) {\n\t\tecTerm2.setSymbolNameSubsetRes(symbolName);\n\t}\n",
    "123992": "    public void setSymbolNameLags(String newSymbolNameLags) {\n\n        if (lagsSymbol != null)\n            lagsSymbol.removeSymbolListener(this);\n\n        if (newSymbolNameLags == null) {\n            lagsDef = null;\n            return;\n        }\n\n        lagsDef = new JSCTypeDef(newSymbolNameLags, JSCTypes.INT);\n\n        updateLagsSymbol();\n    }\n",
    "123993": "    public void setAttribute(String name, Boolean value) {\n        if (value == null)\n            return;\n        newAttribute(name).append(value.booleanValue());\n    }\n",
    "123994": "\tpublic void setSymbolNameBetaSubsetRes(String symbolName) {\n\t\tecTerm1.setSymbolNameSubsetRes(symbolName);\n\t}\n",
    "123995": "\tpublic void setSymbolNameDetVarNames(String symbolName) {\n\t\tecTerm2.setSymbolNameVariables(symbolName);\n\t}\n",
    "123996": "    public void setSymbolNameSubsetRes(String symbolName) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i))\n                    .setSymbolNameSubsetRes(symbolName);\n    }\n",
    "123998": "\tpublic void setSymbolNameEndVarNames(String symbolName) {\n\t\tecTerm1.setSymbolNameVariables(symbolName);\n\t}\n",
    "123999": "\tpublic int getIndex() {\n\t\treturn index;\n\t}\n",
    "124000": "\tpublic String getIndexString() {\n\t\tString str;\n\t\tif (index == 0)\n\t\t\tstr = \"(t)\";\n\t\telse\n\t\t\tstr = \"(t\" + ((index < 0) ? \"\" + index : \"+\" + index) + \")\";\n\n\t\treturn str;\n\t}\n",
    "124001": "\tpublic boolean isShowingTimeIndex() {\n\t\treturn showingTimeIndex;\n\t}\n",
    "124002": "    public void setSymbolNameVariables(String symbolName) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i))\n                    .setSymbolNameVariables(symbolName);\n    }\n",
    "124003": "\tpublic void setCoeffTable(CoeffTable newCoeffTable) {\n\t\tcoeffTable = newCoeffTable;\n\t}\n",
    "124004": "\tpublic void setIndex(int newIndex) {\n\t\tindex = newIndex;\n\t}\n",
    "124005": "\tpublic void setShowingTimeIndex(boolean isShowingTimeIndex) {\n\t\tshowingTimeIndex = isShowingTimeIndex;\n\t}\n",
    "124008": "\tpublic void tableChanged(TableModelEvent e) {\n\t\tsuper.tableChanged(e);\n\t\tif (getColumnCount() < 1 && isVisible())\n\t\t\tsetVisible(false);\n\t\tif (getColumnCount() > 0 && !isVisible())\n\t\t\tsetVisible(true);\n\n\t\tif (coeffTable != null) {\n\t\t\tcoeffTable.setColumnCount(getRowCount());\n\t\t}\n\t}\n",
    "124009": "    public void setAttribute(String name, Byte value) {\n        if (value == null)\n            return;\n        newAttribute(name).append(value.byteValue());\n    }\n",
    "124010": "    public void setTablePopup(JPopupMenu newTablePopup) {\n        tablePopup = newTablePopup;\n        for (int i = 0; i < allTerms.size(); i++) {\n            ((EqTermDefault) allTerms.get(i)).setTablePopup(tablePopup);\n        }\n\n    }\n",
    "124012": "    private void adjustScrollBar(JScrollBar scrollBar) {\n\n        if (scrollBar == null)\n            return;\n\n        if (scrollBar.isVisible()) {\n            int max = scrollBar.getMaximum();\n            int visibleAmount = scrollBar.getVisibleAmount();\n            scrollBar.setVisible(visibleAmount != max);\n        }\n\n    }\n",
    "124018": "    private void updateVisibility(int arg) {\n        int n = allTerms.size();\n        boolean doNotRevalidate = true;\n        for (int i = 0; i < n; i++) {\n            EqTerm et = allTerms.get(i);\n            boolean wasVisible = et.isVisible();\n            et.setVisible(i < arg);\n            doNotRevalidate = doNotRevalidate && (et.isVisible() == wasVisible);\n        }\n        if (!doNotRevalidate) {\n            if (addTermsToParent) {\n                if (equationPanelParent != null)\n                    equationPanelParent.revalidate();\n            } else {\n                revalidate();\n            }\n        }\n    }\n",
    "124020": "    public void setAttribute(String name, Short value) {\n        if (value == null)\n            return;\n        newAttribute(name).append(value.shortValue());\n    }\n",
    "124021": "    public Dimension maximumLayoutSize(Container target) {\n        return preferredLayoutSize(target);\n    }\n",
    "124023": "    public Dimension minimumLayoutSize(Container target) {\n        return preferredLayoutSize(target);\n    }\n",
    "124024": "    public void valueChanged(SymbolEvent evt) {\n        lagsSymbol = evt.getSource();\n        updateLayout();\n    }\n",
    "124026": "    private Dimension preferredLayoutSizeLHS(Container target) {\n        Dimension dim = new Dimension(0, 0);\n        int nmembers = Math.min(numberLHS, target.getComponentCount());\n        for (int i = 0; i < nmembers; i++) {\n            Component m = target.getComponent(i);\n            if (m.isVisible()) {\n                Dimension d = m.getPreferredSize();\n                dim.height = Math.max(dim.height, d.height);\n                if (i > 0) {\n                    dim.width += getHgap();\n                }\n                dim.width += d.width;\n            }\n        }\n        return dim;\n    }\n",
    "124029": "    public void setAttribute(String name, Integer value) {\n        if (value == null)\n            return;\n        newAttribute(name).append(value.intValue());\n    }\n",
    "124030": "\tpublic int getColumnWidth() {\n\t\treturn coeff.getColumnWidth();\n\t}\n",
    "124031": "\tpublic Dimension getMaximumSize() {\n\t\treturn getPreferredSize();\n\t}\n",
    "124032": "\tpublic int getLagIndex() {\n\t\treturn variables.getIndex();\n\t}\n",
    "124033": "\tpublic Dimension getMinimumSize() {\n\t\tDimension dim = super.getMinimumSize();\n\t\tdim.width = Math.max(20, dim.width);\n\t\tdim.height = Math.max(20, dim.height);\n\t\treturn dim;\n\t}\n",
    "124034": "\tpublic Dimension getPreferredSize() {\n\t\tDimension dim = getMinimumSize();\n\t\tDimension dimPref = super.getPreferredSize();\n\t\tdim.width = Math.max(dimPref.width, dim.width);\n\t\tdim.height = Math.max(dimPref.height, dim.height);\n\t\treturn dim;\n\t}\n",
    "124036": "\tpublic void setDataAvailable(boolean isDataAvailable) {\n\t\tdataAvailable = isDataAvailable;\n\t\tsetVisible(dataAvailable);\n\t}\n",
    "124037": "\tpublic int getPrecision() {\n\t\treturn coeff.getPrecision();\n\t}\n",
    "124038": "\tpublic void setVisible(boolean aFlag) {\n\t\taFlag = aFlag && dataAvailable;\n\t\tboolean oldValue = isVisible();\n\t\tif (aFlag != oldValue) {\n\t\t\tsuper.setVisible(aFlag);\n\t\t\tfirePropertyChange(\"visible\", oldValue, isVisible());\n\t\t}\n\t}\n",
    "124039": "\tpublic TableCellRenderer getRendererCoeff() {\n\t\treturn coeff.getCellRenderer();\n\t}\n",
    "124040": "\tpublic Scope getSymbolScope() {\n\t\treturn symbolScope;\n\t}\n",
    "124041": "\tpublic String getSymbolNameCoeff() {\n\t\treturn coeff.getSymbolName();\n\t}\n",
    "124042": "\tpublic void setSymbolScope(Scope scope) {\n\t\tif (scope == null)\n\t\t\tthrow new IllegalArgumentException(\"Argument was null.\");\n\t\tsymbolScope = scope;\n\t}\n",
    "124045": "\tpublic String getSymbolNameSubsetRes() {\n\t\treturn coeff.getSymbolNameSubsetRes();\n\t}\n",
    "124046": "\tprivate void enableComponentsAndChilds(Component[] c, boolean enabled) {\n\t\tif (c != null) {\n\t\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\t\tc[i].setEnabled(enabled);\n\t\t\t\tif (c[i] instanceof Container) {\n\t\t\t\t\tenableComponentsAndChilds(\n\t\t\t\t\t\t((Container) c[i]).getComponents(),\n\t\t\t\t\t\tenabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "124047": "\tpublic void setEnabled(boolean enabled) {\n\t\tenableComponentsAndChilds(getComponents(), enabled);\n\t\tsuper.setEnabled(enabled);\n\t}\n",
    "124048": "\tpublic String getSymbolNameVariables() {\n\t\treturn variables.getSymbolName();\n\t}\n",
    "124049": "    public void setAttribute(String name, Long value) {\n        if (value == null)\n            return;\n        newAttribute(name).append(value.longValue());\n    }\n",
    "124050": "    public void append(String out) {\n        log.info(out);\n    }\n",
    "124053": "\tpublic boolean isCoeffMatRequired() {\n\t\treturn coeffMatRequired;\n\t}\n",
    "124054": "public Insets getBorderInsets(Component c) {\n\treturn insets;\n}\n",
    "124056": "\tpublic boolean isEditable() {\n\t\treturn coeff.isEditable();\n\t}\n",
    "124057": "public Insets getBorderInsets(Component c, Insets insets) {\n\tinsets.left = this.insets.left;\n\tinsets.top = this.insets.top;\n\tinsets.right = this.insets.right;\n\tinsets.bottom = this.insets.bottom;\n\treturn insets;\n}\n",
    "124058": "\tpublic boolean isMatrixCentered() {\n\t\treturn getLayout() instanceof FlowLayout;\n\t}\n",
    "124059": "public boolean isBorderOpaque() {\n\treturn false;\n}\n",
    "124060": "\tpublic boolean isShowingTimeIndex() {\n\t\treturn variables.isShowingTimeIndex();\n\t}\n",
    "124062": "\tpublic void propertyChange(java.beans.PropertyChangeEvent evt) {\n\t\tif (evt.getPropertyName() == \"visible\") {\n\t\t\tboolean b = true;\n\t\t\tif (coeffMatRequired) {\n\t\t\t\tb = coeff.isVisible();\n\t\t\t}\n\t\t\tb = b && variables.isVisible();\n\t\t\tif (b != isVisible()) {\n\t\t\t\t// also sets term visible/invisible\t\n\t\t\t\tsetDataAvailable(b);\n\t\t\t}\n\t\t}\n\t}\n",
    "124063": "\tpublic void setCoeffMatRequired(boolean isCoeffMatRequired) {\n\t\tcoeffMatRequired = isCoeffMatRequired;\n\t}\n",
    "124066": "\tpublic void setColumnWidth(int colWidth) {\n\t\tcoeff.setColumnWidth(colWidth);\n\t}\n",
    "124068": "\tpublic void setEditable(boolean isEditable) {\n\t\tcoeff.setEditable(isEditable);\n\t}\n",
    "124069": "\tpublic void setLagIndex(int index) {\n\t\tvariables.setIndex(index);\n\t}\n",
    "124073": "    public String getTopModuleByName() {\n        if (currentTopFrame == null)\n            return null;\n\n        return currentTopFrame.getTitle();\n    }\n",
    "124074": "\tpublic void setMouseListenerCoeff(java.awt.event.MouseListener listener) {\n\t\tcoeff.setMouseListener(listener);\n\t\tmouseListenerCoeff = listener;\n\n\t}\n",
    "124076": "\tpublic void setPrecision(int precision) {\n\t\tcoeff.setPrecision(precision);\n\t}\n",
    "124077": "\tpublic void setRendererCoeff(TableCellRenderer renderer) {\n\t\tcoeff.setCellRenderer(renderer);\n\t}\n",
    "124079": "\tpublic void setShowingTimeIndex(boolean isShowingTimeIndex) {\n\t\tvariables.setShowingTimeIndex(isShowingTimeIndex);\n\t}\n",
    "124080": "\tpublic void setSymbolNameCoeff(String symbolName) {\n\t\tcoeff.setSymbolName(symbolName);\n\t}\n",
    "124082": "\tpublic void setSymbolNameSubsetRes(String symbolName) {\n\t\tcoeff.setSymbolNameSubsetRes(symbolName);\n\t}\n",
    "124083": "\tpublic void setSymbolNameVariables(String symbolName) {\n\t\tvariables.setSymbolName(symbolName);\n\t}\n",
    "124084": "    public void removeAttribute(String name) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        int index = _formatAttributes.getIndex(name);\n        if (index >= 0) {\n            _formatAttributes.remove(index);\n        }\n    }\n",
    "124086": "\tpublic void setTablePopup(JPopupMenu newTablePopup) {\n\t\ttablePopup = newTablePopup;\n\t\tif (tablePopup == null)\n\t\t\tcoeff.removeMouseListener(triggerPopUp);\n\t\telse {\n\t\t\ttriggerPopUp = new MouseAdapter() {\n\t\t\t\tpublic void mouseReleased(MouseEvent e) {\n\t\t\t\t\ttablePopup.processMouseEvent(e, null, null);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcoeff.addMouseListener(triggerPopUp);\n\t\t}\n\n\t}\n",
    "124088": "\tpublic void setSymbolScope(Scope scope) {\n\t\tsuper.setSymbolScope(scope);\n\t\tcoeff.setSymbolScope(scope);\n\t\tvariables.setSymbolScope(scope);\n\t}\n",
    "124092": "    public XmlPullParser parser() {\n        return _parser;\n    }\n",
    "124096": "        public Object construct() {\n            try {\n                if (classToBuild == null)\n                    return null;\n                if (method != null) {\n                    Object rt = method.invoke(this, new Object[0]);\n                    return rt;\n                }\n                return classToBuild.newInstance();\n            } catch (Throwable ex) {\n                return ex;\n            }\n        }\n",
    "124098": "    public boolean hasNext() {\n        if (!_isParserAtNext) {\n            nextToken();\n            _isParserAtNext = true;\n        }\n        return !_isClosure;\n    }\n",
    "124104": "    public Attributes getAttributes() {\n        if (_formatAttributes != null)\n            return _formatAttributes;\n        if (_isParserAtNext)\n            throw new XmlException(\n                    \"Attributes should be read before any content\");\n        return _parser.getSaxAttributes();\n    }\n",
    "124110": "    public CharSequence getAttribute(String name) {\n        return getAttributes().getValue(name);\n    }\n",
    "124114": "    public boolean isAttribute(String name) {\n        return getAttributes().getIndex(name) >= 0;\n    }\n",
    "124118": "    public CharSequence getAttribute(String name, CharSequence defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? value : defaultValue;\n    }\n",
    "124121": "    public void actionPerformed(ActionEvent arg1) {\n        cardPanel.showCard(getComponent());\n    }\n",
    "124122": "    public JComponent getComponent() {\n        if (component == null) {\n            try {\n                component = (JComponent) Class.forName(className).newInstance();\n            } catch (Throwable thr) {\n                String msg = \"Problem creating \\\"\" + className + \"\\\".\";\n                log.error(msg, thr);\n                component = new JPanel();\n                component.setLayout(new BorderLayout());\n                MultiLineLabel label = new MultiLineLabel(\n                        msg\n                                + \"\\nDisplaying an empty JPanel instead. Check log messages for more.\");\n                label.setHorizontalAlignment(SwingConstants.CENTER);\n                label.setForeground(Color.red);\n                component.add(label, \"Center\");\n            }\n        }\n        return component;\n    }\n",
    "124123": "    public String getAttribute(String name, String defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? value.toString() : defaultValue;\n    }\n",
    "124124": "    protected JInternalFrame getTSCalcFrame() {\n        if (tsCalc == null) {\n            try {\n                tsCalc = new TSCalcFrame();\n            } catch (Throwable ex) {\n                log.error(\"Error creating TSCalcFrame\", ex);\n            }\n        }\n        return tsCalc;\n    }\n",
    "124131": "    private void setText(int start, int length) {\n        _text = newSeq();\n        _text.data = _data;\n        _text.offset = start;\n        _text.length = length;\n    }\n",
    "124132": "private ResultField getResultField() {\n\treturn resultField;\n}\n",
    "124134": "    public boolean getAttribute(String name, boolean defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? TypeFormat.parseBoolean(value) : defaultValue;\n    }\n",
    "124135": "public String toString() {\n    StringBuffer buffer = new StringBuffer();\n    buffer.append(getClass().getName() + \"[name=\" + name);\n    for (int i = 0; i < getComponentCount(); i++)\n        buffer.append(\",\" + getComponent(i).getName());\n    buffer.append(\"]\");\n    return buffer.toString();\n}\n",
    "124136": "    public JToolBar getToolBar() {\n        if (toolBar == null) {\n            try {\n                toolBar = new JToolBar();\n                toolBar.setSize(200, 20);\n                toolBar.setFloatable(false);\n                toolBar.setRollover(true);\n            } catch (Throwable ex) {\n                log.error(\"Error creating toolbar\", ex);\n            }\n        }\n        return toolBar;\n    }\n",
    "124140": "    public void actionPerformed(java.awt.event.ActionEvent evt) {\n        showHelp();\n    }\n",
    "124141": "    public int getAttribute(String name, int defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? TypeFormat.parseInt(value) : defaultValue;\n    }\n",
    "124146": "    public long getAttribute(String name, long defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? TypeFormat.parseLong(value) : defaultValue;\n    }\n",
    "124161": "\tprotected void focusGained() {\n\t\tif (isEnabled() && isEditing == false) {\n\t\t\tisEditing = true;\n\t\t\tToolkit.getDefaultToolkit().addAWTEventListener(\n\t\t\t\tgetAWTEventListener(),\n\t\t\t\tAWTEvent.MOUSE_EVENT_MASK);\n\t\t}\n\t}\n",
    "124164": "\tprivate AWTEventListener getAWTEventListener() {\n\t\tif (eventHandler == null)\n\t\t\teventHandler = new EventHandler();\n\t\treturn eventHandler;\n\t}\n",
    "124165": "\tpublic void handleError(String msg) {\n\t\tsetBackground(CompSettings.errorBackground);\n\t\tif (parentFrame != null)\n\t\t\tStdMessages.errorInput(msg, parentFrame);\n\t\telse if (parentDialog != null)\n\t\t\tStdMessages.errorInput(msg, parentDialog);\n\t\telse\n\t\t\tStdMessages.errorInput(msg);\n\n\t\tsetBackground(Color.WHITE);\n\n\t}\n",
    "124167": "\tpublic void addNotify() {\n\t\tsuper.addNotify();\n\t\tWindow window = SwingUtilities.getWindowAncestor(this);\n\t\tif (window instanceof JFrame)\n\t\t\tparentFrame = (JFrame) window;\n\t\tif (window instanceof JDialog)\n\t\t\tparentDialog = (JDialog) window;\n\t}\n",
    "124168": "    public Boolean getAttribute(String name, Boolean defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? new Boolean(TypeFormat.parseBoolean(value))\n                : defaultValue;\n    }\n",
    "124171": "    private JSplitPane getSplitPane() {\n        if (splitPane == null) {\n            try {\n                splitPane = new JSplitPane();\n                splitPane.setRightComponent(getTopFrameDesktop());\n                JScrollPane scrollPane = new JScrollPane(ProjectTree\n                        .getInstance());\n                leftPanel = new JPanel(new BorderLayout());\n                leftPanel.add(scrollPane, BorderLayout.CENTER);\n                leftPanel.add(getOutputToggleButton(), BorderLayout.NORTH);\n                installDragAndDropListener(scrollPane);\n                scrollPane.setPreferredSize(new Dimension(150, 100));\n                splitPane.setLeftComponent(leftPanel);\n            } catch (Throwable ex) {\n                log.error(\"Error creating splitpane\", ex);\n            }\n        }\n        return splitPane;\n    }\n",
    "124172": "\tpublic void setTextCarefully(String text) {\n\n\t\tint selStart = getSelectionStart();\n\t\tint selEnd = getSelectionEnd();\n\t\tint pos = getCaretPosition();\n\n\t\tsetText(text);\n\n\t\tint ll = getText().length();\n\n\t\t// Set caret again.\n\t\tif (pos < ll)\n\t\t\tsetCaretPosition(pos);\n\n\t\t// Set selection again.   \n\t\tif (selStart < ll)\n\t\t\tsetSelectionStart(selStart);\n\t\tif (selEnd < ll)\n\t\t\tsetSelectionEnd(selEnd);\n\t\telse\n\t\t\tsetSelectionEnd(ll);\n\t\tlastValidText = getText();\n\n\t}\n",
    "124173": "\tprivate String validateInputEx() {\n\n\t\t// Validate only if text has changed.\n\t\tif (lastValidText.equals(getText()))\n\t\t\treturn null;\n\t\tString err = null;\n\t\ttry {\n\t\t\terr = validateInput();\n\t\t\tif (err == null)\n\t\t\t\tlastValidText = getText();\n\t\t} catch (Throwable ex) {\n\t\t\terr = ex.getMessage();\n\t\t}\n\t\treturn err;\n\t}\n",
    "124174": "    public Byte getAttribute(String name, Byte defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? new Byte(TypeFormat.parseByte(value))\n                : defaultValue;\n    }\n",
    "124180": "    public String getID(Object key) {\n        String k = key + \"\";\n        Object rt = map.get(k);\n        if (rt == null)\n            return null;\n        return rt.toString();\n\n    }\n",
    "124181": "    protected JFrame getOutputControlFrame() {\n        if (outputFrame == null) {\n            try {\n                outputFrame = new OutputFrame();\n                outputFrame.setLocationRelativeTo(this);\n            } catch (Throwable ex) {\n                log.error(\"Error creating output control\", ex);\n            }\n        }\n        return outputFrame;\n    }\n",
    "124184": "\tpublic String getVarName() {\n\t\treturn varName;\n\t}\n",
    "124185": "\tpublic void handleError(String msg) {\n\t\tsuper.handleError(\n\t\t\tmsg + \"\\nThe input is set back to the previous value.\");\n\t\tsetVarName(varName);\n\t}\n",
    "124186": "\tpublic void setVarName(String newVarName) {\n\t\tString error = JSCConstants.isValidName(newVarName);\n\t\tif (error != null)\n\t\t\tthrow new IllegalArgumentException(error);\n\t\tvarName = newVarName.trim().toLowerCase();\n\t\tsetText(varName);\n\t}\n",
    "124187": "    public Short getAttribute(String name, Short defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? new Short(TypeFormat.parseShort(value))\n                : defaultValue;\n    }\n",
    "124191": "    protected JFrame getSymbolControlFrame() {\n        if (symbolFrame == null) {\n            try {\n                symbolFrame = new SymbolFrame();\n                symbolFrame.setLocationRelativeTo(this);\n            } catch (Throwable ex) {\n                log.error(\"Error creating symbol frame\", ex);\n            }\n        }\n        return symbolFrame;\n    }\n",
    "124195": "    public Integer getAttribute(String name, Integer defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? new Integer(TypeFormat.parseInt(value))\n                : defaultValue;\n    }\n",
    "124196": "    private void initialize() {\n        this.setContentPane(getJPanel());\n        this.setTitle(\"Preferences\");\n        this.setSize(473, 243);\n\n    }\n",
    "124198": "    private JPanel getJPanel() {\n        if (jPanel == null) {\n            jPanel = new JPanel();\n            jPanel.setLayout(new BorderLayout());\n            jPanel.add(getJPanel1(), java.awt.BorderLayout.SOUTH);\n            jPanel.add(getJScrollPane(), java.awt.BorderLayout.CENTER);\n        }\n        return jPanel;\n    }\n",
    "124199": "    private JScrollPane getJScrollPane() {\n        if (jScrollPane == null) {\n            jScrollPane = new JScrollPane();\n            jScrollPane.setViewportView(getJTable());\n        }\n        return jScrollPane;\n    }\n",
    "124201": "    private JTable getJTable() {\n        if (jTable == null) {\n            jTable = new JTable();\n            jTable.setRowHeight(25);\n            jTable.setRowSelectionAllowed(false);\n            jTable.setColumnSelectionAllowed(false);\n            int gapWidth = 4;\n            int gapHeight = 4;\n            jTable.setIntercellSpacing(new Dimension(gapWidth, gapHeight));\n            jTable.setDefaultEditor(Object.class, myEditor);\n            jTable.setShowGrid(false);\n            jTable.setCellSelectionEnabled(false);\n        }\n        return jTable;\n    }\n",
    "124202": "    private JPanel getJPanel1() {\n        if (jPanel1 == null) {\n            FlowLayout flowLayout1 = new FlowLayout();\n            jPanel1 = new JPanel();\n            jPanel1.setLayout(flowLayout1);\n            jPanel1.setPreferredSize(new java.awt.Dimension(10, 50));\n            jPanel1.setBorder(javax.swing.BorderFactory\n                    .createBevelBorder(javax.swing.border.BevelBorder.LOWERED));\n            flowLayout1.setHgap(100);\n            flowLayout1.setVgap(10);\n            jPanel1.add(getOkButton(), null);\n            jPanel1.add(getCancelButton(), null);\n        }\n        return jPanel1;\n    }\n",
    "124203": "    public void valueChanged(SymbolEvent evt) {\n        symbol = evt.getSource();\n        setJSCSArray(symbol.getJSCSArray());\n    }\n",
    "124204": "    protected JDialog getTopFrameAboutBox() {\n        if (aboutBox == null) {\n            try {\n                aboutBox = new TopFrameAboutBox(this, \"About \" + TITLE,\n                        VERSION, ABOUTINFO, ABOUTIMAGE, LICENSE);\n            } catch (Throwable ex) {\n                log.error(\"Error creating about box\", ex);\n\n            }\n        }\n        return aboutBox;\n    }\n",
    "124205": "    private JButton getOkButton() {\n        if (okButton == null) {\n            okButton = new JButton();\n            okButton.setText(\"OK\");\n            okButton.setPreferredSize(new java.awt.Dimension(100, 26));\n            okButton.addActionListener(new java.awt.event.ActionListener() {\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    TableCellEditor ed = getJTable().getCellEditor();\n                    if (ed != null)\n                        ed.stopCellEditing();\n                    setVisible(false);\n                    appSettings = (AppSettings) getJTable().getModel();\n                }\n            });\n        }\n        return okButton;\n    }\n",
    "124206": "    public Long getAttribute(String name, Long defaultValue) {\n        CharSequence value = getAttributes().getValue(name);\n        return (value != null) ? new Long(TypeFormat.parseLong(value))\n                : defaultValue;\n    }\n",
    "124209": "    private JButton getCancelButton() {\n        if (cancelButton == null) {\n            cancelButton = new JButton();\n            cancelButton.setText(\"Cancel\");\n            cancelButton.setPreferredSize(new java.awt.Dimension(100, 26));\n            cancelButton.addActionListener(new java.awt.event.ActionListener() {\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    setVisible(false);\n                }\n            });\n        }\n        return cancelButton;\n    }\n",
    "124212": "    public void setAppSettings(AppSettings appSettings) {\n        if (appSettings == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.appSettings = appSettings;\n        // copy appSettings before because it might be cancelled\n        getJTable().setModel(new AppSettings(appSettings));\n    }\n",
    "124213": "    public AppSettings getAppSettings() {\n        return appSettings;\n    }\n",
    "124217": "    protected RedirectReceiver getLogFrame() {\n        if (logger == null)\n            try {\n                logger = new LogFrame();\n            } catch (Throwable ex) {\n                log.error(\"Error creating logger\", ex);\n\n            }\n        return logger;\n    }\n",
    "124218": "    public void addNotify() {\n        super.addNotify();\n        updateSymbol();\n    }\n",
    "124223": "    public void clear() {\n        map.clear();\n        removeAll();\n        storeStatusToSelSymbol();\n\n    }\n",
    "124226": "    protected AbstractImportPanel getImportPanel() {\n        if (importPanel == null) {\n            try {\n                importPanel = new TSImportPanel();\n            } catch (Throwable ex) {\n                log.error(\"Error creating import panel\", ex);\n\n            }\n        }\n        return importPanel;\n    }\n",
    "124227": "    public void clearSelectionStatus() {\n        int[] oldStatus = getIntSelectionStatus();\n\n        if (UMatrix.getNonzeroIntCount(oldStatus) == 0)\n            return; // nothing to do\n\n        for (int i = 0; i < getModel().getSize(); i++)\n            ((CheckBoxListItem) getModel().getElementAt(i)).setSelected(false);\n        storeStatusToSelSymbol();\n\n        // Fire the property change to notify listeners only if something was\n        // selected before.\n        setSelectionChanged();\n        repaint();\n\n    }\n",
    "124228": "\tpublic NumberFormatTypes getNumberFormatType() {\n\t\treturn numberFormatType;\n\t}\n",
    "124229": "\tpublic NumberRange getNumberRange() {\n\t\treturn currentNumberRange;\n\t}\n",
    "124231": "\tpublic NumberRange getOverallNumberRange() {\n\t\treturn overallNumberRange;\n\t}\n",
    "124232": "\tpublic String getOverallRangeExpr() {\n\t\treturn overallNumberRange.toString();\n\n\t}\n",
    "124233": "    private void flushStart() throws SAXException {\n        _formatHandler.startElement(Text.EMPTY, _elemName, _elemName,\n                _formatAttributes);\n        _formatAttributes.reset();\n        _elemName = null;\n    }\n",
    "124234": "    public String getBorderTitle() {\n        return fieldBorderTitle;\n    }\n",
    "124235": "\tpublic int getPrecision() {\n\t\treturn precision;\n\t}\n",
    "124236": "    protected ImportDataFrame getImportFrame() {\n        if (importFrame == null) {\n            try {\n                importFrame = new ImportDataFrame();\n                importFrame.setImportPanel(getImportPanel());\n            } catch (Throwable ex) {\n                log.error(\"Error creating import frame\", ex);\n\n            }\n        }\n        return importFrame;\n    }\n",
    "124237": "\tpublic void handleError(String msg) {\n\t\tsuper.handleError(\n\t\t\tmsg\n\t\t\t\t+ \"\\nThe previous value \"\n\t\t\t\t+ currentNumberRange\n\t\t\t\t+ \" is restored.\");\n\t\tsetNumberRange(currentNumberRange);\n\t}\n",
    "124238": "    public String getSymbolName() {\n        return (symbolDef == null) ? null : symbolDef.name;\n    }\n",
    "124241": "    public String getSymbolNameSelected() {\n        return symbolNameSelected;\n    }\n",
    "124242": "    private int nextToken() {\n        try {\n            while (true) {\n                int event = _parser.nextToken();\n                switch (event) {\n                case XmlPullParser.START_TAG:\n                case XmlPullParser.CDSECT:\n                    _isClosure = false;\n                    return event;\n                case XmlPullParser.END_TAG:\n                case XmlPullParser.END_DOCUMENT:\n                    _isClosure = true;\n                    return event;\n                case XmlPullParser.TEXT:\n                    if (!_parser.isWhitespace()) {\n                        _isClosure = false;\n                        return event;\n                    }\n                    break;\n                }\n            }\n        } catch (XmlPullParserException e) {\n            throw new XmlException(e);\n        } catch (IOException e) {\n            throw new XmlException(e);\n        }\n    }\n",
    "124243": "\tpublic void setOverallNumberRange(NumberRange newNumberRange) {\n\t\tif (newNumberRange == null)\n\t\t\tnewNumberRange = new NumberRange();\n\t\t// default constructor creates(-inf,inf)\n\n\t\toverallNumberRange = newNumberRange;\n\n\t\tif (overallNumberRange.encloses(currentNumberRange) == null) {\n\t\t\tsetNumberRange(currentNumberRange); // number is valid\n\t\t\treturn;\n\t\t}\n\n\t\t// set to default range in case of problem\n\t\tsetNumberRange(overallNumberRange.defaultNumberRange());\n\n\t}\n",
    "124244": "    private void handleException(Throwable exception) {\n\n        log.error(\"Unhandled Exception\", exception);\n    }\n",
    "124245": "\tpublic void setOverallRangeExpr(String expr) {\n\n\t\tif (expr == null || expr.length() == 0)\n\t\t\tthrow new IllegalArgumentException(\"Range expression is empty.\");\n\t\tsetOverallNumberRange(NumberRange.valueOf(expr));\n\n\t}\n",
    "124247": "\tpublic void setPrecision(int newPrecision) {\n\n\t\tif (newPrecision < 0)\n\t\t\tthrow new IllegalArgumentException(\"Negative precision argument.\");\n\n\t\tthis.precision = newPrecision;\n\n\t}\n",
    "124249": "\tpublic void setRangeBounds(String expr) {\n\n\t\tif (expr == null || expr.length() == 0)\n\t\t\tthrow new IllegalArgumentException(\"Range expression is empty.\");\n\n\t\texpr =\n\t\t\tNumberRangeTypes.CLOSED.leftBracket\n\t\t\t\t+ expr\n\t\t\t\t+ NumberRangeTypes.CLOSED.rightBracket;\n\n\t\tsetNumberRange(NumberRange.valueOf(expr));\n\n\t}\n",
    "124250": "    private void attributeSettingError() {\n        if (_formatAttributes == null)\n            throw new XmlException(\"Attributes cannot be set during parsing\");\n        if (_elemName == null)\n            throw new XmlException(\n                    \"Attributes should be set before adding nested elements\");\n        throw new XmlException();\n    }\n",
    "124255": "\tpublic void close() {\n\t\tif (isVisible()) {\n\t\t\tSwingUtilities.invokeLater(new CloseSplashScreen());\n\t\t}\n\t}\n",
    "124256": "\tpublic void setVisible(boolean show) {\n\t\tif (show) {\n\t\t\tpack();\n\n\t\t\t// Plonk it on center of screen\n\t\t\tDimension WindowSize = getSize(),\n\t\t\t\tScreenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\t\t\tsetBounds(\n\t\t\t\t(ScreenSize.width - WindowSize.width) / 2,\n\t\t\t\t(ScreenSize.height - WindowSize.height) / 2,\n\t\t\t\tWindowSize.width,\n\t\t\t\tWindowSize.height);\n\t\t}\n\t\tsuper.setVisible(show);\n\t}\n",
    "124257": "\tpublic void showStatus(String message, int percent) {\n\t\tif (isVisible()) {\n\t\t\tSwingUtilities.invokeLater(new UpdateStatus(message, percent));\n\t\t}\n\t}\n",
    "124258": "    public void setBorderTitle(String borderTitle) {\n        String oldValue = fieldBorderTitle;\n        fieldBorderTitle = borderTitle;\n        TitledBorder title = new TitledBorder(new EtchedBorder(), borderTitle,\n                TitledBorder.RIGHT, TitledBorder.TOP);\n        title.setTitleFont(new FontUIResource(\"dialog\", Font.PLAIN, 10));\n        this.setBorder(title);\n        firePropertyChange(\"borderTitle\", oldValue, borderTitle);\n    }\n",
    "124262": "    private void incompleteReadError() throws XmlPullParserException {\n        if (_parser.getEventType() == XmlPullParser.START_TAG) {\n            throw new XmlException(\"Incomplete read error (nested \"\n                    + _parser.getQName() + \" has not been read)\");\n        } else {\n            throw new XmlException(\"Incomplete read error (character data\"\n                    + \"has not been read)\");\n        }\n    }\n",
    "124267": "    public void setJSCSArray(JSCSArray dataKeys) {\n\n        if (dataKeys == null)\n            throw new IllegalArgumentException(\"Data object is null\");\n\n        Object obj[] = new Object[dataKeys.rows()];\n        for (int i = 0; i < obj.length; i++)\n            obj[i] = dataKeys.stringAt(i, 0);\n\n        setObjArray(obj);\n    }\n",
    "124269": "    public void valueChanged(SymbolEvent evt) {\n        symbol = evt.getSource();\n\n        if (symbol.isEmpty())\n            return;\n\n        if (intType)\n            setNumber(symbol.getJSCInt().doubleVal());\n        else\n            setNumber(symbol.getJSCNumber().doubleVal());\n\n    }\n",
    "124272": "    public void addNotify() {\n        super.addNotify();\n\n        setDataForSymbolName();\n    }\n",
    "124273": "    public void setSymbolName(String newSymbolName) {\n\n        if (newSymbolName == null)\n            symbolDef = null;\n        else\n            symbolDef = new JSCTypeDef(newSymbolName, JSCTypes.SARRAY);\n\n        updateSymbol();\n    }\n",
    "124274": "    protected void focusGained() {\n        super.focusGained();\n\n        if (symbol != null)\n            symbol.removeSymbolListener(this);\n\n        double lowerBound = pendingLowerBound;\n        if (symbolNameLBound != null)\n            lowerBound = getDataForSymbol(symbolNameLBound, false);\n\n        double upperBound = pendingUpperBound;\n        if (symbolNameUBound != null)\n            upperBound = getDataForSymbol(symbolNameUBound, true);\n\n        if (symbolNameLBound != null || symbolNameUBound != null)\n            setNumberRange(new NumberRange(lowerBound, upperBound,\n                    pendingRangeType));\n\n    }\n",
    "124277": "    public void setSymbolNameSelected(String newSymbolNameSelected) {\n        if (newSymbolNameSelected != null)\n            JSCConstants.checkNameThrowEx(newSymbolNameSelected);\n\n        symbolNameSelected = newSymbolNameSelected;\n\n        storeStatusToSelSymbol();\n    }\n",
    "124279": "    private void storeStatusToSelSymbol() {\n\n        if (symbolNameSelected == null)\n            return;\n\n        // Store selection to selection symbol if one is set.\n        SymbolTable sTable = symbolScope.getSymbolTable(this);\n\n        if (sTable != null)\n            sTable.set(new JSCNArray(symbolNameSelected,\n                    getIntSelectionStatus()));\n\n    }\n",
    "124284": "    private void format(Object obj, XmlFormat xmlFormat) {\n        if (_areReferencesEnabled && (xmlFormat.identifier(false) != null)) {\n            // Checks if reference exists.\n            Text ref = (Text) _objectToId.get(obj);\n            if (ref != null) { // Reference.\n                setAttribute(xmlFormat.identifier(true), ref);\n            } else { // New identifier.   \n                Text id = Text.valueOf(_objectToId.size());\n                _objectToId.put(obj, id);\n                setAttribute(xmlFormat.identifier(false), id);\n            }\n            if ((ref == null)\n                    || (_expandReferences && !_formatStack.contains(obj))) {\n                _formatStack.addLast(obj);\n                xmlFormat.format(obj, this);\n                _formatStack.removeLast();\n            }\n            return;\n        }\n        xmlFormat.format(obj, this);\n    }\n",
    "124285": "    protected String getSplashImage() {\n        return ABOUTIMAGE;\n    }\n",
    "124286": "    public int getIntNumber() {\n        return new Double(currentNumber).intValue();\n    }\n",
    "124287": "    private void updateSymbol() {\n        if (symbol != null)\n            symbol.removeSymbolListener(this);\n\n        if (symbolDef != null) {\n            SymbolTable sTable = symbolScope.getSymbolTable(this);\n            if (sTable != null) {\n                symbol = sTable.get(symbolDef);\n                setJSCSArray(symbol.getJSCSArray());\n                symbol.addSymbolListener(this);\n                return;\n            }\n        }\n\n    }\n",
    "124288": "    public double getNumber() {\n        return currentNumber;\n    }\n",
    "124289": "    public void setSymbolScope(Scope scope) {\n        if (scope == null)\n            throw new IllegalArgumentException(\"Argument was null\");\n        symbolScope = scope;\n        updateSymbol();\n    }\n",
    "124292": "    public NumberRange getNumberRange() {\n        return numberRange;\n    }\n",
    "124293": "    protected void startSplash() {\n        try {\n            URL url = getClass().getResource(getSplashImage());\n            Icon icon = null;\n            if (url != null)\n                icon = new ImageIcon(url);\n            else\n                log.error(\"About image \\\"\" + getSplashImage()\n                        + \"\\\" could not be found.\");\n            splashScreen = new SplashScreen(icon, \"Starting Up\", \"version \"\n                    + VERSION);\n            splashScreen.setVisible(true);\n        } catch (Throwable ex) {\n            log.error(\"Error creating splash screen\", ex);\n        }\n    }\n",
    "124300": "    public String getRangeExpr() {\n\n        StringBuffer ret = new StringBuffer();\n\n        ret.append(numberRange.rangeType.leftBracket);\n\n        if (symbolNameLBound != null && symbolNameLBound.length() > 0)\n            ret.append(\"\\\"\" + symbolNameLBound + \"\\\"\");\n        else\n            ret.append(numberRange.lowerBound);\n\n        ret.append(\", \");\n\n        if (symbolNameUBound != null && symbolNameUBound.length() > 0)\n            ret.append(\"\\\"\" + symbolNameUBound + \"\\\"\");\n        else\n            ret.append(numberRange.upperBound);\n\n        ret.append(numberRange.rangeType.rightBracket);\n        return ret.toString();\n    }\n",
    "124303": "    protected void adjustFrameSizeandLocation() {\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        Dimension frameSize = getSize();\n        if (frameSize.height > screenSize.height)\n            frameSize.height = screenSize.height;\n        if (frameSize.width > screenSize.width)\n            frameSize.width = screenSize.width;\n        setLocation((screenSize.width - frameSize.width) / 2,\n                (screenSize.height - frameSize.height) / 2);\n    }\n",
    "124304": "    public String getSymbolName() {\n        return symbolName;\n    }\n",
    "124306": "    public void appendWithoutScroll(final String text) {\n\n        Runnable runner = new Thread() {\n            public void run() {\n                int temp = resultTextArea.getText().length();\n                resultTextArea.append(text);\n                resultTextArea.setCaretPosition(temp);\n            }\n        };\n\n        CompSettings.syncWithSwing(runner);\n\n    }\n",
    "124308": "    public void handleError(String msg) {\n        super.handleError(msg + \"\\nThe previous value {\" + currentNumber\n                + \"} is restored.\");\n        setNumber(currentNumber);\n    }\n",
    "124310": "    public void clear() {\n        Runnable runner = new Thread() {\n            public void run() {\n                resultTextArea.setText(\"\");\n            }\n        };\n        CompSettings.syncWithSwing(runner);\n\n    }\n",
    "124313": "    public void setNumber(double val) {\n\n        String msg;\n        if ((msg = numberRange.encloses(val)) != null)\n            throw new IllegalArgumentException(msg);\n\n        double oldValue = currentNumber;\n        currentNumber = val;\n\n        setTextCarefully(UString.formatNumber(val, numberFormat, precision));\n\n        // Store data for symbol.\n        if (symbol != null) {\n            symbol.removeSymbolListener(this);\n            if (intType)\n                symbol.getJSCInt().setVal((int) currentNumber);\n            else\n                symbol.getJSCNumber().setVal(currentNumber);\n            symbol.addSymbolListener(this);\n        }\n\n        // fire property change\n        if (oldValue != currentNumber)\n            firePropertyChange(\"number\", new Double(oldValue), new Double(\n                    currentNumber));\n\n    }\n",
    "124314": "    protected MultiLineLabel getInfoArea() {\n        if (infoArea == null) {\n            infoArea = new MultiLineLabel();\n            infoArea.setText(\"version: \" + version);\n            infoArea.setHorizontalAlignment(SwingConstants.CENTER);\n            infoArea.setVerticalAlignment(SwingConstants.TOP);\n            infoArea.setMinimumSize(new Dimension(45, 30));\n            infoArea.setBackground(Color.white);\n        }\n        return infoArea;\n    }\n",
    "124317": "    public int getDefaultFontSize() {\n        return 12;\n    }\n",
    "124319": "    public int getFontSize() {\n        return resultTextArea.getFontSize();\n    }\n",
    "124323": "    public int getMaxFontSize() {\n        return maxFontSize;\n    }\n",
    "124326": "    public int getMinFontSize() {\n        return minFontSize;\n    }\n",
    "124327": "    public void setNumberRange(NumberRange newNumberRange) {\n        if (newNumberRange == null)\n            newNumberRange = new NumberRange();\n        // default constructor creates(-inf,inf)\n\n        numberRange = newNumberRange;\n\n        if (numberRange.encloses(currentNumber) == null) {\n            setNumber(currentNumber); // number is valid\n            return;\n        }\n\n        setNumber(numberRange.defaultNumber());\n\n    }\n",
    "124331": "    public JPopupMenu getPopup() {\n        return rfPopup;\n    }\n",
    "124335": "    public String getText() {\n        return resultTextArea.getText();\n    }\n",
    "124337": "\tpublic JMenuItem add(JMenuItem item) {\n\t\tsuper.add(item);\n\t\tif (item.isEnabled())\n\t\t\tsetEnabled(true);\n\t\titem.addPropertyChangeListener(this);\n\t\treturn item;\n\t}\n",
    "124338": "\tpublic void propertyChange(PropertyChangeEvent e) {\n\n\t\tif (e.getPropertyName().equals(\"enabled\")) {\n\t\t\tboolean __enabled = false;\n\t\t\tint n = getItemCount();\n\t\t\tint i = 0;\n\t\t\twhile (!__enabled && i < n) {\n\t\t\t\tJMenuItem item = getItem(i++);\n\t\t\t\tif (!item.equals(this)) {\n\t\t\t\t\t__enabled = item.isEnabled();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetEnabled(__enabled);\n\t\t}\n\t}\n",
    "124339": "    public JTextArea getTextArea() {\n\n        return resultTextArea;\n    }\n",
    "124341": "        public void removeLayoutComponent(Component child) {\n            if (child.isVisible()) {\n                Container parent = child.getParent();\n                if (parent.getComponentCount() > 0) {\n                    parent.getComponent(0).setVisible(true);\n                }\n            }\n        }\n",
    "124345": "    private Book makeBook() {\n        if (pageFormat == null) {\n            PrinterJob printJob = PrinterJob.getPrinterJob();\n            pageFormat = printJob.defaultPage();\n        }\n        Book book = new Book();\n        book.append(resultTextArea, pageFormat, resultTextArea\n                .getPageCount(pageFormat));\n        return book;\n    }\n",
    "124348": "    public void print() {\n\n        Thread printer = new Thread(new Runnable() {\n\n            public void run() {\n                PrinterJob printJob = PrinterJob.getPrinterJob();\n                printJob.setPageable(makeBook());\n                if (printJob.printDialog()) {\n                    try {\n                        printJob.print();\n                    } catch (PrinterException ex) {\n                        log.error(\"Printing error\", ex);\n                    }\n                }\n            }\n        });\n        printer.start();\n\n    }\n",
    "124349": "    public void setSymbolName(String newSymbolName) {\n        JSCConstants.checkNameThrowEx(newSymbolName);\n        symbolName = newSymbolName;\n        setDataForSymbolName();\n    }\n",
    "124350": "    protected int getVisibleChildIndex() {\n        int nChildren = getComponentCount();\n        for (int i = 0; i < nChildren; i++) {\n            Component child = getComponent(i);\n            if (child.isVisible()) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
    "124353": "    public void showCard(Component card) {\n        if (card.getParent() != this) {\n            add(card);\n        }\n        int index = getVisibleChildIndex();\n        if (index != -1) {\n            getComponent(index).setVisible(false);\n        }\n        card.setVisible(true);\n        revalidate();\n        repaint();\n    }\n",
    "124354": "    public void saveToFile() {\n        File file = FileSupport.getInstance().saveTextFile(\n                TopFrameReference.getTopFrameRef());\n        String text = resultTextArea.getText();\n        text = UString.replaceAllSubStrings(text, \"\\n\", \"\\r\\n\");\n        if (file != null)\n            FileSupport.getInstance().saveStringToFile(file, text, false);\n\n    }\n",
    "124355": "    public String validateInput() {\n        String inputString = getText().trim();\n\n        Double number = UString.parseToNumber(inputString);\n\n        if (number == null)\n            return \"Input \\\"\" + inputString + \"\\\" is not a valid number.\";\n\n        double doubleVal = number.doubleValue();\n\n        String error = null;\n        if (numberFormatType == NumberFormatTypes.DEFAULT)\n            error = numberRange.encloses(doubleVal, precision, numberFormat);\n        else\n            error = numberRange.encloses(doubleVal);\n\n        if (error != null)\n            return error;\n\n        if (numberFormatType == NumberFormatTypes.DEFAULT)\n            doubleVal = UMath.round(doubleVal, precision);\n\n        setNumber(doubleVal);\n        return null;\n\n    }\n",
    "124356": "    public void showCard(String name) {\n        int nChildren = getComponentCount();\n        for (int i = 0; i < nChildren; i++) {\n            Component child = getComponent(i);\n            if (child.getName().equals(name)) {\n                showCard(child);\n                break;\n            }\n        }\n    }\n",
    "124357": "    public void showFirstCard() {\n        if (getComponentCount() <= 0) {\n            return;\n        }\n        showCard(getComponent(0));\n    }\n",
    "124358": "    public void setEditable(final boolean newEditable) {\n\n        editable = newEditable;\n        resultTextArea.setEditable(editable);\n\n    }\n",
    "124359": "    public void showLastCard() {\n        if (getComponentCount() <= 0) {\n            return;\n        }\n        showCard(getComponent(getComponentCount() - 1));\n    }\n",
    "124361": "    public void setFontSize(final int newFontSize) {\n        Runnable runner = new Thread() {\n            public void run() {\n                resultTextArea.setFontSize(newFontSize);\n            }\n        };\n        CompSettings.syncWithSwing(runner);\n\n    }\n",
    "124362": "    public void showNextCard() {\n        if (getComponentCount() <= 0) {\n            return;\n        }\n        int index = getVisibleChildIndex();\n        if (index == -1) {\n            showCard(getComponent(0));\n        } else if (index == (getComponentCount() - 1)) {\n            showCard(getComponent(0));\n        } else {\n            showCard(getComponent(index + 1));\n        }\n    }\n",
    "124364": "    public void showPreviousCard() {\n        if (getComponentCount() <= 0) {\n            return;\n        }\n        int index = getVisibleChildIndex();\n        if (index == -1) {\n            showCard(getComponent(0));\n        } else if (index == 0) {\n            showCard(getComponent(getComponentCount() - 1));\n        } else {\n            showCard(getComponent(index - 1));\n        }\n    }\n",
    "124367": "    public void setSymbolScope(Scope scope) {\n        if (scope == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        symbolScope = scope;\n        setDataForSymbolName();\n    }\n",
    "124369": "    public void setPopup(JPopupMenu newRfPopup) {\n        rfPopup = newRfPopup;\n\n    }\n",
    "124371": "    public JSCNArray getFrameBounds() {\n        return frameBounds;\n    }\n",
    "124372": "    public void setText(final String text) {\n\n        Runnable runner = new Thread() {\n            public void run() {\n                resultTextArea.setText(text);\n            }\n        };\n\n        CompSettings.syncWithSwing(runner);\n\n    }\n",
    "124373": "    public void setFrameBounds(JSCNArray frameBounds) {\n        if (frameBounds == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.frameBounds = frameBounds;\n    }\n",
    "124374": "    public JSCInt getSplitLocation() {\n        return splitLocation;\n    }\n",
    "124375": "    public boolean isIntType() {\n        return intType;\n    }\n",
    "124377": "    public void setSplitLocation(JSCInt splitLocation) {\n        if (splitLocation == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.splitLocation = splitLocation;\n    }\n",
    "124378": "    public JSCInt getIsOutputOn() {\n        return isOutputOn;\n    }\n",
    "124379": "    public void setIsOutputOn(JSCInt isOutputOn) {\n        if (isOutputOn == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.isOutputOn = isOutputOn;\n    }\n",
    "124380": "    public boolean isAppendWithoutScroll() {\n        return appendWithoutScroll;\n    }\n",
    "124381": "\tpublic void valueChanged(SymbolEvent evt) {\n\t\tsymbol = evt.getSource();\n\t\tsetSymbolText();\n\t}\n",
    "124383": "    public void setIntType(boolean b) {\n        intType = b;\n    }\n",
    "124384": "\tpublic void addNotify() {\n\t\tsuper.addNotify();\n\t\tsetSelectionColor(getParent().getBackground());\n\t\tsetDataForSymbolName();\n\t}\n",
    "124385": "    public void setAppendWithoutScroll(boolean appendWithoutScroll) {\n        this.appendWithoutScroll = appendWithoutScroll;\n    }\n",
    "124386": "\tprivate void setDataForSymbolName() {\n\n\t\tSymbolTable sTable = null;\n\t\tif (symbolDef != null)\n\t\t\tsTable = symbolScope.getSymbolTable(this);\n\t\tSymbol newSymbol = null;\n\t\tif (sTable != null && symbolDef != null)\n\t\t\tnewSymbol = sTable.get(symbolDef);\n\n\t\t// special cases\n\t\tif (newSymbol == symbol)\n\t\t\treturn;\n\n\t\tif (symbol != null)\n\t\t\tsymbol.removeSymbolListener(this);\n\n\t\tsymbol = newSymbol;\n\n\t\tif (symbol != null)\n\t\t\tsymbol.addSymbolListener(this);\n\n\t\tsetSymbolText();\n\t}\n",
    "124387": "\tpublic JSCTypeDef getSymbolDef() {\n\t\treturn symbolDef;\n\t}\n",
    "124389": "\tpublic void setSymbolDef(JSCTypeDef newSymbolDef) {\n\t\tsymbolDef = newSymbolDef;\n\t\tsetDataForSymbolName();\n\t}\n",
    "124391": "\tprivate void setSymbolText() {\n\t\tif (symbol != null)\n\t\t\tsetText(symbol.display());\n\t\telse\n\t\t\tsetText(\"{}\");\n\n\t}\n",
    "124396": "    public JSCInt getSaveLastState() {\n        return saveLastState;\n    }\n",
    "124398": "    public JSCInt getSControlEdit() {\n        return sControlEdit;\n    }\n",
    "124400": "    public JSCInt getExitDialog() {\n        return exitDialog;\n    }\n",
    "124401": "    public JSCInt getShowExplorer() {\n        return showExplorer;\n    }\n",
    "124402": "    public void setSymbolTableNode(SymbolTableTreeNode node) {\n        symbolTableNode = node;\n        symbolTableNode.clear();\n        // put all symbols into node\n        for (Iterator iter = iterator(); iter.hasNext();) {\n            Symbol element = (Symbol) iter.next();\n            symbolTableNode.add(new SymbolTreeNode(element));\n        }\n    }\n",
    "124408": "    public SymbolTableTreeNode getSymbolTableNode() {\n        return symbolTableNode;\n    }\n",
    "124410": "    public String encloses(double number) {\n        boolean leftCheck = lowerBound < number;\n        if (!rangeType.leftOpen && !leftCheck)\n            leftCheck = lowerBound == number;\n\n        boolean rightCheck = upperBound > number;\n        if (!rangeType.rightOpen && !rightCheck)\n            rightCheck = upperBound == number;\n\n        if (leftCheck && rightCheck)\n            return null;\n        String msg = number + \" is not contained in \" + toString() + \".\";\n        return msg;\n    }\n",
    "124413": "    public void setSymbolTable(SymbolTable table) {\n        if (table == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        synchronized (this) {\n            synchronized (table) {\n\n                for (Iterator iter = table.iterator(); iter.hasNext();) {\n                    Symbol element = (Symbol) iter.next();\n                    get(new JSCTypeDef(element.NAME, element.type)).setJSCData(\n                            element.getJSCData());\n                }\n            }\n        }\n    }\n",
    "124416": "    public void addNotify() {\n        super.addNotify();\n\n        if (parentScope == null)\n            parentScope = ModelPanel.findParentScope(this);\n\n        if (parentScope == null)\n            parentScope = this;\n\n        // clear all dummy tables\n        if (preGlobalSymbolTable != null) {\n            global();\n            // inform all childs about change in table \n            updateUpperAfterNotify();\n        }\n        if (preUpperSymbolTable != null) {\n            upper();\n            // inform all childs about change in table \n            updateUpperAfterNotify();\n        }\n\n    }\n",
    "124420": "    public String encloses(NumberRange numberRange) {\n\n        boolean leftCheck = lowerBound < numberRange.lowerBound;\n\n        if (!rangeType.leftOpen && !leftCheck)\n            leftCheck = lowerBound == numberRange.lowerBound;\n\n        boolean rightCheck = upperBound > numberRange.upperBound;\n\n        if (!rangeType.rightOpen && !rightCheck)\n            rightCheck = upperBound == numberRange.upperBound;\n\n        if (leftCheck && rightCheck)\n            return null;\n        String msg = numberRange + \" is not contained in \" + toString() + \".\";\n        return msg;\n    }\n",
    "124424": "\tpublic String toString() {\n\t\treturn super.toString()\n\t\t\t+ \" [source:name=\"\n\t\t\t+ source.name()\n\t\t\t+ \",type=\"\n\t\t\t+ source.type()\n\t\t\t+ \";evttype=\"\n\t\t\t+ type\n\t\t\t+ \"]\";\n\t}\n",
    "124426": "    public boolean equals(Object o) {\n        if (!(o instanceof NumberRange))\n            return false;\n        NumberRange other = (NumberRange) o;\n\n        return lowerBound == other.lowerBound && upperBound == other.upperBound\n                && rangeType == other.rangeType;\n    }\n",
    "124430": "    public String formattedString(NumberFormat formatter) {\n\n        StringBuffer ret = new StringBuffer();\n\n        ret.append(rangeType.leftBracket);\n\n        if (formatter == null) {\n            if ((Math.rint(lowerBound) - lowerBound) == 0)\n                ret.append(new Double(lowerBound).intValue());\n            else\n                ret.append(lowerBound);\n\n        } else\n            ret.append(formatter.format(lowerBound));\n\n        ret.append(\", \");\n\n        if (formatter == null) {\n            {\n                if ((Math.rint(upperBound) - upperBound) == 0)\n                    ret.append(new Double(upperBound).intValue());\n                else\n                    ret.append(upperBound);\n            }\n        } else\n            ret.append(formatter.format(upperBound));\n\n        ret.append(rangeType.rightBracket);\n        return ret.toString();\n\n    }\n",
    "124431": "    public SymbolTable local() {\n\n        if (localSymbolTable == null) {\n            String name = getName();\n            if (name == null || name.length() < 1)\n                name = getClass().getName();\n            if (parentScope == this)\n                localSymbolTable = new SymbolTable(name, null);\n            else\n                localSymbolTable = new SymbolTable(name, upper());\n        }\n\n        return localSymbolTable;\n    }\n",
    "124432": "    public void clear() {\n        TSDateRange oldValue;\n\n        synchronized (this) {\n            if (tsRange == null) // Nothing changes.\n                return;\n\n            oldValue = tsRange;\n            tsRange = null;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, null));\n    }\n",
    "124433": "    public boolean encloses(JSCDate date) {\n\n        if (date == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (date.isEmpty())\n            throw new IllegalArgumentException(\"JSCDate arg is empty.\");\n\n        synchronized (this) {\n\n            if (isEmpty())\n                throw new IllegalArgumentException(\"JSCDateRange is empty.\");\n\n            return tsRange.encloses(date.getTSDate()) == null;\n        }\n    }\n",
    "124434": "    public void shown(boolean isShown) {\n    }\n",
    "124435": "    public double lowerBound() {\n        return lowerBound;\n    }\n",
    "124437": "    public boolean encloses(JSCDRange dRange) {\n\n        if (dRange == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (dRange.isEmpty())\n            throw new IllegalArgumentException(\"JSCDRange arg is empty.\");\n\n        synchronized (this) {\n\n            if (isEmpty())\n                throw new IllegalArgumentException(\"JSCDRange is empty.\");\n\n            return tsRange.encloses(dRange.getTSDateRange()) == null;\n        }\n    }\n",
    "124440": "    public NumberRangeTypes type() {\n        return rangeType;\n    }\n",
    "124444": "    public double upperBound() {\n        return upperBound;\n    }\n",
    "124447": "    public void clear() {\n        String oldValue;\n\n        synchronized (this) {\n            if (value == null) // Nothing changes.\n                return;\n\n            oldValue = value;\n            value = null;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, null));\n    }\n",
    "124448": "    public JSCTypes type() {\n        return JSCTypes.DRANGE;\n    }\n",
    "124449": "    public int hashCode() {\n        int result = 17;\n        long f = Double.doubleToLongBits(lowerBound);\n        result = 37 * result + (int) (f ^ (f >>> 32));\n        f = Double.doubleToLongBits(upperBound);\n        result = 37 * result + (int) (f ^ (f >>> 32));\n        result = 37 * result + rangeType.hashCode();\n        return result;\n    }\n",
    "124452": "    public void setVal(String newValue) {\n\n        if (newValue == null) {\n            clear();\n            return;\n        }\n\n        boolean wasEmpty = false;\n\n        String oldValue = null;\n        synchronized (this) {\n\n            // Nothing changed.\n            if (newValue.equals(value))\n                return;\n\n            wasEmpty = isEmpty();\n\n            // No copy needed, because Double is immutable.\n            oldValue = value;\n            value = newValue;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, newValue));\n\n        if (wasEmpty) {\n            if (notEmptyEvent == null)\n                notEmptyEvent = JSCDataEvent.valueOfEmptyState(this, false);\n            getEventSupport().dispatchEvent(notEmptyEvent);\n        }\n    }\n",
    "124455": "    public String toString() {\n        StringBuffer ret = new StringBuffer();\n        ret.append(rangeType.leftBracket);\n        if ((Math.rint(lowerBound) - lowerBound) == 0)\n            ret.append(new Double(lowerBound).intValue());\n        else\n            ret.append(lowerBound);\n        ret.append(\", \");\n        if ((Math.rint(upperBound) - upperBound) == 0)\n            ret.append(new Double(upperBound).intValue());\n        else\n            ret.append(upperBound);\n        ret.append(rangeType.rightBracket);\n        return ret.toString();\n    }\n",
    "124456": "    public JSCTypes type() {\n        return JSCTypes.STRING;\n    }\n",
    "124457": "    public void addPeriods(int i) {\n\n        TSDate oldValue = null;\n        TSDate newValue = null;\n\n        synchronized (this) {\n\n            // Nothing changed.\n            if (tsDate == null)\n                throw new IllegalStateException(\"JSCDate is empty.\");\n\n            if (i == 0)\n                return;\n\n            // No copy needed, because TSDate is immutable.\n            oldValue = tsDate;\n            tsDate = tsDate.addPeriods(i);\n            newValue = tsDate;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, newValue));\n    }\n",
    "124458": "    public JSCData getInstance() {\n        return type.valueOfEmpty(name);\n    }\n",
    "124460": "    public void clear() {\n\n        TSDate oldValue;\n\n        synchronized (this) {\n            if (tsDate == null) // Nothing changes.\n                return;\n\n            oldValue = tsDate;\n            tsDate = null;\n        }\n\n        if (eventSupport == null)\n            return;\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, null));\n    }\n",
    "124474": "    public JSCTypes type() {\n        return JSCTypes.DATE;\n    }\n",
    "124476": "    public Icon getIcon() {\n        if (icon == null) {\n            URL loc = getClass().getResource(\n                    \"/images/\" + name.toLowerCase() + \".gif\");\n            icon = (loc != null) ? new ImageIcon(loc) : null;\n        }\n        return icon;\n\n    }\n",
    "124477": "    private SymbolEventSupport getEventSupport() {\n        if (eventSupport == null)\n            eventSupport = new SymbolEventSupport();\n        return eventSupport;\n    }\n",
    "124481": "    public List getListenersForType(SymbolEventTypes evtType) {\n\n        if (eventSupport == null)\n            return new ArrayList();\n\n        return eventSupport.getListenersForType(evtType);\n    }\n",
    "124492": "    public void clear() {\n        Double oldValue;\n\n        synchronized (this) {\n            if (value == null) // Nothing changes.\n                return;\n\n            oldValue = value;\n            value = null;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, null));\n    }\n",
    "124495": "    public void setNumber(Double newValue) {\n\n        if (newValue == null) {\n            clear();\n            return;\n        }\n\n        boolean wasEmpty = false;\n\n        Double oldValue = null;\n        synchronized (this) {\n\n            // Nothing changed.\n            if (newValue.equals(value))\n                return;\n\n            wasEmpty = isEmpty();\n\n            // No copy needed, because Double is immutable.\n            oldValue = value;\n            value = newValue;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, newValue));\n\n        if (wasEmpty) {\n            if (notEmptyEvent == null)\n                notEmptyEvent = JSCDataEvent.valueOfEmptyState(this, false);\n            getEventSupport().dispatchEvent(notEmptyEvent);\n        }\n    }\n",
    "124498": "    public Object get(String key) {\n\n        if (key == null)\n            throw new IllegalArgumentException(\"Key was null.\");\n\n        synchronized (this) {\n            return valueMap.get(key);\n        }\n    }\n",
    "124499": "    public void setVal(double newDouble) {\n\n        setNumber(new Double(newDouble));\n\n    }\n",
    "124501": "    public boolean containsKey(String key) {\n        if (key == null)\n            throw new IllegalArgumentException(\"Key was null.\");\n\n        synchronized (this) {\n            return valueMap.containsKey(key);\n        }\n    }\n",
    "124502": "    public JSCTypes type() {\n        return JSCTypes.NUMBER;\n    }\n",
    "124503": "    public String toString() {\n        return name;\n    }\n",
    "124504": "    public JSCTypes type() {\n        return JSCTypes.MAP;\n    }\n",
    "124505": "    public String toString() {\n        return super.toString() + \" [source symbol:name=\" + source.NAME\n                + \",type=\" + source.type + \";evttype=\" + type + \"]\";\n    }\n",
    "124508": "    public void dispatchEvent(JSCDataEvent evt) {\n\n        if (evt == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        // No listeners at all.\n        if (typeMap == null || typeMap.size() == 0)\n            return;\n\n        // No listeners for that type.\n        if (!typeMap.containsKey(evt.getType()))\n            return;\n\n        List currentList = (ArrayList) typeMap.get(evt.getType());\n        for (int i = 0; i < currentList.size(); i++)\n            ((JSCDataListener) currentList.get(i)).valueChanged(evt);\n\n    }\n",
    "124510": "    public void removeListener(JSCDataListener evtListener) {\n\n        if (evtListener == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        // No listeners at all.\n        if (typeMap == null || typeMap.size() == 0)\n            return;\n\n        Collection lists = typeMap.values();\n        for (Iterator it = lists.iterator(); it.hasNext();) {\n            List currentList = (ArrayList) it.next();\n            currentList.remove(evtListener);\n        }\n    }\n",
    "124512": "    public String toString() {\n        StringBuffer str = new StringBuffer(super.toString() + \"\\n\");\n\n        if (typeMap == null || typeMap.size() == 0)\n            str.append(\"no listeners registered\\n\");\n        else {\n            Collection lists = typeMap.values();\n            Collection keys = typeMap.keySet();\n            for (Iterator it = lists.iterator(), kit = keys.iterator(); it\n                    .hasNext();)\n                str.append(kit.next() + \" \" + it.next() + \"\\n\");\n        }\n        return str.toString();\n\n    }\n",
    "124513": "    public void clear() {\n        Object oldValue;\n\n        synchronized (this) {\n            if (value == null) // Nothing changes.\n                return;\n\n            oldValue = value;\n            value = null;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, null));\n    }\n",
    "124518": "    public JSCTypes type() {\n        return JSCTypes.VOID;\n    }\n",
    "124519": "    private void checkIndices(int i, int j) {\n\n        if (i >= rows() || j >= cols() || i < 0 || j < 0)\n            throw new IllegalArgumentException(\"[\" + i + \",\" + j\n                    + \"] is not a valid index for \" + toString() + \".\");\n\n    }\n",
    "124523": "    public void clear() {\n        Integer oldValue;\n\n        synchronized (this) {\n            if (value == null) // Nothing changes.\n                return;\n\n            oldValue = value;\n            value = null;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, null));\n    }\n",
    "124525": "    public void clear() {\n        double[][] oldValue;\n\n        synchronized (this) {\n            if (isEmpty()) // Nothing changes.\n                return;\n\n            oldValue = value;\n            value = new double[0][0];\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, new double[0][0]));\n    }\n",
    "124528": "    public void setInt(Integer newValue) {\n\n        if (newValue == null) {\n            clear();\n            return;\n        }\n\n        boolean wasEmpty = false;\n\n        Integer oldValue = null;\n        synchronized (this) {\n\n            // Nothing changed.\n            if (newValue.equals(value))\n                return;\n\n            wasEmpty = isEmpty();\n\n            // No copy needed, because Double is immutable.\n            oldValue = value;\n            value = newValue;\n        }\n\n        // Dispatch event outside synchronized block.\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, newValue));\n\n        if (wasEmpty) {\n            if (notEmptyEvent == null)\n                notEmptyEvent = JSCDataEvent.valueOfEmptyState(this, false);\n            getEventSupport().dispatchEvent(notEmptyEvent);\n        }\n    }\n",
    "124529": "    protected JPanel getStatusBar() {\n        if (statusBar == null) {\n            try {\n                statusBar = DefaultPCallControl.getInstance();\n                statusBar.setPreferredSize(new Dimension(200, 25));\n            } catch (Throwable ex) {\n                log.error(\"Error creating status bar\", ex);\n            }\n        }\n        return statusBar;\n    }\n",
    "124530": "    public void setVal(int newInt) {\n\n        setInt(new Integer(newInt));\n\n    }\n",
    "124532": "    public JSCTypes type() {\n        return JSCTypes.INT;\n    }\n",
    "124534": "    public void addListener(SymbolListener evtListener, SymbolEventTypes evtType) {\n\n        if (evtListener == null || evtType == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (typeMap == null)\n            typeMap = new HashMap<SymbolEventTypes, List<SymbolListener>>();\n\n        List<SymbolListener> toPut = null;\n        if (!typeMap.containsKey(evtType)) { // First listener for that type.\n            toPut = new ArrayList<SymbolListener>();\n            typeMap.put(evtType, toPut);\n        } else\n            toPut = typeMap.get(evtType);\n\n        if (!toPut.contains(evtListener))\n            toPut.add(evtListener);\n    }\n",
    "124538": "    public void removeListener(SymbolListener evtListener) {\n\n        if (evtListener == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        // No listeners at all.\n        if (typeMap == null || typeMap.size() == 0)\n            return;\n\n        Collection lists = typeMap.values();\n        for (Iterator it = lists.iterator(); it.hasNext();) {\n            List currentList = (ArrayList) it.next();\n            currentList.remove(evtListener);\n        }\n    }\n",
    "124541": "    public SymbolTable global() {\n        if (symbolTable == null) {\n            String title = getTitle();\n            if (title == null || title.length() < 1)\n                title = getClass().getName();\n            symbolTable = new SymbolTable(title, null);\n\n        }\n        return symbolTable;\n    }\n",
    "124542": "    protected void addMenuBar() {\n        if (getTopFrameMenuBar() != null)\n            setJMenuBar(getTopFrameMenuBar());\n        if (getFileMenu() != null)\n            getTopFrameMenuBar().add(getFileMenu());\n        if (getModuleMenu() != null)\n            getTopFrameMenuBar().add(getModuleMenu());\n        if (getToolsMenu() != null)\n            getTopFrameMenuBar().add(getToolsMenu());\n        if (getControlMenu() != null)\n            getTopFrameMenuBar().add(getControlMenu());\n        if (getHelpMenu() != null)\n            getTopFrameMenuBar().add(getHelpMenu());\n    }\n",
    "124543": "    public SymbolTable local() {\n        return global();\n    }\n",
    "124545": "    public SymbolTable upper() {\n        return global();\n    }\n",
    "124546": "    public void setState(ProjectState state) {\n\n    }\n",
    "124547": "    public ProjectState getState() {\n        return null;\n    }\n",
    "124548": "    public String getID() {\n        return getClass().getName();\n    }\n",
    "124549": "    public void clear() {\n        String[][] oldValue;\n\n        synchronized (this) {\n            if (isEmpty()) // Nothing changes.\n                return;\n\n            oldValue = value;\n            value = new String[0][0];\n        }\n\n        // Dispatch event outside synchronized block.\n        if (clearEvent == null)\n            clearEvent = JSCDataEvent.valueOfEmptyState(this, true);\n\n        if (eventSupport == null)\n            return;\n\n        getEventSupport().dispatchEvent(clearEvent);\n        getEventSupport().dispatchEvent(\n                JSCDataEvent.valueOfChanged(this, oldValue, new String[0][0]));\n    }\n",
    "124552": "    protected void extra() {\n    }\n",
    "124556": "    private Symbol getCurrentSymbol() {\n        return currentSymbol;\n    }\n",
    "124559": "    protected void addStatusBar() {\n        if (getStatusBar() != null)\n            getContentPane().add(getStatusBar(), BorderLayout.SOUTH);\n    }\n",
    "124562": "    public void setSymbolEditable(boolean editable) {\n        getJSCSArrayTable().setEditable(editable);\n\n    }\n",
    "124563": "\tprivate void initialize() {\n\t\tthis.setBounds(31, 0, 380, 285);\n\t\tthis.setTitle(\"Save Options for Number Arrays\");\n\t\tthis.setContentPane(getJPanel());\n\t\tgetPrecision().setEnabled(false);\n\t\tgetFieldWidth().setEnabled(false);\n\t\tgetJLabel().setEnabled(false);\n\t\tgetJLabel1().setEnabled(false);\n\n\t}\n",
    "124567": "    protected void addToolBar() {\n        if (getToolBar() != null)\n            getContentPane().add(getToolBar(), BorderLayout.NORTH);\n    }\n",
    "124569": "\tprivate NumSelector getPrecision() {\n\t\tif (numberSelector == null) {\n\t\t\tnumberSelector = new NumSelector();\n\t\t\tnumberSelector.setNumber(6.0);\n\t\t\tnumberSelector.setNumberRange(\n\t\t\t\tnew NumberRange(0, 100, NumberRangeTypes.CLOSED));\n\t\t\tnumberSelector.setPreferredSize(new java.awt.Dimension(40, 20));\n\t\t\tnumberSelector.setEnabled(false);\n\t\t}\n\t\treturn numberSelector;\n\t}\n",
    "124570": "\tprivate NumSelector getFieldWidth() {\n\t\tif (numberSelector1 == null) {\n\t\t\tnumberSelector1 = new NumSelector();\n\t\t\tnumberSelector1.setNumber(10.0);\n\t\t\tnumberSelector1.setNumberRange(\n\t\t\t\tnew NumberRange(2, 102, NumberRangeTypes.CLOSED));\n\t\t\tnumberSelector1.setPreferredSize(new java.awt.Dimension(40, 20));\n\t\t\tnumberSelector1.setEnabled(false);\n\t\t}\n\t\treturn numberSelector1;\n\t}\n",
    "124571": "\tpublic int getPrec() {\n\t\treturn getPrecision().getIntNumber();\n\t}\n",
    "124572": "\tpublic int getFWidth() {\n\t\treturn getFieldWidth().getIntNumber();\n\t}\n",
    "124574": "\tpublic boolean isTransposed() {\n\t\treturn getTransposedCheckBox().isSelected();\n\t}\n",
    "124577": "\tpublic boolean isRaw() {\n\t\treturn getRawCheckBox().isSelected();\n\t}\n",
    "124578": "\tpublic boolean isInfo() {\n\t\treturn getInfoCheckBox().isSelected();\n\t}\n",
    "124582": "\tpublic void addSymbolTable(SymbolTable symbolTable) {\n\t\tif (symbolTable == null)\n\t\t\tthrow new IllegalArgumentException(\"Argument was null.\");\n\n\t\t// manages adding/removing itself\n\t\tnew SymbolTableTreeNode(symbolTable, symbolTreeModel);\n\t\t\n\t}\n",
    "124583": "    public void valueChanged(SymbolEvent evt) {\n        setSymbol(evt.getSource());\n    }\n",
    "124584": "\tpublic void valueChanged(SymbolEvent evt) {\n\t\tSymbolTree.getInstance().repaint();\n\t}\n",
    "124588": "    public void setFormatString(String newFormatString) {\n        try {\n            FArg.sprintf(newFormatString, new FArg(0.0)); // For testing.\n        } catch (Throwable thr) {\n            throw new IllegalArgumentException(\"\\\"\" + newFormatString\n                    + \"\\\" is not a valid format string.\");\n        }\n        formatString = newFormatString;\n    }\n",
    "124589": "    public void setDataEditable(boolean editable) {\n        for (SymbolPanel val : symbolPanelMap.values())\n            val.setSymbolEditable(editable);\n\n    }\n",
    "124590": "    public void setFormatString(String newFormatString) {\n        try {\n            FArg.sprintf(newFormatString, new FArg(\"test\")); // For testing.\n        } catch (Throwable thr) {\n            throw new IllegalArgumentException(\"\\\"\" + newFormatString\n                    + \"\\\" is not a valid format string.\");\n        }\n        formatString = newFormatString;\n    }\n",
    "124591": "    private void initialize() {\n        this.setLayout(new java.awt.BorderLayout());\n        this.add(getResultField(), java.awt.BorderLayout.CENTER);\n        this.setSize(400, 236);\n        setBorder(new TitledBorder(new BevelBorder(BevelBorder.LOWERED),\n                \"Value\", TitledBorder.RIGHT, TitledBorder.TOP));\n        getResultField().setText(\"\");\n        getResultField().getTextArea().setBackground(Color.LIGHT_GRAY);\n    }\n",
    "124599": "    public void setTopModuleByName(String moduleTitle) {\n        if (moduleTitle == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        for (int i = 0; i < moduleFrames.size(); i++) {\n            Object o = moduleFrames.get(i);\n            if (o instanceof JInternalFrame) {\n                JInternalFrame frame = (JInternalFrame) o;\n                if (moduleTitle.equals(frame.getTitle())) {\n                    handleView(frame);\n                    return;\n                }\n            }\n        }\n    }\n",
    "124600": "    public void clear() {\n        if (getChildCount() == 0)\n            return;\n\n        for (int i = 0; i < getChildCount(); i++) {\n            Object item = getChildAt(i);\n            if (item instanceof SymbolTreeNode)\n                remove(i--);\n        }\n        boolean alreadUpdated = false; // economize updates\n        if (getChildCount() == 0)\n            parent.remove(this);\n\n        if (parent instanceof SymbolTableTreeNode)\n            alreadUpdated = ((SymbolTableTreeNode) parent).updateAfterRemove();\n\n        if (!alreadUpdated)\n            reloadInEDT();\n\n    }\n",
    "124601": "    private boolean updateAfterAdd() {\n\n        // checks whether parent was empty before child was added\n        boolean wasEmpty = getChildCount() == 1;\n        boolean alreadUpdated = false; // economize updates\n\n        if (wasEmpty) {\n            addSymbolTableNode(this, parent);\n            // recurse upwards\n            if (parent instanceof SymbolTableTreeNode)\n                alreadUpdated = ((SymbolTableTreeNode) parent).updateAfterAdd();\n            if (!alreadUpdated)\n                symbolTreeModel.reload(parent);\n            return true;\n        }\n        return false;\n\n    }\n",
    "124603": "    private boolean updateAfterRemove() {\n\n        boolean empty = (getChildCount() == 0);\n        boolean alreadUpdated = false; // economize updates\n\n        if (empty) {\n            parent.remove(this);\n            // recurse upwards\n            if (parent instanceof SymbolTableTreeNode)\n                alreadUpdated = ((SymbolTableTreeNode) parent)\n                        .updateAfterRemove();\n            if (!alreadUpdated)\n                reloadInEDT();\n\n            return true;\n        }\n        return false;\n\n    }\n",
    "124604": "    private void reloadInEDT() {\n        if (SwingUtilities.isEventDispatchThread())\n            symbolTreeModel.reload(parent);\n        else {\n            Runnable runner = new Runnable() {\n\n                public void run() {\n                    symbolTreeModel.reload(parent);\n                }\n            };\n            SwingUtilities.invokeLater(runner);\n        }\n\n    }\n",
    "124608": "    public void setTopFrameSettings(TopFrameSettings settings) {\n        if (settings == null)\n            return;\n        int[][] bounds = settings.getFrameBounds().intArray();\n        if (bounds.length == 4) {\n            Rectangle rec = new Rectangle(bounds[0][0], bounds[1][0],\n                    bounds[2][0], bounds[3][0]);\n            setBounds(rec);\n        }\n        int loc = settings.getSplitLocation().intVal();\n        getSplitPane().setDividerLocation(loc);\n\n        int isToggle = settings.getIsOutputOn().intVal();\n        if (isToggle != 0 != getOutputToggleButton().isSelected())\n            getOutputToggleButton().doClick();\n\n    }\n",
    "124617": "    public void setValAt(String val, int i, int j) {\n        String oldVal;\n        synchronized (this) {\n\n            checkIndices(i, j);\n            oldVal = value[i][j];\n            value[i][j] = val;\n\n        }\n        if (eventSupport == null)\n            return;\n\n        // Fire event outside synchronized block.\n        if (!oldVal.equals(val)) {\n            Integer intI = new Integer(i);\n            Integer intJ = new Integer(j);\n            getEventSupport().dispatchEvent(\n                    JSCDataEvent.valueOfChanged(this, new Object[] { oldVal,\n                            intI, intJ }, new Object[] { val, intI, intJ }));\n        }\n    }\n",
    "124620": "    public void setSymbolEditable(boolean editable) {\n        getJSCNArrayTable().setEditable(editable);\n\n    }\n",
    "124622": "    public TopFrameSettings getTopFrameSettings() {\n        TopFrameSettings settings = new TopFrameSettings();\n        Rectangle rec = getBounds();\n        JSCNArray bounds = new JSCNArray(\"bounds\", new double[] { rec.getX(),\n                rec.getY(), rec.getWidth(), rec.getHeight() });\n        settings.setFrameBounds(bounds);\n\n        int divider = getSplitPane().getDividerLocation();\n        JSCInt div = new JSCInt(\"split\", divider);\n        settings.setSplitLocation(div);\n\n        JSCInt output = new JSCInt(\"output\", getOutputToggleButton()\n                .isSelected());\n        settings.setIsOutputOn(output);\n\n        return settings;\n    }\n",
    "124623": "    public JSCTypes type() {\n        return JSCTypes.SARRAY;\n    }\n",
    "124625": "    public Object getJSCProperty(JSCPropertyTypes type) {\n\n        if (type == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (getPropertyMap().containsKey(type))\n            return getPropertyMap().get(type);\n        return null;\n    }\n",
    "124627": "    public void setJSCProperty(JSCPropertyTypes type, Object val) {\n\n        if (type == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        getPropertyMap().put(type, val);\n    }\n",
    "124631": "    public void addProjectData(ProjectData pData) {\n        if (pData == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        if (!projectDataList.contains(pData))\n            projectDataList.add(pData);\n    }\n",
    "124633": "    public void addOutputData(OutputData outputData) {\n        if (outputData == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        outputDataList.add(outputData);\n    }\n",
    "124636": "    public void addProjectState(ProjectState projectState) {\n        if (projectState == null)\n            return;\n        projectStatesList.add(projectState);\n    }\n",
    "124637": "    public Iterator getOutputDataIterator() {\n        return outputDataList.iterator();\n    }\n",
    "124639": "    public Iterator getProjectDataIterator() {\n        return projectDataList.iterator();\n    }\n",
    "124642": "    public Iterator getProjectStatesIterator() {\n        return projectStatesList.iterator();\n    }\n",
    "124644": "    public Date getDate() {\n        return date;\n    }\n",
    "124650": "    public String getCurrentModuleFrame() {\n        return currentModuleFrame;\n    }\n",
    "124653": "    public void setCurrentModuleFrame(String currentModuleFrame) {\n        if (currentModuleFrame == null)\n            return;\n        this.currentModuleFrame = currentModuleFrame;\n    }\n",
    "124660": "    public void setVal(Matrix mat) {\n        setVal(mat.getArray());\n    }\n",
    "124663": "    public int hashCode() {\n        return projectFile.hashCode();\n    }\n",
    "124664": "    public void removeSelected() {\n        int index[] = getSelectedIndices();\n        Arrays.sort(index);\n        for (int i = index.length - 1; i >= 0; i--)\n            model.remove(index[i]);\n    }\n",
    "124665": "    public String toString() {\n        String proj = name;\n        return proj + \" <\" + CompSettings.getDefaultDateFormat().format(date)\n                + \">\";\n    }\n",
    "124667": "    public void removeAll() {\n        model.clear();\n    }\n",
    "124668": "    public void setElement() {\n        currentProject = false;\n        if (projectFile != null && projectFile.canRead())\n            ProjectTree.getInstance().addProjectNode(this);\n    }\n",
    "124669": "    private void sortKeepSelection(Comparator< ? super Object> comparator) {\n        Object[] listElements = new Object[model.size()];\n        model.copyInto(listElements);\n        // remember selection\n        for (int i = 0; i < model.size(); i++)\n            ((OutputData) listElements[i]).selected = isSelectedIndex(i);\n        // sort elements\n        Arrays.sort(listElements, comparator);\n        int[] selection = getSelectedIndices();\n        model.clear();\n        // put elements back, get new indices of previously selected items\n        for (int i = 0, k = 0; i < listElements.length; i++) {\n            if (((OutputData) listElements[i]).selected)\n                selection[k++] = i;\n            model.addElement(listElements[i]);\n        }\n        // set selection again\n        setSelectedIndices(selection);\n    }\n",
    "124671": "    public void setProjectData(ProjectData data) {\n        if (data == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        ProjectDataHandler handler = handlerMap.get(data.getProjectDataType());\n        handler.setProjectData(data);\n    }\n",
    "124672": "    public void register(ProjectDataHandler handler) {\n        if (handler == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (handlerMap.containsKey(handler.getProjectDataType()))\n            throw new IllegalStateException(\n                    \"An instance of ProjectDataHandler for the type \\\"\"\n                            + handler.getProjectDataType()\n                            + \"\\\" has already been registered.\");\n        handlerMap.put(handler.getProjectDataType(), handler);\n\n    }\n",
    "124673": "    public void sortByTime() {\n        if (sortByTime)\n            return;\n        sortByTime = true;\n        sortKeepSelection(OutputListComparators.ByTimeComparator);\n\n    }\n",
    "124676": "    public void sortByName() {\n        if (!sortByTime)\n            return;\n        sortByTime = false;\n        sortKeepSelection(OutputListComparators.ByNameComparator);\n    }\n",
    "124681": "    public boolean isSortByTime() {\n        return sortByTime;\n    }\n",
    "124682": "    public void setValAt(double val, int i, int j) {\n\n        double oldVal;\n        synchronized (this) {\n\n            checkIndices(i, j);\n            oldVal = value[i][j];\n            value[i][j] = val;\n\n        }\n        if (eventSupport == null)\n            return;\n\n        // Fire event outside synchronized block.\n        if (Double.doubleToLongBits(oldVal) != Double.doubleToLongBits(val)) {\n            getEventSupport().dispatchEvent(\n                    JSCDataEvent.valueOfChanged(this, new double[] { oldVal, i,\n                            j }, new double[] { val, i, j }));\n        }\n    }\n",
    "124685": "    public void setSortByTime(boolean sortByTime) {\n        this.sortByTime = sortByTime;\n    }\n",
    "124687": "    public void setParent(JFrame parent) {\n        this.parent = parent;\n    }\n",
    "124689": "    public void removeTreeNode(MutableTreeNode node) {\n        if (node == null)\n            return;\n        projectTreeModel.removeNodeFromParent(node);\n        projectList.remove(node);\n\n    }\n",
    "124690": "    public boolean isOutputHistory() {\n        return isOutputHistory;\n    }\n",
    "124691": "    public void addModuleNode(ModuleTreeNode node) {\n        if (node == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        boolean inserted = false;\n        for (int i = 0; i < ROOT.getChildCount(); i++) {\n            Object item = ROOT.getChildAt(i);\n            if (item instanceof ModuleTreeNode) {\n                ModuleTreeNode mNode = (ModuleTreeNode) item;\n                if (mNode.getName().compareTo(node.getName()) >= 0) {\n                    ROOT.insert(node, i);\n                    inserted = true;\n                    break;\n                }\n            } else {\n                ROOT.insert(node, i);\n                inserted = true;\n                break;\n            }\n        }\n        if (!inserted)\n            ROOT.add(node);\n\n        projectTreeModel.reload();\n    }\n",
    "124692": "    public void setOutputHistory(boolean isOutputHistory) {\n        this.isOutputHistory = isOutputHistory;\n    }\n",
    "124694": "    public String getToolTipText() {\n        return super.getToolTipText();\n    }\n",
    "124697": "    private void initialize() {\n        this.setLayout(new java.awt.BorderLayout());\n        this.setSize(488, 445);\n        this.add(getResultField(), java.awt.BorderLayout.CENTER);\n\n    }\n",
    "124699": "    public void setOutput(OutputData[] dataArray) {\n        if (dataArray == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        getResultField().clear();\n        for (int i = 0; i < dataArray.length; i++) {\n            if (dataArray[i] != null)\n                getResultField().append(dataArray[i].output);\n        }\n    }\n",
    "124706": "    public void setCurrentNode(ProjectTreeNode currentNode) {\n        boolean lastState = currentNode.isLastState();\n        save.setEnabled(!lastState);\n        edit.setEnabled(!lastState);\n\n        this.currentNode = currentNode;\n    }\n",
    "124708": "    public void addProjectStateHandler(ProjectStateHandler handler) {\n        if (handler == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        handlerMap.put(handler.getID(), handler);\n        if (projectStatesMap.containsKey(handler.getID()))\n            try {\n                handler.setState(projectStatesMap.get(handler.getID()));\n            } catch (Throwable t) {\n                log.error(\"Failed to set state for handler ID:\"\n                        + handler.getID(), t);\n            }\n    }\n",
    "124709": "    public String toString() {\n        return DES_NAME;\n    }\n",
    "124712": "    public void addSettingsElement(SettingsElement el) {\n        if (el == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        settingsList.add(el);\n    }\n",
    "124713": "    public ProjectTreeNode getProjectNode() {\n        return treeNode;\n    }\n",
    "124714": "    public void setTopFrame(TopFrame topFrame) {\n        this.topFrame = topFrame;\n    }\n",
    "124715": "\tpublic String getName() {\n\t\treturn (String) action.getValue(Action.NAME);\n\t}\n",
    "124716": "\tpublic String toString() {\n\t\treturn action.getValue(Action.NAME) + \"\";\n\t}\n",
    "124717": "\tpublic void doAction() {\n\t\taction.actionPerformed(null);\n\t}\n",
    "124718": "    public void restoreSettings() {\n\n        // restore settings\n        ObjectReader constructor = new ObjectReader();\n        File file = new File(settingsPath);\n        if (!file.canRead())\n            return;\n        Settings settings = null;\n        try {\n            settings = (Settings) constructor.read(new FileInputStream(file));\n        } catch (Throwable t) {\n            log.error(\"Failed to read settings from \" + file.getAbsolutePath(),\n                    t);\n            return;\n        }\n        for (Iterator iter = settings.getSettingsIterator(); iter.hasNext();) {\n            SettingsElement element = (SettingsElement) iter.next();\n            element.setElement();\n        }\n    }\n",
    "124720": "    public TopFrame getTopFrame() {\n        return topFrame;\n    }\n",
    "124721": "    private void initialize() {\n        this\n                .setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);\n        this.setContentPane(getJPanel());\n        this.setTitle(\"Edit Project Settings\");\n        this.setSize(716, 563);\n        setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n\n    }\n",
    "124722": "    public void saveLastState() {\n        // save last state\n        ProjectManager.getInstance().serializeProject(\n                new File(LAST_STATE_PATH), \"LAST STATE\", null);\n    }\n",
    "124723": "    public void restoreLastState() {\n        // restore last state\n        File lastStateFile = new File(LAST_STATE_PATH);\n        if (lastStateFile.canRead()) {\n            ProjectTreeNode node = ProjectManager.getInstance()\n                    .deSerializeProject(lastStateFile);\n            node.setLastState(true);\n        }\n\n    }\n",
    "124724": "    public void addClassTransformation(String oldClassName, String newClassName) {\n        XmlFormat.addClassTransformation(oldClassName, newClassName);\n    }\n",
    "124725": "    private JPanel getJPanel() {\n        if (jPanel == null) {\n            jPanel = new JPanel();\n            jPanel.setLayout(new BorderLayout());\n            jPanel.add(getJPanel1(), java.awt.BorderLayout.SOUTH);\n            jPanel.add(getJPanel2(), java.awt.BorderLayout.CENTER);\n        }\n        return jPanel;\n    }\n",
    "124726": "    public JSCTypes type() {\n        return JSCTypes.NARRAY;\n    }\n",
    "124730": "    private JPanel getJPanel1() {\n        if (jPanel1 == null) {\n            FlowLayout flowLayout1 = new FlowLayout();\n            jPanel1 = new JPanel();\n            jPanel1.setLayout(flowLayout1);\n            jPanel1.setPreferredSize(new java.awt.Dimension(10, 50));\n            flowLayout1.setHgap(100);\n            flowLayout1.setVgap(10);\n            jPanel1.add(getJButton(), null);\n            jPanel1.add(getJButton1(), null);\n        }\n        return jPanel1;\n    }\n",
    "124742": "    protected TableModel createDefaultDataModel() {\n        return new JSCNArrayTableModel(null);\n    }\n",
    "124743": "    public boolean isEditable() {\n        return isEditable;\n    }\n",
    "124747": "    public void setNumberRange(NumberRange range) {\n        numberRange = range;\n    }\n",
    "124748": "    public void setEditable(boolean editable) {\n        isEditable = editable;\n        if (getModel() instanceof JSCAbstractTableModel)\n            ((JSCAbstractTableModel) getModel()).setEditable(isEditable);\n    }\n",
    "124749": "    public void syncWithScrollPane(JScrollPane sp) {\n        super.syncWithScrollPane(sp);\n\n        getVerticalScrollBar().firePropertyChange(\n                \"JScrollBar.isFreeStanding\", false, true);\n        getHorizontalScrollBar().firePropertyChange(\n                \"JScrollBar.isFreeStanding\", false, true);\n    }\n",
    "124755": "    public void setPrecision(int precision) {\n        this.precision = precision;\n        // called to update the column width as well\n        updateUI();\n    }\n",
    "124757": "    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        if (!(aValue instanceof Double))\n            throw new IllegalArgumentException(\"Value at [\" + rowIndex + \":\"\n                    + columnIndex + \"] is not a Double.\");\n        if (getCurrentSymbol() == null || getCurrentSymbol().isEmpty())\n            throw new IllegalStateException(\"Symbol is empty or null.\");\n\n        getCurrentSymbol().getJSCNArray().setValAt(\n                ((Double) aValue).doubleValue(), rowIndex, columnIndex);\n\n    }\n",
    "124758": "    public JSCNArray getJSCNArray() {\n        return (JSCNArray) getJSCData();\n    }\n",
    "124761": "    public void setSymbolName(String symbolName) {\n        JSCConstants.checkNameThrowEx(symbolName);\n        this.symbolName = symbolName;\n        if (symbolTable != null)\n            setModelForSymbolName(symbolTable, symbolName);\n        else {\n            SymbolTable sTableFromScope = symbolScope.getSymbolTable(this);\n            if (sTableFromScope != null)\n                setModelForSymbolName(sTableFromScope, symbolName);\n        }\n    }\n",
    "124764": "    private JButton getJButton1() {\n        if (jButton1 == null) {\n            jButton1 = new JButton();\n            jButton1.setText(\"Cancel\");\n            jButton1.setPreferredSize(new java.awt.Dimension(100, 26));\n            jButton1.addActionListener(new java.awt.event.ActionListener() {\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    cancelled = true;\n                    treeNode = null;\n                    setVisible(false);\n                }\n            });\n        }\n        return jButton1;\n    }\n",
    "124765": "    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        if (aValue == null)\n            throw new IllegalArgumentException(\"Value at [\" + rowIndex + \":\"\n                    + columnIndex + \"] is null.\");\n\n        if (getCurrentSymbol() == null || getCurrentSymbol().isEmpty())\n            throw new IllegalStateException(\"Symbol is empty or null.\");\n\n        if (isTransposed())\n            getCurrentSymbol().getJSCSArray().setValAt(aValue.toString(),\n                    columnIndex, rowIndex);\n        else\n            getCurrentSymbol().getJSCSArray().setValAt(aValue.toString(),\n                    rowIndex, columnIndex);\n\n    }\n",
    "124766": "    public int columnAtPoint(Point point) {\n        point.x -= _insets.left;\n        return super.columnAtPoint(point);\n    }\n",
    "124768": "    public void createDefaultColumnsFromModel() {\n        super.createDefaultColumnsFromModel();\n        setColumnWidth(columnWidth);\n    }\n",
    "124770": "    public void setSymbolScope(Scope scope) {\n        if (scope == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        symbolScope = scope;\n        symbolTable = null;\n\n        // update because of new scope and only if table was not explicitely set\n        SymbolTable sTableFromScope = symbolScope.getSymbolTable(this);\n        if (sTableFromScope != null && symbolName != null)\n            setModelForSymbolName(sTableFromScope, symbolName);\n        updateSelectionData();\n\n    }\n",
    "124772": "    public Rectangle getCellRect(int row, int column, boolean includeSpacing) {\n        Rectangle r = super.getCellRect(row, column, includeSpacing);\n        if (_insets != null) {\n            r.x += _insets.left;\n            r.y += _insets.top;\n        }\n        return r;\n    }\n",
    "124774": "    public int getColumnWidth() {\n        return columnWidth;\n    }\n",
    "124775": "    public void updateUI() {\n        // Update the UIs of the cell renderers, cell editors and header\n        // renderers.\n        if (cellRenderer != null)\n            ((JComponent) cellRenderer).updateUI();\n        if (cellEditor != null)\n            ((JComponent) ((DefaultCellEditor) cellEditor).getComponent())\n                    .updateUI();\n        setUI((TableUI) UIManager.getUI(this));\n\n        if (isDynamicColumnWidth())\n            setColumnWidth(maxCellLength());\n\n        if (enclosingScrollPane != null) {\n            enclosingScrollPane.setColumnHeaderCellRenderer(enclosingScrollPane\n                    .getColumnHeaderCellRenderer());\n        }\n\n        resizeAndRepaint();\n    }\n",
    "124776": "    public int getMaximumColumnWidth() {\n        return maximumColumnWidth;\n    }\n",
    "124780": "    public MouseListener getMouseListener() {\n        return mouseListener;\n    }\n",
    "124782": "    public int getMinimumColumnWidth() {\n        return minimumColumnWidth;\n    }\n",
    "124784": "    public void setMouseListener(MouseListener listener) {\n        if (mouseListener != null)\n            removeMouseListener(mouseListener);\n\n        mouseListener = listener;\n\n        if (mouseListener != null)\n            addMouseListener(mouseListener);\n    }\n",
    "124785": "    public Dimension getMinimumSize() {\n        return getPreferredSize();\n    }\n",
    "124787": "    public Dimension getPreferredSize() {\n        if (!isVisible())\n            return new Dimension(0, 0);\n\n        Dimension d = super.getPreferredSize();\n        d.width += _insets.left + _insets.right;\n        d.height += _insets.bottom;\n        return d;\n    }\n",
    "124788": "    public TableCellRenderer getCellRenderer() {\n        return cellRenderer;\n    }\n",
    "124790": "    public boolean isDynamicColumnWidth() {\n        return dynamicColumnWidth;\n    }\n",
    "124791": "    private JTextField getProjectNameField() {\n        if (projectNameField == null) {\n            projectNameField = new JTextField();\n        }\n        return projectNameField;\n    }\n",
    "124793": "    public int maxCellLength() {\n        int cols = getColumnCount();\n        int maxWidth = 0;\n        for (int i = 0; i < cols; i++)\n            maxWidth = Math.max(maxWidth, maxCellLengthInColumn(i));\n\n        return maxWidth;\n    }\n",
    "124794": "    public void setCellRenderer(TableCellRenderer renderer) {\n        cellRenderer = renderer;\n        TableModel m = getModel();\n        if (m != null) {\n            TableColumnModel cm = getColumnModel();\n            int n = cm.getColumnCount();\n            for (int i = 0; i < n; i++) {\n                TableColumn tc = cm.getColumn(i);\n                tc.setCellRenderer(cellRenderer);\n            }\n        }\n        updateUI();\n    }\n",
    "124795": "    private int maxCellLengthInColumn(int col) {\n        TableCellRenderer renderer = null;\n        if (getModel().getRowCount() > 0)\n            renderer = getCellRenderer(0, col);\n        else\n            renderer = getDefaultRenderer(getModel().getColumnClass(col));\n\n        int rows = getRowCount();\n        int maxWidth = 0;\n\n        Component c;\n\n        for (int i = 0; i < rows; i++) {\n            if (col < getModel().getColumnCount()) {\n                c = prepareRenderer(renderer, i, col);\n                maxWidth = Math.max(maxWidth, c.getPreferredSize().width);\n            }\n        }\n        maxWidth += 2 * getIntercellSpacing().width;\n\n        return maxWidth + 5;\n    }\n",
    "124797": "    private JTextField getFileNameField() {\n        if (fileNameField == null) {\n            fileNameField = new JTextField();\n        }\n        return fileNameField;\n    }\n",
    "124801": "    public int rowAtPoint(Point point) {\n        point.y -= _insets.top;\n        return super.rowAtPoint(point);\n    }\n",
    "124802": "    public void setTablePopup(JPopupMenu menu) {\n        tablePopup = menu;\n        if (tablePopup == null)\n            removeMouseListener(triggerPopUp);\n        else {\n            triggerPopUp = new MouseAdapter() {\n                public void mouseReleased(MouseEvent e) {\n                    tablePopup.processMouseEvent(e, null, null);\n                }\n            };\n            addMouseListener(triggerPopUp);\n        }\n    }\n",
    "124803": "    public boolean isCancelled() {\n        return cancelled;\n    }\n",
    "124805": "    public void setBorder(Border border) {\n        Border oldBorder = getBorder();\n        if (oldBorder == null)\n            super.setBorder(border);\n        else\n            super.setBorder(new CompoundBorder(border, borderTableBorder));\n        ((AbstractBorder) getBorder()).getBorderInsets(this, _insets);\n    }\n",
    "124810": "    public void setDynamicColumnWidth(boolean newDynamicColumnWidth) {\n        dynamicColumnWidth = newDynamicColumnWidth;\n    }\n",
    "124813": "    public void setIntercellSpacing(Dimension newSpacing) {\n        Dimension oldSpacing = getColumnModel() == null ? new Dimension(0,\n                getRowMargin()) : getIntercellSpacing();\n        super.setIntercellSpacing(newSpacing);\n        updateRect00();\n        firePropertyChange(\"intercellSpacing\", oldSpacing, newSpacing);\n    }\n",
    "124814": "    private ResultField getDataDesField() {\n        if (dataDesField == null) {\n            dataDesField = new ResultField();\n        }\n        return dataDesField;\n    }\n",
    "124815": "    public void setJSCData(JSCData data) {\n        setSymbolName(null);\n        setModelForJSCData(data);\n    }\n",
    "124817": "    public void setMaximumColumnWidth(int newMaximumColumnWidth) {\n        maximumColumnWidth = Math\n                .max(minimumColumnWidth, newMaximumColumnWidth);\n    }\n",
    "124819": "    public void setMinimumColumnWidth(int newMinimumColumnWidth) {\n        minimumColumnWidth = Math\n                .min(newMinimumColumnWidth, maximumColumnWidth);\n    }\n",
    "124821": "    private ResultField getProjectDesArea() {\n        if (projectDesArea == null) {\n            projectDesArea = new ResultField();\n            projectDesArea.setPreferredSize(new java.awt.Dimension(150, 100));\n        }\n        return projectDesArea;\n    }\n",
    "124822": "    public void tableChanged(TableModelEvent e) {\n        super.tableChanged(e);\n\n        if (isDynamicColumnWidth()) {\n            int col = e.getColumn();\n            if (col < 0 || e.getType() == TableModelEvent.DELETE)\n                setColumnWidth(maxCellLength());\n            else {\n                int maybeNewWidth = maxCellLengthInColumn(col);\n                if (columnWidth < maybeNewWidth)\n                    setColumnWidth(maybeNewWidth);\n                else\n                    setColumnWidth(maxCellLength());\n\n            }\n        }\n    }\n",
    "124824": "    public void setModel(TableModel model) {\n        super.setModel(model);\n        if (getModel() instanceof JSCAbstractTableModel) {\n            JSCAbstractTableModel m = (JSCAbstractTableModel) getModel();\n            m.setEditable(isEditable);\n            m.setColEditableMap(colIndexEditableMap);\n            m.setRowEditableMap(rowIndexEditableMap);\n        }\n\n        firePropertyChange(\"model\", null, model);\n    }\n",
    "124825": "    private void updateRect00() {\n        if (getColumnCount() > 0 && getRowCount() > 0)\n            rect00 = getCellRect(0, 0, true);\n    }\n",
    "124826": "public Insets getBorderInsets(Component c) {\n    return new Insets(topInset, leftInset, bottomInset, rightInset);\n}\n",
    "124828": "    private JButton getBrowseButton() {\n        if (browseButton == null) {\n            browseButton = new JButton();\n            browseButton.setText(\"Browse...\");\n            browseButton.setPreferredSize(new java.awt.Dimension(100, 26));\n            browseButton.addActionListener(new java.awt.event.ActionListener() {\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    File file = FileSupport.getInstance().saveProjectFile(\n                            ProjectDialog.this);\n                    if (file != null)\n                        getFileNameField().setText(file.getAbsolutePath());\n                }\n            });\n        }\n        return browseButton;\n    }\n",
    "124829": "public Insets getBorderInsets(Component c, Insets insets) {\n    insets.left = leftInset;\n    insets.top = topInset;\n    insets.right = rightInset;\n    insets.bottom = bottomInset;\n    return insets;\n}\n",
    "124830": "    public SymbolTable getSymbolTable() {\n        return symbolTable;\n    }\n",
    "124835": "    public void setSymbolTable(SymbolTable table) {\n\n        // nothing to do\n        if (table == symbolTable)\n            return;\n\n        symbolTable = table;\n\n        if (table == null) {\n            SymbolTable sTableFromScope = symbolScope.getSymbolTable(this);\n            if (sTableFromScope != null && symbolName != null)\n                setModelForSymbolName(sTableFromScope, symbolName);\n        }\n\n        // set a new model\n        if (table != null && symbolName != null)\n            setModelForSymbolName(table, symbolName);\n\n        updateSelectionData();\n\n    }\n",
    "124847": "    public void actionPerformed(ActionEvent evt) {\n\n    }\n",
    "124851": "    public JSCSArray getJSCSArray() {\n        return (JSCSArray) getJSCData();\n    }\n",
    "124853": "    public void setRowSelectionMode(int newRowSelMode) {\n        getSelectionModel().setSelectionMode(newRowSelMode);\n    }\n",
    "124854": "    public boolean isDisplayTransposed() {\n        return isTransposed;\n    }\n",
    "124856": "    public void setDisplayTransposed(boolean transposed) {\n        if (getModel() instanceof JSCAbstractTableModel)\n            ((JSCSArrayTableModel) getModel()).setTransposed(transposed);\n        isTransposed = transposed;\n    }\n",
    "124859": "    public int getRowSelectionMode() {\n        return getSelectionModel().getSelectionMode();\n    }\n",
    "124865": "\tprotected double getDoubleValue(JSCNArrayTable table, int row, int col) {\n\t\tint convertCol = table.convertColumnIndexToModel(col);\n\t\treturn table.getJSCNArray().doubleAt(row, convertCol);\n\t}\n",
    "124869": "    public void setSymbolNameSelRows(String symbolNameSelRows) {\n        if (symbolNameSelRows == null)\n            symbolTypeDef = null;\n        else\n            symbolTypeDef = new JSCTypeDef(symbolNameSelRows, JSCTypes.NARRAY);\n        updateSelectionData();\n    }\n",
    "124871": "    protected TableCellRenderer createDefaultCellRenderer() {\n        JSCCellRendererTypes renderer = new JSCCellRendererTypes(\n                \"HEADER_RENDERER\") {\n            protected void setStringValue(String value) {\n                setText(value == null ? \"\" : value);\n            }\n        };\n\n        return renderer;\n    }\n",
    "124872": "\tprotected String getStringValue(JSCSArrayTable table, int row, int col) {\n\t\tint convertCol = table.convertColumnIndexToModel(col);\n\t\n\t\tif (table.isDisplayTransposed())\n\t\t\treturn table.getJSCSArray().stringAt(convertCol, row);\n\t\treturn table.getJSCSArray().stringAt(row, convertCol);\n\t}\n",
    "124877": "\tprotected boolean isSubsetRes(JSCNArrayTable table, int row, int col) {\n\t\tif (!(table instanceof CoeffTable))\n\t\t\treturn false;\n\n\t\tJSCNArray subsetRes = ((CoeffTable) table).getJSCNArraySubsetRes();\n\t\tif (subsetRes != null) {\n\t\t\t// Check for restriction. If 0 then element is restricted.\n\t\t\tif (row < subsetRes.rows() && col < subsetRes.cols())\n\t\t\t\treturn subsetRes.intAt(row, col) == 0;\n\t\t}\n\t\treturn false;\n\t}\n",
    "124880": "    protected JComponent createDefaultCorner() {\n        JLabel comp;\n        comp = new JLabel();\n        comp.setBorder(new LineBorder(Color.GRAY, 1));\n        return comp;\n    }\n",
    "124881": "    public void tableChanged(TableModelEvent e) {\n        super.tableChanged(e);\n        if (enclosingScrollPane != null\n                && enclosingScrollPane.getParent() != null)\n            ((JComponent) enclosingScrollPane.getParent()).revalidate();\n\n        // update the vector of selected rows (0-1-vector)\n        updateSelectionData();\n        firePropertyChange(\"columnWidth\", -1, getColumnWidth());\n    }\n",
    "124882": "\tprotected void setDoubleValue(double value, NumberDisplayTable table) {\n\t\tif (new Double(value).equals(doubleNAN)) {\n\t\t\tsetText(value + space);\n\t\t} else {\n\t\t\tif (table != null) {\n\t\t\t\tnumberFormat.setMaximumFractionDigits(table.getPrecision());\n\t\t\t\tnumberFormat.setMinimumFractionDigits(table.getPrecision());\n\t\t\t}\n\t\t\tsetText(numberFormat.format(value) + space);\n\t\t}\n\t}\n",
    "124884": "    public int getColumnHeaderAlignment() {\n        return columnHeaderAlignment;\n    }\n",
    "124886": "    public void valueChanged(ListSelectionEvent e) {\n        super.valueChanged(e);\n\n        // update the vector of selected rows (0-1-vector)\n        if (!e.getValueIsAdjusting())\n            updateSelectionData();\n\n    }\n",
    "124890": "    public void setColEditableMap(Map<Integer, Boolean> colIndexEditableMap) {\n        this.colIndexEditableMap = colIndexEditableMap;\n    }\n",
    "124891": "    public TableCellRenderer getColumnHeaderCellRenderer() {\n        if (columnHeaderCellRenderer == null)\n            columnHeaderCellRenderer = createDefaultCellRenderer();\n\n        return columnHeaderCellRenderer;\n    }\n",
    "124893": "    public void setRowEditableMap(Map<Integer, Boolean> rowIndexEditableMap) {\n        this.rowIndexEditableMap = rowIndexEditableMap;\n    }\n",
    "124894": "    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        if (colIndexEditableMap == null && rowIndexEditableMap == null)\n            return editable;\n\n        boolean rtn = editable;\n\n        if (colIndexEditableMap != null) {\n            Boolean val = colIndexEditableMap.get(columnIndex);\n            rtn = (val == null) ? rtn : val; // global coming through\n        }\n        if (rowIndexEditableMap != null) {\n            Boolean val = rowIndexEditableMap.get(rowIndex);\n            rtn = (val == null) ? rtn : val;\n        }\n\n        return rtn;\n\n    }\n",
    "124896": "\tprotected void setStringValue(String value) {\n\t\tsetText(value == null ? \"\" : space + value + space);\n\t}\n",
    "124897": "    public JSCSArray getColumnHeaderData() {\n        return getColumnHeaderDataTable().getJSCSArray();\n    }\n",
    "124899": "\tprivate void setValue(Object value, JTable table) {\n\t\tif (table instanceof NumberDisplayTable)\n\t\t\tsetDoubleValue(\n\t\t\t\t((Double) value).doubleValue(),\n\t\t\t\t(NumberDisplayTable) table);\n\t\telse {\n\t\t\tif (value != null)\n\t\t\t\tsetStringValue(value.toString() + space);\n\t\t\telse\n\t\t\t\tsetText(\"\");\n\t\t}\n\t}\n",
    "124901": "    public String getColumnHeaderSymbolName() {\n        return columnHeaderSymbolName;\n    }\n",
    "124902": "    public String toString() {\n        return origString;\n    }\n",
    "124903": "    public String toUpperCase() {\n        return upperCaseString;\n    }\n",
    "124904": "    public boolean equals(Object o) {\n        if (!(o instanceof CIString))\n            return false;\n        if (o == this)\n            return true;\n        return upperCaseString.equals(((CIString) o).upperCaseString);\n    }\n",
    "124906": "    public int hashCode() {\n        return hashCode;\n    }\n",
    "124910": "\tpublic FArg add(double arg) {\n\t\treturn add(new Double(arg));\n\t}\n",
    "124911": "    public int getMaximumVisibleColumns() {\n        return maximumVisibleColumns;\n    }\n",
    "124912": "\tpublic FArg add(int arg) {\n\t\treturn add(new Integer(arg));\n\t}\n",
    "124914": "\tpublic FArg add(Object arg) {\n\t\tlist.add(arg);\n\t\treturn this;\n\t}\n",
    "124915": "    public boolean equals(Object o) {\n        if (o == this)\n            return true;\n\n        if (!(o instanceof Maturity))\n            return false;\n        Maturity otherMat = (Maturity) o;\n        boolean ret = (COUNT == otherMat.COUNT && UNIT == otherMat.UNIT);\n        return ret;\n    }\n",
    "124919": "    public int getMaximumVisibleRows() {\n        return maximumVisibleRows;\n    }\n",
    "124921": "        private String fFormatString(double x) {\n            char[] ca6, ca7;\n            if (Double.isInfinite(x)) {\n                if (x == Double.POSITIVE_INFINITY) {\n                    if (leadingSign)\n                        ca6 = \"+Inf\".toCharArray();\n                    else if (leadingSpace)\n                        ca6 = \" Inf\".toCharArray();\n                    else\n                        ca6 = \"Inf\".toCharArray();\n                } else\n                    ca6 = \"-Inf\".toCharArray();\n            } else if (Double.isNaN(x)) {\n                if (leadingSign)\n                    ca6 = \"+NaN\".toCharArray();\n                else if (leadingSpace)\n                    ca6 = \" NaN\".toCharArray();\n                else\n                    ca6 = \"NaN\".toCharArray();\n            } else\n                ca6 = fFormatDigits(x);\n            ca7 = applyFloatPadding(ca6, false);\n            return new String(ca7);\n        }\n",
    "124924": "    public int getMinimumVisibleColumns() {\n        return minimumVisibleColumns;\n    }\n",
    "124926": "    public boolean isValid(JSCTypes type) {\n        if (type == JSCTypes.NARRAY || type == JSCTypes.NUMBER\n                || type == JSCTypes.INT || type == JSCTypes.SARRAY\n                || type == JSCTypes.STRING)\n            return true;\n        return false;\n    }\n",
    "124927": "    public int getMinimumVisibleRows() {\n        return minimumVisibleRows;\n    }\n",
    "124929": "    private void checkArgs(JSCData[] args, boolean checkEmpty) {\n        if (args == null)\n            return;\n        for (int i = 0; i < args.length; i++) {\n            if (args[i] == null)\n                throw new IllegalArgumentException(\n                        \"Argument array contains null element at position [\"\n                                + i + \"].\");\n            if (!isValid(args[i].type()))\n                throw new IllegalArgumentException(\"Type \" + args[i].type()\n                        + \" of argument at position [\" + i\n                        + \"] is not supported by OxEngine.\");\n            if (checkEmpty && args[i].isEmpty()) {\n                throw new IllegalArgumentException(\"Argument at position [\" + i\n                        + \"] is empty.\");\n            }\n        }\n    }\n",
    "124930": "    public int getRowHeaderAlignment() {\n        return rowHeaderAlignment;\n    }\n",
    "124933": "    public void stop() {\n        throw new UnsupportedOperationException(toString()\n                + \" tasks cannot be stopped.\");\n    }\n",
    "124934": "    public TableCellRenderer getRowHeaderCellRenderer() {\n        if (rowHeaderCellRenderer == null)\n            rowHeaderCellRenderer = createDefaultCellRenderer();\n        return rowHeaderCellRenderer;\n    }\n",
    "124935": "    public void shutdown() {\n        joxExitEx();\n        EXIT_STATUS = true; // to invoke init on next load operation\n        loadedModules.clear();\n    }\n",
    "124938": "    public JSCSArray getRowHeaderData() {\n        return getRowHeaderDataTable().getJSCSArray();\n    }\n",
    "124940": "    private JSCSArrayTable getRowHeaderDataTable() {\n        if (rowHeaderDataTable == null) {\n            rowHeaderDataTable = new JSCSArrayTable();\n\n            rowHeaderDataTable.setColumnSelectionAllowed(false);\n            rowHeaderDataTable.setRowSelectionAllowed(false);\n            rowHeaderDataTable.setDynamicColumnWidth(true);\n            rowHeaderDataTable.setEditable(false);\n\n            setRowHeaderCellRenderer(getRowHeaderCellRenderer());\n            // rowHeaderDataTable.setIntercellSpacing(new Dimension(0, 0));\n            setUpRowHeader();\n\n            rowHeaderDataTable.setBackground(Color.lightGray);\n        }\n        return rowHeaderDataTable;\n    }\n",
    "124942": "        private boolean startSymbolicCarry(char[] ca, int cLast, int cFirst) {\n            boolean carry = true;\n            for (int i = cLast; carry && i >= cFirst; i--) {\n                carry = false;\n                switch (ca[i]) {\n                case '0':\n                    ca[i] = '1';\n                    break;\n                case '1':\n                    ca[i] = '2';\n                    break;\n                case '2':\n                    ca[i] = '3';\n                    break;\n                case '3':\n                    ca[i] = '4';\n                    break;\n                case '4':\n                    ca[i] = '5';\n                    break;\n                case '5':\n                    ca[i] = '6';\n                    break;\n                case '6':\n                    ca[i] = '7';\n                    break;\n                case '7':\n                    ca[i] = '8';\n                    break;\n                case '8':\n                    ca[i] = '9';\n                    break;\n                case '9':\n                    ca[i] = '0';\n                    carry = true;\n                    break;\n                }\n            }\n            return carry;\n        }\n",
    "124944": "    public String getRowHeaderSymbolName() {\n        return rowHeaderSymbolName;\n    }\n",
    "124948": "        public void flushBase64() throws java.io.IOException {\n            if (position > 0) {\n                if (encode) {\n                    out.write(encode3to4(b4, buffer, position));\n                    position = 0;\n                } // end if: encoding\n                else {\n                    throw new java.io.IOException(\n                            \"Base64 input not properly padded.\");\n                } // end else: decoding\n            } // end if: buffer partially full\n\n        } // end flush\n",
    "124949": "    public void setColumnHeaderAlignment(int newColumnHeaderAlignment) {\n        // check argument\n        if (newColumnHeaderAlignment != SwingConstants.LEFT\n                && newColumnHeaderAlignment != SwingConstants.RIGHT\n                && newColumnHeaderAlignment != SwingConstants.CENTER)\n            throw new IllegalArgumentException(\"invalid column header policy\");\n\n        columnHeaderAlignment = newColumnHeaderAlignment;\n\n        if (getColumnHeaderCellRenderer() instanceof JSCCellRendererTypes)\n            ((JSCCellRendererTypes) getColumnHeaderCellRenderer())\n                    .setHorizontalAlignment(columnHeaderAlignment);\n    }\n",
    "124954": "        public void close() throws java.io.IOException {\n            // 1. Ensure that pending characters are written\n            flushBase64();\n\n            // 2. Actually close the stream\n            // Base class both flushes and closes.\n            super.close();\n\n            buffer = null;\n            out = null;\n        } // end close\n",
    "124955": "    public void setColumnHeaderData(JSCSArray newColumnHeaderData) {\n        getColumnHeaderDataTable().setJSCData(newColumnHeaderData);\n        updateColWidthForHeader();\n    }\n",
    "124957": "    public void setColumnHeaderShowing(boolean isShowing) {\n        columnHeaderShowing = isShowing;\n\n        if (isShowing)\n            setColumnHeaderView(getColumnHeaderDataTable());\n        else\n            setColumnHeaderView(null);\n\n        revalidate();\n    }\n",
    "124961": "        private String printFFormat(double x) {\n            return fFormatString(x);\n        }\n",
    "124962": "    public boolean getColumnHeaderShowing() {\n        return columnHeaderShowing;\n    }\n",
    "124964": "    public void setRowHeaderShowing(boolean isShowing) {\n        rowHeaderShowing = isShowing;\n\n        if (isShowing)\n            setRowHeaderView(getRowHeaderDataTable());\n        else\n            setRowHeaderView(null);\n\n        revalidate();\n    }\n",
    "124968": "    public boolean getRowHeaderShowing() {\n        return rowHeaderShowing;\n    }\n",
    "124972": "    public void setColumnHeaderStringData(String[] colHeaderStringData) {\n        columnHeaderStringData = colHeaderStringData;\n        if (columnHeaderStringData == null)\n            setColumnHeaderData(null);\n        else\n            setColumnHeaderData(new JSCSArray(\"columnHeader\",\n                    colHeaderStringData));\n        updateColWidthForHeader();\n    }\n",
    "124973": "        private String printEFormat(double x) {\n            if (conversionCharacter == 'e')\n                return eFormatString(x, 'e');\n\n            return eFormatString(x, 'E');\n        }\n",
    "124976": "    public void setColumnHeaderSymbolName(String newColumnHeaderSymbolName) {\n        JSCConstants.checkNameThrowEx(newColumnHeaderSymbolName);\n        getColumnHeaderDataTable().setSymbolName(newColumnHeaderSymbolName);\n        columnHeaderSymbolName = newColumnHeaderSymbolName;\n        updateColWidthForHeader();\n    }\n",
    "124983": "    public void setSymbolScope(Scope newSymbolScope) {\n        if (newSymbolScope == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        symbolScope = newSymbolScope;\n        getColumnHeaderDataTable().setSymbolScope(symbolScope);\n        getRowHeaderDataTable().setSymbolScope(symbolScope);\n        updateColWidthForHeader();\n    }\n",
    "124986": "    public void setMaximumVisibleColumns(int newMaximumVisibleColumns) {\n        if (newMaximumVisibleColumns > 0\n                && newMaximumVisibleColumns >= minimumVisibleColumns) {\n            maximumVisibleColumns = newMaximumVisibleColumns;\n        } else\n            throw new IllegalArgumentException(\n                    \"Bad maximumVisibleColumns argument.\");\n    }\n",
    "124989": "    public void setMaximumVisibleRows(int newMaximumVisibleRows) {\n        if (newMaximumVisibleRows > 0\n                && newMaximumVisibleRows >= minimumVisibleRows) {\n            maximumVisibleRows = newMaximumVisibleRows;\n        } else\n            throw new IllegalArgumentException(\n                    \"Bad maximumVisibleRows argument.\");\n    }\n",
    "124992": "        private String printDFormat(short x) {\n            return printDFormat(Short.toString(x));\n        }\n",
    "124993": "    public void setMinimumVisibleColumns(int newMinimumVisibleColumns) {\n        if (newMinimumVisibleColumns > 0\n                && newMinimumVisibleColumns <= maximumVisibleColumns) {\n            minimumVisibleColumns = newMinimumVisibleColumns;\n        } else\n            throw new IllegalArgumentException(\n                    \"Bad minimumVisibleColumns argument.\");\n    }\n",
    "124996": "    public void setMinimumVisibleRows(int newMinimumVisibleRows) {\n        if (newMinimumVisibleRows > 0\n                && newMinimumVisibleRows <= maximumVisibleRows) {\n            minimumVisibleRows = newMinimumVisibleRows;\n        } else\n            throw new IllegalArgumentException(\n                    \"Bad minimumVisibleRows argument.\");\n    }\n",
    "124997": "    public String getCurrentSysLib() {\n        return systemLib;\n    }\n",
    "124999": "    public void setRowHeaderAlignment(int newRowHeaderAlignment) {\n        // check argument\n        if (newRowHeaderAlignment != SwingConstants.LEFT\n                && newRowHeaderAlignment != SwingConstants.RIGHT\n                && newRowHeaderAlignment != SwingConstants.CENTER)\n            throw new IllegalArgumentException(\"invalid row header policy\");\n\n        rowHeaderAlignment = newRowHeaderAlignment;\n\n        if (getRowHeaderCellRenderer() instanceof JSCCellRendererTypes)\n            ((JSCCellRendererTypes) getRowHeaderCellRenderer())\n                    .setHorizontalAlignment(rowHeaderAlignment);\n\n    }\n",
    "125001": "        private String printDFormat(long x) {\n            return printDFormat(Long.toString(x));\n        }\n",
    "125007": "    private void setUpRowHeader() {\n        getRowHeaderDataTable().setColumnModel(new DefaultTableColumnModel());\n        getRowHeaderDataTable().setSymbolName(rowHeaderSymbolName);\n\n        if (dataTable != null)\n            dataTable.setColumnModel(new DefaultTableColumnModel());\n\n    }\n",
    "125011": "    public void setRowHeaderData(JSCSArray newRowHeaderData) {\n        getRowHeaderDataTable().setJSCData(newRowHeaderData);\n    }\n",
    "125013": "        private String printDFormat(int x) {\n            return printDFormat(Integer.toString(x));\n        }\n",
    "125016": "    public void setRowHeaderSymbolName(String newRowHeaderSymbolName) {\n        JSCConstants.checkNameThrowEx(newRowHeaderSymbolName);\n        getRowHeaderDataTable().setSymbolName(newRowHeaderSymbolName);\n        rowHeaderSymbolName = newRowHeaderSymbolName;\n    }\n",
    "125018": "    protected void preCode() {\n    }\n",
    "125019": "    public void setViewportView(Component view) {\n        super.setViewportView(view);\n        if (view instanceof JSCAbstractDataTable)\n            setDataTable((JSCAbstractDataTable) view);\n    }\n",
    "125020": "    protected void finalCode() {\n    }\n",
    "125024": "    public SymbolTable getSymbolTable() {\n        // both tables rowheader/colheader use the same table\n        return getColumnHeaderDataTable().getSymbolTable();\n    }\n",
    "125025": "    public OutHolder getOutHolder() {\n        return outHolder;\n    }\n",
    "125026": "    public Rengine getRengine() {\n        return R;\n    }\n",
    "125028": "    public long getStartTime() {\n        return startTime;\n    }\n",
    "125029": "    public void setSymbolTable(SymbolTable table) {\n        // delegate this to the header tables\n        getColumnHeaderDataTable().setSymbolTable(table);\n        getRowHeaderDataTable().setSymbolTable(table);\n        updateColWidthForHeader();\n    }\n",
    "125031": "    private void cancelButton_ActionEvents() {\n        isOK = false;\n        setVisible(false);\n    }\n",
    "125035": "    public void removePCallListener(PCallListener l) {\n        if (l == null)\n            return;\n        listenerList.remove(PCallListener.class, l);\n    }\n",
    "125036": "    private void updateColWidthForHeader() {\n        if (dataTable != null && dataTable.isDynamicColumnWidth()) {\n            int i = getColumnHeaderDataTable().maxCellLength();\n            int j = dataTable.maxCellLength();\n            int max = Math.max(i, j);\n            dataTable.setColumnWidth(max);\n            getColumnHeaderDataTable().setColumnWidth(max);\n        }\n    }\n",
    "125041": "    public void setOutHolder(OutHolder outputHolder) {\n        this.outHolder = outputHolder;\n    }\n",
    "125045": "    private void initialize() {\n        this.setLayout(new java.awt.BorderLayout());\n        this.add(getJLabel(), java.awt.BorderLayout.CENTER);\n        this.add(getJButton(), java.awt.BorderLayout.EAST);\n        getJButton().setVisible(true);\n        this.setSize(200, 25);\n        this.setBorder(new javax.swing.border.EtchedBorder());\n\n    }\n",
    "125046": "    public void setSymbolTable(SymbolTable newSymbolTable) {\n        if (newSymbolTable == null)\n            throw new IllegalArgumentException(\"Symbol table was null.\");\n\n        symbolTable = newSymbolTable;\n    }\n",
    "125047": "    private void oKButton_ActionEvents() {\n\n        String error = null;\n        error = configPanel.storeConfig(configHolder);\n\n        if (error == null)\n            error = configHolder.getEngineType().checkConfig(configHolder);\n\n        isOK = error == null;\n\n        if (isOK)\n            setVisible(false);\n        else\n            StdMessages.errorInput(error);\n\n    }\n",
    "125055": "    public void execute() {\n        try {\n            firePCallEvent(EvtTypes.QUEUED);\n            setPriority(Thread.MIN_PRIORITY);\n            getExecutor().execute(this);\n        } catch (InterruptedException ex) {\n            log.error(\"Execution of \" + getName() + \" failed.\", ex);\n            success = false;\n            firePCallEvent(EvtTypes.FINISHED);\n        }\n    }\n",
    "125057": "    public void setStopButtonVisible(boolean isVisible) {\n        getJButton().setVisible(isVisible);\n\n    }\n",
    "125058": "    public String checkSettings(ConfigHolder configHolder) {\n\n        if (configHolder == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        /* check whether graphics dir can be used */\n\n        return null;\n\n    }\n",
    "125061": "    public void cancel() {\n        cancelled = true;\n        if (engine() != null)\n            try {\n                engine().stop();\n            } catch (UnsupportedOperationException e) {\n                cancelled = false; // clear interruption status\n                String s = \"Running task for engine\\n<\"\n                        + engine().getClass().getName()\n                        + \">\\ncannot be stopped.\";\n                if (gui)\n                    StdMessages.infoGeneral(s);\n                else\n                    log.error(s, e);\n            }\n    }\n",
    "125068": "    public void add(PCall pCall) {\n        if (callerList == null)\n            callerList = new ArrayList<PCall>();\n        callerList.add(pCall);\n    }\n",
    "125072": "    private Object getGaussEngineObject(JSCData arg) {\n        // NOT INITIALIZED.\n        if (arg.isEmpty())\n            return new GaussMatrix(new double[0][0]);\n        JSCTypes type = arg.type();\n        if (type == JSCTypes.NARRAY)\n            return new GaussMatrix(((JSCNArray) arg).doubleArray());\n        if (type == JSCTypes.NUMBER)\n            return new GaussMatrix(((JSCNumber) arg).doubleVal());\n        if (type == JSCTypes.INT)\n            return new GaussMatrix(((JSCInt) arg).doubleVal());\n        if (type == JSCTypes.SARRAY) {\n            GaussStringArray gsa = new GaussStringArray(((JSCSArray) arg)\n                    .stringArray());\n            return gsa;\n\n        }\n        if (type == JSCTypes.STRING)\n            return ((JSCString) arg).string();\n        throw new IllegalArgumentException(type + \" is not recognized.\");\n    }\n",
    "125075": "    public String getConfigFile() {\n\n        File dir = new File(DIR_NAME);\n        if (!dir.isDirectory())\n            dir.mkdir();\n\n        return cfgFile;\n\n    }\n",
    "125077": "    public boolean isPrintDate() {\n        return printDate;\n    }\n",
    "125078": "    public AbstractConfigPanel getConfigPanel() {\n        if (configPanel == null)\n            configPanel = new DefaultConfigPanel();\n        return configPanel;\n    }\n",
    "125082": "    public void setPrintDate(boolean b) {\n        printDate = b;\n    }\n",
    "125086": "    public void call(String procName, JSCData[] args, JSCData[] retData) {\n        engine().call(procName, args, retData);\n        if (cancelled)\n            throw new RuntimeException(getName() + \" was interrupted.\");\n    }\n",
    "125087": "    public void adjustConfig() {\n        if (ConfigDialog.showConfigDialog(this))\n            saveConfig(); // Update XML file.\n\n    }\n",
    "125089": "    public String getConfig(ConfigKeys key) {\n\n        if (key == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (configMap.containsKey(key)) {\n            Object o = configMap.get(key);\n            if (o != null)\n                return o.toString();\n        }\n\n        return null;\n    }\n",
    "125090": "    private void saveConfig() {\n\n        try {\n\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(\n                    new File(engineType.getConfigFile())));\n            ObjectWriter<ConfigHolder> objectWriter = new ObjectWriter<ConfigHolder>();\n            objectWriter.setPackagePrefix(\"\", \"com.jstatcom.engine\");\n            objectWriter.setPackagePrefix(\"jstatcom\", \"com.jstatcom\");\n\n            objectWriter.write(this, out); // Uses UTF-8 encoding.\n\n        } catch (IOException ivjExc) {\n            log.error(\"XML serialization failed\", ivjExc);\n        }\n\n    }\n",
    "125091": "    public void load(String module, LoadTypes loadType, JSCData[] args) {\n        engine().load(module, loadType, args);\n        if (cancelled)\n            throw new RuntimeException(getName() + \" was interrupted.\");\n\n    }\n",
    "125093": "    public void setConfig(ConfigKeys configKey, String value) {\n\n        if (configKey == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        Map<String, ConfigKeys> confKeys = engineType.getConfigKeys();\n        if (confKeys == null)\n            throw new IllegalArgumentException(configKey + \" is not valid for \"\n                    + engineType + \".\");\n\n        if (confKeys.containsValue(configKey))\n            configMap.put(configKey, value);\n        else\n            throw new IllegalArgumentException(configKey + \" is not valid for \"\n                    + engineType + \".\");\n\n    }\n",
    "125096": "    protected PCallListener getPCallControl() {\n        return DefaultPCallControl.getInstance();\n    }\n",
    "125100": "    public Executor getExecutor() {\n        return executorThread;\n    }\n",
    "125101": "    private void executeMLabProc(String procName, int rtnArgs) {\n\n        if (procName == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        if (rtnArgs < 0)\n            throw new IllegalArgumentException(\"Negative number of returns.\");\n\n        String error = null;\n\n        if (log.isDebugEnabled())\n            log.debug(\"call: \" + procName);\n\n        if ((error = setRtnArgsLengthEx(rtnArgs)) != null)\n            throw new RuntimeException(\"Error setting return arg length:\\n\"\n                    + error);\n\n        if ((error = callMLabProcEx(procName)) != null)\n            throw new RuntimeException(\"Error executing \\\"\" + procName\n                    + \"\\\":\\n\" + error);\n\n    }\n",
    "125102": "    public void shutdown() {\n        if (graphicsDir != null && graphicsDir.isDirectory()) {\n            File[] tmpFiles = graphicsDir.listFiles();\n            for (int i = 0; i < tmpFiles.length; i++)\n                tmpFiles[i].delete();\n            graphicsDir.delete();\n        }\n        if (wk.getSymbolType(\"shutdownJGRTE\") == Gauss.PROCEDURE)\n            wk.execute(\"shutdownJGRTE\");\n        wk.clear();\n\n        Gauss.shutdown();\n        workSpaceName = null;\n\n    }\n",
    "125103": "    public boolean isGui() {\n        return gui;\n    }\n",
    "125107": "    public void setGui(boolean gui) {\n        this.gui = gui;\n    }\n",
    "125108": "    public GaussWorkspace getGaussWorkSpace() {\n        return wk;\n    }\n",
    "125110": "    protected void cleanUpAfterCall() {\n\n    }\n",
    "125112": "    public GaussWorkspace getWk() {\n        return wk;\n    }\n",
    "125115": "    public void handleOutput(String s) {\n        log.info(s);\n    }\n",
    "125116": "    public void handleError(String s) {\n        log.error(s);\n    }\n",
    "125125": "    public void shutdown() {\n\n        // there is nothing to do\n\n    }\n",
    "125139": "    public void setOutErrHandler(OutErrHandler outErrHandler) {\n        if (outErrHandler == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.outErrHandler = outErrHandler;\n    }\n",
    "125144": "    private CPtr getNArrayVecPtr(JSCNArray nArray) {\n        CMalloc argPtr = null;\n        argPtr = new CMalloc(8 * nArray.cols() * nArray.rows());\n        pointerHolder.add(argPtr);\n        for (int i = 0, index = 0; i < nArray.cols(); i++)\n            for (int j = 0; j < nArray.rows(); j++)\n                argPtr.setDouble(8 * index++, nArray.doubleAt(j, i));\n\n        return argPtr;\n\n    }\n",
    "125146": "\tpublic boolean equals(Object other) {\n\t\tif (other == null)\n\t\t\treturn false;\n\t\tif (other == this)\n\t\t\treturn true;\n\t\tif (CPtr.class != other.getClass())\n\t\t\treturn false;\n\t\treturn peer == ((CPtr) other).peer;\n\t}\n",
    "125147": "\tpublic int hashCode() {\n\t\treturn (int) ((peer >>> 32) + (peer & 0xFFFFFFFF));\n\t}\n",
    "125149": "\tpublic void free() {\n\t\tfree(peer);\n\t\tpeer = 0;\n\t}\n",
    "125150": "\tpublic void copyIn(int bOff, byte[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 1);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125152": "\tpublic void copyIn(int bOff, short[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 2);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125154": "\tpublic void copyIn(int bOff, char[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 2);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125155": "        private String printOFormat(short x) {\n            String sx = null;\n            if (x == Short.MIN_VALUE)\n                sx = \"100000\";\n            else if (x < 0) {\n                String t = Integer.toString((~(-x - 1)) ^ Short.MIN_VALUE, 8);\n                switch (t.length()) {\n                case 1:\n                    sx = \"10000\" + t;\n                    break;\n                case 2:\n                    sx = \"1000\" + t;\n                    break;\n                case 3:\n                    sx = \"100\" + t;\n                    break;\n                case 4:\n                    sx = \"10\" + t;\n                    break;\n                case 5:\n                    sx = \"1\" + t;\n                    break;\n                }\n            } else\n                sx = Integer.toString(x, 8);\n            return printOFormat(sx);\n        }\n",
    "125156": "\tpublic void copyIn(int bOff, int[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 4);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125158": "\tpublic void copyIn(int bOff, long[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 8);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125159": "\tpublic void copyIn(int bOff, float[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 4);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125161": "\tpublic void copyIn(int bOff, double[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 8);\n\t\tsuper.copyIn(bOff, buf, index, length);\n\t}\n",
    "125163": "\tpublic void copyOut(int bOff, byte[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 1);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125164": "\tpublic void copyOut(int bOff, short[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 2);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125166": "\tpublic void copyOut(int bOff, char[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 2);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125167": "\tpublic void copyOut(int bOff, int[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 4);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125169": "\tpublic void copyOut(int bOff, long[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 8);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125171": "\tpublic void copyOut(int bOff, float[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 4);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125172": "\tpublic void copyOut(int bOff, double[] buf, int index, int length) {\n\t\tboundsCheck(bOff, length * 8);\n\t\tsuper.copyOut(bOff, buf, index, length);\n\t}\n",
    "125175": "\tpublic byte getByte(int offset) {\n\t\tboundsCheck(offset, 1);\n\t\treturn super.getByte(offset);\n\t}\n",
    "125177": "\tpublic short getShort(int offset) {\n\t\tboundsCheck(offset, 2);\n\t\treturn super.getShort(offset);\n\t}\n",
    "125178": "\tpublic int getInt(int offset) {\n\t\tboundsCheck(offset, 4);\n\t\treturn super.getInt(offset);\n\t}\n",
    "125179": "    public void shutdown() {\n        String compiler_version = cf\n                .getConfig(StubMlabConfigKeys.MATLAB_COMPILER_VERSION);\n        if (!compiler_version.startsWith(\"4\"))\n            return;\n        CFunc mlabTermCall = new CFunc(mlabLib, \"jmlab_terminate\");\n        mlabTermCall.callVoid(new Object[0]);\n    }\n",
    "125180": "\tpublic long getLong(int offset) {\n\t\tboundsCheck(offset, 8);\n\t\treturn super.getLong(offset);\n\t}\n",
    "125182": "\tpublic float getFloat(int offset) {\n\t\tboundsCheck(offset, 4);\n\t\treturn super.getFloat(offset);\n\t}\n",
    "125184": "\tpublic double getDouble(int offset) {\n\t\tboundsCheck(offset, 8);\n\t\treturn super.getDouble(offset);\n\t}\n",
    "125187": "\tpublic CPtr getCPtr(int offset) {\n\t\tboundsCheck(offset, SIZE);\n\t\treturn super.getCPtr(offset);\n\t}\n",
    "125188": "\tpublic String getString(int offset) {\n\t\tboundsCheck(offset, 0);\n\t\treturn super.getString(offset);\n\t}\n",
    "125190": "    public void execute(String command) {\n\n        if (command == null)\n            throw new IllegalArgumentException(\"Command was null.\");\n\n        if (!isRunning)\n            start(true);\n\n        command = command.trim();\n        if (command.length() == 0)\n            return;\n\n        // Ending \";\" is taken care of by jgauss library.\n        if (command.charAt(command.length() - 1) == ';')\n            command = command.substring(0, command.length() - 1);\n\n        log.debug(\"command:\\n\" + command + \";\\n\");\n\n        String error = null;\n        if ((error = executeCommandEx(command)) != null)\n            throw new RuntimeException(error);\n\n        checkStopped();\n\n    }\n",
    "125191": "\tpublic void setByte(int offset, byte value) {\n\t\tboundsCheck(offset, 1);\n\t\tsuper.setByte(offset, value);\n\t}\n",
    "125193": "\tpublic void setShort(int offset, short value) {\n\t\tboundsCheck(offset, 2);\n\t\tsuper.setShort(offset, value);\n\t}\n",
    "125195": "\tpublic void setInt(int offset, int value) {\n\t\tboundsCheck(offset, 4);\n\t\tsuper.setInt(offset, value);\n\t}\n",
    "125196": "    public void shutdown() {\n        String compiler_version = cf\n                .getConfig(MLabConfigKeys.MATLAB_COMPILER_VERSION);\n        if (!compiler_version.startsWith(\"4\"))\n            return;\n        CFunc mlabTermCall = new CFunc(mlabLib, \"jmlab_terminate\");\n        mlabTermCall.callVoid(new Object[0]);\n    }\n",
    "125197": "\tpublic void setLong(int offset, long value) {\n\t\tboundsCheck(offset, 8);\n\t\tsuper.setLong(offset, value);\n\t}\n",
    "125200": "\tpublic void setFloat(int offset, float value) {\n\t\tboundsCheck(offset, 4);\n\t\tsuper.setFloat(offset, value);\n\t}\n",
    "125202": "\tpublic void setDouble(int offset, double value) {\n\t\tboundsCheck(offset, 8);\n\t\tsuper.setDouble(offset, value);\n\t}\n",
    "125205": "\tpublic void setCPtr(int offset, CPtr value) {\n\t\tboundsCheck(offset, SIZE);\n\t\tsuper.setCPtr(offset, value);\n\t}\n",
    "125208": "\tpublic void setString(int offset, String value) {\n\t\tbyte[] bytes = value.getBytes();\n\t\tint length = bytes.length;\n\t\tboundsCheck(offset, length + 1);\n\t\tsuper.copyIn(offset, bytes, 0, length);\n\t\tsuper.setByte(offset + length, (byte) 0);\n\t}\n",
    "125212": "    public File getTempFile() {\n\n        // Create tmp file.\n        String tmpDir = ConfigHolder.valueOf(this).getConfig(\n                GaussConfigKeys.TEMP_DIR)\n                + \"/\" + DIR_NAME;\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"jsc\", null, new File(tmpDir));\n            tmpFile.deleteOnExit();\n        } catch (IOException ex) {\n            throw new RuntimeException(ex.getMessage());\n        }\n\n        return tmpFile;\n    }\n",
    "125213": "    public String checkSettings(ConfigHolder configHolder) {\n\n        if (configHolder == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        // Test whether Gaussversion fits with specified directory.\n        // This is only a distinction between 3.2 and newer Versions\n        // and only tests, whether tgauss.exe is there.\n\n        // Test whether the 16 bit restriction for directory names\n        // of Gaussversion 3.2 holds. TEMP_DIR, EXE_LOCATION and\n        // GCG_FILENAME have to be checked.\n\n        // This is not implemented.\n\n        // if TEMP_DIR is empty, then use system variable TEMP.\n        // IF TEMP is also empty, then use TMP\n\n        return null;\n\n    }\n",
    "125225": "    public Iterator iterator() {\n        return fileList.iterator();\n    }\n",
    "125230": "        private String printCFormat(char x) {\n            int nPrint = 1;\n            int width = fieldWidth;\n            if (!fieldWidthSet)\n                width = nPrint;\n            char[] ca = new char[width];\n            int i = 0;\n            if (leftJustify) {\n                ca[0] = x;\n                for (i = 1; i <= width - nPrint; i++)\n                    ca[i] = ' ';\n            } else {\n                for (i = 0; i < width - nPrint; i++)\n                    ca[i] = ' ';\n                ca[i] = x;\n            }\n            return new String(ca);\n        }\n",
    "125245": "    public Iterator iterator() {\n        return libList.iterator();\n    }\n",
    "125248": "    public boolean importData(File dataFile) {\n        if (dataFile == null || !dataFile.isFile())\n            throw new IllegalArgumentException(\"Invalid data file \" + dataFile\n                    + \".\");\n        Workbook w = null;\n        symbolTable.clear();\n        try {\n            w = Workbook.getWorkbook(dataFile);\n            parseToDataSet(w);\n        } catch (Throwable t) {\n            throw new RuntimeException(t.getMessage());\n        }\n        w.close();\n        if (symbolTable.isEmpty())\n            return false;\n        return true;\n    }\n",
    "125250": "    public JSCData getData(ImportTypes type) {\n\n        if (symbolTable == null)\n            throw new IllegalStateException(\"There was nothing imported yet.\");\n\n        if (type == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n\n        return symbolTable.getJSCData(new JSCTypeDef(type.name(), type.type()));\n    }\n",
    "125253": "    private TSExcelDialog getTableDialog() {\n        if (tableDialog == null)\n            tableDialog = new TSExcelDialog(TopFrameReference.getTopFrameRef(),\n                    true);\n        tableDialog.setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n        return tableDialog;\n    }\n",
    "125262": "    public void setTestMode(boolean noDialog) {\n        this.noDialog = noDialog;\n    }\n",
    "125271": "    public File chooseDirectory(Component parent, String titleText) {\n        File dir = null;\n        getFileChooserOpenDat().setDialogTitle(titleText);\n        getFileChooserOpenDat().setFileSelectionMode(\n                JFileChooser.DIRECTORIES_ONLY);\n        int returnVal = getFileChooserOpenDat().showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            dir = getFileChooserOpenDat().getSelectedFile();\n        }\n        return dir;\n\n    }\n",
    "125273": "    private void checkStopped() {\n        if (stopped) {\n            stopped = false;\n            throw new RuntimeException(Thread.currentThread().getName()\n                    + \" was interrupted.\");\n        }\n    }\n",
    "125274": "    public String readTextFile(String fileName) {\n        if (fileName == null)\n            throw new IllegalArgumentException(\"Filename was null.\");\n\n        BufferedReader in = null;\n        StringBuffer str = new StringBuffer();\n        String tmp = null;\n        try {\n            in = new BufferedReader(new FileReader(fileName));\n            while ((tmp = in.readLine()) != null)\n                str.append(tmp + \"\\n\");\n            in.close();\n        } catch (IOException e) {\n            log.error(\"Error reading text from \\\"\" + fileName + \"\\\".\", e);\n            return \"Error reading text from \\\"\" + fileName + \"\\\".\";\n        }\n        return str.toString();\n    }\n",
    "125275": "        private boolean setConversionCharacter() {\n            /* idfgGoxXeEcs */\n            boolean ret = false;\n            conversionCharacter = '\\0';\n            if (pos < fmt.length()) {\n                char c = fmt.charAt(pos);\n                if (c == 'i' || c == 'd' || c == 'f' || c == 'g' || c == 'G'\n                        || c == 'o' || c == 'x' || c == 'X' || c == 'e'\n                        || c == 'E' || c == 'c' || c == 's' || c == '%') {\n                    conversionCharacter = c;\n                    pos++;\n                    ret = true;\n                }\n            }\n            return ret;\n        }\n",
    "125276": "    public boolean importData(File file) {\n        return importData(file, true);\n    }\n",
    "125284": "    private TSDataDialog getDataDialog() {\n        if (dialog == null)\n            dialog = new TSDataDialog(TopFrameReference.getTopFrameRef(), true);\n        dialog.setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n\n        return dialog;\n    }\n",
    "125285": "    public void saveStringToFile(File file, String stringDat, boolean append) {\n        if (file != null) {\n            try {\n                BufferedWriter out = new BufferedWriter(new FileWriter(file,\n                        append));\n                out.write(stringDat);\n                out.flush();\n                out.close();\n            } catch (IOException ivjExc) {\n                log.error(\"error saving data to file: \"\n                        + file.getAbsolutePath(), ivjExc);\n            }\n\n        }\n    }\n",
    "125289": "        private void setOptionalHL() {\n            optionalh = false;\n            optionall = false;\n            optionalL = false;\n            if (pos < fmt.length()) {\n                char c = fmt.charAt(pos);\n                if (c == 'h') {\n                    optionalh = true;\n                    pos++;\n                } else if (c == 'l') {\n                    optionall = true;\n                    pos++;\n                } else if (c == 'L') {\n                    optionalL = true;\n                    pos++;\n                }\n            }\n        }\n",
    "125300": "    public void setDefaultPath(String newDefaultPath) {\n        dataDirectory = newDefaultPath;\n        saveTextDirectory = newDefaultPath;\n    }\n",
    "125302": "        private void setPrecision() {\n            int firstPos = pos;\n            precisionSet = false;\n            if (pos < fmt.length() && fmt.charAt(pos) == '.') {\n                pos++;\n                if ((pos < fmt.length()) && (fmt.charAt(pos) == '*')) {\n                    pos++;\n                    if (!setPrecisionArgPosition()) {\n                        variablePrecision = true;\n                        precisionSet = true;\n                    }\n                    return;\n                }\n                while (pos < fmt.length()) {\n                    char c = fmt.charAt(pos);\n                    if (Character.isDigit(c))\n                        pos++;\n                    else\n                        break;\n                }\n                if (pos > firstPos + 1) {\n                    String sz = fmt.substring(firstPos + 1, pos);\n                    precision = Integer.parseInt(sz);\n                    precisionSet = true;\n                }\n\n            }\n        }\n",
    "125304": "    public void startWorkers() {\n        fileChooserOpenDat_Worker.start();\n        fileChooserSave_Worker.start();\n    }\n",
    "125307": "    public void setFileSupportSettings(FileSupportSettings settings) {\n        if (settings == null)\n            return;\n        JSCSArray sel = settings.getSelectedFiles();\n        if (sel.isEmpty() || sel.rows() < 4)\n            return;\n        saveTextDirectory = sel.stringAt(0, 0);\n        dataDirectory = sel.stringAt(1, 0);\n        projectFile = sel.stringAt(2, 0);\n        projectDirectory = sel.stringAt(3, 0);\n    }\n",
    "125313": "    public FileSupportSettings getFileSupportSettings() {\n        FileSupportSettings settings = new FileSupportSettings();\n        JSCSArray sel = new JSCSArray(\"files\",\n                new String[] { saveTextDirectory, dataDirectory, projectFile,\n                        projectDirectory });\n        settings.setSelectedFiles(sel);\n        return settings;\n    }\n",
    "125316": "        private void setFieldWidth() {\n            int firstPos = pos;\n            fieldWidth = 0;\n            fieldWidthSet = false;\n            if ((pos < fmt.length()) && (fmt.charAt(pos) == '*')) {\n                pos++;\n                if (!setFieldWidthArgPosition()) {\n                    variableFieldWidth = true;\n                    fieldWidthSet = true;\n                }\n            } else {\n                while (pos < fmt.length()) {\n                    char c = fmt.charAt(pos);\n                    if (Character.isDigit(c))\n                        pos++;\n                    else\n                        break;\n                }\n                if (firstPos < pos && firstPos < fmt.length()) {\n                    String sz = fmt.substring(firstPos, pos);\n                    fieldWidth = Integer.parseInt(sz);\n                    fieldWidthSet = true;\n                }\n            }\n        }\n",
    "125321": "    public DataHandlerTypes getSelectedImportHandlerType() {\n        FileFilter filter = getFileChooserOpenDat().getFileFilter();\n        DataHandlerTypes type = DataHandlerTypes.DAT; // default\n        if (filter instanceof ExtensionFileFilter)\n            type = ((ExtensionFileFilter) filter).getHandlerType();\n\n        if (type == null)\n            type = DataHandlerTypes.DAT;\n        return type;\n    }\n",
    "125323": "    public TSDate getTSDate() {\n        return tsDate;\n    }\n",
    "125324": "    public int getSelectedSheet() {\n        return selectedSheet;\n    }\n",
    "125325": "    public DataHandlerTypes getSelectedSaveHandlerType() {\n        FileFilter filter = getFileChooserSave().getFileFilter();\n        DataHandlerTypes type = DataHandlerTypes.DAT; // default\n        if (filter instanceof ExtensionFileFilter)\n            type = ((ExtensionFileFilter) filter).getHandlerType();\n\n        if (type == null)\n            type = DataHandlerTypes.DAT;\n\n        return type;\n\n    }\n",
    "125326": "    public String getVariableNames() {\n        return getNames().getText();\n    }\n",
    "125328": "    public void write(byte buf[], int off, int len) {\n        try {\n            // logFile.write(buf, off, len);\n            if (redirectReceiver != null)\n                redirectReceiver.append(new String(buf, off, len));\n            if (logFile != null)\n                logFile.write(buf, off, len);\n        } catch (Throwable e) {\n            log.error(\"Error redirecting\", e);\n            setError();\n        }\n        super.write(buf, off, len);\n    }\n",
    "125329": "    public void write(int b) {\n        try {\n            // logFile.write(b);\n            if (redirectReceiver != null)\n                redirectReceiver.append(b + \"\");\n            if (logFile != null)\n                logFile.write(b);\n\n        } catch (Throwable e) {\n            log.error(\"Error redirecting\", e);\n            setError();\n        }\n        super.write(b);\n    }\n",
    "125330": "    public void setVariableNames(String[] names) {\n        if (names == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        StringBuffer buffer = new StringBuffer();\n        for (int i = 0; i < names.length; i++)\n            buffer.append(names[i] + \" \");\n\n        getNames().setText(buffer.toString());\n    }\n",
    "125335": "    public JSCSArray getSelectedFiles() {\n        return selectedFiles;\n    }\n",
    "125337": "    public void setSelectedFiles(JSCSArray selectedFiles) {\n        if (selectedFiles == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.selectedFiles = selectedFiles;\n    }\n",
    "125339": "        private void setArgPosition() {\n            int xPos;\n            for (xPos = pos; xPos < fmt.length(); xPos++) {\n                if (!Character.isDigit(fmt.charAt(xPos)))\n                    break;\n            }\n            if (xPos > pos && xPos < fmt.length()) {\n                if (fmt.charAt(xPos) == '$') {\n                    positionalSpecification = true;\n                    argumentPosition = Integer.parseInt(fmt\n                            .substring(pos, xPos));\n                    pos = xPos + 1;\n                }\n            }\n        }\n",
    "125340": "    protected Container getParentFrame() {\n        if (parent != null)\n            return parent;\n\n        Container comp = this;\n        while (comp.getParent() != null) {\n            comp = comp.getParent();\n            if (comp instanceof JInternalFrame)\n                parent = comp;\n\n        }\n        return parent;\n    }\n",
    "125354": "    public boolean isCanceled() {\n        return cancelDialog;\n    }\n",
    "125360": "    private void setCanceled(boolean newCanceled) {\n        canceled = newCanceled;\n    }\n",
    "125363": "    private void setSelectedSheet(int newSelectedSheet) {\n        selectedSheet = newSelectedSheet;\n    }\n",
    "125366": "        private boolean setFieldWidthArgPosition() {\n            boolean ret = false;\n            int xPos;\n            for (xPos = pos; xPos < fmt.length(); xPos++) {\n                if (!Character.isDigit(fmt.charAt(xPos)))\n                    break;\n            }\n            if (xPos > pos && xPos < fmt.length()) {\n                if (fmt.charAt(xPos) == '$') {\n                    positionalFieldWidth = true;\n                    argumentPositionForFieldWidth = Integer.parseInt(fmt\n                            .substring(pos, xPos));\n                    pos = xPos + 1;\n                    ret = true;\n                }\n            }\n            return ret;\n        }\n",
    "125368": "    public void setSheets(String[] sheetNames) {\n        if (sheetNames == null)\n            sheetNames = new String[0];\n        this.sheetNames = sheetNames;\n    }\n",
    "125370": "    private void setCancelDialog(boolean newCancelDialog) {\n        cancelDialog = newCancelDialog;\n    }\n",
    "125376": "    public void addExtension(String extension) {\n        if (filters == null) {\n            filters = new HashMap<String, ExtensionFileFilter>(5);\n        }\n        filters.put(extension.toLowerCase(), this);\n        fullDescription = null;\n    }\n",
    "125379": "    public String getDescription() {\n        if (fullDescription == null) {\n            if (description == null || isExtensionListInDescription()) {\n                fullDescription = description == null ? \"(\" : description\n                        + \" (\";\n                // build the description from the extension list\n                Iterator<String> extensions = filters.keySet().iterator();\n                if (extensions != null) {\n                    fullDescription += \".\" + extensions.next();\n                    while (extensions.hasNext()) {\n                        fullDescription += \", \" + extensions.next();\n                    }\n                }\n                fullDescription += \")\";\n            } else {\n                fullDescription = description;\n            }\n        }\n        return fullDescription;\n    }\n",
    "125381": "    public String getExtension(File f) {\n        if (f != null) {\n            String filename = f.getName();\n            int i = filename.lastIndexOf('.');\n            if (i > 0 && i < filename.length() - 1) {\n                return filename.substring(i + 1).toLowerCase();\n            }\n\n        }\n        return null;\n    }\n",
    "125383": "\tpublic void append(String text) {\n\t\tgetResultField().append(text);\n\t}\n",
    "125384": "    public boolean isExtensionListInDescription() {\n        return useExtensionsInDescription;\n    }\n",
    "125385": "\tpublic void showLog(boolean show) {\n\t\tsetVisible(show);\n\t}\n",
    "125387": "    public void setDescription(String description) {\n        this.description = description;\n        fullDescription = null;\n    }\n",
    "125388": "\tprivate void handleException(Exception exception) {\n\n\t\t/* Uncomment the following lines to print uncaught exceptions to stdout */\n\t\tSystem.out.println(\"--------- UNCAUGHT EXCEPTION ---------\");\n\t\texception.printStackTrace(System.out);\n\t}\n",
    "125389": "    public void setExtensionListInDescription(boolean b) {\n        useExtensionsInDescription = b;\n        fullDescription = null;\n    }\n",
    "125392": "    public DataHandlerTypes getHandlerType() {\n        return type;\n    }\n",
    "125395": "    public boolean importData() {\n        if (importPanel == null)\n            throw new IllegalStateException(\"No import panel set.\");\n        return importPanel.importData();\n    }\n",
    "125396": "    public boolean importData(File importFile) {\n        if (importPanel == null)\n            throw new IllegalStateException(\"No import panel set.\");\n        return importPanel.importData(importFile);\n    }\n",
    "125398": "        private boolean setPrecisionArgPosition() {\n            boolean ret = false;\n            int xPos;\n            for (xPos = pos; xPos < fmt.length(); xPos++) {\n                if (!Character.isDigit(fmt.charAt(xPos)))\n                    break;\n            }\n            if (xPos > pos && xPos < fmt.length()) {\n                if (fmt.charAt(xPos) == '$') {\n                    positionalPrecision = true;\n                    argumentPositionForPrecision = Integer.parseInt(fmt\n                            .substring(pos, xPos));\n                    pos = xPos + 1;\n                    ret = true;\n                }\n            }\n            return ret;\n        }\n",
    "125402": "    public boolean importData() {\n        File file = FileSupport.getInstance().selectDataFile(\n                TopFrameReference.getTopFrameRef(), DataHandlerTypes.EXCEL,\n                DataHandlerTypes.MATLAB, DataHandlerTypes.GAUSS_DAT,\n                DataHandlerTypes.GAUSS_FMT, DataHandlerTypes.DAT);\n        if (file == null)\n            return false;\n\n        // get the handler from the filename only\n        DataHandlerTypes type = DataHandlerTypes.getTypeFromFileName(file\n                .getAbsolutePath());\n        return displayDataFile(file, type.getHandler());\n    }\n",
    "125403": "    private void setNamesFromDialog(String namesFromDialog) {\n        // start to fill it filename info\n\n        StringTokenizer st = new StringTokenizer(namesFromDialog);\n        String[] stringArray = new String[st.countTokens()];\n        for (int i = 0; i < stringArray.length; i++)\n            stringArray[i] = st.nextToken();\n        int length = stringArray.length;\n        if (names.length < stringArray.length)\n            length = names.length;\n        for (int i = 0; i < length; i++) {\n            if (JSCConstants.isValidName(stringArray[i]) == null)\n                names[i] = stringArray[i];\n        }\n    }\n",
    "125404": "    public void setImportPanel(AbstractImportPanel panel) {\n        if (panel == null)\n            throw new IllegalArgumentException(\"Panel was null.\");\n        importPanel = panel;\n        getIvjContentPane().add(importPanel, importPanel.getName());\n    }\n",
    "125405": "    public boolean importData(File importFile) {\n        if (importFile == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        if (!importFile.canRead())\n            throw new RuntimeException(\"Cannot read from file \\\"\"\n                    + importFile.getAbsolutePath() + \"\\\".\");\n\n        // get the handler from the filename only\n        DataHandlerTypes type = DataHandlerTypes.getTypeFromFileName(importFile\n                .getAbsolutePath());\n        return displayDataFile(importFile, type.getHandler());\n    }\n",
    "125415": "    public int getDateAsIndex() {\n        return range.indexForDate(tSDate);\n    }\n",
    "125417": "    public TSDateRange getRange() {\n        return range;\n    }\n",
    "125418": "    public TSDate getTSDate() {\n        return tSDate;\n    }\n",
    "125419": "        private void setFlagCharacters() {\n            /* '-+ #0 */\n            thousands = false;\n            leftJustify = false;\n            leadingSign = false;\n            leadingSpace = false;\n            alternateForm = false;\n            leadingZeros = false;\n            for (; pos < fmt.length(); pos++) {\n                char c = fmt.charAt(pos);\n                if (c == '\\'')\n                    thousands = true;\n                else if (c == '-') {\n                    leftJustify = true;\n                    leadingZeros = false;\n                } else if (c == '+') {\n                    leadingSign = true;\n                    leadingSpace = false;\n                } else if (c == ' ') {\n                    if (!leadingSign)\n                        leadingSpace = true;\n                } else if (c == '#')\n                    alternateForm = true;\n                else if (c == '0') {\n                    if (!leftJustify)\n                        leadingZeros = true;\n                } else\n                    break;\n            }\n        }\n",
    "125421": "    public void handleError(String msg) {\n        super.handleError(msg + \"\\nThe previous value {\" + tSDate\n                + \"} is restored.\");\n        setTSDate(tSDate);\n    }\n",
    "125423": "    public void setEnclosingRange(TSDateRange newOverallRange) {\n        if (newOverallRange == null)\n            throw new IllegalArgumentException(\"Range cannot be null.\");\n        range = newOverallRange;\n        if (range.encloses(tSDate) != null)\n            setTSDate(range.lowerBound());\n    }\n",
    "125425": "    public void setTSDate(TSDate newTSDate) {\n        String msg;\n        if ((msg = range.encloses(newTSDate)) != null)\n            throw new IllegalArgumentException(msg);\n\n        TSDate oldDate = tSDate;\n        tSDate = newTSDate;\n\n        setTextCarefully(tSDate.toString());\n\n        // fire property change\n        if (oldDate != null && !oldDate.equals(tSDate))\n            firePropertyChange(\"TSDate\", oldDate, tSDate);\n    }\n",
    "125427": "    public String validateInput() {\n\n        TSDate tmpDate = null;\n        String inputString = getText();\n        try {\n            tmpDate = TSDate.valueOf(inputString);\n        } catch (Throwable ex) {\n            String msg = \"Input \\\"\" + inputString + \"\\\" is not a valid date.\";\n            log.warn(msg, ex);\n            return msg;\n        }\n        String error = range.encloses(tmpDate);\n        if (error == null)\n            setTSDate(tmpDate);\n        return error;\n\n    }\n",
    "125434": "    private void loadButton_ActionEvents() {\n        TableCellEditor ed = getTSTable().getCellEditor();\n        if (ed != null)\n            ed.stopCellEditing();\n\n        TS[] sel = getTSTable().getTS();\n\n        for (int i = 0; i < sel.length; i++) {\n            sel[i].setTSProject(project);\n            int res = TSHolder.getInstance().addTS(sel[i]);\n            if (res == JOptionPane.CANCEL_OPTION)\n                return;\n        }\n\n        if (hideAfterLoad && getParentFrame() != null)\n            getParentFrame().setVisible(false);\n\n    }\n",
    "125435": "    private TSTableScrollPane getTSTableScrollPane() {\n        if (jScrollPane == null) {\n            jScrollPane = new TSTableScrollPane();\n            jScrollPane.setViewportView(getTSTable());\n        }\n        return jScrollPane;\n    }\n",
    "125438": "    private String nonControl(String s, int start) {\n        cPos = s.indexOf(\"%\", start);\n        if (cPos == -1)\n            cPos = s.length();\n        return s.substring(start, cPos);\n    }\n",
    "125439": "    public boolean isHideAfterLoad() {\n        return hideAfterLoad;\n    }\n",
    "125442": "    public void setHideAfterLoad(boolean b) {\n        hideAfterLoad = b;\n    }\n",
    "125445": "    public TSDateRange getEnclosingRange() {\n        return enclosingRange;\n    }\n",
    "125446": "    public int getMinNumberOfObs() {\n        return minNumberOfObs;\n    }\n",
    "125447": "    public TSDateRange getTSDateRange() {\n        return tSDateRange;\n    }\n",
    "125448": "    public void handleError(String msg) {\n        super.handleError(msg + \"\\nThe previous value \" + tSDateRange\n                + \" is restored.\");\n        setTSDateRange(tSDateRange);\n    }\n",
    "125450": "    public void maxRange() {\n        setTSDateRange(enclosingRange);\n    }\n",
    "125453": "    public void setEnclosingRange(TSDateRange newOverallRange) {\n        if (newOverallRange == null)\n            throw new IllegalArgumentException(\"Range cannot be null.\");\n\n        enclosingRange = newOverallRange;\n\n        if (enclosingRange.encloses(tSDateRange) != null) {\n            // Try to get overlapping range.\n            TSDateRange newRange = enclosingRange.commonRange(tSDateRange);\n            if (newRange != null)\n                // Set overlapping range.\n                setTSDateRange(newRange);\n            else\n                // No overlapping range, set overall range.\n                setTSDateRange(enclosingRange);\n        }\n    }\n",
    "125455": "    public void setMinNumberOfObs(int newMinNumberOfObs) {\n        minNumberOfObs = newMinNumberOfObs;\n        setTSDateRange(enclosingRange);\n    }\n",
    "125457": "    public void setTSDateRange(TSDateRange newTSDateRange) {\n\n        if (newTSDateRange == null)\n            throw new IllegalArgumentException(\"Range is null.\");\n\n        String msg;\n        if ((msg = enclosingRange.encloses(newTSDateRange)) != null)\n            throw new IllegalArgumentException(msg);\n\n        TSDateRange oldDateRange = tSDateRange;\n        tSDateRange = newTSDateRange;\n\n        String formattedRange = tSDateRange.lowerBound() + \", \"\n                + tSDateRange.upperBound();\n\n        setTextCarefully(formattedRange);\n\n        // fire property change\n        if (oldDateRange != null && !oldDateRange.equals(tSDateRange))\n            firePropertyChange(\"TSDateRange\", oldDateRange, tSDateRange);\n\n    }\n",
    "125470": "    public String getDescription() {\n        return getDescriptionArea().getText();\n    }\n",
    "125471": "    public JPopupMenu getTSListPopup() {\n        return tSListPopup;\n    }\n",
    "125478": "    public void setTSKeyListener(java.awt.event.KeyListener newTSKeyListener) {\n\n        if (tSKeyListener != null)\n            removeKeyListener(tSKeyListener);\n\n        tSKeyListener = newTSKeyListener;\n\n        if (tSKeyListener != null)\n            addKeyListener(tSKeyListener);\n    }\n",
    "125480": "    public void setTSListPopup(JPopupMenu newTsListPopup) {\n        tSListPopup = newTsListPopup;\n\n    }\n",
    "125484": "    public void addTS(TS ts) {\n        if (!tsList.contains(ts.name()))\n            tsList.add(ts.name());\n\n    }\n",
    "125486": "    public String getDescription() {\n        return projectDescription;\n    }\n",
    "125487": "    private void add_ActionEvents() {\n\n        int[] selIndex = getNamesList().getSelectedIndices();\n\n        // default start\n        if (startDate == null)\n            startDate = new TSDate();\n\n        TSProject project = new TSProject(\"Calculator\");\n        project.setDescription(\"\\n\" + commands.toString() + \"\\n\");\n        for (int i = 0; i < selIndex.length; i++) {\n\n            String name = variableListModel.getElementAt(selIndex[i])\n                    .toString();\n            double[] tsData = parser.getVariable(name);\n            TS toAdd = new TS(tsData, name, startDate);\n\n            toAdd.setTSProject(project);\n            int res = TSHolder.getInstance().addTS(toAdd);\n\n            if (res == JOptionPane.CANCEL_OPTION)\n                return;\n\n        }\n\n    }\n",
    "125488": "    public void propertyChange(PropertyChangeEvent evt) {\n        /*\n         * if (evt.getSource() instanceof TSHolder && evt.getPropertyName() ==\n         * TSHolder.TS_ADDED) { // empty }\n         */\n        if (evt.getSource() instanceof TSHolder\n                && evt.getPropertyName() == TSHolder.TS_REMOVED) {\n            String tsName = evt.getNewValue().toString();\n            removeTS(tsName);\n        }\n\n    }\n",
    "125489": "    public void setDescription(String desc) {\n        getDescriptionArea().setText(desc);\n    }\n",
    "125490": "    public void removeTS(String name) {\n        if (tsList.contains(name))\n            tsList.remove(name);\n    }\n",
    "125491": "    public void setTSList(TSList newTimeSeriesList) {\n        tSList = newTimeSeriesList;\n        TS[] sel = tSList.getSelectedTS();\n        if (sel.length > 0)\n            getDescriptionArea().setText(sel[0].project().getDescription());\n        setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n        canceled = true;\n    }\n",
    "125492": "    public void setDescription(String newProjectDescription) {\n        if (newProjectDescription == null\n                || newProjectDescription.trim().length() == 0)\n            newProjectDescription = \"\";\n\n        projectDescription = newProjectDescription;\n    }\n",
    "125494": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(getClass().getName() + \"[name=\" + name);\n        for (int i = 0; i < tsList.size(); i++)\n            buffer.append(\",\" + tsList.get(i));\n        buffer.append(\"]\");\n        return buffer.toString();\n    }\n",
    "125496": "    private void calc_ActionPerformed(java.awt.event.ActionEvent actionEvent) {\n        String toPut = ((JButton) actionEvent.getSource()).getText();\n        getInputField().getTextArea().insert(toPut,\n                getInputField().getTextArea().getCaretPosition());\n        return;\n    }\n",
    "125500": "    public String sprintf(double x) throws IllegalArgumentException {\n        Enumeration e = vFmt.elements();\n        ConversionSpecification cs = null;\n        char c = 0;\n        StringBuffer sb = new StringBuffer();\n        while (e.hasMoreElements()) {\n            cs = (ConversionSpecification) e.nextElement();\n            c = cs.getConversionCharacter();\n            if (c == '\\0')\n                sb.append(cs.getLiteral());\n            else if (c == '%')\n                sb.append(\"%\");\n            else\n                sb.append(cs.internalsprintf(x));\n        }\n        return sb.toString();\n    }\n",
    "125501": "    public void enableForTSList(TSList tsList) {\n\n        setEnabled(tsList.getSelectedIndices().length != 0);\n        this.tSList = tsList;\n        // Enable/Disable items according to selection\n        for (int i = 0; i < actionList.size(); i++)\n            actionList.get(i).enableForTSList(tSList);\n\n    }\n",
    "125509": "    public int compareTo(Object o) {\n        TSDate otherDate = (TSDate) o;\n\n        if (subPeriodicity != otherDate.subPeriodicity())\n            throw new IllegalArgumentException(\n                    \"Sub periodicities do not match between \" + this + \" and \"\n                            + o + \".\");\n\n        if (equals(otherDate))\n            return 0;\n        long result = (otherDate.mainPeriod() - mainPeriod) * subPeriodicity\n                + otherDate.subPeriod() - subPeriod;\n        if (result > Integer.MAX_VALUE)\n            throw new IllegalStateException(\"Integer.MAX_VALUE overflow.\");\n        if (result < Integer.MIN_VALUE)\n            throw new IllegalStateException(\"Integer.MIN_VALUE overflow.\");\n\n        return (int) result;\n    }\n",
    "125512": "    public double doubleValue() {\n        if (subPeriodicity > 1)\n            return (mainPeriod + ((mainPeriod >= 0) ? 1 : -1)\n                    * (double) subPeriod / parseSubPeriodFormat(subPeriodicity));\n\n        return mainPeriod;\n    }\n",
    "125514": "    public boolean equals(Object o) {\n        if (o == this)\n            return true;\n\n        if (!(o instanceof TSDate))\n            return false;\n        TSDate otherDate = (TSDate) o;\n        boolean ret = (mainPeriod == otherDate.mainPeriod()\n                && subPeriod == otherDate.subPeriod() && subPeriodicity == otherDate\n                .subPeriodicity());\n        return ret;\n    }\n",
    "125517": "    public String sprintf(int x) throws IllegalArgumentException {\n        Enumeration e = vFmt.elements();\n        ConversionSpecification cs = null;\n        char c = 0;\n        StringBuffer sb = new StringBuffer();\n        while (e.hasMoreElements()) {\n            cs = (ConversionSpecification) e.nextElement();\n            c = cs.getConversionCharacter();\n            if (c == '\\0')\n                sb.append(cs.getLiteral());\n            else if (c == '%')\n                sb.append(\"%\");\n            else\n                sb.append(cs.internalsprintf(x));\n        }\n        return sb.toString();\n    }\n",
    "125518": "    public int mainPeriod() {\n        return mainPeriod;\n    }\n",
    "125520": "    public int subPeriod() {\n        return subPeriod;\n    }\n",
    "125525": "    public int subPeriodFormat() {\n        return this.subPeriodFormat;\n    }\n",
    "125526": "    public int subPeriodicity() {\n        return subPeriodicity;\n    }\n",
    "125529": "    public int hashCode() {\n\n        int result = 17;\n        result = 37 * result + mainPeriod;\n        result = 37 * result + subPeriod;\n        result = 37 * result + subPeriodicity;\n        return result;\n    }\n",
    "125530": "    public String sprintf(long x) throws IllegalArgumentException {\n        Enumeration e = vFmt.elements();\n        ConversionSpecification cs = null;\n        char c = 0;\n        StringBuffer sb = new StringBuffer();\n        while (e.hasMoreElements()) {\n            cs = (ConversionSpecification) e.nextElement();\n            c = cs.getConversionCharacter();\n            if (c == '\\0')\n                sb.append(cs.getLiteral());\n            else if (c == '%')\n                sb.append(\"%\");\n            else\n                sb.append(cs.internalsprintf(x));\n        }\n        return sb.toString();\n    }\n",
    "125532": "    private int parseSubPeriodFormat(int subPeriodicity) {\n        double[] d = UMath.base10(subPeriodicity);\n        return (int) Math.pow(10, d[1] + 1);\n    }\n",
    "125533": "    public String printNice() {\n        if (subPeriodicity == 5 || subPeriodicity == 7) {\n            return dailyFormat.format(getDate());\n        }\n        return toString();\n    }\n",
    "125534": "    public void setTSList(TSList newTimeSeriesList) {\n        int maxSel = newTimeSeriesList.getSelectedIndices().length;\n        String seriesNames = \"\";\n        seriesNames = newTimeSeriesList.getSelectedTS()[0].name();\n        for (int i = 1; i < maxSel; i++) {\n            seriesNames = seriesNames + \", \"\n                    + newTimeSeriesList.getSelectedTS()[i].name();\n        }\n        setTitle(\"Transform: \" + seriesNames);\n\n        tSList = newTimeSeriesList;\n        setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n    }\n",
    "125537": "    public String printShort() {\n        StringBuffer s = new StringBuffer();\n\n        if (subPeriodicity == 5 || subPeriodicity == 7) {\n            s.append(dailyFormatShort.format(getDate()));\n        } else {\n            s.append(mainPeriod);\n            switch (subPeriodicity) {\n            case (1):\n                break;\n            case (2):\n                if (subPeriod == 1)\n                    s.append(\"I\");\n                else\n                    s.append(\"II\");\n                break;\n            case (4):\n                s.append(\"Q\");\n                s.append(subPeriod);\n                break;\n            case (12):\n                s.append(\"M\");\n                s.append(subPeriod);\n                break;\n            default:\n                s.append(\" \");\n                s.append(subPeriod);\n                s.append(\"/\");\n                s.append(subPeriodicity);\n            }\n\n        }\n        return s.toString();\n    }\n",
    "125539": "    public Date getDate() {\n\n        if (date == null) {\n            if (subPeriodicity == 7 || subPeriodicity == 5) {\n                // first set date and then get it\n                calendar.setTime(START);\n                calendar.add(Calendar.WEEK_OF_YEAR, mainPeriod);\n                calendar.add(Calendar.DAY_OF_WEEK, subPeriod - 1);\n                date = calendar.getTime();\n            } else\n                throw new IllegalStateException(\n                        \"Conversion to java.util.Date is not implemented for this frequency.\");\n\n        }\n        return (Date) date.clone();\n    }\n",
    "125545": "    public String toString() {\n        StringBuffer s = new StringBuffer();\n\n        // daily data\n        if (subPeriodicity == 5 || subPeriodicity == 7) {\n            s.append(dateFormatUS.format(getDate()) + \" (\" + subPeriodicity + \")\");\n        } else {\n            s.append(mainPeriod);\n            switch (subPeriodicity) {\n            case (1):\n                break;\n            case (2):\n                if (subPeriod == 1)\n                    s.append(\" I\");\n                else\n                    s.append(\" II\");\n                break;\n            case (4):\n                s.append(\" Q\");\n                s.append(subPeriod);\n                break;\n            case (12):\n                s.append(\" M\");\n                s.append(subPeriod);\n                break;\n            default:\n                s.append(\" \");\n                s.append(subPeriod);\n                s.append(\"/\");\n                s.append(subPeriodicity);\n            }\n        }\n        return s.toString();\n    }\n",
    "125546": "    public String sprintf(String x) throws IllegalArgumentException {\n        Enumeration e = vFmt.elements();\n        ConversionSpecification cs = null;\n        char c = 0;\n        StringBuffer sb = new StringBuffer();\n        while (e.hasMoreElements()) {\n            cs = (ConversionSpecification) e.nextElement();\n            c = cs.getConversionCharacter();\n            if (c == '\\0')\n                sb.append(cs.getLiteral());\n            else if (c == '%')\n                sb.append(\"%\");\n            else\n                sb.append(cs.internalsprintf(x));\n        }\n        return sb.toString();\n    }\n",
    "125552": "        public void doAction(TSList tsList) {\n            if (transDialog == null)\n                transDialog = new TSTransDialog(TopFrameReference\n                        .getTopFrameRef(), true);\n            transDialog.setTSList(tsList);\n            transDialog.setVisible(true);\n        }\n",
    "125554": "        public void doAction(TSList tsList) {\n            if (dummyDialog == null)\n                dummyDialog = new TSDummyDialog(TopFrameReference\n                        .getTopFrameRef(), true);\n            dummyDialog.setTSList(tsList);\n            dummyDialog.setVisible(true);\n        }\n",
    "125555": "        public void doAction(TSList tsList) {\n            TS selection[] = tsList.getSelectedTS();\n            if (selection.length > 0) {\n                List<TSProject> list = new ArrayList<TSProject>();\n                for (int i = 0; i < selection.length; i++) {\n                    TSProject proj = selection[i].project();\n                    if (!list.contains(proj))\n                        list.add(proj);\n                }\n                StringBuffer des = new StringBuffer();\n                String marker = \"\\n------------------------------------\\n\";\n                for (TSProject proj : list)\n                    des.append(proj.getDescription().trim() + marker);\n                des.delete(des.length() - marker.length(), des.length());\n\n                JOptionPane.showMessageDialog(TopFrameReference\n                        .getTopFrameRef(), des.toString(),\n                        \"Project Description\", JOptionPane.INFORMATION_MESSAGE);\n                return;\n\n            }\n\n        }\n",
    "125559": "        public void doAction(TSList tsList) {\n            if (editDialog == null)\n                editDialog = new TSEditDialog(TopFrameReference\n                        .getTopFrameRef(), false);\n            editDialog.setTSList(tsList);\n            editDialog.setVisible(true);\n        }\n",
    "125560": "    private void keyTyped_ActionEvents(java.awt.event.KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_E && e.isControlDown())\n            execute_ActionEvents();\n    }\n",
    "125566": "    public boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (!(o instanceof TS))\n            return false;\n\n        TS otherTS = (TS) o;\n\n        boolean dataCheck = true;\n\n        synchronized (this) {\n            synchronized (o) {\n\n                if (!startTSDate.equals(otherTS.start()))\n                    return false;\n\n                if (!name.equalsIgnoreCase(otherTS.name()))\n                    return false;\n\n                if (type() != otherTS.type())\n                    return false;\n\n                dataCheck = numOfObs() == otherTS.numOfObs();\n                for (int i = 0; i < numOfObs() && dataCheck; i++)\n                    if (valueAt(i) != otherTS.valueAt(i))\n                        dataCheck = false;\n            }\n        }\n\n        return dataCheck;\n    }\n",
    "125567": "    public void enableForTSList(TSList tsList) {\n\n        setEnabled(tsList.getSelectedIndices().length != 0);\n        this.tSList = tsList;\n    }\n",
    "125568": "    private void namesList_MouseClicked(java.awt.event.MouseEvent mouseEvent) {\n        if (mouseEvent.getClickCount() == 2) {\n            int index = getNamesList().locationToIndex(mouseEvent.getPoint());\n            String toPut = variableListModel.elementAt(index).toString();\n            getInputField().getTextArea().insert(toPut,\n                    getInputField().getTextArea().getCaretPosition());\n        }\n\n        return;\n    }\n",
    "125573": "    public void setDescription(String dataDescription) {\n        if (dataDescription == null)\n            dataDescription = \"\";\n        this.description = dataDescription;\n    }\n",
    "125575": "    private void checkData(JSCData data, JSCTypes type, int index) {\n        if (data == null)\n            throw new RuntimeException(\n                    \"Error reading TS project data. Null data at array index \"\n                            + index + \".\");\n\n        if (!(data.type() == type && !data.isEmpty()))\n            throw new RuntimeException(\n                    \"Error reading TS project data. Expected nonempty \" + type\n                            + \" at array index \" + index + \", but was \"\n                            + data.type() + \" (empty=\" + data.isEmpty() + \").\");\n    }\n",
    "125578": "    public ProjectDataTypes getProjectDataType() {\n        return ProjectDataTypes.TS_DATA;\n    }\n",
    "125581": "    public TSDateRange addPeriodsToStart(int periods) {\n\n        return new TSDateRange(lowerBound.addPeriods(periods), upperBound);\n    }\n",
    "125585": "    public JSCNArray getSelectedIndices() {\n        return selectedIndices;\n    }\n",
    "125586": "    public void setSelectedIndices(JSCNArray selectedIndices) {\n        if (selectedIndices == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.selectedIndices = selectedIndices;\n    }\n",
    "125587": "    public JSCDRange getSelectedRange() {\n        return selectedRange;\n    }\n",
    "125589": "    public void setSelectedRange(JSCDRange selectedRange) {\n        if (selectedRange == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.selectedRange = selectedRange;\n    }\n",
    "125590": "    public JSCDRange getEnclosingRange() {\n        return enclosingRange;\n    }\n",
    "125591": "    public void setEnclosingRange(JSCDRange enclosingRange) {\n        if (enclosingRange == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        this.enclosingRange = enclosingRange;\n    }\n",
    "125593": "    public TS createTrendShiftDumTS(String name, TSDateRange shiftRange) {\n\n        if (name == null || name.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Trend shift name cannot be empty.\");\n\n        String check = encloses(shiftRange);\n        if (check != null)\n            throw new IllegalArgumentException(check);\n\n        double[] obs = createTrendShiftDum(shiftRange);\n\n        TS dummy = new TS(obs, name, lowerBound(), TSTypes.DETERMINISTIC);\n        return dummy;\n    }\n",
    "125595": "    public int hashCode() {\n        int result = hashPartResult;\n        synchronized (this) {\n            result = 37 * result + name.toLowerCase().hashCode();\n            result = 37 * result + tSType.hashCode();\n        }\n        return result;\n    }\n",
    "125598": "    public TS createShiftDumTS(String name, TSDateRange shiftRange) {\n\n        if (name == null || name.length() == 0)\n            throw new IllegalArgumentException(\"Dummy name cannot be empty.\");\n\n        String check = encloses(shiftRange);\n        if (check != null)\n            throw new IllegalArgumentException(check);\n\n        double[] obs = createShiftDum(shiftRange);\n\n        TS dummy = new TS(obs, name, lowerBound(), TSTypes.DETERMINISTIC);\n        return dummy;\n    }\n",
    "125600": "    public boolean isModelChanged() {\n        return modelChanged;\n    }\n",
    "125602": "    public Component prepareEditor(TableCellEditor editor, int row, int col) {\n        Component c = super.prepareEditor(editor, row, col);\n        if (c instanceof JTextField) {\n\n            JTextField ed = (JTextField) c;\n            ed.setHorizontalAlignment(SwingConstants.RIGHT);\n            // Get rendered text for editing default.\n            Component cc = cellRenderer.getTableCellRendererComponent(this,\n                    getValueAt(row, col), true, true, row, col);\n            if (cc instanceof JLabel)\n                ed.setText(((JLabel) cc).getText());\n            return ed;\n        }\n\n        return c;\n    }\n",
    "125603": "    public String encloses(TSDate date) {\n\n        if (date == null)\n            return date + \" is invalid date for \" + this + \".\";\n\n        if (date.subPeriodicity() != lowerBound.subPeriodicity())\n            return date + \" is invalid date for \" + this + \".\";\n\n        if (lowerBound.compareTo(date) < 0 || upperBound.compareTo(date) > 0)\n            return date + \" is not in \" + toString() + \".\";\n\n        return null;\n    }\n",
    "125605": "    public void print(PrintStream p) {\n        String[] timeIndex = range().timeAxisStringArray();\n        p.println(name + \" \" + range());\n        for (int i = 0; i < timeIndex.length; i++)\n            p.println(printfFormat.sprintf(timeIndex[i]) + \" \" + valueAt(i));\n\n    }\n",
    "125606": "    public void setPrecision(int newPrecision) {\n        if (newPrecision < 0)\n            throw new IllegalArgumentException(\"Negative precision argument.\");\n\n        int oldPrecision = precision;\n        this.precision = newPrecision;\n        if (oldPrecision != precision)\n            repaint();\n\n    }\n",
    "125607": "    public void setTablePopup(JPopupMenu newTablePopup) {\n\n        tablePopup = newTablePopup;\n        if (tablePopup == null)\n            removeMouseListener(triggerPopUp);\n        else {\n            triggerPopUp = new MouseAdapter() {\n                public void mouseReleased(MouseEvent e) {\n                    tablePopup.processMouseEvent(e, null, null);\n                }\n            };\n            addMouseListener(triggerPopUp);\n        }\n    }\n",
    "125608": "    public String encloses(TSDateRange otherRange) {\n\n        if (otherRange == null)\n            return otherRange + \" is invalid range for \" + this + \".\";\n        TSDate otherStart = otherRange.lowerBound();\n        TSDate otherEnd = otherRange.upperBound();\n\n        if (otherStart.subPeriodicity() != lowerBound.subPeriodicity())\n            return otherRange + \" is invalid range for \" + this + \".\";\n\n        if (lowerBound.compareTo(otherStart) < 0\n                || upperBound.compareTo(otherEnd) > 0)\n            return otherRange + \" is not in \" + toString() + \".\";\n\n        return null;\n    }\n",
    "125610": "    public void setTS(TS[] tsArray) {\n        tSModel.setTS(tsArray);\n        setCellRenderer(cellRenderer);\n        if (tsArray.length > 10)\n            setAutoResizeMode(AUTO_RESIZE_OFF);\n        else\n            setAutoResizeMode(AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n        modelChanged = false;\n    }\n",
    "125612": "    public void tableChanged(javax.swing.event.TableModelEvent evt) {\n        super.tableChanged(evt);\n        modelChanged = true;\n    }\n",
    "125613": "    public boolean equals(Object o) {\n        if (o == this)\n            return true;\n\n        if (!(o instanceof TSDateRange))\n            return false;\n\n        TSDateRange otherRange = (TSDateRange) o;\n        return lowerBound.equals(otherRange.lowerBound())\n                && upperBound.equals(otherRange.upperBound());\n    }\n",
    "125618": "    public String format(String description, int space) {\n        if (space < 0)\n            space = 0;\n        return new PrintfFormat(\"%-\" + space + \"s%s, T = %i\")\n                .sprintf(new Object[] { description, this,\n                        new Integer(this.numOfObs()) });\n\n        /*\n         * Format.sprintf( \"%-\" + space + \"s%s, T = %i\", new\n         * Parameters(description).add(this).add(this.getNumberOfObs()));\n         */\n\n    }\n",
    "125622": "    public void setName(String newValue) {\n\n        String error = JSCConstants.isValidName(newValue);\n\n        if (error != null)\n            throw new IllegalArgumentException(error);\n\n        synchronized (this) {\n            name = newValue;\n        }\n    }\n",
    "125623": "    public TSDate dateForIndex(int index) {\n        return lowerBound.addPeriods(index);\n    }\n",
    "125626": "    public int indexForDate(TSDate date) {\n\n        if (date == null\n                || date.subPeriodicity() != lowerBound.subPeriodicity())\n            throw new IllegalArgumentException(date + \" is invalid date for \"\n                    + this + \".\");\n\n        return lowerBound.compareTo(date);\n    }\n",
    "125631": "    public TSDate lowerBound() {\n        return lowerBound;\n    }\n",
    "125634": "    public int numOfObs() {\n        return lowerBound.compareTo(upperBound) + 1;\n    }\n",
    "125637": "    public void setTSType(TSTypes newTSType) {\n\n        TSTypes oldValue;\n\n        if (newTSType == null)\n            newTSType = guessTSType();\n\n        synchronized (this) {\n            oldValue = tSType;\n            tSType = newTSType;\n        }\n        // Outside synchronized region.\n        if (oldValue != newTSType)\n            firePropertyChange(TS_TYPE_CHANGED, name, name);\n    }\n",
    "125639": "    public int subPeriodicity() {\n        return lowerBound.subPeriodicity();\n    }\n",
    "125641": "    public TSDate upperBound() {\n        return upperBound;\n    }\n",
    "125642": "    public String toString() {\n        StringBuffer ts = new StringBuffer();\n\n        synchronized (this) {\n            ts.append(super.toString() + \" [name=\" + name);\n            ts.append(\",start=\" + startTSDate);\n            ts.append(\",obs=\" + numOfObs());\n\n            if (dataArray.length > 0) {\n                ts.append(\",first=\" + dataArray[0]);\n                ts.append(\",last=\" + dataArray[dataArray.length - 1]);\n            }\n            ts.append(\",project=\" + project());\n            ts.append(\",type=\" + type());\n        }\n        ts.append(\"]\");\n\n        return ts.toString();\n    }\n",
    "125645": "    private void oK_ActionEvents() {\n        TableCellEditor ed = getTSTable().getCellEditor();\n        if (ed != null)\n            ed.stopCellEditing();\n\n        if (!getTSTable().isModelChanged()) {\n            setVisible(false);\n            return;\n        }\n        TS[] sel = getTSTable().getTS();\n\n        int accept = JOptionPane.showConfirmDialog(TopFrameReference\n                .getTopFrameRef(), \"Do you want to save your changes?\",\n                \"Question\", JOptionPane.YES_NO_OPTION);\n\n        if (accept == JOptionPane.YES_OPTION)\n            for (int i = 0; i < sel.length; i++) {\n                TSHolder.getInstance().removeTS(sel[i].name());\n                TSHolder.getInstance().addTS(sel[i]);\n            }\n        setVisible(false);\n\n    }\n",
    "125646": "    public int hashCode() {\n\n        int result = 17;\n        result = 37 * result + lowerBound.hashCode();\n        result = 37 * result + upperBound.hashCode();\n\n        return result;\n    }\n",
    "125648": "    public TSDateRange mergedRange(TSDateRange otherRange) {\n        if (otherRange == null)\n            throw new IllegalArgumentException(\"Range argument was null.\");\n\n        TSDate otherStart = otherRange.lowerBound();\n        TSDate otherEnd = otherRange.upperBound();\n\n        // Sub periodicities do not match.\n        if (otherStart.subPeriodicity() != lowerBound.subPeriodicity())\n            throw new IllegalArgumentException(otherRange + \" and \" + this\n                    + \" cannot be merged.\");\n\n        TSDate erliestStart = (lowerBound.compareTo(otherStart) > 0) ? lowerBound\n                : otherStart;\n        TSDate latestEnd = (upperBound.compareTo(otherEnd) < 0) ? upperBound\n                : otherEnd;\n\n        return new TSDateRange(erliestStart, latestEnd);\n    }\n",
    "125652": "    public String toString() {\n        return \"[\" + lowerBound + \", \" + upperBound + \"]\";\n    }\n",
    "125653": "    public void setTSList(TSList newTimeSeriesList) {\n\n        tSList = newTimeSeriesList;\n        TS sel[] = tSList.getSelectedTS();\n        setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n        getTSTable().setTS(sel);\n\n        searchIndex = 0;\n    }\n",
    "125656": "        public void addElement(Object obj) {\n            if (getSize() == 0) {\n                super.addElement(obj);\n                return;\n            }\n            String toAdd = obj.toString();\n            String toCompare = toAdd.toUpperCase();\n            // Add alphabetically sorted.\n            for (int i = 0; i < getSize(); i++) {\n                if (getElementAt(i).toString().toUpperCase().compareTo(\n                        toCompare) >= 0) {\n                    super.add(i, toAdd);\n                    return;\n                }\n            }\n            // If it was not yet added, append it to the end.\n            super.addElement(obj);\n\n        }\n",
    "125657": "    public int getColumnCount() {\n        if (dataArray.length > 0)\n            return dataArray[0].length;\n        return 0;\n\n    }\n",
    "125658": "    public String getColumnName(int col) {\n        if (namesArray.length > 0)\n            return namesArray[col];\n\n        return null;\n    }\n",
    "125659": "        public boolean removeElement(Object obj) {\n            if (super.removeElement(obj))\n                return true;\n            String toAdd = obj.toString();\n            // Add alphabetically sorted.\n            for (int i = 0; i < getSize(); i++) {\n                String obj_i = getElementAt(i).toString();\n                if (obj_i.equalsIgnoreCase(toAdd)) {\n                    return super.removeElement(obj_i);\n                }\n            }\n            return false;\n\n        }\n",
    "125661": "    public double getDoubleValueAt(int row, int col) {\n        if (getRowCount() > 0 && getColumnCount() > 0)\n            return dataArray[row][col].doubleValue();\n        return Double.NaN;\n    }\n",
    "125662": "    public void setTS(TS[] newTimeSeries) {\n        if (newTimeSeries == null)\n            throw new IllegalArgumentException(\"Argument was null.\");\n        synchronized (this) {\n            removeAllTS();\n            for (int i = 0; i < newTimeSeries.length; i++) {\n                addTS(newTimeSeries[i]);\n            }\n        }\n    }\n",
    "125664": "    public int getRowCount() {\n        return dataArray.length;\n\n    }\n",
    "125668": "    public boolean contains(String name) {\n        if (name != null)\n            name = name.toLowerCase();\n        return tsHashTable.containsKey(name);\n    }\n",
    "125675": "    public void removeTS(String name) {\n        boolean fireChanged = false;\n\n        synchronized (this) {\n            if (tsHashTable.containsKey(name.toLowerCase())) {\n                tsListModel.removeElement(name);\n                tsHashTable.remove(name.toLowerCase());\n                fireChanged = true;\n            }\n        }\n        // Outside the synchronized region.\n        if (fireChanged)\n            firePropertyChange(TS_REMOVED, name, name);\n    }\n",
    "125677": "    public TSDate getStartTSDate() {\n        return startDate;\n    }\n",
    "125678": "    public void removeAllTS() {\n        synchronized (this) {\n            if (tsHashTable.size() == 0)\n                return;\n            tsListModel.clear();\n            tsHashTable.clear();\n        }\n        // Outside the synchronized region.\n        firePropertyChange(ALL_TS_REMOVED, null, null);\n    }\n",
    "125680": "    public Object getValueAt(int row, int col) {\n        if (getRowCount() > 0 && getColumnCount() > 0)\n            return dataArray[row][col];\n        return null;\n    }\n",
    "125681": "    public String toString() {\n        StringBuffer ret = new StringBuffer(super.toString() + \" [\");\n        for (String name : tsHashTable.keySet()) {\n            ret.append(\"\\\"\" + name + \"\\\",\");\n        }\n        if (tsHashTable.size() > 0)\n            ret.deleteCharAt(ret.length() - 1);\n        ret.append(\"]\");\n        return ret.toString();\n    }\n",
    "125682": "    public boolean isCellEditable(int row, int col) {\n        return editable;\n    }\n",
    "125695": "    public String getAllDataName() {\n        if (allDataDef == null)\n            return null;\n\n        return allDataDef.name;\n\n    }\n",
    "125702": "    public String getAllStringsName() {\n        if (allStringsDef == null)\n            return null;\n\n        return allStringsDef.name;\n\n    }\n",
    "125722": "    public String getDeterministicDataName() {\n        if (deterministicDataDef == null)\n            return null;\n\n        return deterministicDataDef.name;\n    }\n",
    "125725": "    public String getMessage() {\n        return super.getMessage();\n    }\n",
    "125731": "    public boolean getDeterministicEnabled() {\n        return getDetSelList().isEnabled();\n    }\n",
    "125741": "    public String getDeterministicStringsName() {\n        if (deterministicStringsDef == null)\n            return null;\n\n        return deterministicStringsDef.name;\n\n    }\n",
    "125749": "    private JLabel getRangeLabel() {\n        if (rangeLabel == null) {\n            rangeLabel = new JLabel();\n            rangeLabel.setFont(CompSettings.smallFontDefault);\n            rangeLabel.setPreferredSize(new Dimension(100, 20));\n            rangeLabel.setMinimumSize(new Dimension(100, 20));\n        }\n        return rangeLabel;\n\n    }\n",
    "125762": "    public String getEndogenousDataName() {\n        if (endogenousDataDef == null)\n            return null;\n\n        return endogenousDataDef.name;\n    }\n",
    "125763": "    private JCheckBox getTrendShiftCheck() {\n        if (trendShiftCheck == null) {\n            trendShiftCheck = new JCheckBox();\n            trendShiftCheck.setText(\"Trend shift dummy\");\n            trendShiftCheck.setLocation(37, 162);\n            trendShiftCheck.setSize(173, 21);\n            trendShiftCheck\n                    .addActionListener(new java.awt.event.ActionListener() {\n                        public void actionPerformed(java.awt.event.ActionEvent e) {\n                            boolean sel = trendShiftCheck.isSelected();\n                            getTrendShiftRange().setEnabled(sel);\n                            getTrendShiftName().setEnabled(sel);\n\n                        }\n                    });\n        }\n        return trendShiftCheck;\n    }\n",
    "125774": "    public String getEndogenousStringsName() {\n        if (endogenousStringsDef == null)\n            return null;\n\n        return endogenousStringsDef.name;\n    }\n",
    "125775": "    private TSDateRangeSelector getTrendShiftRange() {\n        if (trendShiftRange == null) {\n            trendShiftRange = new TSDateRangeSelector();\n            trendShiftRange.setEnabled(false);\n            trendShiftRange.setSize(150, 20);\n            trendShiftRange.setLocation(185, 192);\n        }\n        return trendShiftRange;\n    }\n",
    "125781": "    private VarNameSelector getTrendShiftName() {\n        if (trendShiftName == null) {\n            trendShiftName = new VarNameSelector();\n            trendShiftName.setEnabled(false);\n            trendShiftName.setLocation(185, 212);\n            trendShiftName.setSize(150, 20);\n            trendShiftName.setVarName(\"trendshift\");\n        }\n        return trendShiftName;\n    }\n",
    "125785": "    public String getExogenousDataName() {\n        if (exogenousDataDef == null)\n            return null;\n\n        return exogenousDataDef.name;\n    }\n",
    "125791": "    public void setTSList(TSList newTimeSeriesList) {\n\n        TS ts = newTimeSeriesList.getSelectedTS()[0];\n        setTitle(\"Create Dummy for \" + ts.range());\n\n        getTSDateRangeSelShift().setEnclosingRange(ts.range());\n        getTSDateSelectorImpulse().setEnclosingRange(ts.range());\n        getTrendShiftRange().setEnclosingRange(ts.range());\n\n        setLocationRelativeTo(TopFrameReference.getTopFrameRef());\n\n    }\n",
    "125797": "    public String getDateRangeName() {\n        if (dateRangeDef == null)\n            return null;\n\n        return dateRangeDef.name;\n    }\n",
    "125810": "    public boolean getExogenousEnabled() {\n        return getExSelList().isEnabled();\n    }\n",
    "125822": "    public String getExogenousStringsName() {\n        if (exogenousStringsDef == null)\n            return null;\n\n        return exogenousStringsDef.name;\n    }\n",
    "125824": "    final public void tshalfyearly() throws ParseException {\n        TSDate mainDate;\n        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {\n        case HALFYEAR1:\n            jj_consume_token(HALFYEAR1);\n            mainDate = (TSDate) argStack.pop();\n            argStack.push(new TSDate(mainDate.mainPeriod(), 1, 2));\n            break;\n        case HALFYEAR2:\n            jj_consume_token(HALFYEAR2);\n            mainDate = (TSDate) argStack.pop();\n            argStack.push(new TSDate(mainDate.mainPeriod(), 2, 2));\n            break;\n        default:\n            jj_la1[8] = jj_gen;\n            jj_consume_token(-1);\n            throw new ParseException();\n        }\n    }\n",
    "125828": "    final public void tsmonthly() throws ParseException {\n        Token x;\n        jj_consume_token(MONTH);\n        x = jj_consume_token(INTEGER);\n        int subPeriod = Double.valueOf(x.image).intValue();\n        TSDate mainDate = (TSDate) argStack.pop();\n        argStack.push(new TSDate(mainDate.mainPeriod(), subPeriod, 12));\n    }\n",
    "125832": "    public int getSelectionMode() {\n        return getTSList().getSelectionMode();\n    }\n",
    "125833": "    final public void tsquarterly() throws ParseException {\n        Token x;\n        jj_consume_token(QUARTER);\n        x = jj_consume_token(INTEGER);\n        int subPeriod = Double.valueOf(x.image).intValue();\n        TSDate mainDate = (TSDate) argStack.pop();\n        argStack.push(new TSDate(mainDate.mainPeriod(), subPeriod, 4));\n    }\n",
    "125838": "\tpublic void dispatch(SelectionKey key) {\n\t\tRunnable r = (Runnable) (key.attachment());\n\t\tif (r != null) {\n\t\t\tr.run();\n\t\t}\n\t}\n",
    "125844": "\tpublic void destroy() {\n\t\talive = false;\n\t}\n",
    "125846": "\tpublic Selector getSelector() {\n\t\treturn selector;\n\t}\n",
    "125847": "    public void clearVariableMap() {\n        variableMap.clear();\n    }\n",
    "125848": "\tpublic ThreadPoolExecutor getThreadPoolExecutor() {\n\t\treturn threadPool;\n\t}\n",
    "125850": "    public void putVariable(String keyName, double[] dataArray) {\n        String error = JSCConstants.isValidName(keyName);\n        if (error != null)\n            throw new IllegalArgumentException(\"Bad key: \" + error);\n        if (dataArray == null)\n            throw new IllegalArgumentException(\"Data array was null.\");\n        double[] varArray = new double[dataArray.length];\n        for (int i = 0; i < dataArray.length; i++)\n            varArray[i] = dataArray[i];\n        variableMap.put(keyName, varArray);\n    }\n",
    "125851": "\tpublic ICipherSetSpec getCipherSpec() {\n\t\treturn cipherSpec;\n\t}\n",
    "125853": "\tpublic CryptoSpec getDHSpec() {\n\t\treturn dhSpec;\n\t}\n",
    "125855": "\tpublic void setCipherSpec(ICipherSetSpec cipherSpec) {\n\t\tReactor.cipherSpec = cipherSpec;\n\t}\n",
    "125856": "    public String getOutput() {\n        String output = \"\";\n        if (outputBuffer.length() > 0)\n            output = outputBuffer.toString();\n        outputBuffer.delete(0, outputBuffer.length());\n        return output;\n    }\n",
    "125858": "\tpublic void setDHSpec(CryptoSpec dhSpec) {\n\t\tReactor.dhSpec = dhSpec;\n\t}\n",
    "125860": "\tpublic void setPort(int port) {\n\t\tReactor.port = port;\n\t}\n",
    "125861": "\tpublic void setBacklog(int backlog) {\n\t\tReactor.backlog = backlog;\n\t}\n",
    "125864": "\tpublic void setBufferSize(int bufferSize) {\n\t\tReactor.bufferSize = bufferSize;\n\t}\n",
    "125867": "\tpublic void setThreadPoolSpec(IThreadPoolSpec threadPoolSpec) {\n\t\tReactor.threadPoolSpec = threadPoolSpec;\n\t}\n",
    "125870": "\tpublic int getPort() {\n\t\treturn port;\n\t}\n",
    "125873": "\tpublic int getBacklog() {\n\t\treturn backlog;\n\t}\n",
    "125876": "\tpublic int getBufferSize() {\n\t\treturn bufferSize;\n\t}\n",
    "125880": "\tpublic IThreadPoolSpec getThreadPoolSpec() {\n\t\treturn threadPoolSpec;\n\t}\n",
    "125911": "    public Connection borrow()throws DBException{\n        synchronized (this){\n            if(connections.size()>0){\n                Key key = (Key)connections.get(connections.size()-1);\n                connections.remove(key);\n                busy.add(key.connection);\n                return key.connection;\n            }else{\n                Connection con = createConnection();\n                busy.add(con);\n                return con;\n            }\n        }\n    }\n",
    "125924": "    public void clean()throws DBException{\n        synchronized(this){\n            try{\n                long currentTime = (new Date()).getTime();\n                clean(currentTime, connections.size()-1);\n            }catch(SQLException e){\n                throw new DBException(e);\n            }\n        }\n    }\n",
    "125933": "    private void maxRangeButton_ActionEvents() {\n        TSList list = getTSList();\n        if (list.getSelectedIndex() == -1)\n            return;\n\n        // To prevent ListSelectionEvents when removing a selection\n        // automatically.\n        list.removeListSelectionListener(myEventHandler);\n\n        // Savety belt to ensure that ListSelectionListener is added again, even\n        // if something goes wrong. This should not happen.\n        try {\n            // Select max possible range in time series.\n            tsDateRangeCheck(true);\n\n        } catch (Throwable ex) {\n            log.error(\"Failed to set maximum range\", ex);\n        }\n\n        // Adds the ListSelectionListener again.\n        list.addListSelectionListener(myEventHandler);\n        return;\n    }\n",
    "125961": "    public Map getObjectMap(){\n        return map;\n    }\n",
    "125978": "\tprotected String modify(String args) {\n\t\ttry {\n\t\t\tString subCommand = args.substring(0, args.indexOf(\" \"));\n\n\t\t\tif (subCommand.equals(SUB_MODIFY_ADD)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyAddUser(newArgs);\n\t\t\t} else if (subCommand.equals(SUB_MODIFY_REMOVE)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyRemoveUser(newArgs);\n\t\t\t} else {\n\t\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t\t}\n\n\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t}\n\n\t}\n",
    "125979": "\tprotected String modify(String args) {\n\t\ttry {\n\t\t\tString subCommand = args.substring(0, args.indexOf(\" \"));\n\n\t\t\tif (subCommand.equals(SUB_MODIFY_GROUPS)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyGroups(newArgs);\n\t\t\t} else if (subCommand.equals(SUB_MODIFY_USERS)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyUsers(newArgs);\n\t\t\t} else {\n\t\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t\t}\n\n\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t}\n\n\t}\n",
    "125982": "\tprotected String modifyUsers(String args) {\n\t\ttry {\n\t\t\tString subCommand = args.substring(0, args.indexOf(\" \"));\n\n\t\t\tif (subCommand.equals(SUB_MODIFY_ADD)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyUsersAdd(newArgs);\n\t\t\t} else if (subCommand.equals(SUB_MODIFY_REMOVE)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyUsersRemove(newArgs);\n\t\t\t} else {\n\n\t\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t\t}\n\n\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t}\n\t}\n",
    "125984": "    public void setAllDataName(String allDataName) {\n\n        if (allDataName == null)\n            allDataDef = null;\n        else\n            allDataDef = new JSCTypeDef(allDataName, JSCTypes.NARRAY);\n\n    }\n",
    "125986": "\tpublic int unique() throws DBException {\n\t\tjava.security.SecureRandom ran = new java.security.SecureRandom();\n\t\tint unique = ran.nextInt();\n\t\tif (unique < 0) {\n\t\t\tunique = unique * -1;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (isID(unique)) {\n\t\t\t\tunique = ran.nextInt();\n\t\t\t\tif (unique < 0) {\n\t\t\t\t\tunique = unique * -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn unique;\n\t}\n",
    "125987": "\tprotected String modifyGroups(String args) {\n\t\ttry {\n\t\t\tString subCommand = args.substring(0, args.indexOf(\" \"));\n\n\t\t\tif (subCommand.equals(SUB_MODIFY_ADD)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyGroupsAdd(newArgs);\n\t\t\t} else if (subCommand.equals(SUB_MODIFY_REMOVE)) {\n\t\t\t\tString newArgs = args.substring(args.indexOf(\" \") + 1, args.length());\n\t\t\t\treturn modifyGroupsRemove(newArgs);\n\t\t\t} else {\n\n\t\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t\t}\n\n\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn ERROR_IMPROPER_INPUT;\n\t\t}\n\n\t}\n",
    "125988": "\tpublic String getType() {\n\t\treturn null;\n\t}\n",
    "125990": "\tpublic TransferObject create() throws DBException {\n\t\treturn null;\n\t}\n",
    "125993": "\tpublic List get(String field, Object obj) throws DBException {\n\t\treturn null;\n\t}\n",
    "125997": "\tprotected boolean isID(int a) {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = pool.borrow();\n\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"SELECT \" + ID + \" FROM \" + table + \" WHERE \" + ID + \" = ?\");\n\n\t\t\tstmt.setInt(1, a);\n\n\t\t\tResultSet set = stmt.executeQuery();\n\n\t\t\treturn set.next();\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (con != null) {\n\t\t\t\t\tpool.putBack(con);\n\t\t\t\t}\n\t\t\t} catch (DBException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "125998": "    public void setAllStringsName(String allStringsName) {\n\n        if (allStringsName == null)\n            allStringsDef = null;\n        else\n            allStringsDef = new JSCTypeDef(allStringsName, JSCTypes.SARRAY);\n\n    }\n",
    "126000": "\tprotected void create(int id) throws DBException {\n\t\ttry {\n\t\t\tConnection con = pool.borrow();\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"INSERT INTO \" + table + \" (\" + ID + \") VALUES(?)\");\n\t\t\tstmt.setInt(1, id);\n\t\t\tstmt.executeUpdate();\n\t\t\tpool.putBack(con);\n\t\t} catch (SQLException e) {\n\t\t\tthrow new DBException(e);\n\t\t}\n\t}\n",
    "126002": "\tprotected ResultSet getSet(String field, String data) throws DBException {\n\t\ttry {\n\t\t\tConnection con = pool.borrow();\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"SELECT \" + ID + \" FROM \" + table + \" WHERE \" + field + \" = ?\");\n\n\t\t\tstmt.setString(1, data);\n\t\t\tpool.putBack(con);\n\t\t\treturn stmt.executeQuery();\n\t\t} catch (SQLException e) {\n\t\t\tthrow new DBException(e);\n\t\t}\n\t}\n",
    "126005": "\tprotected void delete(String field, String data) throws DBException {\n\t\ttry {\n\t\t\tConnection con = pool.borrow();\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"DELETE FROM \" + table + \" WHERE \" + field + \" = ?\");\n\n\t\t\tstmt.setString(1, data);\n\t\t\tstmt.executeUpdate();\n\t\t\tpool.putBack(con);\n\n\t\t} catch (SQLException e) {\n\t\t\tthrow new DBException(e);\n\t\t}\n\t}\n",
    "126008": "\tprotected String list() {\n\t\ttry {\n\t\t\tDAObject dao = PersistenceManager.getDAOFactory().getDAObject(SQLAccessPolicysDAO.TYPE);\n\t\t\tjava.util.List list = dao.getAll();\n\t\t\tString response = \"----------------------------------------\\n\";\n\n\t\t\tfor (int x = 0; x < list.size(); x++) {\n\n\t\t\t\tSQLAccessPolicyTAO tao = (SQLAccessPolicyTAO) list.get(x);\n\n\t\t\t\tresponse = response +\n\t\t\t\t\t\t\"Policy ID = \" + tao.getID() + \"\\n\" +\n\t\t\t\t\t\t\"Policy Name = \" + tao.getName() + \"\\n\" +\n\t\t\t\t\t\t\"Policy Users = \" + tao.getString(tao.FIELD_USERS) + \"\\n\" +\n\t\t\t\t\t\t\"Policy Groups = \" + tao.getString(tao.FIELD_GROUPS) + \"\\n\" +\n\t\t\t\t\t\t\"----------------------------------------\\n\";\n\n\t\t\t}\n\t\t\treturn response;\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"Unknown error listing policys\";\n\t}\n",
    "126013": "    public void setDatesEditable(boolean newDatesEditable) {\n        fieldDatesEditable = newDatesEditable;\n        getTSDateRangeSelector().setEditable(fieldDatesEditable);\n    }\n",
    "126014": "\tprotected String create(String args) {\n\t\ttry {\n\t\t\tDAObject dao = PersistenceManager.getDAOFactory().getDAObject(SQLAccessPolicysDAO.TYPE);\n\t\t\tAccessPolicy policy = (AccessPolicy) dao.create();\n\t\t\tpolicy.setName(args);\n\t\t\treturn \"Policy \" + policy.getName() + \" created.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"Error creating policy \" + args + \":\" + e.getMessage();\n\t\t}\n\n\t}\n",
    "126020": "\tprotected String remove(String args) {\n\t\ttry {\n\t\t\tDAObject dao = PersistenceManager.getDAOFactory().getDAObject(SQLAccessPolicysDAO.TYPE);\n\n\t\t\tdao.delete(SQLAccessPolicyTAO.FIELD_NAME, (Object) args);\n\n\t\t\treturn args + \" deleted.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"Error deleting policy \" + args + \":\" + e.getMessage();\n\t\t}\n\n\t}\n",
    "126021": "    public void addUser(User user){\n        add((SQLBasicTAO)user, FIELD_USERS);\n    }\n",
    "126022": "    public void removeUser(User user){\n        remove((SQLBasicTAO)user,FIELD_USERS);\n    }\n",
    "126024": "\tpublic String getType() {\n\t\treturn TABLE;\n\t}\n",
    "126025": "    public List getUsers(){\n        List ids = getList(FIELD_USERS);\n\tList users = new java.util.ArrayList();\n\t\n\tfor (int x = 0;x<ids.size();x++){\n\t\tusers.add(new SQLUserTAO(pool,new Integer((String)ids.get(x))));\n\t}\n\treturn users;\n\t\t\n    }\n",
    "126030": "\tpublic void delete(String field, Object obj) throws DBException {\n\t\tdelete(field, (String) obj);\n\t}\n",
    "126032": "\tpublic TransferObject create() throws DBException {\n\t\tint id = unique();\n\t\tcreate(id);\n\t\treturn (TransferObject) new SQLUserTAO(pool, new Integer(id));\n\t}\n",
    "126037": "\tpublic String getString(String field) {\n\t\ttry {\n\t\t\tResultSet results = getValue(field);\n\t\t\tresults.next();\n\n\t\t\treturn results.getString(field);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n",
    "126038": "    public void setDeterministicDataName(String deterministicDataName) {\n\n        if (deterministicDataName == null)\n            deterministicDataDef = null;\n        else\n            deterministicDataDef = new JSCTypeDef(deterministicDataName,\n                    JSCTypes.NARRAY);\n\n    }\n",
    "126042": "\tpublic void setValue(String field, String value) {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = pool.borrow();\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"UPDATE \" + table + \" SET \" + field +\n\t\t\t\t\t\" = '\" + value + \"' WHERE \" + ID_FIELD +\n\t\t\t\t\t\" = ?\");\n\t\t\tstmt.setInt(1, id);\n\t\t\tstmt.executeUpdate();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tpool.putBack(con);\n\t\t\t} catch (DBException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n",
    "126046": "\tpublic void setValue(String field, byte[] bytes) {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = pool.borrow();\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"UPDATE \" + table + \" SET \" + field +\n\t\t\t\t\t\" = ? WHERE \" + ID_FIELD + \" = ?\");\n\n\t\t\tstmt.setBytes(1, bytes);\n\t\t\tstmt.setInt(2, id);\n\t\t\tstmt.execute();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tpool.putBack(con);\n\t\t\t} catch (DBException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n",
    "126051": "\tpublic ResultSet getValue(String field) {\n\t\tConnection con = null;\n\t\ttry {\n\t\t\tcon = pool.borrow();\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"SELECT \" + field + \" FROM \" + table +\n\t\t\t\t\t\" WHERE \" + ID_FIELD + \" = ?\");\n\t\t\t\n\t\t\tstmt.setInt(1, id);\n\n\t\t\tResultSet set = stmt.executeQuery();\n\t\t\treturn set;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tpool.putBack(con);\n\t\t\t} catch (DBException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "126066": "\tpublic boolean contains(SQLBasicTAO tao, String field) {\n\t\tConnection con = null;\n\n\t\ttry {\n\t\t\tcon = pool.borrow();\n\n\t\t\tString param = \"%{\" + tao.getID() + \"}%\";\n\t\t\t\n\t\t\tString statement = \"SELECT \" + field + \" FROM \" + table +\n\t\t\t\t\t\" WHERE \" + ID_FIELD + \" = ? \" +\n\t\t\t\t\t\" AND \" + field + \" LIKE ?\";\n\t\t\t\t\t\n\t\t        \n\t\t\tPreparedStatement stmt = con.prepareStatement(statement);\n\t\t\t\t\t\n\t\t\tstmt.setInt(1, id);\n\t\t\tstmt.setString(2,param);\n\t\t\t\n\t\t\tResultSet results = stmt.executeQuery();\n\n\t\t\treturn results.next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tpool.putBack(con);\n\t\t\t} catch (DBException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "126068": "\tpublic void update() throws DBException {\n\n\t}\n",
    "126070": "\tpublic void delete(String field, Object obj) throws DBException {\n\t\tif(obj instanceof String)\n\t\t\tdelete(field, (String) obj);\n\t\t\n\t}\n",
    "126071": "\tpublic void delete() throws DBException {\n\t\tConnection con = pool.borrow();\n\t\ttry {\n\n\t\t\tPreparedStatement stmt = con.prepareStatement(\n\t\t\t\t\t\"DELETE FROM \" + table + \" WHERE \" + ID_FIELD + \" = ?\");\n\n\t\t\tstmt.setInt(1, id);\n\t\t\tstmt.executeUpdate();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tpool.putBack(con);\n\t\t}\n\t}\n",
    "126072": "\tpublic TransferObject create() throws DBException {\n\t\ttry {\n\t\t\tint id = unique();\n\n\t\t\tClass taoClass = Class.forName(taoName);\n\t\t\tjava.lang.reflect.Constructor[] constructors =\n\t\t\t\t\ttaoClass.getConstructors();\n\n\t\t\tObject tao = constructors[0].newInstance(\n\t\t\t\t\tnew Object[]{pool, new Integer(id)});\n\t\t\tcreate(id);\n\n\t\t\treturn (TransferObject) tao;\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new DBException(e);\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow new DBException(e);\n\t\t}catch (IllegalAccessException e) {\n\t\t\tthrow new DBException(e);\n\t\t}catch (java.lang.reflect.InvocationTargetException e) {\n\t\t\tthrow new DBException(e);\n\t\t}\n\t}\n",
    "126074": "\tpublic int hashCode() {\n\t\t\n\t\treturn id;\n\t}\n",
    "126078": "\tpublic boolean equals(Object o) {\n\t\treturn hashCode() == o.hashCode();\n\t}\n",
    "126087": "    public void setDeterministicEnabled(boolean arg1) {\n        getDetSelList().setEnabled(arg1);\n    }\n",
    "126089": "\tpublic void execute(Communicator communicator, String args) {\n\t}\n",
    "126091": "\tpublic void setCommandPolicy(CommandPolicy policy) {\n\t\tpolicy.setName(name);\n\t\tthis.policy = policy;\n\t}\n",
    "126093": "\tpublic void getCommandPolicy(CommandPolicy policy) {\n\t\tthis.policy = policy;\n\t}\n",
    "126096": "    public void execute(Communicator entity, Object object){\n        \n        String content = (String)object;\n        String command;\n        \n        int spaceIndex = content.indexOf(\" \");\n        \n        if(spaceIndex != -1)\n           command = content.substring(0, spaceIndex);\n        else\n            command = content;\n        \n        TextCommand a = (TextCommand)actions.get(command.toLowerCase());\n        if(a != null){\n            String args = content.substring(content.indexOf(\" \")+1, content.length());\n            a.execute(entity, args);\n         \n        }else{\n            entity.write(TYPE, command+\": is not a valid command\");\n        }\n    }\n",
    "126099": "    public void addCommand(TextCommand textCommand){\n        actions.put(textCommand.getName(), textCommand);\n    }\n",
    "126142": "    public void setDeterministicStringsName(String deterministicStringsName) {\n\n        if (deterministicStringsName == null)\n            deterministicStringsDef = null;\n        else\n            deterministicStringsDef = new JSCTypeDef(deterministicStringsName,\n                    JSCTypes.SARRAY);\n\n    }\n",
    "126157": "    public String getTransform(){\n        return transform;\n    }\n",
    "126158": "    public void setTransform(String transform){\n        this.transform = transform;\n    }\n",
    "126169": "    protected int getInt(byte[] array){\n        int i = ((array[3]&0xFF)<<24) |\n                ((array[2]&0xFF)<<16) |\n                ((array[1]&0xFF)<<8)  |\n                (array[0]&0xFF);\n        return i;\n    }\n",
    "126208": "    public void setEnabled(boolean enabled) {\n\n        super.setEnabled(enabled);\n        getTSList().setEnabled(enabled);\n        if (getDatesEditable() && (getTSList().getSelectedIndex() > -1)) {\n            getTSDateRangeSelector().setEnabled(enabled);\n        }\n\n    }\n",
    "126215": "\tpublic void testWorkspaceModulesetHimself() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-multiproject/moduleA\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126218": "\tpublic void parse(InputStream input, OutputStream output) {\n\t\tlineinput = new LineNumberInputStream(input);\n\t\tdatainput = new DataInputStream(lineinput);\n\t\tthis.output = output;\n\t\t\n\t\tSystem.out.println(version);\n\n\t\ttry {\n\t\t\twhile(doLine());\n\t\t} catch (IOException e) {\n\t\t\tlogger.warning(\"I/O error: \" + e.getMessage());\n\t\t}\n\t}\n",
    "126219": "\tpublic void testWorkspaceModulesetDependent() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-multiproject/moduleB\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126222": "\tpublic void execute() {\n\t\t\n\t\ttry {\t\t\n\t\t\tParser parser = new Parser();\n\t\t\t\n\t\t\tProperties ppProps = new Properties();\n\t\t\tHashtable antProps = project.getProperties();\n\t\t\tEnumeration en = antProps.keys();\n\t\t\t\n\t\t\twhile (en.hasMoreElements()) {\n\t\t\t\tString key = (String)en.nextElement();\n\t\t\t\tppProps.setProperty(key, antProps.get(key).toString());\n\t\t\t}\n\n\t\t\tparser.getParserState().setProperties(ppProps);\n\t\t\t\n\t\t\t// Parse file\n\t\t\tFileOutputStream outputstream = new FileOutputStream(outfile);\n\t\t\tparser.parse(new FileInputStream(infile), outputstream);\n\t\t\toutputstream.close();\n\n\t\t} catch (Exception e) {\n\t\t\tthrow new BuildException(e.getMessage());\n\t\t}\n\t\n\t}\n",
    "126225": "\tpublic void testNoChange() {\n\t\tString testDir = \"src/test/ant/it-nochange/\";\n\t\trunAnt(testDir);\n\t\tFile ref = new File(\"src/test/ant/it-nochange/initial_dotclasspath.xml\");\n\t\tFile classpathF = new File(\"src/test/ant/it-nochange/.classpath\");\n\t\tassertEquals(ref.lastModified() , classpathF.lastModified());\n\t}\n",
    "126229": "\tpublic void pushState(ParserState state) {\n\t\tstack.push(state);\n\t}\n",
    "126231": "\tpublic void testNoDependency() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-nodep/\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126232": "\tpublic ParserState popState() {\n\t\tif (stack.size() > 0) {\n\t\t\treturn (ParserState)stack.pop();\n\t\t} else {\n\t\t\tthrow new UnbalancedConditionException();\n\t\t}\n\t}\n",
    "126234": "\tpublic ParserState getCurrentState() {\n\t\tif (stack.size() > 0) {\n\t\t\treturn (ParserState)stack.peek();\n\t\t} else {\n\t\t\t// State machine is empty, return root state.\n\t\t\treturn new ParserState(ParserState.ROOT_STATE, ParserState.ROOT_STATE, true);\n\t\t}\n\t}\n",
    "126238": "\tpublic void testNoInitialClasspath() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-noinitialclasspath/\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126243": "\tpublic void testRemoveDep() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-removedep/\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126246": "\tpublic void testScrPath() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-src-path/\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126249": "\tpublic void testScrUpdate() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n//\t\tString testDir = \"src/test/ant/it-src-update/\";\n//\t\trunAntAndCompare(testDir);\n\t}\n",
    "126252": "\tpublic void testUpgradeDependecy() throws FileNotFoundException, SAXException, IOException, ParserConfigurationException {\n\t\tString testDir = \"src/test/ant/it-upgradedep/\";\n\t\trunAntAndCompare(testDir);\n\t}\n",
    "126262": "\tpublic void setCancelAvailable(boolean yes) {\n\t\tcancelAvailable = yes;\n\t}\n",
    "126267": "\tpublic void focusGained(FocusEvent e) {\n\t\tif (e.isTemporary())\n\t\t\treturn;\n\n\t\t// We call selectAll() via invokeLater in case something else is dealing\n\t\t// with the component - this was an issue with JFormattedTextFields\n\t\tfinal Component comp = e.getComponent();\n\t\tif (comp instanceof JTextComponent)\n\t\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (comp.hasFocus())  // make sure we still have focus\n\t\t\t\t\t\t((JTextComponent) comp).selectAll();\n\t\t\t\t}\n\t\t\t});\n\t}\n",
    "126269": "\tpublic boolean isFocusable() {\n\t\treturn false;\n\t}\n",
    "126275": "    public void setEndogenousDataName(String endogenousDataName) {\n\n        if (endogenousDataName == null)\n            endogenousDataDef = null;\n        else\n            endogenousDataDef = new JSCTypeDef(endogenousDataName,\n                    JSCTypes.NARRAY);\n\n    }\n",
    "126298": "\tpublic Class getClassToConvertTo() {\n\t\treturn ImageIcon.class;\n\t}\n",
    "126308": "\tpublic Class getClassToConvertTo() {\n\t\treturn Border.class;\n\t}\n",
    "126309": "\tpublic Object convert(Object obj, Locale locale) throws ObjectConverterException {\n\t\tString str = obj.toString();\n\t\tif (cacheMap.containsKey(str))\n\t\t\treturn cacheMap.get(str);\n\n\t\tObject convertedObj = wrappedConverter.convert(obj, locale);\n\t\tsynchronized (cacheMap) {\n\t\t\tcacheMap.put(str, convertedObj);\n\t\t}\n\t\treturn convertedObj;\n\t}\n",
    "126312": "\tpublic JComponent getQuestionComponent(int questionIndex) {\n\t\tif (questionIndex < 0 || questionIndex >= answerComponents.size()) {\n\t\t\tthrow new IndexOutOfBoundsException(questionIndex + \" exceeds \"\n\t\t\t\t\t+ \"maximum index of \" + (answerComponents.size() - 1)\n\t\t\t\t\t+ \" on panel\");\n\t\t}\n\t\treturn (JComponent) answerComponents.get(questionIndex);\n\t}\n",
    "126316": "    public void setEndogenousStringsName(String endogenousStringsName) {\n\n        if (endogenousStringsName == null)\n            endogenousStringsDef = null;\n        else\n            endogenousStringsDef = new JSCTypeDef(endogenousStringsName,\n                    JSCTypes.SARRAY);\n\n    }\n",
    "126322": "\tprivate String makeDecimalString(Object obj) {\n\t\treturn StringUtils.stripChars(obj.toString(), NUMBER_STRIP_CHARS);\n\t}\n",
    "126323": "\tprivate String makeIntegerString(Object obj) {\n\t\tString decString = makeDecimalString(obj);\n\t\t// Now only take it to the decimal point, if there is one\n\t\tif (decString.indexOf('.') == -1)\n\t\t\treturn decString;\n\t\treturn decString.substring(0, decString.indexOf('.'));\n\t}\n",
    "126335": "\tpublic void addQuestionCheckbox(String label) {\n\t\tJCheckBox checkbox = new JCheckBox(label);\n\t\tcheckbox.setFont(DEFAULT_FONT);\n\t\taddQuestionComponent(\"\", checkbox, GridBagConstraints.HORIZONTAL);\n\t}\n",
    "126353": "    public void setExogenousDataName(String exogenousDataName) {\n\n        if (exogenousDataName == null)\n            exogenousDataDef = null;\n        else\n            exogenousDataDef = new JSCTypeDef(exogenousDataName,\n                    JSCTypes.NARRAY);\n\n    }\n",
    "126361": "\tprivate Insets determinePadding(String attributeValue) {\n\t\t// If parent row is null, then the comp is floating and has no padding\n\t\tif (getParentRow() == null)\n\t\t\treturn null;\n\t\n\t\t// Inherit from row, if not available\n\t\tif (attributeValue == null)\n\t\t\tattributeValue = getParentRow().getCellPadding();\n\t\tif (attributeValue == null)\n\t\t\treturn null;\n\t\n\t\ttry {\n\t\t\treturn (Insets) Converter.convert(attributeValue, Insets.class);\n\t\t} catch (ObjectConverterException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "126363": "\tprivate int determineStretch(String attributeValue) {\n\t\t// If parent row is null, then comp is floating, it is forced to stretch\n\t\tif (getParentRow() == null)\n\t\t\treturn STRETCH_BOTH;\n\n\t\tif (\"horizontal\".equalsIgnoreCase(attributeValue))\n\t\t\treturn STRETCH_HORIZONTAL;\n\t\tif (\"vertical\".equalsIgnoreCase(attributeValue))\n\t\t\treturn STRETCH_VERTICAL;\n\t\tif (\"both\".equalsIgnoreCase(attributeValue))\n\t\t\treturn STRETCH_BOTH;\n\t\treturn STRETCH_NONE;\n\t}\n",
    "126365": "\tprivate int determineAlignment(String attributeValue) {\n\t\t// If the parent row is null, then the comp is forced to stretch\n\t\t// anyway, so the alignment doesn't matter\n\t\tif (getParentRow() == null)\n\t\t\treturn WEST;\n\n\t\t// Inherit from row, if not available\n\t\tif (attributeValue == null)\n\t\t\tattributeValue = getParentRow().getCellAlign();\n\t\treturn SwingUtils.convertStringAlign(attributeValue, WEST);\n\t}\n",
    "126367": "    public void setExogenousEnabled(boolean arg1) {\n        getExSelList().setEnabled(arg1);\n    }\n",
    "126375": "\tpublic Dimension getMinimumSize() {\n\t\tif (getParentRow() == null)\n\t\t\treturn getBounds().getSize();\n\t\t\n\t\tint width = getComponent().getMinimumSize().width;\n\t\tint height = getComponent().getMinimumSize().height;\n\t\tif (isFixed())\n\t\t\twidth = Math.max(width, getFixed());\n\t\tif (getParentRow().isFixed())\n\t\t\theight = Math.max(height, getParentRow().getFixed());\n\t\treturn new Dimension(width, height);\n\t}\n",
    "126378": "\tpublic Dimension getPreferredSize() {\n\t\tif (getParentRow() == null)\n\t\t\treturn getBounds().getSize();\n\t\t\n\t\tint width, height;\n\t\n\t\t// Width\n\t\tif (!includeInLayout()) {\n\t\t\twidth = 0;\n\t\t} else if (isFixed()) {\n\t\t\twidth = getFixed();\n\t\t} else {\n\t\t\twidth = getComponent().getPreferredSize().width;\n\t\t\tif (getPadding() != null) {\n\t\t\t\twidth = width + getPadding().left + getPadding().right;\n\t\t\t}\n\t\t}\n\t\n\t\t// Height\n\t\tif (getParentRow().isFixed()) {\n\t\t\theight = getParentRow().getFixed();\n\t\t} else {\n\t\t\theight = getComponent().getPreferredSize().height;\n\t\t\tif (getPadding() != null) {\n\t\t\t\theight = height + getPadding().top + getPadding().bottom;\n\t\t\t}\n\t\t}\n\t\n\t\treturn new Dimension(width, height);\n\t}\n",
    "126390": "    public void setExogenousStringsName(String exogenousStringsName) {\n        if (exogenousStringsName == null)\n            exogenousStringsDef = null;\n        else\n            exogenousStringsDef = new JSCTypeDef(exogenousStringsName,\n                    JSCTypes.SARRAY);\n    }\n",
    "126391": "\tpublic boolean includeInLayout() {\n\t\treturn !(!getComponent().isVisible() && isUnspecified());\n\t}\n",
    "126402": "\tpublic void pullTextFromXmlPanel() {\n\t\ttry {\n\t\t\tsetTextAreaText(DOMUtils.transformToXmlString(rootXmlPanel\n\t\t\t\t\t.getElement().getOwnerDocument()));\n\t\t} catch (XmlException e) {\n\t\t} // Don't care\n\t}\n",
    "126409": "    public void setDateRangeName(String dateRangeName) {\n        if (dateRangeName == null)\n            dateRangeDef = null;\n        else\n            dateRangeDef = new JSCTypeDef(dateRangeName, JSCTypes.DRANGE);\n    }\n",
    "126422": "\tpublic void addLayoutComponent(String name, Component comp) {\n\t}\n",
    "126424": "\tpublic void removeLayoutComponent(Component comp) {\n\t}\n",
    "126429": "    public void setOneEndogenousOnly(boolean newOneEndogenousOnly) {\n        oneEndogenousOnly = newOneEndogenousOnly;\n    }\n",
    "126438": "\tpublic Component createComponent(Element element, XmlPanel panel) {\n\t\tComponentCreator creator = getCreator(element);\n\t\tComponent comp = creator.createComponent(element, panel);\n\t\treturn comp;\n\t}\n",
    "126439": "\tpublic Component createComponent(Element element) {\n\t\treturn createComponent(element, null);\n\t}\n",
    "126444": "\tprivate void adjustServiceTotal(int amount) {\n\t\tJLabel totalLabel = (JLabel) xmlPanel.getComponentNamed(\"total\");\n\t\tdouble total = Double.parseDouble(totalLabel.getText());\n\t\ttotal += amount;\n\t\tDecimalFormat fmt = new DecimalFormat(\"0.00\");\n\t\ttotalLabel.setText(fmt.format(total));\n\t}\n",
    "126447": "\tprivate void doClear() {\n\t\t((JTextField) xmlPanel.getComponentNamed(\"client\")).setText(null);\n\t\t((JLabel) xmlPanel.getComponentNamed(\"total\")).setText(\"0.00\");\n\t\t((JTextField) xmlPanel.getComponentNamed(\"tip\")).setText(null);\n\t\t((JCheckBox) xmlPanel.getComponentNamed(\"checkHaircut\"))\n\t\t\t\t.setSelected(false);\n\t\t((JCheckBox) xmlPanel.getComponentNamed(\"checkColor\"))\n\t\t\t\t.setSelected(false);\n\t\t((JCheckBox) xmlPanel.getComponentNamed(\"checkPerm\"))\n\t\t\t\t.setSelected(false);\n\t\t((JCheckBox) xmlPanel.getComponentNamed(\"checkWeave\"))\n\t\t\t\t.setSelected(false);\n\t}\n",
    "126448": "    public void setSelectionChanged() {\n        firePropertyChange(\"selectionChanged\", Boolean.valueOf(\"TRUE\"), Boolean\n                .valueOf(\"FALSE\"));\n    }\n",
    "126451": "\tpublic void setBackgroundImage(ImageIcon image) {\n\t\tbackgroundImage = image;\n\t}\n",
    "126453": "\tpublic ImageIcon getBackgroundImage() {\n\t\treturn backgroundImage;\n\t}\n",
    "126456": "\tpublic void setBackgroundImageTileX(boolean tiled) {\n\t\tthis.backgroundImageTileX = tiled;\n\t}\n",
    "126458": "    public void setSelectionMode(int selectionMode) {\n        getTSList().setSelectionMode(selectionMode);\n    }\n",
    "126459": "\tpublic void setBackgroundImageTileY(boolean tiled) {\n\t\tthis.backgroundImageTileY = tiled;\n\t}\n",
    "126462": "\tpublic void setBackgroundImageAlign(int align) {\n\t\tbackgroundImageAlign = align;\n\t}\n",
    "126464": "\tpublic void setBackgroundImageAlign(String align) {\n\t\tsetBackgroundImageAlign(SwingUtils\n\t\t\t\t.convertStringAlign(align, NORTH_WEST));\n\t}\n",
    "126467": "\tprivate boolean isEditorDialogAllowed() {\n\t\tString attrib = System.getProperty(\"xmlpanel.allowEditorDialog\");\n\t\tif (attrib != null && attrib.toLowerCase().equals(\"true\"))\n\t\t\treturn true;\n\t\treturn getRootXmlPanel().allowEditorDialog;\n\t}\n",
    "126481": "\tpublic void testStringConversion() throws Exception {\n\t\tConverter.reset();\n\n\t\tString result = (String) Converter.convert(null, String.class);\n\t\tassertNull(\"converts null to null\", result);\n\n\t\tresult = (String) Converter.convert(\"\", String.class);\n\t\tassertNull(\"converts empty string to null\", result);\n\n\t\tObject obj = new Integer(45);\n\t\tresult = (String) Converter.convert(obj, String.class);\n\t\tassertEquals(\"converts object via toString\", obj.toString(), result);\n\n\t\tobj = \"Foo\";\n\t\tresult = (String) Converter.convert(obj, String.class);\n\t\tassertSame(\"Converting a string results in the same String object\",\n\t\t\t\tobj, result);\n\n\t}\n",
    "126483": "\tpublic Component getComponentNamed(String name) {\n\t\tComponent comp = SwingUtils.getChildNamed(name, this);\n\t\tif (comp == null)\n\t\t\tthrow new IllegalArgumentException(\"XmlPanel does not contain \"\n\t\t\t\t\t+ \"a component named \" + name);\n\t\treturn comp;\n\t}\n",
    "126485": "    public void setUpperScope(boolean isUpper) {\n        if (isUpper)\n            symbolScope = Scope.UPPER;\n        else\n            symbolScope = Scope.GLOBAL;\n    }\n",
    "126486": "\tpublic JTextField getJTextField(String name) {\n\t\treturn (JTextField) getComponentOfType(name, JTextField.class);\n\t}\n",
    "126488": "\tpublic JTextArea getJTextArea(String name) {\n\t\treturn (JTextArea) getComponentOfType(name, JTextArea.class);\n\t}\n",
    "126490": "\tpublic JLabel getJLabel(String name) {\n\t\treturn (JLabel) getComponentOfType(name, JLabel.class);\n\t}\n",
    "126493": "    public boolean isUpperScope() {\n        return symbolScope == Scope.UPPER;\n    }\n",
    "126494": "\tpublic JCheckBox getJCheckBox(String name) {\n\t\treturn (JCheckBox) getComponentOfType(name, JCheckBox.class);\n\t}\n",
    "126496": "\tpublic JButton getJButton(String name) {\n\t\treturn (JButton) getComponentOfType(name, JButton.class);\n\t}\n",
    "126498": "\tpublic JRadioButton getJRadioButton(String name) {\n\t\treturn (JRadioButton) getComponentOfType(name, JRadioButton.class);\n\t}\n",
    "126501": "    public boolean isCheckNaN() {\n        return checkNaN;\n    }\n",
    "126502": "\tpublic JComboBox getJComboBox(String name) {\n\t\treturn (JComboBox) getComponentOfType(name, JComboBox.class);\n\t}\n",
    "126508": "    public void setCheckNaN(boolean checkNaN) {\n        this.checkNaN = checkNaN;\n    }\n",
    "126526": "\tpublic void setAllowEditorDialog(boolean allowEditorDialog) {\n\t\t// Only the setting in the parent panel really matters\n\t\tgetRootXmlPanel().allowEditorDialog = allowEditorDialog;\n\t}\n",
    "126535": "\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);\n\n\t\t// Only draw lines if the editor dialog is showing\n\t\tXmlPanelEditDialog dialog = getRootXmlPanel().editorDialog;\n\t\tif (dialog == null || !dialog.isShowing())\n\t\t\treturn;\n\n\t\tColor clr = dialog.getCellRectangleColor();\n\t\tif (clr == null)\n\t\t\treturn; // They shouldn't be drawn\n\n\t\tXmlLayout layout = ((XmlPanelLayoutManager) getLayout()).getXmlLayout();\n\t\tg.setColor(clr);\n\t\tRectangle[] rectangles = layout.getRectangles();\n\t\tfor (int i = 0; i < rectangles.length; i++) {\n\t\t\tg.drawRect(rectangles[i].x, rectangles[i].y,\n\t\t\t\t\trectangles[i].width - 1, rectangles[i].height - 1);\n\t\t}\n\t}\n",
    "126539": "    public Selection getSelection() {\n        Selection sel = new Selection();\n        if (getEndSelList().getModel().getSize() == 0)\n            return sel;\n        sel.setSelectedIndices(new JSCNArray(\"selIndices\",\n                lastConfirmedSelection));\n        sel.setEnclosingRange(new JSCDRange(\"enclosing\",\n                getTSDateRangeSelector().getEnclosingRange()));\n        sel.setSelectedRange(new JSCDRange(\"range\", getTSDateRangeSelector()\n                .getTSDateRange()));\n        return sel;\n    }\n",
    "126544": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tActionListener[] listeners = getActionListeners();\n\t\tfor (int i = 0; i < listeners.length; i++) {\n\t\t\tlisteners[i].actionPerformed(e);\n\t\t}\n\t}\n",
    "126556": "\tpublic void addActionListener(ActionListener l) {\n\t\tlistenerList.add(ActionListener.class, l);\n\t}\n",
    "126565": "\tpublic void removeActionListener(ActionListener l) {\n\t\tlistenerList.remove(ActionListener.class, l);\n\t}\n",
    "126574": "\tprotected void paintComponent(Graphics g) {\n\t\tsuper.paintComponent(g);\n\t\tif (backgroundImage == null)\n\t\t\treturn;\n\n\t\tImage img = backgroundImage.getImage();\n\t\tint imwidth = img.getWidth(null);\n\t\tint imheight = img.getHeight(null);\n\t\tif (imwidth <= 0 || imheight <= 0)\n\t\t\treturn;\n\n\t\tPoint p = getBackgroundImageTopLeft();\n\t\tint width = isBackgroundImageTileX() ? getWidth() : p.x + imwidth;\n\t\tint height = isBackgroundImageTileY() ? getHeight() : p.y + imheight;\n\n\t\tfor (int y = p.y; y < height; y += imheight) {\n\t\t\tfor (int x = p.x; x < width; x += imwidth) {\n\t\t\t\tg.drawImage(img, x, y, null);\n\t\t\t}\n\t\t}\n\t}\n",
    "126595": "\tpublic int getBackgroundImageAlign() {\n\t\treturn backgroundImageAlign;\n\t}\n",
    "126606": "\tpublic boolean isBackgroundImageTileX() {\n\t\treturn backgroundImageTileX;\n\t}\n",
    "126616": "\tpublic boolean isBackgroundImageTileY() {\n\t\treturn backgroundImageTileY;\n\t}\n",
    "126781": "\tpublic Task newTask(final String command, final String[] arguments, final HashMap inputFiles, final String inputStream) {\n        Task task = null;\n\t\tif(currentTaskCount < maxTaskCount) {\n\t\t\ttask = new Task(this, command, arguments, inputFiles, inputStream, maximumCPUPower / maxTaskCount, serialTaskRef);\n\t\t\ttaskQueue.put(new Long(serialTaskRef), task);\n\t\t\tserialTaskRef++;\n\t\t\tcurrentTaskCount++;\n\t\t\tcurrentCPUPower += maximumCPUPower/ maxTaskCount;\n\t\t}\n        return task;\n\t}\n",
    "126784": "\tpublic Task getTask(final long taskRef) {\n\t\treturn (Task) taskQueue.get(new Long(taskRef));\n\t}\n",
    "126787": "\tpublic void removeTask(final long taskRef) {\n\t\tcurrentTaskCount--;\n\t\tcurrentCPUPower -= maximumCPUPower/ maxTaskCount;\n\t\t((Task) taskQueue.get(new Long(taskRef))).cleanUp();\n\t\ttaskQueue.remove(new Long(taskRef));\n\t}\n",
    "126789": "\tpublic String getAgentCookie() {\n\t\treturn agentCookie;\n\t}\n",
    "126792": "\tpublic void setAgentCookie(final String agentCookie) {\n\t\tthis.agentCookie = agentCookie;\n\t\t\n\t\tsaveCookie();\n\t}\n",
    "126796": "\tpublic String getAgentName() {\n\t\treturn agentName;\n\t}\n",
    "126797": "\tpublic String getAgentStatus() {\n\t\treturn agentStatus;\n\t}\n",
    "126801": "\tpublic long getCurrentTaskCount() {\n\t\treturn currentTaskCount;\n\t}\n",
    "126802": "\tpublic long getMaxTaskCount() {\n\t\treturn maxTaskCount;\n\t}\n",
    "126806": "\tpublic long getCurrentCPUPower() {\n\t\treturn currentCPUPower;\n\t}\n",
    "126807": "\tpublic long getMaximumCPUPower() {\n\t\treturn maximumCPUPower;\n\t}\n",
    "126809": "\tpublic String getStringRepresentation() {\n\t\treturn stringRepresentation;\n\t}\n",
    "126811": "\tpublic HashMap getTaskQueue() {\n\t\treturn taskQueue;\n\t}\n",
    "126817": "\tpublic String getHostname() {\n\t\treturn hostname;\n\t}\n",
    "126819": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\t\tMap map = (Map) obj;\n\t\tMap json = new HashMap(map.size());\n\t\tfor (Object key : map.keySet()) {\n\t\t\tObject value = map.get(key);\n\t\t\tConverter con = null;\n\t\t\tif (value == null) {\n\t\t\t\tcon = Json.getConverter(Object.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon = Json.getConverter(value.getClass());\n\t\t\t}\n\t\t\tjson.put(new JsonString(key.toString()), con.toJson(value));\n\t\t}\n\t\treturn new JsonObject(json);\n\t}\n",
    "126820": "    public boolean killProcess() {\n    \tboolean success = false;\n    \t\n    \tif(process != null) {\n    \t\tprocess.destroy();\n    \t\tprocess = null;\n    \t\tsuccess = true;\n    \t}\n    \t\n    \treturn success;\n    }\n",
    "126822": "\tpublic Number toObject() {\n\t\treturn value;\n\t}\n",
    "126824": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\n\t\treturn new JsonObject();\n\t}\n",
    "126825": "\tpublic String toSource() {\n\t\tif (!NumberUtils.isFinite(value)) {\n\t\t\tthrow new ArithmeticException(\n\t\t\t\t\t\"Infinite number cannot be serialized\");\n\t\t}\n\n\t\tString result = value.toString();\n\t\tif (result.indexOf('.') > 0 && result.indexOf('e') < 0\n\t\t\t\t&& result.indexOf('E') < 0) {\n\t\t\twhile (result.endsWith(\"0\")) {\n\t\t\t\tresult = StringUtils.chop(result);\n\t\t\t}\n\t\t\tif (result.endsWith(\".\")) {\n\t\t\t\tresult = StringUtils.chop(result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "126826": "\tpublic Object toJava(JsonType json) {\n\t\treturn json.toObject();\n\t}\n",
    "126828": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\t\tCharacter c = (Character) obj;\n\t\treturn new JsonNumber((int) c.charValue());\n\t}\n",
    "126829": "\tpublic Class getConversionClass() {\n\t\treturn Number.class;\n\t}\n",
    "126830": "\tpublic void invalidateLayout(Container target) {\n\t\tcacheMinimumLayoutSize = null;\n\t\tcachePreferredLayoutSize = null;\n\t\tcacheColumnsX = null;\n\t\tcacheRowsY = null;\n\t}\n",
    "126832": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\t\tObject[] array = null;\n\t\tif (obj instanceof Object[]) {\n\t\t\tarray = (Object[]) obj;\n\t\t}\n\t\telse if (obj instanceof Collection) {\n\t\t\tarray = ((Collection) obj).toArray();\n\t\t}\n\t\telse {\n\t\t\tthrow new ClassCastException(\"Array or Collection expected\");\n\t\t}\n\n\t\tList json = new ArrayList(array.length);\n\t\tfor (Object element : array) {\n\t\t\tConverter con = null;\n\t\t\tif (element == null) {\n\t\t\t\tcon = Json.getConverter(Object.class);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcon = Json.getConverter(element.getClass());\n\t\t\t}\n\t\t\tjson.add(con.toJson(element));\n\t\t}\n\t\treturn new JsonArray(json);\n\t}\n",
    "126833": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\t\tNumber n = (Number) obj;\n\t\treturn new JsonNumber(n);\n\t}\n",
    "126837": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\t\tBoolean b = (Boolean) obj;\n\t\tif (b.equals(Boolean.TRUE)) {\n\t\t\treturn JsonLiteral.TRUE;\n\t\t}\n\t\treturn JsonLiteral.FALSE;\n\t}\n",
    "126838": "\tpublic JsonType toJson(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn JsonLiteral.NULL;\n\t\t}\n\t\tString s = obj.toString();\n\t\treturn new JsonString(s);\n\t}\n",
    "126841": "\tpublic String toJava(JsonType json) {\n\t\tif (json == JsonLiteral.NULL || json == null) {\n\t\t\treturn null;\n\t\t}\n\t\tJsonString s = null;\n\t\tif (json instanceof JsonString) {\n\t\t\ts = (JsonString) json;\n\t\t}\n\t\telse {\n\t\t\ts = new JsonString(json.toString());\n\t\t}\n\t\treturn s.toObject();\n\t}\n",
    "126847": "\tpublic HashMap toObject() {\n\t\tHashMap result = new HashMap(size());\n\t\tfor (Object k : keySet()) {\n\t\t\tString key = ((JsonString) k).toString();\n\t\t\tObject value = ((JsonType) get(k)).toObject();\n\t\t\tresult.put(key, value);\n\t\t}\n\t\treturn result;\n\t}\n",
    "126848": "\tpublic boolean more() {\n\t\treturn pointer < json.length();\n\t}\n",
    "126850": "\tpublic String toSource() {\n\t\tStringBuffer sb = new StringBuffer(\"{\");\n\t\tString separator = \"\";\n\n\t\tfor (Object key : keySet()) {\n\t\t\tJsonString jsonKey = new JsonString(key.toString());\n\t\t\tsb.append(separator).append(jsonKey.toSource()).append(\": \");\n\t\t\tsb.append(((JsonType) get(key)).toSource());\n\t\t\tseparator = \", \";\n\t\t}\n\t\tsb.append(\"}\");\n\t\treturn sb.toString();\n\t}\n",
    "126852": "\tpublic Class getConversionClass() {\n\t\treturn Map.class;\n\t}\n",
    "126854": "\tpublic char peek() {\n\t\tif (pointer < json.length()) {\n\t\t\treturn json.charAt(pointer);\n\t\t}\n\t\treturn 0;\n\t}\n",
    "126861": "\tpublic void back() {\n\t\tif (pointer > 0) {\n\t\t\tpointer--;\n\t\t}\n\t}\n",
    "126865": "\tpublic ArrayList toObject() {\n\t\tArrayList result = new ArrayList(size());\n\t\tfor (Object o : this) {\n\t\t\tObject element = ((JsonType) o).toObject();\n\t\t\tresult.add(element);\n\t\t}\n\t\treturn result;\n\t}\n",
    "126868": "\tpublic char read() {\n\t\tchar c = peek();\n\t\tif (c != 0) {\n\t\t\tpointer++;\n\t\t}\n\t\treturn c;\n\t}\n",
    "126869": "\tpublic String toSource() {\n\t\tStringBuffer sb = new StringBuffer(\"[\");\n\t\tString separator = \"\";\n\n\t\tfor (Object obj : this) {\n\t\t\tJsonType element = (JsonType) obj;\n\t\t\tsb.append(separator).append(element.toSource());\n\t\t\tseparator = \", \";\n\t\t}\n\t\tsb.append(\"]\");\n\t\treturn sb.toString();\n\t}\n",
    "126871": "\tpublic Class getConversionClass() {\n\t\treturn Collection.class;\n\t}\n",
    "126876": "\tpublic char read(char next) throws MalformedJsonSourceException {\n\t\tchar c = read();\n\t\tif (c != next) {\n\t\t\tthrow error(\"Unexpected character: expected '\" + next +\n\t\t\t\t\t\"' but read '\" + c + \"' instead\");\n\t\t}\n\t\treturn c;\n\t}\n",
    "126879": "\tpublic Boolean toObject() {\n\t\treturn value;\n\t}\n",
    "126880": "\tpublic String toSource() {\n\t\tif (value == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\treturn value.toString();\n\t}\n",
    "126882": "\tpublic Class getConversionClass() {\n\t\treturn Boolean.class;\n\t}\n",
    "126886": "\tpublic String toAjax(Object obj) {\n\t\treturn Json.toJson(obj);\n\t}\n",
    "126887": "\tpublic Map toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn (Map) Json.toJava(ajax, Map.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126888": "\tpublic String toObject() {\n\t\treturn value;\n\t}\n",
    "126889": "\tpublic String contentType() {\n\t\treturn PLAIN_CONTENT;\n\t}\n",
    "126891": "\tpublic String read(int count) throws MalformedJsonSourceException {\n\t\tint start = pointer;\n\t\tint end = pointer + count;\n\n\t\tif (end > json.length()) {\n\t\t\tthrow error(\"Too many characters: tried to read \" + count +\n\t\t\t\t\t\" characters when only \" + (json.length() - pointer) +\n\t\t\t\t\t\" were available\");\n\t\t}\n\t\tpointer += count;\n\t\treturn json.substring(start, end);\n\t}\n",
    "126893": "\tpublic Class getConversionClass() {\n\t\treturn String.class;\n\t}\n",
    "126894": "\tpublic Object toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn Json.toJava(ajax, Object.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126898": "\tpublic Character toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn (Character) Json.toJava(ajax, Character.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126899": "\tpublic String toAjax(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tPattern pattern = (Pattern) obj;\n\t\tStringBuffer result = new StringBuffer(\"/\" + pattern.pattern() + \"/g\");\n\t\tif ((pattern.flags() & Pattern.CASE_INSENSITIVE) > 0) {\n\t\t\tresult.append('i');\n\t\t}\n\t\treturn result.toString();\n\t}\n",
    "126901": "\tpublic Pattern toJava(String ajax) throws MalformedAjaxException {\n\t\tint last = ajax.lastIndexOf('/');\n\t\tint flags = 0;\n\t\tString suffix = ajax.substring(last + 1);\n\t\tString regex = ajax.substring(1, last);\n\n\t\tif (suffix.contains(\"i\")) {\n\t\t\tflags |= Pattern.CASE_INSENSITIVE;\n\t\t}\n\t\treturn Pattern.compile(regex, flags);\n\t}\n",
    "126904": "\tpublic Collection toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn (Collection) Json.toJava(ajax, Collection.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126909": "\tpublic Number toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn (Number) Json.toJava(ajax, Number.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126912": "\tpublic Boolean toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn (Boolean) Json.toJava(ajax, Boolean.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126915": "\tpublic String toJava(String ajax) throws MalformedAjaxException {\n\t\ttry {\n\t\t\treturn (String) Json.toJava(ajax, String.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t}\n",
    "126916": "\tpublic String toAjax(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tlong date = ((Date) obj).getTime();\n\t\treturn \"new Date(\" + date + \")\";\n\t}\n",
    "126918": "\tpublic Date toJava(String ajax) throws MalformedAjaxException {\n\t\tlong date = 0L;\n\t\ttry {\n\t\t\tdate = (Long) Json.toJava(ajax, Long.class);\n\t\t}\n\t\tcatch (MalformedJsonSourceException ex) {\n\t\t\tthrow new MalformedAjaxException(ex.getMessage(), ex\n\t\t\t\t\t.getErrorOffset());\n\t\t}\n\t\treturn new Date(date);\n\t}\n",
    "126922": "\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// noop\n\t}\n",
    "126923": "\tpublic String readUntil(char target) {\n\t\tStringBuffer sb = new StringBuffer();\n\n\t\twhile (true) {\n\t\t\tchar c = peek();\n\t\t\tif (c == target || c == '\\r' || c == 'n') {\n\t\t\t\treturn sb.append(read()).toString().trim();\n\t\t\t}\n\t\t\tif (c == 0) {\n\t\t\t\treturn sb.toString().trim();\n\t\t\t}\n\t\t\tsb.append(read());\n\t\t}\n\t}\n",
    "126926": "\tpublic void destroy() {\n\t\t// noop\n\t}\n",
    "126935": "\tpublic void finishResponse() {\n\t\ttry {\n\t\t\tif (writer != null) {\n\t\t\t\twriter.close();\n\t\t\t}\n\t\t\telse if (stream != null) {\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// Ignore the exception\n\t\t}\n\t}\n",
    "126953": "\tpublic void skip(char target) {\n\t\tint index = pointer;\n\t\tpointer = json.indexOf(target, pointer);\n\t\tif (pointer < 0) {\n\t\t\tpointer = index;\n\t\t}\n\t}\n",
    "126961": "    public String getUketdNs () {\n\treturn uketdNs;\n    }\n",
    "126962": "\tpublic void skip(String target) {\n\t\tpointer = json.indexOf(target, pointer);\n\t\tif (pointer < 0) {\n\t\t\tpointer = json.length();\n\t\t}\n\t\telse {\n\t\t\tpointer += target.length();\n\t\t}\n\t}\n",
    "126965": "    public String getUketdUri () {\n\treturn uketdUri;\n    }\n",
    "126969": "    public String getDcNs () {\n\treturn dcNs;\n    }\n",
    "126972": "    public String getDcUri () {\n\treturn dcUri;\n    }\n",
    "126975": "    public String getDcTermsNs () {\n\treturn dcTermsNs;\n    }\n",
    "126980": "    public String getDcTermsUri () {\n\treturn dcTermsUri;\n    }\n",
    "126983": "    public String getUketdTermsNs () {\n\treturn uketdTermsNs;\n    }\n",
    "126987": "    public String getUketdTermsUri () {\n\treturn uketdTermsUri;\n    }\n",
    "126990": "    public String getUketdSchemaLocNs () {\n\treturn uketdSchemaLocNs;\n    }\n",
    "126997": "    public String getUketdSchemaLocUri () {\n\treturn uketdSchemaLocUri;\n    }\n",
    "127118": "\tpublic Direction opposite() {\n\t\tif(this == NORTH) return SOUTH;\n\t\tif(this == SOUTH) return NORTH;\n\t\tif(this == EAST) return WEST;\n\t\tif(this == WEST) return EAST;\n\t\treturn new Direction(-xOffset, -yOffset);\n\t}\n",
    "127176": "\tpublic void movePoint(GridPoint oldPoint, GridPoint newPoint) {\n\t\tGridObject oldObject = (GridObject) state.gridObjects.remove(oldPoint);\n\t\tsetGridPoint(oldPoint, null);\n\t\tsetGridPoint(newPoint, oldObject);\n\t}\n",
    "127409": "\tpublic int getModifier() {\n\t\treturn (score/2) - 5;\n\t}\n",
    "127501": "\tpublic int addTo(List list) {\n\t\tfor (ListIterator i = list.listIterator(); i.hasNext();) {\n\t\t\tModifierInfo mi2 = (ModifierInfo) i.next();\n\t\t\tif(this.replaces(mi2)) {\n\t\t\t\ti.set(this);\n\t\t\t\treturn amount - mi2.amount;\n\t\t\t}\n\t\t\tif(mi2.replaces(this)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tlist.add(this);\n\t\treturn amount;\n\t}\n",
    "127688": "\tpublic int getHitDice() {\n\t\treturn characterLevel;\n\t}\n",
    "127941": "\tpublic boolean hasPriceModifier() {\n\t\treturn priceModifier > 0;\n\t}\n",
    "128235": "\tpublic Map getSets() {\n\t\treturn sets;\n\t}\n",
    "128237": "\tprotected Set getMySetInBook(BaseBook b) {\n\t\treturn b.getSetForClass(getClass());\n\t}\n",
    "128238": "\tprotected void addToBook(BaseBook b, Set s) {\n\t\ts.add(this);\n\t\tthis.book = b;\n\t}\n",
    "128240": "\tprotected void removeFromBook(BaseBook b, Set s) {\n\t\ts.remove(this);\n\t\tif(this.book == b) this.book = null;\n\t}\n",
    "128241": "\tpublic void initWithDefaults() {\n\t}\n",
    "128271": "\tpublic void export(Entity entity, BaseBook book, XMLOutputStream xos) throws HibernateException, IOException {\n\t\t\n\t\txos.newlineAndIndent();\n\t\txos.stag(classNameToPropName(entity.getClass().getName()));\n\t\texportProperties(entity, book, xos);\t\t\n\t\txos.etag();\n\t}\n",
    "128272": "\tprivate void exportProperties(Entity entity, BaseBook book, XMLOutputStream xos) throws HibernateException, IOException {\n\t\tClassMetadata meta = factory.getClassMetadata(entity.getClass());\n\t\tString[] propNames = meta.getPropertyNames();\n\t\tObject[] propValues = meta.getPropertyValues(entity);\n\t\tType[] propTypes = meta.getPropertyTypes();\n\t\texportProperties(entity, book, xos, propNames, propValues, propTypes);\n\t}\n",
    "128281": "\tpublic void export(BaseBook book, File file) throws HibernateException, IOException {\n\t\tXMLOutputStream outputStream = new XMLOutputStream(new FileWriter(file));\n\t\texport(book, outputStream);\n\t\toutputStream.close();\n\t}\n",
    "128390": "\tpublic int getSizeForHitDice(int hitDice) {\n\t\tint defaultSize=0;\n\t\tfor(int i=hitDiceForSize.length-1; i >= 0; i--) {\n\t\t\tif(hitDiceForSize[i] > 0) {\n\t\t\t\tif(hitDiceForSize[i] <= hitDice) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\tif(defaultSize == 0)\n\t\t\t\t\tdefaultSize = i;\n\t\t\t}\n\t\t}\n\t\treturn defaultSize;\n\t}\n",
    "128392": "\tpublic int getBaseSize() {\n\t\treturn getSizeForHitDice(getBaseHitDice());\n\t}\n",
    "128415": "    public void stop() throws Exception {\n        _embedded.stop();\n    }\n",
    "128416": "    public void registerWAR(String contextPath, URL warFile) throws IOException {\n        if (contextPath == null) {\n            throw new IllegalArgumentException(\"Invalid Path : \" + contextPath);\n        }\n        if (contextPath.equals(\"/\")) {\n            contextPath = \"\";\n        }\n        if (warFile == null) { \n            throw new IllegalArgumentException(\"Invalid WAR : \" + warFile);\n        }\n\n        Deployer deployer = (Deployer) _host;\n        Context context = deployer.findDeployedApp(contextPath);\n        if (context != null) {\n            throw new IllegalArgumentException(\"Context \" + contextPath + \" already Exists!\");\n        }\n        deployer.install(contextPath, warFile);\n    }\n",
    "128418": "    public void unregisterWAR(String contextPath) {\n        Context context = _host.map(contextPath);\n        if (context != null) {\n            _embedded.removeContext(context);\n        } else {\n            throw new IllegalArgumentException(\"Context does not exist for named path : \" + contextPath);\n        }\n    }\n",
    "128447": "\tpublic String formatAttack(int attackBonus, String type, Damage damage, int damageBonus) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tif(attackBonus != 0) sb.append(formatBonus(attackBonus)).append(\" \");\n\t\tif(damage != null) {\n\t\t\tsb.append(type).append(\" \");\n\t\t\tsb.append(damage.getDamageDice()).append(\"d\").append(damage.getDamageDie());\n\t\t\tif(damageBonus != 0)sb.append(formatBonus(damageBonus));\n\t\t\tif(damage.getThreatRange() != 20)sb.append(\"/\").append(damage.getThreatRange()).append(\"-20\");\n\t\t\tif(damage.getCriticalMultiplier() != 2)sb.append(\"/x\").append(damage.getCriticalMultiplier());\n\t\t}\n\t\treturn sb.toString();\n\t}\n",
    "128458": "\tpublic int getAbilityCount() {\n\t\treturn 6;\n\t}\n",
    "128472": "\tpublic void bind(String xml) throws ParseException {\n\t\tMutablePropertyValues pvs = new XMLPropertyValues(xml);\n\t\tbind(pvs);\n\t}\n",
    "128473": "\tpublic void bind(XMLInputStream xis) throws ParseException, IOException {\n\t\tMutablePropertyValues pvs = new XMLPropertyValues(xis);\n\t\tbind(pvs);\n\t}\n",
    "128475": "\tpublic void closeNoCatch() throws XMLBindingException {\n\t\tif (getErrors().hasErrors()) {\n\t\t\tthrow new XMLBindingException(\"Errors binding onto object '\" + getErrors().getObjectName() + \"'\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t getErrors());\n\t\t}\n\t}\n",
    "128492": "\tpublic int getGoodSave(int level) {\n\t\treturn 2+(level/2);\n\t}\n",
    "128498": "\tpublic int getPoorSave(int level) {\n\t\treturn level/3;\n\t}\n",
    "128551": "   public void property(String tag, String pcdata) throws IOException {\n       stag(tag);\n       pcdata(pcdata);\n       etag();\n   }\n",
    "128554": "\tpublic int getDamageBonusForEnhancement(int enhancement) {\n\t\tif(enhancement < 2) return 0;\n\t\treturn enhancement - 1;\n\t}\n",
    "128557": "\tpublic int getAttackBonusForEnhancement(int enhancement) {\n\t\tif(enhancement == 0) return 0;\n\t\tif(enhancement == 1) return 1;\n\t\treturn enhancement - 1;\n\t}\n",
    "128558": "\tpublic int getShieldBonusForEnhancement(int enhancement) {\n\t\tif(enhancement < 2) return 0;\n\t\treturn enhancement - 1;\n\t}\n",
    "128559": "\tpublic int getArmorBonusForEnhancement(int enhancement) {\n\t\tif(enhancement < 2) return 0;\n\t\treturn enhancement - 1;\n\t}\n",
    "128562": "\tpublic void testSimpleDiceExpression() throws Exception {\n\t\tDiceExpression de = new DiceExpression(\"(3d6+30)/3\");\n\t\tSystem.out.println(\"Final result = \"+de.getFinalResult());\n\t\tSystem.out.println(\"Calculation = \"+de.getCalculation());\n\t}\n",
    "128597": "\tpublic int adjustGripBasedOnWeaponSize(int grip, int madeForSize, int size) {\n\t\tif(madeForSize == size) return grip;\n\t\twhile(madeForSize > size) {\n\t\t\tif(grip == D20.LIGHT_WEAPON) {\n\t\t\t\tgrip = D20.ONE_HANDED_WEAPON;\n\t\t\t} else if(grip == D20.ONE_HANDED_WEAPON) {\n\t\t\t\tgrip = D20.TWO_HANDED_WEAPON;\n\t\t\t}\n\t\t\tmadeForSize--;\n\t\t}\n\t\twhile(madeForSize < size) {\n\t\t\tif(grip == D20.TWO_HANDED_WEAPON) {\n\t\t\t\tgrip = D20.ONE_HANDED_WEAPON;\n\t\t\t} else if(grip == D20.ONE_HANDED_WEAPON) {\n\t\t\t\tgrip = D20.LIGHT_WEAPON;\n\t\t\t}\n\t\t\tmadeForSize++;\n\t\t}\n\t\treturn 0;\n\t}\n",
    "128612": "\tpublic int getBonusSpellsPerDay(int modifier, int level) {\n\t\tif(level == 0 || modifier < level)\n\t\t\treturn 0;\n\t\t return (modifier - level) / 4 + 1;\n\t}\n",
    "128774": "\tpublic boolean isProficientWithMeleeWeapon(ItemSummary item) {\n\t\tint training = item.getMeleeWeaponTraining();\n\t\treturn isProficientWithWeapon(item, training);\n\t}\n",
    "128807": "\tpublic boolean isProficientWithRangedWeapon(ItemSummary item) {\n\t\tint training = item.getRangedWeaponTraining();\n\t\treturn isProficientWithWeapon(item, training);\n\t}\n",
    "128824": "    public boolean getFeature(String name) {\n        if (name == null)\n            throw new IllegalArgumentException(\"feature name should not be nulll\");\n        if (FEATURE_PROCESS_NAMESPACES.equals(name)) {\n            return processNamespaces;\n            //        } else if(FEATURE_REPORT_NAMESPACE_ATTRIBUTES.equals(name)) {\n            //            return reportNsAttribs;\n        } else if (FEATURE_NAMES_INTERNED.equals(name)) {\n            return false;\n        } else if (FEATURE_PROCESS_DOCDECL.equals(name)) {\n            return false;\n            //} else if(REPORT_DOCDECL.equals(name)) {\n            //    return paramNotifyDoctype;\n        } else if (FEATURE_XML_ROUNDTRIP.equals(name)) {\n            //return true;\n            return roundtripSupported;\n        }\n        return false;\n    }\n",
    "128849": "    public void setInput(Reader in) throws ParseException {\n        reset();\n        reader = in;\n    }\n",
    "128864": "    public String getInputEncoding() {\n        return inputEncoding;\n    }\n",
    "128879": "    public int getNamespaceCount(int depth) throws ParseException {\n        if (processNamespaces == false || depth == 0) {\n            return 0;\n        }\n        //int maxDepth = eventType == END_TAG ? this.depth + 1 : this.depth;\n        //if(depth < 0 || depth > maxDepth) throw new IllegalArgumentException(\n        if (depth < 0 || depth > this.depth)\n            throw new IllegalArgumentException(\n                \"napespace count mayt be for depth 0..\" + this.depth + \" not \" + depth);\n        return elNamespaceCount[depth];\n    }\n",
    "128910": "    public int getDepth() {\n        return depth;\n    }\n",
    "128918": "    public String getPositionDescription() {\n        String fragment = null;\n        if (posStart <= pos) {\n            int start = findFragment(0, buf, posStart, pos);\n            //System.err.println(\"start=\"+start);\n            if (start < pos) {\n                fragment = new String(buf, start, pos - start);\n            }\n            if (bufAbsoluteStart > 0 || start > 0)\n                fragment = \"...\" + fragment;\n        }\n        //        return \" at line \"+tokenizerPosRow\n        //            +\" and column \"+(tokenizerPosCol-1)\n        //            +(fragment != null ? \" seen \"+printable(fragment)+\"...\" : \"\");\n        return \" \" + TYPES[eventType] +\n            (fragment != null ? \" seen \" + printable(fragment) + \"...\" : \"\") +\n            \" @\" + getLineNumber() + \":\" + getColumnNumber();\n    }\n",
    "128925": "    public int getLineNumber() {\n        return lineNumber;\n    }\n",
    "128932": "    public int getColumnNumber() {\n        return columnNumber;\n    }\n",
    "128938": "    public boolean isWhitespace() throws ParseException {\n        if (eventType == TEXT || eventType == CDSECT) {\n            if (usePC) {\n                for (int i = pcStart; i < pcEnd; i++) {\n                    if (!isS(pc[i]))\n                        return false;\n                }\n                return true;\n            } else {\n                for (int i = posStart; i < posEnd; i++) {\n                    if (!isS(buf[i]))\n                        return false;\n                }\n                return true;\n            }\n        } else if (eventType == IGNORABLE_WHITESPACE) {\n            return true;\n        }\n        throw new ParseException(\"no content available to check for whitespaces\", this.lineNumber);\n    }\n",
    "128945": "    public String getText() {\n        if (eventType == START_DOCUMENT || eventType == END_DOCUMENT) {\n            //throw new ParseException(\"no content available to read\");\n            //      if(roundtripSupported) {\n            //          text = new String(buf, posStart, posEnd - posStart);\n            //      } else {\n            return null;\n            //      }\n        } else if (eventType == ENTITY_REF) {\n            return text;\n        }\n        if (text == null) {\n            if (!usePC || eventType == START_TAG || eventType == END_TAG) {\n                text = new String(buf, posStart, posEnd - posStart);\n            } else {\n                text = new String(pc, pcStart, pcEnd - pcStart);\n            }\n        }\n        return text;\n    }\n",
    "129064": "    public int nextTag() throws ParseException, IOException {\n        next();\n        if (eventType == TEXT && isWhitespace()) { // skip whitespace\n            next();\n        }\n        if (eventType != START_TAG && eventType != END_TAG) {\n            throw new ParseException(\"expected START_TAG or END_TAG not \"\n                                     + TYPES[getEventType()], this.lineNumber);\n        }\n        return eventType;\n    }\n",
    "129069": "    public int finishTag() throws ParseException, IOException {\n    \tint startDepth = depth;\n    \tdo {\n    \t\tnextTag();\n    \t} while(eventType != END_TAG || depth > startDepth);\n    \treturn eventType;\n    }\n",
    "129074": "    public int next() throws ParseException, IOException {\n        tokenize = false;\n        return nextImpl();\n    }\n",
    "129079": "    public int nextToken() throws ParseException, IOException {\n        tokenize = true;\n        return nextImpl();\n    }\n",
    "129187": "    public XMLInputSubStream getSubStream() {\n        return new XMLInputSubStream(this);\n    }\n",
    "129862": "    public Paint getPaint() {\n        return paint;\n    }\n",
    "129863": "    public void addObject(final VisualObject vo) {\n        objects.add(vo);\n        Collections.sort(objects, layerComparator);\n    }\n",
    "129864": "    public Stroke getStroke() {\n        return stroke;\n    }\n",
    "129865": "    public void removeObject(final VisualObject vo) {\n        objects.remove(vo);\n    }\n",
    "129866": "    public Composite getComposite() {\n        return composite;\n    }\n",
    "129868": "    public void setPaint(final Paint paint) {\n        if (paint == null) {\n            this.paint = Color.BLACK;\n        }\n        else {\n            this.paint = paint;\n        }\n    }\n",
    "129869": "    public void renderNonNegativeLayers(final Graphics2D g) {\n\n        // Check every object\n        for (VisualObject obj : objects) {\n\n            // Only render objects on non-negative layers\n            if (obj.getLayer() >= 0) {\n                obj.render(g);\n            }\n        }\n\n    }\n",
    "129870": "    public void setStroke(final Stroke stroke) {\n        if (stroke == null) {\n            this.stroke = new BasicStroke();\n        }\n        else {\n            this.stroke = stroke;\n        }\n    }\n",
    "129872": "    public void setComposite(final Composite composite) {\n        if (composite == null) {\n            this.composite = AlphaComposite.Src;\n        }\n        else {\n            this.composite = composite;\n        }\n    }\n",
    "129873": "        public int compare(final VisualObject obj1, final VisualObject obj2) {\n            return obj1.getLayer() - obj2.getLayer();\n        }\n",
    "129874": "    public void useOn(final Graphics2D g) {\n        g.setPaint(paint);\n        g.setStroke(stroke);\n        g.setComposite(composite);\n    }\n",
    "129875": "    static synchronized public ImageManager getSharedInstance() {\n\n        if (singleton == null) {\n            singleton = new ImageManager();\n        }\n\n        return singleton;\n    }\n",
    "129879": "    public Component getViewPane() {\n        return (Component) viewPane;\n    }\n",
    "129880": "    public void addLevel(final double scale, final int detail) {\n        Level level = new Level(scale, detail);\n        levels.add(level);\n    }\n",
    "129881": "    public int getLevel(final double scale) {\n        for (Level level : levels) {\n            if (scale <= level.getScale()) {\n                return level.getDetail();\n            }\n        }\n\n        // This should never happen\n        return 0;\n    }\n",
    "129884": "    public VisualObject getRootObject() {\n        return rootObj;\n    }\n",
    "129885": "    static public FontManager getSharedInstance() {\n\n        if (singleton == null) {\n            singleton = new FontManager();\n        }\n\n        return singleton;\n    }\n",
    "129889": "    public TaskManager getTaskManager() {\n        return taskManager;\n    }\n",
    "129890": "    public VVDisplay getVVDisplay() {\n        return vvDisplay;\n    }\n",
    "129892": "    public boolean isViewportZoomable() {\n        return viewportZoomable;\n    }\n",
    "129893": "    public void setViewportZoomable(final boolean viewportZoomable) {\n        this.viewportZoomable = viewportZoomable;\n    }\n",
    "129895": "    public void addVVMouseListener(final VVMouseListener listener) {\n        \n        viewPane.addMouseListener( listener );\n        viewPane.addMouseWheelListener( listener );\n        \n        if( listener instanceof MouseMotionListener ) {\n            viewPane.addMouseMotionListener( (MouseMotionListener)listener );\n        }\n        \n    }\n",
    "129897": "    public void mouseWheelMoved(final MouseWheelEvent e) {\n        if (isViewportZoomable()) {\n            int rotation = e.getWheelRotation();\n            double scale = getVVDisplay().getWorldViewScale();\n            scale += ((scale * 0.15) * rotation);\n\n            getVVDisplay().setWorldViewScale(scale);\n        }\n    }\n",
    "129898": "    public void removeVVMouseListener(final VVMouseListener listener) {\n\n\n        viewPane.removeMouseListener( listener );\n        viewPane.removeMouseWheelListener( listener );\n        \n        if( listener instanceof MouseMotionListener ) {\n            viewPane.removeMouseMotionListener( (MouseMotionListener)listener );\n        }\n        \n    }\n",
    "129899": "    public boolean isViewportDraggable() {\n        return viewportDraggable;\n    }\n",
    "129900": "    public void setViewportDraggable(final boolean viewportDraggable) {\n        this.viewportDraggable = viewportDraggable;\n    }\n",
    "129901": "    public void addObject(final VisualObject vo) {\n        rootObj.add(vo);\n        viewPane.repaint();\n    }\n",
    "129903": "    public boolean isObjectDraggable(final VisualObject obj) {\n        return draggableObjects.contains(obj);\n    }\n",
    "129904": "    public void setObjectDraggable(final VisualObject obj, final boolean draggable) {\n        if (draggable) {\n            draggableObjects.add(obj);\n        }\n        else {\n            draggableObjects.remove(obj);\n        }\n    }\n",
    "129905": "    public void removeObject(final VisualObject vo) {\n        rootObj.remove(vo);\n        viewPane.repaint();\n    }\n",
    "129907": "    static synchronized public SelectionManager getSharedInstance() {\n\n        if (singleton == null) {\n            singleton = new SelectionManager();\n        }\n\n        return singleton;\n    }\n",
    "129908": "    protected void translateObjectBeingDragged(final VisualObject obj, final double dx, final double dy) {\n\n        double diffX = dx;\n        double diffY = dy;\n\n        AffineTransform trans = obj.getTransform();\n\n        double scale = getVVDisplay().getWorldViewScale();\n        diffX /= (scale * trans.getScaleX());\n        diffY /= (scale * trans.getScaleY());\n\n        trans.translate(diffX, diffY);\n        obj.setTransform(trans);\n    }\n",
    "129909": "    public void addSelectionListener(final SelectionListener listener) {\n        listeners.add(listener);\n    }\n",
    "129910": "    public void removeSelectionListener(final SelectionListener listener) {\n        listeners.remove(listener);\n    }\n",
    "129911": "    public void mouseMoved(final MouseEvent e) {\n\n        // Record the current mouse location\n        lastKnownPoint = e.getPoint();\n    }\n",
    "129913": "    synchronized public void setSelectedObject(final VisualObject obj) {\n\n        VisualObject oldSelection = getSelectedObject();\n        VisualObject newSelection = obj;\n\n        // Determine if a change has occurred\n        if (oldSelection == newSelection) {\n            return;\n        }\n        boolean transition = ((oldSelection != null) && (newSelection != null)) ? true : false;\n\n        // Notify of deselection\n        SelectionEvent event = null;\n        if (oldSelection != null) {\n            event = new SelectionEvent(oldSelection, false, transition);\n\n            for (SelectionListener listener : listeners) {\n                listener.selectionChanged(event);\n            }\n        }\n        selection = newSelection;\n\n        // Notify of selection\n        if (newSelection != null) {\n            event = new SelectionEvent(newSelection, true, transition);\n            for (SelectionListener listener : listeners) {\n                listener.selectionChanged(event);\n            }\n        }\n\n    }\n",
    "129914": "    public VisualObject getSelectedObject() {\n        return selection;\n    }\n",
    "129918": "    private Graphics getBufferedGraphics() {\n\n        // This ensures that this method only creates the BufferStrategy once\n        if (bufferStrategy != null) {\n            return bufferStrategy.getDrawGraphics();\n        }\n\n        try {\n            createBufferStrategy(2);\n            bufferStrategy = getBufferStrategy();\n        }\n        catch (IllegalStateException ise) {\n            bufferStrategy = null;\n            return null;\n        }\n\n        return getBufferedGraphics();\n    }\n",
    "129924": "    private void determineObjectForDrag(final MouseEvent e) {\n\n        // Determine the VisualObject that's under the mouse\n        VisualObject visObj = getVVDisplay().getVisualObjectAt(e.getX(), e.getY());\n\n        // Figure out the nearest draggable object\n        while ((visObj != null) && (!isObjectDraggable(visObj))) {\n            visObj = visObj.getParent();\n        }\n        objectBeingDragged = visObj;\n\n        // If no draggable object was found, consider the viewport\n        if ((objectBeingDragged == null) && (isViewportDraggable())) {\n            objectBeingDragged = getVVDisplay();\n        }\n\n    }\n",
    "129941": "    public void encode(final OutputStream out, final Object object) {\n        XMLEncoder encoder = new XMLEncoder(out);\n        prepareEncoder(encoder);\n        encoder.writeObject(object);\n        encoder.close();\n    }\n",
    "129944": "    public void add(final VisualObject obj) {\n        objects.add(obj);\n        unarrangedPositions.put(obj, obj.getTransform());\n    }\n",
    "129947": "    public void remove(final VisualObject obj) {\n        unarrangedPositions.remove(obj);\n        objects.remove(obj);\n    }\n",
    "129948": "    public int getObjectsPerRow() {\n        return objectsPerRow;\n    }\n",
    "129949": "    public void setAnimationEnabled(final boolean enabled) {\n        animationEnabled = enabled;\n    }\n",
    "129952": "    public boolean isAnimationEnabled() {\n        return animationEnabled;\n    }\n",
    "129953": "    public void arrange() {\n\n        Map<VisualObject, AffineTransform> positions = getArrangedPositions();\n\n        // Apply the positions, possibly using an animation\n        for (VisualObject obj : getObjects()) {\n            AffineTransform position = positions.get(obj);\n            VVDisplay vvDisplay = obj.getDisplay();\n            if (vvDisplay != null) {\n                TaskManager taskManager = vvDisplay.getTaskManager();\n                if (taskManager != null) {\n                    if (isAnimationEnabled()) {\n                        vvDisplay.getTaskManager().addTask(new TranslationTask(obj, position.getTranslateX(), position.getTranslateY(), 2000));\n                        continue;\n                    }\n                }\n            }\n\n            // This is the default behavior if animation cannot be achieved\n            obj.setTransform(position);\n        }\n\n    }\n",
    "129954": "    public void unarrange() {\n        for (VisualObject obj : getObjects()) {\n            AffineTransform position = unarrangedPositions.get(obj);\n            obj.setTransform(position);\n        }\n    }\n",
    "129956": "    static public Shape getBasicArrowTip() {\n        Polygon arrowTip = new Polygon();\n        arrowTip.addPoint(-4, -8);\n        arrowTip.addPoint(0, 0);\n        arrowTip.addPoint(4, -8);\n        arrowTip.addPoint(0, 0);\n\n        return arrowTip;\n    }\n",
    "129957": "    static public Shape getAngularArrowTip() {\n        Polygon arrowTip = new Polygon();\n        arrowTip.addPoint(-4, -8);\n        arrowTip.addPoint(0, -4);\n        arrowTip.addPoint(4, -8);\n        arrowTip.addPoint(0, 0);\n\n        return arrowTip;\n    }\n",
    "129958": "    static public Shape getClosedArrowTip() {\n        Polygon arrowTip = new Polygon();\n        arrowTip.addPoint(-5, -8);\n        arrowTip.addPoint(0, 0);\n        arrowTip.addPoint(5, -8);\n\n        return arrowTip;\n    }\n",
    "129959": "    public String getLabelText() {\n        return labelText;\n    }\n",
    "129960": "    public Shape getShape() {\n        return shape;\n    }\n",
    "129961": "    public void setShape(final Shape shape) {\n        this.shape = shape;\n    }\n",
    "129963": "    public VisualObject getObject() {\n        return object;\n    }\n",
    "129965": "    public void setObject(final VisualObject object) {\n        this.object = object;\n    }\n",
    "129966": "    public long getTime() {\n        return time;\n    }\n",
    "129967": "    public ExecutionState getState() {\n        return state;\n    }\n",
    "129968": "    public boolean isEdge() {\n        return edge;\n    }\n",
    "129973": "    public void setRate(final double rate) {\n        this.rate = rate;\n    }\n",
    "129984": "    public int getCycleLength() {\n        return cycleLength;\n    }\n",
    "129985": "    public void removeTask(final AnimationTask task) {\n        chain.remove(task);\n    }\n",
    "129988": "    public void setCycleLength(final int cycleLength) {\n        this.cycleLength = cycleLength;\n    }\n",
    "129990": "    public void addTask(final AnimationTask task) {\n\n        task.setManager(this);\n        tasks.add(task);\n\n        // Start the thread when the first task is added\n        if (tasks.size() == 1) {\n            new Thread(this, \"TaskManager Thread\").start();\n        }\n\n    }\n",
    "129991": "    protected void setManager(final TaskManager manager) {\n        this.manager = manager;\n    }\n",
    "129994": "    public TaskManager getManager() {\n        return manager;\n    }\n",
    "129995": "    public void removeTaskListener(final TaskListener listener) {\n        listeners.remove(listener);\n    }\n",
    "129997": "    public void signalExit() {\n        tasks.clear();\n    }\n",
    "129998": "    public boolean isFixedHorizontalLabel() {\n        return fixedHorizontalLabel;\n    }\n",
    "129999": "    synchronized public void stop() {\n        duration = 0;\n    }\n",
    "130000": "    public ExecutionState getExecutionState() {\n        return executionState;\n    }\n",
    "130004": "    public void setFixedHorizontalLabel(final boolean horizontal) {\n        fixedHorizontalLabel = horizontal;\n    }\n",
    "130006": "    public double getTotal() {\n        return total;\n    }\n",
    "130007": "    public void setImage(final Image image) {\n        this.image = image;\n\n        // Update the shape based on the image's bounding box\n        Rectangle2D bounds = new Rectangle2D.Double(0, 0, image.getWidth(null), image.getHeight(null));\n        setShape(bounds);\n    }\n",
    "130008": "    public Image getImage() {\n        return image;\n    }\n",
    "130012": "    public void setText(final String text) {\n        if (text == null) {\n            this.text = \"\";\n        }\n        else {\n            this.text = text;\n        }\n\n        if (font != null) {\n            glyphVector = font.createGlyphVector(context, text);\n            super.setShape(glyphVector.getOutline());\n        }\n    }\n",
    "130013": "    synchronized public VVDisplay getDisplay() {\n\n        if (vvDisplay == null) { // doesn't know its display\n\n            if (getParent() != null) { // has a parent\n                return getParent().getDisplay();\n            }\n\n            // doesn't have a parent\n            return null;\n\n        }\n\n        // knows its display\n        return vvDisplay;\n    }\n",
    "130015": "    public String getText() {\n        return text;\n    }\n",
    "130016": "    public void setFont(final Font font) {\n        if (font == null) {\n            this.font = FontManager.getSharedInstance().getFont(\"Dialog-PLAIN-12\");\n        }\n        else {\n            this.font = font;\n        }\n\n        if (text != null) {\n            glyphVector = this.font.createGlyphVector(context, text);\n            super.setShape(glyphVector.getOutline());\n        }\n    }\n",
    "130017": "        public Point2D getCenterPoint() {\n\n            double[] centerCoords = new double[2];\n\n            if (prevCoords == null) {\n                centerCoords[0] = coords[0];\n                centerCoords[1] = coords[1];\n            }\n            else {\n\n                RectangularShape rect = new Rectangle2D.Double(prevCoords[0], prevCoords[1], coords[0]\n                        - prevCoords[0], coords[1] - prevCoords[1]);\n\n                centerCoords[0] = rect.getCenterX();\n                centerCoords[1] = rect.getCenterY();\n            }\n\n            return new Point2D.Double(centerCoords[0], centerCoords[1]);\n        }\n",
    "130019": "    synchronized public Shape getShape() {\n        return shape;\n    }\n",
    "130025": "    public VisualObject getTurret() {\n        return turret;\n    }\n",
    "130026": "    synchronized public void setShape(final Shape shape) {\n        this.shape = shape;\n    }\n",
    "130028": "    public void rotateTurret(final double theta) {\n        Point2D rotationPoint = turret.getRotationPoint();\n        AffineTransform transform = turret.getTransform();\n        transform.rotate(theta, rotationPoint.getX(), rotationPoint.getY());\n        turret.setTransform(transform);\n    }\n",
    "130034": "    synchronized public Brush getLineBrush() {\n        return lineBrush;\n    }\n",
    "130041": "    synchronized public void setLineBrush(final Brush lineBrush) {\n        this.lineBrush = lineBrush;\n    }\n",
    "130048": "    synchronized public Brush getFillBrush() {\n        return fillBrush;\n    }\n",
    "130055": "    synchronized public void setFillBrush(final Brush fillBrush) {\n        this.fillBrush = fillBrush;\n    }\n",
    "130057": "\tpublic DocumentController getControllerSource() {\n\t\treturn (DocumentController)getSource();\n\t}\n",
    "130059": "\tpublic void setCaretLocation(final int location) throws BadLocationException {\n\t\tdocument.getText( location, 0 );\n\t\tcaretLocation = location;\n\t\tsetSelectionLength(0);\n\t}\n",
    "130060": "\tprivate void updateShape() {\n\t\tif( font != null ) {\n\t\t\tglyphVector = font.createGlyphVector( context, getText() );\n\t\t\tsuper.setShape( glyphVector.getOutline() );\n\t\t}\n\t}\n",
    "130061": "\tpublic int getCaretLocation() {\n\t\treturn caretLocation;\n\t}\n",
    "130062": "    synchronized public void addLevelOfDetail(final double scale, final int detail) {\n        if (lodManager == null) {\n            lodManager = new LODManager();\n        }\n        lodManager.addLevel(scale, detail);\n    }\n",
    "130065": "\tpublic void setSelectionLength(final int length) throws BadLocationException {\n\t\tdocument.getText( caretLocation - length, 0 );\n\t\tselectionLength = length;\n\t}\n",
    "130067": "\tpublic int getSelectionLength() {\n\t\treturn selectionLength;\n\t}\n",
    "130069": "    synchronized public int getLevelOfDetail(final Graphics2D g2d) {\n        if (lodManager != null) {\n            AffineTransform absTransform = getTransformRelativeTo(null);\n            AffineTransform gTransform = g2d.getTransform();\n\n            double scale = Math.max(Math.abs(absTransform.getScaleX()), Math.abs(absTransform.getScaleY()));\n            scale *= Math.max(Math.abs(gTransform.getScaleX()), Math.abs(gTransform.getScaleY()));\n            return lodManager.getLevel(scale);\n        }\n\n        return Integer.MAX_VALUE;\n    }\n",
    "130070": "\tpublic void insert(final String text) {\n\t\ttry {\n\t\t\tdocument.insertString( getCaretLocation(), text, null );\n\t\t} catch (BadLocationException ble) {\n\t\t\tlogger.throwing( getClass().getName(), \"insert\", ble );\n\t\t}\n\t}\n",
    "130072": "\tpublic void delete(final int length) {\n\t\ttry {\n\t\t\tdocument.remove( getCaretLocation(), length );\n\t\t} catch (BadLocationException ble) {\n\t\t\tlogger.throwing( getClass().getName(), \"delete\", ble );\n\t\t}\n\t}\n",
    "130074": "\tpublic void replaceSelection(final String text) {\n\t\ttry {\n\t\t\tint startLocation = getCaretLocation()-getSelectionLength();\n\t\t\tdocument.remove( startLocation, getSelectionLength() );\n\t\t\tdocument.insertString( startLocation, text, null );\n\t\t\tsetCaretLocation( startLocation + text.length() );\n\t\t\tsetSelectionLength( text.length() );\n\t\t} catch (BadLocationException ble) {\n\t\t\tlogger.throwing( getClass().getName(), \"replaceSelection\", ble );\n\t\t}\n\t}\n",
    "130076": "    synchronized public void add(final VisualObject obj) {\n        if (objManager == null) {\n            objManager = new VisualObjectManager();\n        }\n        objManager.addObject(obj);\n\n        obj.setParent(this);\n    }\n",
    "130077": "\tpublic void deleteSelection() {\n\t\ttry {\n\t\t\tint startLocation = getCaretLocation()-getSelectionLength();\n\t\t\tdocument.remove( startLocation, getSelectionLength() );\n\t\t\tsetCaretLocation( startLocation );\n\t\t} catch (BadLocationException ble) {\n\t\t\tlogger.throwing( getClass().getName(), \"deleteSelection\", ble );\n\t\t}\n\t}\n",
    "130078": "\tpublic DocumentController getController() {\n\t\treturn controller;\n\t}\n",
    "130079": "\tpublic String getSelectedText() {\n\t\ttry {\n\t\t\tint startLocation = getCaretLocation()-getSelectionLength();\n\t\t\treturn document.getText( startLocation, getSelectionLength() );\n\t\t} catch (BadLocationException ble) {\n\t\t\tlogger.throwing( getClass().getName(), \"getSelectedText\", ble );\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "130080": "\tpublic Document getDocument() {\n\t\treturn document;\n\t}\n",
    "130081": "    synchronized public void remove(final VisualObject obj) {\n        if (objManager == null) {\n            return;\n        }\n        objManager.removeObject(obj);\n\n        obj.setParent(null);\n    }\n",
    "130083": "\tpublic void addDocumentSelectionChangeListener(final DocumentSelectionChangeListener listener) {\n\t\t\n\t}\n",
    "130088": "    synchronized public int getLayer() {\n        return layer;\n    }\n",
    "130093": "    synchronized public void setLayer(final int layer) {\n        this.layer = layer;\n    }\n",
    "130099": "    synchronized public VisualObject getParent() {\n        return parent;\n    }\n",
    "130104": "    synchronized public AffineTransform getTransform() {\n        return new AffineTransform(transform);\n    }\n",
    "130108": "    synchronized public void setTransform(final AffineTransform transform) {\n        this.transform = transform;\n    }\n",
    "130112": "    synchronized public AffineTransform getTransformRelativeTo(final VisualObject parent) {\n\n        // Check to see if this is the desired parent\n        if (parent == this) {\n            return new AffineTransform();\n\n            // Check to see if this object is a root object\n        }\n        else if (getParent() == null) {\n            return getTransform();\n\n            // Return this object's transform concatenated to those it inherits\n        }\n        else {\n            AffineTransform transform = getParent().getTransformRelativeTo(parent);\n            transform.concatenate(getTransform());\n            return transform;\n        }\n\n    }\n",
    "130115": "    synchronized public Point2D getRotationPoint() {\n        Rectangle2D bounds = shape.getBounds2D();\n        return new Point2D.Double(bounds.getCenterX(), bounds.getCenterY());\n    }\n",
    "130118": "    synchronized public boolean contains(final Point2D point) {\n\n        Point2D transPoint = (Point2D) point.clone();\n        try {\n            transPoint = getTransformRelativeTo(null).createInverse().transform(transPoint, transPoint);\n        }\n        catch (NoninvertibleTransformException e) {\n            return false;\n        }\n        return getShape().contains(transPoint);\n    }\n",
    "130121": "    synchronized public VisualObject getVisualObjectAt(final Point2D point) {\n\n        // Check to see if an embedded object is there first\n        if (objManager != null) {\n            for (VisualObject obj : objManager.getAllObjects()) {\n                VisualObject found = obj.getVisualObjectAt(point);\n                if (found != null) {\n                    return found;\n                }\n            }\n        }\n\n        // Check to see if this object contains the point\n        if (contains(point)) {\n            return this;\n        }\n\n        return null;\n    }\n",
    "130126": "    synchronized public void prepare() {\n        // Does nothing by default\n    }\n",
    "130130": "    synchronized public void render(final Graphics2D g) {\n\n        renderingDetail = getLevelOfDetail(g);\n\n        Graphics2D transformedG = (Graphics2D) g.create();\n        transformedG.transform(transform);\n        renderObject(transformedG);\n\n        if (objManager != null) {\n            // Only render children if the detail level is at least 2\n            if (renderingDetail >= 2) {\n                objManager.renderNegativeLayers(transformedG);\n            }\n        }\n\n        renderOutline(transformedG);\n\n        if (objManager != null) {\n            // Only render children if the detail level is at least 2\n            if (renderingDetail >= 2) {\n                objManager.renderNonNegativeLayers(transformedG);\n            }\n        }\n\n        transformedG.dispose();\n    }\n",
    "130135": "    synchronized public void renderObject(final Graphics2D g) {\n        if (fillBrush != null) {\n            fillBrush.useOn(g);\n\n            if (renderingDetail >= 2) {\n                g.fill(shape);\n            }\n            else if (renderingDetail == 1) {\n                Rectangle rect = shape.getBounds();\n                g.fillRect(rect.x, rect.y, rect.width, rect.height);\n            }\n        }\n    }\n",
    "130137": "    public AbstractPositionDevice (PlayerClient plc) {\n        super (plc);\n    }\n",
    "130140": "    synchronized public void renderOutline(final Graphics2D g) {\n        if (renderingDetail >= 2) {\n            if (lineBrush != null) {\n                lineBrush.useOn(g);\n                g.draw(shape);\n            }\n        }\n    }\n",
    "130141": "    public Position3DInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_POSITION3D_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130142": "    public BlinkenlightInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_BLINKENLIGHT_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130143": "    public void set (byte ena, int period) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, 3);         /* 3 bytes payload */\n            os.writeByte (ena);                         /* enable/disable */\n            os.writeShort (period);                     /* flash period in ms */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Blinkenlight] : Couldn't send set command request: \" + \n                    e.toString ());\n        }\n    }\n",
    "130144": "    public MapInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_MAP_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130146": "    public void getMapInformation () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_MAP_GET_INFO_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Map] : Couldn't send PLAYER_MAP_GET_INFO_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130148": "    public void getMapData (int col, int row, int width, int height) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 17);     /* 17 byte payload */\n            os.writeByte (PLAYER_MAP_GET_DATA_REQ);\n            os.writeInt (col);        /* the tile origin (X - pixels) */\n            os.writeInt (row);        /* the tile origin (Y - pixels) */\n            os.writeInt (width);      /* the width of the tile in the map (pixels) */\n            os.writeInt (height);     /* the height of the tile in the map (pixels) */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Map] : Couldn't send PLAYER_MAP_GET_DATA_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130150": "    public void setPosition (int xP, int yP, int zP) {\n        setPosition (xP, yP, zP, this.pitch, this.roll, this.yaw,\n                     this.xSpeed, this.ySpeed, this.zSpeed, \n                     this.pitchSpeed, this.rollSpeed, this.yawSpeed,\n                     (byte)1, (byte)1);\n    }\n",
    "130151": "    public void handleNARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Map] : Handling NAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Map] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130152": "    public PtzInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_PTZ_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130153": "    public void setPosition (int xP, int yP, int zP, int pitchP, int rollP, int yawP) {\n        setPosition (xP, yP, zP, pitchP, rollP, yawP, \n                     this.xSpeed, this.ySpeed, this.zSpeed,\n                     this.pitchSpeed, this.rollSpeed, this.yawSpeed, (byte)1, (byte)1);\n    }\n",
    "130154": "    public void setPTZ (int pan, int tilt, int zoom, int panspeed, int tiltspeed) {\n    \ttry {\n            sendHeader (PLAYER_MSGTYPE_CMD, 10);    /* 10 byte payload */\n            os.writeShort ((short)pan);             /* pan (degrees */\n            os.writeShort ((short)tilt);            /* tilt (degrees) */ \n            os.writeShort ((short)zoom);            /* field of view (degrees) */\n            os.writeShort ((short)panspeed);        /* current pan velocity (deg/sec) */\n            os.writeShort ((short)tiltspeed);       /* current tilt velocity (deg/sec) */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Ptz] : Couldn't send set PTZ parameters command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130157": "    public void genericRequest (int length, byte[] buf) {\n        if (length > PLAYER_PTZ_MAX_CONFIG_LEN)\n            length = PLAYER_PTZ_MAX_CONFIG_LEN;\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, length + 3);\n            os.writeByte (PLAYER_PTZ_GENERIC_CONFIG_REQ);\n            os.writeShort ((short)length);     /* length of data in config buffer */ \n            \n            for (int i = 0; i < length; i++) {\n            \tos.writeByte (buf[i]);         /* buffer for command/reply */\n            }\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Ptz] : Couldn't send PLAYER_PTZ_GENERIC_CONFIG_REQ command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130158": "    public void controlRequest (int mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_PTZ_CONTROL_MODE_REQ);\n            os.writeByte ((byte)mode);              /* 0 for velocity, 1 for position */ \n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Ptz] : Couldn't send PLAYER_PTZ_CONTROL_MODE_REQ command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130159": "    public void setSpeed (int xS, int yS) {\n        setPosition (this.xPos, this.yPos, this.zPos, this.pitch, this.roll, this.yaw,\n                     xS, yS, this.zSpeed, this.pitchSpeed, this.rollSpeed, this.yawSpeed, \n                     (byte)1, (byte)0);\n    }\n",
    "130161": "    public void setAutoServo (int mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_PTZ_AUTOSERVO);\n            os.writeByte ((byte)mode);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Ptz] : Couldn't send PLAYER_PTZ_AUTOSERVO command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130162": "    public void handleResponse (int size) {\n        if (size == 0) {\n            if (isDebugging)\n                System.err.println (\"[Ptz][Debug] : Unexpected response of size 0!\");\n            return;\n        }\n        try {\n            /* each reply begins with a uint8_t subtype field */\n            byte subtype = is.readByte ();\n            switch (subtype) {\n                case PLAYER_PTZ_GENERIC_CONFIG_REQ: {\n                    break;\n                }\n                case PLAYER_PTZ_CONTROL_MODE_REQ: {\n                    break;\n                }\n                case PLAYER_PTZ_AUTOSERVO: {\n                    break;\n                }\n                default:{\n                    System.err.println (\"[Ptz] : Unexpected response \" + subtype + \n                            \" of size = \" + size);\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            System.err.println (\"[Ptz] : Error when reading payload \" + e.toString ());\n        }\n    }\n",
    "130164": "    public void setSpeed (int xS, int yS, int zS) {\n        setPosition (this.xPos, this.yPos, this.zPos, this.pitch, this.roll, this.yaw,\n        \t\t     xS, yS, zS, this.pitchSpeed, this.rollSpeed, this.yawSpeed, \n                     (byte)1, (byte)0);\n    }\n",
    "130165": "    public LogInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_LOG_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130166": "    public void setLoggingState (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 byte payload */\n            os.writeByte (PLAYER_LOG_SET_WRITE_STATE_REQ);\n            os.writeByte ((byte)state);             /* 0=disabled, 1=enabled */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Log] : Couldn't send PLAYER_LOG_SET_WRITE_STATE_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130167": "    public void setPlaybackState (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 byte payload */\n            os.writeByte (PLAYER_LOG_SET_READ_STATE_REQ);\n            os.writeByte ((byte)state);             /* 0=disabled, 1=enabled */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Log] : Couldn't send PLAYER_LOG_SET_READ_STATE_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130168": "    public void setSpeed (int xS, int yS, int zS, int pitchS, int rollS, int yawS) {\n        setPosition (this.xPos, this.yPos, this.zPos, this.pitch, this.roll, this.yaw,\n        \t\t     xS, yS, zS, pitchS, rollS, yawS, (byte)1, (byte)0);\n    }\n",
    "130169": "    public void rewindPlayback () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_LOG_SET_READ_REWIND_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Log] : Couldn't send PLAYER_LOG_SET_READ_REWIND_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130170": "    public void readState () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_LOG_GET_STATE_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Log] : Couldn't send PLAYER_LOG_GET_STATE_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130172": "    public void setFileName (String fileName) {\n        if (fileName.length () > 255)\n            fileName = fileName.substring(0, 255);\n        try {\n            int size = 2 + fileName.length ();\n            sendHeader (PLAYER_MSGTYPE_REQ, size);     /* payload */\n            os.writeByte (PLAYER_LOG_SET_FILENAME);\n            for (int i = 0; i < fileName.length (); i++)\n                os.writeByte (fileName.toCharArray ()[i]);\n            os.writeByte (0);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Log] : Couldn't send PLAYER_LOG_SET_FILENAME \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130173": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.write (PLAYER_POSITION3D_GET_GEOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_GET_GEOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130177": "    public boolean isGeomReady () {\n        if (readyPPGT) {\n            readyPPGT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130180": "    public boolean isStateReady () {\n        if (readyState) {\n            readyState = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130181": "    public HeadingControl (AbstractPositionDevice pd) {\n        super (1, 0, 0);\n        this.device = pd;\n    }\n",
    "130184": "    public HeadingControl (AbstractPositionDevice pd, int minC, int maxC) {\n        super (1, 0, 0);\n        this.minCommand = minC;\n        this.maxCommand = maxC;\n        this.device     = pd;\n    }\n",
    "130187": "    public void setMotorPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION3D_MOTOR_POWER_REQ);\n            os.writeByte ((byte)state);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_MOTOR_POWER_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130188": "    public void setMinimumCommand (int minC) {\n       this.minCommand = minC; \n    }\n",
    "130189": "    public void setMaximumCommand (int maxC) {\n       this.maxCommand = maxC; \n    }\n",
    "130190": "    public void stopRobot () {\n        this.stop = true;\n    }\n",
    "130191": "    public void changePositionControl (byte state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION3D_POSITION_MODE_REQ);\n            os.writeByte (state);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_POSITION_MODE_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130192": "    public void setAllowedError (int err) {\n    \tthis.maxError = err;\n    }\n",
    "130193": "    public double getCommand (double currentOutput) {\n        this.currE = this.goal - currentOutput;\n        \n        /* Angle adjustments */\n        if(currE  <= -180 )\n            currE =  360 + currE;\n        else \n            if(currE >= 180  && currE <= 360)\n            \tcurrE = currE - 360;\n            else \n                if(currE > 360)\n                \tcurrE = currE - 360;\n                \n        eSum += currE;\n        \n        lastE = currE;\n        \n        double Pgain = this.Kp * currE;\n        double Igain = this.Ki * eSum;\n        double Dgain = this.Kd * deltaE ();\n        \n        return Pgain + Igain + Dgain;\n    }\n",
    "130196": "    private int boundCommand (int command) {\n        if (command == 0)\n            return 0;\n        if (command < 0) {\n            if (command > -minCommand)\n                command = -minCommand;\n            if (command < -maxCommand)\n                command = -maxCommand;\n        }\n        else {\n            if (command < minCommand)\n                command = minCommand;\n            if (command > maxCommand)\n                command = maxCommand;\n        }\n        return command;\n    }\n",
    "130197": "    public void setVelocityControl (byte value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION3D_VELOCITY_MODE_REQ);\n            os.writeByte (value);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_VELOCITY_MODE_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130198": "    private int transformAngle (int angle) {\n        angle = angle % 360;\n        if (angle < 0)\n           angle = 360 + angle;\n        return angle;\n    }\n",
    "130200": "    public boolean setHeading (int angle) {\n        /* get the current heading */\n        int currentAngle =  transformAngle (device.getYaw ());\n        \n        /* difference between the current heading and the goal heading */\n        int deltaAngle   = (angle - currentAngle);\n        \n        if (deltaAngle != 0) {\n            if (deltaAngle <= 180 && deltaAngle > 0) \n                return setDiffHeading (deltaAngle);\n            else \n                if (deltaAngle > -180)\n                \treturn setDiffHeading (-360 + deltaAngle);\n                else\n                \treturn setDiffHeading (360 + deltaAngle);\n        }\n        return true;\n    }\n",
    "130202": "    public PIController (double Kp, double Ki) {\n    \tthis.kp = Kp;\n        this.ki = Ki;\n    }\n",
    "130204": "    public double getCommand (double currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        double Pgain = this.kp * currE;\n        double Igain = this.ki * eSum;\n        \n        return Pgain + Igain;\n    }\n",
    "130205": "    public double getKp () {\n        return this.kp;\n    }\n",
    "130206": "    public void setKp (double newKp) {\n        this.kp = newKp;\n    }\n",
    "130207": "    public double getKi () {\n        return this.ki;\n    }\n",
    "130208": "    public void setKi (double newKi) {\n        this.ki = newKi;\n    }\n",
    "130209": "    public void setGoal (double newGoal) {\n        this.goal = newGoal;\n    }\n",
    "130210": "    protected double deltaE () {\n        return (currE - lastE);\n    }\n",
    "130211": "    public void resetOdometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_POSITION3D_RESET_ODOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_RESET_ODOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130212": "    public PDController (double Kp, double Kd) {\n    \tthis.kp = Kp;\n        this.kd = Kd;\n    }\n",
    "130213": "    public double getCommand (double currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        double Pgain = this.kp * currE;\n        double Dgain = this.kd * deltaE ();\n        \n        return Pgain + Dgain;\n    }\n",
    "130216": "    public double getKd () {\n        return this.kd;\n    }\n",
    "130218": "    public void setKd (double newKd) {\n        this.kd = newKd;\n    }\n",
    "130219": "    public PIDController (double Kp, double Ki, double Kd) {\n    \tthis.kp = Kp;\n        this.ki = Ki;\n        this.kd = Kd;\n    }\n",
    "130220": "    public void setVelocityPIDParams (int kp, int ki, int kd) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 13);        /* 13 bytes payload */\n            os.writeByte (PLAYER_POSITION3D_SPEED_PID_REQ);\n            os.writeInt (kp);\n            os.writeInt (ki);\n            os.writeInt (kd);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_SPEED_PID_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130221": "    public double getCommand (double currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        double Pgain = this.kp * currE;\n        double Igain = this.ki * eSum;\n        double Dgain = this.kd * deltaE ();\n        \n        return Pgain + Igain + Dgain;\n    }\n",
    "130231": "    public PositionControl (AbstractPositionDevice pd) {\n    \tsuper (1, 0, 0);\n    \tthis.device = pd;\n    }\n",
    "130233": "    public PositionControl (AbstractPositionDevice pd, int minC, int maxC) {\n    \tsuper (1, 0, 0);\n        this.minCommand = minC;\n        this.maxCommand = maxC;\n    \tthis.device     = pd;\n    }\n",
    "130234": "    public void setSpeedProfileParams (int sp, int acc) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 9);     /* 9 bytes payload */\n            os.writeByte (PLAYER_POSITION3D_SPEED_PROF_REQ);\n            os.writeInt (sp);\n            os.writeInt (acc);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : Couldn't send \" +\n                    \"PLAYER_POSITION3D_SPEED_PROF_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130240": "    public void handleNARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Position3D] : Handling NAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130242": "    public Point getRobotPosition () {\n       return new Point (device.getX (), device.getY ());\n    }\n",
    "130246": "    public void handleEARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Position3D] : Handling EAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Position3D] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130248": "    public PController (double Kp) {\n    \tthis.kp = Kp;\n    }\n",
    "130249": "    public AIOInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_AIO_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130250": "    public double getCommand (double currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        double Pgain = this.kp * currE;\n        \n        return Pgain;\n    }\n",
    "130253": "    public TruthInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_TRUTH_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130254": "    public WiFiInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_WIFI_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130255": "    public void teleport (int x, int y) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 25);      /* 25 bytes payload */\n            os.writeByte (PLAYER_TRUTH_SET_POSE);\n            os.writeInt (x);\n            os.writeInt (y);\n            os.writeInt (zPos);\n            os.writeInt (rHead);\n            os.writeInt (pHead);\n            os.writeInt (yHead);\n            os.flush ();\n        } catch (Exception e) {\n        \tSystem.err.println (\"[Truth] : Couldn't send PLAYER_TRUTH_SET_POSE command: \" +\n                    e.toString ());\n        }\n        isTeleported = !isTeleported;\n    }\n",
    "130256": "    public void teleport (int x, int y, int z) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 25);      /* 25 bytes payload */\n            os.writeByte (PLAYER_TRUTH_SET_POSE);\n            os.writeInt (x);\n            os.writeInt (y);\n            os.writeInt (z);\n            os.writeInt (rHead);\n            os.writeInt (pHead);\n            os.writeInt (yHead);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Truth] : Couldn't send PLAYER_TRUTH_SET_POSE command: \" +\n                    e.toString ());\n        }\n        isTeleported = !isTeleported;\n    }\n",
    "130257": "    public EnergyInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_ENERGY_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130259": "    public void getMapData (byte enable_input, byte enable_output) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 byte payload */\n            os.writeByte (enable_input);\n            os.writeByte (enable_output);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Energy] : Couldn't send command: \" + e.toString ());\n        }\n    }\n",
    "130260": "    public void teleport (int xp, int yp, int zp, int ro, int po, int yo) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 25);      /* 25 bytes payload */\n            os.writeByte (PLAYER_TRUTH_SET_POSE);\n            os.writeInt (xp);\n            os.writeInt (yp);\n            os.writeInt (zp);\n            os.writeInt (ro);\n            os.writeInt (po);\n            os.writeInt (yo);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Truth] : Couldn't send PLAYER_TRUTH_SET_POSE command: \" +\n                    e.toString ());\n        }\n        isTeleported = !isTeleported;\n    }\n",
    "130261": "    public SpeechInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device = PLAYER_SPEECH_CODE;\n        index  = indexOfDevice;\n    }\n",
    "130264": "    public SonarInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_SONAR_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130265": "    public void handleResponse (int size) {\n        if (size == 0) {\n            if (isDebugging)\n            \tSystem.err.println (\"[Truth][Debug] : Unexpected response of size 0!\");\n            return;\n        }\n        try {\n            \n        } catch (Exception e) {\n        \tSystem.err.println (\"[Truth] : Error when reading payload \" + e.toString ());\n        }\n    }\n",
    "130266": "    public JoystickInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_JOYSTICK_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130267": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);\t\t/* 1 byte payload */\n            os.writeByte (PLAYER_SONAR_GET_GEOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Sonar] : Couldn't send PLAYER_SONAR_GET_GEOM_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130268": "    public DIOInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_DIO_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130269": "    public void setSonarPower (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_SONAR_POWER_REQ);\n            os.writeByte ((byte)value);             /* turn power off (0) or on (>0) */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Sonar] : Couldn't send PLAYER_SONAR_POWER_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130270": "    public void setOutputBitfield (byte count, int digout) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, 5);       /* 5 bytes payload */\n            os.writeByte (count);\n            os.writeInt  (digout);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[DIO] : Couldn't send output bitfield command request: \" + \n                    e.toString ());\n        }\n    }\n",
    "130273": "    public BlobfinderInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_BLOBFINDER_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130274": "    public boolean isPSGTReady () {\n        if (readyPSGT) {\n            readyPSGT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130279": "    public PowerInterface (PlayerClient pc, short indexOfDevice) {\n    \tsuper (pc);\n        device = PLAYER_POWER_CODE;\n        index  = indexOfDevice;\n    }\n",
    "130280": "    public void requestCharge () {\n    \ttry {\n    \t    sendHeader (PLAYER_MSGTYPE_REQ, 1);       /* 1 byte payload */\n            os.writeByte (PLAYER_MAIN_POWER_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Power] : Couldn't send PLAYER_MAIN_POWER_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130281": "    public void handleResponse (int size) {\n        if (size == 0) {\n            if (isDebugging)\n                System.err.println (\"[Blobfinder][Debug] : Unexpected response of size 0!\");\n            return;\n        }\n        try {\n            /* each reply begins with a uint8_t subtype field */\n            byte subtype = is.readByte ();\n            switch (subtype) {\n                case PLAYER_BLOBFINDER_SET_COLOR_REQ: {\n                    break;\n                }\n                case PLAYER_BLOBFINDER_SET_IMAGER_PARAMS_REQ: {\n                    break;\n                }\n                default:{\n                    System.err.println (\"[Blobfinder] : Unexpected response \" + subtype + \n                            \" of size = \" + size);\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            System.err.println (\"[Blobfinder] : Error when reading payload \" + e.toString ());\n        }\n    }\n",
    "130283": "    public SoundInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device = PLAYER_SOUND_CODE;\n        index  = indexOfDevice;\n    }\n",
    "130284": "    public AudioDSPInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_AUDIODSP_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130285": "    public void play (short index) {\n    \ttry {\n            sendHeader (PLAYER_MSGTYPE_CMD, 2);       /* 2 bytes payload */\n            os.writeShort (index);                    /* index of sound to be played */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Sound] : Couldn't send play command request: \" + \n                    e.toString ());\n        }\n    }\n",
    "130287": "    public void getAudioProperties () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_AUDIODSP_GET_CONFIG);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[AudioDSP] : Couldn't send PLAYER_AUDIODSP_GET_CONFIG \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130288": "    public void setAudioProperties (int sampleFormat, int sampleRate, byte channels) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 8);     /* 8 byte payload */\n            os.writeByte  (PLAYER_AUDIODSP_SET_CONFIG);\n            os.writeInt   (sampleFormat);           /* format with which to sample */ \n            os.writeShort (sampleRate);             /* Sample rate in Hertz */\n            os.writeByte  (channels);               /* nr of channels to use, 1=mono, 2=stereo */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[AudioDSP] : Couldn't send PLAYER_AUDIODSP_SET_CONFIG \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130292": "    public FiducialInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_FIDUCIAL_CODE;\n        index     = indexOfDevice;\n        \n        // create the new items\n        for (int i = 0; i < fiducials.length; i++) {\n            fiducials[i] = new PlayerFiducialItem();\n        }\n    }\n",
    "130293": "    public void getGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_FIDUCIAL_GET_GEOM);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Fiducial] : Couldn't send PLAYER_FIDUCIAL_GET_GEOM \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130297": "    public boolean isGeomReady () {\n        if (geometryReady) {\n            geometryReady = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130298": "    public void close () {\n        try {\n            /* close all sockets */\n        \tos.close     ();\n            buffer.close ();\n            is.close     ();\n            socket.close ();\n        } catch (Exception e) {\n            System.err.println (\"[PlayerClient] : Error in PlayerClient stop: \" + e.toString ());\n            System.exit (1);\n        }\n    }\n",
    "130300": "    public void getFOV () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_FIDUCIAL_GET_FOV);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Fiducial] : Couldn't send PLAYER_FIDUCIAL_GET_FOV \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130301": "    public boolean isFOVReady () {\n        if (fovReady) {\n            fovReady = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130302": "    public void setNotThreaded() {\n    \tisThreaded = false;\n    }\n",
    "130304": "    public void setFOV (int newMinRange, int newMaxRange, int newViewAngle) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 7);     /* 7 byte payload */\n            os.writeByte (PLAYER_FIDUCIAL_SET_FOV);\n            /* the minimum range of the sensor in mm */\n            os.writeShort (newMinRange);\n            /* the maximum range of the sensor in mm */\n            os.writeShort (newMaxRange);\n            /* the receptive angle of the sensor in degrees */\n            os.writeShort (newViewAngle);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Fiducial] : Couldn't send PLAYER_FIDUCIAL_SET_FOV \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130306": "    public void getFiducialVal () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_FIDUCIAL_GET_ID);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Fiducial] : Couldn't send PLAYER_FIDUCIAL_GET_ID \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130308": "    public boolean isIDReady () {\n        if (idReady) {\n            idReady = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130309": "    public void runThreaded (long millis, int nanos) {\n        if (isThreaded) {\n            System.err.println (\"[PlayerClient] : A second call for runThreaded, ignoring!\");\n            return;\n        }\n\t    this.millis = millis;\n\t    this.nanos  = nanos;\n\t    isThreaded  = true;\n\t    this.start ();\n\t}\n",
    "130310": "    public void setFiducialVal (int newID) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 5);     /* 5 byte payload */\n            os.writeByte (PLAYER_FIDUCIAL_SET_ID);\n            os.writeInt (newID);                    /* the value displayed */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Fiducial] : Couldn't send PLAYER_FIDUCIAL_SET_ID \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130312": "    public int getFiducialCount() {\n    \treturn this.count; \n    }\n",
    "130313": "    public MotorInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_MOTOR_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130314": "    public void run () {\n        try {\n            while (isThreaded) {\n                while (read () != PLAYER_MSGTYPE_SYNCH && isThreaded);\n                if (millis < 0)\n                    Thread.yield ();\n                else\n                    if (nanos <= 0)\n                        Thread.sleep (millis);\n                    else\n                        Thread.sleep (millis, nanos);\n            }\n        } catch (Exception e) { e.printStackTrace (); }\n    }\n",
    "130320": "    public void setVelocityControl (byte mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_MOTOR_VELOCITY_MODE_REQ);\n            os.writeByte (mode);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : Couldn't send \" +\n                    \"PLAYER_MOTOR_VELOCITY_MODE_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130321": "    public void resetOdometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_MOTOR_RESET_ODOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : Couldn't send \" +\n                    \"PLAYER_MOTOR_RESET_ODOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130322": "    public void setOdometry (int xT, int yT, int theta) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 5);        /* 5 bytes payload */\n            os.writeByte (PLAYER_MOTOR_SET_ODOM_REQ);\n            os.writeInt (theta);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : Couldn't send \" +\n                    \"PLAYER_MOTOR_SET_ODOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130323": "    public PowerInterface requestInterfacePower (int index, char r) {\n        return (PowerInterface)requestDeviceAccess (PLAYER_POWER_CODE, \n                (short)index, r);\n    }\n",
    "130324": "    public void setVelocityPIDParams (int kp, int ki, int kd) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 13);        /* 13 bytes payload */\n            os.writeByte (PLAYER_MOTOR_SPEED_PID_REQ);\n            os.writeInt (kp);\n            os.writeInt (ki);\n            os.writeInt (kd);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : Couldn't send \" +\n                    \"PLAYER_MOTOR_SPEED_PID_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130327": "    public void setSpeedProfileParams (int sp, int acc) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 9);     /* 9 bytes payload */\n            os.writeByte (PLAYER_MOTOR_SPEED_PROF_REQ);\n            os.writeInt (sp);\n            os.writeInt (acc);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : Couldn't send \" +\n                    \"PLAYER_MOTOR_SPEED_PROF_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130328": "    public void setMotorPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_MOTOR_MOTOR_POWER_REQ);\n            os.writeByte (state);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : Couldn't send \" +\n                    \"PLAYER_MOTOR_MOTOR_POWER_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130329": "    public GripperInterface requestInterfaceGripper (int index, char r) {\n        return (GripperInterface)requestDeviceAccess (PLAYER_GRIPPER_CODE, \n                (short)index, r);\n    }\n",
    "130330": "    public void handleNARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Motor] : Handling NAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130333": "    public void handleEARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Motor] : Handling EAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Motor] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130334": "    public NomadInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_NOMAD_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130335": "    public void setVelocities (int newveltrans, int newvelsteer, int newvelturret) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, 12);   /* 12 byte payload */\n            os.writeInt (newveltrans);             /* translation velocity */\n            os.writeInt (newvelsteer);             /* steering velocity */ \n            os.writeInt (newvelturret);            /* turret rotation velocity */ \n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Nomad] : Couldn't send set new goals command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130336": "    public AudioMixerInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_AUDIOMIXER_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130338": "    public void setVolume (byte subtype, short left, short right) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, 5); /* 5 byte payload */\n            os.writeByte  (subtype);            /* the packet subtype */\n            os.writeShort (left);               /* left channel */ \n            os.writeShort (right);              /* right channel */ \n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[AudioMixer] : Couldn't send new command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130339": "    public void getLevels (byte subtype) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n// Not yet implemented in player!\n            os.writeByte (subtype);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[AudioMixer] : Couldn't send command: \" + e.toString ());\n        }\n    }\n",
    "130340": "    public PositionInterface requestInterfacePosition (int index, char r) {\n        return (PositionInterface)requestDeviceAccess (PLAYER_POSITION_CODE,   \n                (short)index, r);\n    }\n",
    "130342": "    public PlayerDevice (PlayerClient plc) {\n        pc = plc;\n        is = pc.is;\n        os = pc.os;\n    }\n",
    "130344": "    public void handleNARMessage () {\n        System.err.println (\"[PlayerDevice] : Need to handle a NAR message.\");\n    }\n",
    "130346": "    public void handleEARMessage () {\n        System.err.println (\"[PlayerDevice] : Need to handle a EAR message.\");\n    }\n",
    "130347": "    public void handleResponse (int size) {\n        if (size == 0) {\n            System.err.println (\"[PlayerDevice] : Unexpected response of size 0!\");\n            return;\n        }\n        System.err.println (\"[PlayerDevice] : General handle responce was triggered.\");\n    }\n",
    "130348": "    public BumperInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device      = PLAYER_BUMPER_CODE;\n        index       = indexOfDevice;\n    }\n",
    "130349": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);        /* 1 byte payload */\n            os.writeByte (PLAYER_BUMPER_GET_GEOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Bumper] : Couldn't send PLAYER_BUMPER_GET_GEOM_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130351": "    public SonarInterface requestInterfaceSonar (int index, char r) {\n        return (SonarInterface)requestDeviceAccess (PLAYER_SONAR_CODE, \n                (short)index, r);\n    }\n",
    "130353": "    public boolean isGeomReady () {\n        if (readyPBGT) {\n            readyPBGT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130356": "    public Position2DInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_POSITION2D_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130358": "    public LaserInterface requestInterfaceLaser (int index, char r) {\n        return (LaserInterface)requestDeviceAccess (PLAYER_LASER_CODE, \n                (short)index, r);\n    }\n",
    "130360": "    public void setPosition (int xP, int yP, int yawT) {\n        setPosition (xP, yP, yawT, \n                     this.xSpeed, this.ySpeed, this.yawSpeed, (byte)1, (byte)1);\n    }\n",
    "130361": "    public void setSpeed (int speed, int turnrate) {\n        setPosition (this.xPos, this.yPos, this.yaw, \n                     speed, this.ySpeed, turnrate, (byte)1, (byte)0);\n    }\n",
    "130364": "    public void setSpeed (int speed, int turnrate, int sideSpeed) {\n        setPosition(this.xPos, this.yPos, this.yaw, \n                    speed, sideSpeed, turnrate, (byte)1, (byte)0);\n    }\n",
    "130365": "    public BlobfinderInterface requestInterfaceBlobfinder (int index, char r) {\n        return (BlobfinderInterface)requestDeviceAccess (PLAYER_BLOBFINDER_CODE, \n                (short)index, r);\n    }\n",
    "130366": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.write (PLAYER_POSITION2D_GET_GEOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_GET_GEOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130370": "    public PtzInterface requestInterfacePtz (int index, char r) {\n        return (PtzInterface)requestDeviceAccess (PLAYER_PTZ_CODE, \n                (short)index, r);\n    }\n",
    "130371": "    public void setMotorPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION2D_MOTOR_POWER_REQ);\n            os.writeByte ((byte)state);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_MOTOR_POWER_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130374": "    public void setVelocityControl (byte mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION2D_VELOCITY_MODE_REQ);\n            os.writeByte (mode);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_VELOCITY_MODE_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130375": "    public AudioInterface requestInterfaceAudio (int index, char r) {\n        return (AudioInterface)requestDeviceAccess (PLAYER_AUDIO_CODE, \n                (short)index, r);\n    }\n",
    "130376": "    public void resetOdometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_POSITION2D_RESET_ODOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_RESET_ODOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130379": "    public FiducialInterface requestInterfaceFiducial (int index, char r) {\n        return (FiducialInterface)requestDeviceAccess (PLAYER_FIDUCIAL_CODE, \n                (short)index, r);\n    }\n",
    "130380": "    public void setOdometry (int xT, int yT, int theta) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 13);        /* 13 bytes payload */\n            os.writeByte (PLAYER_POSITION2D_SET_ODOM_REQ);\n            os.writeInt (xT);\n            os.writeInt (yT);\n            os.writeInt (theta);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_SET_ODOM_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130382": "    public void setVelocityPIDParams (int kp, int ki, int kd) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 13);        /* 13 bytes payload */\n            os.writeByte (PLAYER_POSITION2D_SPEED_PID_REQ);\n            os.writeInt (kp);\n            os.writeInt (ki);\n            os.writeInt (kd);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_SPEED_PID_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130385": "    public SpeechInterface requestInterfaceSpeech (int index, char r) {\n        return (SpeechInterface)requestDeviceAccess (PLAYER_SPEECH_CODE, \n                (short)index, r);\n    }\n",
    "130387": "    public void setSpeedProfileParams (int sp, int acc) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 9);     /* 9 bytes payload */\n            os.writeByte (PLAYER_POSITION2D_SPEED_PROF_REQ);\n            os.writeInt (sp);\n            os.writeInt (acc);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : Couldn't send \" +\n                    \"PLAYER_POSITION2D_SPEED_PROF_REQ command: \" + e.toString ());\n        }\n    }\n",
    "130388": "    public void handleNARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Position2D] : Handling NAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Position2D] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130390": "    public GPSInterface requestInterfaceGPS (int index, char r) {\n        return (GPSInterface)requestDeviceAccess (PLAYER_GPS_CODE, \n                (short)index, r);\n    }\n",
    "130394": "    public LaserInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device    = PLAYER_LASER_CODE;\n        index     = indexOfDevice;\n\n        for (int i = 0; i < range.length; i++) {\n            range[i]     = 0;\n            intensity[i] = 0;\n        }\n\t}\n",
    "130395": "    public BumperInterface requestInterfaceBumper (int index, char r) {\n        return (BumperInterface)requestDeviceAccess (PLAYER_BUMPER_CODE, \n                (short)index, r);\n    }\n",
    "130396": "    public void getGeometry () {\n    \ttry {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);        /* 1 byte payload */\n            os.writeByte (PLAYER_LASER_GET_GEOM);\n            os.flush ();\n        } catch (Exception e) {\n        \tSystem.err.println (\"[Laser] : Couldn't send PLAYER_LASER_GET_GEOM command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130397": "    public void setScanProperties (short minA, short maxA, short res, short range, byte intent) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 10);        /* 10 bytes payload */\n            os.writeByte (PLAYER_LASER_SET_CONFIG);\n            os.writeShort (minA);                       /* start angle for the laser scan */\n            os.writeShort (maxA);                       /* end angle for the laser scan */\n            os.writeShort (res);                        /* scan resolution */\n            os.writeShort (range);                      /* range resolution */\n            os.writeByte  (intent);                     /* enable reflection intensity data */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Laser] : Couldn't send PLAYER_LASER_SET_CONFIG command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130400": "    public void setPower (byte value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);        /* 2 bytes payload */\n            os.writeByte (PLAYER_LASER_POWER_CONFIG);\n            os.writeByte (value);\n            os.flush ();\n        } catch (Exception e) {\n        \tSystem.err.println (\"[Laser] : Couldn't send PLAYER_LASER_POWER_CONFIG command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130402": "    public TruthInterface requestInterfaceTruth (int index, char r) {\n        return (TruthInterface)requestDeviceAccess (PLAYER_TRUTH_CODE, \n                (short)index, r);\n    }\n",
    "130407": "    public boolean isReadyPLGT () {\n        if (readyPLGT) {\n            readyPLGT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130408": "    public DIOInterface requestInterfaceDIO (int index, char r) {\n        return (DIOInterface)requestDeviceAccess (PLAYER_DIO_CODE, \n                (short)index, r);\n    }\n",
    "130410": "    public boolean isReadyPLCT () {\n        if (readyPLCT) {\n            readyPLCT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130411": "    public CameraInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_CAMERA_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130413": "    public void handleResponse (int size) {\n        if (size == 0) {\n            if (isDebugging)\n                System.err.println (\"[Camera][Debug] : Unexpected response of size 0!\");\n            return;\n        }\n        try {\n            /* each reply begins with a uint8_t subtype field */\n            byte subtype = is.readByte ();\n            switch (subtype) {\n                default:{\n                    System.err.println (\"[Camera] : Unexpected response \" + subtype + \n                            \" of size = \" + size);\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            System.err.println (\"[Camera] : Error when reading payload \" + e.toString ());\n        }\n    }\n",
    "130414": "    public GripperInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device = PLAYER_GRIPPER_CODE;\n        index  = indexOfDevice;\n    }\n",
    "130416": "    public PlannerInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_PLANNER_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130418": "    public void setGoal (int newgx, int newgy, int newga) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, 12);   /* 12 byte payload */\n            os.writeInt (newgx);                   /* Goal location (mm,mm,deg) */\n            os.writeInt (newgy);\n            os.writeInt (newga);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Planner] : Couldn't send set new goals command: \" +\n                    e.toString ());\n        }\n    }\n",
    "130419": "    public AIOInterface requestInterfaceAIO (int index, char r) {\n        return (AIOInterface)requestDeviceAccess (PLAYER_AIO_CODE, \n                (short)index, r);\n    }\n",
    "130420": "    public void getWaypoints () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_PLANNER_GET_WAYPOINTS_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Planner] : Couldn't send PLAYER_PLANNER_GET_WAYPOINTS_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130422": "    public void setRobotMotion (byte state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_PLANNER_ENABLE_REQ);\n            os.writeByte (state);                   /* 1 to enable, 0 to disable */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Planner] : Couldn't send PLAYER_PLANNER_ENABLE_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130427": "    public IRInterface requestInterfaceIR (int index, char r) {\n        return (IRInterface)requestDeviceAccess (PLAYER_IR_CODE, \n                (short)index, r);\n    }\n",
    "130433": "    public WaveformInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_WAVEFORM_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130435": "    public GPSInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device    = PLAYER_GPS_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130436": "    public AudioInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device = PLAYER_AUDIO_CODE;\n        index  = indexOfDevice;\n        \n        for (int i = 0; i < 5; i++) {\n        \tfrequency[i] = 0;\n            amplitude[i] = 0;\n        }\n    }\n",
    "130438": "    public WiFiInterface requestInterfaceWiFi (int index, char r) {\n        return (WiFiInterface)requestDeviceAccess (PLAYER_WIFI_CODE, \n                (short)index, r);\n    }\n",
    "130439": "    public void produceSound (short freq, short amp, short duration) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, 6);       /* 6 bytes payload */\n            os.writeShort (freq);                     /* freq frequency to play (Hz?) */\n            os.writeShort (amp);                      /* amp amplitude to play (dB?) */\n            os.writeShort (duration);                 /* duration duration to play (sec?) */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Audio] : Couldn't send produce sound command request: \" + \n                    e.toString ());\n        }\n    }\n",
    "130440": "    public IRInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_IR_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130441": "    public void queryPose () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);     /* 1 byte payload */\n            os.writeByte (PLAYER_IR_POSE_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[IR] : Couldn't send PLAYER_IR_POSE_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130442": "    public void setIRPower (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);     /* 2 bytes payload */\n            os.writeByte (PLAYER_IR_POWER_REQ);\n            os.writeByte ((byte)value);             /* 0 for power off, 1 for power on */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[IR] : Couldn't send PLAYER_IR_POWER_REQ command: \" + \n                    e.toString ());\n        }\n    }\n",
    "130444": "    public boolean isPIPRTReady () {\n        if (readyPIPRT) {\n            readyPIPRT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130447": "    public WaveformInterface requestInterfaceWaveform (int index, char r) {\n        return (WaveformInterface)requestDeviceAccess (PLAYER_WAVEFORM_CODE, \n                (short)index, r);\n    }\n",
    "130448": "    public PositionInterface (PlayerClient pc, short indexOfDevice) {\n        super (pc);\n        device    = PLAYER_POSITION_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130453": "    public void setHeading (int yawT) {\n        setPosition (this.x, this.y, yawT, \n                     this.xSpeed, this.ySpeed, this.yawSpeed, (byte)1, (byte)1);\n    }\n",
    "130454": "    public LocalizeInterface requestInterfaceLocalize (int index, char r) {\n        return (LocalizeInterface)requestDeviceAccess (PLAYER_LOCALIZE_CODE, \n                (short)index, r);\n    }\n",
    "130455": "    public void setSpeed (int speed, int turnrate) {\n        setPosition (this.x, this.y, this.yaw, \n                     speed, this.ySpeed, turnrate, (byte)1, (byte)0);\n    }\n",
    "130456": "    public void setSpeed (int speed, int turnrate, int sideSpeed) {\n        setPosition(this.x, this.y, this.yaw, speed, sideSpeed, turnrate, (byte)1, (byte)0);\n    }\n",
    "130457": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);\t\t/* 1 byte payload */\n            os.write (PLAYER_POSITION_GET_GEOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send PLAYER_POSITION_GET_GEOM_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130461": "    public void setMotorPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);\t\t/* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION_MOTOR_POWER_REQ);\n            os.writeByte ((byte)state);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send PLAYER_POSITION_MOTOR_POWER_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130462": "    public MComInterface requestInterfaceMCom (int index, char r) {\n        return (MComInterface)requestDeviceAccess (PLAYER_MCOM_CODE, \n                (short)index, r);\n    }\n",
    "130463": "    public void setVelocityControl (int mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 2);\t\t/* 2 bytes payload */\n            os.writeByte (PLAYER_POSITION_VELOCITY_MODE_REQ);\n            os.writeByte ((byte)mode);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send PLAYER_POSITION_VELOCITY_MODE_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130464": "    public void resetOdometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 1);\t\t/* 1 byte payload */\n            os.writeByte (PLAYER_POSITION_RESET_ODOM_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send PLAYER_POSITION_RESET_ODOM_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130468": "    public void setOdometry (int xT, int yT, int theta) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 13);        /* 13 bytes payload */\n            os.writeByte (PLAYER_POSITION_SET_ODOM_REQ);\n            os.writeInt (xT);\n            os.writeInt (yT);\n            os.writeInt (theta);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send PLAYER_POSITION_SET_ODOM_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130469": "    public SoundInterface requestInterfaceSound (int index, char r) {\n        return (SoundInterface)requestDeviceAccess (PLAYER_SOUND_CODE, \n                (short)index, r);\n    }\n",
    "130473": "    public void setSpeedProfileParams (short sp, short acc) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 5);\t\t/* 5 bytes payload */\n            os.writeByte (PLAYER_POSITION_SPEED_PROF_REQ);\n            os.writeShort (sp);\n            os.writeShort (acc);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send PLAYER_POSITION_SPEED_PROF_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130474": "    public void setSegwayRPMparams (byte subtype, short value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 3);\t\t/* 3 bytes payload */\n            os.writeByte  (subtype);\n            os.writeShort (value);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Position] : Couldn't send Segway RPM configuration request: \" +\n                    e.toString ());\n        }\n    }\n",
    "130476": "    public AudioDSPInterface requestInterfaceAudioDSP (int index, char r) {\n        return (AudioDSPInterface)requestDeviceAccess (PLAYER_AUDIODSP_CODE, \n                (short)index, r);\n    }\n",
    "130479": "    public void handleNARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Position] : Handling NAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Position] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130480": "    public void handleEARMessage () {\n        try {\n            int size = is.readInt ();    /* read the packet size */\n            System.err.println (\"[Position] : Handling EAR of size = \" + size);\n        } catch (Exception e) {\n            System.err.println (\"[Position] : handleResponsePosition ERROR \" + e.toString ());\n        }\n    }\n",
    "130481": "    public AudioMixerInterface requestInterfaceAudioMixer (int index, char r) {\n        return (AudioMixerInterface)requestDeviceAccess (PLAYER_AUDIOMIXER_CODE, \n                (short)index, r);\n    }\n",
    "130482": "    public MComInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_MCOM_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130486": "    public void Push (int type, String channel, char[] dataT) {\n        sendConfigReq (PLAYER_MCOM_PUSH_REQ, type, channel, true, dataT);\n    }\n",
    "130488": "    public void Read (int type, String channel) {\n        char[] dataT = new char[MCOM_DATA_LEN];\n        sendConfigReq (PLAYER_MCOM_READ_REQ, type, channel, false, dataT);\n    }\n",
    "130490": "    public Position3DInterface requestInterfacePosition3D (int index, char r) {\n        return (Position3DInterface)requestDeviceAccess (PLAYER_POSITION3D_CODE, \n                (short)index, r);\n    }\n",
    "130491": "    public void setCapacity (int type, String channel, char capacity) {\n        char[] dataT = new char[MCOM_DATA_LEN];\n        dataT[0] = capacity;\n        sendConfigReq (PLAYER_MCOM_SET_CAPACITY_REQ, type, channel, false, dataT);\n    }\n",
    "130492": "    public boolean isDataReady () {\n        if (readyData) {\n            readyData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130495": "    public LocalizeInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_LOCALIZE_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130497": "    public SpeechRecognitionInterface (PlayerClient pc, short indexOfDevice) {\n        super(pc);\n        device    = PLAYER_SPEECH_RECOGNITION_CODE;\n        index     = indexOfDevice;\n    }\n",
    "130498": "    public int getHypothCount () {\n    \treturn this.hypothCount;\n    }\n",
    "130499": "    public char charValue() {\n        return this.value;\n    }\n",
    "130502": "    public void setPose (int[] mean, long[][] cov) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 85);      /* 85 bytes payload */\n            os.writeByte (PLAYER_LOCALIZE_SET_POSE_REQ);\n            for (int i = 0; i < 3; i++)\n                os.writeInt (mean[i]);                /* mean value of the pose estimate */\n            for (int i = 0; i < 3; i++)\n                for (int j = 0; j < 3; j++)\n                    os.writeLong (cov[i][j]);         /* covariance matrix pose estimate */\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Localize] : Couldn't send PLAYER_LOCALIZE_SET_POSE_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130503": "    public SimulationInterface requestInterfaceSimulation (int index, char r) {\n        return (SimulationInterface)requestDeviceAccess (PLAYER_SIMULATION_CODE, \n                (short)index, r);\n    }\n",
    "130507": "    public void setConfiguration (int numParticles) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, 5);      /* 5 bytes payload */\n            os.writeByte (PLAYER_LOCALIZE_SET_CONFIG_REQ);\n            os.writeInt (numParticles);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[Localize] : Couldn't send PLAYER_LOCALIZE_GET_CONFIG_REQ \" +\n                    \"command: \" + e.toString ());\n        }\n    }\n",
    "130511": "    public boolean isPLCTReady () {\n        if (readyPLCT) {\n            readyPLCT = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130512": "    public int getReason() {\n        return reason;\n    }\n",
    "130514": "    public long longValue() {\n        return this.value;\n    }\n",
    "130516": "    public int getXdrLength() {\n        return bufferIndex;\n    }\n",
    "130518": "    public BlinkenlightInterface requestInterfaceBlinkenlight (int index, char r) {\n        return (BlinkenlightInterface)requestDeviceAccess (PLAYER_BLINKENLIGHT_CODE, \n                (short)index, r);\n    }\n",
    "130520": "    public int intValue() {\n        return this.value;\n    }\n",
    "130524": "    public byte byteValue() {\n        return this.value;\n    }\n",
    "130533": "    public short shortValue() {\n        return this.value;\n    }\n",
    "130535": "    public void setXdrData(byte [] buffer, int encodedLength) {\n        //\n        // Make sure that the buffer size is a multiple of four, otherwise\n        // throw an exception.\n        //\n        if ( (encodedLength < 0)\n             || (encodedLength & 3) != 0 ) {\n            throw(new IllegalArgumentException(\"length of encoded data must be a multiple of four and must not be negative\"));\n        }\n        this.buffer = buffer;\n        this.encodedLength = encodedLength;\n        bufferIndex = 0;\n        bufferHighmark = -4;\n    }\n",
    "130538": "    public InetAddress getSenderAddress() {\n        return null;\n    }\n",
    "130539": "    public NomadInterface requestInterfaceNomad (int index, char r) {\n        return (NomadInterface)requestDeviceAccess (PLAYER_NOMAD_CODE, \n                (short)index, r);\n    }\n",
    "130541": "    public float floatValue() {\n        return this.value;\n    }\n",
    "130542": "    public int getSenderPort() {\n        return 0;\n    }\n",
    "130546": "    public double doubleValue() {\n        return this.value;\n    }\n",
    "130550": "    public boolean booleanValue() {\n        return this.value;\n    }\n",
    "130555": "    public CameraInterface requestInterfaceCamera (int index, char r) {\n        return (CameraInterface)requestDeviceAccess (PLAYER_CAMERA_CODE, \n                (short)index, r);\n    }\n",
    "130565": "    public MapInterface requestInterfaceMap (int index, char r) {\n        return (MapInterface)requestDeviceAccess (PLAYER_MAP_CODE, \n                (short)index, r);\n    }\n",
    "130566": "    public void setCharacterEncoding(String characterEncoding) {\n        this.characterEncoding = characterEncoding;\n    }\n",
    "130568": "    public String getCharacterEncoding() {\n        return characterEncoding;\n    }\n",
    "130570": "    public String stringValue() {\n        return this.value;\n    }\n",
    "130574": "    public PlannerInterface requestInterfacePlanner (int index, char r) {\n        return (PlannerInterface)requestDeviceAccess (PLAYER_PLANNER_CODE, \n                (short)index, r);\n    }\n",
    "130578": "    public PointCloud3DInterface (PlayerClient pc) {\n        super (pc);\n    }\n",
    "130579": "    public PlayerPointCloud3DData getData () {\n        return this.ppc3data;\n    }\n",
    "130580": "    public boolean isDataReady () {\n        if (readyPpc3data) {\n            readyPpc3data = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130584": "    public boolean isDataReady () {\n        if (readyPbdata) {\n            readyPbdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130586": "    public LogInterface requestInterfaceLog (int index, char r) {\n        return (LogInterface)requestDeviceAccess (PLAYER_LOG_CODE, \n                (short)index, r);\n    }\n",
    "130590": "    public void setPosition (PlayerPosition3dCmdPos pp3dcp) {\n        setPosition(pp3dcp.getPos(), pp3dcp.getVel(), pp3dcp.getState());\n    }\n",
    "130596": "    public EnergyInterface requestInterfaceEnergy (int index, char r) {\n        return (EnergyInterface)requestDeviceAccess (PLAYER_ENERGY_CODE, \n                (short)index, r);\n    }\n",
    "130597": "    public void requestMapInformation () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_MAP_REQ_GET_INFO, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Map] : ECouldn't request PLAYER_MAP_GET_INFO_REQ: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130598": "    public void setVelocity (PlayerPosition3dCmdVel pp3dcv) {\n        setVelocity(pp3dcv.getVel(), pp3dcv.getState());\n    }\n",
    "130600": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_POSITION3D_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position3D] : Couldn't send \" +\n                        \"PLAYER_POSITION3D_GET_GEOM_REQ: \" + e.toString(), e);\n        }\n    }\n",
    "130601": "    public void requestMapDataVector () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_MAP_REQ_GET_VECTOR, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Map] : Couldn't request PLAYER_MAP_REQ_GET_VECTOR: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130605": "    public MotorInterface requestInterfaceMotor (int index, char r) {\n        return (MotorInterface)requestDeviceAccess (PLAYER_MOTOR_CODE, \n                (short)index, r);\n    }\n",
    "130607": "    public boolean isDataReady () {\n        if (readyPminfo) {\n            readyPminfo = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130611": "    public boolean isGridDataReady () {\n        if (readyPmdata) {\n            readyPmdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130613": "    public Position2DInterface requestInterfacePosition2D (int index, char r) {\n        return (Position2DInterface)requestDeviceAccess (PLAYER_POSITION2D_CODE, \n                (short)index, r);\n    }\n",
    "130615": "    public void resetOdometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_POSITION3D_RESET_ODOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position3D] : Couldn't request \" +\n                        \"PLAYER_POSITION3D_RESET_ODOM: \" + e.toString(), e);\n        }\n    }\n",
    "130616": "    public boolean isMapDataVectorReady () {\n        if (readyPmdatavector) {\n            readyPmdatavector = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130619": "    public boolean isDataReady () {\n        if (readyPrdata) {\n            readyPrdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130621": "    public void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_RFID_REQ_POWER: {\n                // null response\n                break;\n            }\n            case PLAYER_RFID_REQ_READTAG: {\n                // null response\n                break;\n            }\n            case PLAYER_RFID_REQ_WRITETAG: {\n                // null response\n                break;\n            }\n            case PLAYER_RFID_REQ_LOCKTAG: {\n                // null response\n                break;\n            }\n            default:{\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[RFID][Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "130623": "    public JoystickInterface requestInterfaceJoystick (int index, char r) {\n        return (JoystickInterface)requestDeviceAccess (PLAYER_JOYSTICK_CODE, \n                (short)index, r);\n    }\n",
    "130630": "    public boolean isDataReady () {\n        if (readyPpdata) {\n            readyPpdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130631": "    public SpeechRecognitionInterface requestInterfaceSpeechRecognition (int index, char r) {\n        return (SpeechRecognitionInterface)requestDeviceAccess (PLAYER_SPEECH_RECOGNITION_CODE, \n                (short)index, r);\n    }\n",
    "130632": "    public boolean isGeomReady () {\n        if (readyPpgeom) {\n            readyPpgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130635": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PTZ_REQ_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Ptz] : Couldn't request PLAYER_PTZ_REQ_GEOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130639": "    public void controlRequest (int mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PTZ_REQ_CONTROL_MODE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (mode);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Ptz] : Couldn't request PLAYER_PTZ_REQ_CONTROL_MODE: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Ptz] : Error while XDR-encoding CONTROL_MODE request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130646": "    public boolean isDataReady () {\n        if (readyPp3ddata) {\n            readyPp3ddata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130649": "    public void rewindPlayback () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LOG_REQ_SET_READ_REWIND, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Log] : Couldn't request PLAYER_LOG_REQ_SET_READ_REWIND: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "130650": "    public void requestDeviceList () {\n       try {\n       \t    sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_CODE, (short)0, 2); /* 2 bytes payload */ \n       \t    os.writeShort (PLAYER_PLAYER_DEVLIST_REQ);\n       \t    os.flush ();\n       } catch (Exception e) {\n       \t    System.err.println (\"[PlayerClient] : Couldn't request device list \" + e.toString ());\n       }\n    }\n",
    "130651": "    public boolean isGeomReady () {\n        if (readyPp3dgeom) {\n            readyPp3dgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130652": "    public void queryState () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LOG_REQ_GET_STATE, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Log] : Couldn't request PLAYER_LOG_REQ_GET_STATE: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "130658": "    public boolean isDataReady () {\n        if (readyPlgs) {\n            readyPlgs = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130661": "    public void requestDriverName (short device) {\n       try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_CODE, (short)0, 4); /* 4 bytes payload */ \n            os.writeShort (PLAYER_PLAYER_DRIVERINFO_REQ);\n            os.writeShort (device);\n            os.flush ();\n       } catch (Exception e) {\n            System.err.println (\"[PlayerClient] : Couldn't request driver name \" + e.toString ());\n       }\n    }\n",
    "130666": "    public void setMinimumCommand (double minC) {\n        this.minCommand = minC;\n    }\n",
    "130667": "    public void setMaximumCommand (double maxC) {\n        this.maxCommand = maxC;\n    }\n",
    "130670": "    public void setAllowedError (double err) {\n        this.maxError = err;\n    }\n",
    "130674": "    private double boundCommand (double command) {\n        if (command == 0)\n            return 0;\n        if (command < 0) {\n            if (command > -minCommand)\n                command = -minCommand;\n            if (command < -maxCommand)\n                command = -maxCommand;\n        }\n        else {\n            if (command < minCommand)\n                command = minCommand;\n            if (command > maxCommand)\n                command = maxCommand;\n        }\n        return command;\n    }\n",
    "130676": "    private double transformAngle (double angle) {\n        angle = angle % 360;\n        if (angle < 0)\n            angle = 360 + angle;\n        return angle;\n    }\n",
    "130678": "    public boolean setHeading (double angle) {\n        /* get the current heading */\n        double currentAngle =  transformAngle (device.getYaw ());\n\n        /* difference between the current heading and the goal heading */\n        double deltaAngle   = (angle - currentAngle);\n\n        if (deltaAngle != 0) {\n            if (deltaAngle <= 180 && deltaAngle > 0)\n                return setDiffHeading (deltaAngle);\n            else\n                if (deltaAngle > -180)\n                    return setDiffHeading (-360 + deltaAngle);\n                else\n                    return setDiffHeading (360 + deltaAngle);\n        }\n        return true;\n    }\n",
    "130715": "    public boolean isDataReady () {\n        if (readyPadata) {\n            readyPadata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130720": "    public void requestData () {\n    \ttry {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_CODE, (short)0, 2); /* 2 bytes payload */ \n            os.writeShort (PLAYER_PLAYER_DATA_REQ);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[PlayerClient] : Couldn't request one round data \" + \n                    e.toString ());\n        }\n    }\n",
    "130723": "    public Point getRobotPosition () {\n        Point p = new Point ();\n        p.setLocation (device.getX (), device.getY ());\n        return p;\n    }\n",
    "130724": "    public boolean isDataReady () {\n        if (readyPwdata) {\n            readyPwdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130726": "    public void queryWifiMac () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_WIFI_REQ_MAC, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Wifi] : Couldn't request PLAYER_WIFI_REQ_MAC: \" +\n                        e.toString (), e);\n        }\n    }\n",
    "130727": "    public void queryWifiIwspyAddrAdd () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_WIFI_REQ_IWSPY_ADD, 32*4);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Wifi] : Couldn't request PLAYER_WIFI_REQ_IWSPY_ADD: \" +\n                        e.toString (), e);\n        }\n    }\n",
    "130729": "    public void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_WIFI_REQ_MAC: {\n                break;\n            }\n            default:{\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[Wifi][Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "130730": "    public String toString() {\n        return \"(PlayerGpsData time_sec=\" + time_sec + \" time_usec=\" + time_usec + \" latitude=\" + latitude\n                + \" longitude=\" + longitude + \" altitude=\" + altitude + \" utm_e=\" + utm_e\n                + \" utm_n=\" + utm_n + \" quality=\" + quality + \" num_sats=\" + num_sats + \" hdop=\" + hdop\n                + \" vdop=\" + vdop + \" err_horiz=\" + err_horz + \" err_vert=\" + err_vert + \")\";\n    }\n",
    "130737": "    public void requestDataDeliveryMode (byte mode) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_CODE, (short)0, 3); /* 3 bytes payload */ \n            os.writeShort (PLAYER_PLAYER_DATAMODE_REQ);\n            os.writeByte (mode);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[PlayerClient] : Couldn't request change of data mode \" + \n                    e.toString ());\n        }\n    }\n",
    "130746": "    public String toString() {\n        StringBuffer result = new StringBuffer(\"(PlayerPosition2dData\");\n        result.append(\"\\n\\tPosition: x=\" + pos.getPx() + \"m, y=\" + pos.getPy()\n                    + \"m, yaw=\" + pos.getPa() + \"rad\");\n        result.append(\"\\n\\tVelocity: x=\" + vel.getPx() + \"m/s, y= \" + vel.getPy()\n                    + \"m/s, yaw=\" + vel.getPa() + \"rad/s)\");\n        return result.toString();\n    }\n",
    "130762": "    public boolean isDataReady () {\n        if (readyPsdata) {\n            readyPsdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130764": "    public void requestDataDeliveryFrequency (short frequency) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_CODE, (short)0, 4); /* 4 bytes payload */ \n            os.writeShort (PLAYER_PLAYER_DATAFREQ_REQ);\n            os.writeShort (frequency);\n            os.flush ();\n        } catch (Exception e) {\n            System.err.println (\"[PlayerClient] : Couldn't request change of data frequency \" + \n                    e.toString ());\n        }\n    }\n",
    "130766": "    public boolean isGeomReady () {\n        if (readyPsgeom) {\n            readyPsgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130769": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_SONAR_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Sonar] : Couldn't request PLAYER_SONAR_REQ_GET_GEOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130771": "    public void setSonarPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_SONAR_REQ_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Sonar] : Couldn't request PLAYER_SONAR_REQ_POWER: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Sonar] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130775": "    public void clearScreen () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_GRAPHICS3D_CMD_CLEAR, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Graphics3D] : Couldn't send clear screen command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130779": "    public boolean isDataReady () {\n        if (readyPjdata) {\n            readyPjdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130781": "    public boolean isDataReady () {\n        if (readyPddata) {\n            readyPddata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130788": "    public void requestAuthentication (byte[] key) {\n        try {\n            if (key.length > 32) \n                throw new Exception (\"[PlayerClient] : Supplied authentication key is \" + \n                        key.length + \" but should be <= 32 bytes\");\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_CODE, (short)0, 34);/* 34 bytes payload */ \n            os.writeShort (PLAYER_PLAYER_AUTH_REQ);\n            for (int i = 0; i < key.length; i++)\n                os.writeByte (key[i]);\n            for (int i = 0; i < 32 - key.length; i++)\n                os.writeByte ((byte)0);\n            os.flush ();\n        } catch (Exception e) {\n        \tSystem.err.println (\"[PlayerClient] : Couldn't request authentication \" + \n                    e.toString ());\n        }\n    }\n",
    "130790": "    protected void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_BLOBFINDER_REQ_SET_COLOR: {\n                // null response\n                break;\n            }\n            case PLAYER_BLOBFINDER_REQ_SET_IMAGER_PARAMS: {\n                // null response\n                break;\n            }\n            default:{\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[Blobfinder][Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "130791": "    protected void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_POWER_SET_CHARGING_POLICY_REQ: {\n                break;\n            }\n            default:{\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[Power][Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "130804": "    public boolean isConfigReady () {\n        if (readyPaconfig) {\n            readyPaconfig = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130806": "    public void play (int index) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_SOUND_CMD_IDX, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (index);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Sound] : Couldn't send play command request: \" +\n                    e.toString (), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Sound] : Couldn't XDR-encode play command request: \" +\n                    e.toString (), e);\n        }\n    }\n",
    "130812": "    public void getAudioProperties () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_AUDIODSP_GET_CONFIG, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[AudioDSP] : Couldn't send PLAYER_AUDIODSP_GET_CONFIG \" +\n                        \"command: \" + e.toString(), e);\n        }\n    }\n",
    "130818": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_FIDUCIAL_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Fiducial] : Couldn't request PLAYER_FIDUCIAL_REQ_GET_GEOM: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "130820": "    public void queryFOV () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_FIDUCIAL_REQ_GET_FOV, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Fiducial] : Couldn't request PLAYER_FIDUCIAL_REQ_GET_FOV: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "130821": "    public void close () {\n        try\n      {\n  /*\n        for (int i = 0; i < deviceList.size (); i++)\n          {\n        PlayerDevice pd = (PlayerDevice)deviceList.get (i);\n        requestDeviceAccess (pd.getDeviceAddress ().getInterf (),\n                     pd.getDeviceAddress ().getIndex (),\n                     PLAYER_CLOSE_MODE);\n        readAll ();\n          }\n  */\n            // close all sockets\n            this.setNotThreaded ();\n            os.close     ();\n            buffer.close ();\n            is.close     ();\n            socket.close ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[PlayerClient]: Error in PlayerClient stop: \" +\n                        e.toString (), e);\n        }\n    }\n",
    "130823": "    public void readAll () {\n    \tif (isThreaded) return;\n        while (read () != PLAYER_MSGTYPE_SYNCH);\n    }\n",
    "130824": "    public void queryFiducialVal () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_FIDUCIAL_REQ_GET_ID, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Fiducial] : Couldn't request PLAYER_FIDUCIAL_REQ_GET_ID: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "130826": "    public void setFiducialVal (int id) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_FIDUCIAL_REQ_SET_ID, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (id);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Fiducial] : Couldn't request PLAYER_FIDUCIAL_REQ_SET_ID: \"\n                        + e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Fiducial] : Error while XDR-encoding SET_ID request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130828": "    public void setNotThreaded() {\n        if (!isThreaded)\n            return;\n        isThreaded = false;\n        while (isRunning == true) // wait to exit run thread\n            try { Thread.sleep (10); } catch (Exception e) { }\n    }\n",
    "130833": "    public void runThreaded (long millis, int nanos) {\n        if (isThreaded) {\n            logger.log (Level.WARNING, \"[PlayerClient]: A second call for runThreaded, ignoring!\");\n            return;\n        }\n        this.millis = millis;\n        this.nanos  = nanos;\n        isThreaded  = true;\n        this.start ();\n    }\n",
    "130837": "    public boolean isDataReady () {\n        if (readyPfdata) {\n            readyPfdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130838": "    public void run () {\n        isRunning = true;\n        try {\n            while (isThreaded) {\n                if (this.datamode == PLAYER_DATAMODE_PULL) {\n                    this.requestData ();\n                    while (read () != PLAYER_MSGTYPE_SYNCH && isThreaded);\n                } else\n//                    while (is.available () != 0)\n//                    while (read () != PLAYER_MSGTYPE_SYNCH && isThreaded);\n                    read ();\n\n                if (millis < 0)\n                    Thread.yield ();\n                else\n                    if (nanos <= 0)\n                        Thread.sleep (millis);\n                    else\n                        Thread.sleep (millis, nanos);\n            }\n        } catch (InterruptedException e) { throw new PlayerException (e); }\n}\n",
    "130840": "    public boolean isGeomReady () {\n        if (readyPfgeom) {\n            readyPfgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130842": "    public boolean isFOVReady () {\n        if (readyPffov) {\n            readyPffov = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130843": "    public void homeCmd () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_LIMB_CMD_HOME, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Limb] : Couldn't send homing command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130844": "    public boolean isIDReady () {\n        if (readyPfid) {\n            readyPfid = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130845": "    public void stopCmd () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_LIMB_CMD_STOP, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Limb] : Couldn't send stop command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130847": "    public Logger getLogger () {\n        return this.logger;\n    }\n",
    "130851": "    public void getLevels (byte subtype) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_AUDIOMIXER_GET_LEVELS, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[AudioMixer] : Couldn't request PLAYER_AUDIOMIXER_GET_LEVELS: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130859": "    public void setPower (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_REQ_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)value);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Limb] : Couldn't request PLAYER_LIMB_POWER_REQ: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Limb] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130861": "    public boolean isDataReady () {\n        if (readyPhdata) {\n            readyPhdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130864": "    public void setBrakes (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_REQ_BRAKES, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)value);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Limb] : Couldn't request PLAYER_LIMB_BRAKES_REQ: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Limb] : Error while XDR-encoding BRAKES request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130866": "    public void clearScreen () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_GRAPHICS2D_CMD_CLEAR, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Graphics2D] : Couldn't send clear screen command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130867": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_REQ_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Limb] : Couldn't request PLAYER_LIMB_GEOM_REQ: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "130870": "    public void setSpeed (float speed) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_REQ_SPEED, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeFloat (speed);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Limb] : Couldn't request PLAYER_LIMB_SPEED_REQ: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Limb] : Error while XDR-encoding SPEED request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130875": "    public boolean isDataReady () {\n        if (readyPodata) {\n            readyPodata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130876": "    public void command (byte[] data) {\n        try {\n            sendData (data, PLAYER_OPAQUE_CMD_DATA);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n            (\"[Opaque] : Couldn't send data command: \" +\n                    e.toString(), e);\n        } catch (IOException e) {\n            throw new PlayerException\n            (\"[Opaque] : Error while XDR-encoding data command: \" +\n                    e.toString(), e);\n        }\n    }\n",
    "130877": "    public void request (byte[] data) {\n        try {\n            sendData (data, PLAYER_OPAQUE_REQ_DATA);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n            (\"[Opaque] : Couldn't send data request: \" +\n                    e.toString(), e);\n        } catch (IOException e) {\n            throw new PlayerException\n            (\"[Opaque] : Error while XDR-encoding data request: \" +\n                    e.toString(), e);\n        }\n    }\n",
    "130880": "    public void handleResponse (PlayerMsgHdr header) {\n        try {\n            switch (header.getSubtype ()) {\n                case PLAYER_OPAQUE_REQ_DATA: {\n                    readData ();\n                    break;\n                }\n                default:{\n                    if (isDebugging)\n                        logger.log (Level.FINEST, \"[Opaque][Debug] : \" +\n                                \"Unexpected response \" + header.getSubtype () +\n                                \" of size = \" + header.getSize ());\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Opaque] : Error reading payload: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Opaque] : Error while XDR-decoding payload: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130885": "    public boolean isDataReady () {\n        if (readyPldata) {\n            readyPldata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130888": "    public boolean isGeomReady () {\n        if (readyPlgeom) {\n            readyPlgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130893": "    public void handleNARMessage () {\n        logger.log (Level.FINEST, \"[PlayerDevice] : Need to handle a NAR message.\");\n    }\n",
    "130895": "    protected void handleResponse (PlayerMsgHdr header) {\n        logger.log (Level.FINEST, \"[PlayerDevice] : General handle response was triggered.\");\n    }\n",
    "130896": "    public void setDeviceAddress (PlayerDevAddr newDevAddr) {\n        this.deviceAddress = newDevAddr;\n    }\n",
    "130898": "    public PlayerDevAddr getDeviceAddress () {\n        return this.deviceAddress;\n    }\n",
    "130900": "    public void setDeviceAccess (byte newDeviceAccess) {\n        this.deviceAccess = newDeviceAccess;\n    }\n",
    "130902": "    public byte getDeviceAccess () {\n        return this.deviceAccess;\n    }\n",
    "130903": "    public void setDeviceDriverName (String newDeviceDriverName) {\n        this.deviceDriverName = newDeviceDriverName;\n    }\n",
    "130904": "    public boolean isDataIntnsReady () {\n        if (readyPrintn) {\n            readyPrintn = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130905": "    public String getDeviceDriverName () {\n        return this.deviceDriverName;\n    }\n",
    "130906": "    public double getTimestamp() {\n      return timestamp;\n    }\n",
    "130907": "    public boolean isGeomReady () {\n        if (readyPrgeom) {\n            readyPrgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130909": "    public boolean isAuthenticated () { \n        if (receivedAuthentication) {\n            receivedAuthentication = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130911": "    public boolean isConfReady () {\n        if (readyPrconf) {\n            readyPrconf = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130914": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_RANGER_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Ranger] : Couldn't request PLAYER_RANGER_REQ_GET_GEOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130916": "    public boolean isGeomReady () {\n        if (readyPbgeom) {\n            readyPbgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130917": "    public void queryConfiguration () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_RANGER_REQ_GET_CONFIG, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Ranger] : Couldn't request PLAYER_RANGER_REQ_GET_CONFIG: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130919": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_BUMPER_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Bumper] : Couldn't request PLAYER_BUMPER_REQ_GET_GEOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130920": "    public void setRangerPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_RANGER_REQ_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Ranger] : Couldn't request PLAYER_RANGER_REQ_POWER: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Ranger] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130921": "    public void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_BUMPER_REQ_GET_GEOM: {\n                readGeom ();\n                break;\n            }\n            default:{\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[Bumper]Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "130923": "    public boolean isReadyPortNumber () {\n        if (readyPortNumber) {\n            readyPortNumber = false;\n            return true;\n        }\n        return false; \n    }\n",
    "130925": "    public void requestData () {\n        try {\n            sendHeader ((int)PLAYER_MSGTYPE_REQ, PLAYER_PLAYER_REQ_DATA, 0);\n                  os.flush  ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[PlayerClient]: Couldn't request data: \" +\n                        e.toString (), e);\n        }\n    }\n",
    "130929": "    public void getImage () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_CAMERA_REQ_GET_IMAGE, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Camera] : Couldn't send PLAYER_CAMERA_REQ_GET_IMAGE \" +\n                        \"command: \" + e.toString(), e);\n        }\n    }\n",
    "130935": "    public boolean isDataReady () {\n        if (readyPcdata) {\n            readyPcdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130942": "   public boolean isDataScanposeReady () {\n       if (readyPldatascan) {\n           readyPldatascan = false;\n           return true;\n       }\n       return false;\n   }\n",
    "130946": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LASER_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Laser] : Couldn't request PLAYER_LASER_REQ_GET_GEOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130949": "    public void setGripper (int cmd) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, cmd, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Gripper] : Couldn't send state command request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130950": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_GRIPPER_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Gripper] : Couldn't send PLAYER_GRIPPER_REQ_GET_GEOM \" +\n                        \"command: \" + e.toString(), e);\n        }\n    }\n",
    "130955": "    public void getScanProperties () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LASER_REQ_GET_CONFIG, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Laser] : Couldn't request PLAYER_LASER_REQ_GET_CONFIG: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130958": "    public void setPower (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LASER_REQ_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)value);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Laser] : Couldn't request PLAYER_LASER_REQ_POWER: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Laser] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130961": "    public boolean isDataReady () {\n        if (readyPgdata) {\n            readyPgdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130962": "    public boolean isGeomReady () {\n        if (readyPggeom) {\n            readyPggeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130965": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_POSITION2D_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position2D] : Couldn't request \" +\n                        \"PLAYER_POSITION2D_REQ_GET_GEOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130969": "    public void getWaypoints () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLANNER_REQ_GET_WAYPOINTS, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Planner] : Couldn't request \" + \"\" +\n                        \"PLAYER_PLANNER_REQ_GET_WAYPOINTS: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130971": "    public void setRobotMotion (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PLANNER_REQ_ENABLE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Planner] : Couldn't request PLAYER_PLANNER_REQ_ENABLE: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Planner] : Error while XDR-encoding ENABLE request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130976": "    public boolean isReadyPlgeom () {\n        if (readyPlgeom) {\n            readyPlgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130980": "    public boolean isReadyPlconfig () {\n        if (readyPlconfig) {\n            readyPlconfig = false;\n            return true;\n        }\n        return false;\n    }\n",
    "130981": "    public void resetOdometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_POSITION2D_REQ_RESET_ODOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position2D] : Couldn't request \" +\n                        \"PLAYER_POSITION2D_RESET_ODOM_REQ: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "130983": "    public void setControlMode (byte type) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_IMU_REQ_SET_DATATYPE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte (type);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[IMU] : Couldn't request PLAYER_IMU_REQ_SET_DATATYPE: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[IMU] : Error while XDR-encoding SET_DATATYPE \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "130985": "    public void resetOrientation (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_IMU_REQ_RESET_ORIENTATION, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (value);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[IMU] : Couldn't request PLAYER_IMU_REQ_RESET_ORIENTATION: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[IMU] : Error while XDR-encoding RESET_ORIENTATION \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "130988": "    protected void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_IMU_REQ_SET_DATATYPE: {\n                // null response\n                break;\n            }\n            case PLAYER_IMU_REQ_RESET_ORIENTATION: {\n                // null response\n                break;\n            }\n            default:{\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[IMU][Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "130995": "    public boolean isStateReady () {\n        if (readyPIMUState) {\n            readyPIMUState = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131002": "    public boolean isCalibReady () {\n        if (readyPIMUCalib) {\n            readyPIMUCalib = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131003": "    private PlayerDevice getRequestedDevice (int interf, int index) {\n        while (!readyRequestDevice);\n        PlayerDevAddr pda = newpd.getDeviceAddress ();\n        if ((pda.getInterf () == interf) && (pda.getIndex () == index))\n            return newpd;\n        else\n            return null;\n    }\n",
    "131009": "    public boolean isQuatReady () {\n        if (readyPIMUQuat) {\n            readyPIMUQuat = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131014": "    private short read () {\n        return read (0, 0);\n    }\n",
    "131015": "    public boolean isEulerReady () {\n        if (readyPIMUEuler) {\n            readyPIMUEuler = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131024": "    public boolean isFullStateReady () {\n        if (readyPIMUFull) {\n            readyPIMUFull = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131033": "    public boolean isDataReady () {\n        if (readyPp2ddata) {\n            readyPp2ddata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131039": "    public boolean isGeomReady () {\n        if (readyPp2dgeom) {\n            readyPp2dgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131041": "    public void homeCmd (int joint) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_ACTARRAY_CMD_HOME, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte  ((byte)joint);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Actarray] : Couldn't send homing command: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Actarray] : Error while XDR-encoding homing command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131043": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_ACTARRAY_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Actarray] : Couldn't request PLAYER_ACTARRAY_REQ_GET_GEOM: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "131046": "    public void setPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_ACTARRAY_REQ_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Actarray] : Couldn't request PLAYER_ACTARRAY_REQ_POWER: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Actarray] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131047": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_GET_GEOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request GET_GEOM: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "131048": "    public void setBrakes (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_ACTARRAY_REQ_BRAKES, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Actarray] : Couldn't request PLAYER_ACTARRAY_REQ_BRAKES: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Actarray] : Error while XDR-encoding BRAKES request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131051": "    public void setMotorPower (int state) {\n        try {\n            sendHeader\n                (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_MOTOR_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request MOTOR_POWER: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Position1D] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131053": "    public int readAll () {\n        if (isThreaded) return 0;\n        if (this.datamode == PLAYER_DATAMODE_PULL) {\n            requestData ();\n            while (read () != PLAYER_MSGTYPE_SYNCH);\n            return PLAYER_MSGTYPE_SYNCH;\n        }\n\n        int type = 0;\n//        try {\n/*            long start = System.currentTimeMillis ();\n            while (is.available () == 0) {\n                if (System.currentTimeMillis () > (start + timeout)) break;\n            }\n            while (is.available () != 0) {*/\n                type = read ();\n//                if (type == PLAYER_MSGTYPE_SYNCH) break;\n//            }\n/*        } catch (IOException e) {\n            throw new PlayerException\n            (\"[PlayerClient]: Error reading data: \" +\n                    e.toString (), e);\n        }*/\n        return type;\n    }\n",
    "131055": "    public void setVelocityControl (int mode) {\n        try {\n            sendHeader\n                (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_VELOCITY_MODE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (mode);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request VELOCITY_MODE: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Position1D] : Error while XDR-encoding VELOCITY_MODE \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "131057": "    public void resetOdometry () {\n        try {\n            sendHeader\n                (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_RESET_ODOM, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request RESET_ODOM: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131061": "    public void setControlMode (int state) {\n        try {\n            sendHeader\n                (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_POSITION_MODE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request POSITION_MODE: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Position1D] : Error while XDR-encoding POSITION_MODE \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "131063": "    private void readDataDevice (PlayerMsgHdr header) {\n        PlayerDevAddr devAddr = header.getAddr ();\n\n        for (int i = 0; i < deviceList.size (); i++) {\n            PlayerDevAddr currAddr = ((PlayerDevice)deviceList.get (i)).getDeviceAddress ();\n            if ( currAddr.getHost   () == devAddr.getHost   () &&\n                 currAddr.getIndex  () == devAddr.getIndex  () &&\n                 currAddr.getInterf () == devAddr.getInterf () &&\n                 currAddr.getRobot  () == devAddr.getRobot  ()\n               ) {\n                ((PlayerDevice)deviceList.get (i)).readData (header);\n                break;\n            }\n        }\n    }\n",
    "131064": "    public boolean isGeomReady () {\n        if (readyPageom) {\n            readyPageom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131067": "    public void setOdometry (float pos) {\n        try {\n            sendHeader\n                (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_SET_ODOM, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeFloat (pos);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request SET_ODOM: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Position1D] : Error while XDR-encoding SET_ODOM \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "131070": "    public boolean isWaveformDataReady () {\n        if (readyPaWavData) {\n            readyPaWavData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131073": "    public void resetOdometry (int value) {\n        try {\n            sendHeader\n                (PLAYER_MSGTYPE_REQ, PLAYER_POSITION1D_REQ_SET_ODOM, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (value);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Position1D] : Couldn't request RESET_ODOM: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Position1D] : Error while XDR-encoding RESET_ODOM \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "131074": "    public void setDataType (int value) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_WSN_REQ_DATATYPE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)value);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[WSN] : Couldn't request PLAYER_WSN_REQ_DATATYPE\" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[WSN] : Error while XDR-encoding DATATYPE \" +\n                        \"request: \" + e.toString(), e);\n        }\n    }\n",
    "131076": "    private void handleRequestsDevice (PlayerMsgHdr header) {\n        PlayerDevAddr devAddr = header.getAddr ();\n\n        for (int i = 0; i < deviceList.size (); i++) {\n            PlayerDevAddr currAddr = ((PlayerDevice)deviceList.get (i)).getDeviceAddress ();\n            if ( currAddr.getHost   () == devAddr.getHost   () &&\n                 currAddr.getIndex  () == devAddr.getIndex  () &&\n                 currAddr.getInterf () == devAddr.getInterf () &&\n                 currAddr.getRobot  () == devAddr.getRobot  ()\n               ) {\n                ((PlayerDevice)deviceList.get (i)).handleResponse (header);\n                break;\n            }\n\n        }\n    }\n",
    "131079": "    public void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_WSN_REQ_POWER: {\n                // null response\n                break;\n            }\n            case PLAYER_WSN_REQ_DATATYPE: {\n                // null response\n                break;\n            }\n            case PLAYER_WSN_REQ_DATAFREQ: {\n                // null response\n                break;\n            }\n            default: {\n                if (isDebugging)\n                    logger.log (Level.FINEST, \"[WSN][Debug] : \" +\n                            \"Unexpected response \" + header.getSubtype () +\n                            \" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "131080": "    public boolean isSampleDataReady () {\n        if (readyPaSmpData) {\n            readyPaSmpData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131086": "    public boolean isDataReady () {\n        if (readyPidata) {\n            readyPidata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131087": "    public boolean isPoseReady () {\n        if (readyPipose) {\n            readyPipose = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131088": "    public void queryPose () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_IR_REQ_POSE, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[IR] : Couldn't send PLAYER_IR_POSE command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131089": "    public boolean isSequenceDataReady () {\n        if (readyPaSeqData) {\n            readyPaSeqData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131092": "    public void setIRPower (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_IR_REQ_POWER, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeByte ((byte)state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[IR] : Couldn't send PLAYER_IR_POWER_REQ request: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[IR] : Error while XDR-encoding POWER request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131099": "    public void Push (int type, String channel, char[] dataT) {\n//        sendConfigReq (PLAYER_MCOM_PUSH, type, channel, true, dataT);\n    }\n",
    "131100": "    public boolean isChannelsDataReady () {\n        if (readyPaMclData) {\n            readyPaMclData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131103": "    public void Read (int type, String channel) {\n//        char[] dataT = new char[MCOM_DATA_LEN];\n//        sendConfigReq (PLAYER_MCOM_READ, type, channel, false, dataT);\n    }\n",
    "131104": "    public void Clear (int type, String channel) {\n//        char[] dataT = new char[MCOM_DATA_LEN];\n//        sendConfigReq (PLAYER_MCOM_CLEAR, type, channel, false, dataT);\n    }\n",
    "131107": "    public void setCapacity (int type, String channel, char capacity) {\n        char[] dataT = new char[MCOM_DATA_LEN];\n        dataT[0] = capacity;\n//        sendConfigReq (PLAYER_MCOM_SET_CAPACITY, type, channel, false, dataT);\n    }\n",
    "131110": "    public boolean isDetailsDataReady () {\n        if (readyPaMcdData) {\n            readyPaMcdData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131112": "    public boolean isDataReady () {\n        if (readyPmdata) {\n            readyPmdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131117": "    public void queryParticles () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LOCALIZE_REQ_GET_PARTICLES, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Localize] : Couldn't request \" +\n                        \"PLAYER_LOCALIZE_REQ_GET_PARTICLES: \"\n                        + e.toString(), e);\n        }\n    }\n",
    "131118": "    public boolean isDataReady () {\n        if (readyPp1ddata) {\n            readyPp1ddata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131119": "    public boolean isStateDataReady () {\n        if (readyPaSttData) {\n            readyPaSttData = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131124": "    public boolean isGeomReady () {\n        if (readyPp1dgeom) {\n            readyPp1dgeom = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131129": "    public boolean isDataReady () {\n        if (readyPsrdata) {\n            readyPsrdata = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131130": "    public void recordWavStream (int state) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_AUDIO_CMD_WAV_STREAM_REC, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (state);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Audio] : Couldn't send command: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n            (\"[Audio] : Error while XDR-encoding command: \" +\n                    e.toString(), e);\n        }\n    }\n",
    "131132": "    public boolean isParticleDataReady () {\n        if (readyPlgp) {\n            readyPlgp = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131139": "    public void playSample (int index) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_AUDIO_CMD_SAMPLE_PLAY, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (index);\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Audio] : Couldn't send command: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Audio] : Error while XDR-encoding command: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131140": "    public boolean isReadyPDDList () {\n        if (readyPDDList) {\n            readyPDDList = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131182": "    public boolean isReadyPDDI () {\n        if (readyPDDI) {\n            readyPDDI = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131190": "    public void recordWaveform () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_AUDIO_REQ_WAV_REC, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Audio] : Couldn't send request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131208": "    public void retrieveSample (int index) {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_AUDIO_REQ_SAMPLE_RETRIEVE, 4);\n            XdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n            xdr.beginEncoding (null, 0);\n            xdr.xdrEncodeInt (index);  // sample index\n            xdr.endEncoding ();\n            os.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n            xdr.close ();\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Audio] : Couldn't send request: \" +\n                        e.toString(), e);\n        } catch (OncRpcException e) {\n            throw new PlayerException\n                (\"[Audio] : Error while XDR-encoding request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131225": "    public void getMixerDetails () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_AUDIO_REQ_MIXER_CHANNEL_LIST, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException\n                (\"[Audio] : Couldn't send request: \" +\n                        e.toString(), e);\n        }\n    }\n",
    "131273": "    public void setAutoServo (int mode) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_PTZ_REQ_AUTOSERVO, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeInt (mode);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Ptz] : Couldn't request PLAYER_PTZ_AUTOSERVO: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Ptz] : Error while XDR-encoding AUTOSERVO request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131277": "    public boolean isReadyRequestDevice () {\n        if (readyRequestDevice) {\n            readyRequestDevice = false;\n            return true;\n        }\n        return false;\n    }\n",
    "131283": "    public PIController (float Kp, float Ki) {\n    \tthis.kp = Kp;\n        this.ki = Ki;\n    }\n",
    "131285": "    public float getCommand (float currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        float Pgain = this.kp * currE;\n        float Igain = this.ki * eSum;\n        \n        return Pgain + Igain;\n    }\n",
    "131286": "    public float getKp () {\n        return this.kp;\n    }\n",
    "131287": "    public void setKp (float newKp) {\n        this.kp = newKp;\n    }\n",
    "131289": "    public float getKi () {\n        return this.ki;\n    }\n",
    "131291": "    public void setKi (float newKi) {\n        this.ki = newKi;\n    }\n",
    "131292": "    public void setGoal (float newGoal) {\n        this.goal = newGoal;\n    }\n",
    "131293": "    protected float deltaE () {\n        return (currE - lastE);\n    }\n",
    "131294": "    public PDController (float Kp, float Kd) {\n    \tthis.kp = Kp;\n        this.kd = Kd;\n    }\n",
    "131295": "    public float getCommand (float currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        float Pgain = this.kp * currE;\n        float Dgain = this.kd * deltaE ();\n        \n        return Pgain + Dgain;\n    }\n",
    "131300": "    public float getKd () {\n        return this.kd;\n    }\n",
    "131301": "    public PowerInterface requestInterfacePower (int index, int access) {\n        return (PowerInterface)\n            requestInterface (PLAYER_POWER_CODE, index, access);\n    }\n",
    "131302": "    public void setKd (float newKd) {\n        this.kd = newKd;\n    }\n",
    "131303": "    public PIDController (float Kp, float Ki, float Kd) {\n    \tthis.kp = Kp;\n        this.ki = Ki;\n        this.kd = Kd;\n    }\n",
    "131304": "\tpublic void setMinimumCommand (float minC) {\n\t\tthis.minCommand = minC; \n\t}\n",
    "131305": "    public float getCommand (float currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        float Pgain = this.kp * currE;\n        float Igain = this.ki * eSum;\n        float Dgain = this.kd * deltaE ();\n        \n        return Pgain + Igain + Dgain;\n    }\n",
    "131307": "\tpublic void setMaximumCommand (float maxC) {\n\t\tthis.maxCommand = maxC; \n\t}\n",
    "131314": "\tpublic void setAllowedError (float err) {\n\t\tthis.maxError = err;\n\t}\n",
    "131316": "\tpublic float getCommand (float currentOutput) {\n\t\tthis.currE = this.goal - currentOutput;\n\t\t\n\t\t/* Angle adjustments */\n\t\tif (currE  <= -180 )\n\t\t\tcurrE =  360 + currE;\n\t\telse \n\t\t\tif(currE >= 180  && currE <= 360)\n\t\t\t\tcurrE = currE - 360;\n\t\t\telse \n\t\t\t\tif(currE > 360)\n\t\t\t\t\tcurrE = currE - 360;\n\t\t\n\t\teSum += currE;\n\t\t\n\t\tlastE = currE;\n\t\t\n\t\tfloat Pgain = this.Kp * currE;\n\t\tfloat Igain = this.Ki * eSum;\n\t\tfloat Dgain = this.Kd * deltaE ();\n\t\t\n\t\treturn Pgain + Igain + Dgain;\n\t}\n",
    "131320": "\tprivate float boundCommand (float command) {\n\t\tif (command == 0)\n\t\t\treturn 0;\n\t\tif (command < 0) {\n\t\t\tif (command > -minCommand)\n\t\t\t\tcommand = -minCommand;\n\t\t\tif (command < -maxCommand)\n\t\t\t\tcommand = -maxCommand;\n\t\t}\n\t\telse {\n\t\t\tif (command < minCommand)\n\t\t\t\tcommand = minCommand;\n\t\t\tif (command > maxCommand)\n\t\t\t\tcommand = maxCommand;\n\t\t}\n\t\treturn command;\n\t}\n",
    "131321": "    public PController (float Kp) {\n    \tthis.kp = Kp;\n    }\n",
    "131322": "    public float getCommand (float currentOutput) {\n    \tthis.currE = this.goal - currentOutput;\n        eSum += currE;\n        \n        lastE = currE;\n        float Pgain = this.kp * currE;\n        \n        return Pgain;\n    }\n",
    "131325": "\tprivate float transformAngle (float angle) {\n\t\tangle = angle % 360;\n\t\tif (angle < 0)\n\t\t\tangle = 360 + angle;\n\t\treturn angle;\n\t}\n",
    "131333": "\tpublic boolean setHeading (float angle) {\n\t\t/* get the current heading */\n\t\tfloat currentAngle =  transformAngle (device.getYaw ());\n\t\t\n\t\t/* difference between the current heading and the goal heading */\n\t\tfloat deltaAngle   = (angle - currentAngle);\n\t\t\n\t\tif (deltaAngle != 0) {\n\t\t\tif (deltaAngle <= 180 && deltaAngle > 0) \n\t\t\t\treturn setDiffHeading (deltaAngle);\n\t\t\telse \n\t\t\t\tif (deltaAngle > -180)\n\t\t\t\t\treturn setDiffHeading (-360 + deltaAngle);\n\t\t\t\telse\n\t\t\t\t\treturn setDiffHeading (360 + deltaAngle);\n\t\t}\n\t\treturn true;\n\t}\n",
    "131334": "    public GripperInterface requestInterfaceGripper (int index, int access) {\n        return (GripperInterface)\n            requestInterface (PLAYER_GRIPPER_CODE, index, access);\n    }\n",
    "131342": "    public void queryWifiMac () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_WIFI_MAC, 0);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException \n            \t(\"[Wifi] : Couldn't request PLAYER_WIFI_MAC: \" + \n            \t\t\te.toString (), e);\n        }\n    }\n",
    "131344": "    public void queryWifiIwspyAddrAdd () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_WIFI_IWSPY_ADD, 32*4);\n            os.flush ();\n        } catch (IOException e) {\n            throw new PlayerException \n            \t(\"[Wifi] : Couldn't request PLAYER_WIFI_IWSPY_ADD: \" + \n            \t\t\te.toString (), e);\n        }\n    }\n",
    "131346": "    public void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_WIFI_MAC: {\n        \t    break;\n            }\n            default:{\n            \tif (isDebugging)\n            \t\tlogger.log (Level.FINEST, \"[Wifi][Debug] : \" +\n            \t\t\t\t\"Unexpected response \" + header.getSubtype () + \n            \t\t\t\t\" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "131360": "    public Position2DInterface requestInterfacePosition2D (int index, int access) {\n        return (Position2DInterface)\n            requestInterface (PLAYER_POSITION2D_CODE, index, access);\n    }\n",
    "131390": "    public SonarInterface requestInterfaceSonar (int index, int access) {\n        return (SonarInterface)\n            requestInterface (PLAYER_SONAR_CODE, index, access);\n    }\n",
    "131401": "    public LaserInterface requestInterfaceLaser (int index, int access) {\n        return (LaserInterface)\n            requestInterface (PLAYER_LASER_CODE, index, access);\n    }\n",
    "131402": "    public void homeCmd () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_LIMB_HOME_CMD, 0);\n            os.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Couldn't send homing command: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131404": "    public void stopCmd () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_CMD, PLAYER_LIMB_STOP_CMD, 0);\n            os.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Couldn't send stop command: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131411": "    public void setPower (int value) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_POWER_REQ, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeByte ((byte)value);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Couldn't request PLAYER_LIMB_POWER_REQ: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Error while XDR-encoding POWER request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131412": "    public BlobfinderInterface requestInterfaceBlobfinder (int index, int access) {\n        return (BlobfinderInterface)\n            requestInterface (PLAYER_BLOBFINDER_CODE, index, access);\n    }\n",
    "131413": "    public void setBrakes (int value) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_BRAKES_REQ, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeByte ((byte)value);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Couldn't request PLAYER_LIMB_BRAKES_REQ: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Error while XDR-encoding BRAKES request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131416": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_GEOM_REQ, 0);\n            os.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Couldn't request PLAYER_LIMB_GEOM_REQ: \"\n        \t\t\t\t+ e.toString(), e);\n        }\n    }\n",
    "131417": "    public void setSpeed (float speed) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_LIMB_SPEED_REQ, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeFloat (speed);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Couldn't request PLAYER_LIMB_SPEED_REQ: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Limb] : Error while XDR-encoding SPEED request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131423": "    public PtzInterface requestInterfacePtz (int index, int access) {\n        return (PtzInterface)\n            requestInterface (PLAYER_PTZ_CODE, index, access);\n    }\n",
    "131435": "    public AudioInterface requestInterfaceAudio (int index, int access) {\n        return (AudioInterface)\n            requestInterface (PLAYER_AUDIO_CODE, index, access);\n    }\n",
    "131454": "    public FiducialInterface requestInterfaceFiducial (int index, int access) {\n        return (FiducialInterface)\n            requestInterface (PLAYER_FIDUCIAL_CODE, index, access);\n    }\n",
    "131471": "    public SpeechInterface requestInterfaceSpeech (int index, int access) {\n        return (SpeechInterface)\n            requestInterface (PLAYER_SPEECH_CODE, index, access);\n    }\n",
    "131474": "    public void queryGeometry () {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_BUMPER_GET_GEOM, 0);\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Bumper] : Couldn't request PLAYER_BUMPER_GET_GEOM: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131476": "    public void handleResponse (PlayerMsgHdr header) {\n        switch (header.getSubtype ()) {\n            case PLAYER_BUMPER_GET_GEOM: {\n            \treadGeom ();\n        \t    break;\n            }\n            default:{\n            \tif (isDebugging)\n            \t\tlogger.log (Level.FINEST, \"[Bumper]Debug] : \" +\n            \t\t\t\t\"Unexpected response \" + header.getSubtype () + \n            \t\t\t\t\" of size = \" + header.getSize ());\n                break;\n            }\n        }\n    }\n",
    "131485": "    public GPSInterface requestInterfaceGPS (int index, int access) {\n        return (GPSInterface)requestInterface (PLAYER_GPS_CODE, index, access);\n    }\n",
    "131496": "    public BumperInterface requestInterfaceBumper (int index, int access) {\n        return (BumperInterface)\n            requestInterface (PLAYER_BUMPER_CODE, index, access);\n    }\n",
    "131506": "    public DIOInterface requestInterfaceDIO (int index, int access) {\n        return (DIOInterface)requestInterface (PLAYER_DIO_CODE, index, access);\n    }\n",
    "131521": "    public AIOInterface requestInterfaceAIO (int index, int access) {\n        return (AIOInterface)requestInterface (PLAYER_AIO_CODE, index, access);\n    }\n",
    "131534": "    public IRInterface requestInterfaceIR (int index, int access) {\n        return (IRInterface)requestInterface (PLAYER_IR_CODE, index, access);\n    }\n",
    "131548": "    public WiFiInterface requestInterfaceWiFi (int index, int access) {\n        return (WiFiInterface)requestInterface (PLAYER_WIFI_CODE, index, access);\n    }\n",
    "131564": "    public WaveformInterface requestInterfaceWaveform (int index, int access) {\n        return (WaveformInterface)\n            requestInterface (PLAYER_WAVEFORM_CODE, index, access);\n    }\n",
    "131573": "    public void homeCmd (int joint) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_CMD, PLAYER_ACTARRAY_HOME_CMD, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeByte  ((byte)joint);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Couldn't send homing command: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Error while XDR-encoding homing command: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131575": "    public LocalizeInterface requestInterfaceLocalize (int index, int access) {\n        return (LocalizeInterface)\n            requestInterface (PLAYER_LOCALIZE_CODE, index, access);\n    }\n",
    "131576": "    public void queryGeometry () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_ACTARRAY_GET_GEOM_REQ, 0);\n            os.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Couldn't request PLAYER_ACTARRAY_GET_GEOM_REQ: \"\n        \t\t\t\t+ e.toString(), e);\n        }\n    }\n",
    "131578": "    public void setPower (int state) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_ACTARRAY_POWER_REQ, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeByte ((byte)state);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Couldn't request PLAYER_ACTARRAY_POWER_REQ: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Error while XDR-encoding POWER request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131580": "    public void setBrakes (int state) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_ACTARRAY_BRAKES_REQ, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeByte ((byte)state);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Couldn't request PLAYER_ACTARRAY_BRAKES_REQ: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[Actarray] : Error while XDR-encoding BRAKES request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131588": "    public MComInterface requestInterfaceMCom (int index, int access) {\n        return (MComInterface)\n            requestInterface (PLAYER_MCOM_CODE, index, access);\n    }\n",
    "131601": "    public SoundInterface requestInterfaceSound (int index, int access) {\n        return (SoundInterface)\n            requestInterface (PLAYER_SOUND_CODE, index, access);\n    }\n",
    "131615": "    public void queryPose () {\n        try {\n            sendHeader (PLAYER_MSGTYPE_REQ, PLAYER_IR_POSE, 0);\n            os.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[IR] : Couldn't send PLAYER_IR_POSE command: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131616": "    public AudioDSPInterface requestInterfaceAudioDSP (int index, int access) {\n        return (AudioDSPInterface)\n            requestInterface (PLAYER_AUDIODSP_CODE, index, access);\n    }\n",
    "131618": "    public void setIRPower (int state) {\n        try {\n        \tsendHeader (PLAYER_MSGTYPE_REQ, PLAYER_IR_POWER, 4);\n        \tXdrBufferEncodingStream xdr = new XdrBufferEncodingStream (4);\n        \txdr.beginEncoding (null, 0);\n        \txdr.xdrEncodeByte ((byte)state);\n        \txdr.endEncoding ();\n        \tos.write (xdr.getXdrData (), 0, xdr.getXdrLength ());\n        \txdr.close ();\n        \tos.flush ();\n        } catch (IOException e) {\n        \tthrow new PlayerException \n        \t\t(\"[IR] : Couldn't send PLAYER_IR_POWER_REQ request: \" + \n        \t\t\t\te.toString(), e);\n        } catch (OncRpcException e) {\n        \tthrow new PlayerException \n        \t\t(\"[IR] : Error while XDR-encoding POWER request: \" + \n        \t\t\t\te.toString(), e);\n        }\n    }\n",
    "131631": "    public AudioMixerInterface requestInterfaceAudioMixer (int index, int access) {\n        return (AudioMixerInterface)\n            requestInterface (PLAYER_AUDIOMIXER_CODE, index, access);\n    }\n",
    "131659": "    public Position3DInterface requestInterfacePosition3D (int index, int access) {\n        return (Position3DInterface)\n            requestInterface (PLAYER_POSITION3D_CODE, index, access);\n    }\n",
    "131688": "  public boolean hasParent() {\n    return (parent != null);\n  }\n",
    "131692": "  public boolean detatch() {\n    if (parent == null) {\n      return false;\n    }\n\n    parent.removeChild(this);\n    parent = null;\n    return true;\n  }\n",
    "131710": "    public SimulationInterface requestInterfaceSimulation (int index, int access) {\n        return (SimulationInterface)\n            requestInterface (PLAYER_SIMULATION_CODE, index, access);\n    }\n",
    "131731": "  public OutgoingConnection openConnection(AddressPortPair app, long timeout) {\n    return tcpService.openConnection(app, timeout);\n  }\n",
    "131733": "  public ASyncTcpListener getListener() {\n    return tcpService.getListener();\n  }\n",
    "131734": "  public ASyncTcpListener setListener(ASyncTcpListener tcpListener) {\n    return tcpService.setListener(tcpListener);\n  }\n",
    "131736": "  public int getPortNumber() {\n    return tcpService.getPortNumber();\n  }\n",
    "131739": "  public ASyncTcp getASyncTCP() {\n    return atcp;\n  }\n",
    "131741": "  public boolean copyParams(ASyncTcpParams otherParams) {\n    if (!isRunning) {\n      sendBufferSize = otherParams.sendBufferSize;\n      receiveBufferSize = otherParams.receiveBufferSize;\n      return true;\n    }\n    return false;\n  }\n",
    "131744": "  public int getSendBufferSize() {\n    return sendBufferSize;\n  }\n",
    "131746": "  public boolean setSendBufferSize(int sendBufferSize) {\n    if (!isRunning) {\n      this.sendBufferSize = sendBufferSize;\n      return true;\n    }\n    return false;\n  }\n",
    "131748": "    public BlinkenlightInterface requestInterfaceBlinkenlight (int index, int access) {\n        return (BlinkenlightInterface)\n            requestInterface (PLAYER_BLINKENLIGHT_CODE, index, access);\n    }\n",
    "131749": "  public int getReceiveBufferSize() {\n    return receiveBufferSize;\n  }\n",
    "131751": "  public boolean setRecvBufferSize(int receiveBufferSize) {\n    if (!isRunning) {\n      this.receiveBufferSize = receiveBufferSize;\n      return true;\n    }\n    return false;\n  }\n",
    "131756": "  public int getCapacity() {\n    return capacity;\n  }\n",
    "131758": "  public void setCapacity(int new_capacity) {\n    capacity = (new_capacity < 0) ? -1 : new_capacity;\n  }\n",
    "131760": "  public boolean isFull() {\n    return ((capacity != -1) && (enqueuedMessages.size() >= capacity));\n  }\n",
    "131768": "  public AddressPortPair getRemoteHost() {\n    return app;\n  }\n",
    "131771": "  public Object attach(Object obj) {\n    Object prev_attachment = attachment;\n    attachment = obj;\n    return prev_attachment;\n  }\n",
    "131774": "  public Object attachment() {\n    return attachment;\n  }\n",
    "131776": "  public ASyncTcpParams getParams() {\n    return tcpService.getParams();\n  }\n",
    "131777": "  public ConnectionState getConnectionState() {\n    return connectionState;\n  }\n",
    "131778": "    public CameraInterface requestInterfaceCamera (int index, int access) {\n        return (CameraInterface)\n            requestInterface (PLAYER_CAMERA_CODE, index, access);\n    }\n",
    "131781": "  public ConnectionState disconnect() {\n    if ((connectionState == ConnectionState.DISCONNECTING)\n        || (connectionState == ConnectionState.DISCONNECTED)) {\n      // already disconnecting or disconnected, so return immediately\n      return connectionState;\n    }\n\n    if ((messageQueue.sendingMessage == null)\n        && messageQueue.enqueuedMessages.isEmpty()) {\n      // nothing sending or enqueued, can immediately disconnect\n      provider.removeChannel(channel);\n      try {\n        channel.close();\n      } catch (IOException e) {\n      }\n      // change state to disconnected and remove from connection list\n      connectionState = ConnectionState.DISCONNECTED;\n      removeConnection();\n    } else {\n      // still have data to send, enter disconnecting state\n      connectionState = ConnectionState.DISCONNECTING;\n    }\n    return connectionState;\n  }\n",
    "131783": "  public ASyncTcpMessageQueue getMessageQueue() {\n    return messageQueue;\n  }\n",
    "131786": "  public ConnectionListener getListener() {\n    return connectionListener;\n  }\n",
    "131788": "  public ConnectionListener setListener(ConnectionListener _cl) {\n    ConnectionListener prev_cl = connectionListener;\n    connectionListener = _cl;\n    return prev_cl;\n  }\n",
    "131795": "    public MapInterface requestInterfaceMap (int index, int access) {\n        return (MapInterface)requestInterface (PLAYER_MAP_CODE, index, access);\n    }\n",
    "131814": "  public InetAddress getAddress() {\n    return address;\n  }\n",
    "131818": "    public PlannerInterface requestInterfacePlanner (int index, int access) {\n        return (PlannerInterface)\n            requestInterface (PLAYER_PLANNER_CODE, index, access);\n    }\n",
    "131834": "  public ASyncUdp getASyncUDP() {\n    return audp;\n  }\n",
    "131836": "  public boolean copyParams(ASyncUdpParams otherParams) {\n    if (!isRunning) {\n      maxSegmentSize = otherParams.maxSegmentSize;\n      receiveBufferSize = otherParams.receiveBufferSize;\n      return true;\n    }\n    return false;\n  }\n",
    "131837": "  public AddressPortPair getDestination() {\n    return dst;\n  }\n",
    "131845": "  public boolean setReceiveBufferSize(int receiveBufferSize) {\n    if (!isRunning) {\n      this.receiveBufferSize = receiveBufferSize;\n      return true;\n    }\n    return false;\n  }\n",
    "131849": "  public ASyncService getService() {\n    return udpService;\n  }\n",
    "131851": "  public QueueManager getQueueManager() {\n    return queueManager;\n  }\n",
    "131854": "  public ASyncUdpParams getParams() {\n    return udpService.getParams();\n  }\n",
    "131855": "    public LogInterface requestInterfaceLog (int index, int access) {\n        return (LogInterface)requestInterface (PLAYER_LOG_CODE, index, access);\n    }\n",
    "131870": "  public ASyncUdpMessageHandle enqueue(Message message, AddressPortPair app) {\n    return udpService.enqueue(message, app);\n  }\n",
    "131872": "  public ASyncUdpMessageQueue getMessageQueue(AddressPortPair app) {\n    return udpService.getMessageQueue(app);\n  }\n",
    "131873": "  public ASyncUdpListener getListener() {\n    return udpService.getListener();\n  }\n",
    "131874": "  public ASyncUdpListener setListener(ASyncUdpListener udpListener) {\n    return udpService.setListener(udpListener);\n  }\n",
    "131875": "  public int getPortNumber() {\n    return udpService.getPortNumber();\n  }\n",
    "131880": "    public JoystickInterface requestInterfaceJoystick (int index, int access) {\n        return (JoystickInterface)requestInterface\n            (PLAYER_JOYSTICK_CODE, index, access);\n    }\n",
    "131916": "    public OpaqueInterface requestInterfaceOpaque (int index, int access) {\n        return (OpaqueInterface)\n            requestInterface (PLAYER_OPAQUE_CODE, index, access);\n    }\n",
    "131928": "    public Position1DInterface requestInterfacePosition1D (int index, int access) {\n        return (Position1DInterface)\n            requestInterface (PLAYER_POSITION1D_CODE, index, access);\n    }\n",
    "131943": "    public ActarrayInterface requestInterfaceActarray (int index, int access) {\n        return (ActarrayInterface)\n            requestInterface (PLAYER_ACTARRAY_CODE, index, access);\n    }\n",
    "131954": "    public LimbInterface requestInterfaceLimb (int index, int access) {\n        return (LimbInterface)requestInterface (PLAYER_LIMB_CODE, index, access);\n    }\n",
    "131964": "    public Graphics2DInterface requestInterfaceGraphics2D (int index, int access) {\n        return (Graphics2DInterface)\n            requestInterface (PLAYER_GRAPHICS2D_CODE, index, access);\n    }\n",
    "131979": "    public Graphics3DInterface requestInterfaceGraphics3D (int index, int access) {\n        return (Graphics3DInterface)\n            requestInterface (PLAYER_GRAPHICS3D_CODE, index, access);\n    }\n",
    "131992": "    public RFIDInterface requestInterfaceRFID (int index, int access) {\n        return (RFIDInterface)requestInterface (PLAYER_RFID_CODE, index, access);\n    }\n",
    "132008": "    public WSNInterface requestInterfaceWSN (int index, int access) {\n        return (WSNInterface)requestInterface (PLAYER_WSN_CODE, index, access);\n    }\n",
    "132039": "    public HealthInterface requestInterfaceHealth (int index, int access) {\n        return (HealthInterface)requestInterface (PLAYER_HEALTH_CODE, index, access);\n    }\n",
    "132091": "\tprivate void createPage(ServiceReference<IGBService> igbServiceReference) {\n        try\n        {\n        \tIGBService igbService = bundleContext.getService(igbServiceReference);\n        \tserviceRegistration = bundleContext.registerService(IGBTabPanel.class, getPage(igbService), null);\n        \tbundleContext.ungetService(igbServiceReference);\n        } catch (Exception ex) {\n            System.out.println(this.getClass().getName() + \" - Exception in Activator.createPage() -> \" + ex.getMessage());\n            ex.printStackTrace(System.out);\n        }\n\t}\n",
    "132097": "    public IMUInterface requestInterfaceIMU (int index, int access) {\n        return (IMUInterface)requestInterface (PLAYER_IMU_CODE, index, access);\n    }\n",
    "132115": "\tpublic Object importContent(Reader theInput) throws IOException {\n\t\tif (null == xmlParser) {\n\t\t\ttry {\n\t\t\t\txmlParser = SAXParserFactory.newInstance().newSAXParser().getXMLReader();\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\txmlParser.setContentHandler(this);\n\t\t\tmap.clearWidget();\n\t\t\txmlParser.parse(new InputSource(theInput));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn map;\n\t}\n",
    "132119": "\tpublic Object importContent(InputStream theInput) throws IOException {\n\t\treturn importContent(new InputStreamReader(theInput));\n\t}\n",
    "132127": "\tpublic void setWidget(NeoAbstractWidget theWidget) {\n\t\tSystem.out.println(\"setting widget\");\n\n\t\tif (theWidget instanceof NeoMap) {\n\t\t\tSystem.out.println(\"it's a map\");\n\n\t\t\tthis.map = (NeoMap) theWidget;\n\t\t\tthis.labelFactory = this.map.addFactory(\"-glyphtype LabelGlyph\");\n\t\t}\n\t}\n",
    "132131": "\tpublic void addMap(String theName, NeoMap theMap) {\n\t\tSystem.out.println(\"adding map type \" + theName);\n\t\tthis.maps.put(theName, theMap);\n\t}\n",
    "132142": "    public PointCloud3DInterface requestInterfacePointCloud3D (int index, int access) {\n        return (PointCloud3DInterface)requestInterface (PLAYER_POINTCLOUD3D_CODE, index, access);\n    }\n",
    "132160": "    public RangerInterface requestInterfaceRanger (int index, int access) {\n        return (RangerInterface)\n            requestInterface (PLAYER_RANGER_CODE, index, access);\n    }\n",
    "132168": "\tprivate void parseFile(File theFile) throws IOException {\n\t\tparseInputStream(new FileReader(theFile));\n\t}\n",
    "132180": "    public StereoInterface requestInterfaceStereo (int index, int access) {\n        return (StereoInterface)\n            requestInterface (PLAYER_STEREO_CODE, index, access);\n    }\n",
    "132199": "    public PlayerDevice requestInterface (int type, int index, int access) {\n//        if (isThreaded)\n//               isThreaded = false;\n//            Thread myc = Thread.currentThread ();\n//            myc.suspend();\n           return requestDeviceAccess (type, index, access);\n//           isThreaded = true;\n/*        if (isReadyRequestDevice ())\n            return newpd;\n        else\n            return null;*/\n           //return xnewpd;\n    }\n",
    "132322": "\tpublic void zoomFrameSetup() {\n\t\tzoomframe.setBackground(Color.white);\n\t\tzoomframe.setLayout(new BorderLayout());\n\t\tzoomframe.add(\"South\", (JScrollBar) xzoomer);\n\t\tzoomframe.add(\"North\", (JScrollBar) yzoomer);\n\t\tzoomframe.pack();\n\t\tzoomframe.setSize(200, zoomframe.getSize().height);\n\t}\n",
    "132336": "\n  public void mouseClicked(MouseEvent e) { }\n",
    "132356": "\tpublic void setScene(Scene scene) {\n\t\treturn;\n\t}\n",
    "132505": "\tpublic Sequence (String id) {\n\t\tthis.start = 0;\n\t\tsetID( id );\n\t}\n",
    "132515": "\tpublic void setStart(int theStart) {\n\t\tif ( theStart < 0 )\n\t\t\tthrow new IllegalArgumentException\n\t\t\t\t( \"theStart cannot be negative\" );\n\t\tthis.start = theStart;\n\t\tthis.end = this.start + this.length - 1;\n\t}\n",
    "132520": "\tpublic void setResidues ( String residues ) {\n\t\tif (residues != null) {\n\t\t\tthis.residues = new StringBuffer(residues);\n\t\t\tlength = residues.length();\n\t\t\tif (length == 0) {\n\t\t\t\tthis.end = this.start;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.end = this.start + this.length - 1;\n\t\t\t}\n\t\t}\n\t}\n",
    "132521": "\tpublic void setResidues ( StringBuffer resBuf ) {\n\t\tif (resBuf != null) {\n\t\t\tresidues = resBuf;\n\t\t}\n\t}\n",
    "132523": "\tpublic void appendResidue(char new_residue) {\n\t\tresidues.append(new_residue);\n\t\tlength++;\n\t}\n",
    "132524": "\tpublic void appendResidues(String new_residues) {\n\t\tresidues.append(new_residues);\n\t\tlength += new_residues.length();\n\t\tthis.end = this.start + this.length;\n\t}\n",
    "132527": "\tpublic void insertResidues(int start, String new_residues) {\n\t\tif (start >= residues.length()) {\n\t\t\tthrow new IllegalArgumentException(\"try appending instead\");\n\t\t}\n\t\telse {\n\t\t\tresidues.insert(start, new_residues);\n\t\t\tlength += new_residues.length();\n\t\t}\n\t}\n",
    "132530": "\tpublic Sequence loadSequence(String theRef) {\n\t\tSequence model = null;\n\t\ttry {\n\t\t\tURL seq_URL = new URL(this.getDocumentBase(), theRef);\n\t\t\tSystem.out.println(\"getting sequence from \" + seq_URL);\n\t\t\tFastaSequenceParser parser = new FastaSequenceParser();\n\t\t\tInputStream istream = seq_URL.openStream();\n\t\t\tBufferedInputStream bistream = new BufferedInputStream(istream);\n\t\t\tmodel = (Sequence)parser.importContent(istream);\n\t\t\tif ( null == model.getID() || model.getID().equals( \"\" ) )\n\t\t\t\tmodel.setID( \"NeoSeqDemo\" );\n\t\t\tbistream.close();\n\t\t\tistream.close();\n\t\t}\n\t\tcatch(Exception ex) {\n\t\t\tSystem.out.println(ex.getMessage());\n\t\t\tex.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"got \" + model );\n\t\treturn model;\n\t}\n",
    "132532": "\tpublic char getResidue (int n) {\n\t\tchar c = '\\000';\n\t\ttry {\n\t\t\tc = residues.charAt( n - this.start );\n\t\t} catch ( RuntimeException e ) {\n\t\t\t//System.err.println( \"getting residue \" + n );\n\t\t\t//System.err.println( \"start is at \" + this.start );\n\t\t\t//System.err.println( \"end is at \" + this.end );\n\t\t\t//System.err.println( \"length is \" + this.length );\n\t\t}\n\t\treturn c;\n\t}\n",
    "132551": "\tprotected void processSequenceEvent( SequenceEvent theEvent ) {\n\t\tif ( null != listeners ) {\n\t\t\tfor (SequenceListener l : listeners) {\n\t\t\t\tl.sequenceChanged( theEvent );\n\t\t\t\t\t}\n\t\t}\n\t}\n",
    "132552": "\tpublic void addSequenceListener( SequenceListener l ) {\n\t\tlisteners.add( l );\n\t}\n",
    "132555": "\tpublic void removeSequenceListener( SequenceListener l ) {\n\t\tlisteners.remove( l );\n\t}\n",
    "132566": "\tpublic void setOffset(int theValue) {\n\t\tif ( theValue == this.offset ) { // it was already thus.\n\t\t\treturn;\n\t\t}\n\t\tif ( theValue < 0 ) {\n\t\t\tthrow new IllegalArgumentException\n\t\t\t\t( \"Offsets must not be negative.\" );\n\t\t}\n\t\tthis.offset = theValue;\n\t\tnotifyListeners();\n\t}\n",
    "132578": "\tpublic void setOrientation(boolean forward) {\n\t\tif (forward) {\n\t\t\torientation = FORWARD;\n\t\t} else {\n\t\t\torientation = REVERSE;\n\t\t}\n\t}\n",
    "132591": "\tpublic void setPeaks() {\n\t\tpeak = new int[baseVector.size()];\n\t\tfor (int i = baseVector.size()-1; 0 <= i; i--) {\n\t\t\tBaseCall b = baseVector.get(i);\n\t\t\tpeak[i] = b.getTracePoint();\n\t\t\t//System.err.println(peak[i]);\n\t\t}\n\t}\n",
    "132592": "\tpublic int getPeak(int theIndex) {\n\t\tif (null == peak) {\n\t\t\tsetPeaks();\n\t\t}\n\t\treturn peak[theIndex];\n\t}\n",
    "132593": "\tpublic int getResidueIndexNear(int thePoint) {\n\t\tif (null == peak) {\n\t\t\tsetPeaks();\n\t\t}\n\t\tint candidate = Arrays.binarySearch(peak, thePoint);\n\t\tif (0 <= candidate) // exact match was found.\n\t\t\treturn candidate;\n\t\t// Exact match was not found.\n\t\tint j = -(candidate + 1), i = j - 1;\n\t\tif (i < 0) return j;\n\t\tif (peak.length <= j) return i;\n\t\tif (thePoint < (peak[i] + peak[j]) / 2) return i;\n\t\treturn j;\n\t}\n",
    "132594": "\tpublic BaseCall getBaseCall(int index) {\n\t\tif (index < 0 || baseVector.size()-1 < index) {\n\t\t\treturn null;\n\t\t}\n\t\treturn baseVector.get(index);\n\t}\n",
    "132605": "\tpublic void addSample(int sample_A, int sample_C, int sample_G, int sample_T){\n\n\t\tif (max_trace_value < sample_A) { max_trace_value = sample_A; }\n\t\tif (max_trace_value < sample_C) { max_trace_value = sample_C; }\n\t\tif (max_trace_value < sample_G) { max_trace_value = sample_G; }\n\t\tif (max_trace_value < sample_T) { max_trace_value = sample_T; }\n\n\t\tTraceSample sample = new TraceSample(sample_A,\n\t\t\t\tsample_C,\n\t\t\t\tsample_G,\n\t\t\t\tsample_T);\n\t\tsampleVector.add(sample);\n\t}\n",
    "132607": "\tpublic void addBase(BaseCall base) {\n\t\tbaseHashtable.put(new Integer(base.getTracePoint()), base);\n\t\tbaseVector.add(base);\n\t\tseqBuffer.append(base.getBase());\n\t}\n",
    "132612": "\tpublic Span ( int a, int b, int c, int d ) {\n\t\tseq_start = a;\n\t\tseq_end = b;\n\t\tref_start = c;\n\t\tref_end = d;\n\t\treturn;\n\t}\n",
    "132617": "\tpublic int getSequencePosition(int trace_position) {\n\t\tint seq_position;\n\t\tseq_position = trace_position - seq_offset;\n\t\treturn seq_position;\n\t}\n",
    "132618": "\tpublic int getTracePosition(int seq_position) {\n\t\tint trace_position;\n\t\ttrace_position = seq_position + seq_offset;\n\t\treturn trace_position;\n\t}\n",
    "132623": "\tpublic TraceI getTraceData() {\n\t\tif (trace == null) {\n\t\t\tloadTrace();\n\t\t}\n\t\treturn trace;\n\t}\n",
    "132625": "\tpublic void loadTrace() {\n\t\tSCFTraceParser scfp = new SCFTraceParser();\n\t\ttry {\n\t\t\ttrace = (Trace) scfp.importContent(this.traceURL.openStream());\n\t\t} catch (Exception ex) {\n\t\t\tSystem.out.println(ex.getMessage());\n\t\t\tex.printStackTrace();\n\t\t}\n\t\tif (seq_flipped) {\n\t\t\ttrace = trace.reverseComplement();\n\t\t}\n\t}\n",
    "132628": "\tpublic void addBaseConfidence( BaseConfidence theBase ) {\n\t\tthis.qualityList.add( theBase );\n\t\tthis.maxConfidence = Math.max( this.maxConfidence, theBase.getConfidence() );\n\t}\n",
    "132634": "\tpublic BaseConfidence ( char base, int conf ) {\n\t\tthis( Character.toUpperCase( base ), conf, 0 );\n\t}\n",
    "132640": "\tpublic BaseCall reverseComplement ( int trace_length ) {\n\t\tchar rev_base = DNAUtils.complementChar(base);\n\t\tint rev_peak = trace_length - point - 1;\n\n\t\treturn new BaseConfidence(rev_base, conf, rev_peak);\n\t}\n",
    "132649": "\tpublic Mapping (String id) {\n\t\tthis.id = id;\n\t}\n",
    "132651": "\tpublic void setSequence(Sequence seq) {\n\t\tthis.seq = seq;\n\t}\n",
    "132652": "\tpublic Sequence getSequence() {\n\t\treturn seq;\n\t}\n",
    "132657": "\tpublic void setDirection ( boolean direction ) {\n\t\tthis.direction = direction;\n\t}\n",
    "132658": "\tpublic boolean getDirection () {\n\t\treturn direction;\n\t}\n",
    "132659": "\tpublic boolean isForward() {\n\t\treturn direction;\n\t}\n",
    "132660": "\tpublic void addSpan(Span span) {\n\t\tif (spans.size() == 0 && (!ref_range_set)) {\n\t\t\tref_start = span.ref_start;\n\t\t\tref_end = span.ref_end;\n\t\t\tmap_start = span.seq_start;\n\t\t\tmap_end = span.seq_end;\n\n\t\t}\n\t\telse {\n\t\t\tif (span.ref_start < ref_start) { ref_start = span.ref_start; }\n\t\t\tif (span.ref_end > ref_end) { ref_end = span.ref_end; }\n\t\t\tif (span.seq_start < map_start) { map_start = span.seq_start; }\n\t\t\tif (span.seq_end > map_end) { map_end = span.seq_end; }\n\t\t}\n\t\tspans.add(span);\n\t\tsetDirection(span.seq_start <= span.seq_end);\n\t}\n",
    "132663": "\tpublic int getStart() {\n\t\treturn ref_start;\n\t}\n",
    "132664": "\tpublic Object clone() {\n\t\treturn new Range(beg, end);\n\t}\n",
    "132665": "\tpublic int getEnd() {\n\t\treturn ref_end;\n\t}\n",
    "132666": "\tpublic boolean overlaps(Range that) {\n\t\treturn !(this.end < that.beg  || this.beg > that.end);\n\t}\n",
    "132668": "\tpublic boolean within(Range that) {\n\t\treturn (this.beg >= that.beg && this.end <= that.end);\n\t}\n",
    "132670": "\tpublic Range union(Range that) {\n\t\tRange result = new Range(0, 0);\n\t\tresult.beg = (this.beg <= that.beg) ? this.beg : that.beg;\n\t\tresult.end = (this.end >= that.end) ? this.end : that.end;\n\t\treturn result;\n\t}\n",
    "132671": "\tpublic Range intersection(Range that) {\n\t\tRange result = new Range(0, 0);\n\t\tresult.beg = (this.beg > that.beg) ? this.beg : that.beg;\n\t\tresult.end = (this.end < that.end) ? this.end : that.end;\n\t\treturn result;\n\t}\n",
    "132675": "\tpublic int mapToMapped(int ref_pos) {\n\t\tint seqpos = Integer.MIN_VALUE;\n\t\tif (ref_pos < ref_start || ref_pos > ref_end) {\n\t\t\treturn seqpos;\n\t\t}\n\t\tint i;\n\t\tSpan sp;\n\t\tint numspans = spans.size();\n\t\tfor (i=0; i<numspans; i++) {\n\t\t\tsp = spans.get(i);\n\t\t\tif (ref_pos >= sp.ref_start && ref_pos <= sp.ref_end) {\n\t\t\t\tseqpos = sp.seq_start + (ref_pos - sp.ref_start);\n\t\t\t\treturn seqpos;\n\t\t\t}\n\t\t}\n\t\treturn seqpos;\n\t}\n",
    "132678": "\tpublic int mapToReference(int map_pos) {\n\t\tint i;\n\t\tint ref_pos = Integer.MIN_VALUE;\n\t\tif (map_pos < map_start || map_pos > map_end) {\n\t\t\treturn ref_pos;\n\t\t}\n\n\t\tSpan sp;\n\t\tint numspans = spans.size();\n\t\tfor (i=0; i<numspans; i++) {\n\t\t\tsp = spans.get(i);\n\t\t\tif (map_pos >= sp.seq_start && map_pos <= sp.seq_end) {\n\t\t\t\tref_pos = sp.ref_start + (map_pos - sp.seq_start);\n\t\t\t\treturn ref_pos;\n\t\t\t}\n\t\t}\n\t\treturn ref_pos;\n\t}\n",
    "132688": "\tpublic BaseCall reverseComplement( int trace_length ) {\n\t\tchar rev_base = DNAUtils.complementChar(base);\n\t\tint rev_peak = trace_length - peak_index - 1;\n\n\t\tint p = prob_A;\n\t\tprob_A = prob_T;\n\t\tprob_T = p;\n\t\tp = prob_C;\n\t\tprob_C = prob_G;\n\t\tprob_G = p;\n\n\t\treturn new CalledBase(rev_peak, prob_T, prob_G,\n\t\t\t\tprob_C, prob_A, rev_base);\n\t}\n",
    "132698": "\tpublic void removeAdjustmentListener(java.awt.event.AdjustmentListener l) {\n\t\tthis.listeners.remove( l );\n\t}\n",
    "132706": "\tprivate void fireAdjustmentEvent() {\n\t\tAdjustmentEvent e = new AdjustmentEvent\n\t\t\t( this, AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED, AdjustmentEvent.TRACK, getValue() );\n\t\tfor (AdjustmentListener l : this.listeners) {\n\t\t\tl.adjustmentValueChanged( e );\n\t\t}\n\t}\n",
    "132707": "\tpublic BaseCalls reverseComplement() {\n\t\tint traceLength = 0;\n\t\tif ( null != this.trace ) {\n\t\t\ttraceLength = this.trace.getTraceLength();\n\t\t}\n\t\tBaseCalls revBaseCalls = new BaseCalls();\n\t\trevBaseCalls.setTrace( this.getTrace() );\n\t\tint iCount = getBaseCount();\n\t\tfor (int i = iCount - 1; i >= 0; i--) {\n\t\t\tBaseCall base = baseVector.get(i).reverseComplement( traceLength );\n\t\t\trevBaseCalls.addBase(base);\n\t\t}\n\t\treturn revBaseCalls;\n\t}\n",
    "132709": "\tpublic void addBase(BaseCall base) {\n\t\tbaseVector.add(base);\n\t}\n",
    "132712": "  public void postPaintEvent(NeoPaintEvent e) {\n    for (NeoPaintListener npl : paintListeners) {\n      npl.componentPainted(e);\n    }\n  }\n",
    "132714": "  public void addNeoPaintListener(NeoPaintListener pl) {\n    paintListeners.add(pl);\n  }\n",
    "132715": "  public void removeNeoPaintListener(NeoPaintListener pl) {\n    paintListeners.remove(pl);\n  }\n",
    "132716": "\tpublic void update(Graphics g) {\n\t\tpaint(g);\n\t}\n",
    "132718": "\tpublic void paint(Graphics g) {\n\t\tif (needs_background_paint) {\n\t\t\tneeds_background_paint = false;\n\t\t\tDimension dim = this.getSize();\n\t\t\tg.setClip(0, 0, dim.width, dim.height);\n\t\t\tg.setColor(this.getBackground());\n\t\t\tg.fillRect(0, 0, dim.width, dim.height);\n\t\t}\n\t\tsuper.paint(g);\n\t}\n",
    "132721": "\tpublic void forceBackgroundFill() {\n\t\tneeds_background_paint = true;\n\t}\n",
    "132730": "\tpublic TierEvent (AbstractTieredMap src, int evtType, MapTierGlyph evtTier, boolean full_repack, boolean stretch_map) {\n\t\tsuper(src);\n\t\tsource = src;\n\t\ttype = evtType;\n\t\ttier = evtTier;\n\t\tthis.full_repack = full_repack;\n\t\tthis.stretch_map = stretch_map;\n\t}\n",
    "132734": "\tpublic Object getArg() {\n\t\treturn arg;\n\t}\n",
    "132735": "\tpublic MapTierGlyph getTier() {\n\t\treturn tier;\n\t}\n",
    "132740": "\tpublic void setMoveLocs (int[] moveLocs) {\n\t\tif (moveLocs == null)\n\t\t\treturn;\n\t\tthis.moveLocs = new int[2];\n\t\tthis.moveLocs[0] = moveLocs[0];\n\t\tthis.moveLocs[1] = moveLocs[1];\n\t}\n",
    "132744": "\tpublic boolean getFullRepack() {\n\t\treturn full_repack;\n\t}\n",
    "132747": "\tpublic void recycle(Object source, int id, GlyphI glyph)  {\n\t\tthis.source = source;\n\t\tthis.id = id;\n\t\tdragged_glyph = glyph;\n\t}\n",
    "132750": "\tpublic int getState() {\n\t\treturn state;\n\t}\n",
    "132752": "\tpublic int getOffset() {\n\t\treturn this.offset;\n\t}\n",
    "132756": "\tpublic int getLength() {\n\t\treturn this.length;\n\t}\n",
    "132757": "\tpublic SequenceI getDocument() {\n\t\treturn (SequenceI) super.getSource();\n\t}\n",
    "132758": "\tpublic EditType getType() {\n\t\treturn this.type;\n\t}\n",
    "132759": "\tpublic int getLocation() {\n\t\treturn location;\n\t}\n",
    "132772": "\tpublic void setCoords(double x, double y, double w, double h) {\n\t\teveGlyph.setCoords(x,y,w,h);\n\t\tmaxDamage();\n\t}\n",
    "132773": "\tpublic void setGlyph(GlyphI glyph) {\n\t\tif (glyph == null) {\n\t\t\teveGlyph = new RootGlyph();\n\t\t\treturn;\n\t\t}\n\t\teveGlyph = glyph;\n\t\teveGlyph.setScene(this);\n\t\tmaxDamage();\n\t}\n",
    "132776": "\tpublic GlyphI getGlyph()  {\n\t\treturn eveGlyph;\n\t}\n",
    "132778": "\tpublic void addGlyph(GlyphI glyph) {\n\t\tif (glyph != null) {\n\t\t\tgetGlyph().addChild(glyph);\n\n\t\t\t// transients should be added both to the root glyph (for pick\n\t\t\t//     traversal, etc.) and to the transients list (for actual drawing),\n\t\t\t//     but shouldn't be considered in damage expansion...\n\t\t\tif (glyph instanceof TransientGlyph) {\n\t\t\t\taddTransient((TransientGlyph)glyph);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texpandDamage(glyph);\n\t\t\t}\n\t\t}\n\t}\n",
    "132784": "\tpublic void addView(ViewI view)  {\n\t\tviews.add(view);\n\t}\n",
    "132788": "\tpublic void removeView(ViewI view)  {\n\t\tviews.remove(view);\n\t}\n",
    "132790": "\tpublic void draw()  {\n\t\tfor (ViewI view : views) {\n\t\t\tview.draw();\n\t\t}\n\t\tclearDamage();\n\t}\n",
    "132793": "\tpublic void draw(ViewI v) {\n\t\tv.draw();\n\t}\n",
    "132796": "\tpublic void draw(Component c, Graphics2D g)  {\n\t\tfor (ViewI view : views) {\n\t\t\tif (view.getComponent() == c)  {\n\t\t\t\tview.setGraphics (g);\n\t\t\t\tview.draw();\n\t\t\t}\n\t\t}\n\t\t// This will cause problems when trying to do damage control across\n\t\t// views on multiple canvases!!!  11-17-97\n\t\t// should probably switch to a long damage_counter for both View\n\t\t// and Scene, so View can compare to its own counter and decide based\n\t\t// on that what to do, and Scene can in turn check View counters to\n\t\t// decide when it can zero out the damage again\n\t\tclearDamage();\n\t}\n",
    "132809": "\tpublic void setVisibility(GlyphI glyph, boolean isVisible) {\n\t\tglyph.setVisibility(isVisible);\n\t\texpandDamage(glyph);\n\t}\n",
    "132813": "\tpublic void select(GlyphI gl) {\n\t\tif (gl != null) {\n\t\t\tgl.setSelected(true);\n\t\t\texpandDamage(gl);\n\t\t}\n\t}\n",
    "132819": "\tpublic void deselect(GlyphI gl) {\n\t\tif (gl != null) {\n\t\t\tgl.setSelected(false);\n\t\t\texpandDamage(gl);\n\t\t}\n\t}\n",
    "132821": "\tpublic void addGlyphDragListener(NeoGlyphDragListener listener) {\n\t\tdrag_listeners.add(listener);\n\t}\n",
    "132822": "\tpublic void removeGlyph(GlyphI gl) {\n\t\texpandDamage(gl);\n\t\t// special case: if gl is the top-level glyph, set to null\n\t\tif (gl == this.getGlyph()) {\n\t\t\tsetGlyph(null);\n\t\t}\n\t\t// otherwise remove reference to gl in parent's children\n\t\telse {\n\t\t\tGlyphI parent = gl.getParent();\n\t\t\tparent.removeChild(gl);\n\t\t}\n\t\tif (gl instanceof TransientGlyph) {\n\t\t\tremoveTransient((TransientGlyph)gl);\n\t\t}\n\t}\n",
    "132829": "\tpublic void setSelectionAppearance(int id) {\n\t\tselect_style = id;\n\t}\n",
    "132834": "\tpublic void configure(String options) {\n\t\tHashtable<String,Object> options_hash = GeneralUtils.parseOptions(options);\n\t\tconfigure(options_hash);\n\t}\n",
    "132837": "\tpublic double transform(int orientation, double in) {\n\t\tdouble out = 0;\n\t\tif (orientation == NeoConstants.HORIZONTAL) {\n\t\t\tout = in * this.getScaleX() + this.getTranslateX();\n\t\t} else if (orientation == NeoConstants.VERTICAL) {\n\t\t\tout = in * this.getScaleY() + this.getTranslateY();\n\t\t}\n\t\treturn out;\n\t}\n",
    "132838": "\tpublic void configure(Hashtable<String,Object> options) {\n\t\tconfigureTemp(options);\n\t\tdefault_background = background_color;\n\t\tdefault_width = width;\n\t\tdefault_offset = offset;\n\t\tdefault_glyphtype = glyphtype;\n\t\tdefault_packer = packer;\n\t\tdefault_mirror = mirror;\n\t\tdefault_foreground = foreground_color;\n\t}\n",
    "132848": "\tpublic void expandDamage(GlyphI glyph) {\n\t\tif (glyph == null) {\n\t\t\treturn;\n\t\t}\n\t\tdamaged = true;\n\t\tRectangle2D.Double gcoords = glyph.getCoordBox();\n\n\t\tif (damageCoordBox == null) {\n\t\t\tdamageCoordBox = new Rectangle2D.Double();\n\t\t\tdamageCoordBox.setRect(gcoords);\n\t\t}\n\t\telse {\n\t\t\tdamageCoordBox.add(gcoords);\n\t\t}\n\t}\n",
    "132853": "\tpublic void select(double x, double y, double width, double height) {\n\t\tsetSelected(true);\n\t}\n",
    "132859": "\tpublic boolean supportsSubSelection() {\n\t\treturn false;\n\t}\n",
    "132875": "\tpublic void removeAllTransients() {\n\t\tif ( null != transients ) {\n\t\t\ttransients.clear();\n\t\t}\n\t}\n",
    "132890": "\tprivate boolean RectangleIntersectHack(ViewI view) {\n\t\tRectangle2D.Double r= this.getPositiveCoordBox();\n\t\tRectangle2D.Double v = view.getCoordBox();\n\t\tif (r.width == 0 || r.height == 0) {\n\t\t\treturn !((r.x + r.width <= v.x) ||\n\t\t\t\t(r.y + r.height <= v.y) ||\n\t\t\t\t(r.x >= v.x + v.width) ||\n\t\t\t\t(r.y >= v.y + v.height));\n\t\t}\n\t\treturn false;\n\t}\n",
    "132900": "\tpublic void setMoveType(int movetype) {\n\t\tthis.movetype = movetype;\n\t}\n",
    "132904": "\tpublic void setCoordFuzziness(double fuzz) {\n\t\tif (fuzz > spacing) {\n\t\t\tthrow new IllegalArgumentException\n\t\t\t\t(\"Can't set packer fuzziness greater than spacing\");\n\t\t}\n\t\telse {\n\t\t\tcoord_fuzziness = fuzz;\n\t\t}\n\t}\n",
    "132908": "\tpublic void setSpacing(double sp) {\n\t\tif (sp < coord_fuzziness) {\n\t\t\tthrow new IllegalArgumentException\n\t\t\t\t(\"Can't set packer spacing less than fuzziness\");\n\t\t}\n\t\telse {\n\t\t\tspacing = sp;\n\t\t}\n\t}\n",
    "132914": "\tpublic void setComponent( Component c ) {\n\t\tthis.comp = c;\n\t}\n",
    "132915": "\tpublic GlyphI makeGlyph(double beg, double end, String options) {\n\t\tHashtable<String,Object> options_hash = GeneralUtils.parseOptions(options);\n\t\treturn makeGlyph(beg, end, options_hash);\n\t}\n",
    "132919": "\tpublic GlyphI makeGlyph(double beg, double end, Hashtable<String,Object> options) {\n\t\t// set configuration fields based on options hash\n\t\tconfigureTemp(options);\n\t\t// make the glyph, based on configuration fields\n\t\tGlyphI gl = makeGlyph(beg, end);\n\n\t\t// restore configure fields to their previous values\n\t\tbackground_color = default_background;\n\t\tforeground_color = default_foreground;\n\t\twidth = default_width;\n\t\toffset = default_offset;\n\t\tglyphtype = default_glyphtype;\n\t\tpacker = default_packer;\n\t\tmirror = default_mirror;\n\t\treturn gl;\n\t}\n",
    "132924": "\tpublic GlyphI makeItem(double beg, double end) {\n\t\tGlyphI gl = this.makeGlyph(beg, end);\n\t\tscene.addGlyph(gl);\n\t\treturn gl;\n\t}\n",
    "132971": "\tpublic void addColor(String theName, Color theColor) {\n\t\tif (null == theName) {\n\t\t\tthrow new IllegalArgumentException(\"Can't addColor without a name.\");\n\t\t}\n\t\tif (null == theColor) {\n\t\t\tthrow new IllegalArgumentException(\"Can't add a null color.\");\n\t\t}\n\t\tmap.put(theName, theColor);\n\t}\n",
    "132972": "\tpublic Color getColor(String theName) {\n\t\tif (null == theName) {\n\t\t\tthrow new IllegalArgumentException(\"Can't getColor without a name.\");\n\t\t}\n\t\treturn map.get(theName);\n\t}\n",
    "132973": "\tpublic void setEmpty( boolean empty ) {\n\t\tint orientation = sel_orientation;\n\t\tif ( empty ) {\n\t\t\torientation = ORIENTATION_NONE;\n\t\t}\n\t\telse {\n\t\t\tif (sel_start < sel_end) {\n\t\t\t\torientation = ORIENTATION_FORWARD;\n\t\t\t}\n\t\t\telse if (sel_end < sel_start) {\n\t\t\t\torientation = ORIENTATION_REVERSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\torientation = ORIENTATION_POINT;\n\t\t\t}\n\t\t}\n\t\tif ( this.sel_orientation != orientation ) {\n\t\t\tthis.sel_orientation = orientation;\n\t\t\tsetChanged();\n\t\t}\n\t}\n",
    "132974": "\tpublic String getColorName(Color theColor) {\n\t\tif (null == theColor) {\n\t\t\tthrow new IllegalArgumentException(\"Can't get a name for a null color.\");\n\t\t}\n\t\tEnumeration it = map.keys();\n\t\twhile (it.hasMoreElements()) {\n\t\t\tString candidate = (String)it.nextElement();\n\t\t\tif (theColor.equals(map.get(candidate))) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "132975": "\tpublic Enumeration getColorNames() {\n\t\treturn map.keys();\n\t}\n",
    "132982": "\tpublic void clear() {\n\t\tif (this.isEmpty())\n\t\t\treturn; // It was already thus.\n\t\tsetChanged();\n\t\tsel_orientation = ORIENTATION_NONE;\n\t\tsel_orig = sel_start = sel_end = 0;\n\t}\n",
    "132984": "\tpublic void start() {\n\t\t//start_date = new Date();\n\t\tstart_time = System.currentTimeMillis();\n\t}\n",
    "132985": "\tpublic void setPoint(int point) {\n\t\tif (sel_orientation == ORIENTATION_POINT\n\t\t\t\t&& point == sel_orig\n\t\t\t\t&& !isEmpty())\n\t\t\treturn; // It was already thus.\n\t\tsetRange(point, point);\n\t}\n",
    "132987": "\tpublic void print() {\n\t\tSystem.out.println(\"Elapsed time since start: \" + (double)this.read()/1000f);\n\t}\n",
    "132989": "\tpublic void setRange(int start, int end) {\n\n\t\tif ( start <= end && start == sel_start && end == sel_end && !isEmpty() )\n\t\t\treturn; // It was already thus.\n\t\tif ( end < start && end == sel_start && start == sel_end && !isEmpty() )\n\t\t\treturn; // It was already thus.\n\n\t\tsetChanged();\n\n\t\tsel_orig = start;\n\t\tsel_start = start;\n\t\tsel_end = end;\n\n\t\tif ( sel_start < sel_end ) {\n\t\t\tsel_orientation = ORIENTATION_FORWARD;\n\t\t}\n\t\telse if ( sel_start == sel_end ) {\n\t\t\tsel_orientation = ORIENTATION_POINT;\n\t\t}\n\t\telse {\n\t\t\t// swap start and end to match update()\n\t\t\tsel_end = start;\n\t\t\tsel_start = end;\n\t\t\tsel_orientation = ORIENTATION_REVERSE;\n\t\t}\n\n\t}\n",
    "132991": "\tpublic void setLimit(int theLimit) {\n\t\tif (theLimit < 0) {\n\t\t\tthrow new IllegalArgumentException(\"The limit cannot be negative.\");\n\t\t}\n\t\tthis.limit = theLimit;\n\t}\n",
    "132993": "\tpublic boolean hit(Rectangle pixel_hitbox, ViewI view)  {\n\t\treturn false;\n\t}\n",
    "132994": "\tpublic void update(int value) {\n\n\t\tsetChanged();\n\n\t\tif ( this.isEmpty() ) {\n\t\t\tsel_orig = value;\n\t\t}\n\n\t\tif ( sel_orig < value ) {\n\t\t\tsel_start = sel_orig;\n\t\t\tsel_end = value;\n\t\t\tsel_orientation = ORIENTATION_FORWARD;\n\t\t}\n\t\telse if ( sel_orig == value ) {\n\t\t\tsel_start = value;\n\t\t\tsel_end = value;\n\t\t\tsel_orientation = ORIENTATION_POINT;\n\t\t}\n\t\telse {\n\t\t\tsel_start = value;\n\t\t\tsel_end = sel_orig-1;\n\t\t\tsel_orientation = ORIENTATION_REVERSE;\n\t\t}\n\n\t}\n",
    "132997": "\tpublic boolean hit(Rectangle2D.Double coord_hitbox, ViewI view)  {\n\t\treturn false;\n\t}\n",
    "133015": "\tpublic int indexOf (LegendGlyph lglyph) {\n\t\treturn legend_glyphs.indexOf(lglyph);\n\t}\n",
    "133018": "\tpublic void addChild(GlyphI glyph, int position) {\n\t\tif (this==glyph) throw new IllegalArgumentException(\n\t\t\t\t\"Illegal to add a Glyph as a child of itself!\");\n\t\tGlyphI prev_parent = glyph.getParent();\n\t\tif (prev_parent != null) {\n\t\t\tprev_parent.removeChild(glyph);\n\t\t}\n\t\tif (children == null)  {\n\t\t\tchildren = new ArrayList<GlyphI>();\n\t\t}\n\t\tif (position == children.size()) {\n\t\t\tchildren.add(glyph);\n\t\t}\n\t\telse  {\n\t\t\tchildren.add(position, glyph);\n\t\t}\n\t\t// setParent() also calls setScene()\n\t\tglyph.setParent(this);\n\t}\n",
    "133019": "\tpublic void addChild(GlyphI glyph)  {\n\t\tGlyphI prev_parent = glyph.getParent();\n\t\tif (prev_parent != null) {\n\t\t\tprev_parent.removeChild(glyph);\n\t\t}\n\t\tif (children == null)  {\n\t\t\tchildren = new ArrayList<GlyphI>();\n\t\t}\n\t\tchildren.add(glyph);\n\t\tglyph.setParent(this);\n\t}\n",
    "133021": "\tpublic void removeChild(GlyphI glyph)  {\n\t\tif (children != null) {\n\t\t\tchildren.remove(glyph);\n\t\t\tif (children.size() == 0) { children = null; }\n\t\t}\n\t\t// null out the scene if glyph is removed\n\t\tglyph.setScene(null);\n\t}\n",
    "133023": "\tpublic boolean hasMultiGlyphsPerModel() {\n\t\treturn models_have_multiple_glyphs;\n\t}\n",
    "133030": "\tpublic Object getDataModel(GlyphI glyph) {\n\t\treturn glyph.getInfo();\n\t}\n",
    "133033": "\tpublic void moveAbsolute(GlyphI glyph, double x, double y) {\n\t\tglyph.moveAbsolute(x, y);\n\t}\n",
    "133037": "\tpublic void moveAbsolute(List<GlyphI> glyphs, double x, double y) {\n\t\tfor (GlyphI glyph : glyphs) {\n\t\t\tmoveAbsolute(glyph, x, y);\n\t\t}\n\t}\n",
    "133041": "\tpublic void moveRelative(GlyphI glyph, double diffx, double diffy) {\n\t\tglyph.moveRelative(diffx, diffy);\n\t}\n",
    "133044": "\tpublic void moveRelative(List<GlyphI> glyphs, double x, double y) {\n\t\tfor (GlyphI glyph : glyphs) {\n\t\t\tmoveRelative(glyph, x, y);\n\t\t}\n\t}\n",
    "133048": "\tpublic void setScrollIncrementBehavior(int id, int behavior) {\n\t\tscroll_behavior[id] = behavior;\n\t}\n",
    "133051": "\tpublic int getScrollIncrementBehavior(int id) {\n\t\treturn scroll_behavior[id];\n\t}\n",
    "133054": "\tpublic void setMinimumPixelBounds(Dimension d)   {\n\t\t// to save a miniscule amount of memory per Glyph, this is saved as\n\t\t// two integers rather than one Dimension object.\n\t\tmin_pixels_width  = Math.abs(d.width);\n\t\tmin_pixels_height = Math.abs(d.height);\n\t}\n",
    "133055": "  public boolean isSelected(GlyphI g) {\n    return selected.contains(g);\n  }\n",
    "133056": "\tpublic void setCoords(double x, double y, double width, double height)  {\n\t\tif (width < 0) {\n\t\t\tx = x + width;\n\t\t\twidth = -width;\n\t\t}\n\t\tif (height < 0) {\n\t\t\ty = y + height;\n\t\t\theight = -height;\n\t\t}\n\t\tcoordbox.setRect(x, y, width, height);\n\t}\n",
    "133058": "\tpublic void setCoordBox(Rectangle2D.Double coordbox)   {\n\t\tthis.coordbox = coordbox;\n\t}\n",
    "133059": "\tpublic void select(List<GlyphI> glyphs) {\n\t\tif (glyphs == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (GlyphI glyph : glyphs) {\n\t\t\tselect(glyph);\n\t\t}\n\t}\n",
    "133062": "\tpublic void clearSelected() {\n\t\twhile (selected.size() > 0) {\n\t\t\t// selected.size() shrinks because deselect(glyph)\n\t\t\t//    calls selected.remove()\n\t\t\tObject gl = selected.get(0);\n\t\t\tif (gl == null) { selected.remove(0); }\n\t\t\telse {\n\t\t\t\tdeselect((GlyphI)gl);\n\t\t\t}\n\t\t}\n\t\tselected.clear();\n\t}\n",
    "133066": "\tpublic void deselect(List<GlyphI> glyphs) {\n\t\t// need to special case if glyphs argument is ref to same List as selected,\n\t\t//   since the deselect(Object) will cause shrinking of vec size as\n\t\t//   it is being looped through\n\t\tif (glyphs == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (glyphs == selected) {\n\t\t\tclearSelected();\n\t\t}\n\t\tfor (int i=0; i<glyphs.size(); i++) {\n\t\t\tdeselect(glyphs.get(i));\n\t\t}\n\t}\n",
    "133070": "\tpublic void clearWidget() {\n\t\tselected.clear();\n\t\t// reset glyph_hash\n\t\tglyph_hash = new HashMap<GlyphI,Object>();\n\n\t\t// reset model_hash\n\t\tmodel_hash = new HashMap<Object,Object>();\n\n\t\tmodels_have_multiple_glyphs = false;\n\t}\n",
    "133077": "\tpublic Rectangle getComponentSizeRect() {\n\t\treturn component_size_rect;\n\t}\n",
    "133082": "\tpublic void mouseClicked(MouseEvent e) {\n\t\theardMouseEvent(e);\n\t}\n",
    "133102": "\tpublic void mouseDragged(MouseEvent e) {\n\t\theardMouseEvent(e);\n\t}\n",
    "133108": "\tpublic void keyPressed(KeyEvent e) {\n\t\theardKeyEvent(e);\n\t}\n",
    "133117": "\tprivate void setCaretCoords() {\n\t\tif ( null != this.caret ) {\n\t\t\tthis.caret.setCoords ( 0, 0, residues_per_line, seq_map_size );\n\t\t}\n\t}\n",
    "133120": "\tpublic void componentPainted(NeoPaintEvent evt) {\n\t\tsetGraphics(evt.getGraphics());\n\t\tdraw();\n\t}\n",
    "133125": "\tpublic void heardKeyEvent(KeyEvent e) {\n\t\tif (e.getSource() != component) {\n\t\t\treturn;\n\t\t}\n\t\tint id = e.getID();\n\t\tfor (KeyListener kl : key_listeners) {\n\t\t\tif (id == KeyEvent.KEY_PRESSED) {\n\t\t\t\tkl.keyPressed(e);\n\t\t\t} else if (id == KeyEvent.KEY_RELEASED) {\n\t\t\t\tkl.keyReleased(e);\n\t\t\t} else if (id == KeyEvent.KEY_TYPED) {\n\t\t\t\tkl.keyTyped(e);\n\t\t\t}\n\t\t}\n\t}\n",
    "133131": "\tpublic void destroy() {\n\t\tkey_listeners.clear();\n\t\tmouse_motion_listeners.clear();\n\t\tmouse_listeners.clear();\n\t\tglyph_hash.clear();\n\t\tmodel_hash.clear();\n\t\tselected.clear();\n\t}\n",
    "133132": "\tpublic Image getBufferedImage() {\n\t\tif (this.isBuffered()) {\n\t\t\treturn bufferImage;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "133133": "\tpublic void setSelectable(boolean selectability) {\n\t\tif (!selectability) setSelected(false);\n\t\tthis.selectable = selectability;\n\t}\n",
    "133134": "\tpublic boolean isSelectable() {\n\t\treturn this.selectable;\n\t}\n",
    "133137": "\tpublic GlyphI addOutlineAnnotation(int start, int end, Color color) {\n\t\treturn getResidueGlyph().addOutlineAnnotation(start, end, color);\n\t}\n",
    "133138": "\tpublic void setMap(AbstractTieredMap map){\n\t\ttiermap = map;\n\t}\n",
    "133139": "\tpublic void addMap(AbstractTieredMap ntm){\n\t\tother_maps.add(ntm);\n\t}\n",
    "133142": "\tpublic void setSelected(boolean selected) {\n\t\tif (this.selectable) this.selected = selected;\n\t}\n",
    "133151": "\tpublic GlyphI addAnnotation(int start, int end, Color color) {\n\t\treturn getResidueGlyph().addAnnotation(start, end, color);\n\t}\n",
    "133157": "\tpublic boolean getGlobalTransform(ViewI view, LinearTransform trans) {\n\t\ttrans.setTransform(view.getTransform());\n\t\treturn getParent().getGlobalChildTransform(view, trans);\n\t}\n",
    "133159": "\tpublic void getChildTransform(ViewI view, LinearTransform trans) {\n\t}\n",
    "133160": "\tpublic Range getAnnotationRange(GlyphI annotation) {\n\t\tRange r = new Range(0,0);\n\t\tif (annotation instanceof AnnotationGlyph) {\n\t\t\tr.beg = ((AnnotationGlyph) annotation).getStart();\n\t\t\tr.end = ((AnnotationGlyph) annotation).getEnd();\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"can only getAnnotationRange for an annotation.\");\n\t\t}\n\t\treturn r;\n\t}\n",
    "133165": "\tpublic int getAnnotationStart(GlyphI annotation) {\n\t\tint s = 0;\n\t\tif (annotation instanceof AnnotationGlyph) {\n\t\t\ts = ((AnnotationGlyph) annotation).getStart();\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"can only getAnnotationStart for an annotation.\");\n\t\t}\n\t\treturn s;\n\t}\n",
    "133170": "\tpublic int getAnnotationEnd(GlyphI annotation) {\n\t\tint e = 0;\n\t\tif (annotation instanceof AnnotationGlyph) {\n\t\t\te = ((AnnotationGlyph) annotation).getEnd();\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"can only getAnnotationEnd for an annotation.\");\n\t\t}\n\t\treturn e;\n\t}\n",
    "133176": "\tpublic void removeAnnotation(GlyphI gl) {\n\t\tgetResidueGlyph().removeAnnotation(gl);\n\t}\n",
    "133199": "\tpublic void deselect() {\n\t\tsetResiduesSelected(false);\n\t\tWrapSequence wrapseq = getResidueGlyph();\n\t\tif (wrapseq != null) {\n\t\t\twrapseq.unhighlight();\n\t\t}\n\t}\n",
    "133202": "\tpublic void setRevNumbering (boolean rn) {\n\t\trevNums = rn;\n\t}\n",
    "133203": "\tpublic boolean getRevNumbering () {\n\t\treturn revNums;\n\t}\n",
    "133204": "\tpublic void setFirstOrdinal (int firstOrd) {\n\t\tthis.firstOrd = firstOrd;\n\t}\n",
    "133205": "\tpublic int getFirstOrdinal () {\n\t\treturn firstOrd;\n\t}\n",
    "133215": "\tpublic void appendResidues(String residues) {\n\t\t// if no previous sequence, then residues becomes full sequence\n\t\tif (seq == null) {\n\t\t\tsetResidues(residues);\n\t\t\treturn;\n\t\t}\n\t\t// want to remain in same place, need to remember start and restore\n\t\t//   after calling setResidues()\n\t\tint start_base = (int)num_map.getView().getCoordBox().y;\n\t\tseq.appendResidues(residues);\n\t\tsetSequence(seq);\n\t\tresidue_map.scrollOffset(start_base);\n\t\tnum_map.scrollOffset(start_base);\n\t\tresidue_map.adjustScroller(NeoMap.Y);\n\t}\n",
    "133226": "\tprotected boolean checkRange(int start, int end) {\n\t\tint orientedStart = Math.min(start, end);\n\t\tint orientedEnd = Math.max(start, end);\n\t\tif (orientedStart < range_start || orientedEnd > range_end) {\n\t\t\tif (orientedStart < range_start) { range_start = orientedStart; }\n\t\t\tif (orientedEnd > range_end) { range_end = orientedEnd; }\n\t\t\tsetRange(range_start, range_end);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "133228": "\tpublic int getResidueHeight() {\n\t\tline_height = calcLineHeight();\n\t\treturn line_height;\n\t}\n",
    "133236": "\tpublic GlyphI setResidues(String residues) {\n\t\tif (residues == null) {\n\t\t\tthrow new IllegalArgumentException(\"NeoSeq.setResidues() requires a \" +\n\t\t\t\t\t\"String argument, was passed null instead\");\n\t\t}\n\t\tSequence s = new NASequence();\n\t\ts.setResidues(residues);\n\t\tsetSequence(s);\n\t\treturn getResidueGlyph();\n\t}\n",
    "133247": "\tprotected Glyph addAlignment(Mapping align) {\n\t\treturn null;\n\t}\n",
    "133248": "\tpublic void draw(ViewI view) {\n\t\tvisible_box = ((View)view).calcCoordBox();\n\n\t\tfirst_visible_residue = (int)visible_box.y;\n\n\t\tif (residues_per_line < 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tlast_visible_residue = useConstrain(residues_per_line, visible_box.y, visible_box.height);\n\n\t\tlastPotentiallyVisibleResidue = last_visible_residue;\n\n\t\tif (last_visible_residue > seq_end) {\n\t\t\tlast_visible_residue = seq_end;\n\t\t}\n\t\tif (first_visible_residue < 0) {\n\t\t\tSystem.out.println(\"first_visible_residue = \" + first_visible_residue);\n\t\t}\n\t\tdrawResidues(first_visible_residue, last_visible_residue, view,\n\t\t\t\tseqfont, getBackgroundColor());\n\t}\n",
    "133249": "\tpublic int getResiduesPerScreen() {\n\t\treturn lastPotentiallyVisibleResidue + 1 - first_visible_residue;\n\t}\n",
    "133254": "\tpublic void setMatchChar ( Character match_char ) {\n\t\tthis.match_char = match_char;\n\t}\n",
    "133268": "\tpublic void setSequence(SequenceI seq, int first) {\n\t\tsetSequence(seq);\n\t\tsetFirstOrdinal(first);\n\t}\n",
    "133283": "\tpublic void makeResidueVisible(int theResidueIndex) {\n\t\tRange r = getVisibleRange();\n\t\tif ( theResidueIndex < r.beg ) {\n\t\t\tscrollSequence( theResidueIndex );\n\t\t}\n\t\telse if ( r.end < theResidueIndex ) {\n\t\t\tint rpl = getResiduesPerLine();\n\t\t\tif (rpl > 0) {\n\t\t\t\tint rps = this.residue_glyph.getResiduesPerScreen() - 1;\n\t\t\t\tint top;\n\t\t\t\tfor ( top = r.beg;\n\t\t\t\t\t\ttop + rps < theResidueIndex;\n\t\t\t\t\t\ttop += rpl\n\t\t\t\t\t);\n\t\t\t\tscrollSequence( top );\n\t\t\t}\n\t\t}\n\t}\n",
    "133290": "\tpublic void scrollSequence(int value) {\n\t\tint cval = value - (value % scroll_increment);\n\t\tresidue_map.scrollOffset(cval);\n\t\tnum_map.scrollOffset(cval);\n\t}\n",
    "133301": "\tpublic void draw(ViewI view) {\n\t\t// if no drawTypes are set, then draw as _all_ types that space\n\t\t//    has been allocated for in the WrapSequence\n\t\t// doing it this way mainly to save memory in default case where all\n\t\t//    types with allocated space are supposed to be drawn\n\t\tif (drawTypes == null) {\n\t\t\twrap_seq.drawResidues(annot_start, annot_end, view,\n\t\t\t\t\twrap_seq.getFont(), getBackgroundColor());\n\t\t}\n\t\telse {\n\t\t\twrap_seq.drawResidues(annot_start, annot_end, view,\n\t\t\t\t\twrap_seq.getFont(), getBackgroundColor(), drawTypes);\n\t\t}\n\t}\n",
    "133308": "\tpublic void setFill( int f ) {\n\t\tswitch ( f ) {\n\t\t\tcase OUTLINE:\n\t\t\tcase SOLID:\n\t\t\tcase UNDERLINE:\n\t\t\t\tthis.fill = f;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException\n\t\t\t\t\t(\"Fill must be either SOLID, UNDERLINE, or OUTLINE.\");\n\t\t}\n\t}\n",
    "133321": "\tpublic LinearTransform calcFittedTransform() {\n\t\tLinearTransform new_trans = new LinearTransform();\n\t\tnew_trans.setTransform(\n\t\t\t\t(double) view.getPixelBox().width / scene.getCoordBox().width,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t(double) view.getPixelBox().height / scene.getCoordBox().height,\n\t\t\t\t(double) view.getPixelBox().x - new_trans.getScaleX() * scene.getCoordBox().x,\n\t\t\t\t(double) view.getPixelBox().y - new_trans.getScaleY() * scene.getCoordBox().y);\n\n\t\treturn new_trans;\n\t}\n",
    "133322": "\tpublic void destroy() {\n\t\tsuper.destroy();\n\t\tclearWidget();\n\t\tviewbox_listeners.clear();\n\t}\n",
    "133335": "\tpublic void repack() {\n\t\t// _ONLY_ tiers and glyphs placed in tiers will be repacked --\n\t\t// anything added directly to map other than tiers will need to\n\t\t// be dealt with manually\n\t\tif (debug_events) {\n\t\t\tSystem.out.println(name + \" repacking tiers\");\n\t\t}\n\t\tpackTiers (true, true);\n\n\t\tif (! notifyOnPackTiers) {\n\t\t\tnotifyTierEventListeners  (new TierEvent (this, TierEvent.REPACK, null));\n\t\t}\n\t}\n",
    "133337": "\tpublic int indexOf (MapTierGlyph mtg) {\n\t\treturn tiers.indexOf(mtg);\n\t}\n",
    "133338": "\tpublic MapTierGlyph getTierAt(int i) {\n\t\tif (i>=0 && i<tiers.size()) {\n\t\t\treturn tiers.get(i);\n\t\t}\n\t\telse return null;\n\t}\n",
    "133341": "\tpublic List getAllTiers( ) {\n\t\treturn tiers;\n\t}\n",
    "133342": "\tpublic String getLabel(GlyphI seq_tag) {\n\t\tString label = null;\n\t\tAlignmentGlyph aglyph = (AlignmentGlyph)seq_tag;\n\t\tif (aglyph == cons_glyph) {\n\t\t\tlabel = consensus_name;\n\t\t}\n\t\telse {\n\t\t\tlabel = labelhash.get(aglyph).getString();\n\t\t}\n\t\treturn label;\n\t}\n",
    "133345": "\tpublic void setBounds(int axis, int start, int end) {\n\t\tsuper.setBounds(axis, start, end);\n\t\tRectangle2D.Double mbox = getScene().getGlyph().getCoordBox();\n\n\t\tif ((axis != X) || (tiers == null))\n\t\t\treturn;\n\n\t\tfor (int i=0; i<tiers.size(); i++) {\n\t\t\tMapTierGlyph tier = tiers.get(i);\n\t\t\tRectangle2D.Double tbox = tier.getCoordBox();\n\t\t\ttier.setCoords(mbox.x, tbox.y, mbox.width, tbox.height);\n\t\t}\n\t}\n",
    "133348": "\tpublic void removeTier (MapTierGlyph toRemove) {\n\n\t\t// First, see if we've got such a tier\n\n\t\tif (!tiers.contains(toRemove))\n\t\t\treturn;\n\n\t\t// Then tell our listeners to remove the corresponding tier\n\n\t\tTierEvent te = new TierEvent (this, TierEvent.REMOVE, toRemove);\n\t\tnotifyTierEventListeners (te);\n\n\t\t// Remove the tier's children\n\n\t\ttoRemove.removeChildren();\n\n\t\t// Finally, remove our own\n\n\t\ttiers.remove (toRemove);\n\n\t\trepack ();\n\t\tupdateWidget();\n\n\t\t// remove ourself from the tier's audience\n\n\t\ttoRemove.removeTierStateChangeListener (this);\n\t}\n",
    "133349": "\tpublic void moveTier( int from, int to ) {\n\t\tfrom = Math.max( from, 0 );\n\t\tto = Math.min( to, tiers.size()-1 );\n\t\tif ( from == to ) { // null operation\n\t\t\treturn;\n\t\t}\n\t\tMapTierGlyph mtg = tiers.get( from );\n\t\ttiers.remove( from );\n\t\ttiers.add( to, mtg );\n\n\t\trepack();\n\t\tupdateWidget();\n\n\n\t}\n",
    "133351": "\tprotected void moveTiers (AbstractTieredMap otherMap, int[] tierLocs) {\n\n\t\tint from,to;\n\t\t// First do ourself:\n\t\tfrom = Math.max( tierLocs[0], 0 );\n\t\tto = Math.min( tierLocs[0], tiers.size()-1 );\n\t\tif ( from == to ) { // null operation\n\t\t\treturn;\n\t\t}\n\t\tMapTierGlyph mtg = tiers.get( from );\n\t\ttiers.remove( from );\n\t\ttiers.add( to, mtg );\n\n\t\t// Then do the other map:\n\t\tmtg = otherMap.tiers.get(tierLocs[0]);\n\t\tif (mtg == null)\n\t\t\treturn; // Why isn't an exception thrown?\n\t\totherMap.tiers.remove(from);\n\t\totherMap.tiers.add(to, mtg);\n\n\t}\n",
    "133352": "\tprotected void removeCorrTier (AbstractTieredMap otherMap, MapTierGlyph otherTier) {\n\n\t\t// Figure out which one of our tiers corresponds,\n\n\t\tint loc = otherMap.indexOf (otherTier);\n\n\t\tif ((loc < 0) || loc > tiers.size())\n\t\t\treturn;\n\n\t\t// Remove the tier's children\n\n\t\tMapTierGlyph toRemove = tiers.get(loc);\n\n\t\ttoRemove.removeChildren();\n\n\t\t// Then the tier itself!\n\n\t\ttiers.remove(toRemove);\n\n\t\tpackTiers(true,true);\n\t\tupdateWidget();\n\n\t\t// remove ourself from the tier's audience\n\n\t\ttoRemove.removeTierStateChangeListener (this);\n\n\t}\n",
    "133356": "\tpublic int getCoordResidue(double xcoord, double ycoord) {\n\t\tRectangle2D.Double visible_box = residue_map.getView().calcCoordBox();\n\n\t\tif (xcoord < 0) {\n\t\t\txcoord = 0;\n\t\t}\n\n\t\tif (xcoord > residues_per_line) {\n\t\t\txcoord = residues_per_line;\n\t\t}\n\n\t\tint yoff = (int)(ycoord - visible_box.y);\n\t\tint residue =\n\t\t\t(int)(yoff - (yoff % residues_per_line) + xcoord + visible_box.y);\n\n\t\tRange r = getVisibleRange();\n\n\t\tif (r.end < residue && r.end <= this.seq.getLength()) {\n\t\t\tresidue = r.end;\n\t\t}\n\n\t\tif (residue > this.seq.getLength()) {\n\t\t\tresidue = this.seq.getLength();\n\t\t\tif ( this.isEditable() )\n\t\t\t\tresidue++;\n\t\t}\n\n\t\tif ( residue < 0) {\n\t\t\tresidue = 0;\n\t\t}\n\t\treturn residue;\n\t}\n",
    "133363": "\tpublic void clearSelection() {\n\t\tsel_range.clear();\n\t\tsel_range.notifyObservers();\n\t\tsetResiduesSelected(false);\n\t}\n",
    "133366": "\tpublic void configureLayout(int component, int placement) {\n\t    //\t    System.out.println(\"in NeoAssembler.configureLayout()\");\n\t\tif (component == AXIS_SCROLLER) {\n\t\t\thscroll_loc = placement;\n\t\t}\n\t\telse if (component == OFFSET_SCROLLER) {\n\t\t\tvscroll_loc = placement;\n\t\t}\n\t\telse if (component == CONSENSUS) {\n\t\t\tcons_loc = placement;\n\t\t}\n\t\telse if (component == LABELS) {\n\t\t\tlabel_loc = placement;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"unknown component\");\n\t\t}\n\t\tdoLayout();\n\t\t// trying to fix paint issues when configuring layout\n\t\tContainer parent = getParent();\n\t\tif (parent instanceof NeoPanel) {\n\t\t\t((NeoPanel)parent).forceBackgroundFill();\n\t\t}\n\t\trepaint();\n\t}\n",
    "133381": "\tpublic GlyphI addItem(MapGlyphFactory factory, int start, int end) {\n\t\tString nullstring = null;\n\t\treturn addItem(factory, start, end, nullstring);\n\t}\n",
    "133382": "\tpublic String getFontName() {\n\t\treturn residue_font.getFamily();\n\t}\n",
    "133384": "\tprotected int getSortedPosition(Comparable<AlignmentGlyph> elem, List<GlyphI> vec) {\n\t\tif (vec == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tint max = vec.size();\n\t\tfor (int i=0; i<max; i++) {\n\t\t\tif (vec.get(i) instanceof AlignmentGlyph && elem.compareTo((AlignmentGlyph)vec.get(i)) < 0) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n",
    "133387": "\tpublic void setFontName(String name) {\n\t\tFont new_font = new Font(name, residue_font.getStyle(), residue_font.getSize());\n\t\tsetFont(new_font);\n\t}\n",
    "133388": "\tpublic void configureLayout(int component, int placement) {\n\t}\n",
    "133390": "\tpublic int getPlacement(int component) {\n\t\treturn PLACEMENT_NONE;\n\t}\n",
    "133392": "\tpublic int getFontSize() {\n\t\treturn residue_font.getSize();\n\t}\n",
    "133393": "\tpublic void setFloatBounds(int id, double start, double end) {\n\t\tdouble size = end - start;\n\t\tRectangle2D.Double sbox = scene.getCoordBox();\n\t\tif (id == X) {\n\t\t\tscene.setCoords(start, sbox.y, size, sbox.height);\n\t\t}\n\t\telse {\n\t\t\tscene.setCoords(sbox.x, start, sbox.width, size);\n\t\t}\n\t\tadjustScroller(id);\n\t}\n",
    "133396": "\tpublic void setBounds(int id, int start, int end) {\n\t\tdouble size = end-start+1;\n\t\tRectangle2D.Double sbox = scene.getCoordBox();\n\t\tif (id == X) {\n\t\t\tscene.setCoords(start, sbox.y, size, sbox.height);\n\t\t}\n\t\telse {\n\t\t\tscene.setCoords(sbox.x, start, sbox.width, size);\n\t\t}\n\t\tadjustScroller(id);\n\t}\n",
    "133397": "\tpublic void setFontSize(int size) {\n\t\tFont new_font = new Font(residue_font.getFamily(), residue_font.getStyle(), size);\n\t\tsetFont(new_font);\n\t}\n",
    "133398": "\tpublic List getVisibleItems() {\n\t\t// SHOULD THIS BE getViewBounds() INSTEAD!!??!!!\n\t\t//    WHICH GLYPHS DO WE REALLY WANT TO RETURN????\n\t\tRectangle2D.Double coordrect = getCoordBounds();\n\t\tList<GlyphI> pickvect = new ArrayList<GlyphI>();\n\t\tscene.pickTraversal(coordrect, pickvect, view);\n\t\treturn pickvect;\n\t}\n",
    "133399": "\tpublic GlyphI addItem(GlyphI parent, GlyphI child) {\n\t\tparent.addChild(child);\n\t\treturn null;\n\t}\n",
    "133400": "\tpublic void setSelectionEvent(int theEvent) {\n\t\talignmap.setSelectionEvent(theEvent);\n\t\tconsmap.setSelectionEvent(theEvent);\n\t\tlabelmap.setSelectionEvent(theEvent);\n\t}\n",
    "133402": "\tpublic void setResidueMultipleConstraint(int i) {\n\t\tif (i>0) {\n\t\t\tresidue_multiple_constraint = i;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"can't constrain below 1.\");\n\t\t}\n\t}\n",
    "133406": "\tpublic int getResidueMultipleConstraint() {\n\t\treturn residue_multiple_constraint;\n\t}\n",
    "133408": "\tpublic void updateWidget() {\n\t\tupdateWidget(false);\n\t}\n",
    "133409": "\tpublic void setRangeScroller(JScrollBar nscroll) {\n\t\tsetScroller(X, nscroll);\n\t}\n",
    "133410": "\tpublic void setStripeWidth(int i) {\n\t\tif (i >= 0) {\n\t\t\tresidue_stripe_width = i;\n\t\t\tgetResidueGlyph().setStripeWidth(residue_stripe_width);\n\t\t\tupdateWidget();\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"stripes can't be narrower than 0.\");\n\t\t}\n\t}\n",
    "133411": "\tpublic void updateWidget(boolean full_update) {\n\t\tif (canvas == null) return; // in case destroy() was called.\n\t\tif (full_update) {\n\t\t\tscene.maxDamage();\n\t\t}\n\t\tcanvas.repaint();\n\t}\n",
    "133415": "\tpublic int getStripeWidth() {\n\t\treturn residue_stripe_width;\n\t}\n",
    "133422": "\tpublic int getStripeOrientation() {\n\t\treturn getResidueGlyph().getStripeOrientation();\n\t}\n",
    "133426": "\tprotected void setPixelBounds() {\n\t\tif (canvas == null) return; // in case destroy() was called.\n\t\tpixel_beg[X] = 0;\n\t\tpixel_beg[Y] = 0;\n\t\tpixel_size[X] = canvas.getSize().width;\n\t\tpixel_size[Y] = canvas.getSize().height;\n\n\t\tpixel_end[X] = pixel_size[X] - pixel_beg[X];\n\t\tpixel_end[Y] = pixel_size[Y] - pixel_beg[Y];\n\n\t\tRectangle bbox = new Rectangle(pixel_beg[X], pixel_beg[Y],\n\t\t\t\tpixel_size[X], pixel_size[Y]);\n\t\tview.setPixelBox(bbox);\n\t}\n",
    "133431": "\tprotected RootGlyph createRootGlyph() {\n\t\treturn new RootGlyph();\n\t}\n",
    "133439": "\tprivate void selectLabel( double offset ) {\n\t\tList<GlyphI> v = this.labelmap.getItems( 10, offset );\n\t\tfor ( int i = 0; i < v.size(); i++ ) {\n\t\t\tGlyphI o = v.get( i );\n\t\t\tif ( o instanceof StringGlyph ) {\n\t\t\t\tStringGlyph g = ( StringGlyph ) o;\n\t\t\t\tthis.labelmap.select( g );\n\t\t\t\tString s = g.getString();\n\t\t\t\tfireItemEvent( new ItemEvent( this,\n\t\t\t\t\t\t\tItemEvent.ITEM_STATE_CHANGED,\n\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\tItemEvent.SELECTED ) );\n\t\t\t}\n\t\t}\n\t}\n",
    "133442": "\tpublic void setSpacing(int size) {\n\t\tif (size < 0) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"spacing cannot be set to less than 0.\");\n\t\t}\n\t\tgetResidueGlyph().setSpacing(size);\n\t\tgetNumGlyph().setSpacing(size);\n\t\tstretchToFit(false,false);\n\t\tupdateWidget();\n\t}\n",
    "133449": "\tpublic void setDamageOptimized(boolean optimize_damage) {\n\t\tthis.optimize_damage = optimize_damage;\n\t\tsetOptimizations();\n\t}\n",
    "133450": "\tpublic void setStripeColors(Color[] colors) {\n\t\tgetResidueGlyph().setStripeColors(colors);\n\t}\n",
    "133456": "\tpublic void setResidueColor(Color color) {\n\t\tgetResidueGlyph().setColor(color);\n\t\tgetNumGlyph().setColor(color);\n\t\tupdateWidget();\n\t}\n",
    "133460": "\tpublic Color getResidueColor() {\n\t\treturn getResidueGlyph().getColor();\n\t}\n",
    "133471": "\tpublic boolean isTransientOptimized() {\n\t\treturn optimize_transients;\n\t}\n",
    "133475": "\tpublic void select(GlyphI g) {\n\t\tscene.select(g);\n\t\tif ( g.isSelected() && !selected.contains(g)) {\n\t\t\tselected.add(g);\n\t\t}\n\t}\n",
    "133490": "\tpublic void setScaleConstraint(int axisid, int constraint) {\n\t\tscale_constraint[axisid] = constraint;\n\t}\n",
    "133518": "\tpublic boolean getAutoSort() {\n\t\treturn auto_sort;\n\t}\n",
    "133519": "\tpublic boolean residuesSelected() {\n\t\treturn residues_selected;\n\t}\n",
    "133522": "\tpublic void setAutoSort(boolean sort) {\n\t\tauto_sort = sort;\n\t\tif (auto_sort) {\n\t\t\tif (all_sorted == false) {\n\t\t\t\tif (cglyph.getChildren() != null) {\n\t\t\t\t\t//QuickSorter.sort(cglyph.getChildren());\n\t\t\t\t\tCollections.sort(cglyph.getChildren(), comparatorHack);\n\t\t\t\t\tpack();\n\t\t\t\t\tall_sorted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "133527": "\tpublic void pack()  {\n\t\tif (cglyph == null || alignmap == null)  {\n\t\t\treturn;\n\t\t}\n\t\tViewI pack_view = alignmap.getView();\n\t\tList align_glyphs = cglyph.getChildren();\n\t\tif (pack_view == null || align_glyphs == null) {\n\t\t\treturn;\n\t\t}\n\t\tcglyph.pack(pack_view);\n\n\t\tRectangle2D.Double cbox = cglyph.getCoordBox();\n\t\talignmap.setMapOffset((int)cbox.y, (int)(cbox.y + cbox.height));\n\t\tlabelmap.setMapOffset((int)cbox.y, (int)(cbox.y + cbox.height));\n\t\tmoveLabels();\n\t}\n",
    "133529": "\tpublic void addItem(GlyphI gl) {\n\t\tif (gl != null) {\n\t\t\tScene glyph_scene = gl.getScene();\n\t\t\tif (glyph_scene == null) {\n\t\t\t\tscene.addGlyph(gl);\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"must remove item from previous \"\n\t\t\t\t\t\t+ \"map before adding it to new map\");\n\t\t\t}\n\t\t}\n\t}\n",
    "133530": "\tpublic void setSubSelectionAllowed(boolean allowed) {\n\t}\n",
    "133531": "\tpublic boolean isSubSelectionAllowed() {\n\t\treturn false;\n\t}\n",
    "133545": "\tpublic boolean isUnObscured(GlyphI gl) {\n\t\treturn (isFullyWithinView(gl) && isOnTop(gl));\n\t}\n",
    "133550": "\tpublic void configure(String options) {\n\t\tdefault_factory.configure(options);\n\t}\n",
    "133555": "\tpublic void configure(Hashtable<String, Object> options) {\n\t\tdefault_factory.configure(options);\n\t}\n",
    "133557": "\tprotected void setCheckZoomValue(boolean b) {\n\t\tcheckZoomValue = b;\n\t}\n",
    "133559": "\tpublic Font getResidueFont() {\n\t\treturn residue_font;\n\t}\n",
    "133560": "\tpublic boolean getCheckZoomValue() {\n\t\treturn checkZoomValue;\n\t}\n",
    "133562": "\tprotected void setCheckScrollValue(boolean b) {\n\t\tcheckScrollValue = b;\n\t}\n",
    "133563": "\tpublic void setMaxZoomToFont(Font fnt) {\n\t\tfont_for_max_zoom = fnt;\n\t\tseqmetrics = GeneralUtils.getFontMetrics(font_for_max_zoom);\n\t\tint font_width = seqmetrics.charWidth('C');\n\t\tsetMaxZoom(X, font_width);\n\t}\n",
    "133564": "\tpublic void zoom(int id, double zoom_scale) {\n\t\tif (id == X) {\n\t\t\talignmap.zoom(id, zoom_scale);\n\t\t\tconsmap.zoom(id, zoom_scale);\n\t\t}\n\t\telse if (id == Y)  {\n\t\t\talignmap.zoom(id, zoom_scale);\n\t\t\tlabelmap.zoom(id, zoom_scale);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"NeoAssembler.zoom() id argument \" +\n\t\t\t\t\t\"must be either NeoAssembler.X or NeoAssembler.Y\");\n\t\t}\n\t}\n",
    "133565": "\tpublic boolean getCheckScrollValue() {\n\t\treturn checkScrollValue;\n\t}\n",
    "133567": "\tpublic void heardDragEvent(NeoDragEvent evt) {\n\t\tif (!drag_scrolling_enabled) {\n\t\t\treturn;\n\t\t}\n\t\tObject src = evt.getSource();\n\t\tint direction = evt.getDirection();\n\t\tif (src == canvas_drag_monitor) {\n\t\t\tdrag(direction, 10);\n\t\t}\n\t}\n",
    "133588": "\tpublic void setShow(int type, boolean show) {\n\t\tif (showAs[type] == show)  { return; }\n\t\tshowAs[type] = show;\n\t\tresidue_glyph.setShow(type, show);\n\t\tnum_glyph.setShow(type, show);\n\t\t// calling stretchToFit to force adjustment of vertical scrollbar\n\t\tstretchToFit(false,false);\n\t}\n",
    "133592": "\tpublic void setResidueRange( boolean isResidueRange ) {\n\t\tif ( isResidueRange == this.isRR ) return; // It was already thus.\n\t\tthis.isRR = isResidueRange;\n\t}\n",
    "133595": "\tpublic void rangeChanged( NeoRangeEvent evt ) {\n\t\tint st = (int) evt.getVisibleStart();\n\t\tint en = (int) evt.getVisibleEnd();\n\t\tsetRange(st, en);\n\t}\n",
    "133597": "\tpublic void shadowForReverse(long residueCount) {\n\t\tthis.labelForReverse = true;\n\t\tthis.residueCount = residueCount;\n\t}\n",
    "133603": "\tpublic void widgetCleared( NeoWidgetEvent e ) {\n\t\t( ( NeoWidgetListener ) this.a ).widgetCleared( e );\n\t\t( ( NeoWidgetListener ) this.b ).widgetCleared( e );\n\t}\n",
    "133610": "\tpublic Object clone() {\n\t\tObject o = null;\n\t\ttry {\n\t\t\to = super.clone();\n\t\t\tVisibleRange vr = ( VisibleRange ) o;\n\t\t\tvr.listeners = new CopyOnWriteArraySet<NeoRangeListener>();\n\t\t\tvr.changed = false;\n\t\t} catch ( CloneNotSupportedException e ) {\n\t\t}\n\t\treturn o;\n\t}\n",
    "133612": "\tpublic void setSpot( double thePlace ) {\n\t\tif ( debug ) new RuntimeException (\"setSpot in VisibleRange: \" + (int)thePlace).printStackTrace();\n\t\tdouble before = Math.floor( thePlace );\n\t\tsetBeginning( before );\n\t\tdouble after = Math.ceil( thePlace );\n\t\tif ( before == after ) after++;\n\t\tsetEnd( after );\n\t\tnotifyListeners();\n\t}\n",
    "133614": "\tpublic boolean getShow(int type) {\n\t\treturn showAs[type];\n\t}\n",
    "133615": "\tpublic void notifyListeners( boolean checkIfChanged ) {\n\t\tif ( this.changed |! checkIfChanged ) {\n\t\t\tthis.changed = false; // Needs to be done before notifying listeners to avoid possible loops.\n\t\t\tNeoRangeEvent evt = new NeoRangeEvent( this, this.beginning, this.end );\n\t\t\tfor (NeoRangeListener l : this.listeners) {\n\t\t\t\tl.rangeChanged( evt );\n\t\t\t}\n\t\t}\n\t}\n",
    "133639": "\tpublic void setRevNumbering (boolean revNums) {\n\t\tif (num_glyph == null)\n\t\t\treturn;\n\n\t\tnum_glyph.setRevNumbering(revNums);\n\t}\n",
    "133645": "\tpublic void removeChildren() {\n\t\tif (children != null) {\n\t\t\tchildren.clear();\n\t\t\tchildren = null;\n\t\t}\n\t\tglyphsInSearchTree.clear();\n\t\tif (l != null) { l.removeChildren(); l=null;}\n\t\tif (r != null) { r.removeChildren(); r=null;}\n\t}\n",
    "133663": "\tpublic boolean getRevNumbering () {\n\t\tif (num_glyph == null)\n\t\t\treturn false;\n\n\t\treturn num_glyph.getRevNumbering();\n\t}\n",
    "133678": "\tpublic void setReshapeBehavior(int id, int behavior) {\n\t\treshape_constraint[id] = behavior;\n\t\talignmap.setReshapeBehavior(id, behavior);\n\t\tif (id == X) {\n\t\t\tconsmap.setReshapeBehavior(id, behavior);\n\t\t}\n\t\telse if (id == Y) {\n\t\t\tlabelmap.setReshapeBehavior(id, behavior);\n\t\t}\n\t}\n",
    "133687": "\tpublic void restoreState() {\n\t\tif (state==HIDDEN) setState(stateBeforeHidden);\n\t}\n",
    "133696": "\tpublic void setOutlineColor(Color color) {\n\t\toutline_color = color;\n\t}\n",
    "133697": "\tpublic Color getOutlineColor() {\n\t\treturn outline_color;\n\t}\n",
    "133707": "\tprotected void fireNeoWidgetEvent(NeoWidgetEvent e) {\n\t\tif (null != listeners) {\n\t\t\tlisteners.widgetCleared(e);\n\t\t}\n\t}\n",
    "133712": "\tpublic void setLabelColor(Color color) {\n\t\tlabel_color = color;\n\t\tif (label_color != null) super.setForegroundColor(color);\n\t}\n",
    "133714": "\tpublic Color getLabelColor() {\n\t\treturn label_color;\n\t}\n",
    "133715": "\tpublic void setHitable(boolean h) {\n\t\thitable = h;\n\t}\n",
    "133719": "\tpublic void setHideable(boolean h) {\n\t\tthis.hideable = h;\n\t}\n",
    "133721": "\tpublic void setRange(int start, int end) {\n\t\tthis.range = new Range(start, end);\n\t\tbar_map.setMapRange(start, end);\n\t\tbase_map.setMapRange(start, end);\n\t}\n",
    "133722": "\tpublic boolean isHideable() {\n\t\treturn this.hideable;\n\t}\n",
    "133725": "\tpublic void setShowLabel(boolean s) {\n\t\tshowLabel = s;\n\t}\n",
    "133727": "\tpublic boolean isShowLabel() {\n\t\treturn showLabel;\n\t}\n",
    "133729": "\tpublic void removeAllTierStateChangeListeners() {\n\t\ttierStateChangeListeners.clear();\n\t}\n",
    "133731": "\tpublic void addTierStateChangeListener(TierStateChangeListener tl) {\n\t\ttierStateChangeListeners.add(tl);\n\t}\n",
    "133733": "\tpublic boolean isFullyWithinView(GlyphI gl) {\n\t\tif ((gl instanceof AnnotationGlyph) && (getWidget(gl) == residue_map)) {\n\t\t\tRange vis_range = getVisibleRange();\n\t\t\tRange glyph_range = getAnnotationRange(gl);\n\t\t\treturn glyph_range.within(vis_range);\n\t\t}\n\t\telse  {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "133734": "\tpublic void removeTierStateChangeListener(TierStateChangeListener tl) {\n\t\ttierStateChangeListeners.remove(tl);\n\t}\n",
    "133736": "\tpublic void notifyTierStateChangeListeners(TierStateChangeEvent evt) {\n\t\tfor (TierStateChangeListener tl : tierStateChangeListeners) {\n\t\t\ttl.heardTierStateChangeEvent(evt);\n\t\t}\n\t}\n",
    "133738": "\tpublic String getStateString() {\n\t\treturn getStateString(getState());\n\t}\n",
    "133742": "\tpublic void addTier(MapTierGlyph mtg) {\n\t\taddTier(mtg, false);\n\t}\n",
    "133743": "\tpublic void centerAtBase(int baseNum) {\n\t\t// if baseNum is too big, set to last base in read\n\t\tif (baseNum > read_length) {\n\t\t\tbaseNum = read_length ;\n\t\t}\n\t\tdouble xcenter = baseNum;\n\t\tRectangle2D.Double viewbox = bar_map.getView().getCoordBox();\n\t\tdouble xstart = xcenter - viewbox.width/2;\n\n\t\tscrollRange((int)xstart);\n\t\tupdateWidget();\n\t}\n",
    "133744": "\tpublic void packTiers(boolean full_repack, boolean stretch_map)  {\n\t\tif (full_repack) {\n\t\t}\n\t\tsuper.packTiers(full_repack, stretch_map);\n\t}\n",
    "133745": "\tpublic boolean isPartiallyWithinView(GlyphI gl) {\n\t\tif ((gl instanceof AnnotationGlyph) && (getWidget(gl) == residue_map)) {\n\t\t\tRange vis_range = getVisibleRange();\n\t\t\tRange glyph_range = getAnnotationRange(gl);\n\t\t\treturn glyph_range.overlaps(vis_range);\n\t\t}\n\t\telse  {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "133746": "\tpublic void addTier(MapTierGlyph mtg, boolean ontop) {\n\t\tif (mtg == null)\n\t\t\treturn;\n\t\tint evtid;\n\t\tthis.addItem(mtg);\n\t\t// Use packTiers() rather than repack(), 'cause repack would\n\t\t// generate a TierEvent and any label maps will be out of sync\n\t\t// without the TierEvent.ADD below\n\n\t\tif (ontop) {\n\t\t\ttiers.add(0, mtg);\n\t\t\tevtid = TierEvent.ADD_TOP;\n\t\t}\n\t\telse {\n\t\t\ttiers.add(mtg);\n\t\t\tevtid = TierEvent.ADD_BOTTOM;\n\t\t}\n\n\t\tmtg.addTierStateChangeListener (this);\n\t\tTierEvent te = new TierEvent (this, evtid, mtg);\n\t\tthis.notifyTierEventListeners(te);\n\t}\n",
    "133763": "\tpublic void update(Observable theObserved, Object theArgument) {\n\t\tif (theObserved instanceof Selection) {\n\t\t\tupdate((Selection)theObserved);\n\t\t}\n\t}\n",
    "133764": "\tpublic void setSelectionColor( Color c ) {\n\t\tTraceGlyph.selColor = c;\n\t\tthis.sel_color = c;\n\t\tif (sel_glyph != null) {\n\t\t\tsel_glyph.setColor(sel_color);\n\t\t}\n\t}\n",
    "133769": "\tpublic void selectBases(int start, int end) {\n\t\thighlightBars(start,end);\n\t\thighlightBases(start,end);\n\n\t\t// Make sure the at least part of the selection is visible.\n\t\tRange r = getVisibleRange();\n\t\tif (end < r.beg || r.end < start) {\n\t\t\tif (end < r.beg) {\n\t\t\t\tscrollRange(start);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscrollRange(end);\n\t\t\t}\n\t\t}\n\n\t}\n",
    "133773": "\tpublic void highlightBars(int start, int end) {\n\t\tbar_glyph.select(start,end);\n\t\tupdateWidget();\n\t}\n",
    "133779": "\tpublic void highlightBases(int start, int end) {\n\t\tbase_glyph.select(start,end);\n\t\tupdateWidget();\n\t}\n",
    "133791": "\tpublic Adjustable getScroller() {\n\t\treturn offset_scroll;\n\t}\n",
    "133797": "\tpublic void clearSelection() {\n\t\tbar_glyph.clearSelection();\n\t\tbase_glyph.clearSelection();\n\t}\n",
    "133802": "\tpublic void select (double start, double end) {\n\t\tselect((int)start, (int)end);\n\t}\n",
    "133803": "\tpublic void select(int start, int end) {\n\t\tif (sel_glyph == null) {\n\t\t\tsel_glyph = new OutlineRectGlyph();\n\t\t\tsel_glyph.setForegroundColor(sel_color);\n\t\t\taddChild(sel_glyph, 0);\n\t\t}\n\t\tRectangle2D.Double cb = getCoordBox();\n\t\t// Why are we adding to cb.y? Why was 5 added to cb.y and cb.height? elb 1999-12-02\n\t\tsel_glyph.setCoords( start, cb.y, end-start + 1, cb.height );\n\t}\n",
    "133804": "\tpublic void setScroller(JScrollBar scroller) {\n\n\t\tif (!(scroller instanceof Component) || (scroller == null))\n\t\t\treturn;\n\n\t\tremove((Component)offset_scroll);\n\t\toffset_scroll = scroller;\n\t\tadd ((Component)scroller);\n\n\t\tresidue_map.setOffsetScroller(offset_scroll);\n\t\tnum_map.setOffsetScroller(offset_scroll);\n\t}\n",
    "133824": "\tpublic void enableDragScrolling(boolean enable) {\n\t\tdrag_scrolling_enabled = enable;\n\t\tif (drag_scrolling_enabled) { // drag scrolling turned on\n\t\t\tif (residue_drag_monitor != null) {\n\t\t\t\tresidue_drag_monitor.removeDragListener(this);\n\t\t\t}\n\t\t\t// DragMonitor constructor also adds itself as listener to canvas\n\t\t\tresidue_drag_monitor = new DragMonitor(residue_canvas);\n\t\t\tresidue_drag_monitor.addDragListener(this);\n\t\t}\n\t\telse {  // drag scrolling turned off\n\t\t\tif (residue_drag_monitor != null) {\n\t\t\t\tresidue_drag_monitor.removeDragListener(this);\n\t\t\t}\n\t\t\tresidue_drag_monitor = null;\n\t\t}\n\t}\n",
    "133845": "\tpublic void setInternalZoomer (Adjustable adjustable) {\n\n\t\tif (!(adjustable instanceof Component) || (adjustable == null))\n\t\t\treturn;\n\n\t\tremove ((Component)hzoom);\n\t\thzoom = adjustable;\n\t\tadd    ((Component)hzoom);\n\n\t\talignmap.setZoomer(X, hzoom);\n\t\tconsmap.setZoomer (X, hzoom);\n\t}\n",
    "133847": "\tpublic void setBasesTrimmedLeft(int theBasesTrimmed) {\n\t\tthis.leftTrim = theBasesTrimmed;\n\t\tRectangle2D.Double coordbox = bar_glyph.getCoordBox();\n\t\tif (left_trim_glyph != null) {\n\t\t\tbar_glyph.removeChild(left_trim_glyph);\n\t\t}\n\t\tleft_trim_glyph = new FillRectGlyph();\n\t\tleft_trim_glyph.setColor(trim_color);\n\t\tleft_trim_glyph.setCoords(coordbox.x, coordbox.y,\n\t\t\t\ttheBasesTrimmed, coordbox.height);\n\t\tbar_glyph.addChild(left_trim_glyph);\n\t\tbar_map.toBack(left_trim_glyph);\n\t}\n",
    "133852": "\tpublic void setBasesTrimmedRight(int theBasesTrimmed) {\n\t\tthis.rightTrim = theBasesTrimmed;\n\t\tRectangle2D.Double coordbox = bar_glyph.getCoordBox();\n\t\tif (right_trim_glyph != null) {\n\t\t\tbar_glyph.removeChild(right_trim_glyph);\n\t\t}\n\t\tright_trim_glyph = new FillRectGlyph();\n\t\tright_trim_glyph.setColor(trim_color);\n\t\tright_trim_glyph.setCoords(\n\t\t\t\tcoordbox.x + coordbox.width - theBasesTrimmed,\n\t\t\t\tcoordbox.y,\n\t\t\t\ttheBasesTrimmed,\n\t\t\t\tcoordbox.height);\n\t\tbar_glyph.addChild(right_trim_glyph);\n\t\tbar_map.toBack(right_trim_glyph);\n\t}\n",
    "133854": "\tpublic Adjustable getInternalZoomer () {\n\t\treturn hzoom;\n\t}\n",
    "133858": "\tprivate void refreshSequence(Sequence theSeq) {\n\n\t\tthis.seq.setResidues(theSeq.getResidues());\n\n\t\tgetResidueGlyph().setSequence(this.seq);\n\t\tgetNumGlyph().setSequence(this.seq);\n\n\t\tresidue_map.scrollRange(0);\n\t\tresidue_map.zoomRange(getResiduePixelWidth());\n\t\tnum_map.scrollRange(0);\n\n\t\tstretchToFit(false,false);\n\n\t\t// Why is it needed at all? It screws up editing. -- elb 3/16/99\n\n\t\tcalcNumPixelWidth();\n\n\t\tupdateWidget();\n\t}\n",
    "133862": "\tpublic void setUseLabelArrows(boolean use_label_arrows) {\n\t\tthis.use_label_arrows = use_label_arrows;\n\t}\n",
    "133865": "\tpublic void sequenceChanged( SequenceEvent e ) {\n\n\t\tSequence s = (Sequence)e.getSource();\n\n\t\t// This shouldn't change the sequence.\n\t\trefreshSequence(s);\n\t\t// why doesn't this display changed sequence?\n\t\tif ( null != this.caret ) {\n\t\t\tthis.caret.setCoords ( 0, 0, residues_per_line, seq_map_size );\n\t\t}\n\n\t}\n",
    "133887": "\tpublic boolean getUseLabelArrows() {\n\t\treturn use_label_arrows;\n\t}\n",
    "133892": "\tpublic void setExpansionBehavior(int axisid, int behavior) {\n\t\tif (!(NeoAbstractWidget.X == axisid || NeoAbstractWidget.Y == axisid))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can set behavior for X (\"+NeoAbstractWidget.X\n\t\t\t\t\t+\") or Y (\"+NeoAbstractWidget.Y+\") axis. \"\n\t\t\t\t\t+\"Not for \"+ axisid);\n\t\tif (!(NeoAbstractWidget.EXPAND == behavior || NeoAbstractWidget.NO_EXPAND == behavior))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can only set behavior to EXPAND or NO_EXPAND\");\n\t\tfor (NeoAbstractWidget widg : widgets) {\n\t\t\twidg.setExpansionBehavior(axisid, behavior);\n\t\t}\n\t}\n",
    "133898": "\tpublic int getExpansionBehavior(int axisid) {\n\t\tif (!(NeoAbstractWidget.X == axisid || NeoAbstractWidget.Y == axisid))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Can get behavior for X (\"+NeoAbstractWidget.X+\") or Y (\"\n\t\t\t\t\t+NeoAbstractWidget.Y+\") axis. \"\n\t\t\t\t\t+\"Not for \"+ axisid);\n\t\t// The following will throw an exception if widgets is empty.\n\t\t// This will do until we find out (and formalize) the default.\n\t\treturn widgets.get(0).getExpansionBehavior(axisid);\n\t}\n",
    "133909": "\tpublic boolean isSubSelectionAllowed() {\n\t\treturn subSelectionAllowed;\n\t}\n",
    "133910": "\tpublic void setLabelWidth(int label_width) {\n\t\tthis.label_width = label_width;\n\t\tlabelmap.setBounds(NeoMap.X, 0, label_width-1);\n\t\tdoLayout();\n\t}\n",
    "133911": "\tpublic void setSubSelectionAllowed(boolean allowed) {\n\t\tsubSelectionAllowed = allowed;\n\t}\n",
    "133947": "\tpublic Border getBorder() {\n\t\tBorder b = border;\n\t\tif (b == null) {\n\t\t\tb = UIManager.getBorder(\"TitledBorder.border\");\n\t\t}\n\t\treturn b;\n\t}\n",
    "133949": "\tpublic int getTitlePosition() {\n\t\treturn titlePosition;\n\t}\n",
    "133952": "\tpublic int getTitleJustification() {\n\t\treturn titleJustification;\n\t}\n",
    "133955": "\tpublic Font getTitleFont() {\n\t\tFont f = titleFont;\n\t\tif (f == null) {\n\t\t\tf = UIManager.getFont(\"TitledBorder.font\");\n\t\t}\n\t\treturn f;\n\t}\n",
    "133957": "\tpublic Color getTitleColor() {\n\t\tColor c = titleColor;\n\t\tif (c == null) {\n\t\t\tc = UIManager.getColor(\"TitledBorder.titleColor\");\n\t\t}\n\t\treturn c;\n\t}\n",
    "133962": "\tpublic void setBorder(Border border) {\n\t\tthis.border = border;\n\t}\n",
    "133963": "\tpublic void setTitlePosition(int titlePosition) {\n\t\tswitch (titlePosition) {\n\t\t\tcase ABOVE_TOP:\n\t\t\tcase TOP:\n\t\t\tcase BELOW_TOP:\n\t\t\tcase ABOVE_BOTTOM:\n\t\t\tcase BOTTOM:\n\t\t\tcase BELOW_BOTTOM:\n\t\t\tcase DEFAULT_POSITION:\n\t\t\t\tthis.titlePosition = titlePosition;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(titlePosition\n\t\t\t\t\t\t+ \" is not a valid title position.\");\n\t\t}\n\t}\n",
    "133965": "\tpublic void setTitleJustification(int titleJustification) {\n\t\tswitch (titleJustification) {\n\t\t\tcase DEFAULT_JUSTIFICATION:\n\t\t\tcase LEFT:\n\t\t\tcase CENTER:\n\t\t\tcase RIGHT:\n\t\t\tcase LEADING:\n\t\t\tcase TRAILING:\n\t\t\t\tthis.titleJustification = titleJustification;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(titleJustification\n\t\t\t\t\t\t+ \" is not a valid title justification.\");\n\t\t}\n\t}\n",
    "133968": "\tpublic void setTitleFont(Font titleFont) {\n\t\tthis.titleFont = titleFont;\n\t}\n",
    "133971": "\tpublic void setTitleColor(Color titleColor) {\n\t\tthis.titleColor = titleColor;\n\t}\n",
    "133973": "\tpublic Dimension getMinimumSize(Component c) {\n\t\tInsets insets = getBorderInsets(c);\n\t\tDimension minSize = new Dimension(insets.right + insets.left,\n\t\t\t\tinsets.top + insets.bottom);\n\t\tFont font = getFont(c);\n\t\tFontMetrics fm = c.getFontMetrics(font);\n\t\tswitch (titlePosition) {\n\t\t\tcase ABOVE_TOP:\n\t\t\tcase BELOW_BOTTOM:\n\t\t\t\tminSize.width = Math.max(fm.stringWidth(getTitle()),\n\t\t\t\t\t\tminSize.width);\n\t\t\t\tbreak;\n\t\t\tcase BELOW_TOP:\n\t\t\tcase ABOVE_BOTTOM:\n\t\t\tcase TOP:\n\t\t\tcase BOTTOM:\n\t\t\tcase DEFAULT_POSITION:\n\t\t\tdefault:\n\t\t\t\tminSize.width += fm.stringWidth(getTitle());\n\t\t}\n\t\treturn minSize;\n\t}\n",
    "133976": "    public void actionPerformed(ActionEvent e) {\n        if (EDIT.equals(e.getActionCommand())) {\n            //The user has clicked the cell, so\n            //bring up the dialog.\n            button.setBackground(currentColor);\n            colorChooser.setColor(currentColor);\n            dialog.setVisible(true);\n\n            //Make the renderer reappear.\n            fireEditingStopped();\n\n        } else { //User pressed dialog's \"OK\" button.\n            currentColor = colorChooser.getColor();\n        }\n    }\n",
    "133996": "\tprivate void initSlider() {\n\t\tsetOrientation(HORIZONTAL);\n\t}\n",
    "133997": "\t@Override\n\tpublic void updateUI() {\t\t\n\t\tsetUI(new RangeSliderUI(this));\n\t\t// Update UI for slider labels.  This must be called after updating the\n\t\t// UI of the slider.  Refer to JSlider.updateUI().\n\t\tupdateLabelUIs();\n\t}\n",
    "134001": "\tpublic int getHighValue() {\n\t\treturn getValue() + getExtent();\n\t}\n",
    "134002": "\tpublic void setHighValue(int value) {\n\t\t// Compute new extent.\n\t\tint lowerValue = getValue();\n\t\tint newExtent = Math.min(Math.max(0, value - lowerValue), getMaximum() - lowerValue);\n\n\t\t// Set extent to set upper value.\n\t\tsetExtent(newExtent);\n\t}\n",
    "134056": "\tpublic void runScriptString(String scriptText, String extension) {\n\t\ttry {\n\t\t\tScriptEngine engine = getScriptEngine(\"x.\" + extension); // fake file name\n\t\t\tif (engine == null) {\n\t\t\t\tLogger.getLogger(this.getClass().getName()).log(Level.SEVERE, \"igb script engine is not loaded\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tReader reader = new StringReader(scriptText + '\\n');\n\t\t\tengine.eval(reader);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n",
    "134091": "\tpublic void setRange(int start, int end) {\n\t\tthis.range = new Range(start, end);\n\t\ttrace_map.setMapRange(start, end);\n\t\tbase_map.setMapRange(start, end);\n\t\tRectangle2D.Double box = base_axis.getCoordBox();\n\t\tbase_axis.setCoords(start, box.y, end - start, box.height);\n\t}\n",
    "134154": "  private Object doGet() throws InvocationTargetException {\n    if (exception_ != null) \n      throw exception_;\n    else\n      return value_; \n  }\n",
    "134225": "\tprivate void paintThumb(Graphics g, Rectangle rect) {\n\t\tRectangle tempRect = thumbRect;\n\t\tthumbRect = rect;\n\t\tsuper.paintThumb(g);\n\t\tthumbRect = tempRect;\n\t}\n",
    "134230": "\tpublic void setAlwaysDrawArrow(boolean bool) {\n\t\talwaysDrawArrow = bool;\n\t}\n",
    "134233": "\tpublic void scrollByBlock(int direction) {\n\t\tsynchronized (slider) {\n\t\t\tint blockIncrement = (slider.getMaximum() - slider.getMinimum()) / 10;\n\t\t\tif (blockIncrement <= 0 && slider.getMaximum() > slider.getMinimum()) {\n\t\t\t\tblockIncrement = 1;\n\t\t\t}\n\t\t\tint delta = blockIncrement * ((direction > 0) ? POSITIVE_SCROLL : NEGATIVE_SCROLL);\n\n\t\t\tif (upperThumbSelected) {\n\t\t\t\tint oldValue = ((RangeSlider) slider).getHighValue();\n\t\t\t\t((RangeSlider) slider).setHighValue(oldValue + delta);\n\t\t\t} else {\n\t\t\t\tint oldValue = slider.getValue();\n\t\t\t\tslider.setValue(oldValue + delta);\n\t\t\t}\n\t\t}\n\t}\n",
    "134235": "\tpublic void scrollByUnit(int direction) {\n\t\tsynchronized (slider) {\n\t\t\tint delta = 1 * ((direction > 0) ? POSITIVE_SCROLL : NEGATIVE_SCROLL);\n\n\t\t\tif (upperThumbSelected) {\n\t\t\t\tint oldValue = ((RangeSlider) slider).getHighValue();\n\t\t\t\t((RangeSlider) slider).setHighValue(oldValue + delta);\n\t\t\t} else {\n\t\t\t\tint oldValue = slider.getValue();\n\t\t\t\tslider.setValue(oldValue + delta);\n\t\t\t}\n\t\t}\n\t}\n",
    "134236": "\tpublic void setAlwaysDrawUnalignedSpans(boolean bool) {\n\t\talwaysDrawUnalignedSpans = bool;\n\t}\n",
    "134256": "\tpublic void setTrace(TraceI trace) {\n\t\tsetTrace(trace, 0);\n\t}\n",
    "134264": "\tpublic void setTrace(TraceI trace, int start) {\n\t\tsetChromatogram(trace, start);\n\t\tif (0 < trace.getBaseCount()) { // deprecated storage of base calls has been done.\n\t\t\t// Move the base calls out of the trace\n\t\t\t// and add them directly.\n\t\t\tthis.base_count = trace.getBaseCount();\n\t\t\tif (trace.getActiveBaseCalls() != null) {\n\t\t\t\tBaseCall[] b = trace.getActiveBaseCalls().getBaseCalls();\n\t\t\t\tbase_map.removeItem((GlyphI) base_glyphs);\n\t\t\t\tbase_calls_vector.clear();\n\t\t\t\tbase_glyphs.clear();\n\t\t\t\taddBaseCalls(b, start);\n\t\t\t}\n\t\t}\n\t}\n",
    "134282": "\tpublic void setText(String str) {\n\t\tthis.text = str;\n\t}\n",
    "134283": "\tpublic void replaceBaseCalls(BaseCall[] theCalls) {\n\t\tif (this.base_calls_vector.size() < 1) {\n\t\t\taddBaseCalls(theCalls, 0);\n\t\t} else {\n\t\t\treplaceBaseCalls(theCalls, 0);\n\t\t}\n\t}\n",
    "134299": "\tpublic void setPlacement(int placement) {\n\t\tswitch (placement) {\n\t\t\tcase LEFT:\n\t\t\tcase RIGHT:\n\t\t\tcase ABOVE:\n\t\t\tcase BELOW:\n\t\t\tcase CENTER:\n\t\t\t\tthis.placement = placement;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException\n\t\t\t\t\t(\"must be LEFT, RIGHT, ABOVE, BELOW, or CENTER\");\n\t\t}\n\t}\n",
    "134302": "\tpublic int getPlacement() {\n\t\treturn this.placement;\n\t}\n",
    "134303": "\tprivate void replaceBaseCalls(BaseCall[] theCalls, int bases_index) {\n\t\ttry {\n\t\t\tBaseCalls bc = base_calls_vector.get(bases_index);\n\t\t\tbc.setBaseCalls(theCalls);\n\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t}\n\t}\n",
    "134309": "\tpublic void setLabeledGlyph(GlyphI lg) {\n\n\t\tlabeled = lg;\n\n\t\t/* Here we set this.coordbox to that of the labeled glyph.\n\t\t * This is a reasonable default.\n\t\t */\n\t\tRectangle2D.Double lgbox = lg.getCoordBox();\n\n\t\t/* We favor setCoords() over setCoordBox for speed.\n\t\t * Also, setting to lg's coordbox causes moving problems,\n\t\t * since both lg and this will try to do moveRelative() calls\n\t\t * affecting the _same_ coordbox.\n\t\t */\n\t\tsetCoords(lgbox.x, lgbox.y, lgbox.width, lgbox.height);\n\n\t\tprev_view = null;\n\t}\n",
    "134332": "\tprivate void removeAllBaseCalls() {\n\t\tsetActiveBaseCalls(new NullBaseCalls());\n\t\t// Not removing based axis because,\n\t\t// this is only called when about to replace the base calls with reverse complements.\n\t\t// To be correct,\n\t\t// we should remove all the base glyphs.\n\t\tint iBaseGlyphs = base_glyphs.size();\n\t\tfor (int i = 0; i < iBaseGlyphs; i++) {\n\t\t\tTraceBaseGlyph baseGlyph = base_glyphs.get(i);\n\t\t\tbase_map.getScene().removeGlyph(baseGlyph);\n\t\t}\n\t\t//base_glyphs.clear();\n\t\tbase_calls_vector.clear();\n\t}\n",
    "134340": "  public void setFillColor(Color c) {\n    this.fill_color = c;\n  }\n",
    "134341": "  public Color getFillColor() {\n    return this.fill_color;\n  }\n",
    "134342": "\tprotected void expandIfNeeded(GlyphI child) {\n\t\tRectangle2D.Double childbox = child.getCoordBox();\n\t\tdouble oldend = getCoordBox().x + getCoordBox().width;\n\t\tdouble newend = childbox.x + childbox.width;\n\t\tif (childbox.x < getCoordBox().x || newend > oldend) {\n\t\t\tdouble newx = Math.min(childbox.x, getCoordBox().x);\n\t\t\tdouble newwidth = Math.max(oldend, newend) - newx;\n\t\t\tsetCoords(newx, getCoordBox().y, newwidth, getCoordBox().height);\n\t\t}\n\t}\n",
    "134345": "\tpublic void redoColors()  {\n\t\tredoColors(ProteinUtils.getAACharToIdMap());\n\t}\n",
    "134347": "\tpublic void setActiveBaseCalls(BaseCalls bc) {\n\t\tif (null == bc || base_calls_vector.contains(bc)) {\n\t\t\ttrace.setActiveBaseCalls(bc);\n\t\t\tfor (int i = 0; i < base_glyphs.size(); i++) {\n\t\t\t\tTraceBaseGlyph base_glyph = base_glyphs.get(i);\n\t\t\t\tif (base_glyph.getBaseCalls() == trace.getActiveBaseCalls()) {\n\t\t\t\t\tthis.activeBaseCallsGlyph = base_glyph;\n\t\t\t\t} else {\n\t\t\t\t\tbase_glyph.clearSelection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase_axis.setBaseCalls(trace.getActiveBaseCalls());\n\t\t}\n\t}\n",
    "134361": "\tpublic void removeChild(GlyphI glyph) {\n\t\tsuper.removeChild(glyph);\n\t\tList child_glyphs = this.getChildren();\n\t\tif (child_glyphs == null || child_glyphs.size() <= 0) {\n\t\t\t// what should be done if no children left???\n\t\t}\n\t\telse {\n\t\t\tGlyphI child = (GlyphI)child_glyphs.get(0);\n\t\t\tRectangle2D.Double childbox = child.getCoordBox();\n\t\t\tthis.setCoords(childbox.x, childbox.y, childbox.width, childbox.height);\n\t\t\tfor (int i=1; i<child_glyphs.size(); i++) {\n\t\t\t\tchild = (GlyphI)child_glyphs.get(i);\n\t\t\t\tchildbox = child.getCoordBox();\n\t\t\t\tgetCoordBox().add(childbox);\n\t\t\t}\n\t\t}\n\t}\n",
    "134371": "\tpublic void setFillRect(boolean b) {\n\t\tfill_rect = b;\n\t}\n",
    "134396": "    private void drawResidueStrings(Graphics g, double pixelsPerBase, String str, int pixelStart, int baseline) {\n        g.setFont(getResidueFont());\n        g.setColor(getForegroundColor());\n        fontmet = GeneralUtils.getFontMetrics(getResidueFont());\n        // Ample room to draw residue letters.\n        for (int i = 0; i < str.length(); i++) {\n            String c = String.valueOf(str.charAt(i));\n            if (c != null) {\n                g.drawString(c, pixelStart + (int) (i * pixelsPerBase), baseline);\n            }\n        }\n    }\n",
    "134404": "\tpublic void addChild(GlyphI glyph) {\n\t\t// child.cbox.y is modified, but not child.cbox.height)\n\t\t// center the children of the LineContainerGlyph on the line\n\t\tRectangle2D.Double cbox = glyph.getCoordBox();\n\t\tdouble ycenter = this.getCoordBox().y + this.getCoordBox().height/2;\n\t\tcbox.y = ycenter - cbox.height/2;\n\t\tsuper.addChild(glyph);\n\t}\n",
    "134435": "\tpublic void redoColors()  {\n\t\tredoColors(DNAUtils.getNACharToIdMap());\n\t}\n",
    "134445": "\tpublic void moveRelative(double diffx, double diffy) {\n\t\tfull_rect.moveRelative(diffx, diffy);\n\t\tsuper.moveRelative(diffx, diffy);\n\t}\n",
    "134473": "\tprivate void setStemWidth(int theWidth) {\n\t\tthis.stemWidth = Math.max( Math.min( theWidth, MAX_STEM_WIDTH ), 1 );\n\t\tif ( 0 == this.stemWidth % 2 ) this.stemWidth--;\n\t\tthis.headY = 2*this.stemWidth+4;\n\t\tthis.headX = this.headY/2;\n\t}\n",
    "134478": "\tpublic void setScene(Scene s) {\n\t\tsuper.setScene(s);\n\t\tfull_rect.setScene(s);\n\t}\n",
    "134485": "\tpublic void setHitable(boolean hitable) {\n\t\tthis.hitable = hitable;\n\t}\n",
    "134486": "\tpublic void setShowBackground(boolean show) {\n\t\tshow_background = show;\n\t}\n",
    "134491": "\tpublic void setPrimaryFill(int theTechnique) {\n\t\tswitch (theTechnique) {\n\t\t\tcase NONE:\n\t\t\tcase STRETCHED:\n\t\t\tcase TILED:\n\t\t\t\tthis.primaryFill = theTechnique;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"technique must be NONE, STRETCHED, or TILED\");\n\t\t}\n\t}\n",
    "134494": "\tpublic void highlight(int start, int end) {\n\t\thighlightTrace(start, end);\n\t\thighlightBases(start, end);\n\t}\n",
    "134495": "\tpublic int getPrimaryFill() {\n\t\treturn this.primaryFill;\n\t}\n",
    "134496": "\tpublic GlyphStyle getStyle( Color fg, Color bg ) {\n\t\treturn getStyle( fg, bg, NeoConstants.default_plain_font );\n\t}\n",
    "134498": "\tpublic void setSecondaryFill(int theTechnique) {\n\t\tswitch (theTechnique) {\n\t\t\tcase NONE:\n\t\t\tcase STRETCHED:\n\t\t\tcase TILED:\n\t\t\t\tthis.secondaryFill = theTechnique;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"technique must be NONE or STRETCHED\");\n\t\t}\n\t}\n",
    "134500": "\tpublic int getSecondaryFill() {\n\t\treturn this.secondaryFill;\n\t}\n",
    "134504": "\tpublic void setImage(Image img, ImageObserver observer) {\n\t\t((Component)observer).prepareImage(img, observer);\n\t\tthis.img = img;\n\t\timg_width = this.img.getWidth(observer);\n\t\timg_height = this.img.getHeight(observer);\n\t}\n",
    "134513": "\tpublic void highlightTrace(int start, int end) {\n\t\ttrace_map.select(trace_glyph, start, end);\n\t\ttrace_map.updateWidget();\n\t}\n",
    "134521": "\tpublic void setChangeWidth ( int width ) {\n\t\tchangeWidth = width;\n\t}\n",
    "134526": "\tpublic void setCoords(double x, double y, double width, double height) {\n\t\tsuper.setCoords(x, y, width, height);\n\t\tfull_rect.setCoords(x, y, width, height);\n\t\tseq_beg = (int)x;\n\t\tseq_end = (int)(x+width-1);\n\t}\n",
    "134536": "\tpublic void highlightBases(int start, int end) {\n\t\tif (null != this.activeBaseCallsGlyph) {\n\t\t\tbase_map.select(this.activeBaseCallsGlyph, start, end);\n\t\t} else {\n\t\t\tfor (int i = 0; i < base_glyphs.size(); i++) {\n\t\t\t\tTraceBaseGlyph base_glyph = base_glyphs.get(i);\n\t\t\t\tbase_map.select(base_glyph, start, end);\n\t\t\t}\n\t\t}\n\t\tbase_map.updateWidget();\n\t}\n",
    "134541": "\tpublic void draw(ViewI view) {\n\n\t\t/* The reason this is done is so that pickTraversalByPixel will work.\n\t\t * Otherwise, the root glyph's pixel box is always empty.\n\t\t * Hence, since all glyphs are children of the root glyph,\n\t\t * no glyphs can get hit. -- Eric 1998-12-12\n\t\t */\n\t\tview.transformToPixels(getCoordBox(), getPixelBox());\n\t\tsuper.draw(view);\n\t}\n",
    "134547": "\tpublic void redoColors(int[] charMap) {\n\t\tredoColors(charMap, BACKGROUND);\n\t\tredoColors(charMap, FOREGROUND);\n\t}\n",
    "134548": "\tpublic void setPointCoords(double xcoords[], double ycoords[]) {\n\t\tthis.xcoords = xcoords;\n\t\tthis.ycoords = ycoords;\n\t}\n",
    "134555": "\tpublic void redoColors() {\n\t}\n",
    "134582": "\tpublic void setResidueFont(Font f) {\n\t\tresidue_font = f;\n\t\tFontMetrics fontmet = GeneralUtils.getFontMetrics(residue_font);\n\t\tfont_width = fontmet.charWidth('G');\n\t\tfont_height = fontmet.getAscent(); // Descent not needed for capital letters\n\t\tmonospace = GeneralUtils.isReallyMonospaced(residue_font,\n\t\t\t\tDNAUtils.getAllowedDNACharacters());\n\t\tif (!monospace) {\n\t\t\tfont_width = GeneralUtils.getMaxCharWidth(residue_font,\n\t\t\t\t\tDNAUtils.getAllowedDNACharacters());\n\t\t}\n\t}\n",
    "134587": "\tpublic void setLabelFormat(int theFormat) {\n\t\tif (theFormat != FULL && theFormat != ABBREV && theFormat != COMMA && theFormat != NO_LABELS) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Label format must be FULL, ABBREV, COMMA, or NO_LABELS.\");\n\t\t}\n\t\tthis.labelFormat = theFormat;\n\t}\n",
    "134593": "\tprivate BaseCall getBaseCall(int theBaseIndex) {\n\t\tBaseCalls bc = getActiveBaseCalls();\n\t\tif (null == bc) { // for backward compatibility\n\t\t\treturn this.trace.getActiveBaseCalls().getBaseCall(theBaseIndex);\n\t\t}\n\t\treturn bc.getBaseCall(theBaseIndex);\n\t}\n",
    "134616": "\tprotected void setCenter() {\n\t\tif (orient == VERTICAL) {\n\t\t\tcenter_line = getCoordBox().x + getCoordBox().width/2;\n\t\t}\n\t\telse {\n\t\t\tcenter_line = getCoordBox().y + getCoordBox().height/2;\n\t\t}\n\t\tthis.lastCoordBox = null;\n\t}\n",
    "134620": "\tpublic void selectResidues(int basenum_start, int basenum_end) {\n\t\tBaseCalls bc = getActiveBaseCalls();\n\t\tif (null == bc) {\n\t\t\treturn; // There are no residues to select.\n\t\t}\n\t\tRange trace_range = baseRange2TraceRange(bc, basenum_start, basenum_end);\n\t\thighlight(trace_range.beg, trace_range.end);\n\t}\n",
    "134644": "\tpublic void setCoordBox( Rectangle2D.Double theBox ) {\n\t\tsetCoords( theBox.x, theBox.y, theBox.width, theBox.height );\n\t}\n",
    "134655": "\tprotected void exportContent( PrintWriter pw, Sequence theSequence ) {\n\t\tpw.println(\">\" + theSequence.getID() + \" \" + theSequence.getDescription());\n\t\tString r = theSequence.getResidues();\n\t\tint limit = r.length() - LINE_LENGTH;\n\t\tint i;\n\t\tfor (i = 0; i < limit; i += LINE_LENGTH) {\n\t\t\tpw.println(r.substring(i, i+LINE_LENGTH));\n\t\t}\n\t\tpw.println(r.substring(i));\n\t}\n",
    "134657": "\tpublic Object importContent( InputStream theInput ) throws IOException {\n\t\tBufferedReader in;\n\t\tReadConfidence conf = new ReadConfidence();\n\n\t\tin = new BufferedReader( new InputStreamReader( theInput ) );\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile ( null != ( line = in.readLine() )\n\t\t\t\t\t&& !line.startsWith( \"BEGIN_DNA\" ) ) {\n\t\t\t\t// Skip header.\n\t\t\t\t\t}\n\t\t\twhile ( null != ( line = in.readLine() )\n\t\t\t\t\t&& !line.startsWith( \"END_DNA\" ) ) {\n\t\t\t\tBaseConfidence bc = importContent(line);\n\t\t\t\tconf.addBaseConfidence( bc );\n\t\t\t\t\t}\n\t\t} finally {\n\t\t\tin.close();\n\t\t}\n\t\treturn conf;\n\t}\n",
    "134658": "\tprivate BaseConfidence importContent(String theLine) {\n\t\tBaseConfidence bc = null;\n\t\tStringTokenizer line = new StringTokenizer(theLine);\n\t\tif (line.hasMoreTokens()) {\n\t\t\tchar base = line.nextToken().charAt(0);\n\t\t\tif (line.hasMoreTokens()) {\n\t\t\t\tint conf = Integer.parseInt(line.nextToken());\n\t\t\t\tif (line.hasMoreTokens()) {\n\t\t\t\t\tint point = Integer.parseInt(line.nextToken());\n\t\t\t\t\tbc = new BaseConfidence(base, conf, point);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbc = new BaseConfidence(base, conf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bc;\n\t}\n",
    "134677": "\tprivate int readABIint (DataInputStream in, String msg) throws IOException {\n\t\tint int_value = 0;\n\n\t\tint_value = (in.readUnsignedByte () & 0xff);\n\t\tint_value = ((int_value << 8) | (in.readUnsignedByte () & 0xff));\n\t\tint_value = ((int_value << 8) | (in.readUnsignedByte () & 0xff));\n\t\tint_value = ((int_value << 8) | (in.readUnsignedByte () & 0xff));\n\t\tcurpos += 4;\n\n\t\treturn int_value;\n\t}\n",
    "134678": "\tprivate int readABIint( DataInputStream in, int theOffset ) throws IOException {\n\t\tif ( this.curpos < theOffset ) {\n\t\t\tin.skip( theOffset - curpos );\n\t\t\tthis.curpos = theOffset;\n\t\t}\n\t\tif ( this.curpos == theOffset ) {\n\t\t\treturn readABIint( in, \"offset_read\" );\n\t\t}\n\t\tthrow new IOException( \"Can't go backwards.\" );\n\t}\n",
    "134681": "\tpublic Color getTrimColor() {\n\t\treturn trim_color;\n\t}\n",
    "134682": "\tprivate boolean verifyFileID (DataInputStream in) throws IOException {\n\t\tString read_id = \"\";\n\n\t\tread_id = readABIlabel (in, \"read_id\");\n\t\tif (read_id.equals (\"ABIF\")) {\n\t\t\theader_len = 0;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tin.skip (124);\n\t\t\tcurpos = 0;\n\t\t\theader_len = 128;\n\t\t\tread_id = readABIlabel (in, \"read_id\");\n\t\t\tif (read_id.equals (\"ABIF\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "134690": "\tpublic void setTrimColor(Color col) {\n\t\tif (col != this.trim_color) {\n\t\t\tthis.trim_color = col;\n\t\t\tif (this.left_trim_glyph != null) {\n\t\t\t\tthis.left_trim_glyph.setBackgroundColor(this.trim_color);\n\t\t\t}\n\t\t\tif (this.right_trim_glyph != null) {\n\t\t\t\tthis.right_trim_glyph.setBackgroundColor(this.trim_color);\n\t\t\t}\n\t\t}\n\t}\n",
    "134698": "\tpublic Object importContent( InputStream theInput ) throws IOException {\n\t\tTrace trace = new Trace();\n\t\ttry {\n\t\t\tDataInputStream dis = new DataInputStream(theInput);\n\t\t\treadHeader(dis, trace);\n\t\t\treadSamples(dis, trace);\n\t\t\treadBases(dis, trace);\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.getMessage());\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn trace;\n\t}\n",
    "134701": "\tpublic void setLeftTrim(int left_trim_end) {\n\t\tRectangle2D.Double coordbox = trace_glyph.getCoordBox();\n\t\tif (left_trim_glyph != null) {\n\t\t\ttrace_glyph.removeChild(left_trim_glyph);\n\t\t}\n\t\tleft_trim_glyph = new FillRectGlyph();\n\t\tleft_trim_glyph.setBackgroundColor(trim_color);\n\t\tleft_trim_glyph.setCoords(coordbox.x, coordbox.y,\n\t\t\t\tleft_trim_end, coordbox.height);\n\t\ttrace_glyph.addChild(left_trim_glyph);\n\t}\n",
    "134705": "\t\tpublic boolean isTab() {\n\t\t\treturn tab;\n\t\t}\n",
    "134708": "\tpublic String getDisplayName() {\n\t\treturn displayName;\n\t}\n",
    "134712": "\tpublic boolean isFocus() {\n\t\treturn focus;\n\t}\n",
    "134713": "\tpublic int getPosition() {\n\t\treturn position;\n\t}\n",
    "134714": "\tpublic TabState getDefaultState() {\n\t\treturn TabState.COMPONENT_STATE_BOTTOM_TAB;\n\t}\n",
    "134715": "\tpublic void setRightTrim(int right_trim_start) {\n\t\tRectangle2D.Double coordbox = trace_glyph.getCoordBox();\n\t\tif (right_trim_glyph != null) {\n\t\t\ttrace_glyph.removeChild(right_trim_glyph);\n\t\t}\n\t\tright_trim_glyph = new FillRectGlyph();\n\t\tright_trim_glyph.setBackgroundColor(trim_color);\n\t\tright_trim_glyph.setCoords(right_trim_start, coordbox.y,\n\t\t\t\tcoordbox.x + coordbox.width - right_trim_start,\n\t\t\t\tcoordbox.height);\n\t\ttrace_glyph.addChild(right_trim_glyph);\n\t}\n",
    "134716": "\tpublic JFrame getFrame() {\n\t\treturn frame;\n\t}\n",
    "134717": "\tpublic void setFrame(JFrame frame) {\n\t\tthis.frame = frame;\n\t}\n",
    "134721": "\tpublic Icon getIcon() {\n\t\tImageIcon icon = null;\n\t\ttry {\n\t\t\tURL url = IGBTabPanel.class.getResource(\"igb.gif\");\n\t\t\tif (url != null) {\n\t\t\t\ticon = new ImageIcon(url);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\t// It isn't a big deal if we can't find the icon, just return null\n\t\t}\n\t\treturn icon;\n\t}\n",
    "134722": "\tpublic boolean isEmbedded() {\n\t\treturn false;\n\t}\n",
    "134723": "\tpublic boolean isCheckMinimumWindowSize() {\n\t\treturn false;\n\t}\n",
    "134736": "\tpublic void setLabelColor(Color col) {\n\t\tlabel_color = col;\n\t}\n",
    "134743": "\tprivate String getCacheDir() {\n\t\treturn getCacheFolder() + \"v\" + CommonUtils.getInstance().getAppVersionFull() + \"-bundle-cache\";\n\t}\n",
    "134749": "\tpublic void clearCache() {\n\t\tdeleteDirectory(new File(getCacheFolder()));\n\t}\n",
    "134752": "\tprivate boolean deleteDirectory(File path) {\n\t\tif (path.exists()) {\n\t\t\tFile[] files = path.listFiles();\n\t\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\t\tif (files[i].isDirectory()) {\n\t\t\t\t\tdeleteDirectory(files[i]);\n\t\t\t\t} else {\n\t\t\t\t\tfiles[i].delete();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (path.delete());\n\t}\n",
    "134777": "\tpublic void setResidueFontColor(Color col) {\n\t\tfont_color_strategy = AlignedResiduesGlyph.FIXED_COLOR;\n\t\tresidue_color = col;\n\t\tif (apply_color_retro) {\n\t\t\tList<GlyphI> align_glyphs = this.getAlignmentGlyphs();\n\t\t\tAlignmentGlyph gar;\n\t\t\tfor (int i=0; i<align_glyphs.size(); i++) {\n\t\t\t\tgar = (AlignmentGlyph) align_glyphs.get(i);\n\t\t\t\tgar.setForegroundColor(residue_color);\n\t\t\t}\n\t\t\tif (colors_affect_cons && cons_glyph != null)  {\n\t\t\t\tcons_glyph.setForegroundColor(residue_color);\n\t\t\t}\n\t\t}\n\t}\n",
    "134797": "\tpublic int getDirection() {\n\t\tif (!this.forward) {\n\t\t\treturn REVERSE_COMPLEMENT;\n\t\t}\n\t\treturn FORWARD;\n\t}\n",
    "134821": "    public void close() {\n        mIndexBuffer.close();\n    }\n",
    "134824": "    public int getLevelSize(final int levelNumber) {\n        if(levelNumber == getNumIndexLevels())\n            return MAX_BINS+1-LEVEL_STARTS[levelNumber];\n        else\n            return LEVEL_STARTS[levelNumber+1]-LEVEL_STARTS[levelNumber];\n    }\n",
    "134827": "    public int getLevelForBin(final Bin bin) {\n        if(bin.getBinNumber() >= MAX_BINS)\n            throw new SAMException(\"Tried to get level for invalid bin.\");\n        for(int i = getNumIndexLevels()-1; i >= 0; i--) {\n            if(bin.getBinNumber() >= LEVEL_STARTS[i])\n                return i;\n        }\n        throw new SAMException(\"Unable to find correct bin for bin \"+bin);\n    }\n",
    "134836": "    public int getFirstLocusInBin(final Bin bin) {\n        final int level = getLevelForBin(bin);\n        final int levelStart = LEVEL_STARTS[level];\n        final int levelSize = ((level==getNumIndexLevels()-1) ? MAX_BINS-1 : LEVEL_STARTS[level+1]) - levelStart;\n        return (bin.getBinNumber() - levelStart)*(BIN_GENOMIC_SPAN /levelSize)+1;\n    }\n",
    "134838": "    public int getLastLocusInBin(final Bin bin) {\n        final int level = getLevelForBin(bin);\n        final int levelStart = LEVEL_STARTS[level];\n        final int levelSize = ((level==getNumIndexLevels()-1) ? MAX_BINS-1 : LEVEL_STARTS[level+1]) - levelStart;\n        return (bin.getBinNumber()-levelStart+1)*(BIN_GENOMIC_SPAN /levelSize);\n    }\n",
    "134840": "\tpublic void addRangeListener(NeoRangeListener l) {\n\t\trange_listeners.add(l);\n\t}\n",
    "134849": "    public Long getNoCoordinateCount() {\n\n        seek(4);\n        final int sequenceCount = readInteger();\n\n        skipToSequence(sequenceCount);\n        try { // in case of old index file without meta data\n            return readLong();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n",
    "134851": "\tpublic void removeRangeListener(NeoRangeListener l) {\n\t\trange_listeners.remove(l);\n\t}\n",
    "134853": "\tpublic boolean autoApplyChanges() {\n\t\treturn PreferenceUtils.getBooleanParam(PREF_AUTO_REFRESH,\n\t\t\t\tdefault_auto_refresh);\n\t}\n",
    "134856": "    private int getMaxBinNumberForReference(final int reference) {\n        try {\n            final int sequenceLength = mBamDictionary.getSequence(reference).getSequenceLength();\n            return getMaxBinNumberForSequenceLength(sequenceLength);\n        } catch (Exception e) {\n            return MAX_BINS;\n        }\n    }\n",
    "134858": "    protected int getMaxAddressibleGenomicLocation() {\n        return BIN_GENOMIC_SPAN;\n    }\n",
    "134883": "\tpublic Adjustable getHorizontalScroller () {\n\t\treturn hscroll;\n\t}\n",
    "134893": "\tpublic void setHorizontalScroller(JScrollBar scroller) {\n\n\t\tif (!(scroller instanceof Component) || (scroller == null))\n\t\t\treturn;\n\n\t\tremove ((Component)hscroll);\n\t\thscroll = scroller;\n\t\tadd    ((Component)hscroll);\n\n\t\talignmap.setRangeScroller(hscroll);\n\t\tconsmap.setRangeScroller (hscroll);\n\t}\n",
    "134903": "\tpublic Adjustable getVerticalScroller () {\n\t\treturn vscroll;\n\t}\n",
    "134913": "\tpublic void setVerticalScroller(JScrollBar scroller) {\n\n\t\tif (!(scroller instanceof Component) || (scroller == null))\n\t\t\treturn;\n\n\t\tremove ((Component)vscroll);\n\t\tvscroll = scroller;\n\t\tadd    ((Component)vscroll);\n\n\t\talignmap.setOffsetScroller(vscroll);\n\t\tlabelmap.setOffsetScroller(vscroll);\n\t}\n",
    "134934": "\tpublic void addDataSource(ServerTypeI type, String name, String url, int order, boolean isDefault) {\n\t\tif (url == null || url.isEmpty() || name == null || name.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tGenericServer server = GeneralLoadUtils.addServer(serverList,\n\t\t\t\ttype, name, url, order, isDefault);\n\n\t\tif (server == null) {\n\t\t\tErrorHandler.errorPanel(\n\t\t\t\t\t\"Unable to Load Data Source\",\n\t\t\t\t\t\"Unable to load \" + type + \" data source '\" + url + \"'.\");\n\t\t\treturn;\n\t\t}\n\n\t\tServerList.getServerInstance().addServerToPrefs(server, order);\n\t\tsourceTableModel.init();\n\t}\n",
    "134949": "\tprivate void refresh() {\n\t\tObject[][] rows;\n\t\trows = buildRows(PreferenceUtils.getKeystrokesNode(), PreferenceUtils.getToolbarNode());\n\t\tmodel.setRows(rows);\n\t}\n",
    "134951": "\tpublic void invokeRefreshTable() {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\trefresh();\n\t\t\t\tmodel.fireTableDataChanged();\n\t\t\t\tif (selected > 0) {\n\t\t\t\t\ttable.setRowSelectionInterval(selected, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t}\n",
    "135035": "\tprivate String toComparisonString() {\n\t\t// Do NOT consider the \"name\" in tests of equality.\n\t\t// We do not want to allow two links that are identical except for name.\n\t\t// This is important in allowing users to over-ride the default links.\n\t\treturn original_regex + \", \" + url.toString() + \", \" + id_field_name;\n\t}\n",
    "135040": "\tpublic void padCoordBox() {\n\t\t// 1000 is arbitrary\n\t\ttrace_map.setMapRange(-1000, trace_length + 2000);\n\t\tbase_map.setMapRange(-1000, trace_length + 2000);\n\t}\n",
    "135061": "\tpublic void setRegex(String regex) throws PatternSyntaxException {\n\t\tif (regex == null || \".*\".equals(regex) || \"(?i).*\".equals(regex)) {\n\t\t\tpattern = null;\n\t\t\toriginal_regex = regex;\n\t\t\treturn;\n\t\t}\n\n\t\t// delete any double, triple, etc., \"(?i)\" strings caused by a bug in a previous version\n\t\twhile (regex.startsWith(\"(?i)(?i)\")) {\n\t\t\tregex = regex.substring(4);\n\t\t}\n\t\tif (!regex.startsWith(\"(?i)\") && !type.equals(LOCAL)) {\n\t\t\tregex = \"(?i)\" + regex; // force all server web link matches to be case-insensitive\n\t\t}\n\t\toriginal_regex = regex;\n\t\tpattern = Pattern.compile(regex);\n\n\t}\n",
    "135062": "\tpublic Pattern getPattern() {\n\t\treturn pattern;\n\t}\n",
    "135064": "\tpublic String getUrl() {\n\t\treturn this.url;\n\t}\n",
    "135070": "\tpublic Adjustable getScroller() {\n\t\treturn hscroll;\n\t}\n",
    "135080": "\tpublic void setScroller(JScrollBar scroller) {\n\n\t\tif (!(scroller instanceof Component)\n\t\t\t\t|| (scroller == null)\n\t\t\t\t|| !hscroll_show) {\n\t\t\treturn;\n\t\t}\n\n\t\tremove((Component) hscroll);\n\t\thscroll = scroller;\n\t\tadd((Component) hscroll);\n\n\t\tsetRangeScroller(hscroll);\n\t}\n",
    "135089": "\tpublic void setTab(int i) {\n\t\tif (i < 0 || i >= tab_pane.getComponentCount()) {\n\t\t\treturn;\n\t\t}\n\t\ttab_pane.setSelectedIndex(i);\n\t\tComponent c = tab_pane.getComponentAt(i);\n\t\tif (c instanceof IPrefEditorComponent) {\n\t\t\tIPrefEditorComponent p = (IPrefEditorComponent) c;\n\t\t\tp.refresh();\n\t\t}\n\t}\n",
    "135090": "\tpublic int addPrefEditorComponent(final IPrefEditorComponent pec) {\n\t\ttab_pane.add(pec);\n\t\tpec.addComponentListener(new ComponentAdapter() {\n\n\t\t\t@Override\n\t\t\tpublic void componentShown(ComponentEvent e) {\n\t\t\t\tpec.refresh();\n\t\t\t}\n\t\t});\n\t\treturn tab_pane.indexOfComponent(pec);\n\t}\n",
    "135093": "\tpublic Adjustable getHorizontalZoomer() {\n\t\treturn hzoom;\n\t}\n",
    "135110": "\tpublic void setHorizontalZoomer(Adjustable zoomer) {\n\t\tif (!(zoomer instanceof Component) || (zoomer == null) || !hzoom_show) {\n\t\t\treturn;\n\t\t}\n\t\tremove((Component) hzoom);\n\t\thzoom = zoomer;\n\t\tadd((Component) hzoom);\n\t\tsetRangeZoomer(hzoom);\n\t}\n",
    "135120": "\tpublic Adjustable getVerticalZoomer() {\n\t\treturn vzoom;\n\t}\n",
    "135133": "\tpublic void setVerticalZoomer(Adjustable zoomer) {\n\t\tif (!(zoomer instanceof Component) || (zoomer == null) || !vzoom_show) {\n\t\t\treturn;\n\t\t}\n\t\tremove((Component) vzoom);\n\t\tvzoom = zoomer;\n\t\tadd((Component) vzoom);\n\t\tsetOffsetZoomer(vzoom);\n\t}\n",
    "135433": "\tprivate void setMaxExpandDepth(int max) {\n\t\texpand_packer.setMaxSlots(max);\n\t}\n",
    "135454": "\tpublic void init(Map<String, Object> options) {\n\t\tBoolean ccs = (Boolean) options.get(CHECK_SAME_SEQ_OPTION);\n\t\tif (ccs != null) {\n\t\t\tcheck_same_seq = ccs.booleanValue();\n\t\t}\n\t}\n",
    "135538": "\tpublic TierGlyph getReferenceTier() {\n\t\treturn (TierGlyph) getInfo();\n\t}\n",
    "135541": "\tprivate String getLabelString() {\n\t\tTierGlyph reference_tier = getReferenceTier();\n\t\tif (reference_tier.getLabel() == null) {\n\t\t\treturn \".......\";\n\t\t}\n\t\tString direction_str = getDirectionString(reference_tier);\n\t\treturn reference_tier.getLabel() + direction_str;\n\t}\n",
    "135610": "\tpublic void startDrag(List<TierLabelGlyph> theRegion, NeoMouseEvent nevt) {\n\t\tthis.dragStarted = true;\n\t\t\n\t\tthis.start = nevt.getCoordY();\n\n\t\t// These minimum heights are in coord space.\n\t\t// Shouldn't we be dealing in pixels?\n\t\tourCeiling = 0;\n\t\tourFloor = Double.POSITIVE_INFINITY;\n\t}\n",
    "135618": "\tpublic void setDoGraphSelections(boolean b) {\n\t\tdo_graph_selections = b;\n\t}\n",
    "135634": "\tpublic void showTiers(List<TierLabelGlyph> tier_labels, boolean full_repack, boolean fit_y) {\n\t\tfor (TierLabelGlyph g : tier_labels) {\n\t\t\tif (g.getInfo() instanceof TierGlyph) {\n\t\t\t\tTierGlyph tier = (TierGlyph) g.getInfo();\n\t\t\t\ttier.getAnnotStyle().setShow(true);\n\t\t\t}\n\t\t}\n\n\t\trepackTheTiers(full_repack, fit_y);\n\t}\n",
    "135639": "\tpublic void hideTiers(List<TierLabelGlyph> tier_labels, boolean full_repack, boolean fit_y) {\n\t\tfor (TierLabelGlyph g : tier_labels) {\n\t\t\tif (g.getInfo() instanceof TierGlyph) {\n\t\t\t\tTierGlyph tier = (TierGlyph) g.getInfo();\n\t\t\t\ttier.getAnnotStyle().setShow(false);\n\t\t\t}\n\t\t}\n\n\t\trepackTheTiers(full_repack, fit_y);\n\t}\n",
    "135648": "\tpublic void setTiersCollapsed(List<TierLabelGlyph> tier_labels, boolean collapsed) {\n\t\tfor (TierLabelGlyph tlg : tier_labels) {\n\t\t\tsetTierCollapsed(tlg.getReferenceTier(), collapsed);\n\t\t}\n\t\ttiermap.setTierStyles();\n\t\trepackTheTiers(true, true);\n\t\ttiermap.updateWidget();\n\t}\n",
    "135654": "\tpublic void packTiers(boolean full_repack, boolean stretch_map, boolean stretch_includes_nontiers) {\n\t\tpackTiers(full_repack, stretch_map);\n\t}\n",
    "135680": "\tpublic void sortTiers() {\n\t\tList<TierLabelGlyph> label_glyphs = tiermap.getTierLabels();\n\t\tCollections.sort(label_glyphs, new Comparator<TierLabelGlyph>(){\n\t\t\t@Override\n\t\t\tpublic int compare(TierLabelGlyph g1, TierLabelGlyph g2) {\n\t\t\t\treturn Double.compare(g1.getPosition(), g2.getPosition());\n\t\t\t}\n\t\t});\n\t\t\n\t\t// then repack of course (tiermap repack also redoes labelmap glyph coords...)\n\t\ttiermap.packTiers(false, true, false);\n\t\ttiermap.updateWidget();\n\t}\n",
    "135686": "  private void createTierLabel(TierGlyph mtg, int tier_index) {\n    TierLabelGlyph label_glyph = new TierLabelGlyph(mtg, tier_index);\n    // No need to set the TierLabelGlyph colors or label:\n    // it reads that information dynamically from the given TierGlyph\n    \n    labelmap.addItem(label_glyph);\n    // set info for string glyph to point to tier glyph\n    //   (which also sets value returned by label_glyph.getInfo())\n    labelmap.setDataModel(label_glyph, mtg);  \n    label_glyphs.add(label_glyph);\n    ordered_glyphs = null;\n  }\n",
    "135695": "\tpublic void removeTier(TierGlyph toRemove) {\n\t\tthis.removeItem(toRemove);\n\t\ttiers.remove(toRemove);\n\t}\n",
    "135714": "  private void print(boolean print_labels) throws java.awt.print.PrinterException {\n    ComponentPagePrinter cpp = null;\n    if (print_labels) {\n      cpp = new ComponentPagePrinter(mapsplitter);\n    } else {\n      cpp = new ComponentPagePrinter(can_panel);\n    }\n    cpp.print();\n    cpp = null; // for garbage collection\n  }\n",
    "135716": "  public JSplitPane getSplitPane() {\n    return mapsplitter;\n  }\n",
    "135723": "\tpublic void startDrag(List<TierLabelGlyph> theRegion, NeoMouseEvent nevt) {\n\t\tthis.dragStarted = true;\n\t\tthis.upperGl = theRegion.get(0);\n\t\tthis.start = nevt.getCoordY();\n\n\t\t// These minimum heights are in coord space.\n\t\t// Shouldn't we be dealing in pixels?\n\t\tourCeiling = this.upperGl.getCoordBox().getY()\n\t\t\t\t+ this.upperGl.getMinimumHeight();\n\t\t//ourFloor = ourCeiling + upperGl.getReferenceTier().getViewModeGlyph().getChildHeight() * upperGl.getReferenceTier().getActualSlots();\n\t\tthis.fixedInterior = theRegion;\n\t}\n",
    "135729": "\tpublic void doPopup(MouseEvent e) {\n\t\tpopup.removeAll();\n\n\t\tsetPopuptitle();\n\t\t\n\t\tfor (PopupListener pl : popup_listeners) {\n\t\t\tpl.popupNotify(popup, this);\n\t\t}\n\t\tList<TierGlyph> selectedGlyphs = getSelectedTiers();\n\t\tfor (TrackClickListener l : ExtensionPointHandler.getExtensionPoint(TrackClickListener.class).getExtensionPointImpls()) {\n\t\t\tl.trackClickNotify(popup, selectedGlyphs);\n\t\t}\n\t\tif (popup.getComponentCount() > 0) {\n\t\t\tpopup.show(labelmap, e.getX() + xoffset_pop, e.getY() + yoffset_pop);\n\t\t}\n\t}\n",
    "135732": " \tpublic void print() throws PrinterException {\n\t\tprint(PageFormat.LANDSCAPE, false);\n\t}\n",
    "135737": "\tprivate void setPopuptitle(){\n\t\tList<TierGlyph> tiers = getSelectedTiers();\n\n\t\tif(tiers.isEmpty())\n\t\t\treturn;\n\n\t\tString label;\n\t\tif(tiers.size() == 1 && tiers.get(0).getAnnotStyle().getFeature() != null)\n\t\t\tlabel = tiers.get(0).getAnnotStyle().getFeature().featureName;\n\t\telse\n\t\t\tlabel = tiers.size() + \" Selections\";\n\n\t\tif (label != null && label.length() > 30) {\n\t\t\tlabel = label.substring(0, 30) + \" ...\";\n\t\t}\n\n\t\tif(label != null && label.length() > 0){\n\t\t\tJLabel label_name = new JLabel(label);\n\t\t\tlabel_name.setEnabled(false); // makes the text look different (usually lighter)\n\t\t\tpopup.add(label_name);\n\t\t}\n\t}\n",
    "135739": "\tpublic void print(int pageFormat, boolean noDialog) throws PrinterException {\n \t\tComponentPagePrinter cpp = new ComponentPagePrinter(this);\n\t\tif (noDialog) {\n\t\t\tcpp.print(pageFormat, noDialog);\n\t\t} else {\n\t\t\tcpp.print();\n\t\t}\n \t\tcpp = null; // for garbage collection\n \t}\n",
    "135746": "\tpublic void setDataModelFromOriginalSym(GlyphI g, SeqSymmetry sym) {\n\t\tif (sym instanceof DerivedSeqSymmetry) {\n\t\t\tsetDataModelFromOriginalSym(g, ((DerivedSeqSymmetry) sym).getOriginalSymmetry());\n\t\t} else {\n\t\t\tsuper.setDataModel(g, sym);\n\t\t}\n\t}\n",
    "135778": "  public Object clone() throws CloneNotSupportedException {\n    StyleElement clone = (StyleElement) super.clone();\n    if (propertyMap != null) {\n      clone.propertyMap = (PropertyMap) this.propertyMap.clone();\n    }\n    if (glyphElement != null) {\n      clone.glyphElement = (GlyphElement) this.glyphElement.clone();\n    }\n    if (matchElements != null) {\n      clone.matchElements = new ArrayList<MatchElement>(matchElements.size());\n      for (int i=0; i<matchElements.size(); i++) {\n        MatchElement me = matchElements.get(i);\n        MatchElement new_me = (MatchElement) me.clone();\n        clone.matchElements.add(new_me);\n      }\n    }\n    return clone;\n  }  \n",
    "135791": "  private boolean hasAncestor(PropertyMap possible_ancestor) {\n    PropertyMap p2 = this;\n    while (p2 != null) {\n      if (p2 == possible_ancestor) {\n        return true;\n      }\n      p2 = p2.parentProperties;\n    }\n    return false;\n  }\n",
    "135813": "\tprivate SeqSpan transformForViewSeq(SeqMapViewExtendedI gviewer, SeqSymmetry insym) {\n\t\tder.clear();\n\t\t// copy the span into derSpan\n\t\tinsym.getSpan(gviewer.getAnnotatedSeq(), derSpan);\n\t\tder.addSpan(derSpan);\n\t\t\n\t\tif (gviewer.getAnnotatedSeq() != gviewer.getViewSeq()) {\n\t\t\tSeqUtils.transformSymmetry(der, gviewer.getTransformPath());\n\t\t}\n\t\treturn gviewer.getViewSeqSpan(der);\n\t}\n",
    "136111": "\tpublic void defloat(Glyph floater, ViewModeGlyph floatingGlyph) {\n\t\tfloater.removeChild(floatingGlyph);\n\t\tviewModeGlyph = floatingGlyph;\n\t\tviewModeGlyph.setCoordBox(super.getCoordBox());\n\t}\n",
    "136113": "\tpublic void setMaxSlots(int slotnum) {\n\t\tmax_slots_allowed = Math.max(slotnum, 0);\n\t}\n",
    "136114": "\tpublic void enjoin(ViewModeGlyph comboGlyph, NeoMap map) {\n\t\tviewModeGlyph.setVisibility(true);\n\t\tcomboGlyph.addChild(viewModeGlyph);\n\t\t// replace viewModeGlyph with dummy, so that it won't show as a regular glyph in the track\n\t\tviewModeGlyph = DummyGlyphFactory.getInstance().getViewModeGlyph(modelSym, style, getDirection(), smv);\n\t\tviewModeGlyph.setTierGlyph(this);\n\t\tviewModeGlyph.setCoordBox(super.getCoordBox());\n\t\tsetVisibility(false);\n\t\tsetUnloadedOK(false);\n\t}\n",
    "136117": "\tpublic void dejoin(ViewModeGlyph comboGlyph, ViewModeGlyph joinedGlyph) {\n\t\tcomboGlyph.removeChild(joinedGlyph);\n\t\tjoinedGlyph.setParent(getParent());\n\t\tviewModeGlyph = joinedGlyph;\n\t\tviewModeGlyph.setCoordBox(super.getCoordBox());\n\t}\n",
    "136121": "\tpublic int getActualSlots(){\n\t\treturn actual_slots;\n\t}\n",
    "136126": "\tprivate HeatMap getCustomHeatMap() {\n\t\tif (custom_heatmap == null) {\n\t\t\t// Bottom color is not quite same as background, so it remains visible\n\t\t\tColor bottom_color = HeatMap.interpolateColor(getBackground(), getForeground(), 0.20f);\n\t\t\tcustom_heatmap = HeatMap.makeLinearHeatmap(\"Custom\", bottom_color, getForeground());\n\t\t}\n\t\treturn custom_heatmap;\n\t}\n",
    "136149": "\tpublic void setCoordBox( Rectangle2D.Double theBox ) {\n\t\tsuper.setCoordBox(theBox);\n\t\tsetCoords( theBox.x, theBox.y, theBox.width, theBox.height );\n\t}\n",
    "136456": "\tpublic int toSummary() {\n\t\treturn Math.max(threshold_min, getCurrentThresholdValue() - threshold_increment);\n\t}\n",
    "136457": "\tpublic int toDetail() {\n\t\treturn getCurrentThresholdValue() + threshold_increment;\n\t}\n",
    "136460": "\tpublic Color getFillColor() {\n\t\treturn style.getBackground();\n\t}\n",
    "136484": "\tpublic void initSeqViewListener(Component seqView, Adjustable scroller) {\n\t\tseqView.addComponentListener(resizelistener);\n\t\tscroller.addAdjustmentListener(adjustmentlistener);\n\t}\n",
    "136487": "\tpublic void initSpinner(String unit) {\n\t\tdouble width = imageInfo.getWidth();\n\t\tdouble height = imageInfo.getHeight();\n\n\t\tif (unit.equals(UNIT[1])) {\n\t\t\twidth /= imageInfo.getResolution();\n\t\t\theight /= imageInfo.getResolution();\n\t\t}\n\n\t\tSpinnerModel sm = new SpinnerNumberModel(width, 0, 10000, 1);\n\t\twidthSpinner.setModel(sm);\n\t\tsm = new SpinnerNumberModel(height, 0, 10000, 1);\n\t\theightSpinner.setModel(sm);\n\n\t\tresetWidthHeight(width, height);\n\t}\n",
    "136488": "\tpublic float getGraphMinY() {\n\t\treturn point_min_ycoord;\n\t}\n",
    "136496": "\tprivate void resetPath(String path) {\n\t\texportFile = new File(path);\n\t\tfilePathTextField.setText(path);\n\t}\n",
    "136499": "\tprivate ExportFileType getType(String description) {\n\t\tfor (ExportFileType type : FILTER_LIST.keySet()) {\n\t\t\tif (type.getDescription().equals(description)) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "136504": "\tprivate ExportFileFilter getFilter(String ext) {\n\t\tfor (ExportFileFilter filter : FILTER_LIST.values()) {\n\t\t\tif (filter.getExtension().equals(ext)) {\n\t\t\t\treturn filter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "136508": "\tprivate String getDescription(String ext) {\n\t\tif (ext.equalsIgnoreCase(EXTENSION[0])) {\n\t\t\treturn DESCRIPTION[0];\n\t\t} else if (ext.equalsIgnoreCase(EXTENSION[1])) {\n\t\t\treturn DESCRIPTION[1];\n\t\t} else {\n\t\t\treturn DESCRIPTION[2];\n\t\t}\n\t}\n",
    "136516": "\tprivate boolean isValidExportFile(String previousPath) {\n\t\tif (!exportFile.getParentFile().isDirectory()) {\n\t\t\t// if output path is invalid, reset to previous correct path\n\t\t\tErrorHandler.errorPanel(\"The output path is invalid.\");\n\t\t\tresetPath(previousPath);\n\t\t\tfilePathTextField.grabFocus();\n\t\t\treturn false;\n\t\t}\n\n\t\t// if image size is too large...\n\t\tlong heapFreeSize = Runtime.getRuntime().freeMemory();\n\t\tlong size = (long) imageInfo.getWidth() * (long) imageInfo.getHeight();\n\t\tif (size > heapFreeSize) {\n\t\t\tErrorHandler.errorPanel(\"The image size is invalid.\");\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "136520": "\tprivate boolean isOverwrite() {\n\t\tString[] options = {\"Yes\", \"No\"};\n\t\tif (JOptionPane.YES_OPTION == JOptionPane.showOptionDialog(\n\t\t\t\tnull, \"Overwrite Existing File?\", \"File Exists\",\n\t\t\t\tJOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null,\n\t\t\t\toptions, options[1])) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "136523": "\tpublic void previewImage() {\n\t\texportImage = GraphicsUtil.getDeviceCompatibleImage(\n\t\t\t\tcomponent.getWidth(), component.getHeight());\n\t\tGraphics2D g = exportImage.createGraphics();\n\t\tif(component instanceof JFrame){\n\t\t\tdrawTitleBar( g);\n\t\t}\n\t\tcomponent.printAll(g);\n\n\t\tImage previewImage = GraphicsUtil.resizeImage(exportImage,\n\t\t\t\tpreviewLabel.getWidth(), previewLabel.getHeight());\n\n\t\tpreviewLabel.setIcon(new ImageIcon(previewImage));\n\t}\n",
    "136528": "\tprivate void drawTitleBar(Graphics2D g) {\n\t\t// Draw Background\n\t\tg.setColor(component.getBackground().darker());\n\t\tg.fillRect(0, 0, component.getWidth(), component.getHeight());\n\t\t\n\t\t// Draw Border\n\t\tg.setColor(Color.BLACK);\n\t\tg.fillRect(0, 20, component.getWidth(), 2);\n\t\t\n\t\t// Draw Title\n\t\tg.setFont(g.getFont().deriveFont(FONT_SIZE));\n\t\tint x_offset = (component.getWidth() - g.getFontMetrics().stringWidth(((JFrame)component).getTitle()))/2;\n\t\tint y_offset = 14;\n\t\tg.drawString(((JFrame)component).getTitle(), x_offset, y_offset);\n\t}\n",
    "136531": "\tpublic void widthSpinnerStateChanged() {\n\t\tif (!isHeightSpinner) {\n\t\t\tdouble newWidth = ((Double) widthSpinner.getValue()).doubleValue();\n\t\t\tdouble newHeight = newWidth * imageInfo.getHeightWidthRate();\n\n\t\t\tisWidthSpinner = true;\n\t\t\theightSpinner.setValue(newHeight);\n\t\t\tisWidthSpinner = false;\n\n\t\t\tresetWidthHeight(newWidth, newHeight);\n\t\t}\n\t}\n",
    "136536": "\tpublic void heightSpinnerStateChanged() {\n\t\tif (!isWidthSpinner) {\n\t\t\tdouble newHeight = ((Double) heightSpinner.getValue()).doubleValue();\n\t\t\tdouble newWidth = newHeight * imageInfo.getWidthHeightRate();\n\n\t\t\tisHeightSpinner = true;\n\t\t\twidthSpinner.setValue(newWidth);\n\t\t\tisHeightSpinner = false;\n\n\t\t\tresetWidthHeight(newWidth, newHeight);\n\t\t}\n\t}\n",
    "136544": "\tpublic void unitComboBoxActionPerformed() {\n\t\tunit = (String) unitComboBox.getSelectedItem();\n\n\t\tdouble newWidth = ((Double) widthSpinner.getValue()).doubleValue();\n\n\t\tif (unit.equals(UNIT[0])) {\n\t\t\tnewWidth *= imageInfo.getResolution();\n\t\t} else {\n\t\t\tnewWidth /= imageInfo.getResolution();\n\t\t}\n\n\t\twidthSpinner.setValue(newWidth);\n\t}\n",
    "136548": "\tprivate void resetWidthHeight(double width, double height) {\n\t\tif (unit != null) {\n\t\t\tif (unit.equals(UNIT[1])) {\n\t\t\t\t// Convert back from inches to pixels\n\t\t\t\twidth *= imageInfo.getResolution();\n\t\t\t\theight *= imageInfo.getResolution();\n\t\t\t}\n\n\t\t\timageInfo.setWidth(width);\n\t\t\timageInfo.setHeight(height);\n\n\t\t\tsizeLabel.setText(String.valueOf((int) width)\n\t\t\t\t\t+ \" x \"\n\t\t\t\t\t+ String.valueOf((int) height)\n\t\t\t\t\t+ \" pixels\");\n\n\t\t\t// Allow user to reset width and height back to current size\n\t\t\tenableRefreshButton();\n\t\t}\n\t}\n",
    "136551": "\tpublic void resolutionComboBoxActionPerformed() {\n\t\timageInfo.setResolution((Integer) resolutionComboBox.getSelectedItem());\n\n\t\tif (unit.equals(UNIT[1])) {\n\t\t\tdouble width = imageInfo.getWidth();\n\t\t\twidth /= imageInfo.getResolution();\n\t\t\twidthSpinner.setValue(width);\n\t\t}\n\t}\n",
    "136586": "    private ByteBuffer wrapForBufferedReading(byte[] b, int off, int len) {\n        if (cachedClientBuffer == null || cachedClientBuffer.array() != b) {\n            cachedClientBuffer = ByteBuffer.wrap(b);\n        }\n\n        if (len < singleByteReadBuffer.capacity()) {\n            singleByteReadBuffer.clear();\n            return singleByteReadBuffer;\n        }\n        cachedClientBuffer.position(off);\n        cachedClientBuffer.limit(off + len);\n        return cachedClientBuffer;\n    }\n",
    "136628": "\tpublic void performSelection(String selectParam) {\n\n\t\tif (selectParam == null || selectParam.length() == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// split the parameter by commas\n\t\tString[] ids = selectParam.split(\",\");\n\n\t\tif (ids.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tAnnotatedSeqGroup group = GenometryModel.getGenometryModel().getSelectedSeqGroup();\n\t\tList<SeqSymmetry> sym_list = new ArrayList<SeqSymmetry>(ids.length);\n\t\tfor (String id : ids) {\n\t\t\tsym_list.addAll(group.findSyms(id));\n\t\t}\n\n\t\tGenometryModel.getGenometryModel().setSelectedSymmetriesAndSeq(sym_list, ServiceUtils.class);\n\t}\n",
    "136635": "    private void replaceWithReduce(ByteBuffer data, int startPosition, byte[] replacementFrom, byte[] replacementTo) {\n        // Copy 'replacementTo' data.\n        if (replacementTo.length > 0) {\n            System.arraycopy(replacementTo, 0, data.array(), startPosition, replacementTo.length);\n        }\n        int newPosition = startPosition + replacementTo.length;\n\n        // Move buffer's tail if 'to' is shorter than 'from'.\n        if (data.remaining() > 0) {\n            System.arraycopy(data.array(), data.position(), data.array(), newPosition, data.remaining());\n        }\n\n        data.position(newPosition);\n        data.limit(data.limit() - replacementFrom.length + replacementTo.length);\n    }\n",
    "136683": "\tprivate double getLowerYCoordInset(ViewI view) {\n\t\t/* This original super to this function had had its return value\n\t\t * changed from 0 to 5 by GAH 3-21-2005.  bottom_ycoord_inset\n\t\t * is set to five to mirror the original call to super */\n\t\tdouble bottom_ycoord_inset = 5;\n\t\tif (getShowThreshold()) {\n\t\t\tthresh_pix_box.height = thresh_contig_height + thresh_contig_yoffset;\n\t\t\tview.transformToCoords(thresh_pix_box, thresh_coord_box);\n\t\t\tbottom_ycoord_inset += thresh_coord_box.height;\n\t\t}\n\t\treturn bottom_ycoord_inset;\n\t}\n",
    "136706": "\tpublic void refreshTable() {\n\t\t((AbstractTableModel) seqtable.getModel()).fireTableDataChanged();\n\t}\n",
    "136739": "\tprivate void speciesCBChanged() {\n\t\tString speciesName = (String) speciesCB.getSelectedItem();\n\n\t\t// Populate the versionName CB\n\t\trefreshVersionCB(speciesName);\n\n\t\t// Select the null group (and the null seq), if it's not already selected.\n\t\tif (curGroup != null) {\n\t\t\tgmodel.setSelectedSeqGroup(null); // This method is being called on purpose to fire group selection event.\n\t\t\tgmodel.setSelectedSeq(null);\t  // which in turns calls refreshTreeView method.\n\t\t}\n\t}\n",
    "136745": "\tprivate void versionCBChanged() {\n\t\tString versionName = (String) versionCB.getSelectedItem();\n\t\tif (DEBUG_EVENTS) {\n\t\t\tSystem.out.println(\"Selected version: \" + versionName);\n\t\t}\n\n\t\tif (curGroup != null) {\n\t\t\tgmodel.setSelectedSeqGroup(null);\n\t\t\tgmodel.setSelectedSeq(null);\n\t\t}\n\n\t\tif (versionName.equals(SELECT_GENOME)) {\n\t\t\t// Select the null group (and the null seq), if it's not already selected.\n\t\t\treturn;\n\t\t}\n\n\t\tsetSelectedGroup(versionName);\n\t}\n",
    "136777": "\tpublic void setRange(String search_text) {\n\t\tList<SeqSpan> mergedSpans = getSpanList(gview, search_text);\n\t\tif (mergedSpans != null && mergedSpans.size() > 0) {\n\t\t\tfoundSpans = mergedSpans;\n\t\t\tspanPointer = 0;\n\t\t\tif (foundSpans.size() > 1) {\n\t\t\t\tApplication.getSingleton().setStatus(\"found \" + foundSpans.size() + \" spans\");\n\t\t\t\tNextSearchSpanAction.getAction().setEnabled(true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNextSearchSpanAction.getAction().setEnabled(false);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tNextSearchSpanAction.getAction().setEnabled(false);\n\t\t\tApplication.getSingleton().setStatus(\"unable to match entry\");\n\t\t}\n\t}\n",
    "136785": "\tprivate double getCoordValue(ViewI view, float graph_value) {\n\t\tgetInternalLinearTransform(view, scratch_trans);\n\t\tdouble yscale = scratch_trans.getScaleY();\n\t\tdouble offset = scratch_trans.getTranslateY();\n\t\tfloat coord_value = (float) (offset - ((graph_value - getVisibleMinY()) * yscale));\n\t\treturn coord_value;\n\t}\n",
    "136796": "\tpublic float getGraphValue(ViewI view, double coord_value) {\n\t\tgetInternalLinearTransform(view, scratch_trans);\n\t\tdouble yscale = scratch_trans.getScaleY();\n\t\tdouble offset = scratch_trans.getTranslateY();\n\t\tfloat graph_value = (float) ((offset - coord_value) / yscale) + getVisibleMinY();\n\t\treturn graph_value;\n\t}\n",
    "136905": "\tpublic void loadVisibleFeatures() {\n\t\tif (DEBUG_EVENTS) {\n\t\t\tSeqSpan request_span = gviewer.getVisibleSpan();\n\t\t\tSystem.out.println(\"Visible load request span: \" + request_span.getBioSeq() + \":\" + request_span.getStart() + \"-\" + request_span.getEnd());\n\t\t}\n\t\tList<LoadStrategy> loadStrategies = new ArrayList<LoadStrategy>();\n\t\tloadStrategies.add(LoadStrategy.AUTOLOAD);\n\t\tloadStrategies.add(LoadStrategy.VISIBLE);\n//\t\tloadStrategies.add(LoadStrategy.CHROMOSOME);\n\t\tloadFeatures(loadStrategies, null);\n\t}\n",
    "136919": "\tpublic void actionPerformed(ActionEvent evt) {\n\t\tfinal Object src = evt.getSource();\n\n\t\tif (src == this.serverPrefsB) {\n\t\t\t// Go to server prefs tab.\n\n\t\t\tif (PreferencesPanel.TAB_DATALOAD_PREFS != -1) {\n\t\t\t\tPreferencesPanel pv = PreferencesPanel.getSingleton();\n\t\t\t\tpv.setTab(PreferencesPanel.TAB_DATALOAD_PREFS);\t// Server preferences tab\n\t\t\t\tJFrame f = pv.getFrame();\n\t\t\t\tf.setVisible(true);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"Data Load Preferences not instantiated\");\n\t\t\t}\n\t\t}\n\t}\n",
    "136950": "\tprivate void disableButtonsIfNecessary() {\n\t\t// Don't allow buttons for a full genome sequence\n\t\tsetAllButtons(getIsDisableNecessary());\n\t}\n",
    "137025": "\tprivate void updatedStrategy(int row, int col, GenericFeature gFeature) {\n\t\tfireTableCellUpdated(row, col);\n\n\t\tif (gFeature.getLoadStrategy() == LoadStrategy.GENOME || gFeature.getLoadStrategy() == LoadStrategy.AUTOLOAD) {\n\t\t\tGeneralLoadUtils.loadAndDisplayAnnotations(gFeature);\n\t\t}\n\n\t\t//  Whatever feature strategy changed, it may have affected\n\t\t// the enable status of the \"load visible\" button\n\n\t\tthis.glv.changeVisibleDataButtonIfNecessary(features);\n\t}\n",
    "137130": "  public void setKeepHairlineInView(boolean b) {\n    keep_hairline_in_view = b;\n\thairline.setShowHairline(b);\n\tmap.updateWidget();\n  }\n",
    "137131": "  public void setShowHairlineLabel(boolean b){\n\thairline.setLabeled(b);\n\tmap.updateWidget();\n  }\n",
    "137133": "  public void setSpot(double spot) {\n    focus = spot;\n    //visible_range.setSpot(focus);\n    // instead of using the visible_range, directly call hairline.setRange()\n    hairline.setRange((int) focus, (int) focus + 1);\n    map.setZoomBehavior(NeoMap.X, NeoMap.CONSTRAIN_COORD, focus);\n    //map.updateWidget();\n  }\n",
    "137135": "  public double getSpot() {\n    return focus;\n  }\n",
    "137137": "  public Shadow getShadow() {\n    return hairline;\n  }\n",
    "137138": "  public void destroy() {\n    if (map != null && pre_draw_listener != null) {\n      map.getView().removePreDrawViewListener(pre_draw_listener);\n    }\n    //if (visible_range != null && hairline != null) {\n    //  visible_range.removeListener(hairline);\n    //}\n    //if (map != null && mouse_listener != null) {\n    //  map.removeMouseListener(mouse_listener);\n    //}\n    if (hairline != null) { hairline.destroy(); }\n    //visible_range = null;\n    //mouse_listener = null;\n    hairline = null;\n    map = null;\n    if (pcl != null) {PreferenceUtils.getTopNode().removePreferenceChangeListener(pcl);}\n    pcl = null;\n  }\n",
    "137147": "\tpublic void copyAction() {\n\t\tString selectedSeq = seqview.getSelectedResidues().trim();\n\t\tif (seqview.getShow(NeoSeq.COMPLEMENT)) {\n\t\t\tselectedSeq = DNAUtils.complement(selectedSeq);\n\t\t}\n\t\tif (selectedSeq != null) {\n\t\t\tClipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n\t\t\tStringBuffer hackbuf = new StringBuffer(selectedSeq);\n\t\t\tString hackstr = new String(hackbuf);\n\t\t\tStringSelection data = new StringSelection(hackstr);\n\t\t\tclipboard.setContents(data, null);\n\t\t} else {\n\t\t\tErrorHandler.errorPanel(\"Missing Sequence Residues\",\n\t\t\t\t\t\"Don't have all the needed residues, can't copy to clipboard.\\n\"\n\t\t\t\t\t+ \"Please load sequence residues for this region.\", Level.WARNING);\n\t\t}\n\t}\n",
    "137161": "\tprotected ImageIcon createImageIcon(URL imgURL) throws IOException {\n\t\tif (imgURL != null) {\n\t\t\treturn new ImageIcon(imgURL, \"\");\n\t\t} else {\n\t\t\tthrow new IOException(\"file not found\");\n\t\t}\n\t}\n",
    "137207": "\tpublic void itemStateChanged(ItemEvent e) {\n\t\tif(e.getStateChange() != ItemEvent.SELECTED || e.getItem() == null)\n\t\t\treturn;\n\t\t\n\t\tCardLayout layout = (CardLayout) getLayout();\n\t\tSystem.out.println(\"MainWorkspaceManager:itemStateChanged hit\");\n\t\tString species = e.getItem().toString();\n\t\tif(gmodel.getSelectedSeqGroup() == null && SELECT_SPECIES.equals(species)){\n\t\t\tlayout.show( this, WELCOME_PANE );\n\t\t}else{\n\t\t\tlayout.show( this, SEQ_MAP_PANE );\n\t\t}\n\t}\n",
    "137241": "\tpublic void addRepositoryChangeListener(RepositoryChangeListener repositoryChangeListener) {\n\t\trepositoryChangeListeners.add(repositoryChangeListener);\n\t}\n",
    "137245": "\tpublic void removeRepositoryChangeListener(RepositoryChangeListener repositoryChangeListener) {\n\t\trepositoryChangeListeners.remove(repositoryChangeListener);\n\t}\n",
    "137251": "\tpublic void failRepository(String url) {\n\t\tServerList.getRepositoryInstance().getServer(url).setEnabled(false);\n\t}\n",
    "137253": "\tpublic void displayRepositoryPreferences() {\n\t\tif (PreferencesPanel.TAB_PLUGIN_PREFS != -1) {\n\t\t\tPreferencesPanel pv = PreferencesPanel.getSingleton();\n\t\t\tpv.setTab(PreferencesPanel.TAB_PLUGIN_PREFS);\t// Repository preferences tab\n\t\t\tJFrame f = pv.getFrame();\n\t\t\tf.setVisible(true);\n\t\t} else {\n\t\t\tSystem.out.println(\"Plugin Repository Preferences not instantiated\");\n\t\t}\n\t}\n",
    "137284": "\tpublic GenericServer getServer(String URLorName) {\n\t\tGenericServer server = url2server.get(URLorName);\n\t\tif (server == null) {\n\t\t\tfor (GenericServer gServer : getAllServers()) {\n\t\t\t\tif (gServer.serverName.equals(URLorName)) {\n\t\t\t\t\treturn gServer;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn server;\n\t}\n",
    "137306": "\tpublic void removeServer(String url) {\n\t\tGenericServer server = url2server.get(url);\n\t\turl2server.remove(url);\n\t\tif (server != null) {\n\t\t\tserver.setEnabled(false);\n\t\t\tif (server.serverType == ServerTypeI.QuickLoad) {\n\t\t\t\tQuickLoadServerModel.removeQLModelForURL(url);\n\t\t\t}\n\t\t\tfireServerInitEvent(server, ServerStatus.NotResponding); // remove it from our lists.\n\t\t}\n\t}\n",
    "137346": "\tprivate GenericServer addRepositoryToPrefs(String url, String name) {\n\t\tPreferences node = PreferenceUtils.getRepositoriesNode().node(GenericServer.getHash(url));\n\n\t\tnode.put(GenericServerPref.NAME, name);\n\t\tnode.put(GenericServerPref.URL, GeneralUtils.URLEncode(url));\n\n\t\treturn new GenericServer(node, null, null, false);\n\t}\n",
    "137353": "\tpublic void addServerToPrefs(GenericServer server, int order) {\n\t\tif (server.serverType == null) {\n\t\t\taddRepositoryToPrefs(server.URL, server.serverName);\n\t\t} else {\n\t\t\taddServerToPrefs(server.URL, server.serverName,\n\t\t\t\t\tserver.serverType, order, server.isDefault());\n\t\t}\n\t}\n",
    "137358": "\tpublic void removeServerFromPrefs(String url) {\n\t\ttry {\n\t\t\tgetPreferencesNode().node(GenericServer.getHash(url)).removeNode();\n\t\t} catch (BackingStoreException ex) {\n\t\t\tLogger.getLogger(ServerList.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t}\n",
    "137379": "\tpublic GenericServer getServer(URL u) throws URISyntaxException {\n\t\tURI a = u.toURI();\n\t\tURI b;\n\t\tfor (String url : url2server.keySet()) {\n\t\t\ttry {\n\t\t\t\tb = new URI(url);\n\t\t\t\tif (!b.relativize(a).equals(a)) {\n\t\t\t\t\treturn url2server.get(url);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException ex) {\n\t\t\t\tLogger.getLogger(ServerList.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"URL \" + u.toString() + \" is not a valid \" + textName + \".\");\n\t}\n",
    "137435": "\tpublic GenericServer getPrimaryServer() {\n\t\tfor (GenericServer server : getEnabledServers()) {\n\t\t\tif (server.isPrimary()) {\n\t\t\t\treturn server;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "137517": "\tpublic Action getAction() {\n\t\treturn this;\n\t}\n",
    "137549": "\tpublic boolean shouldBeEnabled() {\n\t\tList<? extends GlyphI> l = this.getSeqMapView().getSelectedTiers();\n\t\tif (0 == l.size()) {\n\t\t\tl = this.getSeqMapView().getTierManager().getAllTierGlyphs();\n\t\t}\n\t\tif (1 == l.size()) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.graphTracks.clear();\n\t\tfor (GlyphI g: l) {\n\t\t\tTierGlyph tg = (TierGlyph) g;\n\t\t\tObject info = tg.getInfo();\n\t\t\tif (info instanceof GraphSym) { // then we have a graph.\n\t\t\t\tthis.graphTracks.add(tg);\n\t\t\t}\n\t\t\n\t\t}\n\t\treturn (1 < this.graphTracks.size());\n\t}\n",
    "137639": "\t@Override\n  public void mousePressed(MouseEvent e) { \n    List<GlyphI> hit_glyphs = nmap.getItemsByPixel(e.getX(), e.getY());\n    if (hit_glyphs == null || hit_glyphs.isEmpty()) {\n      heardEvent(e); \n    }\n  }\n",
    "137666": "\tpublic IGBTabPanel getViewByDisplayName(String viewName) {\n\t\tfor (IGBTabPanel plugin : windowService.getPlugins()) {\n\t\t\tif (plugin.getDisplayName().equals(viewName)) {\n\t\t\t\treturn plugin;\n\t\t\t}\n\t\t}\n\t\tString message = getClass().getName() + \".getView() failed for \\\"\" + viewName + \"\\\"\";\n\t\ttry {\n\t\t\tLogger.getLogger(this.getClass().getName()).log(Level.SEVERE, message);\n\t\t}\n\t\tcatch (Exception x) {\n\t\t\tSystem.out.println(message);\n\t\t}\n\t\treturn null;\n\t}\n",
    "137672": "\tpublic void addAction(GenericAction theAction) {\n\t\tJPanel panel = (JPanel) this.frm.getContentPane();\n\t\tObject o = theAction.getValue(Action.ACCELERATOR_KEY);\n\t\tif (null != o && o instanceof KeyStroke) {\n\t\t\tKeyStroke ks = (KeyStroke) o;\n\t\t\tInputMap im = panel.getInputMap(JPanel.WHEN_IN_FOCUSED_WINDOW);\n\t\t\tActionMap am = panel.getActionMap();\n//\t\t\tGenericActionHolder h = GenericActionHolder.getInstance();\n\t\t\tString actionIdentifier = theAction.getId();\n\t\t\tim.put(ks, actionIdentifier);\n\t\t\tam.put(actionIdentifier, theAction);\n\t\t}\n\t}\n",
    "137679": "  public void matchEdges(NeoMap map, List<GlyphI> query_glyphs, List<GlyphI> target_glyphs, List<GlyphI> match_glyphs) {\n    for (GlyphI query : query_glyphs) {\n      matchEdges(map, query, target_glyphs, match_glyphs);\n    }\n  }\n",
    "137686": "\tpublic void setDockIconImage(Image image) {\n\t\ttry {\n\t\t\tMethod setDockIconImage = applicationClass.getDeclaredMethod(\"setDockIconImage\", Image.class);\n\t\t\tsetDockIconImage.invoke(application, image);\n\t\t} catch (Exception ex) {\n\t\t\tLogger.getLogger(MacIntegration.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t}\n",
    "137690": "\tpublic TierGlyph getTrack(SeqSymmetry sym, ITrackStyleExtended style, TierGlyph.Direction tier_direction) {\n\t\tMapViewGlyphFactoryI factory = MapViewModeHolder.getInstance().getAutoloadFactory(style);\n\t\treturn getTrack(sym, style, tier_direction, factory);\n\t}\n",
    "137716": "\tpublic String getPath(String genome_name, String file) {\n\t\tStringBuilder builder = new StringBuilder();\n\n\t\tbuilder.append(LOOKUP.findMatchingSynonym(genome_names, genome_name));\n\t\tbuilder.append(\"/\");\n\n\t\tif (file != null && !file.isEmpty()) {\n\t\t\tbuilder.append(file);\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n",
    "137721": "\tpublic double getLengthDouble() {\n\t\treturn length;\n\t}\n",
    "137725": "\tpublic InputStream getSpeciesTxt( ){\n\t\tInputStream stream = null;\n\t\ttry {\n\t\t\tstream = getInputStream( Constants.speciesTxt, false, true );\n\t\t} catch (IOException ex) {\n\t\t\tLogger.getLogger(QuickLoadServerModel.class.getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t\treturn stream;\n\t}\n",
    "137728": "\tpublic boolean hasSpeciesTxt(){\n\t\tInputStream stream;\n\t\ttry {\n\t\t\tstream = getInputStream( Constants.speciesTxt, false, true );\n\t\t} catch (IOException ex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn  stream != null;\n\t}\n",
    "137730": "\tpublic void setBoundsDouble(double min, double max) {\n\t\tlength = max - min;\n\t\tif (min < Integer.MIN_VALUE) { start = Integer.MIN_VALUE + 1; }\n\t\telse { start = (int)min; }\n\t\tif (max > Integer.MAX_VALUE) { end = Integer.MAX_VALUE - 1; }\n\t\telse { end = (int)max; }\n\t}\n",
    "137732": "\tpublic void setBounds(int min, int max) {\n\t\tstart = min;\n\t\tend = max;\n\t\t//    length = end - start;\n\t\tlength = (double)end - (double)start;\n\t}\n",
    "137748": "\tpublic SymWithProps getAnnotation(String type) {\n\t\tif (type_id2sym == null) {\n\t\t\treturn null; }\n\t\treturn type_id2sym.get(type);\n\t}\n",
    "137765": "\tprivate boolean getAllFiles(GenericServer gServer, String genome_name, String local_path) {\n\t\tFile file;\n\t\tSet<String> files = quickloadFiles;\n\n\t\tString server_path = gServer.URL + \"/\" + genome_name;\n\t\tlocal_path += \"/\" + genome_name;\n\t\tGeneralUtils.makeDir(local_path);\n\t\tboolean fileMayNotExist;\n\t\tfor (String fileName : files) {\n\t\t\tfileMayNotExist = getFileAvailability(fileName);\n\n\t\t\tfile = GeneralUtils.getFile(server_path + \"/\" + fileName, fileMayNotExist);\n\n\t\t\tif ((file == null && !fileMayNotExist)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!GeneralUtils.moveFileTo(file, fileName, local_path)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "137767": "\tpublic String getResidues() {\n\t\treturn this.getResidues(start, end);\n\t}\n",
    "137772": "\tpublic String getResidues(int start, int end) {\n\t\treturn getResidues(start, end, ' ');\n\t}\n",
    "137783": "\tprivate String getResiduesFromComposition(int res_start, int res_end, char fillchar) {\n\t\t\tSeqSpan residue_span = new SimpleSeqSpan(res_start, res_end, this);\n\t\t\tint reslength = Math.abs(res_end - res_start);\n\t\t\tchar[] char_array = new char[reslength];\n\t\t\tArrays.fill(char_array, fillchar);\n\t\t\tSeqSymmetry rootsym = this.getComposition();\n\t\t\tif (rootsym != null) {\n\t\t\t\t// adjusting index into array to compensate for possible seq start < 0\n\t\t\t\t//int array_offset = -start;\n\t\t\t\tgetResiduesFromComposition(residue_span, rootsym, char_array);\n\t\t\t\t// Note that new String(char[]) causes the allocation of a second char array\n\t\t\t}\n\t\t\treturn new String(char_array);\n\t\t}\n",
    "137845": "\tprivate boolean moveNonFloatingTierGlyphs() {\n\t\tboolean change_happened = false;\n\t\tif (pixel_floater_glyph.getChildren() != null) {\n\t\t\tfor (GlyphI glyph : new ArrayList<GlyphI>(pixel_floater_glyph.getChildren())) {\n\t\t\t\tViewModeGlyph vg = (ViewModeGlyph) glyph;\n\t\t\t\tif (!vg.getAnnotStyle().getFloatTier()) {\n\t\t\t\t\tvg.getTierGlyph().defloat(pixel_floater_glyph, vg);\n\t\t\t\t\tchange_happened = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn change_happened;\n\t}\n",
    "137917": "\tpublic static interface Order{\n\t\tpublic int getOrder();\n\t}\n",
    "137951": "\tprivate boolean moveFloatingTierGlyphs(List<TierGlyph> tiers) {\n\t\tboolean change_happened = false;\n\t\tfor (TierGlyph tg : tiers) {\n\t\t\tif (tg.getViewModeGlyph().getAnnotStyle().getFloatTier()) {\n\t\t\t\ttg.enfloat(pixel_floater_glyph, getSeqMap());\n\t\t\t\tchange_happened = true;\n\t\t\t}\n\t\t}\n\t\treturn change_happened;\n\t}\n",
    "138025": "\tpublic BioSeq getSelectedSeq() {\n\t\treturn primary_selection;\n\t}\n",
    "138026": "\tpublic void addGenericAction(GenericAction genericAction) {\n\t\tsynchronized(genericActions) {\n\t\t\tgenericActions.put(genericAction.getId(), genericAction);\n\t\t}\n\t\tKeyStroke k = PreferenceUtils.getAccelerator(genericAction.getClass().getName());\n\t\tgenericAction.putValue(Action.ACCELERATOR_KEY, k);\n\t\tfor (GenericActionListener listener : listeners) {\n\t\t\tlistener.onCreateGenericAction(genericAction);\n\t\t}\n\t}\n",
    "138029": "\tpublic void addGenericActionSilently(GenericAction genericAction) {\n\t\tsynchronized(genericActions) {\n\t\t\tgenericActions.put(genericAction.getId(), genericAction);\n\t\t}\n\t\tKeyStroke k = PreferenceUtils.getAccelerator(genericAction.getClass().getName());\n\t\tgenericAction.putValue(Action.ACCELERATOR_KEY, k);\n\t}\n",
    "138041": "\tpublic AnnotatedSeqGroup getSelectedGroup() {\n\t\treturn primary_selection;\n\t}\n",
    "138063": "  public void closeDialog() {\n    is_closed = true;\n    dialog.setVisible(false);\n    opt_pane.removePropertyChangeListener(pcl);\n    pcl = null;\n    opt_pane = null;\n    dialog = null;\n  }\n",
    "138066": "\tpublic ITrackStyleExtended getAnnotStyle(String name) {\n\t\tITrackStyleExtended style = id2annotState.get(name.toLowerCase());\n\t\tif (style == null) {\n\t\t\tstyle = new SimpleTrackStyle(name, false);\n\t\t\tid2annotState.put(name.toLowerCase(), style);\n\t\t}\n\t\treturn style;\n\t}\n",
    "138077": "  private void cancelPressed() {\n    dialog.setEnabled(false);\n    closeDialog();\n    if (thread != null) {thread.interrupt();}\n  }\n",
    "138080": "\tpublic Color getColor(int heatmap_index) {\n\t\tif (heatmap_index < 0) {\n\t\t\treturn colors[0];\n\t\t} else if (heatmap_index > 255) {\n\t\t\treturn colors[255];\n\t\t} else {\n\t\t\treturn colors[heatmap_index];\n\t\t}\n\t}\n",
    "138082": "  private void okPressed() {\n    closeDialog();\n  }\n",
    "138111": "\tpublic void copyPropertiesFrom(ITrackStyle g) {\n\t\tsetGraphTier(g.isGraphTier());\n\t\tsetForeground(g.getForeground());\n\t\tsetShow(g.getShow());\n\t\t// don't copy unique name\n\t\tsetTrackName(g.getTrackName());\n\t\tsetBackground(g.getBackground());\n\t\tsetCollapsed(g.getCollapsed());\n\t\tsetMaxDepth(g.getMaxDepth());\n\t\tsetHeight(g.getHeight());\n\t\tsetY(g.getY());\n\t\tsetExpandable(g.getExpandable());\n\t\tgetTransientPropertyMap().putAll(g.getTransientPropertyMap());\n\t}\n",
    "138184": "\tpublic void addCompressionEnding(String ending) {\n\t\tcompression_endings.add(ending.toLowerCase());\n\t}\n",
    "138185": "\tpublic void setThresholdDirection(int d) {\n\t\tif (d != THRESHOLD_DIRECTION_GREATER && d != THRESHOLD_DIRECTION_LESS_EQUAL\n\t\t\t\t&& d != THRESHOLD_DIRECTION_BETWEEN) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t\t\t}\n\t\tthreshold_direction = d;\n\t}\n",
    "138193": "\t/*public String getExtension(File f) {\n\t  if(f != null) {\n\t  String filename = f.getName().toLowerCase();\n\t  filename = stripCompressionEndings(filename);\n\t  int i = filename.lastIndexOf('.');\n\t  if(i>0 && i<filename.length()-1) {\n\t  return filename.substring(i+1).toLowerCase();\n\t  }\n\t  }\n\t  return null;\n\t  }*/\n",
    "138216": "\tpublic void writeServerMapping() {\n\t\tFileOutputStream fos = null;\n\t\tPrintStream out = null;\n\t\ttry {\n\t\t\tFile mapping = new File(path + \"/\" + Constants.serverMapping);\n\t\t\tmapping.createNewFile();\n\t\t\tfos = new FileOutputStream(mapping);\n\t\t\tout = new PrintStream(fos);\n\t\t\tfor (final GenericServer gServer : server_list) {\n\t\t\t\tout.println(gServer.URL + \"\\t\" + gServer.serverName);\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tLogger.getLogger(CacheScript.class.getName()).log(Level.SEVERE, null, ex);\n\t\t} finally {\n\t\t\tGeneralUtils.safeClose(fos);\n\t\t\tGeneralUtils.safeClose(out);\n\t\t}\n\t}\n",
    "138261": "\tpublic void loadSynonyms(InputStream istream) throws IOException {\n\t\tthis.loadSynonyms(istream, false);\n\t}\n",
    "138271": "\tpublic boolean isSynonym(String synonym1, String synonym2) {\n\t\treturn isSynonym(synonym1, synonym2, DEFAULT_CS, DEFAULT_SR);\n\t}\n",
    "138282": "\tpublic void start() {\n\t\tstart_time = System.currentTimeMillis();\n\t}\n",
    "138285": "\tpublic String getPreferredName(String synonym) {\n\t\treturn getPreferredName(synonym, DEFAULT_CS);\n\t}\n",
    "138287": "\tpublic String getPreferredName(String synonym, boolean cs) {\n\t\treturn this.findMatchingSynonym(preferredNames, synonym, cs, false);\n\t}\n",
    "138288": "\tpublic String findMatchingSynonym(Collection<String> choices, String synonym) {\n\t\treturn findMatchingSynonym(choices, synonym, DEFAULT_CS, DEFAULT_SR);\n\t}\n",
    "138290": "\tpublic String findMatchingSynonym(Collection<String> choices, String synonym, boolean cs, boolean sr) {\n\t\tfor (String id : choices) {\n\t\t\tif (this.isSynonym(synonym, id, cs, sr)) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t}\n\t\treturn synonym;\n\t}\n",
    "138292": "\tpublic String findSecondSynonym(String synonym) {\n\t\tSet<String> synonymSet = this.lookupHash.get(synonym);\n\t\tif (synonymSet == null) {\n\t\t\treturn synonym;\n\t\t}\n\t\tString firstSynonym = \"\";\n\t\tfor (String id : this.lookupHash.get(synonym)) {\n\t\t\tif (firstSynonym.length() == 0) {\n\t\t\t\tfirstSynonym = id;\n\t\t\t} else {\n\t\t\t\treturn id;\t// second synonym\n\t\t\t}\n\t\t}\n\t\treturn firstSynonym;\n\t}\n",
    "138297": "\tpublic int getLength() {\n\t\treturn (int) length;\n\t}\n",
    "138325": "    public Das2Region getSegment(BioSeq seq) {\n\t\tfor (Das2Region region : getSegments().values()) {\n            BioSeq region_seq = region.getAnnotatedSeq();\n            if (region_seq == seq) {\n                return region;\n            }\n        }\n        return null;\n    }\n",
    "138327": "  public BioSeq getSeq(int index) {\n    ensureSeqsLoaded();\n    return super.getSeq(index);\n  }\n",
    "138329": "  public int getSeqCount() {\n    ensureSeqsLoaded();\n    return super.getSeqCount();\n  }\n",
    "138334": "  public BioSeq getSeq(String synonym) {\n    ensureSeqsLoaded();\n    return super.getSeq(synonym);\n\n  }\n",
    "138336": "  public BioSeq getSeq(SeqSymmetry sym) {\n    ensureSeqsLoaded();\n    return super.getSeq(sym);\n  }\n",
    "138343": "\tpublic Das2VersionedSource getVersionedSource(AnnotatedSeqGroup group) {\n\t\tCollection<Das2VersionedSource> vsources = getVersionedSources(group);\n\t\tif (vsources.isEmpty()) { return null; }\n\t\telse { return vsources.iterator().next(); }\n\t}\n",
    "138348": "\tprivate String getRegionString(String type){\n\t\tif(!isLoadingFromPrimary()){\n\t\t\tDas2Capability segcap = getCapability(type);\n\t\t\treturn segcap.getRootURI().toString();\n\t\t}\n\n\t\treturn primary_uri.toString() + type + XML;\n\t}\n",
    "138351": "\tprivate String getLoadURL(){\n\t\tif(!isLoadingFromPrimary())\n\t\t\treturn server_uri.toString();\n\n\t\treturn primary_uri.toString() + \"/\" + Constants.GENOME_SEQ_ID+XML;\n\t}\n",
    "138360": "\tpublic String getSessionId() {\n\t\treturn sessionId;\n\t}\n",
    "138404": "\tprivate String getPath(String id, URL server, String file){\n\t\ttry {\n\t\t\tURL server_path = new URL(server, id + \"/\" + file);\n\t\t\treturn server_path.toExternalForm();\n\t\t} catch (MalformedURLException ex) {\n\t\t\tLogger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\t\t}\n\t\treturn null;\n\t}\n",
    "138415": "\tpublic int compare(UcscPslSym sym1, UcscPslSym sym2) {\n\t\tfinal int min1 = sym1.getTargetMin();\n\t\tfinal int min2 = sym2.getTargetMin();\n\t\tif (min1 != min2) {\n\t\t\treturn ((Integer)min1).compareTo(min2);\n\t\t}\n\t\treturn ((Integer)sym1.getTargetMax()).compareTo(sym2.getTargetMax());\n\t}\n",
    "138468": "\tpublic void clear() {\n\t\t// Remove all childred from request\n\t\trequestSym.removeChildren();\n\t\tif (currentRequestSym.getChildCount() > 0) {\n\t\t\tLogger.getLogger(GenericFeature.class.getName()).log(Level.WARNING, \"Genericfeature contains current request sym for server {0}\", gVersion.gServer.serverType);\n\t\t\tcurrentRequestSym.removeChildren();\n\t\t}\n\t\tmethods.clear();\n\t\tif(symL != null){\n\t\t\tsymL.clear();\n\t\t}\n\t\tsetInvisible();\n\t\tsetLastRefreshStatus(RefreshStatus.NOT_REFRESHED);\n\t}\n",
    "138474": "\tpublic SeqSymmetry optimizeRequest(SeqSpan span) {\n\t\tMutableSeqSymmetry query_sym = new SimpleMutableSeqSymmetry();\n\t\tquery_sym.addSpan(span);\n\n\t\tSeqSymmetry optimized_sym = SeqUtils.exclusive(query_sym, requestSym, span.getBioSeq());\n\t\toptimized_sym = SeqUtils.exclusive(optimized_sym, currentRequestSym, span.getBioSeq());\n\t\tif (SeqUtils.hasSpan(optimized_sym)) {\n\t\t\treturn optimized_sym;\n\t\t}\n\t\treturn null;\n\t}\n",
    "138478": "\tpublic void addLoadedSpanRequest(SeqSpan span) {\n\t\tMutableSeqSymmetry query_sym = new SimpleMutableSeqSymmetry();\n\t\tquery_sym.addSpan(span);\n\t\trequestSym.addChild(query_sym);\n\t\tremoveCurrentRequest(span);\n\t}\n",
    "138496": "\tpublic int compareTo(GenericServer gServer) {\n\t\tif (this.isEnabled() != gServer.isEnabled()) {\n\t\t\treturn Boolean.valueOf(this.isEnabled()).compareTo(Boolean.valueOf(gServer.isEnabled()));\n\t\t}\n\t\tif (!(this.serverName.equals(gServer.serverName))) {\n\t\t\treturn this.serverName.compareTo(gServer.serverName);\n\t\t}\n\t\treturn this.serverType.compareTo(gServer.serverType);\n\t}\n",
    "138499": "\tpublic void preferenceChange(PreferenceChangeEvent evt) {\n\t\tfinal String key = evt.getKey();\n\n\t\tif (key.equals(GenericServerPref.NAME) || key.equals(GenericServerPref.TYPE)) {\n\t\t\t/*\n\t\t\t * Ignore\n\t\t\t */\n\t\t} else if (key.equals(GenericServerPref.LOGIN)) {\n\t\t\tthis.login = evt.getNewValue() == null ? \"\" : evt.getNewValue();\n\t\t} else if (key.equals(GenericServerPref.PASSWORD)) {\n\t\t\tthis.password = evt.getNewValue() == null ? \"\" : decrypt(evt.getNewValue());\n\t\t} else if (key.equals(GenericServerPref.ENABLED)) {\n\t\t\tthis.enabled = evt.getNewValue() == null ? true : Boolean.valueOf(evt.getNewValue());\n\t\t}\n\t}\n",
    "138501": "\tprotected AnnotatedSeqGroup createSeqGroup(String group_id) {\n\t\treturn new AnnotatedSeqGroup(group_id);\n\t}\n",
    "138544": "\tpublic void setSelectedSymmetries(List<RootSeqSymmetry> all_syms, List<SeqSymmetry> graph_syms, Object src)  {\n\t\tsetSelectedSymmetries(graph_syms);\n\t\tfireSymSelectionEvent(src, all_syms, graph_syms); // Note this is the complete list of selections\n\t}\n",
    "138546": "\tpublic void setSelectedSymmetriesAndSeq(List<SeqSymmetry> graph_syms, Object src) {\n\t\tList<BioSeq> seqs_with_selections = setSelectedSymmetries(graph_syms);\n\t\tif (! seqs_with_selections.contains(getSelectedSeq())) {\n\t\t\tif (getSelectedSymmetries(getSelectedSeq()).isEmpty()) {\n\t\t\t\tBioSeq seq = null;\n\t\t\t\tif (! seqs_with_selections.isEmpty()) {\n\t\t\t\t\tseq = seqs_with_selections.get(0);\n\t\t\t\t}\n\t\t\t\tsetSelectedSeq(seq, src);\n\t\t\t}\n\t\t}\n\t\tList<RootSeqSymmetry> all_syms = Collections.<RootSeqSymmetry>emptyList();\n\t\tfireSymSelectionEvent(src, all_syms, graph_syms); // Note this is the complete list of selections\n\t}\n",
    "138550": "\tpublic void clearSelectedSymmetries(Object src) {\n\t\tclearSelectedSymmetries();\n\t\tfireSymSelectionEvent(src, Collections.<RootSeqSymmetry>emptyList(), Collections.<SeqSymmetry>emptyList());\n\t}\n",
    "138553": "\tprivate void clearSelectedSymmetries() {\n\t\tfor (List<SeqSymmetry> list : seq2selectedGraphSymsHash.values()) {\n\t\t\tlist.clear();\n\t\t}\n\t\tseq2selectedGraphSymsHash.clear();\n\t}\n",
    "138578": "\tprivate void getCurrentInput(BufferedReader input) {\n\t\tline_number++;\n\t\tcurrent_line = getCurrentLine(input, line_number);\n\t\tif (current_line == null) {\n\t\t\treturn;\n\t\t}\n\t\tcurrent_line_type = getLineType(current_line);\n\t\tcurrent_content = getRestOfLine(current_line, content_offset);\n\t}\n",
    "138579": "\tpublic String getMimeType() {\n\t\treturn \"text/bed\";\n\t}\n",
    "138581": "\tpublic void addFeatureFilter(String feature_type) {\n\t\taddFeatureFilter(feature_type, false);\n\t}\n",
    "138584": "\tpublic void addFeatureFilter(String feature_type, boolean pass_filter) {\n\t\tif (pass_filter) {\n\t\t\tif (pass_filter_hash == null) {\n\t\t\t\tpass_filter_hash = new HashMap<String, String>();\n\t\t\t}\n\t\t\tpass_filter_hash.put(feature_type, feature_type);\n\t\t} else {\n\t\t\tif (fail_filter_hash == null) {\n\t\t\t\tfail_filter_hash = new HashMap<String, String>();\n\t\t\t}\n\t\t\tfail_filter_hash.put(feature_type, feature_type);\n\t\t}\n\t}\n",
    "138588": "\tpublic void removeFeatureFilter(String feature_type) {\n\t\tremoveFeatureFilter(feature_type, false);\n\t}\n",
    "138590": "\tpublic void removeFeatureFilter(String feature_type, boolean pass_filter) {\n\t\tif (pass_filter) {\n\t\t\tif (pass_filter_hash != null) {\n\t\t\t\tpass_filter_hash.remove(feature_type);\n\t\t\t\tif (pass_filter_hash.size() == 0) {\n\t\t\t\t\tpass_filter_hash = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (fail_filter_hash != null) {\n\t\t\t\tfail_filter_hash.remove(feature_type);\n\t\t\t\tif (fail_filter_hash.size() == 0) {\n\t\t\t\t\tfail_filter_hash = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "138591": "\tprivate void ignoreSequence(BufferedReader input) {\n\t\tgetCurrentInput(input);\n\t\twhile (current_line != null && current_line.length() > 0 && current_line_type == SEQUENCE) {\n\t\t\tgetCurrentInput(input);\n\t\t}\n\t}\n",
    "138593": "\tpublic void resetFilters() {\n\t\tpass_filter_hash = null;\n\t\tfail_filter_hash = null;\n\t}\n",
    "138596": "\tpublic void setGroupTag(String tag) {\n\t\tgroup_tag = tag;\n\t}\n",
    "138614": "\tpublic void setUseStandardFilters(boolean b) {\n\t\t// \"standard\" filters may depend on whether file is GFF1, GFF2, GTF, or GFF3\n\t\taddFeatureFilter(\"intron\");\n\t\taddFeatureFilter(\"splice3\");\n\t\taddFeatureFilter(\"splice5\");\n\t\taddFeatureFilter(\"splice_donor\");\n\t\taddFeatureFilter(\"splice_acceptor\");\n\t\taddFeatureFilter(\"prim_trans\");\n\t\taddFeatureFilter(\"transcript\");\n\t\taddFeatureFilter(\"gene\");\n\t\taddFeatureFilter(\"cluster\");\n\t\taddFeatureFilter(\"psr\");\n\t\taddFeatureFilter(\"link\");\n\t\taddFeatureFilter(\"chromosome\");\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"group tag: transcript_id\");\n\t\t}\n\t\tsetGroupTag(\"transcript_id\");\n\t}\n",
    "138629": "\tpublic String getMimeType() {\n\t\treturn \"text/plain\";\n\t}\n",
    "138674": "\tstatic public File findIndexFile(File bamfile) throws IOException {\n\t\t//look for xxx.bam.bai\n\t\tString path = bamfile.getPath();\n\t\tFile f = new File(path+\".bai\");\n\t\tif (f.exists())\n\t\t\treturn f;\n\n\t\t//look for xxx.bai\n\t\tpath = path.substring(0, path.length()-3)+\"bai\";\n\t\tf = new File(path);\n\t\tif (f.exists())\n\t\t\t\treturn f;\n\n\t\treturn null;\n\t}\n",
    "138727": "\tpublic int compareTo (PositionData other){\n\t\tif (sortedPositions[0].position <other.sortedPositions[0].position) return -1;\n\t\tif (sortedPositions[0].position >other.sortedPositions[0].position) return 1;\n\t\treturn 0;\n\t}\n",
    "138728": "\tpublic void writeBed (PrintWriter out){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tfor (int i=0; i< sortedPositions.length; i++){\n\t\t\t//chrom start stop name score strand\n\t\t\tout.println(chrom+\"\\t\"+sortedPositions[i].position+\"\\t\"+(sortedPositions[i].position + 1)+\"\\t\"+\".\\t0\\t\"+strand);\n\t\t}\n\t}\n",
    "138730": "\tpublic int fetchLastBase(){\n\t\treturn sortedPositions[sortedPositions.length-1].position;\n\t}\n",
    "138733": "\tpublic void writeNative (PrintWriter out){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tif (strand.equals(\".\")){\n\t\t\tout.println(\"#Chr\\tPosition\");\n\t\t\tfor (int i=0; i< sortedPositions.length; i++) out.println(chrom+\"\\t\"+sortedPositions[i].position);\n\t\t}\n\t\telse {\n\t\t\tout.println(\"#Chr\\tPosition\\tStrand\");\n\t\t\tfor (int i=0; i< sortedPositions.length; i++){\n\t\t\t\t//chrom start stop name score strand\n\t\t\t\tout.println(chrom+\"\\t\"+sortedPositions[i].position+\"\\t\"+strand);\n\t\t\t}\n\t\t}\n\t}\n",
    "138735": "\tpublic void writePositionScore (PrintWriter out){\n\t\tint priorPosition = -1;\n\t\tfor (int i=0; i< sortedPositions.length; i++){\n\t\t\t\tif (priorPosition != sortedPositions[i].position){\n\t\t\t\t\tout.println((sortedPositions[i].position +1)+\"\\t0\");\n\t\t\t\t\tpriorPosition = sortedPositions[i].position;\n\t\t\t\t}\n\t\t}\n\t}\n",
    "138742": "    public String getRegionResidues(SeqSpan span) throws Exception {\n\t\tLogger.getLogger(this.getClass().getName()).log(\n\t\t\t\t\tLevel.WARNING, \"Not supported.  Returning empty string.\");\n\t\treturn \"\";\n    }\n",
    "138745": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<Position> al = new ArrayList<Position>();\n\t\tfor (int i=0; i< sortedPositions.length; i++){\n\t\t\tif (sortedPositions[i].isContainedBy(beginningBP, endingBP)) al.add(sortedPositions[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedPositions = new Position[al.size()];\n\t\tal.toArray(sortedPositions);\n\t\tupdateSliceInfo(sortedPositions, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138748": "\tpublic int fetchLastBase(){\n\t\tint lastBase = -1;\n\t\tfor (RegionScoreText r : sortedRegionScoreTexts){\n\t\t\tint end = r.getStop();\n\t\t\tif (end > lastBase) lastBase = end;\n\t\t}\n\t\treturn lastBase;\n\t}\n",
    "138758": "\tpublic int fetchLastBase(){\n\t\tint lastBase = -1;\n\t\tfor (RegionText r : sortedRegionTexts){\n\t\t\tint end = r.getStop();\n\t\t\tif (end > lastBase) lastBase = end;\n\t\t}\n\t\treturn lastBase;\n\t}\n",
    "138767": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<RegionScoreText> al = new ArrayList<RegionScoreText>();\n\t\tfor (int i=0; i< sortedRegionScoreTexts.length; i++){\n\t\t\tif (sortedRegionScoreTexts[i].isContainedBy(beginningBP, endingBP)) al.add(sortedRegionScoreTexts[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedRegionScoreTexts = new RegionScoreText[al.size()];\n\t\tal.toArray(sortedRegionScoreTexts);\n\t\tupdateSliceInfo(sortedRegionScoreTexts, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138774": "\tpublic int fetchLastBase(){\n\t\treturn sortedPositionTexts[sortedPositionTexts.length-1].position;\n\t}\n",
    "138778": "\tpublic void writeNative (PrintWriter out){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tif (strand.equals(\".\")){\n\t\t\tout.println(\"#Chr\\tPosition\\tText(s)\");\n\t\t\tfor (int i=0; i< sortedPositionTexts.length; i++) out.println(chrom+\"\\t\"+sortedPositionTexts[i].position+\"\\t\"+sortedPositionTexts[i].text);\n\t\t}\n\t\telse {\n\t\t\tout.println(\"#Chr\\tPosition\\tText(s)\\tStrand\");\n\t\t\tfor (int i=0; i< sortedPositionTexts.length; i++){\n\t\t\t\t//chrom start stop name score strand\n\t\t\t\tout.println(chrom+\"\\t\"+sortedPositionTexts[i].position+\"\\t\"+sortedPositionTexts[i].text+\"\\t\"+strand);\n\t\t\t}\n\t\t}\n\t}\n",
    "138779": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<RegionText> al = new ArrayList<RegionText>();\n\t\tfor (int i=0; i< sortedRegionTexts.length; i++){\n\t\t\tif (sortedRegionTexts[i].isContainedBy(beginningBP, endingBP)) al.add(sortedRegionTexts[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedRegionTexts = new RegionText[al.size()];\n\t\tal.toArray(sortedRegionTexts);\n\t\tupdateSliceInfo(sortedRegionTexts, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138780": "\tpublic void writePositionScore (PrintWriter out){\n\t\tint prior = -1;\n\t\tfor (int i=0; i< sortedPositionTexts.length; i++){\n\t\t\t\tif (prior != sortedPositionTexts[i].position) {\n\t\t\t\t\tout.println((sortedPositionTexts[i].position +1) +\"\\t0\");\n\t\t\t\t\tprior = sortedPositionTexts[i].position;\n\t\t\t\t}\n\t\t}\n\t}\n",
    "138784": "\tpublic int compareTo (PositionScoreData other){\n\t\tif (sortedPositionScores[0].position <other.sortedPositionScores[0].position) return -1;\n\t\tif (sortedPositionScores[0].position >other.sortedPositionScores[0].position) return 1;\n\t\treturn 0;\n\t}\n",
    "138787": "\tpublic int fetchLastBase(){\n\t\treturn sortedPositionScores[sortedPositionScores.length-1].position;\n\t}\n",
    "138790": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<PositionText> al = new ArrayList<PositionText>();\n\t\tfor (int i=0; i< sortedPositionTexts.length; i++){\n\t\t\tif (sortedPositionTexts[i].isContainedBy(beginningBP, endingBP)) al.add(sortedPositionTexts[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedPositionTexts = new PositionText[al.size()];\n\t\tal.toArray(sortedPositionTexts);\n\t\tupdateSliceInfo(sortedPositionTexts, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138791": "\tpublic void writeNative (PrintWriter out){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tif (strand.equals(\".\")){\n\t\t\tout.println(\"#Chr\\tPosition\\tScore\");\n\t\t\tfor (int i=0; i< sortedPositionScores.length; i++) out.println(chrom+\"\\t\"+sortedPositionScores[i].position+\"\\t\"+sortedPositionScores[i].score);\n\t\t}\n\t\telse {\n\t\t\tout.println(\"#Chr\\tPosition\\tScore\\tStrand\");\n\t\t\tfor (int i=0; i< sortedPositionScores.length; i++){\n\t\t\t\t//chrom start stop name score strand\n\t\t\t\tout.println(chrom+\"\\t\"+sortedPositionScores[i].position+\"\\t\"+sortedPositionScores[i].score+\"\\t\"+strand);\n\t\t\t}\n\t\t}\n\t}\n",
    "138794": "\tpublic void writePositionScore (PrintWriter out){\n\t\tint prior = -1;\n\t\tfor (int i=0; i< sortedPositionScores.length; i++){\n\t\t\t\tif (prior != sortedPositionScores[i].position) {\n\t\t\t\t\tout.println((sortedPositionScores[i].position +1)+\"\\t\"+sortedPositionScores[i].score);\n\t\t\t\t\tprior = sortedPositionScores[i].position;\n\t\t\t\t}\n\t\t}\n\t}\n",
    "138796": "\tpublic boolean intersects (int start, int stop){\n\t\tif (stop <= this.start || start >= this.stop) return false;\n\t\treturn true;\n\t}\n",
    "138798": "\tpublic int compareTo(Region se){\n\t\tif (start<se.start) return -1;\n\t\tif (start>se.start) return 1;\n\t\t// if same start, sort by length, smaller to larger\n\t\tint len = stop-start;\n\t\tint otherLen = se.stop-se.start;\n\t\tif (len<otherLen) return -1;\n\t\tif (len>otherLen) return 1;\n\t\treturn 0;\n\t}\n",
    "138799": "\tpublic int getLength(){\n\t\treturn stop-start;\n\t}\n",
    "138808": "\tpublic int fetchLastBase(){\n\t\tint lastBase = -1;\n\t\tfor (RegionScore r : sortedRegionScores){\n\t\t\tint end = r.getStop();\n\t\t\tif (end > lastBase) lastBase = end;\n\t\t}\n\t\treturn lastBase;\n\t}\n",
    "138810": "\tpublic void writeBed (PrintWriter out, boolean fixScore){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tfor (int i=0; i< sortedRegionScores.length; i++){\n\t\t\t//chrom start stop name score strand\n\t\t\tif (fixScore){\n\t\t\t\tint score = USeqUtilities.fixBedScore(sortedRegionScores[i].score);\n\t\t\t\tout.println(chrom+\"\\t\"+sortedRegionScores[i].start+\"\\t\"+sortedRegionScores[i].stop+\"\\t\"+\".\\t\"+ score +\"\\t\"+strand);\n\t\t\t}\n\t\t\telse out.println(chrom+\"\\t\"+sortedRegionScores[i].start+\"\\t\"+sortedRegionScores[i].stop+\"\\t\"+\".\\t\"+ sortedRegionScores[i].score +\"\\t\"+strand);\n\t\t}\n\t}\n",
    "138812": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<PositionScore> al = new ArrayList<PositionScore>();\n\t\tfor (int i=0; i< sortedPositionScores.length; i++){\n\t\t\tif (sortedPositionScores[i].isContainedBy(beginningBP, endingBP)) al.add(sortedPositionScores[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedPositionScores = new PositionScore[al.size()];\n\t\tal.toArray(sortedPositionScores);\n\t\tupdateSliceInfo(sortedPositionScores, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138838": "\tpublic void read (File binaryFile) {\n\t\tFileInputStream workingFIS = null;\n\t\tDataInputStream workingDIS = null;\n\t\ttry {\n\t\t\t//open IO\n\t\t\tthis.binaryFile = binaryFile;\n\t\t\tworkingFIS = new FileInputStream(binaryFile);\n\t\t\tworkingDIS = new DataInputStream( new BufferedInputStream(workingFIS ));\n\t\t\tread(workingDIS);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tUSeqUtilities.safeClose(workingFIS);\n\t\t\tUSeqUtilities.safeClose(workingDIS);\n\t\t}\n\t}\n",
    "138839": "\tpublic void read (DataInputStream dis) {}\n",
    "138842": "\tpublic int compareTo(Position other){\n\t\tif (position<other.position) return -1;\n\t\tif (position>other.position) return 1;\n\t\treturn 0;\n\t}\n",
    "138848": "\tpublic int fetchLastBase(){\n\t\tint lastBase = -1;\n\t\tfor (Region r : sortedRegions){\n\t\t\tint end = r.getStop();\n\t\t\tif (end > lastBase) lastBase = end;\n\t\t}\n\t\treturn lastBase;\n\t}\n",
    "138851": "\tpublic void writeBed (PrintWriter out){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tfor (int i=0; i< sortedRegions.length; i++){\n\t\t\t//chrom start stop name score strand\n\t\t\tout.println(chrom+\"\\t\"+sortedRegions[i].start+\"\\t\"+sortedRegions[i].stop+\"\\t\"+\".\\t0\\t\"+strand);\n\t\t}\n\t}\n",
    "138856": "\tpublic void writeNative (PrintWriter out){\n\t\tString chrom = sliceInfo.getChromosome();\n\t\tString strand = sliceInfo.getStrand();\n\t\tif (strand.equals(\".\")){\n\t\t\tout.println(\"#Chr\\tStart\\tStop\");\n\t\t\tfor (int i=0; i< sortedRegions.length; i++) out.println(chrom+\"\\t\"+sortedRegions[i].start+\"\\t\"+sortedRegions[i].stop);\n\t\t}\n\t\telse {\n\t\t\tout.println(\"#Chr\\tStart\\tStop\\tStrand\");\n\t\t\tfor (int i=0; i< sortedRegions.length; i++) out.println(chrom+\"\\t\"+sortedRegions[i].start+\"\\t\"+sortedRegions[i].stop+\"\\t\"+strand);\n\t\t}\n\t}\n",
    "138858": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<RegionScore> al = new ArrayList<RegionScore>();\n\t\tfor (int i=0; i< sortedRegionScores.length; i++){\n\t\t\tif (sortedRegionScores[i].isContainedBy(beginningBP, endingBP)) al.add(sortedRegionScores[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedRegionScores = new RegionScore[al.size()];\n\t\tal.toArray(sortedRegionScores);\n\t\tupdateSliceInfo(sortedRegionScores, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138867": "\tpublic void writePositionScore (PrintWriter out){\n\t\tint prior = -1; \n\t\tfor (int i=0; i< sortedPositionScoreTexts.length; i++){\n\t\t\tif (prior != sortedPositionScoreTexts[i].position) {\n\t\t\t\tout.println((sortedPositionScoreTexts[i].position +1) +\"\\t\"+sortedPositionScoreTexts[i].score);\n\t\t\t\tprior = sortedPositionScoreTexts[i].position;\n\t\t\t}\n\t\t}\n\t}\n",
    "138873": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<Region> al = new ArrayList<Region>();\n\t\tfor (int i=0; i< sortedRegions.length; i++){\n\t\t\tif (sortedRegions[i].isContainedBy(beginningBP, endingBP)) al.add(sortedRegions[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedRegions = new Region[al.size()];\n\t\tal.toArray(sortedRegions);\n\t\tupdateSliceInfo(sortedRegions, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138881": "\tpublic boolean trim(int beginningBP, int endingBP) {\n\t\tArrayList<PositionScoreText> al = new ArrayList<PositionScoreText>();\n\t\tfor (int i=0; i< sortedPositionScoreTexts.length; i++){\n\t\t\tif (sortedPositionScoreTexts[i].isContainedBy(beginningBP, endingBP)) al.add(sortedPositionScoreTexts[i]);\n\t\t}\n\t\tif (al.size() == 0) return false;\n\t\tsortedPositionScoreTexts = new PositionScoreText[al.size()];\n\t\tal.toArray(sortedPositionScoreTexts);\n\t\tupdateSliceInfo(sortedPositionScoreTexts, sliceInfo);\n\t\treturn true;\n\t}\n",
    "138917": "\tpublic void appendCommentedKeyValues (PrintWriter out){\n\t\t//any comment lines?\n\t\tif (commentLines!= null){\n\t\t\tfor (int i=0; i< commentLines.length; i++) out.println(commentLines[i]);\n\t\t\tout.println();\n\t\t}\n\t\t//print key values, spaces flanking = are permitted\n\t\tIterator<String> it = keyValues.keySet().iterator();\n\t\twhile (it.hasNext()){\n\t\t\tString key = it.next();\n\t\t\tString value = keyValues.get(key);\n\t\t\tout.println(\"# \"+key +\" = \"+value);\n\t\t}\n\t}\n",
    "138922": "\tpublic void loadTextArchiveReadMeFile (File readMeTxt) {\n\t\tFileReader fr = null;\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tfr = new FileReader (readMeTxt);\n\t\t\tbr = new BufferedReader (fr);\n\t\t\tloadTextArchiveReadMeFile (br);\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tUSeqUtilities.safeClose(fr);\n\t\t\tUSeqUtilities.safeClose(br);\n\t\t}\n\t}\n",
    "138932": "\tpublic void parseSliceName(String sliceName) throws IOException {\n\t\tMatcher mat = SLICE_NAME_SPLITTER.matcher(sliceName);\n\t\tif (mat.matches() == false) throw new IOException (\"Malformed slice name! Failed to parse the slice info from -> \"+sliceName);\n\t\tchromosome = mat.group(1);\n\t\tstrand = mat.group(2);\n\t\t//no need to catch NumberFormatException, this is checked by the NAME_SPLITTER Pattern\n\t\tfirstStartPosition = Integer.parseInt(mat.group(3));\n\t\tlastStartPosition = Integer.parseInt(mat.group(4));\n\t\tnumberRecords = Integer.parseInt(mat.group(5));\n\t\tbinaryType = mat.group(6);\n\t}\n",
    "138934": "\tpublic String getSliceName(){\n\t\treturn chromosome+strand+firstStartPosition+\"-\"+lastStartPosition+\"-\"+numberRecords+\".\"+binaryType;\n\t}\n",
    "138966": "\tpublic void setKeyValues (LinkedHashMap<String,String> keyValues) throws IOException {\n\t\tif (keyValues.containsKey(ARCHIVE_VERSION_KEY) == false || keyValues.containsKey(VERSIONED_GENOME_KEY) == false || keyValues.containsKey(DATA_TYPE_KEY) == false){\n\t\t\tthrow new IOException (\"Error: keyValues do not contain required keys.  Add '\"+ARCHIVE_VERSION_KEY+\"' and or '\"+VERSIONED_GENOME_KEY+\"' and or '\"+DATA_TYPE_KEY+\"'\");\n\t\t}\n\t\tthis.keyValues = keyValues;\n\t}\n",
    "139003": "\tpublic void dump(PrintStream str) {\n\t\tstr.println(this.getClass().getName());\n\t\tstr.println(\"guid: \" + data_type_guid);\n\t\tstr.println(\"unique: \" + unique_id);\n\t\tstr.println(\"date: \" + date_time);\n\t\tstr.println(\"locale: \" + locale);\n\n\t\tfor (AffyChpParameter param : paramMap.values()) {\n\t\t\tstr.println(param.toString());\n\t\t}\n\n\t\tfor (AffyGenericDataHeader header : children) {\n\t\t\tstr.println(\"----- child header ------\");\n\t\t\theader.dump(str);\n\t\t}\n\t}\n",
    "139093": "\tpublic String getMimeType() {\n\t\treturn FEATURES_CONTENT_TYPE;\n\t}\n",
    "139111": "\tpublic void addFileTypeHandler(FileTypeHandler fileTypeHandler) {\n\t\tString[] extensions = fileTypeHandler.getExtensions();\n\t\tfor (String extension : extensions) {\n\t\t\tif (fileTypeHandlerMap.get(extension) != null) {\n\t\t\t\tLogger.getLogger(ServerUtils.class.getName()).log(Level.SEVERE, \"duplicate SymLoaderFactory for extension {0}!!!\", new Object[]{extension});\n\t\t\t}\n\t\t\tfileTypeHandlerMap.put(extension, fileTypeHandler);\n\t\t}\n\t}\n",
    "139115": "\tpublic void removeFileTypeHandler(FileTypeHandler fileTypeHandler) {\n\t\tString[] extensions = fileTypeHandler.getExtensions();\n\t\tfor (String extension : extensions) {\n\t\t\tif (fileTypeHandlerMap.get(extension) == null) {\n\t\t\t\tLogger.getLogger(ServerUtils.class.getName()).log(Level.SEVERE, \"missing removed SymLoaderFactory for extension {0}!!!\", new Object[]{extension});\n\t\t\t}\n\t\t\tfileTypeHandlerMap.remove(extension);\n\t\t}\n\t}\n",
    "139118": "\tpublic FileTypeHandler getFileTypeHandler(String extension) {\n\t\tif (extension == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (extension.startsWith(\"x-das-feature\")) {\n\t\t\treturn fileTypeHandlerMap.get(\"das2xml\");\n\t\t}\n\t\treturn fileTypeHandlerMap.get(extension);\n\t}\n",
    "139174": "\t\tpublic Color getTextColor() {\n\t\t\tColor col = getColor();\n\t\t\tint intensity = col.getRed() + col.getGreen() + col.getBlue();\n\t\t\tif (intensity > 255+128) { return Color.BLACK; }\n\t\t\telse {\n\t\t\t\treturn Color.WHITE;\n\t\t\t}\n\t\t}\n",
    "139181": "\tpublic void writeBinary(String file_name, List<SeqSymmetry> annots) throws IOException {\n\t\tDataOutputStream dos = null;\n\t\ttry {\n\t\t\tdos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(new File(file_name))));\n\t\t\tfor (SeqSymmetry gsym : annots) {\n\t\t\t\twriteSymmetry(gsym, null, dos);\n\t\t\t}\n\t\t} finally {\n\t\t\tGeneralUtils.safeClose(dos);\n\t\t}\n\t}\n",
    "139199": "\tpublic String getMimeType() {\n\t\treturn \"binary/bgn\";\n\t}\n",
    "139216": "\tfinal public void setOrganism(String org) {\n\t\torganism = org;\n\t}\n",
    "139221": "\tpublic String getMimeType() {\n\t\treturn \"binary/brs\";\n\t}\n",
    "139236": "\tpublic BioSeq getSeq(int index) {\n\t\tfinal List<BioSeq> seq_list = getSeqList();\n\t\tif (index < seq_list.size()) {\n\t\t\treturn seq_list.get(index);\n\t\t}\n\t\treturn null;\n\t}\n",
    "139240": "\tpublic int getSeqCount() {\n\t\treturn id2seq.size();\n\t}\n",
    "139244": "\tpublic BioSeq getSeq(String synonym) {\n\t\tBioSeq aseq = id2seq.get(synonym.toLowerCase());\n\t\tif (use_synonyms && aseq == null) {\n\t\t\t// Try and find a synonym.\n\t\t\tfor (String syn : chrLookup.getSynonyms(synonym,false)) {\n\t\t\t\taseq = id2seq.get(syn.toLowerCase());\n\t\t\t\tif (aseq != null) {\n\t\t\t\t\treturn aseq;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aseq;\n\t}\n",
    "139246": "\tpublic BioSeq getSeq(SeqSymmetry sym) {\n\t\tfinal int spancount = sym.getSpanCount();\n\t\tfor (int i = 0; i < spancount; i++) {\n\t\t\tSeqSpan span = sym.getSpan(i);\n\t\t\tBioSeq seq1 = span.getBioSeq();\n\t\t\tString seqid = seq1.getID();\n\t\t\tBioSeq seq2 = id2seq.get(seqid.toLowerCase());\n\t\t\tif ((seq2 != null) && (seq1 == seq2)) {\n\t\t\t\treturn seq2;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "139267": "\tfinal public void addSeq(BioSeq seq) {\n\t\tString seqID = seq.getID();\n\t\tfinal BioSeq oldseq = id2seq.get(seqID.toLowerCase());\n\t\tif (oldseq == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tid2seq_dirty_bit = true;\n\t\t\t\tid2seq.put(seqID.toLowerCase(), seq);\n\t\t\t\tseq.setSeqGroup(this);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"ERROR! tried to add seq: \" + seqID + \" to AnnotatedSeqGroup: \" +\n\t\t\t\t\tthis.getID() + \", but seq with same id is already in group\");\n\t\t}\n\t}\n",
    "139280": "\tfinal public void addToIndex(String id, SeqSymmetry sym) {\n\t\tif (id == null || sym == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tthis.putSeqInList(id.toLowerCase(), sym);\n\t}\n",
    "139289": "\tprivate void putSeqInList(String id, SeqSymmetry sym) {\n\t\tSet<SeqSymmetry> seq_list = id2sym_hash.get(id);\n\t\tif (seq_list == null) {\n\t\t\tseq_list = new LinkedHashSet<SeqSymmetry>();\n\t\t\tid2sym_hash.put(id,seq_list);\n\t\t}\n\t\tseq_list.add(sym);\n\n\t\tString lcSymID = sym.getID().toLowerCase();\n\t\tif (id.equals(lcSymID)) {\n\t\t\treturn;\n\t\t}\n\t\tSet<String> id_list = symid2id_hash.get(lcSymID);\n\t\tif (id_list == null) {\n\t\t\tid_list = new HashSet<String>();\n\t\t\tsymid2id_hash.put(lcSymID, id_list);\n\t\t}\n\t\tid_list.add(id);\n\t}\n",
    "139292": "\tpublic boolean setProperties(Map<String,Object> propmap) {\n\t\tthis.props = propmap;\n\t\treturn true;\n\t}\n",
    "139294": "\t@Override\n\tpublic String getID() { return (String)getProperty(\"id\"); }\n",
    "139297": "\tfinal public void removeSymmetry(SeqSymmetry sym) {\n\t\tif (sym == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i=0; i<sym.getChildCount(); i++){\n\t\t\tremoveSymmetry(sym.getChild(i));\n\t\t}\n\t\t\n\t\tif(sym.getID() == null)\n\t\t\treturn;\n\n\t\tString lcSymID = sym.getID().toLowerCase();\n\t\tremoveSymmetry(lcSymID, sym);\n\t\t\n\t\tif(sym instanceof UcscGeneSym){\n\t\t\tlcSymID = ((UcscGeneSym)sym).getGeneName();\n\t\t\tif(lcSymID != null){\n\t\t\t\tremoveSymmetry(lcSymID.toLowerCase(), sym);\n\t\t\t}\n\t\t}\n\t}\n",
    "139298": "\tpublic void removeCdsSpans(){\n\t\tList<SeqSymmetry> remove_list = new ArrayList<SeqSymmetry>();\n\t\tfor(SeqSymmetry child : children) {\n\t\t\tif (isCdsSym(child)) {\n\t\t\t\tremove_list.add(child);\n\t\t\t}\n\t\t}\n\t\tchildren.removeAll(remove_list);\n\t}\n",
    "139367": "\tpublic String getGroup()  {\n\t\tif (is_gff1) return group;\n\t\telse return null;\n\t}\n",
    "139383": "\tpublic void removeSpans() {\n\t\tthrow new RuntimeException(\"can't removeSpans(), MutableSingletonSeqSymmetry is not mutable itself, only its children\");\n\t}\n",
    "139385": "\tpublic void clear() {\n\t\tthrow new RuntimeException(\"can't clear(), MutableSingletonSeqSymmetry is not mutable itself, only its children\");\n\t}\n",
    "139418": "\tprotected float getYCoordFromX(int x) {\n\t\tint leftBound = this.determineBegIndex(x);\n\t\tif (this.getGraphXCoord(leftBound) == x || (this.hasWidth && this.getGraphXCoord(leftBound) + this.getGraphWidthCoord(leftBound) >= x)) {\n\t\t\t// Right on the point or in a region bound by its width\n\t\t\treturn this.getGraphYCoord(leftBound);\n\t\t}\n\t\t// Couldn't find point\n\t\treturn -1f;\n\t}\n",
    "139442": "\tpublic MutableSeqSpan getChildSpan(int child_index, BioSeq aseq, MutableSeqSpan result_span) {\n\t\tif ((child_index >= child_mins.length) ||\n\t\t\t\t(aseq != getBioSeq()) ||\n\t\t\t\t(result_span == null)) {\n\t\t\treturn null;\n\t\t\t\t}\n\t\tif (forward) { result_span.set(child_mins[child_index], child_mins[child_index] + getProbeLength(), aseq); }\n\t\telse { result_span.set(child_mins[child_index] + getProbeLength(), child_mins[child_index], aseq); }\n\t\treturn result_span;\n\t}\n",
    "139473": "\tpublic String getID() {\n\t\tString rootid = Integer.toString(getIntID());\n\t\tif (getIDPrefix() == null) {\n\t\t\treturn rootid;\n\t\t}\n\t\telse {\n\t\t\treturn (getIDPrefix() + rootid);\n\t\t}\n\t}\n",
    "139508": "\tpublic boolean setProperty(String key, Object val) {\n\t\tif (key.equals(\"id\")) {\n\t\t\tsetID((String)val);\n\t\t\treturn true;\n\t\t}\n\t\telse  {\n\t\t\tSystem.err.println(\"IndexedSingletonSym does not support setting properties, except for id\");\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "139518": "\tpublic BioSeq getSpanSeq(int index) {\n\t\tif (index == 0) { return seq; }\n\t\telse { return null; }\n\t}\n",
    "139524": "\tpublic boolean setProperty(String key, Object val) {\n\t\treturn false;\n\t}\n",
    "139608": "\tpublic int getLength() {\n\t\treturn (end > start ? end-start : start-end);\n\t}\n",
    "139614": "\tpublic int getLength() {\n\t\tdouble dl = getLengthDouble();\n\t\tif (dl > Integer.MAX_VALUE)  {\n\t\t\treturn (Integer.MAX_VALUE - 1);\n\t\t}\n\t\telse  {\n\t\t\treturn (int)dl;\n\t\t}\n\t}\n",
    "139686": "\tprivate void constructorTest(String id, String version, String err_msg) {\n\t\ttry {\n\t\t\tBioSeq testseq = new BioSeq(id, version, 0);\n\t\t\tfail(err_msg);\n\t\t} catch (IllegalArgumentException e) { }\n\t}\n",
    "139690": "\tprivate void constructorTest(String id, String version, int len, String err_msg) {\n\t\ttry {\n\t\t\tBioSeq testseq = new BioSeq(id, version, len);\n\t\t\tfail(err_msg);\n\t\t} catch (IllegalArgumentException e) { }\n\t}\n",
    "139797": "\tprivate String createTestString() {\n\t\tStringBuffer testBuffer = new StringBuffer(256*2);\n\t\tchar[] nibble2char = {'A', 'C', 'G', 'T', 'N', 'M', 'R', 'W', 'S', 'Y', 'K', 'V', 'H', 'D', 'B', 'U'};\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\tfor (int j = 0; j < 16; j++) {\n\t\t\t\tString tempString = String.valueOf(nibble2char[i]) + String.valueOf(nibble2char[j]);\n\t\t\t\tassertEquals(2, tempString.length());\n\t\t\t\ttestBuffer.append(tempString);\n\t\t\t}\n\t\t}\n\t\tString testString = testBuffer.toString();\n\t\tassertEquals(256*2, testString.length());\n\t\treturn testString;\n\t}\n",
    "139829": "\tpublic void testWriteFormat() throws IOException {\n\n\t\tString string =\n\t\t\t\t\"948025\t0.128646\\n\" +\n\t\t\t\t\"948026\t0.363933\\n\";\n\t\tInputStream istr = new ByteArrayInputStream(string.getBytes());\n\n\t\tAnnotatedSeqGroup group = new AnnotatedSeqGroup(\"Test Group\");\n\t\tString stream_name = \"test_file\";\n\t\tboolean ensure_unique_id = true;\n\n\n\t\tBioSeq aseq = group.addSeq(stream_name, 1000);\n\n\n\t\tGraphSym gr0 = GrParser.parse(istr, aseq, stream_name, ensure_unique_id);\n\n\t\tByteArrayOutputStream outstream = new ByteArrayOutputStream();\n\n\t\tGrParser.writeGrFormat(gr0, outstream);\n\n\t\tassertEquals(string, outstream.toString());\n\t}\n",
    "139846": "\tpublic void testWriteFormat() throws IOException {\n\n\t\tString string =\n\t\t\t\t\t\t\"16\t948025\t0.128646\\n\" +\n\t\t\t\t\t\t\"16\t948026\t0.363933\\n\";\n\t\tInputStream istr = new ByteArrayInputStream(string.getBytes());\n\n\t\tAnnotatedSeqGroup group = new AnnotatedSeqGroup(\"Test Group\");\n\t\tboolean annot_seq = true;\n\t\tString stream_name = \"test_file\";\n\t\tboolean ensure_unique_id = true;\n\n\t\tList<GraphSym> results = SgrParser.parse(istr, stream_name, group, annot_seq, ensure_unique_id);\n\n\t\tByteArrayOutputStream outstream = new ByteArrayOutputStream();\n\t\t\n\t\tSgrParser.writeSgrFormat(results.get(0), outstream);\n\n\t\tassertEquals(string, outstream.toString());\n\t}\n",
    "139906": "\tpublic String getAppVersion() {\n\t\treturn APP_VERSION;\n\t}\n",
    "139910": "\tpublic String getAppVersionFull() {\n\t\treturn APP_VERSION_FULL;\n\t}\n",
    "139913": "\tpublic boolean getUpdateAvailable(){\n\t\treturn updateAvailable;\n\t}\n",
    "139918": "\tpublic String getArg(String label, String[] args) {\n\t\tString to_return = null;\n\t\tboolean got_it = false;\n\t\tif (label != null && args != null) {\n\t\t\tfor (String item : args) {\n\t\t\t\tif (got_it) {\n\t\t\t\t\tto_return = item;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (item.equals(label)) {\n\t\t\t\t\tgot_it = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (got_it && to_return == null) {\n\t\t\tto_return = \"true\";\n\t\t}\n\t\treturn to_return;\n\t}\n",
    "139928": "\tpublic String getAppDataDirectory() {\n\t\tif (app_dir == null) {\n\t\t\tString home = System.getProperty(\"user.home\");\n\t\t\tString app_data = home + \"/Application Data\";\n\t\t\tFile app_data_dir = new File(app_data);\n\t\t\tif (app_data_dir.exists() && app_data_dir.isDirectory()) {\n\t\t\t\tapp_dir = app_data + \"/IGB/\";\n\t\t\t} else {\n\t\t\t\tapp_dir = home + \"/.igb/\";\n\t\t\t}\n\t\t}\n\t\tif (!app_dir.endsWith(\"/\")) {\n\t\t\tapp_dir = app_dir + \"/\";\n\t\t}\n\t\treturn app_dir;\n\t}\n",
    "139935": "\tpublic String getUCSCQuery(){\n\t\tBioSeq aseq = igbService.getSeqMapView().getAnnotatedSeq();\n\n\t\tif (aseq == null) { return \"\"; }\n\n        String UcscVersion = getUcscGenomeVersion(aseq.getVersion());\n        if(!UcscVersion.isEmpty()){\n            return \"db=\" + UcscVersion + \"&position=\" + getRegionString();\n        }\n\n        return \"\";\n    }\n",
    "139940": "\tprivate String getRegionString() {\n\t\tSeqSpan span = igbService.getSeqMapView().getVisibleSpan();\n\t\treturn span.getBioSeq() + \":\" + span.getMin() + \"-\" + span.getMax();\n\t}\n",
    "140010": "\tpublic void runEventually() {\n\t\t// Note: we do NOT want to simply call SwingUtilities.invokeLater(this)\n\t\t// because that would cause this thread to actually run ON the Swing thread\n\t\t// (potentially freezing the GUI)\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tstart();\n\t\t\t}\n\t\t});\n\t}\n",
    "140021": "\tprivate BookmarkList getSubListByName(String name, boolean create) {\n\t\tBookmarkList result = null;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tEnumeration<BookmarkList> childs = children();\n\t\twhile (childs.hasMoreElements()) {\n\t\t\tBookmarkList tn = childs.nextElement();\n\t\t\tObject o = tn.getUserObject();\n\t\t\tif (o instanceof String) {\n\t\t\t\tif (name.equals(o)) {\n\t\t\t\t\tresult = tn;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (create && result == null) {\n\t\t\tresult = new BookmarkList(name);\n\t\t\tthis.add(result);\n\t\t}\n\t\treturn result;\n\t}\n",
    "140029": "\tpublic BookmarkList getSubListByPath(String path, String delimiter, boolean create) {\n\t\tStringTokenizer st = new StringTokenizer(path, delimiter);\n\t\tBookmarkList current_list = this;\n\t\twhile (current_list != null && st.hasMoreElements()) {\n\t\t\tString name = st.nextToken();\n\t\t\tcurrent_list = current_list.getSubListByName(name, create);\n\t\t}\n\t\treturn current_list;\n\t}\n",
    "140031": "\tpublic void printText(PrintStream out) {\n\t\tprintTextRecursively(out, \"\");\n\t}\n",
    "140032": "\tpublic boolean isIGBRunning(){\n\t\tSocket sock = null;\n\t\tint port = SimpleBookmarkServer.default_server_port;\n\t\ttry {\n\t\t    sock = new Socket(\"localhost\", port);\n\t\t    if (sock.isBound()) {\n\t\t    \t//try to bring to front\n\t\t    \tURL toSend = new URL (\"http://localhost:\"+port+\"/IGBControl?bringIGBToFront=true\");\n\t\t    \tHttpURLConnection conn = (HttpURLConnection)toSend.openConnection();\n\t\t        conn.getResponseMessage();\n\t\t    \treturn true;\n\t\t    }\n\t\t} catch (Exception e) {\n\t\t\t//Don't do anything. isBound() throws an error when trying to bind a bound port\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (sock != null) sock.close();\n\t\t\t} catch (IOException e) {}\n\t\t}\n\t\treturn false;\n\t}\n",
    "140039": "\tpublic boolean equals(Object o) {\n\t\treturn (this == o);\n\t}\n",
    "140044": "\tpublic boolean isUnibrowControl() {\n\t\tString host = getURL().getHost();\n\t\tString path = getURL().getPath();\n\t\treturn ((\"localhost\".equals(host) || \"127.0.0.1\".equals(host))\n\t\t\t\t&& (path.equals(\"/\" + SimpleBookmarkServer.SERVLET_NAME) || path.equals(\"/\" + SimpleBookmarkServer.SERVLET_NAME_OLD)));\n\t}\n",
    "140050": "    private SymBookmark getLast(){\n        if(syms.size() > 0){\n            return syms.get(syms.size() - 1);\n        }\n        throw new IndexOutOfBoundsException(\"No parsers in bookmark\");\n    }\n",
    "140052": "   public void set(SymWithProps mark_sym) {\n\t\tList<String> queries = new ArrayList<String>();\n\t\tList<String> servers = new ArrayList<String>();\n\n        for(SymBookmark bookmark : this.syms){\n\t\t\tif(!bookmark.isGraph()){\n\t\t\t\tservers.add(bookmark.getServer());\n\t\t\t\tqueries.add(bookmark.getPath());\n\t\t\t}\n        }\n\t\t\n\t\tmark_sym.setProperty(Bookmark.QUERY_URL, queries.toArray(new String[queries.size()]));\n\t    mark_sym.setProperty(Bookmark.SERVER_URL, servers.toArray(new String[servers.size()]));\n\n    }\n",
    "140076": "\tprivate void buildMenus(JRPMenu pp, BookmarkList bl) {\n\t\tJRPMenu bl_menu = (JRPMenu) component_hash.get(bl);\n\t\tif (bl_menu == null) {\n\t\t\tbl_menu = addBookmarkListMenu(pp, bl);\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tEnumeration<BookmarkList> e = bl.children();\n\t\twhile (e.hasMoreElements()) {\n\t\t\tBookmarkList node = e.nextElement();\n\t\t\tObject o = node.getUserObject();\n\t\t\tif (o instanceof String) {\n\t\t\t\tbuildMenus(bl_menu, node);\n\t\t\t} else if (o instanceof Bookmark) {\n\t\t\t\taddBookmarkMI(bl_menu, (Bookmark) o);\n\t\t\t} else if (o instanceof Separator) {\n\t\t\t\taddSeparator(bl_menu, (Separator) o);\n\t\t\t}\n\t\t}\n\n\t}\n",
    "140079": "\tprotected void bookmarkCurrentPosition() {\n\t\tBookmark bookmark = getCurrentPosition();\n\t\tif (bookmark != null) {\n\t\t\tBookmarkEditor.init(bookmark);\n\t\t\tBookmarkEditor.run();\n\t\t}\n\t}\n",
    "140081": "\tprivate JRPMenuItem addBookmarkMI(JRPMenu parent_menu, Bookmark bm) {\n\t\tJRPMenuItem markMI = (JRPMenuItem) component_hash.get(bm);\n\t\tif (markMI != null) {\n\t\t\treturn markMI;\n\t\t}\n\t\tmarkMI = new BookmarkJMenuItem(getIdFromName(bm.getName()), bm);\n\t\tcomponent_hash.put(bm, markMI);\n\t\tparent_menu.add(markMI);\n\t\tmarkMI.addActionListener(this);\n\t\treturn markMI;\n\t}\n",
    "140082": "\tprivate void importBookmarks(BookmarkList bookmark_list) {\n\t\tJFileChooser chooser = getJFileChooser(false);\n\t\tchooser.setCurrentDirectory(getLoadDirectory());\n\t\tint option = chooser.showOpenDialog(null);\n\t\tif (option == JFileChooser.APPROVE_OPTION) {\n\t\t\tsetLoadDirectory(chooser.getCurrentDirectory());\n\t\t\ttry {\n\t\t\t\tFile fil = chooser.getSelectedFile();\n\t\t\t\tBookmarksParser.parse(bookmark_list, fil);\n\t\t\t\tAddBookmarkAction.addNode(bookmark_list);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tErrorHandler.errorPanel(\"Error importing bookmarks\", ex, Level.SEVERE);\n\t\t\t}\n\t\t}\n\t}\n",
    "140084": "\tpublic void setValuesFromMap(Map<String, String[]> map) {\n\t\tif (map == null) {\n\t\t\tthrow new IllegalArgumentException(\"Map was null\");\n\t\t}\n\t\tduples = new ArrayList<Duple>();\n\t\tfor (Map.Entry<String, String[]> entry : map.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tString[] value = entry.getValue();\n\t\t\tif (value.length == 0) {\n\t\t\t\tduples.add(new Duple(key, \"\"));\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < value.length; i++) {\n\t\t\t\t\tDuple duple = new Duple(key, value[i]);\n\t\t\t\t\tduples.add(duple);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = EXTRA_ROWS; i > 0; i--) {\n\t\t\tduples.add(new Duple(\"\", \"\"));\n\t\t}\n\t\tfireTableDataChanged();\n\t}\n",
    "140092": "\tprivate JRPMenu addBookmarkListMenu(JRPMenu parent_menu, BookmarkList bm_list) {\n\t\tJRPMenu sub_menu = (JRPMenu) component_hash.get(bm_list);\n\t\tif (sub_menu != null) {\n\t\t\treturn sub_menu;\n\t\t}\n\t\tsub_menu = new JRPMenu(getIdFromName(bm_list.getName()), bm_list.getName());\n\t\tcomponent_hash.put(bm_list, sub_menu);\n\t\tparent_menu.add(sub_menu);\n\t\treturn sub_menu;\n\t}\n",
    "140162": "\tpublic void focusGained(FocusEvent e) {\n\t}\n",
    "140167": "\tpublic void focusLost(FocusEvent e) {\n\t\tObject src = e.getSource();\n\t\tif (src instanceof JTextField) {\n\t\t\tdoAction(src);\n\t\t}\n\t}\n",
    "140282": "  private void registerKeyStrokes() {\n    KeyStroke copyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK, false);\n    KeyStroke pasteStroke = KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK, false);\n\n    jTable1.registerKeyboardAction(copyAction , (String) copyAction.getValue(Action.NAME), \n        copyStroke, JComponent.WHEN_FOCUSED);\n    jTable1.registerKeyboardAction(pasteAction, (String) pasteAction.getValue(Action.NAME), \n        pasteStroke, JComponent.WHEN_FOCUSED);\n  }\n",
    "140283": "  private boolean isValidSelectionForCopy() {\n    int numcols=jTable1.getSelectedColumnCount();\n    int numrows=jTable1.getSelectedRowCount();\n    int[] rowsselected=jTable1.getSelectedRows();\n    int[] colsselected=jTable1.getSelectedColumns();\n    if (numrows==0 || numcols==0) {\n      return false;\n    }\n    boolean isValid = ((numrows-1==rowsselected[rowsselected.length-1]-rowsselected[0] &&\n        numrows==rowsselected.length) &&\n        (numcols-1==colsselected[colsselected.length-1]-colsselected[0] &&\n        numcols==colsselected.length));\n    return isValid;\n  }\n",
    "140369": "\tprivate Bundle getNameInfoBundle(Point p) {\n        int row = bundleTable.rowAtPoint(p);\n        int column = bundleTable.columnAtPoint(p);\n\t\tif (column == bundleTableModel.getColumnIndex(BUNDLE_NAME)) {\n            Bundle bundle = getBundleAtRow(row);\n            Rectangle r = bundleTable.getCellRect(row, column, false);\n            NameInfoPanel nameInfoPanel = NameInfoPanel.getPanel(bundle); // kludge\n            if (nameInfoPanel.isOnInfoIcon(p.x - r.x, p.y - r.y)) {\n            \treturn bundle;\n            }\n\t\t}\n\t\treturn null;\n\t}\n",
    "140389": "\tprivate void createFactory(ServiceReference<IGBService> igbServiceReference) {\n        try {\n        \tIGBService igbService = bundleContext.getService(igbServiceReference);\n    \t\tList<String> extensions = new ArrayList<String>();\n    \t\textensions.add(\"igb\");\n    \t\tScriptProcessorHolder.getInstance().addScriptProcessor(new IGBScriptProcessor(igbService));\n       } catch (Exception ex) {\n            System.out.println(this.getClass().getName() + \" - Exception in Activator.createPage() -> \" + ex.getMessage());\n            ex.printStackTrace(System.out);\n        }\n\t}\n",
    "140435": "\tpublic String getMimeType() {\n\t\treturn \"text/bb\";\n\t}\n",
    "140445": "\tprivate String join(String[] fields, int startField) {\n\t\tStringBuilder buffer = new StringBuilder(\"\");\n\t\tfor (int i = startField; i < fields.length; i++) {\n\t\t\tbuffer.append(fields[i]);\n\t\t}\n\t\treturn buffer.toString();\n\t}\n",
    "140475": "\tpublic int getColumnIndex(String key) {\n\t\tfor (int i = 0; i < columns.size(); i++) {\n\t\t\tif (columns.get(i).getTitle().equals(PluginsView.BUNDLE.getString(key))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n",
    "140480": "\tpublic void setJTable(JTable jTable) {\n\t\tfor (int i = 0; i < columns.size(); i++) {\n\t\t\tBundleColumn bundleColumn = columns.get(i);\t\t\t\n\t\t\tTableColumn checkboxColumn = jTable.getColumnModel().getColumn(i);\n\t\t\tbundleColumn.formatColumn(jTable, checkboxColumn);\n\t\t}\n\t}\n",
    "140504": "\tprivate boolean isLatest(Bundle bundle) {\n\t\treturn bundle.getVersion().equals(getLatestVersion(bundle));\n\t}\n",
    "140520": "\tprivate BundleFilter getBundleFilter() {\n\t\tBundleFilter bundleFilter = null;\n\t\tif (isShowInstalledBundles && isShowUninstalledBundles) {\n\t\t\tbundleFilter = BOTH_BUNDLE_FILTER;\n\t\t}\n\t\telse if (isShowInstalledBundles && !isShowUninstalledBundles) {\n\t\t\tbundleFilter = INSTALLED_BUNDLE_FILTER;\n\t\t}\n\t\telse if (!isShowInstalledBundles && isShowUninstalledBundles) {\n\t\t\tbundleFilter = UNINSTALLED_BUNDLE_FILTER;\n\t\t}\n\t\telse if (!isShowInstalledBundles && !isShowUninstalledBundles) {\n\t\t\tbundleFilter = NEITHER_BUNDLE_FILTER;\n\t\t}\n\t\treturn bundleFilter;\n\t}\n",
    "140544": "\tprivate void setRepositoryBundles() {\n\t\tResource[] allResourceArray = repoAdmin.discoverResources(\"(symbolicname=*)\");\n\t\tList<Bundle> repositoryBundles = new ArrayList<Bundle>();\n\t\tfor (Resource resource : allResourceArray) {\n\t\t\tif (checkRequirements(resource.getRequirements())) {\n\t\t\t\trepositoryBundles.add(new ResourceWrapper(resource));\n\t\t\t}\n\t\t}\n\t\tsetRepositoryBundles(repositoryBundles);\n\t}\n",
    "140563": "\tprivate void reloadBundleTable() {\n\t\tfilterBundles();\n\t\tbundleTableModel.fireTableDataChanged();\n\t}\n",
    "140569": "  public void setVisibleMinPercent(float percent) {\n\t\tfor (AbstractGraphGlyph gl : graphs) {\n      Object info = gl.getInfo();\n      float[] percent2score = info2pscores.get(info);\n      float min_score = percent2score[Math.round(percent * sliders_per_percent)];\n      gl.setVisibleMinY(min_score);\n    }\n  }\n",
    "140570": "\tpublic void deactivate() {\n\t\tisShowInstalledBundles = false;\n\t\tisShowUninstalledBundles = false;\n\t\tbundleContext.removeBundleListener(bundleListener);\n\t\tbundleContext = null;\n\t}\n",
    "140572": "  public void setVisibleMaxPercent(float percent) {\n\t\tfor (AbstractGraphGlyph gl : graphs) {\n      Object info = gl.getInfo();\n      float[] percent2score = info2pscores.get(info);\n      float max_score = percent2score[Math.round(percent * sliders_per_percent)];\n      gl.setVisibleMaxY(max_score);\n    }\n  }\n",
    "140621": "\tprivate void setInstalledBundles(List<Bundle> installedBundles) {\n\t\tthis.installedBundles = installedBundles;\n\t\tsetUnfilteredBundles();\n\t}\n",
    "140634": "\tprivate void setRepositoryBundles(List<Bundle> repositoryBundles) {\n\t\tthis.repositoryBundles = repositoryBundles;\n\t\tsetUnfilteredBundles();\n\t}\n",
    "140655": "\tprivate void setBundleFilter(BundleFilter bundleFilter) {\n\t\tthis.bundleFilter = bundleFilter;\n\t}\n",
    "140666": "\tprivate void adjustThreshStartShift(Collection<AbstractGraphGlyph> glyphs, int shift) {\n\t\tIterator<AbstractGraphGlyph> iter = glyphs.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tAbstractGraphGlyph sggl = iter.next();\n\t\t\tsggl.setThreshStartShift(shift);\n\t\t}\n\t\twidg.updateWidget();\n\t}\n",
    "140672": "\tprivate void saveDividerLocation() {\n\t\tif (getDividerLocation() == 0 || getFullSize() == 0) {\n\t\t\treturn;\n\t\t}\n\t\tsaveDividerProportionalLocation = (double) getDividerLocation() / (double) getFullSize();\n\t}\n",
    "140677": "\tprivate void adjustThreshEndShift(Collection<AbstractGraphGlyph> glyphs, int shift) {\n\t\tIterator<AbstractGraphGlyph> iter = glyphs.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tAbstractGraphGlyph sggl = iter.next();\n\t\t\tsggl.setThreshEndShift(shift);\n\t\t}\n\t\twidg.updateWidget();\n\t}\n",
    "140678": "\tprivate void saveWindowLocations() {\n\t\t// Save the main window location\n\t\tPreferenceUtils.saveWindowLocation(frame, \"main window\");\n\n\t\tfor (TabHolder tabHolder : tabHolders.values()) {\n\t\t\ttabHolder.close();\n\t\t}\n\t\tfor (IGBTabPanel comp : tabHolders.get(TabState.COMPONENT_STATE_WINDOW).getPlugins()) {\n\t\t\tPreferenceUtils.saveWindowLocation(comp.getFrame(), comp.getName());\n\t\t}\n\t}\n",
    "140687": "\tprivate void setTabMenu(final IGBTabPanel plugin) {\n\t\tJMenu menu = tabMenus.get(plugin);\n\t\tTabState tabState = getTabState(plugin);\n\t\tfor (int i = 0; i < menu.getItemCount(); i++) {\n\t\t\tJMenuItem menuItem = menu.getItem(i);\n\t\t\tif (menuItem != null && menuItem instanceof TabStateMenuItem) {\n\t\t    \tmenuItem.setSelected(((TabStateMenuItem)menuItem).getTabState() == tabState);\n\t\t\t}\n\t\t}\n\t}\n",
    "140691": "\tpublic void removeTab(final IGBTabPanel plugin) {\n\t\tfor (TabState tabState : tabHolders.keySet()) {\n\t\t\ttabHolders.get(tabState).removeTab(plugin);\n\t\t}\n\t\tfor (Component item : Arrays.asList(tabs_menu.getMenuComponents())) {\n\t\t\tif (item instanceof JMenuItem && ((JMenuItem)item).getText().equals(plugin.getDisplayName())) {\n\t\t\t\ttabs_menu.remove(item);\n\t\t\t}\n\t\t}\n\t\tPreferenceUtils.saveComponentState(plugin.getName(), null);\n\t}\n",
    "140692": "\tprivate void setTabState(IGBTabPanel panel, TabState tabState) {\n\t\tif (panel == null || tabState == getTabState(panel)) {\n\t\t\treturn;\n\t\t}\n\t\tTabState oldTabState = getTabState(panel);\n\t\tif (oldTabState != null) {\n\t\t\ttabHolders.get(oldTabState).removeTab(panel);\n\t\t}\n\t\tif (tabState == null) {\n\t\t\tremoveTab(panel);\n\t\t}\n\t\telse {\n\t\t\ttabHolders.get(tabState).addTab(panel);\n\t\t}\n\t\tPreferenceUtils.saveComponentState(panel.getName(), tabState.name());\n\t}\n",
    "140735": "\tprivate TabState getTabState(IGBTabPanel panel) {\n\t\tfor (TabState tabState : tabHolders.keySet()) {\n\t\t\tif (tabHolders.get(tabState).getPlugins().contains(panel)) {\n\t\t\t\treturn tabState;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "140738": "\tpublic String getMimeType() {\n\t\treturn \"text/bw\";\n\t}\n",
    "140742": "\tprivate void hideTray() {\n\t\tif (trayState == TrayState.HIDDEN) {\n\t\t\treturn;\n\t\t}\n\t\tif (trayState == TrayState.WINDOW) {\n\t\t\tunWindow();\n\t\t}\n\t\tif (trayState == TrayState.EXTENDED) {\n\t\t\tsaveDividerLocation();\n\t\t}\n\t\tsetDividerLocation(getHideDividerLocation());\n\t\tsetDividerSize(0);\n\t\ttrayState = TrayState.HIDDEN;\n\t\tPreferenceUtils.saveComponentState(title, TrayState.HIDDEN.toString());\n\t\tnotifyTrayStateChangeListeners();\n\t}\n",
    "140750": "\tprivate void extendTray() {\n\t\tif (trayState == TrayState.WINDOW) {\n\t\t\tunWindow();\n\t\t}\n\t\tsetDividerLocation(getExtendDividerLocation());\n\t\tsetDividerSize(DIVIDER_SIZE);\n\t\ttrayState = TrayState.EXTENDED;\n\t\tPreferenceUtils.saveComponentState(title, TrayState.EXTENDED.toString());\n\t\tnotifyTrayStateChangeListeners();\n\t\ttab_pane.setIconAt(0, getRetractIcon());\n\t\ttab_pane.setToolTipTextAt(0, \"retract tray\");\n\t\tif (tab_pane.getSelectedIndex() < 1) {\n\t\t\ttab_pane.setSelectedIndex(1);\n\t\t}\n\t}\n",
    "140759": "\tprivate void retractTray() {\n\t\tif (trayState == TrayState.WINDOW) {\n\t\t\tunWindow();\n\t\t}\n\t\tif (trayState == TrayState.EXTENDED) {\n\t\t\tsaveDividerLocation();\n\t\t}\n\t\tint retractDividerLocation = getRetractDividerLocation();\n\t\tif (retractDividerLocation != -1) {\n\t\t\tsetDividerLocation(retractDividerLocation);\n\t\t\tretractDividerSet = true;\n\t\t}\n\t\tsetDividerSize(0);\n\t\ttrayState = TrayState.RETRACTED;\n\t\tPreferenceUtils.saveComponentState(title, TrayState.RETRACTED.toString());\n\t\tnotifyTrayStateChangeListeners();\n\t\ttab_pane.setIconAt(0, getExtendIcon());\n\t\ttab_pane.setToolTipTextAt(0, \"extend tray\");\n\t}\n",
    "140786": "\tpublic void invokeTrayState(TrayState newState) {\n\t\tif (trayState == newState) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (newState) {\n\t\t\tcase HIDDEN:\n\t\t\t\thideTray();\n\t\t\t\tbreak;\n\t\t\tcase RETRACTED:\n\t\t\t\tretractTray();\n\t\t\t\tbreak;\n\t\t\tcase EXTENDED:\n\t\t\t\textendTray();\n\t\t\t\tbreak;\n\t\t\tcase WINDOW:\n\t\t\t\twindowTray();\n\t\t\t\tbreak;\n\t\t}\n\t}\n",
    "140835": "\tprotected JRPTabbedPane createTabbedPane(String id, int tabPlacement) {\n\t\treturn new JRPTabbedPane(id, tabPlacement);\n\t}\n",
    "140850": "\tprivate void notifyTrayStateChangeListeners() {\n\t\tfor (TrayStateChangeListener trayStateChangeListener : trayStateChangeListeners) {\n\t\t\ttrayStateChangeListener.trayStateChanged(this, trayState);\n\t\t}\n\t}\n",
    "140853": "    private void no_data() {\n        frm.setTitle(\" ProtAnnot\");\n        gview.setTitle(\"\");\n        gview.no_data();\n\t\tshowhairline.setEnabled(false);\n    }\n",
    "140854": "\tpublic void addTrayStateChangeListener(TrayStateChangeListener trayStateChangeListener) {\n\t\ttrayStateChangeListeners.add(trayStateChangeListener);\n\t}\n",
    "140855": "\tprivate BioSeq processDocument(Document seqdoc) {\n       Element top_element = seqdoc.getDocumentElement();\n\t\tString name = top_element.getTagName();\n\t\tif (!name.equalsIgnoreCase(\"dnaseq\")) {\n\t\t\treturn null;\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.err.println(\"processing dna seq\");\n\t\t}\n\t\tString version = \"\";\n\t\ttry {\n\t\t\tversion = top_element.getAttribute(\"version\");\n\t\t} catch (Exception e) {\n\t\t\t// ignore exception\n\t\t}\n\t\tString seq = \"genome\";\n\t\ttry {\n\t\t\tseq = top_element.getAttribute(\"seq\");\n\t\t} catch (Exception e) {\n\t\t\t// ignore exception\n\t\t}\n\n\t\tBioSeq chrom = buildChromosome(top_element, seq, version);\n\n\t\tprocessDNASeq(chrom, top_element);\n\n\t\treturn chrom;\n    }\n",
    "140857": "\tpublic void removeTrayStateChangeListener(TrayStateChangeListener trayStateChangeListener) {\n\t\ttrayStateChangeListeners.remove(trayStateChangeListener);\n\t}\n",
    "140860": "    private void processDNASeq(BioSeq genomic, Element elem) {\n        NodeList children = elem.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n            String name = child.getNodeName();\n            if (name != null) {\n                if (name.equalsIgnoreCase(\"genesearch\")) {\n                    processGeneSearch(genomic, (Element) child);\n                } else {\n                    if (name.equalsIgnoreCase(MRNASTR)) {\n                        processMRNA(genomic, (Element) child);\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n            String name = child.getNodeName();\n            if (name != null && name.equalsIgnoreCase(\"aaseq\")) {\n                processProtein(prot_hash, (Element) child);\n            }\n        }\n    }\n",
    "140862": "    private void setUpPanels() {\n        Container cpane = frm.getContentPane();\n        cpane.setLayout(new BorderLayout());\n        gview = new GenomeView(prefs_hash);\n        cpane.add(\"Center\", gview);\n        print_panel = new ComponentPagePrinter(gview);\n    }\n",
    "140901": "    public void windowClosing(WindowEvent evt) {\n       if (evt.getSource() == frm) {\n\t\t\tupdatePrefs(gview.getColorPrefs());\n\n\t\t\tJFrame frame = (JFrame) evt.getComponent();\n\n\t\t\tString message = \"Do you really want to exit?\";\n\t\t\tif (confirmPanel(message)) {\n\t\t\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\t\t} else {\n\t\t\t\tframe.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n\t\t\t}\n\t\t}\n    }\n",
    "140919": "\tpublic void setStatus(final String text) {\n\t\tThreadUtils.runOnEventQueue(new Runnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\tstatus_bar.setText(text);\n\t\t\t}\n\t\t});\n\t}\n",
    "140931": "\tprivate void addHelpActions(final JMenu help_menu){\n        MenuUtil.addToMenu(help_menu, new JMenuItem(Actions.getAboutAction()));\n\t\tMenuUtil.addToMenu(help_menu, new JMenuItem(Actions.getReportBugAction()));\n\t\tMenuUtil.addToMenu(help_menu, new JMenuItem(Actions.getFeatureAction()));\n\t\tMenuUtil.addToMenu(help_menu, new JMenuItem(Actions.getShowConsoleAction()));\n\t}\n",
    "140945": "\tstatic private boolean moveToFailedDir(String filename){\n\t\tFile file = new File(filename);\n\t\tFile dir = new File(file.getParentFile().getPath() + \"/failed\");\n\t\tif(!dir.exists()){\n\t\t\tdir.mkdir();\n\t\t}\n\t\tFile newFile = new File(dir.getPath() + \"/\" + file.getName());\n\t\tif(newFile.exists()){\n\t\t\tnewFile.delete();\n\t\t}\n\t\treturn file.renameTo(newFile);\n\t}\n",
    "140947": "\tstatic private void printUsage(){\n\t\tSystem.err.println(\"Usage: java -cp protannot_exe.jar org.bioviz.protannot.TestSamples [dir_path]\");\n\t}\n",
    "141026": "\tprivate void load(File seqfile) {\n\n\t\tFileInputStream fistr = null;\n\t\ttry {\n\t\t\tfistr = new FileInputStream(seqfile);\n\t\t\tload(fistr, seqfile.getName());\n\t\t} catch (Exception e) {\n\t\t\tReporter.report(\"Couldn't read file: \" + e.getMessage(), e, false, false, true);\n\t\t} finally {\n\t\t\tGeneralUtils.safeClose(fistr);\n\t\t}\n\t}\n",
    "141028": "    private void initPrefs(Map<String,Color> phash) {\n        tempColorPrefs(phash);\n        prefs_hash = phash;\n    }\n",
    "141037": "    private void parseArguments(String[] args) {\n\n       if(args.length  == 1)\n\t   {\n\t\t   checkArguments(\"\",args[0]);\n       }else if(args.length%2 == 0)\n       {\n\t\t   for(int i=0; i<args.length; i += 2)\n\t\t\t   checkArguments(args[i],args[i+1]);\n       }\n       else\n           outputErrorMessage(\"Invalid number of arguments\");\n    }\n",
    "141040": "    public void addMapListener(MouseListener listener) {\n        seqmap.addMouseListener(listener);\n        axismap.addMouseListener(listener);\n    }\n",
    "141053": "    private boolean addToArgumentDictionary(String[] args) {\n\n       for(int i=0; i<args.length; i+=2)\n       {\n            if(Arguments.getValue(args[i])!=null)\n                ArgumentValues.put(Arguments.getValue(args[i]), args[i+1]);\n       }\n\n\t   return true;\n    }\n",
    "141058": "\tpublic boolean toggleHairline() {\n\t\tshowhairline = !showhairline;\n\n\t\thairline.setShowHairline(showhairline);\n\t\taxishairline.setShowHairline(showhairline);\n\n\t\tupdateWidget();\n\n\t\treturn showhairline;\n\t}\n",
    "141081": "    private String loadPage() {\n\t\ttry {\n\t\t\tStringBuilder output = new StringBuilder(2000);\n\t\t\tBufferedReader buff = null;\n\t\t\ttry {\n\t\t\t\tURL url = new URL(getArgumentValue(Arguments.SERVER));\n\t\t\t\tbuff = new BufferedReader(new InputStreamReader(LocalUrlCacher.getInputStream(url)));\n\t\t\t\tboolean eof = false;\n\t\t\t\twhile (!eof) {\n\t\t\t\t\tString line = buff.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\teof = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput.append(line).append(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tSystem.out.println(\"Error -- \" + e.toString());\n\t\t\t} finally {\n\t\t\t\tGeneralUtils.safeClose(buff);\n\t\t\t}\n\t\t\treturn output.toString();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n    }\n",
    "141090": "\tpublic boolean toggleHairlineLabel() {\n\t\tshowhairlineLabel = !showhairlineLabel;\n\n\t\thairline.setLabeled(showhairlineLabel);\n\n\t\tupdateWidget();\n\n\t\treturn showhairlineLabel;\n\t}\n",
    "141156": "            public int getRowCount() {\n                return data.length;\n            }\n",
    "141164": "            public int getColumnCount() {\n                return col_headings.length;\n            }\n",
    "141174": "            public Object getValueAt(int rowIndex, int columnIndex) {\n                return data[rowIndex][columnIndex];\n            }\n",
    "141441": "  public void clearSACK() {\n    int headerLength = getTCPHeaderByteLength();\n    int offset = OFFSET_URG_POINTER + 2;\n\n    if(headerLength > offset) {\n      offset+=__offset;\n      headerLength+=__offset;\n\n      loop:\n      do {\n        byte kind = _data_[offset];\n\n        switch(kind) {\n          case KIND_NOP:\n            ++offset;\n            break;\n          case KIND_EOL:\n            break loop;\n          case KIND_SACK:\n            _data_[offset]     = KIND_NOP;\n            _data_[offset + 1] = KIND_NOP;\n            break loop;\n            //break;\n          default:\n            offset+=_data_[offset + 1];\n            /*\n            int length = _data_[offset + 1];\n            while(length-- > 0)\n              _data_[offset++] = KIND_NOP;\n            */\n            break;\n        }\n\n      } while(offset < headerLength);\n\n    }\n  }\n",
    "141448": "  public void addControlFlags(int mask) {\n    int flags = _data_[__offset + OFFSET_CONTROL] & 0xff;\n    flags |= mask;\n    _data_[__offset + OFFSET_CONTROL] = (byte)(flags & 0xff);\n  }\n",
    "141450": "  public void removeControlFlags(int mask) {\n    int flags = _data_[__offset + OFFSET_CONTROL] & 0xff;\n    flags |= mask;\n    flags ^= mask;\n    _data_[__offset + OFFSET_CONTROL] = (byte)(flags & 0xff);\n  }\n",
    "141452": "  public void setControlFlags(int mask) {\n    _data_[__offset + OFFSET_CONTROL] = (byte)(mask & 0xff);\n  }\n",
    "141463": "  public void setUDPPacketLength(int length) {\n    _data_[__offset + OFFSET_UDP_TOTAL_LENGTH] = (byte)((length >> 8) & 0xff);\n    _data_[__offset + OFFSET_UDP_TOTAL_LENGTH + 1] = (byte)(length & 0xff);\n  }\n",
    "141466": "  public void setData(byte[] data) {\n    _data_ = data;\n  }\n",
    "141468": "  public void getData(byte[] data) {\n    System.arraycopy(_data_, 0, data, 0, data.length);\n  }\n",
    "141469": "  public void setIPHeaderLength(int length) {\n    // Clear low order bits and then set\n    _data_[0] &= 0xf0;\n    _data_[0] |= (length & 0xf);\n  }\n",
    "141479": "  public void close() {\n    __close(__handle);\n    __handle = 0;\n  }\n",
    "141480": "  public int setMode(int mode, int range) {\n    return __setMode(__handle, mode, range);\n  }\n",
    "141481": "  public int read(NetlinkMessage message, int timeout) {\n    return __read(__handle, message, timeout);\n  }\n",
    "141486": "  protected void finalize() throws Throwable {\n    __freeBuffer();\n  }\n",
    "141530": "\tpublic int getEthHeaderProto() {\n        return (((_ethdata[OFFSET_ETH_PROTO] & 0xff) << 8) |\n                (_ethdata[OFFSET_ETH_PROTO + 1] & 0xff)); \n      }\n",
    "141587": "\tpublic void close() {\n\t\tsynchronized(dobs)\n\t\t{\n\t\t\ttimer.cancel();\n\t\t\tif (source != null && counter > 0)\n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"closing - processing oa dobs: \" + counter);\n\t\t\t\t\tsource.process(dobs);\n\t\t\t\t}\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(e.fillInStackTrace());\n\t\t\t\t}\n\t\t\t\tcounter = 0;\n\t\t\t\tdobs = new SimpleDataObject[maxcount];\n//\t\t\t\tsource.waitAsyncQueueComplete();\n\t\t\t}\n\t\t}\n\t}\n",
    "141605": "\tprotected void open() {\n\t\ttry {\n\t\t\tdbh = Class.forName(props.getProperty(PROP_OUTPUTWRITERCLASS)).newInstance();\n\t\t\tif (!(dbh instanceof isc.sensor.PacketOutputAdaptorIF))\n\t\t\t\tthrow (new Exception(\"Output writer did not implement handler interface\"));\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(e, e);\n\t\t}\n\t}\n",
    "141607": "\tprotected void close() {\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn;\n\t\t((PacketOutputAdaptorIF)dbh).close();\n\t}\n",
    "141611": "\tpublic void setFinish() {\n\t\tlog.debug(\">>setFinish()\");\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn;\n\t\ttry\n\t\t{\n\t\t    sesTimer.setFinish();\n\t\t\tsesTimer.join();\n\t\t\tfinish = true;\n\t\t\tnotifyProc();\n\t\t\tthis.join();\n\t\t}\n\t\tcatch(InterruptedException e)\n\t\t{\n\t\t\tlog.error(e, e);\n\t\t}\n\t}\n",
    "141612": "\tpublic boolean finished() {\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn true;\n\t\t\n\t\treturn finish;\n\t}\n",
    "141614": "\tpublic Vector getSessionPackets(String key) throws Exception {\n\t\tVector rsVect;\n\t\t\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn (Vector)null;\n\t\n\t\tsynchronized(packetDB) \n\t\t{\n\t\t\trsVect = (Vector)packetDB.get(key);\n\t\t}\n\t\tif (rsVect == null)\n\t\t{\n\t\t\tException error = new Exception(\"Key not found in DB\");\n\t\t\tthrow error;\n\t\t}\n\t\treturn rsVect;\n\t}\n",
    "141616": "\tpublic void updatePacketClock(long currentPacketTime) {\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn;\n\t\n\t\tthis.currentPacketTime = currentPacketTime;\n\t\tsesTimer.setPacketTime(currentPacketTime);\n\t}\n",
    "141617": "\tpublic Enumeration getActiveSessions() {\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn (Enumeration)null;\n\t\n\t\tsynchronized (sessions)\n\t\t{\n\t\t\treturn sessions.elements();\n\t\t}\n\t}\n",
    "141638": "\tprotected void flush(SessionBean udpsbean) {\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn;\n\t\ttry\n\t\t{\n\t\t\t((PacketOutputAdaptorIF)dbh).writeUDPSession(udpsbean);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlog.error(e, e);\n\t\t}\n\t}\n",
    "141640": "\tpublic void setKey(String key) {\n\t\tskey = new StringBuffer().append(key);\n\t}\n",
    "141642": "\tpublic void setPacketTime(long ptime) {\n\t\tpacketTime = ptime;\n\t}\n",
    "141644": "\tpublic long getPacketTime() {\n\t\treturn packetTime;\n\t}\n",
    "141645": "\tpublic void setFinish() {\n\t\tlog.debug(\">>setFinish()\");\n\t\tfinish = true;\n\t\tnotifyProc();\n\t\tlog.debug(\"<<setFinish()\");\n\t}\n",
    "141646": "\tpublic boolean finished() {\n\t\treturn finish;\n\t}\n",
    "141661": "\tpublic void init(int protocol) {\n\t\t\n\t\tlog.info(\">>init+\" + protocol);\n\t\thttpSession = new Hashtable();\n\t\tinit();\n\t\t\n\t\t/** register ports and events with the parserMain */\n\t\tinitEvents(port, tcpflags);\n\t}\n",
    "141665": "\tprotected void flush(SessionBean tcpsbean) {\n\t\tif (!writeSession.booleanValue())\n\t\t\treturn;\n\t\ttry\n\t\t{\n\t\t\t((PacketOutputAdaptorIF)dbh).writeTCPSession(tcpsbean);\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tlog.error(e,e);\n\t\t}\n\t}\n",
    "141668": "\tprivate boolean _finished() {\n\t\treturn finish;\n\t}\n",
    "141673": "\tpublic boolean _ready() {\n\t\tsynchronized(readyState)\n\t\t{\n\t\t\treturn readyState.booleanValue();\n\t\t}\n\t}\n",
    "141677": "\tpublic void _setFinish() {\n\t\tlog.debug(\">>_setFinish\");\n\t\tfinish = true;\n\t\t_notifyProc();\n\t\tlog.debug(\"Parser Main queue size - \" + workQueue.size());\n\t}\n",
    "141679": "\tprotected void initEvents(int[] port, short[] tcpflags) {\n\t\tlog.debug(\">>initEvents(port, tcpflags)\");\n\t\t_port = port;\n\t\t_tcpflags = tcpflags;\n\t}\n",
    "142008": "    public void update(Graphics g) {\n        // Note: Since the paint method is going to draw an\n        // image that covers the complete area of the component we\n        // do not fill the component with its background color\n        // here. This avoids flickering.\n        paint(g);\n    }\n",
    "142012": "    public void paint(Graphics g) {\n        g.drawImage(image, 0, 0, this);\n        \n        // Notify method splash that the window\n        // has been painted.\n        // Note: To improve performance we do not enter\n        // the synchronized block unless we have to.\n        if (! paintCalled) {\n            paintCalled = true;\n            synchronized (this) { notifyAll(); }\n        }\n    }\n",
    "142352": "\tprivate File fetchAnnotationDirectory (AnnotationGrouping ag, String annotationName){\n\t\tIterator it = ag.getAnnotations().iterator();\n\t\twhile (it.hasNext()){\n\t\t\tAnnotation a = (Annotation)it.next();\n\t\t\tif (a.getName().equals(annotationName)) return new File (a.getDirectory(genometry_genopub_dir));\n\t\t}\n\t\treturn null;\n\t}\n",
    "142384": "\tpublic void characters(char buf[], int offset, int len) throws SAXException {\n\t\tString s = new String(buf, offset, len);\n\n\t\tif (!s.trim().equals(\"\") && importType == \"STRANGEBREW\") {\n\t\t\t// SBWin uses gr instead of g, fix it:\n\t\t\tif (s.trim().equalsIgnoreCase(\"gr\"))\n\t\t\t\ts=\"g\";\n\t\t\tsbCharacters(s.trim());\t\n\t\t} \n\t\telse if (!s.trim().equals(\"\") && importType == \"QBREW\") {\n\t\t\t\tqbCharacters(s.trim());\t\n\t\t\t} \n\t}\n",
    "143256": "\tpublic void loadInternalLink(final String internal) {\n\t\tloadInternalLink(internal, false);\n\t}\n",
    "143261": "\tpublic void loadInternalLink(final String internal, boolean delayed) {\n\n\t\tinternalLink = null;\n\n\t\tif (!documentLoaded) {\n\t\t\tinternalLink = internal;\n\t\t\treturn;\n\t\t}\n\n\t\tif (delayed) {\n\t\t\tThread t = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tsetViewportToLinkTarget(internal);\n\t\t\t\t}\n\t\t\t};\n\t\t\tt.setPriority(Thread.NORM_PRIORITY - 1);\n\t\t\tt.start();\n\n\t\t} else\n\t\t\tsetViewportToLinkTarget(internal);\n\t}\n",
    "143279": "\tprivate void setViewportToLinkTarget(final String internal) {\n\t\tBox box = textContentPane.getSharedContext().getBoxById(internal);\n\t\tif (box == null)\n\t\t\tbox = GUIUtils.searchForName(internal, textContentPane.getRootBox());\n\n\t\tif (box != null)\n\t\t\ttextContentPane.scrollTo(new Point(box.getAbsX(), box.getAbsY()));\n\t}\n",
    "144869": "    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }\n",
    "144873": "    protected void fireStateChanged() {\n        // Guaranteed to return a non-null array\n        Object[] listeners = listenerList.getListenerList();\n        // Process the listeners last to first, notifying\n        // those that are interested in this event\n        for (int i = listeners.length-2; i>=0; i-=2) {\n            if (listeners[i]==ChangeListener.class) {\n                // Lazily create the event:\n                if (changeEvent == null)\n                    changeEvent = new ChangeEvent(this);\n                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);\n            }\n        }\n    }\n",
    "145278": "\t\tpublic void paintIcon(Component c, Graphics g, int x, int y)\n\t\t{\t\t\t\n\t\t\tif (leftIcon != null) {\n\t\t\t\tleftIcon.paintIcon(c, g, x, y + 1);\n\t\t\t\tdrawTitleAndRightIcon(c, g, x, y, leftIcon.getIconWidth() + ICON_TEXT_GAP);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdrawTitleAndRightIcon(c, g, x, y, 0);\n\t\t\t}\n\t\t}\n",
    "145361": "\t\tpublic void stateChanged(ChangeEvent e) {\n\t\t\tif (oldIndex != -1 && oldIndex < CloseableTabbedPane.this.getTabCount()) {\n\t\t\t\tCloseableTabbedPane.this.setButtonVisible(oldIndex, false);\n\t\t\t}\n\t\t\toldIndex = getSelectedIndex();\n\t\t\tif (oldIndex != -1) {\n\t\t\t\tCloseableTabbedPane.this.setButtonVisible(oldIndex, true);\n\t\t\t}\n\t\t}\n",
    "145646": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t\tresourceBundle = null;\n\t}\n",
    "145647": "\tpublic ResourceBundle getResourceBundle() {\n\t\ttry {\n\t\t\tif (resourceBundle == null)\n\t\t\t\tresourceBundle = ResourceBundle.getBundle(\"org.xnap.commons.eclipse.plugins.changelog.test.ChangeLogTestPluginResources\");\n\t\t} catch (MissingResourceException x) {\n\t\t\tresourceBundle = null;\n\t\t}\n\t\treturn resourceBundle;\n\t}\n",
    "145874": "\tpublic void actionPerformed(ActionEvent actionEvent) {\n\t\tif (actionEvent.getSource() == button1) {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "146040": "    public Color getColor() {\n        return col;\n    }\n",
    "146042": "    public void setColor( Color color ) {\n        col = color;\n    }\n",
    "146049": "    public void setLength(int len) {\n        length=len;\n    }\n",
    "146051": "    public void setVisible( boolean v) {\n        visible = v;\n    } \n",
    "146057": "    public void reverse() {\n        Node temp = to;\n        to = from;\n        from = temp;\n    }\n",
    "146119": "    public Iterator getAllNodes() {\n        return completeEltSet.getNodes();\n    }\n",
    "146127": "    public ImmutableGraphEltSet getGES() {\n        return visibleLocality;\n    }\n",
    "146135": "    public int getNodeCount() {\n        return completeEltSet.nodeCount();\n    }\n",
    "146138": "    protected Node nodeAt( int i ) {\n        if ( nodes.size() == 0 ) return null;\n        return (Node)nodes.elementAt(i);\n    }\n",
    "146140": "    public int nodeNum() {\n        return nodes.size(); \n    }\n",
    "146141": "    public int nodeNum() {\n        return visibleLocality.nodeCount();\n    }\n",
    "146142": "    public int nodeCount() {\n        return nodes.size(); \n    }\n",
    "146144": "    public int visibleNodeCount() {\n        return visibleLocality.nodeCount();\n    }\n",
    "146145": "    //protected void registerNode( String id, Node node ) {\n  // FIXME\n    //}\n",
    "146149": "    public boolean contains( Node node ) {\n        return nodes.contains(node);\n    }\n",
    "146151": "    protected Edge edgeAt( int index ) {\n        if ( edges.size() == 0 ) return null;\n        return (Edge)edges.elementAt(index);\n    }\n",
    "146152": "    public int edgeNum() {\n        return edges.size(); \n    }\n",
    "146154": "    public Node findNodeLabelContaining( String substring ) {\n        if ( substring == null ) return null; //ignore\n        return completeEltSet.findNodeLabelContaining(substring);\n    }\n",
    "146155": "    public int edgeCount() {\n        return edges.size(); \n    }\n",
    "146158": "    public void addEdge( Edge edge ) {\n        if ( edge == null ) return;\n        if(!contains(edge)) {\n            edges.addElement(edge);\n            edge.from.addEdge(edge);\n            edge.to.addEdge(edge);\n        }\n    }\n",
    "146161": "    public Edge addEdge( Node from, Node to, int tension ) {\n        Edge edge = null;\n        if ( from != null && to != null ) {\n             edge = new Edge(from,to,tension);\n             addEdge(edge);\n         }\n         return edge;\n    }\n",
    "146162": "    public boolean contains( Edge edge ) {\n        return edges.contains(edge);\n    }\n",
    "146163": "    public Node addNode( String label ) throws TGException {\n        return addNode(null,label);\n    }\n",
    "146166": "    public Node findNodeLabelContaining( String substring ) {\n         for ( int i = 0 ; i < nodeCount() ; i++) {\n            if (nodeAt(i)!=null && nodeAt(i).getLabel().toLowerCase().equals(substring.toLowerCase())) {\n                return nodeAt(i);\n            }\n        }\n               \n        for ( int i = 0 ; i < nodeCount() ; i++) {\n            if (nodeAt(i)!=null && nodeAt(i).getLabel().toLowerCase().indexOf(\n                                        substring.toLowerCase())>-1) {\n                return nodeAt(i);\n            }\n        }\n        return null;\n    }\n",
    "146167": "    public Node addNode( String id, String label ) throws TGException {\n        Node node;\n        if (label==null) \n            node = new Node(id);\n        else\n            node = new Node(id, label);\n\n        updateDrawPos(node); // The addNode() call should probably take a position, this just sets it at 0,0\n        addNode(node);\n        return node;\n    }\n",
    "146168": "    public Edge findEdge( Node from, Node to ) {\n        for ( int i = 0 ; i < from.edgeCount(); i++ ) {\n            Edge e = from.edgeAt(i);\n            if (e.to == to) return e;\n        }\n        return null;\n    }\n",
    "146169": "    public boolean deleteEdge( Edge edge ) {\n        synchronized(edges) {\n            if ( edge == null ) return false;\n            if (!edges.removeElement(edge)) return false;\n            edge.from.removeEdge(edge);\n            edge.to.removeEdge(edge);\n            return true;\n        }\n    }\n",
    "146171": "    public void deleteEdges( Vector edgesToDelete ) {\n        synchronized(edges) {\n            for (int i=0;i<edgesToDelete.size();i++) {\n                deleteEdge((Edge) edgesToDelete.elementAt(i));\n            }\n        }\n    }\n",
    "146174": "    public boolean deleteEdge( Node from, Node to ) {\n        synchronized(edges) {\n            Edge e = findEdge(from,to);\n            if (e!=null) return deleteEdge(e);\n            return false;\n        }\n    }\n",
    "146177": "    public void deleteNodes( Vector nodesToDelete ) {\n        synchronized (nodes) {\n            for (int i=0;i<nodesToDelete.size();i++) {\n                deleteNode((Node)nodesToDelete.elementAt(i));\n            }\n        }   \n    }\n",
    "146178": "    public Node getRandomNode() {\n        if ( nodes.size() == 0 ) return null;\n        int r=(int) (Math.random()*nodeCount());\n        return nodeAt(r);\n    }\n",
    "146182": "    public Node getFirstNode() {\n        if ( nodes.size() == 0 ) return null;\n        else return nodeAt(0);\n    }\n",
    "146183": "    public void clearAll() {\n        synchronized(nodes) {\n            synchronized(edges) {\n                nodes.removeAllElements();\n                edges.removeAllElements();\n                nodeIDRegistry.clear();\n            }\n        }\n    }\n",
    "146184": "    public void forAllNodes( TGForEachNode fen ) {\n        synchronized(nodes) {\n            for (int i=0;i<nodeCount();i++) {\n                Node n = nodeAt(i);\n                fen.forEachNode(n);\n            }\n        }\n    }\n",
    "146187": "    public void forAllNodePairs( TGForEachNodePair fenp ) {\n        synchronized(nodes) {\n            for (int i=0;i<nodeCount();i++) {\n                Node n1=nodeAt(i);\n                fenp.beforeInnerLoop(n1);            \n                for (int j=i+1;j<nodeCount();j++)\n                    fenp.forEachNodePair(n1, nodeAt(j));            \n                fenp.afterInnerLoop(n1);\n            }\n        }\n    }\n",
    "146188": "    public void forAllEdges( TGForEachEdge fee ) {\n        synchronized(edges) {\n            for (int i=0;i<edgeCount();i++) {\n                Edge e = edgeAt(i);\n                fee.forEachEdge(e);\n            }\n        }\n    }\n",
    "146202": "    public Iterator getAllEdges() {\n        return completeEltSet.getEdges();\n    }\n",
    "146223": "    public int getEdgeCount() {\n        return completeEltSet.edgeCount();\n    }\n",
    "146228": "    public int edgeNum() {\n        return visibleLocality.edgeCount();\n    }\n",
    "146232": "    public int visibleEdgeCount() {\n        return visibleLocality.edgeCount();\n    }\n",
    "146360": "    public void startDamper() {\n        if (tgLayout!=null) tgLayout.startDamper();\n    }\n",
    "146367": "    public void resetDamper() {\n        if (tgLayout!=null) tgLayout.resetDamper();\n    }\n",
    "146371": "    public void stopMotion() {\n        if (tgLayout!=null) tgLayout.stopMotion();\n    }\n",
    "146462": "    public void initialize() {\n        buildPanel();\n        buildLens();\n        tgPanel.setLensSet(tgLensSet);\n        addUIs();\n      //tgPanel.addNode();  //Add a starting node.\n        try {\n            randomGraph();\n        } catch ( TGException tge ) {\n            System.err.println(tge.getMessage());\n            tge.printStackTrace(System.err);\n        }\n        tgPanel.setSelect(tgPanel.getGES().getFirstNode()); //Select first node, so hiding works\n        setVisible(true);\n    }\n",
    "146465": "    public TGPanel getTGPanel() {\n        return tgPanel;\n    }\n",
    "146474": "    public void setOffset( Point p ) {\n        hvScroll.setOffset(p);\n    };\n",
    "146477": "    public Point getOffset() {\n        return hvScroll.getOffset();\n    };\n",
    "146484": "     public void setRotationAngle( int angle ) {\n        rotateScroll.setRotationAngle(angle);\n    }\n",
    "146486": "    public int getRotationAngle() {\n        return rotateScroll.getRotationAngle();\n    }\n",
    "146494": "    public void setLocalityRadius( int radius ) {\n        localityScroll.setLocalityRadius(radius);\n    }\n",
    "146497": "    public int getLocalityRadius() {\n        return localityScroll.getLocalityRadius();\n    }\n",
    "146504": "    public void setZoomValue( int zoomValue ) {\n        zoomScroll.setZoomValue(zoomValue);\n    }\n",
    "146508": "    public int getZoomValue() {\n        return zoomScroll.getZoomValue();\n    }\n",
    "146519": "    public TGPoint2D convRealToDraw( TGPoint2D p ) {\n        TGPoint2D newp = new TGPoint2D(p);\n        applyLens(newp);\n        return newp;\n    }\n",
    "146520": "    public TGPoint2D convRealToDraw( double x, double y ) {\n        TGPoint2D newp = new TGPoint2D(x,y);\n        applyLens(newp);\n        return newp;\n    }\n",
    "146522": "    public TGPoint2D convDrawToReal( TGPoint2D p ) {\n        TGPoint2D newp = new TGPoint2D(p);\n        undoLens(newp);\n        return newp;\n    }\n",
    "146523": "    public TGPoint2D convDrawToReal(double x, double y) {\n        TGPoint2D newp = new TGPoint2D(x, y);\n        undoLens(newp);\n        return newp;\n    }\n",
    "146545": "    public void setLocation( Point p ) {\n        this.x = p.x;\n        this.y = p.y;\n    }\n",
    "146547": "    public Point getLocation() {\n        return new Point((int)x,(int)y);\n    }\n",
    "146564": "    public int getType() {\n        return typ;\n    }\n",
    "146567": "    public void setSerialParameters(int baudrate, int dataBits, int stopBits, int parity) throws Exception {\n        serialCom.setParams(baudrate, dataBits, stopBits, parity);\n    }\n",
    "146571": "    public void open(String comport) throws Exception {\n        serialCom.open(comport);\n        serialCom.addEventListener(this);\n        inputStream = serialCom.getInputStream();        \n    }\n",
    "146573": "    public Color getBackColor() {\n        return backColor;\n    }\n",
    "146575": "    public void close() throws Exception {\n        serialCom.close();\n        inputStream = null;\n    }\n",
    "146577": "    public Color getTextColor() {\n        return textColor;\n    }\n",
    "146580": "    public GPSPoint getLatLong() {\n        return latlong;\n    }\n",
    "146581": "    public void setLabel( String label ) {\n        lbl = label;\n        \n        if(lbl.length() > max_display_length+3)\n        {\n          display_lbl = lbl.substring(0,max_display_length)+\"...\";\n        }\n    }\n",
    "146583": "    public void setParams(int baudrate, int dataBits, int stopBits, int parity) throws Exception {\n        this.baudrate = new Integer(baudrate);\n        this.databits = new Integer(dataBits);\n        this.stopbits = new Integer(stopBits);\n        this.parity   = new Integer(parity);\n\n        if (sPort != null) {\n            try {\n                sPort.setSerialPortParams(baudrate, dataBits, stopBits, parity);\n            } catch (Exception e) {\n                throw new Exception(\"Could not set data to serial port.\", e);\n            }\n        }\n    }\n",
    "146585": "    public String getLabel() {\n        return lbl;\n    }\n",
    "146586": "    public Float getSpeed() {\n        return speed;\n    }\n",
    "146587": "    public void close() throws Exception {\n        sPort.close();\n    }\n",
    "146588": "    public InputStream getInputStream() throws Exception {\n        InputStream inputStream = null;\n        try {\n            inputStream = sPort.getInputStream();\n        } catch (IOException e) {\n            sPort.close();\n            throw new Exception(\"Error opening i/o streams.\", e);\n        }\n        return inputStream;\n    }\n",
    "146589": "    public void setFixed( boolean fixed ) {\n        this.fixed = fixed;\n    }\n",
    "146590": "    public OutputStream getOutputStream() throws Exception {\n        OutputStream outputStream = null;\n        try {\n            outputStream = sPort.getOutputStream();\n        } catch (IOException e) {\n            sPort.close();\n            throw new Exception(\"Error opening i/o streams\", e);\n        }\n        return outputStream;\n    }\n",
    "146592": "    public void addEventListener(SerialPortEventListener listener) throws TooManyListenersException {\n        sPort.addEventListener(listener);\n    }\n",
    "146593": "    public boolean getFixed() {\n        return fixed;\n    }\n",
    "146594": "    public Float getAltitude() {\n        return altitude;\n    }\n",
    "146595": "    public void removeEventListener() {\n        sPort.removeEventListener();\n    }\n",
    "146596": "    public String getPRN() {\n        return this.PRN;\n    }\n",
    "146597": "    public Integer getElevation() {\n        return this.elevation;\n    }\n",
    "146599": "    public Integer getAzimuth() {\n        return this.azimuth;\n    }\n",
    "146600": "    public Integer getSNR() {\n        return this.SNR;\n    }\n",
    "146601": "    public void setPRN(String PRN) {\n        this.PRN = PRN;\n    }\n",
    "146602": "    public void setElevation(Integer elevation) {\n        this.elevation = elevation;\n    }\n",
    "146603": "    public Integer getQuality() {\n        return quality;\n    }\n",
    "146605": "    public void setAzimuth(Integer azimuth) {\n        this.azimuth = azimuth;\n    }\n",
    "146606": "    public void setSNR(Integer SNR) {\n        this.SNR = SNR;\n    }\n",
    "146608": "    public void setUseStatus(int PRN, boolean status) {\n        GPSSatellite sat = (GPSSatellite) get(PRN);\n        sat.used = status;\n        add(PRN, sat);\n    }\n",
    "146609": "    public void setUseStatusAll(boolean status) {\n        for (int i = 1; i <= MAX_NO_OF_SATELLITES; i++) {\n            GPSSatellite sat = (GPSSatellite) get(i);\n            sat.used = status;\n            add(i, sat);\n        }\n    }\n",
    "146610": "    public int visibleEdgeCount() {\n        return visibleEdgeCnt;\n    }\n",
    "146611": "    public void setAvailableStatus(int PRN, boolean status) {\n        GPSSatellite sat = (GPSSatellite) get(PRN);\n        sat.available = status;\n        add(PRN, sat);\n    }\n",
    "146612": "    public void setAvailabeStatusAll(boolean status) {\n        for (int i = 1; i <= MAX_NO_OF_SATELLITES; i++) {\n            GPSSatellite sat = (GPSSatellite) get(i);\n            sat.available = status;\n            add(i, sat);\n        }\n    }\n",
    "146613": "    public void add(int index, GPSSatellite element) {\n        satellites[index-1] = element;\n    }\n",
    "146614": "    public GPSSatellite get(int index) {\n        return satellites[index-1];\n    }\n",
    "146616": "    public Float getHorizontalDilution() {\n        return horizontalDilution;\n    }\n",
    "146617": "    public Edge edgeAt( int index ) {\n        return (Edge)edges.elementAt(index);\n    }\n",
    "146621": "    public Float getLatitude() {\n        return this.latitude;\n    }\n",
    "146622": "    public void addEdge( Edge edge ) {\n        if ( edge == null ) return;\n        edges.addElement(edge);\n    }\n",
    "146624": "    public Integer getLatitudeDeg() {\n        return new Integer(this.latitude.intValue());\n    }\n",
    "146625": "    public Integer getNumOfUsedSatellites() {\n        return numOfTrackSatellites;\n    }\n",
    "146626": "    public Integer getLatitudeMin() {\n        int degrees = getLatitudeDeg().intValue();\n        int minutes = (int) ((this.latitude.floatValue() - degrees) * 60);\n        return new Integer(minutes);\n    }\n",
    "146627": "    public Float getLatitudeSec() {\n        BigDecimal latitude = new BigDecimal(this.latitude.toString());\n        int degrees        = getLatitudeDeg().intValue();\n        BigDecimal minutes = latitude.subtract(new BigDecimal(degrees)).multiply(new BigDecimal(60));\n        BigDecimal seconds = minutes.subtract(new BigDecimal(getLatitudeMin().intValue())).multiply(new BigDecimal(60));\n        return new Float(seconds.floatValue());\n    }\n",
    "146628": "    public void removeEdge( Edge edge ) {\n        edges.removeElement(edge);\n    }\n",
    "146629": "    public Float getLongitude() {\n        return this.longitude;\n    }\n",
    "146631": "    public Integer getLongitudeDeg() {\n        return new Integer(this.longitude.intValue());\n    }\n",
    "146632": "    public Integer getLongitudeMin() {\n        int degrees = getLongitudeDeg().intValue();\n        int minutes = (int) ((this.longitude.floatValue() - degrees) * 60);\n        return new Integer(minutes);\n    }\n",
    "146633": "    public int getWidth() {\n        String display;\n        if(\"\".equals(display_lbl))\n        {\n            display = lbl;\n        }\n        else\n        {\n          display = display_lbl;\n        }\n\n        if ( fontMetrics != null && display != null ) {\n            return fontMetrics.stringWidth(display) + 12;\n        } else {\n            return 10;\n        }\n    }\n",
    "146634": "    public Integer getNumOfAvailableSatellites() {\n        return numOfViewSatellites;\n    }\n",
    "146635": "    public Float getLongitudeSec() {\n        BigDecimal longitude = new BigDecimal(this.longitude.toString());\n        int degrees        = getLongitudeDeg().intValue();\n        BigDecimal minutes = longitude.subtract(new BigDecimal(degrees)).multiply(new BigDecimal(60));\n        BigDecimal seconds = minutes.subtract(new BigDecimal(getLongitudeMin().intValue())).multiply(new BigDecimal(60));\n        return new Float(seconds.floatValue());\n    }\n",
    "146638": "    public int getHeight() {\n        if ( fontMetrics != null ) {\n            return fontMetrics.getHeight() + 6;\n        } else {\n            return 6;\n        }\n    }\n",
    "146639": "    public void setChangedMask(int mask) {\n        this.changedMask = mask;\n    }\n",
    "146640": "    public int getChangedMask() {\n        return this.changedMask;\n    }\n",
    "146642": "    public boolean intersects( Dimension d ) {\n        return ( drawx > 0 && drawx < d.width && drawy>0 && drawy < d.height );\n    }\n",
    "146645": "    public GPSSatelliteArray getSatellites() {\n        return satellites;\n    }\n",
    "146648": "    public boolean containsPoint( double px, double py ) {\n        return (( px > drawx-getWidth()/2) && ( px < drawx+getWidth()/2)\n                && ( py > drawy-getHeight()/2) && ( py < drawy+getHeight()/2));\n    }\n",
    "146652": "    public boolean containsPoint( Point p ) {\n        return (( p.x > drawx-getWidth()/2) && ( p.x < drawx+getWidth()/2) \n                && ( p.y > drawy-getHeight()/2) && ( p.y < drawy+getHeight()/2));\n    }\n",
    "146654": "    public void addGPSListener(GPSListener listener) {\n        GPSListeners.add(GPSListener.class, listener);\n    }\n",
    "146658": "    public void removeGPSListener(GPSListener listener) {\n        GPSListeners.remove(GPSListener.class, listener);\n    }\n",
    "146676": "    public void setFix(GPS_FixType fix) {\n        this.fix = fix;\n    }\n",
    "146677": "    public void testDecode(StringBuffer inputBuffer) {\n        decodeData(inputBuffer);\n    }\n",
    "146678": "    public GPS_FixType getFix() {\n        return fix;\n    }\n",
    "146681": "    public GPS_Point getPosition() {\n        return position;\n    }\n",
    "146682": "    public void setAltitude(BigDecimal altitude) {\n        this.altitude = altitude;\n    }\n",
    "146683": "    public BigDecimal getAltitude() {\n        return altitude;\n    }\n",
    "146685": "    public void setVelocity(BigDecimal velocity) {\n        this.velocity = velocity;\n    }\n",
    "146687": "    public BigDecimal getVelocity() {\n        return velocity;\n    }\n",
    "146688": "    public void setQuality(GPS_FixQualityType quality) {\n        this.quality = quality;\n    }\n",
    "146689": "    public GPS_FixQualityType getQuality() {\n        return quality;\n    }\n",
    "146691": "    public void setHorizontalDilution(BigDecimal horizontalDilution) {\n        this.horizontalDilution = horizontalDilution;\n    }\n",
    "146695": "    public void setPRN(int PRN) {\n        this.PRN = PRN;\n    }\n",
    "146696": "    public int getPRN() {\n        return PRN;\n    }\n",
    "146698": "    public void setElevation(int elevation) {\n        this.elevation = elevation;\n    }\n",
    "146700": "    public int getElevation() {\n        return elevation;\n    }\n",
    "146702": "    public void setAzimuth(int azimuth) {\n        this.azimuth = azimuth;\n    }\n",
    "146703": "    public int getAzimuth() {\n        return azimuth;\n    }\n",
    "146704": "    public void setSNR(int SNR) {\n        this.SNR = SNR;\n    }\n",
    "146705": "    public int getSNR() {\n        return SNR;\n    }\n",
    "146707": "    public void setAvailable(boolean available) {\n        this.available = available;\n    }\n",
    "146709": "    public boolean isAvailable() {\n        return available;\n    }\n",
    "146710": "    public void setInUse(boolean inUse) {\n        this.inUse = inUse;\n    }\n",
    "146711": "    public boolean isInUse() {\n        return inUse;\n    }\n",
    "146712": "    public void add(int PRN, GPS_SatelliteData satellite) {\n        satellites[PRN - 1] = satellite;\n    }\n",
    "146714": "    public GPS_SatelliteData get(int PRN) {\n        return satellites[PRN - 1];\n    }\n",
    "146717": "    public void add(NMEA_ProviderConfigParameter newParameter) throws Exception {\n        \n        for (Enumeration e = parameters.elements(); e.hasMoreElements();) {\n            NMEA_ProviderConfigParameter parameter = (NMEA_ProviderConfigParameter) e.nextElement();\n            if (!parameter.getName().equals(newParameter.getName()) &&\n                parameter.getSortOrder() == newParameter.getSortOrder()) {\n                throw new Exception (\"A configuration parameter with sort order \" + newParameter.getSortOrder() + \" already exists.\");\n            }\n        }\n        parameters.put(newParameter.getName(), newParameter);\n    }\n",
    "146718": "    public NMEA_ProviderConfigParameter get(String name) {\n        return parameters.get(name);\n    }\n",
    "146719": "    public boolean hasNext() {\n        for (Enumeration e = parameters.elements(); e.hasMoreElements();) {\n            NMEA_ProviderConfigParameter parameter = (NMEA_ProviderConfigParameter) e.nextElement();\n            if (parameter.getSortOrder() > iterator) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "146721": "    public NMEA_ProviderConfigParameter next() {\n        int lowestFound = -1;\n        String lowestFoundKey = null;\n        boolean firstLoop = true;\n        for (Enumeration e = parameters.elements(); e.hasMoreElements();) {\n            NMEA_ProviderConfigParameter parameter = (NMEA_ProviderConfigParameter) e.nextElement();\n            if (parameter.getSortOrder() > iterator) {\n                if (firstLoop) {\n                    lowestFound = parameter.getSortOrder();\n                    lowestFoundKey = parameter.getName();\n                } else {\n                    if (parameter.getSortOrder() < lowestFound) {\n                        \n                        lowestFound = parameter.getSortOrder();\n                        lowestFoundKey = parameter.getName();\n                    }                    \n                }\n                firstLoop = false;\n            }\n        }\n        \n        if (lowestFoundKey != null) {\n            iterator = lowestFound;\n            return parameters.get(lowestFoundKey);\n        }\n        return null;\n    }\n",
    "146723": "    public void resetIterator() {\n        iterator = -1;\n    }\n",
    "146724": "    public void clear() {\n        parameters.clear();\n        iterator = -1;\n    }\n",
    "146729": "    public void setType(NMEA_ProviderConfigParameterType type) throws ParseException {\n        this.type = type;\n        \n        if (this.type == NMEA_ProviderConfigParameterType.TEXT ||\n            this.type == NMEA_ProviderConfigParameterType.NUMBER) {\n        \n            if (!this.format.trim().matches(\"[0-9]+\")) {\n                throw new ParseException(\"When configuration type is TEXT or NUMBER, the format parameter can only contain numbers\", 0);\n            }\n        }\n    }\n",
    "146732": "    public NMEA_ProviderConfigParameterType getType() {\n        return type;\n    }\n",
    "146734": "    public void setFormat(String format) throws ParseException {\n        this.format = format;\n        \n        if (this.type == NMEA_ProviderConfigParameterType.TEXT ||\n            this.type == NMEA_ProviderConfigParameterType.NUMBER) {\n        \n            if (!this.format.trim().matches(\"[0-9]+\")) {\n                throw new ParseException(\"When configuration type is TEXT or NUMBER, the format parameter can only contain numbers\", 0);\n            }\n        }\n    }\n",
    "146736": "    public String getFormat() {\n        return format;\n    }\n",
    "146738": "    public void setLabel(String label) {\n        this.label = label;\n    }\n",
    "146745": "    public void setSortOrder(int sortOrder) {\n        this.sortOrder = Math.abs(sortOrder);\n    }\n",
    "146746": "    public int getSortOrder() {\n        return sortOrder;\n    }\n",
    "146753": "    public BigDecimal getLongitude() {\n        return this.longitude;\n    }\n",
    "146757": "    public void add_GPS_DataListener(GPS_DataListener listener) {\n        listenerList.add(GPS_DataListener.class, listener);   \n    }\n",
    "146758": "    public void add_GPS_DataListener(GPS_DataListener listener) {\n        gpsData.add_GPS_DataListener(listener);\n    }\n",
    "146760": "    public void remove_GPS_DataListener(GPS_DataListener listener) {\n        listenerList.remove(GPS_DataListener.class, listener);\n    }\n",
    "146761": "    public void remove_GPS_DataListener(GPS_DataListener listener) {\n        gpsData.remove_GPS_DataListener(listener);\n    }\n",
    "146763": "    public boolean validate() {\n        \n        boolean valid = false;\n        if (type == NMEA_ProviderConfigParameterType.TEXT) {\n            if (value.trim().length() > 0 &&\n                value.trim().length() <= new Integer(format).intValue()) {\n                valid = true;\n            }\n            \n        } else if (type == NMEA_ProviderConfigParameterType.NUMBER) {\n            if ((value.trim().length() > 0) && \n                value.trim().length() <= new Integer(format).intValue() &&\n                value.trim().matches(\"[0-9]+\")) {\n                valid = true;\n            }\n        \n        } else if (type == NMEA_ProviderConfigParameterType.ENUM) {\n            String[] formatSplit = format.split(\";\");\n            for(String split : formatSplit) {\n                if (split.trim().equals(value.trim())) {\n                    valid = true;\n                    break;\n                }\n            }\n        }\n        \n        return valid;\n    }\n",
    "146764": "    public boolean open(NMEA_Provider provider) {\n        provider.add_NMEA_Listener(this);\n        try {\n            return provider.open();\n        } catch (Exception e) {\n            return false;\n        }\n    }\n",
    "146767": "    public boolean close(NMEA_Provider provider) {\n        provider.remove_NMEA_Listener(this);\n        try {\n            return provider.close();\n        } catch (Exception e) {\n            return false;\n        }\n    }\n",
    "146768": "    public void decode_NMEA(String NMEA) {\n        if (NMEA != null && NMEA.length() > 5) {\n            String messageType = NMEA.substring(2,5);\n            String[] data = NMEA.toString().split(\",\", -20);\n            if (messageType.equals(\"RMC\")) {\n                decode_RMC(data);\n            } else if (messageType.equals(\"GGA\")) {\n                decode_GGA(data);\n            } else if (messageType.equals(\"GSA\")) {\n                decode_GSA(data);\n            } else if (messageType.equals(\"GSV\")) {\n                decode_GSV(data);\n            } else if (messageType.equals(\"GLL\")) {\n                decode_GLL(data);\n            }\n        }\n    }\n",
    "146769": "    public String getName() {\n        return \"Serial port (RS-232)\";\n    }\n",
    "146777": "    public String getDescription() {\n        return \"Talk to a GPS receiver using a serial port on your computer\";\n    }\n",
    "146787": "    public void setConfiguration(NMEA_ProviderConfigParameterArray parameters) throws Exception {\n        \n        parameters.resetIterator();\n        while (parameters.hasNext()) {\n            NMEA_ProviderConfigParameter param = parameters.next();\n            if (!(param.getValue() != null && param.getValue().trim().length() > 0)) {\n                throw new Exception(\"Not all configuration parameters have been set.\");\n            }\n        }\n        \n        configParameters = parameters;\n        configParametersSet = true;\n    }\n",
    "146798": "    public NMEA_ProviderConfigParameterArray getConfiguration() {\n        return configParameters;\n    }\n",
    "146827": "    public boolean close() {\n        try {\n            sPort.removeEventListener();\n            sPort.close();\n            inputStream = null;\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n",
    "146834": "    private BigDecimal string2LatLong(String latlong, GPS_Direction direction) {\n        BigDecimal result;\n        \n        BigDecimal templatlong = new BigDecimal(latlong);\n        \n        int degrees = templatlong.divide(new BigDecimal(100)).intValue();\n        BigDecimal minutes = templatlong.subtract(new BigDecimal(degrees * 100));\n        \n        result = new BigDecimal(degrees).add(minutes.divide(new BigDecimal(60), BigDecimal.ROUND_HALF_EVEN));\n        \n        if (direction == GPS_Direction.WEST || direction == GPS_Direction.SOUTH) {\n            result = result.multiply(new BigDecimal(-1));\n        }\n\n        return result;\n    }\n",
    "146843": "    private Date string2Date(String time) {\n        int hour   = 0;\n        int minute = 0;\n        int second = 0;\n        \n        // Fetch values from input string.\n        hour   = new Integer(time.substring(0,2)).intValue();\n        minute = new Integer(time.substring(2,4)).intValue();\n        second = new Integer(time.substring(4,6)).intValue();\n        \n        // Get the current date and time of client computer.\n        GregorianCalendar calendar = new GregorianCalendar();\n        calendar.setTimeInMillis(System.currentTimeMillis());\n\n        // Set new values.   \n        calendar.set(GregorianCalendar.HOUR_OF_DAY, hour);\n        calendar.set(GregorianCalendar.MINUTE, minute);\n        calendar.set(GregorianCalendar.SECOND, second);\n        \n        return calendar.getTime();\n    }\n",
    "146861": "    public void add_NMEA_Listener(NMEA_Listener listener) {\n        NMEA_Listeners.add(NMEA_Listener.class, listener);\n    }\n",
    "146869": "    public void remove_NMEA_Listener(NMEA_Listener listener) {\n        NMEA_Listeners.remove(NMEA_Listener.class, listener);\n    }\n",
    "146870": "    static public String lineAndFile() {\n        return lineAndFile(2);\n    }\n",
    "146872": "    static public String lineAndFile(int stackDepth) {\n        try { throw new Exception();} catch (Exception e) {\n            String trace = DGUtils.stackTraceToString(e);\n            String find = \"\\tat \";\n            int len = find.length();\n\n            int start = nthIndexOf(trace, find, stackDepth, 0);\n            int end = nthIndexOf(trace, find, 0, start+len);\n            if (end == -1) end = trace.length();\n            return trace.substring(start+len, end-1);\n        }\n    }\n",
    "146957": "    public BaseCmdLine (String[] argv, String[] names, int[] lengths) {\n        this (argv, false, names, lengths);\n    }\n",
    "146961": "    public BaseCmdLine (String[] argv, boolean ignoreCase) {\n        this (argv);\n        this.ignoreCase = ignoreCase;\n    }\n",
    "146964": "    public BaseCmdLine (String[] argv, boolean ignoreCase, String[] names, int[] lengths) {\n        this (argv, ignoreCase);\n        for (int i = 0; i < Math.min (names.length, lengths.length); i++)\n            getParam (names[i], lengths[i]);\n    }\n",
    "146968": "    public boolean hasParam (String name) {\n        if (ignoreCase)\n            name = name.toUpperCase();\n    \n\t// we may know already this argument\n        if (knownParams.containsKey (name))\n            return true;\n\n\t// or we have to find it on the command-line\n        synchronized (params) {\n            for (int i = 0; i <params.length; i++)\n                if (ignoreCase && params[i].equalsIgnoreCase (name) ||\n                    params[i].equals (name))\n                    return true;\n\t}\n\n\t// not found\n        return false;\n    }\n",
    "146972": "    public boolean hasOption (String name) {\n        getParam (name, 0);      // this removes 'name' from the argument list\n        return hasParam (name);  // and this checks if 'name' really exists\n    }\n",
    "146975": "    public String getParam (String name) {\n        return (getParam (name, 1))[0];\n    }\n",
    "147557": "\tpublic JMenuItem createMenu(ActionListener parent, String title, String action) {\n\t\tJMenuItem result = new JMenuItem(title);\n\t\t\n\t\tresult.setActionCommand(action);\n\t\tresult.addActionListener(parent);\n\t\t\n\t\treturn result;\n\t}\n",
    "147561": "\tprotected JButton getButton(String imageName, String actionCommand, String toolTipText, String altText) {\n\t\tJButton button = new JButton();\n\t\t\n\t\t// Create and initialize the button\n\t\tbutton.setActionCommand(actionCommand);\n\t\tbutton.setToolTipText(toolTipText);\n\t\tbutton.addActionListener(getParentObject());\n\t\t\n\t\tbutton.setIcon(sys.getIcon(imageName));\n\t\t\n\t\treturn button;\n\t}\n",
    "147564": "\tpublic ActionListener getParentObject() {\n\t\treturn parent;\n\t}\n",
    "147569": "\tprotected void addTable() {\n\t\tthis.add(new JScrollPane(getTable()));\n\t}\n",
    "147582": "\tprivate JMenuItem createMenu(String label, int mnemonic, KeyStroke keyStroke, String command, ActionListener al) {\n\t\tlogger.debug(\"Creating JMenuItem \\\"\" + label + \"\\\"\");\n\t\tJMenuItem result = new JMenuItem(label);\n\t\t\n\t\tresult.setMnemonic(mnemonic);\n\t\tresult.setAccelerator(keyStroke);\n\t\tresult.setActionCommand(command);\n\t\tresult.addActionListener(al);\n\t\t\n\t\treturn result;\n\t}\n",
    "147588": "\tprivate void reportError(String title, Exception e) {\n\t\tlogger.fatal(title + \": \" + e.getMessage());\n\t\tJOptionPane.showInternalMessageDialog(this, e.getMessage(), title, JOptionPane.ERROR_MESSAGE);\n\t}\n",
    "147596": "\tprotected void saveDocument(File file) throws IOException, MappingException, MarshalException, ValidationException {\n\t\t// Marshalling\n\t\tlogger.debug(\"Starting marshalling to \\\"\" + file + \"\\\"\");\n\t\tlogger.debug(\"Creating FileWriter\");\n\t\tFileWriter marshalFile = new FileWriter(file.toString());\n\n\t\tlogger.debug(\"Loading mapping file\");\n\t\tMapping mapping = new Mapping(getClass().getClassLoader()); \n\t\tmapping.loadMapping(getClass().getResource(\"mapping.xml\"));\n\n\t\tlogger.debug(\"Constructing Marshaller\");\n\t\tMarshaller m = new Marshaller(marshalFile);\n\t\tm.setMapping(mapping);\n\n\t\tlogger.debug(\"Marshalling data\");\n\t\tm.marshal(firewall);\n\t\t\n\t\tlogger.debug(\"Closing \\\"\" + file + \"\\\"\");\n\t\tmarshalFile.close();\n\n\t}\n",
    "147603": "\tpublic void remove(int row) {\n\t\tgetFirewall().removeScrub(row);\n\t\t\n\t\tlogger.info(\"Removed SCRUB #\" + (row + 1));\n\t\t\n\t\tfireTableRowsDeleted(row, row);\n\t}\n",
    "147607": "\tpublic void setFile(File file) {\n\t\tthis.file = file;\n\t\t\n\t\tlogger.debug(\"Checking for File -> Save menu\");\n\t\tif(mnuFileSave != null) {\n\t\t\tlogger.debug(\"Enabling File -> Save\");\n\t\t\tmnuFileSave.setEnabled(true);\n\t\t}\n\t}\n",
    "147613": "\tprotected String getStringValue(Object obj) {\n\t\tString result = null;\n\t\tString str = (String)obj;\n\n\t\tif(!str.equals(\"\")){\n\t\t\tresult = str; \n\t\t}\n\n\t\treturn result;\n\t}\n",
    "147614": "\tprivate To generateTo(Vector vector, int rowIndex) {\n\t\tTo result = new To();\n\t\t\n\t\tfor(int i = 0; i < vector.size(); i++) {\n\t\t\tObject value = vector.get(i);\n\t\t\t\n\t\t\tif(value instanceof Network) {\n\t\t\t\tresult.addNetwork(value);\n\t\t\t} else if(value instanceof Interface) {\n\t\t\t\tresult.addInterface(value);\n\t\t\t} else if(value instanceof Host) {\n\t\t\t\tresult.addHost(value);\n\t\t\t}\n\t\t}\n\t\t\n\t\tVector ports = (Vector)getValueAt(9, rowIndex);\n\t\t\n\t\tfor(int i = 0; i < ports.size(); i++) {\n\t\t\tresult.addService(ports.get(i));\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n",
    "147615": "\tprivate String getColName(int columnIndex) {\n\t\treturn COL_NAMES[columnIndex].toLowerCase();\n\t}\n",
    "147616": "\tprotected int getIntValue(Object obj) {\n\t\treturn (Integer.valueOf(String.valueOf(obj))).intValue();\n\t}\n",
    "147618": "\tprotected Vector getVectorValue(Enumeration enumeration) {\n\t\tVector result = new Vector();\n\t\t\n\t\twhile(enumeration.hasMoreElements()) {\n\t\t\tresult.add(enumeration.nextElement());\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n",
    "147624": "\tprotected Vector concatVector(Vector vector, Enumeration enumeration) {\n\t\tVector result = vector;\n\t\t\n\t\twhile(enumeration.hasMoreElements()) {\n\t\t\tresult.add(enumeration.nextElement());\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n",
    "147627": "\tpublic void add() {\n\t\tRedirect rdr = new Redirect();\n\t\tgetFirewall().addRedirect(rdr);\n\t\t\n\t\tlogger.info(\"Added REDIRECT #\" + getRowCount());\n\t\t\n\t\tfireTableRowsInserted(getRowCount(), getRowCount());\n\t}\n",
    "147630": "\tpublic void remove(int row) {\n\t\tgetFirewall().removeRedirect(row);\n\t\t\n\t\tlogger.info(\"Removed REDIRECT #\" + (row + 1));\n\t\t\n\t\tfireTableRowsDeleted(row, row);\n\t}\n",
    "147641": "\tpublic Pfpro getFirewall() {\n\t\treturn firewall;\n\t}\n",
    "147643": "\tpublic void add() {\n\t\taddBottom();\n\t}\n",
    "147649": "\tprivate void add(int num) {\n\t\tRule rule = new Rule();\n\t\trule.setNum(num);\n\t\tgetFirewall().addRule(rule);\n\t\t\n\t\tlogger.info(\"Added RULE #\" + getRowCount());\n\t\t\n\t\tfireTableRowsInserted(getRowCount(), getRowCount());\n\t}\n",
    "147651": "\tpublic void add() {\n\t\tNat nat = new Nat();\n\t\tgetFirewall().addNat(nat);\n\t\t\n\t\tlogger.info(\"Added NAT #\" + getRowCount());\n\t\t\n\t\tfireTableRowsInserted(getRowCount(), getRowCount());\n\t}\n",
    "147654": "\tpublic void remove(int row) {\n\t\tgetFirewall().removeNat(row);\n\t\t\n\t\tlogger.info(\"Removed NAT #\" + (row + 1));\n\t\t\n\t\tfireTableRowsDeleted(row, row);\n\t}\n",
    "147655": "\tpublic void addBottom() {\n\t\tadd(getFirewall().getRuleCount() + 1);\n\t}\n",
    "147662": "\tpublic void addTop() {\n\t\t// TODO PLACE RULE PROPERLY\n\t\tadd();\n\t}\n",
    "147666": "\tpublic String getClassName(Object obj) {\n\t\tString result[] = obj.getClass().getName().split(\"\\\\.\");\n\t\t\t\n\t\treturn result[result.length - 1];\n\t}\n",
    "147670": "\tpublic void addBelow(int rowIndex) {\n\t\t// TODO PLACE RULE PROPERLY\n\t\tadd();\n\t}\n",
    "147671": "\tpublic String getName(Object obj) {\n\t\tString result = obj.toString();\n\t\t\n\t\tif(obj instanceof Firewall) {\n\t\t\tresult = ((Firewall)obj).getName();\n\t\t} else if(obj instanceof Interface) {\n\t\t\tresult = ((Interface)obj).getName();\n\t\t} else if(obj instanceof Network) {\n\t\t\tresult = ((Network)obj).getName();\n\t\t} else if(obj instanceof Host) {\n\t\t\tresult = ((Host)obj).getName();\n\t\t} else if(obj instanceof Service) {\n\t\t\tresult = ((Service)obj).getName();\n\t\t} else if(obj instanceof User) {\n\t\t\tresult = ((User)obj).getName();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n",
    "147682": "\tpublic void addAbove(int rowIndex) {\n\t\t// TODO PLACE RULE PROPERLY\n\t\tadd();\n\t}\n",
    "147701": "\tpublic void remove(int row) {\n\t\tgetFirewall().removeRule(row);\n\t\t\n\t\tlogger.info(\"Removed RULE #\" + (row + 1));\n\t\t\n\t\tfireTableRowsDeleted(row, row);\n\t}\n",
    "147702": "\tprivate void exitApp() {\n\t\tlogger.info(\"Exiting on user request\");\n\t\t\n\t\tlogger.debug(\"Saving preferences...\");\n\t\tprefs.putInt(WINDOW_X, getX());\n\t\tprefs.putInt(WINDOW_Y, getY());\n\t\tprefs.putInt(WINDOW_HEIGHT, getHeight());\n\t\tprefs.putInt(WINDOW_WIDTH, getWidth());\n\t\t\n\t\tSystem.exit(0);\n\t}\n",
    "149712": "\tpublic IHeaderResponse getHeaderResponse() {\n\t\tif (this.headerResponse == null)\n\t\t{\n\t\t\theaderResponse = new HeaderResponse(getResponse());\n\t\t}\n\t\treturn headerResponse;\n\t}\n",
    "151410": "\tpublic Contact get(long id) {\n\t\tContact c = (Contact) map.get(new Long(id));\n\t\tif (c == null)\n\t\t\tthrow new RuntimeException(\"contact with id [\" + id\n\t\t\t\t\t+ \"] not found in the database\");\n\t\treturn c;\n\t}\n",
    "151414": "\tpublic Iterator find(QueryParam qp) {\n\t\tList sublist = getIndex(qp.getSort(), qp.isSortAsc()).subList(\n\t\t\t\tqp.getFirst(), qp.getFirst() + qp.getCount());\n\t\treturn sublist.iterator();\n\t}\n",
    "151422": "\tpublic void save(final Contact contact) {\n\t\tif (contact.getId() == 0) {\n\t\t\tcontact.setId(ContactGenerator.getInstance().generateId());\n\t\t\tadd(contact);\n\t\t\tupdateIndecies();\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"contact [\"\n\t\t\t\t\t+ contact.getFirstName() + \"] is already persistent\");\n\t\t}\n\t}\n",
    "151425": "\tpublic void delete(final Contact contact) {\n\t\tmap.remove(new Long(contact.getId()));\n\n\t\tfnameIdx.remove(contact);\n\t\tlnameIdx.remove(contact);\n\t\tfnameDescIdx.remove(contact);\n\t\tlnameDescIdx.remove(contact);\n\n\t\tcontact.setId(0);\n\t}\n",
    "151433": "\tpublic Contact generate() {\n\t\tContact contact = new Contact(randomString(firstNames),\n\t\t\t\trandomString(lastNames));\n\t\tcontact.setId(generateId());\n\t\tcontact.setHomePhone(generatePhoneNumber());\n\t\tcontact.setCellPhone(generatePhoneNumber());\n\t\treturn contact;\n\t}\n",
    "152575": "    public int getTag() {\n        return tag;\n    }\n",
    "152578": "        public CPEntry getConstantPoolEntry() {\n            return cpEntry;\n        }\n",
    "152581": "        public int getOffset() {\n            return offset;\n        }\n",
    "152593": "    public String getTypeSignature() {\n\tif (typeSignature == null) {\n\t    DataInputStream in = attributes.getStream(\"Signature\"); // NOI18N\n\t    if (in != null) {\n\t\ttry {\n\t\t    int index = in.readUnsignedShort();\n\t\t    CPUTF8Info entry = \n\t\t\t(CPUTF8Info)classFile.constantPool.get(index);\n\t\t    typeSignature = entry.getName();\n\t\t    in.close();\n\t\t} catch (IOException e) {\n\t\t    System.err.println(\"invalid Signature attribute\");\n\t\t}\n\t    }\n\t}\n\treturn typeSignature;\n    }\n",
    "152609": "    public ElementValue getAnnotationDefault() {\n\tif (annotationDefault == null) {\n\t    DataInputStream in = \n\t\tattributes.getStream(\"AnnotationDefault\"); // NOI18N\n\t    if (in != null) {\n\t\ttry {\n\t\t    annotationDefault = \n\t\t\tElementValue.load(in, classFile.constantPool, false);\n\t\t    in.close();\n\t\t} catch (IOException e) {\n\t\t    System.err.println(\"invalid AnnotationDefault attribute\");\n\t\t}\n\t    }\n\t}\n        return annotationDefault;\n    }\n",
    "152611": "    public int size() {\n\treturn map.size();\n    }\n",
    "152615": "    public boolean isEmpty() {\n\treturn map.isEmpty();\n    }\n",
    "152618": "    public boolean containsAttribute(String key) {\n\treturn map.containsKey(key);\n    }\n",
    "152620": "    public Set keySet() {\n\treturn map.keySet();\n    }\n",
    "152628": "        public int getOffsetDelta() {\n            return frameType;\n        }\n",
    "152632": "        public int getOffsetDelta() {\n            return frameType - 64;\n        }\n",
    "152637": "        public VerificationTypeInfo getVerificationTypeInfo() {\n            return typeInfo;\n        }\n",
    "152642": "        public int getOffsetDelta() {\n            return offset;\n        }\n",
    "152644": "    public int getMajorVersion() {\n\treturn majorVersion;\n    }\n",
    "152651": "    public int getMinorVersion() {\n\treturn minorVersion;\n    }\n",
    "152657": "    public String getTypeSignature() {\n\tif (typeSignature == null) {\n\t    DataInputStream in = attributes.getStream(\"Signature\"); // NOI18N\n\t    if (in != null) {\n\t\ttry {\n\t\t    CPUTF8Info entry = \n\t\t\t(CPUTF8Info)constantPool.get(in.readUnsignedShort());\n\t\t    typeSignature = entry.getName();\n\t\t    in.close();\n\t\t} catch (IOException e) {\n\t\t    System.err.println(\"invalid Signature attribute\");\n\t\t}\n\t    }\n\t}\n\treturn typeSignature;\n    }\n",
    "152665": "    public EnclosingMethod getEnclosingMethod() {\n\tif (enclosingMethod == null) {\n\t    DataInputStream in = \n\t\tattributes.getStream(\"EnclosingMethod\"); // NOI18N\n\t    if (in != null) {\n\t\ttry {\n\t\t    int classIndex = in.readUnsignedShort();\n\t\t    int natIndex = in.readUnsignedShort();\n\t\t    CPEntry classInfo = constantPool.get(classIndex);\n\t\t    if (classInfo.getTag() == ConstantPool.CONSTANT_Class)\n\t\t\tenclosingMethod = \n\t\t\t    new EnclosingMethod(constantPool, \n\t\t\t\t\t\t(CPClassInfo)classInfo, \n\t\t\t\t\t\tnatIndex);\n\t\t    else\n\t\t\t; // JDK 1.5 beta1 bug\n\t\t    in.close();\n\t\t} catch (IOException e) {\n\t\t    System.err.println(\"invalid EnclosingMethod attribute\");\n\t\t}\n\t    }\n\t}\n\treturn enclosingMethod;\n    }\n",
    "152672": "    public CPClassInfo getClassInfo() {\n\treturn classInfo;\n    }\n",
    "152673": "    public boolean hasMethod() {\n\treturn methodInfo != null;\n    }\n",
    "152675": "    public CPNameAndTypeInfo getMethodInfo() {\n\treturn methodInfo;\n    }\n",
    "152686": "    public String getInternalName() {\n        return internalName;\n    }\n",
    "152689": "    public String getExternalName() {\n        return getExternalName(false);\n    }\n",
    "152690": "    public boolean isRuntimeVisible() {\n\treturn runtimeVisible;\n    }\n",
    "152693": "    public String getExternalName(boolean suppressArrays) {\n        initExternalName();\n        int i;\n        if (suppressArrays && (i = externalName.indexOf('[')) != -1)\n\t    return externalName.substring(0, i);\n        return externalName;\n    }\n",
    "152700": "    public String getSimpleName() {\n\tif (simpleName == null) {\n\t    String pkg = getPackage();\n\t    int i = pkg.length();\n\t    String extName = getExternalName();\n\t    if (i == 0)\n\t\tsimpleName = extName;  // no package\n\t    else\n\t\tsimpleName = extName.substring(i + 1);\n\t}\n\treturn simpleName;\n    }\n",
    "152712": "    public int compareTo(Object obj) {\n        // If obj isn't a ClassName, the correct ClassCastException\n        // will be thrown by the cast.\n        return type.compareTo(((ClassName)obj).type);\n    }\n",
    "152719": "    public int compare(Object o1, Object o2) {\n        return ((ClassName)o1).compareTo(o2);\n    }\n",
    "152745": "    private Object readResolve() throws ObjectStreamException {\n        return getClassName(internalName);\n    }\n",
    "154443": "\tpublic WindowState getWindowState(){\n\t\treturn new WindowState(windowState);\n\t}\n",
    "156270": "\tpublic void debugComponentTrees(String filter) {\n\t\tlog.info(\"debugging ----------------------------------------------\");\n\t\tfor (Iterator iter = WicketTesterHelper.getComponentData(getLastRenderedPage())\n\t\t\t\t.iterator(); iter.hasNext();) {\n\t\t\tWicketTesterHelper.ComponentData obj = (WicketTesterHelper.ComponentData) iter\n\t\t\t\t\t.next();\n\t\t\tif (obj.path.matches(\".*\" + filter + \".*\")) {\n\t\t\t\tlog.info(\"path\\t\" + obj.path + \" \\t\" + obj.type + \" \\t[\" + obj.value + \"]\");\n\t\t\t}\n\t\t}\n\t}\n",
    "156373": "\tfinal protected boolean isHeadRendered() {\n\t\treturn getFlag(FLAG_HEAD_RENDERED);\n\t}\n",
    "156381": "\tfinal protected void resetHeadRendered() {\n\t\tsetFlag(FLAG_HEAD_RENDERED, false);\n\t}\n",
    "156732": "\tprotected void onError(AjaxRequestTarget target, Form form) {\n\t\t\n\t}\n",
    "157048": "\tpublic void generate(Collection collection, int count) {\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tcollection.add(generate());\n\t\t}\n\t}\n",
    "157049": "\tpublic ContactDao getContactDao() {\n\t\tif (contactDao == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (contactDao == null) {\n\t\t\t\t\tcontactDao = (ContactDao) internalGetApplicationContext()\n\t\t\t\t\t\t\t.getBean(\"contactDao\", ContactDao.class);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn contactDao;\n\t}\n",
    "157052": "\tpublic ContactDao getContactDaoProxy() {\n\t\tif (contactDaoProxy == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (contactDaoProxy == null) {\n\t\t\t\t\tcontactDaoProxy = (ContactDao) createSpringBeanProxy(\n\t\t\t\t\t\t\tContactDao.class, \"contactDao\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn contactDaoProxy;\n\t}\n",
    "158150": "\tprivate void initFactory(ISpringContextLocator locator) {\n\t\tfactory = new CommonsAttributeProxyFieldValueFactory(locator);\n\t}\n",
    "158828": "\tprotected void onClearSubmit(Button button) {\n\t\tbutton.getForm().setModelObject(Objects.cloneModel(originalState));\n\t}\n",
    "159077": "\tprotected void onBeforeAttach() \n\t{\t\n\t}\n",
    "164848": "  public void testAdd() {\n    System.out.println(\"add\");\n    \n    Path instance = new Path(\"a/b\");\n    instance = instance.add(\"c\");\n    assertEquals(instance, new Path(\"a/b/c\"));\n    instance = instance.add(\"../d\");\n    assertEquals(instance, new Path(\"a/b/d\"));\n    instance = new Path(\"../c\");\n    instance = instance.add(\"../../d\");\n    assertEquals(instance, new Path(\"../../d\"));\n  }\n",
    "164851": "  public boolean isHighQuality() {\n    return highQuality;\n  }\n",
    "164852": "  public void testGetParent() {\n    System.out.println(\"getParent\");\n    \n    Path instance = new Path(\"a/b\");\n    instance = instance.getParent();\n    assertEquals(instance, new Path(\"a\"));\n    instance = new Path(\"../../a\");\n    instance = instance.getParent();\n    assertEquals(instance, new Path(\"../..\"));\n    instance = new Path(\"..\");\n    instance = instance.getParent();\n    assertEquals(instance, new Path(\"../..\"));\n  }\n",
    "164853": "  public void setContent(Path dirPath, String names, boolean cut) {\n    this.dirPath = dirPath;\n    fileNames = Utils.tokenize(names, \",\");\n    this.cut = cut;\n  }\n",
    "164855": "  public void clear() {\n    dirPath = null;\n    fileNames = null;\n    cut = false;\n  }\n",
    "164857": "  public void setHighQuality(boolean highQuality) {\n    this.highQuality = highQuality;\n  }\n",
    "164858": "  public void testGetPartial() {\n    System.out.println(\"getPartial\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    instance = instance.getPartial(2);\n    assertEquals(instance, new Path(\"a/b\"));\n  }\n",
    "164859": "  public int countFiles() {\n    return fileNames == null ? 0 : fileNames.length;\n  }\n",
    "164860": "  public Path getDirPath() {\n    return dirPath;\n  }\n",
    "164862": "  public void testGetCommonPath() {\n    System.out.println(\"getCommonPath\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    instance = instance.getCommonPath(new Path(\"a/b/e\"));\n    assertEquals(instance, new Path(\"a/b\"));\n    instance = instance.getCommonPath(new Path(\"b/e\"));\n    assertEquals(instance, Path.ROOT);\n  }\n",
    "164863": "  public boolean isCut() {\n    return cut;\n  }\n",
    "164868": "  public void testIsRelative() {\n    System.out.println(\"isRelative\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    assertTrue(!instance.isRelative());\n    instance = new Path(\"..\");\n    assertTrue(instance.isRelative());\n    instance = new Path(\"../c\");\n    assertTrue(instance.isRelative());\n  }\n",
    "164872": "  public void testIsRoot() {\n    System.out.println(\"isRoot\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    assertTrue(!instance.isRoot());\n    instance = new Path(\"c/..\");\n    assertTrue(instance.isRoot());\n  }\n",
    "164875": "  public void setName(String name) {\n    this.name = Utils.trim(name);\n  }\n",
    "164876": "  public void setWriter(Writer writer) {\n    this.writer = writer;\n  }\n",
    "164877": "  public void testIsChildOf() {\n    System.out.println(\"isChildOf\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    assertTrue(!instance.isChildOf(new Path(\"a/b\")));\n    assertTrue(instance.isChildOf(new Path(\"a/b/c\")));\n    assertTrue(!instance.isChildOf(new Path(\"a/b/c/d\")));\n    assertTrue(!instance.isChildOf(new Path(\"a/b/c/d/e\")));\n    instance = new Path(\"../a\");\n    assertTrue(instance.isChildOf(new Path(\"..\")));\n    assertTrue(!instance.isChildOf(Path.ROOT));\n  }\n",
    "164878": "  public Writer getWriter() {\n    return writer;\n  }\n",
    "164880": "  public void testIsContainedIn() {\n    System.out.println(\"isContainedIn\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    assertTrue(instance.isContainedIn(new Path(\"a/b\")));\n    assertTrue(instance.isContainedIn(new Path(\"a/b/c\")));\n    assertTrue(instance.isContainedIn(new Path(\"a/b/c/d\")));\n    assertTrue(!instance.isContainedIn(new Path(\"a/b/c/d/e\")));\n    instance = new Path(\"../a\");\n    assertTrue(!instance.isContainedIn(Path.ROOT));\n  }\n",
    "164881": "  public void setStaticDir(File staticDir) {\n    this.staticDir = staticDir;\n  }\n",
    "164887": "  public File getStaticDir() {\n    return staticDir;\n  }\n",
    "164889": "  public void setCode(String code) {\n    this.code = Utils.trim(code);\n  }\n",
    "164891": "  public void testGetElementCount() {\n    System.out.println(\"getElementCount\");\n    \n    Path instance = new Path(\"a/../b/c/./d\");\n    assertEquals(instance.getElementCount(), 3);\n  }\n",
    "164893": "  public void setContextURL(URL contextURL) {\n    this.contextURL = contextURL;\n  }\n",
    "164895": "  public void testGetElementAt() {\n    System.out.println(\"getElementAt\");\n    \n    Path instance = new Path(\"a/../b/c/./d\");\n    assertEquals(instance.getElementAt(1), \"c\");\n  }\n",
    "164899": "  public URL getContextURL() {\n    return contextURL;\n  }\n",
    "164901": "  public void testGetLastElement() {\n    System.out.println(\"getLastElement\");\n    \n    Path instance = new Path(\"a/b/c/d\");\n    assertEquals(instance.getLastElement(), \"d\");\n    instance = new Path(\"a/b/c/..\");\n    assertEquals(instance.getLastElement(), \"b\");\n  }\n",
    "164905": "  public void setCheckDates(boolean checkDates) {\n    this.checkDates = checkDates;\n  }\n",
    "164907": "  public void testGetAsLink() {\n    System.out.println(\"getAsLink\");\n    \n    Path instance = new Path(\"a/b\");\n    assertEquals(instance.getAsLink(), \"/a/b\");\n    instance = new Path(\"../a/b\");\n    assertEquals(instance.getAsLink(), \"../a/b\");\n    assertEquals(Path.ROOT.getAsLink(), \"\");\n  }\n",
    "164909": "  public boolean getCheckDates() {\n    return checkDates;\n  }\n",
    "164910": "  public void testCompareTo() {\n    System.out.println(\"compareTo\");\n    \n    Path p1 = new Path(\"abc/def\");\n    Path p2 = new Path(\"abc/de/f\");\n    Path p3 = new Path(\"abcd/e/f\");\n    Path p4 = new Path(\"abc\");\n    \n    assertEquals(p3.compareTo(p3), 0);\n    assertTrue(p1.compareTo(p2) > 0);\n    assertTrue(p1.compareTo(p3) < 0);\n    assertTrue(p1.compareTo(p4) > 0);\n    assertTrue(p2.compareTo(p1) < 0);\n    assertTrue(p2.compareTo(p3) < 0);\n    assertTrue(p2.compareTo(p4) > 0);\n    assertTrue(p4.compareTo(p3) < 0);\n  }\n",
    "164914": "  public void testEquals() {\n    System.out.println(\"equals\");\n    \n    Path p1 = new Path(\"abc/def\");\n    Path p2 = new Path(\"abc/./def/b/..\");\n    assertTrue(p1.equals(p2));\n  }\n",
    "164917": "  public void setValue(String value) {\n    this.value = Utils.trim(value);\n  }\n",
    "164919": "  public void testCommonPart() {\n    // tested by testGetCommonPath\n  }\n",
    "164923": "  public void testReplace() {\n    System.out.println(\"replace\");\n    \n    Path instance = new Path(\"a/b/c\");\n    instance = instance.replace(1, \"d\");\n    assertEquals(instance, new Path(\"a/d/c\"));\n    instance = instance.replace(2, \"e\");\n    assertEquals(instance, new Path(\"a/d/e\"));\n  }\n",
    "164929": "  public void setOptions(String[] options) {\n    this.options = options;\n\n    for (int i = 0; i < options.length; i++) {\n      this.options[i] = Utils.trim(this.options[i]);\n    }\n  }\n",
    "164937": "  public void setNameAndCode(String name) {\n    setName(name);\n    setCode(createCode(name));\n  }\n",
    "164947": "  public void setRequired(boolean required) {\n    this.required = required;\n  }\n",
    "164954": "  public int getStartTagReturnValue() {\n    return SKIP_BODY;\n  }\n",
    "164955": "  public boolean isRequired() {\n    return required;\n  }\n",
    "164958": "  public void writeEditTag() throws IOException, JspException {\n    writeTag();\n  }\n",
    "164961": "  protected Page getPage() {\n    Page p = (Page) pageContext.getAttribute(PAGE, PageContext.PAGE_SCOPE);\n    \n    if (p == null) {\n      p = (Page) pageContext.getAttribute(PAGE, PageContext.REQUEST_SCOPE);\n      \n      if (p == null) {\n        pageContext.removeAttribute(PAGE, PageContext.PAGE_SCOPE);\n      } else {\n        pageContext.setAttribute(PAGE, p, PageContext.PAGE_SCOPE);\n      }\n      \n      pageContext.removeAttribute(PAGE, PageContext.REQUEST_SCOPE);\n    }\n    \n    if (p == null) {\n      // No page? Weird! Better to block the cache at least.\n      WebUtils.setBlockCache(request);\n    }\n    \n    return p;\n  }\n",
    "164962": "  public void setSender(boolean sender) {\n    this.sender = sender;\n\n    if (sender) {\n      setRequired(true);\n    }\n  }\n",
    "164965": "  protected Writer getOut() {\n    return OutputConverter.getWriter(pageContext.getOut());\n  }\n",
    "164968": "  public boolean isSender() {\n    return sender;\n  }\n",
    "164975": "  public void setRecipient(boolean recipient) {\n    this.recipient = recipient;\n  }\n",
    "164983": "  public boolean isRecipient() {\n    return recipient;\n  }\n",
    "164991": "  public void setRows(int rows) {\n    this.rows = rows;\n  }\n",
    "164999": "  public int getRows() {\n    return rows;\n  }\n",
    "165016": "  public boolean checkValue() {\n    String val = Utils.noNull(getValue()).trim();\n\n    if (isRequired() && val.equals(\"\")) {\n      return false;\n    }\n\n    if (getType() == EMAIL || isSender() || isRecipient()) {\n      if (!Utils.checkAddress(val)) {\n        return false;\n      }\n    }\n\n    if (getType() == NUMBER && !val.equals(\"\")) {\n      try {\n        Double.parseDouble(val);\n      } catch (Exception ex) {\n        return false;\n      }\n    }\n\n    val = val.toLowerCase();\n\n    /* The purpose of this if block is to reject some attempts to spam the mail\n       form. All identified attempts contained these pieces of text somewhere */\n      return !(val.indexOf(\"content-type:\") > -1 &&\n          val.indexOf(\"mime-version:\") > -1);\n\n  }\n",
    "165026": "  public String getDescription() {\n    String desc = getValue();\n\n    if (Utils.isNullOrEmpty(desc)) {\n      desc = getName();\n\n      if (Utils.isNullOrEmpty(desc)) {\n        if (isRecipient()) {\n          desc = \"(recipient)\";\n        } else if (isSender()) {\n          desc = \"(sender)\";\n        } else {\n          desc = \"(unknown)\";\n        }\n      }\n    }\n\n    return desc;\n  }\n",
    "165032": "  public String toString() {\n    return \"Form Field: \" + getDescription();\n  }\n",
    "165040": "  public boolean isSenderName() {\n    return senderName;\n  }\n",
    "165046": "  public void setSenderName(boolean senderName) {\n    this.senderName = senderName;\n  }\n",
    "165055": "  public boolean isSubject() {\n    return subject;\n  }\n",
    "165067": "  public void setSubject(boolean subject) {\n    this.subject = subject;\n  }\n",
    "165078": "  public boolean isMessageBody() {\n    return messageBody;\n  }\n",
    "165088": "  public void setMessageBody(boolean messageBody) {\n    this.messageBody = messageBody;\n  }\n",
    "165148": "  public boolean isPrependSlash() {\n    return prependSlash;\n  }\n",
    "165194": "  public boolean getResult() {\n    return result;\n  }\n",
    "165208": "  public boolean check() {\n    if (notStarted) {\n      imgImage.getSource().startProduction(this);\n      notStarted = false;\n    }\n\n    return completed;\n  }\n",
    "165212": "  public int getWidth() {\n    return width;\n  }\n",
    "165213": "  public Path add(Object o) {\n    return new Path(this, o);\n  }\n",
    "165215": "  public int getHeight() {\n    return height;\n  }\n",
    "165219": "  public Path add(Object o1, Object o2) {\n    return new Path(this, o1, o2);\n  }\n",
    "165225": "  public int compare(Object o1, Object o2) {\n    try {\n      Locale l1 = (Locale) o1;\n      Locale l2 = (Locale) o2;\n\n      if (locale == null) {\n        return l1.getDisplayName().compareTo(l2.getDisplayName());\n      } else {\n        return l1.getDisplayName(locale).compareTo(l2.getDisplayName(locale));\n      }\n    } catch (Exception ex) {}\n\n    return 0;\n  }\n",
    "165226": "  public Path getParent() {\n    return new Path(this, \"..\");\n  }\n",
    "165237": "  public void setRecursive(boolean recursive) {\n    this.recursive = recursive;\n  }\n",
    "165239": "  public void setProcessStartDir(boolean processStartDir) {\n    this.processStartDir = processStartDir;\n  }\n",
    "165240": "  public Path getCommonPath(Path other) {\n    return commonPart(this, other);\n  }\n",
    "165241": "  public boolean isRecursive() {\n    return recursive;\n  }\n",
    "165242": "  public Image getImage() {\n    waitForImage();\n\n    return Toolkit.getDefaultToolkit().createImage(\n      new MemoryImageSource(width, height, imgPixels, 0, width)\n    );\n  }\n",
    "165244": "  public boolean isProcessStartDir() {\n    return processStartDir;\n  }\n",
    "165245": "  public void waitForImage() {\n    while (!check()) {\n      try {\n        Thread.sleep(500L);\n      } catch (InterruptedException ex) {}\n    }\n  }\n",
    "165246": "  public void setSorted(boolean sorted) {\n    if (sorted) {\n      comparator = new FileNameComparator();\n    } else {\n      comparator = null;\n    }\n  }\n",
    "165249": "  public boolean isSorted() {\n    return comparator != null;\n  }\n",
    "165253": "  public void setInitialDir(String dir) {\n    setInitialDir(Utils.isNullOrEmpty(dir) ? null : new File(dir));\n  }\n",
    "165256": "  public void setInitialDir(File dir) {\n    initialDir = dir;\n  }\n",
    "165260": "  public File getInitialDir() {\n    return initialDir;\n  }\n",
    "165264": "  public void run() {\n    process();\n  }\n",
    "165268": "  public boolean isContainedIn(Path root) {\n    return root == null ? false : !getRelativeTo(root).isRelative();\n  }\n",
    "165271": "  protected boolean preProcess() {\n    return true;\n  }\n",
    "165272": "  public Path getRelativeTo(Object root) {\n    Path rootPath = (root instanceof Path) ? (Path) root : new Path(root);\n\n    int i0 = 0;\n    int i1 = 0;\n\n    List list = new ArrayList();\n\n    while (i0 < rootPath.getElementCount() && i1 < elements.length &&\n           rootPath.getElementAt(i0).equals(elements[i1])) {\n      i0++;\n      i1++;\n    }\n\n    while (i0++ < rootPath.getElementCount()) {\n      list.add(\"..\");\n    }\n\n    while (i1 <= elements.length - 1) {\n      list.add(elements[i1++]);\n    }\n\n    return new Path(list);\n  }\n",
    "165273": "  protected void postProcess() {\n  }\n",
    "165275": "  public File getFile(File parent) {\n    return elements.length == 0 ? parent : new File(parent, pathName);\n  }\n",
    "165279": "  protected void processFile(File file, Path path) {\n  }\n",
    "165280": "  public int getElementCount() {\n    return elements.length;\n  }\n",
    "165281": "  public void init(String data) {\n    if (data.indexOf(LOCATION_ID) < 0) { // old module definition\n      String[] values = Utils.tokenize(data, \":\");\n      advancedParams = new Properties();\n\n      if (values != null) {\n        switch (values.length) {\n          case 1: // path only\n            setLocation(\"\");\n            setTemplate(\"include.jsp\");\n            setArgument(values[0]);\n            break;\n          case 2: // template and path\n            setLocation(\"\");\n            setTemplate(values[0]);\n            setArgument(values[1]);\n            break;\n          case 3: // location, template and path\n            setLocation(values[0]);\n            setTemplate(values[1]);\n            setArgument(values[2]);\n        }\n      }\n    } else { // new module definition\n      parseParameters(data);\n    }\n  }\n",
    "165283": "  public String getElementAt(int index) {\n    return elements[index];\n  }\n",
    "165284": "  public void parseParameters(String data) {\n    advancedParams = new Properties();\n    StringTokenizer st = new StringTokenizer(data, \",\");\n    String value, param;\n\n    while (st.hasMoreTokens()) {\n      value = st.nextToken().trim();\n      int eqIdx = value.indexOf('=');\n\n      if (eqIdx != -1) {\n        param = value.substring(0, eqIdx).trim();\n        value = value.substring(eqIdx + 1).trim();\n\n        if (param.equals(LOCATION_ID)) {\n          setLocation(value);\n        } else if (param.equals(TEMPLATE_ID)) {\n          setTemplate(value);\n        } else if (param.equals(ARGUMENT_ID)) {\n          setArgument(value);\n        } else if (param.equals(TITLE_ID)) {\n          setTitle(value);\n        } else {\n          advancedParams.setProperty(param, value);\n        }\n      }\n    }\n  }\n",
    "165286": "  public boolean isValid() {\n    return location != null && template != null;\n  }\n",
    "165289": "  public String getLastElement() {\n    return elements.length == 0 ? \"\" : elements[elements.length - 1];\n  }\n",
    "165290": "  public Path getCMSPath() {\n    if (cmsPath == null) {\n      process();\n    }\n\n    return cmsPath;\n  }\n",
    "165291": "  public String getLocation() {\n    return location;\n  }\n",
    "165292": "  public String toString() {\n    return pathName;\n  }\n",
    "165293": "  public void setLocation(String location) {\n    this.location = location;\n  }\n",
    "165294": "  public String getTemplate() {\n    return template;\n  }\n",
    "165296": "  public void setTemplate(String template) {\n    this.template = template.endsWith(\".jsp\") ?\n        // old modules were in the form module_name.jsp\n        template.substring(0, template.length() - 4) : template;\n  }\n",
    "165299": "  public String getArgument() {\n    return argument;\n  }\n",
    "165300": "  public int compareTo(Object o) {\n    return compareTo(new Path(o));\n  }\n",
    "165301": "  public void setArgument(String s) {\n    argument = PageAssembler.EMPTY.equals(s) ? null : s;\n  }\n",
    "165302": "  public int compareTo(Path other) {\n    int level = other.getElementCount();\n    int result;\n\n    for (int i = 0; i < elements.length; i++) {\n      if (i >= level) {\n        return 1;\n      }\n\n      result = elements[i].compareTo(other.getElementAt(i));\n\n      if (result != 0) {\n        return result;\n      }\n    }\n\n    return level > elements.length ? -1 : 0;\n  }\n",
    "165304": "  public Properties getAdvancedParams() {\n    return advancedParams;\n  }\n",
    "165305": "  public String getAdvancedParam(String paramName, String defaultValue) {\n    return advancedParams == null ? defaultValue :\n     advancedParams.getProperty(paramName, defaultValue);\n  }\n",
    "165306": "  public int hashCode() {\n    return pathName.hashCode();\n  }\n",
    "165307": "  public void updateSiteMap(boolean force) {\n    if (force) {\n      new SiteMap(this).process();\n    } else if (System.currentTimeMillis() - siteMap.getLastModified() >\n               configuration.getUpdateIntervalMillis()) {\n    \tnew SiteMap(this).start();\n      new DirectoryCleaner(getFile(repositoryPath),\n          configuration.getBackupLifeMillis()).start();\n      new DirectoryCleaner(getFile(generatedFilesPath),\n          configuration.getBackupLifeMillis()).start();\n      new DirectoryCleaner(getFile(moduleDataPath)).start();\n    }\n  }\n",
    "165310": "  public void setAdvancedParams(Properties advancedParams) {\n    this.advancedParams = advancedParams;\n  }\n",
    "165311": "  public boolean equals(Object o) {\n    if (o == null || !(o instanceof Path)) {\n      return false;\n    }\n\n    return pathName.equals(o.toString());\n  }\n",
    "165312": "  public Path getPagePath() {\n    return pagePath;\n  }\n",
    "165313": "  public void setPagePath(Path pagePath) {\n    this.pagePath = pagePath;\n  }\n",
    "165314": "  public Path successor() {\n    return (elements.length == 0) ? new Path(\"\\0\") : getParent().add(getLastElement() + '\\0');\n  }\n",
    "165316": "  public Path getModulePath() {\n    return modulePath;\n  }\n",
    "165317": "  public SiteMap getSiteMap() {\n    return siteMap;\n  }\n",
    "165320": "  public void setModulePath(Path modulePath) {\n    this.modulePath = modulePath;\n  }\n",
    "165322": "  public Configuration getConfiguration() {\n    return configuration;\n  }\n",
    "165323": "  public String getDateFormat() {\n    return dateFormat;\n  }\n",
    "165324": "  public void write(int b) throws IOException {\n    output.write(b);\n\n    try {\n      cacheOutput.write(b);\n    } catch (IOException ex) {}\n  }\n",
    "165325": "  public PageInfo getPageInfo(Path path) {\n    return (PageInfo) pagesMap.get(getPathInMenu(path));\n  }\n",
    "165326": "  public void flush() throws IOException {\n    output.flush();\n\n    try {\n      cacheOutput.flush();\n    } catch (IOException ex) {}\n  }\n",
    "165327": "  public void setDateFormat(String dateFormat) {\n    this.dateFormat = dateFormat;\n  }\n",
    "165328": "  public void close() throws IOException {\n    output.close();\n\n    try {\n      cacheOutput.close();\n    } catch (IOException ex) {}\n  }\n",
    "165330": "  public String getStyle() {\n    return style;\n  }\n",
    "165332": "  public SiteInfo getSiteInfo() {\n    return siteInfo;\n  }\n",
    "165334": "  public void setStyle(String style) {\n    this.style = style;\n  }\n",
    "165336": "  public Path getModuleArgumentPath(boolean allowCurrentPath) {\n    Path argPath = null;\n\n    if (argument != null) {\n      argPath = new Path(argument);\n    } else if (allowCurrentPath) {\n      argPath = pagePath;\n    }\n\n    return argPath;\n  }\n",
    "165345": "  public String getFullCSSAttribute(String paramName) {\n    String css = getAdvancedParam(paramName, style);\n    return Utils.isNullOrEmpty(css) ? \"\" : \" class=\\\"\" + css + \"\\\"\";\n  }\n",
    "165348": "  public int getStatsLength() {\n    return statsLength;\n  }\n",
    "165349": "  public PageInfo getNextPage() {\n    findNextPage();\n    nextPageChecked = false;\n    return nextPage;\n  }\n",
    "165352": "  public Path getPathInMenu(Path path) {\n    return currentWelcomes.containsValue(path) ? path.getParent() : path;\n  }\n",
    "165355": "  public DateFormat getDateFormat(Locale locale, String paramName) {\n    String paramValue = getAdvancedParam(paramName, dateFormat);\n    DateFormat df = null;\n\n    if (Module.DATE_NORMAL.equals(paramValue)) {\n      df = DateFormat.getDateInstance(DateFormat.MEDIUM, locale);\n    } else if (Module.DATE_FULL.equals(paramValue)) {\n      df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,\n          locale);\n    }\n\n    return df;\n  }\n",
    "165359": "  public boolean createDirectory(UserInfo user, Path dirPath) {\n    File newDir = getFile(dirPath);\n\n    if (newDir.isDirectory()) {\n      return true;\n    }\n\n    return user != null && user.canWrite(this, dirPath) && newDir.mkdir();\n  }\n",
    "165364": "  public Path getPath() {\n    return path;\n  }\n",
    "165365": "  public Path getCurrentWelcome(Path dirPath) {\n    return (Path) currentWelcomes.get(dirPath);\n  }\n",
    "165368": "  public boolean createFile(UserInfo user, Path filePath) {\n    if (user == null || !user.canWrite(this, filePath)) {\n      return false;\n    }\n\n    File newFile = getFile(filePath);\n\n    if (newFile.exists()) {\n      return !newFile.isDirectory();\n    }\n\n    try {\n      if (FileTypes.isPage(filePath.getLastElement())) {\n        if (newFile.exists()) {\n          return false;\n        }\n\n        return saveToFile(user, getHTMLTemplate(null), filePath);\n      } else {\n        return newFile.createNewFile();\n      }\n    } catch (IOException ex) {\n      sc.log(\"Can't create file \" + newFile, ex);\n    }\n\n    return false;\n  }\n",
    "165370": "  public void setWidth(int width) {\n    this.width = width;\n  }\n",
    "165371": "  public String getName() {\n    return path.getLastElement();\n  }\n",
    "165373": "  public int getLevel() {\n    return path.getElementCount();\n  }\n",
    "165374": "  public boolean isCurrentWelcome(Path path) {\n    return currentWelcomes.containsValue(path);\n  }\n",
    "165375": "  public String toString() {\n    return title;\n  }\n",
    "165376": "  public void setHeight(int height) {\n    this.height = height;\n  }\n",
    "165377": "  public long getLastModified() {\n    return lastModified;\n  }\n",
    "165379": "  public boolean copyFile(UserInfo user, Path filePath, String newName) {\n    return copyFile(user, filePath, filePath.getParent().add(newName));\n  }\n",
    "165380": "  public void setLastModified(long lastModified) {\n    this.lastModified = lastModified;\n  }\n",
    "165382": "  public void setMode(String mode) {\n    if (mode == null) {\n      this.mode = MODE_SCALE;\n    } else {\n      mode = mode.trim().toLowerCase();\n\n      if (mode.equals(MODE_CROP) || mode.equals(MODE_PADDING) ||\n          mode.equals(MODE_SCALE) || mode.equals(MODE_STRETCH)) {\n        this.mode = mode;\n      } else {\n        throw new IllegalArgumentException(\"Unknown mode: \" + mode);\n      }\n    }\n  }\n",
    "165387": "  public void setColor(String color) {\n    if (color == null) {\n      this.color = WHITE;\n    } else {\n      if (hexColorMatcher.reset(color).find()) {\n        this.color = hexColorMatcher.group();\n      } else {\n        throw new IllegalArgumentException(\"Unknown color: \" + color);\n      }\n    }\n  }\n",
    "165388": "  public String getExcerpt() {\n    return excerpt;\n  }\n",
    "165391": "  public boolean copyFile(UserInfo user, Path oldPath, Path newPath) {\n    File oldFile = getFile(oldPath);\n\n    if (!oldFile.exists()) {\n      return false;\n    }\n\n    File newFile = getFile(newPath);\n\n    if (user == null || !user.canWrite(this, newPath)) {\n      return false;\n    }\n\n    if (oldFile.isDirectory()) {\n      return Utils.copyDirectory(oldFile, newFile, false, false, false);\n    } else {\n    try {\n      return Utils.copyFile(oldFile, newFile, false, false);\n    } catch (IOException ex) {\n      sc.log(\"Can't copy file \" + oldFile + \" to file \" + newFile, ex);\n      }\n    }\n\n    return false;\n  }\n",
    "165393": "  public void setExcerpt(String excerpt) {\n    this.excerpt = excerpt;\n  }\n",
    "165401": "  public void setUsername(String username) {\n    if (username != null) {\n      info.setProperty(USERNAME, username);\n    }\n  }\n",
    "165402": "  public boolean rename(UserInfo user, Path filePath, String newName) {\n    return move(user, filePath, filePath.getParent().add(newName));\n  }\n",
    "165404": "  public String getUsername() {\n    return getValue(USERNAME);\n  }\n",
    "165406": "  public void setUseAdminTheme(boolean useAdminTheme) {\n    this.useAdminTheme = useAdminTheme;\n  }\n",
    "165407": "  public void setPassword(String password) {\n    info.setProperty(PASSWORD, cryptPassword(password));\n  }\n",
    "165408": "  public boolean updatePassword(String oldPassword, String newPassword) {\n    if (verifyPassword(oldPassword)) {\n      setPassword(newPassword);\n      return true;\n    }\n\n    return false;\n  }\n",
    "165409": "  public boolean isPreventHotlinking() {\n    return preventHotlinking;\n  }\n",
    "165410": "  public boolean move(UserInfo user, Path oldPath, Path newPath) {\n    File oldFile = getFile(oldPath);\n\n    if (!oldFile.exists()) {\n      return false;\n    }\n\n    if (newPath.isContainedIn(oldPath)) {\n      return false;\n    }\n\n    if (user == null ||\n        !(user.canWrite(this, oldPath) && user.canWrite(this, newPath))) {\n      return false;\n    }\n\n    File newFile = getFile(newPath);\n\n    if (Utils.forceRenameTo(oldFile, newFile, false)) {\n      return true;\n    } else {\n      sc.log(\"Can't move file \" + oldFile + \" to file \" + newFile);\n    }\n\n    return false;\n  }\n",
    "165412": "  public String getPassword() {\n    return getValue(PASSWORD);\n  }\n",
    "165413": "  public void setPreventHotlinking(boolean preventHotlinking) {\n    this.preventHotlinking = preventHotlinking;\n  }\n",
    "165414": "  public boolean setEmail(String email) {\n    if (Utils.checkAddress(email)) {\n      info.setProperty(E_MAIL, email);\n      return true;\n    }\n\n    return false;\n  }\n",
    "165415": "  public int getBackupLife() {\n    return backupLife;\n  }\n",
    "165418": "  public String getEmail() {\n    return getValue(E_MAIL);\n  }\n",
    "165419": "  public void setBackupLife(int backupLife) {\n    this.backupLife = Math.max(backupLife, 0);\n  }\n",
    "165420": "  public void setHomePath(Path homePath) {\n    if (homePath != null) {\n      info.setProperty(HOME_PATH, homePath.toString());\n    }\n  }\n",
    "165422": "  public List getPagesInDirectory(Path path, boolean includeDir) {\n    PageInfo rootPage = getPageInfo(webSite.getDirectory(path));\n    int idx = pagesList.indexOf(rootPage);\n    \n    if (idx < 0) {\n      return null;\n    }\n    \n    List list = new ArrayList();\n    \n    if (includeDir) {\n      list.add(rootPage);\n    }\n    \n    for (int i = idx + 1; i < pagesList.size(); i++) {\n      PageInfo pi = (PageInfo) pagesList.get(i);\n      int n = pi.getLevel() - rootPage.getLevel();\n      \n      if (n <= 0) {\n        break;\n      } else if (n == 1) {\n        list.add(pi);\n      }\n    }\n    \n    return list;\n  }\n",
    "165423": "  public Path getHomePath() {\n    return new Path(getValue(HOME_PATH));\n  }\n",
    "165424": "  public boolean touch(UserInfo user, Path filePath) {\n    return setFileTime(user, filePath, System.currentTimeMillis());\n  }\n",
    "165425": "  public void setStatsLength(int statsLength) {\n    this.statsLength = Math.max(statsLength, 1);\n  }\n",
    "165426": "  public void setPermissions(int permissions) {\n    info.setProperty(PERMISSIONS, Integer.toHexString(permissions));\n  }\n",
    "165427": "  public List getPagesList() {\n    return pagesList;\n  }\n",
    "165428": "  public int getUpdateInterval() {\n    return updateInterval;\n  }\n",
    "165429": "  public int getPermissions() {\n    try {\n      return Integer.parseInt(getValue(PERMISSIONS), 16);\n    } catch (Exception ex) {}\n\n    return GUEST;\n  }\n",
    "165430": "  public String getPreferredLocaleCode() {\n    return getValue(LANGUAGE);\n  }\n",
    "165431": "  public void setUpdateInterval(int updateInterval) {\n    this.updateInterval = Math.max(updateInterval, 1);\n  }\n",
    "165433": "  public void setPreferredLocaleCode(String localeCode) {\n    if (localeCode == null || localeCode.length() < 2) {\n      localeCode = \"en_US\";\n    }\n\n    info.setProperty(LANGUAGE, localeCode);\n  }\n",
    "165435": "  public int getCacheType() {\n    return cacheType;\n  }\n",
    "165436": "  public void loadGuest() {\n    info = new Properties();\n    global = false;\n  }\n",
    "165437": "  public void setCacheType(int cacheType) {\n    this.cacheType = cacheType;\n  }\n",
    "165439": "  public String getMailServer() {\n    return mailServer;\n  }\n",
    "165441": "  public void cache(Path path, byte[] b) {\n    if (pageCache != null) {\n      pageCache.put(new Path(path), b);\n    }\n  }\n",
    "165442": "  public boolean store(WebSite webSite) {\n    if (global) {\n      webSite = ((VirtualWebSite) webSite).getMainWebSite();\n    }\n    \n    return webSite.storeToXML(info, getUserPath(webSite, getUsername()));\n  }\n",
    "165443": "  public void setMailServer(String mailServer) {\n    this.mailServer = mailServer;\n  }\n",
    "165444": "  private String cryptPassword(String password) {\n    if (Utils.isNullOrEmpty(password)) {\n      return \"\";\n    }\n\n    /* if (password.startsWith(SALT)) {\n      return password;\n    } */\n\n    return com.kingwoodcable.locutus.jfd.JCrypt.crypt(SALT, password);\n  }\n",
    "165445": "  public String getSmtpUsername() {\n    return smtpUsername;\n  }\n",
    "165446": "  public boolean verifyPassword(String password) {\n    return getPassword().equals(cryptPassword(password));\n  }\n",
    "165447": "  public void removeFromCache(Path path) {\n    if (pageCache != null) {\n      pageCache.remove(path);\n    }\n  }\n",
    "165448": "  public File getRepositoryFile(Path filePath, String fileName) {\n    File repoDir = getFile(repositoryPath.add(filePath));\n    repoDir.mkdirs();\n    return new File(repoDir, fileName);\n  }\n",
    "165449": "  public void setSmtpUsername(String smtpUsername) {\n    this.smtpUsername = smtpUsername;\n  }\n",
    "165452": "  public String getSmtpPassword() {\n    return smtpPassword;\n  }\n",
    "165453": "  public boolean isCached(Path path) {\n    return pageCache == null ? false : pageCache.containsKey(path);\n  }\n",
    "165454": "  public boolean canDo(int what) {\n    return (getPermissions() & what) != 0;\n  }\n",
    "165455": "  public void setSmtpPassword(String smtpPassword) {\n    this.smtpPassword = smtpPassword;\n  }\n",
    "165458": "  public boolean store(WebSite webSite) {\n    return webSite.storeToXML(this, webSite.getConfigFilePath());\n  }\n",
    "165460": "  public boolean setDetail(String name, String value) {\n    if (Utils.searchString(DETAILS, name, false) != -1) {\n      info.setProperty(name, value);\n      return true;\n    }\n\n    return false;\n  }\n",
    "165461": "  public long getUpdateIntervalMillis() {\n    return getUpdateInterval() * LENGTH_OF_HOUR;\n  }\n",
    "165462": "  public String getValue(String name) {\n    return Utils.noNull(info.getProperty(name));\n  }\n",
    "165465": "  public long getBackupLifeMillis() {\n    return getBackupLife() * LENGTH_OF_DAY;\n  }\n",
    "165466": "  public String getDetailValue(String name) {\n    if (name != null) {\n      name = name.toLowerCase();\n\n      if (Utils.searchString(DETAILS, name, false) != -1) {\n        return getValue(name);\n      }\n    }\n\n    return null;\n  }\n",
    "165467": "  public void setVisualExtensions(String[] visualExtensions) {\n    this.visualExtensions = visualExtensions;\n  }\n",
    "165468": "  public String getDetailName(int index) {\n    return DETAILS[index];\n  }\n",
    "165470": "  public boolean isAlwaysRedirectWelcomes() {\n    return alwaysRedirectWelcomes;\n  }\n",
    "165471": "  public String getDisplayName() {\n    String name = getValue(DETAILS[1]);\n    String surname = getValue(DETAILS[2]);\n\n    if (name.equals(\"\") && surname.equals(\"\")) {\n      return isGuest() ? \"guest\" : getUsername();\n    }\n\n    if (name.equals(\"\")) {\n      return surname;\n    }\n\n    if (surname.equals(\"\")) {\n      return name;\n    }\n\n    return name + \" \" + surname;\n  }\n",
    "165473": "  public void setAlwaysRedirectWelcomes(boolean alwaysRedirectWelcomes) {\n    this.alwaysRedirectWelcomes = alwaysRedirectWelcomes;\n  }\n",
    "165474": "  public boolean isGuest() {\n    return getPermissions() == GUEST;\n  }\n",
    "165476": "  public boolean isAlwaysDenyDirectoryListings() {\n    return alwaysDenyDirectoryListings;\n  }\n",
    "165477": "  public boolean exists(WebSite webSite, String username) {\n    return getUserFile(webSite, username).exists();\n  }\n",
    "165479": "  public File getFile(Path path) {\n    return (path == null || path.isRelative()) ? null :\n        new File(rootFile, path.toString());\n  }\n",
    "165480": "  public void setAlwaysDenyDirectoryListings(boolean alwaysDenyDirectoryListings) {\n    this.alwaysDenyDirectoryListings = alwaysDenyDirectoryListings;\n  }\n",
    "165481": "  public void setObsolete(boolean obsolete) {\n    this.obsolete = obsolete;\n  }\n",
    "165485": "  public String getSiteHost() {\n    return siteHost;\n  }\n",
    "165489": "  public void setSiteHost(String siteHost) {\n    this.siteHost = siteHost;\n  }\n",
    "165494": "  public String getSiteDescription() {\n    return siteDescription;\n  }\n",
    "165500": "  public void setSiteDescription(String siteDescription) {\n    this.siteDescription = siteDescription;\n  }\n",
    "165503": "  public Path getRootPath() {\n    return rootPath;\n  }\n",
    "165507": "  public String getSiteKeywords() {\n    return siteKeywords;\n  }\n",
    "165513": "  public void setSiteKeywords(String siteKeywords) {\n    this.siteKeywords = siteKeywords;\n  }\n",
    "165515": "  public Path getPath(File file) {\n    return new Path(Utils.getRelativePath(rootFile, file, \"/\"));\n  }\n",
    "165516": "  public ServletOutputStream createOutputStream() throws IOException {\n    return new CacheResponseStream(response, cacheOutput);\n  }\n",
    "165517": "  public void finishResponse() {\n    try {\n      if (writer != null) {\n        writer.close();\n      } else if (stream != null) {\n        stream.close();\n      }\n    } catch (IOException e) {}\n  }\n",
    "165519": "  public String getSiteAuthor() {\n    return siteAuthor;\n  }\n",
    "165523": "  public void setSiteAuthor(String siteAuthor) {\n    this.siteAuthor = siteAuthor;\n  }\n",
    "165530": "  public String getSiteName() {\n    return siteName;\n  }\n",
    "165532": "  public boolean store() {\n    return webSite.storeToXML(this, webSite.getPropertiesFilePath());\n  }\n",
    "165534": "  public String getPageTheme(Path pagePath) {\n    return Utils.noNull(data.getProperty(getThemeCode(pagePath)));\n  }\n",
    "165536": "  public void setSiteName(String siteName) {\n    this.siteName = siteName;\n  }\n",
    "165538": "  public void setPageTheme(Path pagePath, String theme) {\n    if (Utils.isNullOrEmpty(theme)) {\n      data.remove(getThemeCode(pagePath));\n    } else {\n      data.setProperty(getThemeCode(pagePath), theme);\n    }\n  }\n",
    "165541": "  public String getPageTitle(PageInfo pageInfo) {\n    String customTitle = getPageTitle(pageInfo.getPath());\n\n    if (Utils.isNullOrEmpty(customTitle)) {\n      customTitle = pageInfo.getTitle();\n    }\n\n    return customTitle;\n  }\n",
    "165543": "  public String getSiteAuthorURL() {\n    return siteAuthorURL;\n  }\n",
    "165545": "  public String getPageTitle(Path pagePath) {\n    return Utils.noNull(data.getProperty(getTitleCode(pagePath)));\n  }\n",
    "165547": "  public void setPageTitle(Path pagePath, String title) {\n    if (Utils.isNullOrEmpty(title)) {\n      data.remove(getTitleCode(pagePath));\n    } else {\n      data.setProperty(getTitleCode(pagePath), title);\n    }\n  }\n",
    "165548": "  public void setSiteAuthorURL(String siteAuthorURL) {\n    this.siteAuthorURL = siteAuthorURL;\n  }\n",
    "165551": "  public int getPageScore(Path pagePath) {\n    return Utils.parseInt(data.getProperty(getScoreCode(pagePath)), 0);\n  }\n",
    "165554": "  public boolean isHideExceptions() {\n    return hideExceptions;\n  }\n",
    "165555": "  public String getPageScoreAsString(Path pagePath) {\n    int score = getPageScore(pagePath);\n    return score == 0 ? \"\" : Integer.toString(score);\n  }\n",
    "165557": "  public void setPageScore(Path pagePath, String score) {\n    setPageScore(pagePath, Utils.parseInt(score, 0));\n  }\n",
    "165559": "  public void setHideExceptions(boolean hideExceptions) {\n    this.hideExceptions = hideExceptions;\n  }\n",
    "165561": "  public void setPageScore(Path pagePath, int score) {\n    if (score == 0) {\n      data.remove(getScoreCode(pagePath));\n    } else {\n      data.setProperty(getScoreCode(pagePath), Integer.toString(score));\n    }\n  }\n",
    "165562": "  public WebSite getWebSite(ServletRequest request) {\n    return multiSiteManager.getWebSite(request.getServerName());\n  }\n",
    "165564": "  public boolean getHideSubmenu(Path pagePath) {\n    return Utils.isTrue(data.getProperty(getHideSubmenuCode(pagePath)));\n  }\n",
    "165565": "  public VirtualWebSite getVirtualSite(String dirName) {\n    VirtualWebSite vws = (VirtualWebSite) virtualSitesMap.get(dirName);\n\n    if (vws == null) {\n      Path sitePath = virtualSitesPath.add(dirName);\n      File root = getFile(sitePath);\n      Path cms = new CMSDirectoryFinder(root, true).getCMSPath();\n      vws = VirtualWebSite.create(this, sitePath, cms);\n      virtualSitesMap.put(dirName, vws);\n    }\n\n    return vws;\n  }\n",
    "165566": "  public boolean isEditorModulesCollapsed() {\n    return editorModulesCollapsed;\n  }\n",
    "165567": "  public boolean isDirectory(Path path) {\n    return getFile(path).isDirectory();\n  }\n",
    "165568": "  public MultiSiteManager getMultiSiteManager() {\n    return multiSiteManager;\n  }\n",
    "165569": "  public String getHideSubmenuAsString(Path pagePath) {\n    boolean hide = getHideSubmenu(pagePath);\n    return hide == false ? \"\" : Boolean.toString(hide);\n  }\n",
    "165572": "  public void setHideSubmenu(Path pagePath, String hide) {\n    setHideSubmenu(pagePath, Utils.isTrue(hide));\n  }\n",
    "165573": "  public void setEditorModulesCollapsed(boolean editorModulesCollapsed) {\n    this.editorModulesCollapsed = editorModulesCollapsed;\n  }\n",
    "165577": "  public void setHideSubmenu(Path pagePath, boolean hide) {\n    if (hide == false) {\n      data.remove(getHideSubmenuCode(pagePath));\n    } else {\n      data.setProperty(getHideSubmenuCode(pagePath), Boolean.toString(hide));\n    }\n  }\n",
    "165581": "  public Path getDirectory(Path path) {\n    // PageInfo pageInfo = getPageInfo(path);\n    // return pageInfo.isDirectory() ? path : pageInfo.getPath().getParent();\n    if (path == null) {\n      return null;\n    }\n\n    if (getFile(path).isDirectory()) {\n      return path;\n    }\n\n    path = path.getParent();\n\n    if (!path.isRelative() && getFile(path).isDirectory()) {\n      return path;\n    }\n\n    return null;\n  }\n",
    "165592": "  public Path getThemeRoot(Path pagePath) {\n    do {\n      String theme = getPageTheme(pagePath);\n\n      if (!Utils.isNullOrEmpty(theme)) {\n        if (webSite.getSiteMap().getThemesMap().get(theme) != null) {\n          return pagePath;\n        }\n      }\n\n      pagePath = pagePath.getParent();\n    } while (!pagePath.isRelative());\n\n    return null;\n  }\n",
    "165678": "  public Path getModulePath(String moduleName) {\n    if (moduleName.endsWith(\".jsp\")) {\n      // old module names were in the form module_name.jsp\n      moduleName = moduleName.substring(0, moduleName.length() - 4);\n    }\n\n    return (Path) siteMap.getModulesMap().get(moduleName);\n  }\n",
    "165689": "  public Path getAdminPath() {\n    return adminPath;\n  }\n",
    "165735": "  public String getAdminMetaThemeTag() {\n    Path themePath = getThemePath(adminPath);\n    return \"<meta name=\\\"decorator\\\" content=\\\"/\" + getServedPath(themePath) +\n        \"/\" + SiteMap.THEME_DECORATOR + \"\\\" />\";\n  }\n",
    "165772": "  public String getHTMLTemplate(String pageTitle) throws IOException {\n    String text = Utils.readFully(getFile(getAdminPath().add(\"template.html\")));\n\n    if (pageTitle != null) {\n      int idx = text.indexOf(\"New Page\");\n\n      if (idx >= 0) {\n        text = text.substring(0, idx) + pageTitle + text.substring(idx + 8);\n      }\n    }\n\n    return text;\n  }\n",
    "165811": "  protected void log(String s) {\n    sc.log(s);\n  }\n",
    "165823": "  public void log(String message, Throwable throwable) {\n    sc.log(message, throwable);\n  }\n",
    "165835": "  public boolean isWelcomeFileName(String fileName) {\n    return Utils.searchString(welcomeFiles, fileName, false) != -1;\n  }\n",
    "165849": "  public Path findCurrentWelcome(Path dirPath) {\n    File dirFile = getFile(dirPath);\n\n    if (dirFile.isDirectory()) {\n      for (int i = 0; i < welcomeFiles.length; i++) {\n        Path wPath = dirPath.add(welcomeFiles[i]);\n\n        if (getFile(wPath).exists()) {\n          return wPath;\n        }\n      }\n    }\n\n    return null;\n  }\n",
    "165921": "\tpublic Path checkAndCreate(Path imagePath) {\n\t\tWebSite webSite = RequestContext.get().getWebSite();\n\t\tFile imageFile = webSite.getFile(imagePath);\n\n\t\tif (imageFile == null || !imageFile.exists() || imageFile.isDirectory()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tPath thumbnailPath = webSite.getRepositoryPath(imagePath)\n\t\t\t\t\t.add(getClass().getName(), getFileName());\n\t\tFile thumbnailFile = webSite.getFile(thumbnailPath);\n\n\t\tif (!thumbnailFile.exists()\n\t\t\t\t\t|| thumbnailFile.lastModified() < imageFile.lastModified()) {\n\t\t\tthumbnailFile.getParentFile().mkdirs();\n\n\t\t\tif (!createThumbnail(imageFile, thumbnailFile)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn thumbnailPath;\n\t}\n",
    "166003": "  public Path getThemePath(Path pagePath) {\n    Path themePath = siteInfo.getThemePath(pagePath);\n\n    if (pagePath.isContainedIn(adminPath)) {\n      if (configuration.isUseAdminTheme() || themePath == null ||\n          System.currentTimeMillis() - lastAdminThemeBlock < 300000L || // 5 minutes\n          !getFile(themePath.add(SiteMap.THEME_DECORATOR)).exists()) {\n        themePath = adminThemePath;\n      }\n    }\n\n    return themePath;\n  }\n",
    "166048": "\tpublic boolean copyFile(Path oldPath, Path newPath) {\n\t\tFile oldFile = getFile(oldPath);\n\n\t\tif (!oldFile.exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tFile newFile = getFile(newPath);\n\n\t\tif (oldFile.isDirectory()) {\n\t\t\treturn IO.copyDirectory(oldFile, newFile, false, false, false);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\treturn IO.copyFile(oldFile, newFile, false, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tContext.log(\"Can't copy file \" + oldFile + \" to file \" + newFile, ex);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "166050": "\tpublic boolean copyFile(Path filePath, String newName) {\n\t\treturn copyFile(filePath, filePath.getParent().add(newName));\n\t}\n",
    "166051": "\tpublic Path getCurrentWelcome(Path dirPath) {\n\t\treturn currentWelcomes.get(dirPath);\n\t}\n",
    "166052": "\tpublic boolean createDirectory(Path dirPath) {\n\t\tFile newDir = getFile(dirPath);\n\n\t\tif (newDir.exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn newDir.mkdirs();\n\t}\n",
    "166056": "\tpublic boolean createFile(Path filePath) {\n\t\tFile newFile = getFile(filePath);\n\n\t\tif (!newFile.exists()) {\n\t\t\ttry {\n\t\t\t\tif (Server.get().isPage(filePath.getLastElement())) {\n\t\t\t\t\twriteNewHTMLFile(filePath, \"\");\n\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn newFile.createNewFile();\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tContext.log(\"Can't create file \" + newFile, ex);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "166059": "\tpublic boolean delete(Path filePath, boolean deleteNonEmptyDirectories) {\n\t\t// TODO: avoid deletion of required CMS items\n\t\tFile file = getFile(filePath);\n\n\t\tif (!file.exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (file.isDirectory() && deleteNonEmptyDirectories) {\n\t\t\tDirectoryRemover dr = new DirectoryRemover(file);\n\t\t\tdr.process();\n\n\t\t\treturn dr.getResult();\n\t\t} else {\n\t\t\treturn file.delete();\n\t\t}\n\t}\n",
    "166060": "\tpublic PageInfo getPageInfo(Path path) {\n\t\treturn pageMap.get(getPathInMenu(path));\n\t}\n",
    "166061": "\tpublic Path findCurrentWelcome(Path dirPath) {\n\t\tif (isDirectory(dirPath)) {\n\t\t\tfor (String welcomeFile : Server.get().getWelcomeFiles()) {\n\t\t\t\tPath wPath = dirPath.add(welcomeFile);\n\n\t\t\t\tif (getFile(wPath).exists()) {\n\t\t\t\t\treturn wPath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "166071": "\tpublic SiteConfiguration getSiteConfiguration() {\n\t\treturn siteConfiguration;\n\t}\n",
    "166077": "\tpublic Path getDirectory(Path path) {\n\t\tif (path == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isDirectory(path)) {\n\t\t\treturn path;\n\t\t}\n\n\t\tpath = path.getParent();\n\n\t\tif (isDirectory(path)) {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "166080": "\tpublic File getFile(Path path) {\n\t\tif (path == null || path.isRelative()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (type != WebSiteType.MAIN) {\n\t\t\tServer server = Server.get();\n\n\t\t\tif (path.isContainedIn(Context.MESHCMS_PATH)\n\t\t\t\t\t\t|| path.isContainedIn(server.getCMSServerPath())) {\n\t\t\t\treturn server.getMainWebSite().getFile(path);\n\t\t\t}\n\t\t}\n\n\t\treturn new File(rootFile, path.toString());\n\t}\n",
    "166106": "\tpublic Path getThemeRoot(Path pagePath) {\n\t\tPersistentPageData pageData = webSite.getPersistentPageData();\n\n\t\tdo {\n\t\t\tString themeName = pageData.getTheme(pagePath);\n\n\t\t\tif (!Strings.isNullOrEmpty(themeName)\n\t\t\t\t\t\t&& siteInfo.getThemes().get(themeName) != null) {\n\t\t\t\treturn pagePath;\n\t\t\t}\n\n\t\t\tpagePath = pagePath.getParent();\n\t\t} while (!pagePath.isRelative());\n\n\t\treturn null;\n\t}\n",
    "166110": "\tpublic boolean isDirectory(Path path) {\n\t\tFile file = getFile(path);\n\n\t\treturn file != null && file.isDirectory();\n\t}\n",
    "166113": "\tpublic boolean move(Path oldPath, Path newPath) {\n\t\tFile oldFile = getFile(oldPath);\n\n\t\tif (!oldFile.exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (newPath.isContainedIn(oldPath)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tFile newFile = getFile(newPath);\n\n\t\tif (IO.forceRenameTo(oldFile, newFile, false)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tContext.log(\"Can't move file \" + oldFile + \" to file \" + newFile);\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "166124": "\tpublic void updateSiteMap(boolean force) {\n\t\tif (isCMSEnabled()) {\n\t\t\tif (force) {\n\t\t\t\tnew SiteMap(this).process();\n\t\t\t} else if (System.currentTimeMillis() - siteMap.getLastModified() > siteConfiguration\n\t\t\t\t\t\t.getUpdateIntervalMillis()) {\n\t\t\t\tnew SiteMap(this).process();\n\n\t\t\t\t// TODO: restore cleaning\n\t\t\t\t//\t\t\tnew DirectoryCleaner(getFile(repositoryPath),\n\t\t\t\t//\t\t\t\tconfiguration.getBackupLifeMillis()).start();\n\t\t\t\t//\t\t\tnew DirectoryCleaner(getFile(generatedFilesPath),\n\t\t\t\t//\t\t\t\tconfiguration.getBackupLifeMillis()).start();\n\t\t\t\t//\t\t\tnew DirectoryCleaner(getFile(moduleDataPath)).start();\n\t\t\t}\n\t\t}\n\t}\n",
    "166143": "\tpublic boolean isHidden(Path path, boolean deepCheck) {\n\t\tif (deepCheck) {\n\t\t\tfor (CMSDirectoryItem hiddenItem : hiddenCMSDirectoryItems) {\n\t\t\t\tif (path.isContainedIn(hiddenItem.getPath())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (CMSDirectoryItem hiddenItem : hiddenCMSDirectoryItems) {\n\t\t\t\tif (path.equals(hiddenItem.getPath())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "166154": "\tpublic boolean isSystem(Path path) {\n\t\tif (path.isRoot()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (path.isContainedIn(Context.MESHCMS_PATH)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString first = path.getElementAt(0);\n\n\t\treturn \"web-inf\".equalsIgnoreCase(first)\n\t\t\t\t|| \"meta-inf\".equalsIgnoreCase(first);\n\t}\n",
    "166225": "\tpublic boolean isWelcomeFileName(String fileName) {\n\t\treturn Strings.searchString(welcomeFiles, fileName, false) != -1;\n\t}\n",
    "166316": "\tpublic int compare(Locale l1, Locale l2) {\n\t\ttry {\n\t\t\tif (locale == null) {\n\t\t\t\treturn l1.getDisplayName().compareTo(l2.getDisplayName());\n\t\t\t} else {\n\t\t\t\treturn l1.getDisplayName(locale).compareTo(l2.getDisplayName(locale));\n\t\t\t}\n\t\t} catch (Exception ex) {}\n\n\t\treturn 0;\n\t}\n",
    "166358": "\tpublic void setSorted(boolean sorted) {\n\t\tcomparator = sorted ? new FileNameComparator() : null;\n\t}\n",
    "166431": "\tpublic long getUpdateIntervalMillis() {\n\t\treturn updateInterval * (long) Time.HOUR;\n\t}\n",
    "166454": "\tpublic String getLabel() {\n\t\treturn name == null ? getPath().getLastElement()\n\t\t: MeshCMS.getDynamicTranslation(\"filesystem_\", name);\n\t}\n",
    "166508": "\tpublic String getMenuTitle() {\n\t\tString menuTitle = pageConfiguration.getShortTitle();\n\n\t\tif (Strings.isNullOrEmpty(menuTitle)) {\n\t\t\tmenuTitle = title;\n\t\t}\n\n\t\treturn menuTitle;\n\t}\n",
    "166586": "\tpublic long getBackupLifeMillis() {\n\t\treturn backupLife * (long) Time.DAY;\n\t}\n",
    "167141": "\tprotected void onEvent(T event) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"This object does not know how to handle the event.\");\n\t}\n",
    "167144": "\tprotected void answer(T1 question) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"This object does not know how to answer.\");\n\t}\n",
    "167146": "\tprotected void onAnswer(T2 answer) {\n\t\tthrow new UnsupportedOperationException(\n\t\t\t\"This object does not know how to handle answers.\");\n\t}\n",
    "167163": "\tpublic Path add(String... pathItems) {\n\t\tString[] items = new String[elements.length + pathItems.length];\n\t\tSystem.arraycopy(elements, 0, items, 0, elements.length);\n\t\tSystem.arraycopy(pathItems, 0, items, elements.length, pathItems.length);\n\n\t\treturn new Path(items);\n\t}\n",
    "167182": "\tprivate void checkCapacity() {\n\t\twhile (MAX_WAITING < (requested - collector.getCollected())) {\n\t\t\ttry {\n\t\t\t\tsynchronized (id) {\n\t\t\t\t\tid.wait();\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tthrow new RuntimeException(\"Error waiting calculation.\", e);\n\t\t\t}\n\t\t} \n\t}\n",
    "167183": "\tpublic String getServiceURL() throws IOException {\n\t\tNode serviceURL = NodeHandler.getSingleNode(protocol, \"//service/@URL\");\n\t\tif (serviceURL == null) {\n\t\t\tthrow new IOException(\"Tagname service was not found in protocol.\");\n\t\t}\n\t\treturn serviceURL.getNodeValue().toString();\n\t}\n",
    "167184": "\tprotected void prepare() {\n\t\tsuper.prepare();\n\t\tnumKeys = Integer.parseInt(parameters.getValueString());\n\t\tnumEvals = targets_.size() - numKeys;\n\t\tif (paramPrefix != null)\n\t\t\tnumPPrefix = Integer.parseInt(paramPrefix.getValueString());\n\t\tif (evalPrefix != null)\n\t\t\tnumEPrefix = Integer.parseInt(evalPrefix.getValueString());\n\t}\n",
    "167188": "\tprotected void MakeLabelLine() {\n\t\txYSeriesCollection.removeAllSeries();\n\t\tIterator item = targets_.iterator();\n\t\tParameter p;\n\t\twhile (item.hasNext()) {\n\t\t\tp = (Parameter) item.next();\n\t\t\txYSeriesCollection.addSeries(new XYSeries(p.getShortName()));\n\t\t}\n\t}\n",
    "167189": "\tprotected void MakeValueLine() {\n\t\tfor (int i = 0; i < targets_.size(); i++) {\n\t\t\tdouble p = ((Parameter)targets_.get(i)).getValue();\n\t\t\txYSeriesCollection.getSeries(i).add(elapsedTime.getValue(), p);\n\t\t}\n\t}\n",
    "167199": "\tpublic void testGetServiceURL1() {\n\t\ttry {\n\t\t\tassertEquals(\"Error in ServiceURL\", \"jini://10.238.63.40\", jsProtocolParserProtocol.getServiceURL());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "167200": "\tpublic Path getParent() {\n\t\treturn new Path(toString(), \"..\");\n\t}\n",
    "167203": "\tpublic void testGetServiceURL2() {\n\t\ttry {\n\t\t\tassertNull(\"Error in ServiceURL, should not exist in the model\", jsProtocolParserModel.getServiceURL());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n\t}\n",
    "167204": "\tpublic void testGetCodeBases1() {\n\t\tString[] URLset = jsProtocolParserProtocol.getCodeBases();\n\t\tassertEquals(\"Error in CodeBase\", \"http://10.238.63.14:8083/JavaSpacesClient/lib/simBio_JavaSpacesClient-1.0.jar\", URLset[0]);\n\t\tassertEquals(\"Error in CodeBase\", \"http://10.238.63.14:8083/NoNCX/target/classes/\", URLset[1]);\n\t}\n",
    "167205": "\tpublic void testGetWaitingNum() throws InterruptedException, IOException {\n\t\tInputStream protocolXML = new FileInputStream(PROTOCOL_XML);\n\t\tJSProtocolParser protocol = new JSProtocolParser(protocolXML);\n\t\tString modelName = protocol.getBaseModel();\n\t\tJSEntry js = new JSEntry(ID, protocol);\n\n\t\tThread resultTaker = new Thread(js);\n\t\tresultTaker.start();\n\t\tjs.send(new FileInputStream(modelName),new FileInputStream(PROTOCOL_XML));\n\t\t\n\t\tresultTaker.join();\n\t}\n",
    "167206": "\tpublic void testGetCodeBases2() {\n\t\tString[] URLset = jsProtocolParserModel.getCodeBases();\n\t\tassertTrue(\"Error in CodeBase, should not exist in the model\", URLset.length == 0);\n\t}\n",
    "167208": "\tpublic void testPlot() throws FileNotFoundException, InterruptedException {\n\t\tJSEntry.main( new String[] { ID, PROTOCOL_XML } );\n\t}\n",
    "167209": "    protected void setUp() throws FileNotFoundException { \n    \tjsProtocolParserProtocol = new JSProtocolParser(new FileInputStream(\"src/test/resources/org/simBio/sim/js/3A_NCXvsCaLStub.xml\"));\n    \tjsProtocolParserModel = new JSProtocolParser(new FileInputStream(\"../simBio/src/xml/matsuoka_et_al_2003/model.xml\"));\n    }\n",
    "167210": "\tprivate void read(String filename) {\n\t\tsynchronized (obj) {\n\t\t\tResourceBundle resource = ResourceBundle.getBundle(filename, Locale\n\t\t\t\t\t.getDefault());\n\t\t\tEnumeration itr = resource.getKeys();\n\t\t\twhile (itr.hasMoreElements()) {\n\t\t\t\tString key_ = (String) itr.nextElement();\n\t\t\t\tproperties.put(key_, resource.getString(key_));\n\t\t\t}\n\t\t}\n\t}\n",
    "167211": "\tpublic void testExecute() throws IOException, InterruptedException {\n\t\t\n\t\tProtocolParser protocol = new ProtocolParser(new FileInputStream(PROTOCOL_XML));\n\t\tString modelName = protocol.getBaseModel();\n\t\t\n\t\tString tocString = JSEntry.execute(ID, DOMHandler.parseXML(new FileInputStream(modelName)),\n\t\t\t\t\t\t\t\t\t\t\tDOMHandler.parseXML(new FileInputStream(PROTOCOL_XML)));\n\t\t\n\t\tFile tocFile = new File(tocString);\n\t\tassertTrue(\"Table Of Contents file '\" + tocString + \"' does not exist.\", tocFile.isFile());\n\t}\n",
    "167213": "\tpublic HashMap getProperties(Class c) {\n\t\tsynchronized (obj) {\n\t\t\tString prefix = c.getName() + \".\";\n\t\t\tEnumeration itr = properties.keys();\n\t\t\tHashMap map = new HashMap();\n\t\t\twhile (itr.hasMoreElements()) {\n\t\t\t\tString key_ = (String) itr.nextElement();\n\t\t\t\tif (key_.startsWith(prefix)) {\n\t\t\t\t\tmap.put(key_.substring(prefix.length()), properties\n\t\t\t\t\t\t\t.get(key_));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map.size() == 0)\n\t\t\t\treturn null;\n\t\t\treturn map;\n\t\t}\n\n\t}\n",
    "167214": "\tpublic Path getRelativeTo(Path rootPath) {\n\t\tint i0 = 0;\n\t\tint i1 = 0;\n\t\tList<String> list = new ArrayList<String>();\n\n\t\twhile (i0 < rootPath.getElementCount()\n\t\t\t\t\t&& i1 < elements.length\n\t\t\t\t\t&& rootPath.getElementAt(i0).equals(elements[i1])) {\n\t\t\ti0++;\n\t\t\ti1++;\n\t\t}\n\n\t\twhile (i0++ < rootPath.getElementCount()) {\n\t\t\tlist.add(\"..\");\n\t\t}\n\n\t\twhile (i1 <= elements.length - 1) {\n\t\t\tlist.add(elements[i1++]);\n\t\t}\n\n\t\treturn new Path(list.toArray(new String[list.size()]));\n\t}\n",
    "167216": "\tpublic boolean getBooleanProperty(Class c, String name) {\n\t\tsynchronized (obj) {\n\t\t\tString key_ = c.getName() + \".\" + name;\n\t\t\treturn (new Boolean(getProperty(key_))).booleanValue();\n\t\t}\n\t}\n",
    "167232": "\tpublic void calculated() {\n\t\tsynchronized (processing) {\n\t\t\tprocessing.notifyAll();\n\t\t\tprocessing = new Integer(processing.intValue() - 1);\n\t\t\tlog.debug(\"The number of active threads is \" + processing);\n\t\t}\n\t}\n",
    "167235": "\tpublic URLClassLoader getClassLoader() {\n\t\tif (loader == null) {\n\t\t\tURLClassLoader cl = (URLClassLoader) this.getClass().getClassLoader();\n\t\t\tlogCodeBases(cl, \"Original codebases are;\");\n\t\t\tloader = URLClassLoader.newInstance(codebases, cl);\n\t\t\tlogCodeBases(loader, \"Codebases are added as;\");\n\t\t}\n\t\treturn loader;\n\t}\n",
    "167249": "\tprotected void setUp() throws Exception {\n\t\tproperty = PropertyManager.getInstance();\n\t\tsuper.setUp();\n\t}\n",
    "167250": "\tpublic void testGetProperties() {\n\t\tHashMap m;\n\t\t\n\t\tm = property.getProperties(ServiceLocator.class);\n\t\tassertEquals(\"Error in testString\", \"for_test_only\", m.get(\"testString\"));\n\t\tassertEquals(\"Error in testURL\", \"jini://10.238.63.40\", m.get(\"testURL\"));\n\t\t\n\t\tm = property.getProperties(Worker.class);\n\t\tassertEquals(\"Error in testTrue\", \"true\", m.get(\"testTrue\"));\n\t\tassertEquals(\"Error in testFalse\", \"false\", m.get(\"testFalse\"));\n\t}\n",
    "167251": "\tpublic void testGetPropertyClassString() {\n\t\tString str = property.getProperty(ServiceLocator.class, \"testString\");\n\t\tassertEquals(\"Error in testString\", \"for_test_only\", str);\n\t}\n",
    "167253": "\tpublic void testGetBooleanProperty() {\n\t\tboolean bln; \n\t\t\n\t\tbln = property.getBooleanProperty(Worker.class, \"testTrue\");\n\t\tassertTrue(\"Error in testTrue\", bln);\n\t\t\n\t\tbln = property.getBooleanProperty(Worker.class, \"testFalse\");\n\t\tassertFalse(\"Error in testFalse\", bln);\n\t}\n",
    "167254": "\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tspace = SpaceLocator.getSpace();\n\t}\n",
    "167255": "\tpublic void testGetPropertyString() {\n\t\tString str = property.getProperty(\"org.simBio.sim.js.jini.ServiceLocator.testString\");\n\t\tassertEquals(\"Error in testString\", \"for_test_only\", str);\n\t}\n",
    "167256": "\tpublic void testGetURLs() throws MalformedURLException {\n\t\tfinal URL[] codebases = new URL[] {\n\t\t\t\tnew URL(\n\t\t\t\t\t\t\"http://192.168.0.194:8081/simBio_private/target/simBio_private-0.3.02.jar\"),\n\t\t\t\tnew URL(\n\t\t\t\t\t\t\"http://localhost:8081/simBio_private/target/simBio_private-0.3.02.jar\") };\n\n\t\tRequest request = new Request(null, null, null, null, null, codebases);\n\n\t\tassertNotNull(request);\n\t\tassertEquals(codebases[0], request.getClassLoader().getURLs()[0]);\n\t\tassertEquals(codebases[1], request.getClassLoader().getURLs()[1]);\n\t}\n",
    "167259": "\tpublic void testCreate() {\n\t\tString channel = getName();\n\t\tIndex index = Channel.removeHead(space, channel, timeout);\n\t\tassertNull(\"create channel first.\", index);\n\t\t\n\t\tChannel.create(space, channel);\n\t\t\n\t\tindex = Channel.removeHead(space, channel, timeout);\n\t\tassertEquals(\"head\", index.type);\n\t\tindex = Channel.removeTail(space, channel, timeout);\n\t\tassertEquals(\"tail\", index.type);\n\n\t\tChannel.dispose(space, channel);\n\t}\n",
    "167263": "\tpublic void testDispose() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tChannel.create(space, channel);\n\n\t\tChannel.dispose(space, channel);\n\t\tIndex index = Channel.removeHead(space, channel, timeout);\n\t\tassertNull(\"channel has been disposed.\", index);\n\t\tindex = Channel.removeTail(space, channel, timeout);\n\t\tassertNull(\"channel has been disposed.\", index);\n\t}\n",
    "167264": "\tpublic void characters(char[] ch, int start, int length) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"\u30c6\u30ad\u30b9\u30c8=\\\"\" + (new String(ch, start, length)) + \"\\\"\");\n\t}\n",
    "167265": "\tpublic void testRemoveHead() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tChannel.create(space, channel);\n\t\t\n\t\tIndex index = Channel.removeHead(space, \"not a \" + channel, timeout);\n\t\tassertNull(\"different head.\", index);\n\t\tindex = Channel.removeHead(space, channel, timeout);\n\t\tassertEquals(\"head\", index.type);\n\t\tindex = Channel.removeHead(space, channel, timeout);\n\t\tassertNull(\"head has been taken.\", index);\n\n\t\tChannel.dispose(space, channel);\n\t}\n",
    "167266": "\tpublic Path successor() {\n\t\treturn elements.length == 0 ? new Path(\"\\u0000\")\n\t\t: getParent().add(getLastElement() + '\\u0000');\n\t}\n",
    "167268": "\tpublic void comment(char[] ch, int start, int length) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"comment=\\\"\" + (new String(ch, start, length)) + \"\\\"\");\n\t}\n",
    "167269": "\tpublic void testRemoveTail() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tChannel.create(space, channel);\n\t\t\n\t\tIndex index = Channel.removeTail(space, \"not a \" + channel, timeout);\n\t\tassertNull(\"different tail.\", index);\n\t\tindex = Channel.removeTail(space, channel, timeout);\n\t\tassertEquals(\"tail\", index.type);\n\t\tindex = Channel.removeTail(space, channel, timeout);\n\t\tassertNull(\"tail has been taken.\", index);\n\n\t\tChannel.dispose(space, channel);\n\t}\n",
    "167270": "\tpublic void endDocument() throws SAXException {\n\t\tif (log.isInfoEnabled())\n\t\t\tlog.info(\"parsed\");\n\t}\n",
    "167272": "\tpublic void testReadHead() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tChannel.create(space, channel);\n\t\t\n\t\tIndex index = Channel.readHead(space, \"not a \" + channel, timeout);\n\t\tassertNull(\"different head.\", index);\n\t\tindex = Channel.readHead(space, channel, timeout);\n\t\tassertEquals(\"head\", index.type);\n\t\tindex = Channel.readHead(space, channel, timeout);\n\t\tassertNotNull(\"head has not been taken.\", index);\n\n\t\tChannel.dispose(space, channel);\n\t}\n",
    "167274": "\tpublic void endElement(String uri, String localName, String qName) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"\u7d42\u4e86\u30bf\u30b0=\" + qName + \", uri=\" + uri + \", localName=\" + localName);\n\t}\n",
    "167275": "\tpublic void testReadTail() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tChannel.create(space, channel);\n\t\t\n\t\tIndex index = Channel.readTail(space, \"not a \" + channel, timeout);\n\t\tassertNull(\"different tail.\", index);\n\t\tindex = Channel.readTail(space, channel, timeout);\n\t\tassertEquals(\"tail\", index.type);\n\t\tindex = Channel.readTail(space, channel, timeout);\n\t\tassertNotNull(\"tail has not been taken.\", index);\n\n\t\tChannel.dispose(space, channel);\n\t}\n",
    "167277": "\tpublic void ignorableWhitespace(char[] ch, int start, int length) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"White space=\\\"\" + (new String(ch, start, length)) + \"\\\"\");\n\t}\n",
    "167279": "\tpublic void testGetRequestNumber() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tChannel.create(space, channel);\n\t\tassertEquals(\"head is\", 1, Channel.readHead(space, channel, timeout).position.intValue());\n\t\tassertEquals(\"tail is\", 0, Channel.readTail(space, channel, timeout).position.intValue());\n\t\tInteger num = Channel.getRequestNumber(space, channel, 0);\n\t\tassertEquals(\"no request\", 1, num.intValue());\n\t\tassertEquals(\"head is\", 1, Channel.removeHead(space, channel, timeout).position.intValue());\n\t\tassertEquals(\"tail is\", 1, Channel.removeTail(space, channel, timeout).position.intValue());\n\t\tChannel.dispose(space, channel);\n\t}\n",
    "167280": "\tpublic void characters(char[] ch, int start, int length) {\n\t\txml.append(ch, start, length);\n\t\tsuper.characters(ch, start, length);\n\t}\n",
    "167283": "\tpublic void comment(char[] ch, int start, int length) throws SAXException {\n\t\txml.append(\"<!--\");\n\t\txml.append(ch, start, length);\n\t\txml.append(\"-->\");\n\t\tsuper.comment(ch, start, length);\n\t}\n",
    "167284": "\tpublic void testIsExist() {\n\t\tString channel = getName();\n\t\tChannel.dispose(space, channel);\n\t\tassertFalse(\"Not yet created.\", Channel.isExist(space, channel, timeout));\n\t\tChannel.create(space, channel);\n\t\tassertTrue(\"Created.\", Channel.isExist(space, channel, timeout));\n\t\tChannel.create(space, channel);\n\t\tassertTrue(\"Created.\", Channel.isExist(space, channel, timeout));\n\t\tChannel.removeTail(space, channel, timeout);\n\t\tassertFalse(\"No tail.\", Channel.isExist(space, channel, timeout));\n\t\tChannel.create(space, channel);\n\t\tassertTrue(\"Created.\", Channel.isExist(space, channel, timeout));\n\t\tChannel.dispose(space, channel);\n\t\tassertFalse(\"disposed.\", Channel.isExist(space, channel, timeout));\n\t}\n",
    "167285": "\tpublic void processingInstruction(String target, String data) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"ProcessingInstruction: \" + \"target=\" + target + \", component=\" + data);\n\t}\n",
    "167287": "\tpublic void endDocument() throws SAXException {\n\t\tif (0 != initialValues.size())\n\t\t\t// xml\u306b\u542b\u307e\u308c\u308bComponent\u306e\u6570\u304cmodel tree\u304b\u3089\u62fe\u3063\u3066\u304d\u305f\u6570\u3068\u4e00\u81f4\u3057\u306a\u3044\u3002\n\t\t\tthrow new SAXException(\"The number of the Nodes in the model and the xml are not match by \"\n\t\t\t\t\t+ initialValues.size());\n\t\ttry {\n\t\t\twriter.write(xml.toString());\n\t\t\twriter.close();\n\t\t\tlog.info(\"updated\");\n\t\t} catch (IOException e) {\n\t\t\tlog.error(e);\n\t\t\tthrow new SAXException(e);\n\t\t}\n\t}\n",
    "167290": "\tpublic void setDocumentLocator(Locator locator) {\n\t\tif (log.isDebugEnabled()) {\n\t\t\tif (locator instanceof Locator2) {\n\t\t\t\tLocator2 loc = (Locator2) locator;\n\t\t\t\tlog.debug(\"setDocumentLocator: \" + \"locator=\" + loc + \", encoding=\" + loc.getEncoding()\n\t\t\t\t\t\t+ \", XML Version=\" + loc.getXMLVersion() + \", PublicId=\" + loc.getPublicId() + \", SystemId=\"\n\t\t\t\t\t\t+ loc.getSystemId());\n\t\t\t} else {\n\t\t\t\tlog.debug(\"setDocumentLocator: \" + \"locator=\" + locator + \", PublicId=\" + locator.getPublicId()\n\t\t\t\t\t\t+ \", SystemId=\" + locator.getSystemId());\n\t\t\t}\n\t\t}\n\t}\n",
    "167291": "\tpublic void visit(Component component) {\n\t\tencodeOneLine(component);\n\t}\n",
    "167293": "\tpublic void ignorableWhitespace(char[] ch, int start, int length) {\n\t\txml.append(ch, start, length);\n\t\tsuper.ignorableWhitespace(ch, start, length);\n\t}\n",
    "167294": "\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n\t\tif (log.isDebugEnabled()) {\n\t\t\tString s = toOneLine(qName, attributes);\n\t\t\tlog.debug(s);\n\t\t}\n\t}\n",
    "167295": "\tpublic void visit(Composite composite) {\n\t\tencodeStart(composite);\n\n\t\tIterator item = composite.getNodesIterator();\n\t\twhile (item.hasNext())\n\t\t\t((Component) item.next()).accept(this);\n\n\t\tencodeEnd(composite);\n\t}\n",
    "167298": "\tpublic void startDocument() {\n\t\tlog.info(\"start parcing\");\n\t}\n",
    "167299": "\tprivate void encodeOneLine(Component component) {\n\t\tencodeNameValue(component);\n\t\txml.append(\" \" + TAG_END + TAG_GTLF);\n\t}\n",
    "167302": "\tprivate void encodeStart(Component component) {\n\t\tencodeNameValue(component);\n\t\txml.append(TAG_GTLF);\n\t}\n",
    "167305": "\tpublic void write(Component component) throws IOException {\n\t\tif (source != null) {\n\t\t\tnew Encoder(component, this, new BufferedWriter(\n\t\t\t\t\tnew FileWriter(FileHandler.getNewFile(source.getSystemId()))));\n\t\t\twriteTable.clear();\n\t\t}\n\t}\n",
    "167306": "\tprivate void encodeNameValue(Component component) {\n\t\txml.append(component.getIndent() + TAG_LT + coder.getTag(component));\n\t\tencodeAttribute(Initializer.NAME, component.getShortName());\n\t\tString v = component.getValueString();\n\t\tif ((v != null) && (0 < v.length()))\n\t\t\tencodeAttribute(Initializer.INITIAL_VALUE, v);\n\t\tv = component.getUnits();\n\t\tif ((v != null) && (0 < v.length()))\n\t\t\tencodeAttribute(Initializer.UNITS, v);\n\t\tv = coder.getClassName(component);\n\t\tif (v != null)\n\t\t\tencodeAttribute(Initializer.CLASS_NAME, v);\n\t}\n",
    "167307": "\tpublic void attributeDecl(String eName, String aName, String type, String mode, String value) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"attributeDecl: \" + \"eName=\" + eName + \", aName=\" + aName + \", type=\" + type + \", mode=\" + mode\n\t\t\t\t\t+ \", value=\" + value);\n\t}\n",
    "167309": "\tprivate void encodeAttribute(String name, String value) {\n\t\txml.append(\" \" + name + \"=\" + TAG_QUOTE + value + TAG_QUOTE);\n\t}\n",
    "167310": "\tpublic void write(Component component, String uri) throws IOException {\n\t\tsource = new InputSource(uri);\n\t\twrite(component);\n\t}\n",
    "167313": "\tprivate void encodeEnd(Component component) {\n\t\txml.append(component.getIndent() + TAG_LTEND + coder.getTag(component) + TAG_GTLF);\n\t}\n",
    "167314": "\tpublic void endCDATA() throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"endCDATA\");\n\t}\n",
    "167316": "\tpublic Component read() throws InstantiationException {\n\t\tParser saxHandler = new Parser(this);\n\t\ttry {\n\t\t\tSAXParser saxParser = SAXParserFactory.newInstance().newSAXParser();\n\t\t\tsaxParser.parse(source, saxHandler);\n\t\t} catch (IOException e) {\n\t\t\tInstantiationException ne = new InstantiationException();\n\t\t\tne.initCause(e);\n\t\t\tthrow ne;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tInstantiationException ne = new InstantiationException();\n\t\t\tne.initCause(e);\n\t\t\tthrow ne;\n\t\t} catch (SAXException e) {\n\t\t\tInstantiationException ne = new InstantiationException();\n\t\t\tne.initCause(e);\n\t\t\tthrow ne;\n\t\t}\n\t\tread = saxHandler.getRoot();\n\t\treturn read;\n\t}\n",
    "167317": "\tstatic public Composite start(Serializer serializer, String id, Reader reference) {\n\t\ttry {\n\t\t\t// model instance\u3092\u4f5c\u6210\u3002\n\t\t\tConductor model = (Conductor) serializer.read();\n\t\t\tmodel.addCalculationObserver(new Saver(model, serializer, reference));\n\t\t\tmodel.addCalculationObserver(new Counter(id));\n\t\t\tThread thread = new Thread(model);\n\t\t\t// \u8a08\u7b97\u3092\u76f4\u3050\u306b\u958b\u59cb\u3057\u3001\u8a08\u7b97\u7d42\u4e86\u5f8cThread\u3092\u7d42\u4e86\u3059\u308b\u3088\u3046flag\u3092\u30bb\u30c3\u30c8\u3059\u308b\u3002\n\t\t\tmodel.start();\n\t\t\tmodel.exit();\n\t\t\t// model thread\u3092\u958b\u59cb\u3002\n\t\t\tthread.start();\n\t\t\tnum = new Integer(num.intValue() + 1);\n\t\t\treturn model;\n\t\t} catch (InstantiationException e) {\n\t\t\tthrow new RuntimeException(\"Error instantiating a model from the xml.\", e);\n\t\t}\n\t}\n",
    "167318": "    public String toString(Tag tag) {\n        return \"\";\n    }\n",
    "167320": "    public String toString(Tag tag) {\n        return tag.text();\n    }\n",
    "167322": "\tpublic void endDTD() throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"endDTD\");\n\t}\n",
    "167326": "\tprivate void register(String tag, String className) {\n\t\tclassNameTable.put(tag, className);\n\t\ttagTable.put(className, tag);\n\t}\n",
    "167328": "\tpublic void endEntity(String name) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"endEntity: \" + \"name=\" + name);\n\t}\n",
    "167331": "\t\tpublic void start() {\n\t\t\t// do nothing.\n\t\t}\n",
    "167333": "\tpublic void externalEntityDecl(String name, String publicId, String systemId) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"externalEntityDecl: \" + \"name=\" + name + \", publicId=\" + publicId + \", systemId=\" + systemId);\n\t}\n",
    "167335": "\tpublic void setEncoding(String encoding) {\n\t\tsource.setEncoding(encoding);\n\t}\n",
    "167337": "\t\tpublic void stop() {\n\t\t\tComponent c = (Component) model.getNode(\"result file name\");\n\t\t\tif (c != null) {\n\t\t\t\tFile file = FileHandler.getNewFile(c.getValueString());\n\t\t\t\ttry {\n\t\t\t\t\tserializer.update(model, new FileOutputStream(file), new InputSource(reference));\n\t\t\t\t\tlog.info(\"The result model xml has been written as \" + file);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.error(\"Error writing result xml file.\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "167340": "    public boolean isInlineTag() {\n        return true;\n    }\n",
    "167343": "\tpublic InputSource getExternalSubset(String name, String baseURI) throws SAXException, IOException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"getExternalSubset: \" + \"name=\" + name + \", baseURI=\" + baseURI);\n\t\treturn super.getExternalSubset(name, baseURI);\n\t}\n",
    "167344": "\tstatic public void writeCsv(BufferedWriter writer, XYSeriesCollection timeSerieses, String label) throws IOException {\n\t\t// \u5148\u982d\u884c\u304b\u3089\u30e9\u30d9\u30eb\u3092\u8aad\u307f\u53d6\u308b\u3002\n\t\twriter.write(label);\n\t\tfor (int i = 0; i < timeSerieses.getSeriesCount(); i++) {\n\t\t\twriter.write(SEPARATOR + timeSerieses.getSeriesKey(i));\n\t\t}\n\t\twriter.newLine();\n\t\tfor (int i = 0; i < timeSerieses.getSeries(0).getItemCount(); i++) {\n\t\t\twriter.write(timeSerieses.getX(0,i).toString());\n\t\t\tfor (int j = 0; j < timeSerieses.getSeriesCount(); j++) {\n\t\t\t\twriter.write(SEPARATOR + timeSerieses.getY(j, i));\n\t\t\t}\n\t\t\twriter.newLine();\n\t\t}\n\t}\n",
    "167345": "    public String toString(Tag[] tags) {\n        return null;\n    }\n",
    "167346": "\tstatic public XYSeriesCollection getXYSerieses(BufferedReader csv) throws IOException{\n\t\tXYSeriesCollection xYSeriesCollection = new XYSeriesCollection();\n\t\t// \u5148\u982d\u884c\u304b\u3089\u30e9\u30d9\u30eb\u3092\u8aad\u307f\u53d6\u308b\u3002\n\t\tString[] labels = csv.readLine().split(SEPARATOR);\n\t\t// \u5148\u982d\u5217\u306e\u30c7\u30fc\u30bf\u3092x\u306b\u5165\u308c\u308b\u3002\n\t\tfor (int i = 1; i < labels.length; i++) {\n\t\t\txYSeriesCollection.addSeries(new XYSeries(labels[i]));\n\t\t}\n\t\t// Read all CSV file data\n\t\tString line = null;\n\t\tdouble[] values = null;\n\t\twhile ((line = csv.readLine()) != null) {\n\t\t\tvalues = getValues(line);\n\t\t\tfor (int i = 1; i < values.length; i++) {\n\t\t\t\txYSeriesCollection.getSeries(i-1).add(values[0], values[i]);\n\t\t\t}\n\t\t}\n\t\treturn xYSeriesCollection;\n\t}\n",
    "167347": "\tpublic Component getComponent(String className) throws InstantiationException {\n\t\t// className\u304b\u3089\u30d1\u30c3\u30b1\u30fc\u30b8\u306e\u540d\u524d\u3092\u53d6\u308a\u9664\u304f\u3002\n\t\tint i = className.lastIndexOf(\".\");\n\t\tString tag = className.substring(i + 1);\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"tag is \" + tag);\n\t\tInitializer initializer = Initializer.getInstance(className);\n\t\t// TODO \u982d\u6587\u5b57\u3060\u3051\u3092\u5c0f\u6587\u5b57\u306b\u3059\u308b?\n\t\tinitializer.setName(tag.toLowerCase());\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"initializer name is set \" + initializer.getName());\n\t\tinitializer.setUnits(DEFAULT_DIMENSION);\n\t\t// get instance from className\n\t\tComponent component = getInstanceOf(tag, initializer);\n\t\tcomponent.setInitializer(initializer);\n\t\t// create child nodes\n\t\tinitializer.setParent((Composite) component);\n\t\tcreateChildren(initializer, component);\n\t\treturn component;\n\t}\n",
    "167348": "\tpublic void calculate(double t) {\n\t\tfor (int i = 0, n = rbcs.size(); i < n; i++) {\n\t\t\t((Reactor) rbcs.get(i)).setValue(0);\n\t\t}\n\t\tfor (int i = 0, n = size(); i < n; i++) {\n\t\t\t((Reactor) get(i)).calculate(t);\n\t\t}\n\t}\n",
    "167349": "\tpublic void internalEntityDecl(String name, String value) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"internalEntityDecl: \" + \"name=\" + name + \", value=\" + value);\n\t}\n",
    "167351": "\tpublic void setInitializer(Initializer initializer) {\n\t\tparent = initializer.getParent();\n\t\tname = initializer.getName();\n\t\tif (parent != null) {\n\t\t\troot = parent.getRoot();\n\t\t\tlevel = parent.getLevel() + 1;\n\t\t\thierarchicalName = parent.getName() + CONNECTOR + name;\n\t\t\tparent.addNode(this);\n\t\t} else {\n\t\t\troot = (Composite) this;\n\t\t\thierarchicalName = name;\n\t\t}\n\t\tinitializer.setName(null);\n\t\tunits = initializer.getUnits();\n\t\tinitializer.setUnits(null);\n\t\tvalueString = initializer.getInitialValue();\n\t\tinitializer.setInitialValue(null);\n\t\tif (log.isDebugEnabled())\n\t\t\tlogIndented(\" as 'Component' Created, set value = '\" + valueString\n\t\t\t\t\t+ \"', units = '\" + units + \"'.\");\n\t}\n",
    "167352": "\tpublic Iterator getNodesIterator() {\n\t\treturn nodes.iterator();\n\t}\n",
    "167354": "\tprotected void setLinks() {\n\t\tlogIndented(\" set links\");\n\t}\n",
    "167358": "\tprotected void prepare() {\n\t\tlogIndented(\" prepared\");\n\t}\n",
    "167359": "\tprotected Node getLink(String name) {\n\t\tNode node = getNode(name);\n\t\tif (node != null)\n\t\t\treturn getNode(((Component) node).getValueString());\n\t\treturn null;\n\t}\n",
    "167360": "\tpublic InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"resolveEntity: \" + \"publicId=\" + publicId + \", systemId=\" + systemId);\n\t\treturn super.resolveEntity(publicId, systemId);\n\t}\n",
    "167361": "\tprotected void end() {\n\t\tlogIndented(\" ended\");\n\t}\n",
    "167362": "\tpublic void setLinks(ReactorList reactors) {\n\t\tthis.reactors = reactors;\n\t}\n",
    "167365": "\tprotected void quit() {\n\t\tlogIndented(\" finalized\");\n\t}\n",
    "167366": "\tprotected double adjustDt() {\n\t\tdouble dt = 0;\n\t\t// same dt\n\t\tif (maxDt <= minDt)\n\t\t\tdt = maxDt;\n\t\telse {\n\t\t\tratio = 0;\n\t\t\tmaxR = 0;\n\t\t\tfor (int i = 0, n = size(); i < n; i++) {\n\t\t\t\tratio = ((Variable) get(i)).getDydtOverY();\n\t\t\t\tif (maxR < ratio) {\n\t\t\t\t\tmaxR = ratio;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxRthreshold <= maxR)\n\t\t\t\tdt = minDt;\n\t\t\telse if (maxR <= minRthreshold)\n\t\t\t\tdt = maxDt;\n\t\t\telse\n\t\t\t\tdt = adjustDyY / maxR;\n\t\t}\n\t\tif (lest < dt)\n\t\t\tdt = lest;\n\t\tlest -= dt;\n\t\treturn dt;\n\t}\n",
    "167367": "\tpublic void startCDATA() throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"startCDATA\");\n\t}\n",
    "167373": "\tpublic void startDTD(String name, String publicId, String systemId) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"startDTD: \" + \"name=\" + name + \", publicId=\" + publicId + \", systemId=\" + systemId);\n\t}\n",
    "167374": "\tpublic boolean isNamed(String s) {\n\t\treturn name.equals(s);\n\t}\n",
    "167375": "\tpublic String getClassName() {\n\t\treturn className;\n\t}\n",
    "167376": "\tpublic boolean isPrefixed(String prefix) {\n\t\treturn name.startsWith(prefix);\n\t}\n",
    "167377": "\tpublic String getInitialValue() {\n\t\treturn initialValue;\n\t}\n",
    "167378": "\tpublic void visit(Component component) {\n\t\tnodes.add(component);\n\t\tif (component instanceof Euler) {\n\t\t\tif (!(variables instanceof EulerList)) {\n\t\t\t\tvariables = new EulerList();\n\t\t\t}\n\t\t\tvariables.add(component);\n\t\t} else if (component instanceof RungeKutta) {\n\t\t\tif (!(variables instanceof RungeKuttaList)) {\n\t\t\t\tvariables = new RungeKuttaList();\n\t\t\t}\n\t\t\tvariables.add(component);\n\t\t}\n\t}\n",
    "167379": "\tpublic void startEntity(String name) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"startEntity: \" + \"name=\" + name);\n\t}\n",
    "167382": "\tpublic Composite getParent() {\n\t\treturn parent;\n\t}\n",
    "167383": "\tpublic void visit(Composite composite) {\n\t\tIterator item = composite.getNodesIterator();\n\t\twhile (item.hasNext())\n\t\t\t((Component) item.next()).accept(this);\n\t\tif (composite != this)\n\t\t\tnodes.add(composite);\n\t\tif ((composite instanceof Reactor) && (composite != this))\n\t\t\treactors.add(composite);\n\t\telse if (composite instanceof Analyzer)\n\t\t\tanalyzers.add(composite);\n\t}\n",
    "167384": "\tpublic void endPrefixMapping(String prefix) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"endPrefixMapping: \" + \"prefix=\" + prefix);\n\t}\n",
    "167386": "\tpublic String getUnits() {\n\t\treturn units;\n\t}\n",
    "167387": "\tsynchronized public void run() {\n\t\taccept(this);\n\n\t\tcheck();\n\n\t\tsetLinks();\n\n\t\tdo {\n\t\t\tif (isCalculate) {\n\t\t\t\t// \u8a08\u7b97\u524d\u306eObserver\u3092\u547c\u3073\u51fa\u3059\n\t\t\t\tif (calculationObservers.size() > 0) {\n\t\t\t\t\tIterator iter = calculationObservers.listIterator();\n\t\t\t\t\twhile (iter.hasNext())\n\t\t\t\t\t\t((CalculationObserver) iter.next()).start();\n\t\t\t\t}\n\t\t\t\tintegrate();\n\t\t\t\t// \u8a08\u7b97\u5f8c\u306eObserver\u3092\u547c\u3073\u51fa\u3059\n\t\t\t\tif (calculationObservers.size() > 0) {\n\t\t\t\t\tIterator iter = calculationObservers.listIterator();\n\t\t\t\t\twhile (iter.hasNext())\n\t\t\t\t\t\t((CalculationObserver) iter.next()).stop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isActive)\n\t\t\t\ttry {\n\t\t\t\t\twait();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tlog.error(e);\n\t\t\t\t}\n\t\t} while (isActive);\n\t\tquit();\n\t}\n",
    "167388": "\tpublic void setClassName(String className) {\n\t\tthis.className = className;\n\t}\n",
    "167389": "\tpublic void setValue(final double newValue) {\n\t\tthrow new UnsupportedOperationException(\"Check Type, because \" + hierarchicalName\n\t\t\t\t+ \" doesn't support setValue().\");\n\t}\n",
    "167390": "\tpublic void setInitialValue(String initialValue) {\n\t\tthis.initialValue = initialValue;\n\t}\n",
    "167391": "\tpublic void skippedEntity(String name) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"skippedEntity: \" + \"name=\" + name);\n\t}\n",
    "167394": "\tpublic void addValue(final double value) {\n\t\tthrow new UnsupportedOperationException(\"Check Type, because \" + hierarchicalName\n\t\t\t\t+ \" doesn't support addDydt().\");\n\t}\n",
    "167395": "\tpublic void setParent(Composite parent) {\n\t\tthis.parent = parent;\n\t}\n",
    "167396": "\tpublic void startPrefixMapping(String prefix, String uri) throws SAXException {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"startPrefixMapping: \" + \"prefix=\" + prefix + \", uri=\" + uri);\n\t}\n",
    "167397": "\tprotected void setLinks() {\n\t\tnodes.setLinks();\n\t\tvariables.setLinks(reactors);\n\t}\n",
    "167398": "\tpublic double getValue() {\n\t\tthrow new UnsupportedOperationException(\"Check Type, because \" + hierarchicalName\n\t\t\t\t+ \" doesn't support getValue().\");\n\t}\n",
    "167399": "\tpublic void setUnits(String units) {\n\t\tthis.units = units;\n\t}\n",
    "167402": "\tpublic void clear() {\n\t\tparent = null;\n\t\tname = null;\n\t\tinitialValue = null;\n\t\tunits = null;\n\t\tclassName = null;\n\t}\n",
    "167404": "\tpublic void addDydt(final double dydt) {\n\t\tthrow new UnsupportedOperationException(\"Check Type, because \" + hierarchicalName\n\t\t\t\t+ \" doesn't support addDydt().\");\n\t}\n",
    "167405": "\tprotected void quit() {\n\t\tnodes.quit();\n\t}\n",
    "167407": "    protected void update(double dt) {\n        super.update(dt);\n        if (value < TINY) {\n            log.warn(getName() + \" becomes \" + value + \", but should be positive.\");\n            value = TINY;\n        }\n    }\n",
    "167408": "\tpublic void setValue(final double newValue) {\n\t\tsuper.setValue(newValue);\n\t\tif (log.isWarnEnabled()) {\n\t\t\tlog.warn(\"The Method setValue() in \" + this.getClass().getName()\n\t\t\t\t\t+ \" of \" + getName() + \" will be depricated!\");\n\t\t}\n\t}\n",
    "167409": "    protected void update(double dt) {\n        super.update(dt);\n        if (1 <= value) {\n            log.warn(getName() + \" becomes \" + value + \", but should be less than 1.\");\n            value = 1 - TINY;\n        }\n    }\n",
    "167410": "\tpublic void addValue(final double value) {\n\t\tsuper.addValue(value);\n\t\tif (log.isWarnEnabled()) {\n\t\t\tlog.warn(\"The Method addValue() in \" + this.getClass().getName()\n\t\t\t\t\t+ \" of \" + getName() + \" will be depricated!\");\n\t\t}\n\t}\n",
    "167412": "\tpublic String getName() {\n\t\treturn hierarchicalName;\n\t}\n",
    "167422": "\tprotected void end() {\n\t\tnodes.end();\n\t}\n",
    "167425": "\tpublic String getShortName() {\n\t\treturn name;\n\t}\n",
    "167427": "\tpublic void setInitializer(Initializer initializer) {\n\n\t\t// get the instance of volume\n\t\tComposite c = initializer.getParent();\n\t\tvolume = c.getNode(\"volume\");\n\t\tif (volume == null)\n\t\t\tSystem.err.println(\"Volume is not defined!\");\n\n\t\t// get initial value(concentration)\n\t\tdouble x1 = Double.parseDouble(initializer.getInitialValue());\n\t\tdouble x2 = x1 * volume.getValue();\n\t\tinitializer.setInitialValue(String.valueOf(x2));\n\n\t\t// call super method \n\t\tsuper.setInitializer(initializer);\n\t}\n",
    "167431": "\tpublic double update(double t) {\n\t\tdouble dt = adjustDt();\n\t\tfor (int i = 0, n = size(); i < n; i++) {\n\t\t\t((Euler) get(i)).update(dt);\n\t\t}\n\t\treturn dt;\n\t}\n",
    "167437": "\tpublic Composite getRoot() {\n\t\treturn root;\n\t}\n",
    "167438": "\tpublic void calculate(double t) {\n\t\treactors.calculate(t);\n\t}\n",
    "167445": "\tpublic void checkException() throws Exception {\n\t\tif (except != null)\n\t\t\tthrow except;\n\t}\n",
    "167447": "\tpublic void addValue(double value) {\n\t\tthis.value += value;\n\t\t//\t\tsetValueToField();\n\t}\n",
    "167448": "\tpublic String getIndent() {\n\t\tif (indent == null) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor (int i = 0; i < level; i++)\n\t\t\t\tsb.append(\"    \");\n\t\t\tindent = sb.toString();\n\t\t}\n\t\treturn indent;\n\t}\n",
    "167453": "\tpublic String getIndentedShortName() {\n\t\treturn getIndent() + name;\n\t}\n",
    "167454": "\tpublic void exit(){\n\t\ttry {\n\t\t\twriteEndTag(TAG_TOC);\n\t\t\twriter.close();\n\t\t\twriter = null;\n\t\t\tlog.info(\"Table of contents has been saved.\");\n\t\t} catch (IOException e) {\n\t\t\tlog.error(e);\n\t\t}\n\t}\n",
    "167458": "\tpublic void logIndented(String s) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(getIndentedShortName() + s);\n\t}\n",
    "167463": "\tsynchronized public void exit() {\n\t\tisActive = false;\n\t\tnotifyAll();\n\t}\n",
    "167466": "\tpublic ProtocolParser getProtocolParser() {\n\t\treturn protocol;\n\t}\n",
    "167475": "\tpublic boolean hasXMLs() {\n\t\tif (!collectXMLs())\n\t\t\treturn false;\n\t\txmls = getXMLs();\n\t\treturn (xmls != null);\n\t}\n",
    "167479": "\tpublic boolean render(Graphics2D arg0, Rectangle2D arg1, int arg2, PlotRenderingInfo arg3, CrosshairState arg4) {\n\t\ttry {\n\t\t\treturn super.render(arg0, arg1, arg2, arg3, arg4);\n\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\tPlotLine.log.info(\"IndexOutOfBoundsException\");\n\t\t\tif (PlotLine.log.isDebugEnabled())\n\t\t\t\tPlotLine.log.debug(e);\n\t\t\treturn false;\n\t\t} catch (NullPointerException e) {\n\t\t\tPlotLine.log.info(\"NullPointerException\");\n\t\t\tif (PlotLine.log.isDebugEnabled())\n\t\t\t\tPlotLine.log.debug(e);\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "167489": "\tprivate JFreeChart createChart(int index) {\n\t\t// return a new chart containing the overlaid plot...\n\t\tJFreeChart chart = new JFreeChart(null, JFreeChart.DEFAULT_TITLE_FONT, createSubPlot(index), true);\n\t\tchart.setBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000,\n\t\t\t\tColor.green));\n\t\treturn chart;\n\t}\n",
    "167502": "\tpublic void update(){\n\t\tthis.setTitle(getTitle(collection));\n\t\t//\u65b0\u3057\u3044\u30c7\u30fc\u30bf\u3092\u6700\u5f8c\u306b\u4ed8\u3051\u52a0\u3048\u308b\u3002\n\t\tfor (int i = 0; i < collection.getKeySize(); i++) {\n\t\t\tseriesCollections[indexKey].getSeries(i).add(collection.getSize(), \n\t\t\t\t\tcollection.getParamRatio(collection.getSize()-1, i));\n\t\t}\n\t\tfor (int i = 0; i < collection.getEvalSize(); i++) {\n\t\t\tseriesCollections[indexEval].getSeries(i).add(collection.getSize(), \n\t\t\t\t\tcollection.getEval(collection.getSize()-1, i));\n\t\t\tlog.debug(\" add xy data of result No. \" + collection.getSize() + \", eval \" \n\t\t\t\t\t+ collection.getEvalLabvel(i) + \"=\" \n\t\t\t\t\t+ collection.getEval(collection.getSize()-1, i));\n\t\t}\t\n\t\tthis.repaint();\n\t}\n",
    "167503": "\tpublic void writeToc(String protocolName, boolean runResultGenerator) {\n\t\tString modelName;\n\t\ttry {\n\t\t\tmodelName = protocol.getBaseModel();\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Error in randinput\", e);\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\twriteToc(modelName, protocolName, runResultGenerator);\n\t}\n",
    "167513": "\t\tpublic void contourRenderer(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info, ContourPlot plot, ValueAxis horizontalAxis, ValueAxis verticalAxis, ColorBar colorBar, ContourDataset data, CrosshairState crosshairState) {\n\t\t\ttry {\n\t\t\t\tsuper.contourRenderer(g2, dataArea, info, plot, horizontalAxis, verticalAxis,\n\t\t\t\t\t\tcolorBar, data, crosshairState);\n\t\t\t} catch (ArrayIndexOutOfBoundsException e) {\n\t\t\t\tlog.info(\"data number is not a square.\");\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(e);\n\t\t\t}\t\n\t\t}\n",
    "167517": "\tprivate XYSeriesCollection createDataset(int indexResult, int indexEval) {\n\t\tXYSeriesCollection sc = collection.getLastXYSeriesCollection();\n\t\tXYSeries s = sc.getSeries(indexEval);\n\t\tif (isPlotLastOnly)\n\t\t\tseriesCollections[indexEval].removeAllSeries();\n\t\tseriesCollections[indexEval].addSeries(s);\n\t\treturn seriesCollections[indexEval];\n\t}\n",
    "167518": "\tprivate ChartPanel createPanel(int indexEval) {\n\t\tJFreeChart chart = createContourPlot(indexEval);\n\t\tChartPanel panel = new ChartPanel(chart, true, true, true, true, true);\n\t\tpanel.setPreferredSize(new java.awt.Dimension(width, height));\n\t\treturn panel;\n\t}\n",
    "167549": "\tprotected void analyze(double t) {\n\t\tif (max < t) reset(t);\n\t}\n",
    "167550": "\tprotected void setLinks() {\n\t\tpage = (ICanvas) getParent();\n\t\tint i = 0;\n\t\tIterator item = getNodesIterator();\n\t\tComponent c = null;\n\t\twhile (item.hasNext()) {\n\t\t\tc = (Component) item.next();\n\t\t\tif (c.isPrefixed(\"target\")) {\n\t\t\t\tNode d = (Component) getParent().getParent().getNode(\n\t\t\t\t\t\tc.getValueString());\n\t\t\t\tif (d == null)\n\t\t\t\t\tlog.error(\"'\" + c.getValueString() + \"' at \" + c.getName()\n\t\t\t\t\t\t\t+ \" is missing.\");\n\t\t\t\telse\n\t\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif ((axisXFix == null) && (c instanceof AxisXFix))\n\t\t\t\taxisXFix = (AxisXFix) c;\n\t\t\tif ((axisY == null) && (c instanceof AxisY))\n\t\t\t\taxisY = (AxisY) c;\n\t\t}\n\t\ttarget = new Node[i];\n\t\tlastY = new int[i];\n\t}\n",
    "167551": "\tprotected void setLinks() {\n\t\tsuper.setLinks();\n\t\tif (getParent().getParent() instanceof ICanvas)\n\t\t\tpage = (ICanvas) getParent().getParent();\n        if (units == null) {\n            units = new Component();\n            ((Component)units).setValueString(getParent().getShortName() + \" (\" + getUnits() + \")\");\n        }\n\t}\n",
    "167556": "\tprotected void setLinks() {\n\t\tpage = (ICanvas) getParent();\n\t\tif (axisX == null)\n\t\t\tsetAxisX();\n\t\tif (axisY == null)\n\t\t\tsetAxisY();\n\t\t// check the links.\n\t\ttargets = getTargetsOf(this);\n\t}\n",
    "167571": "\tprotected void prepare() {\n\t\tnextTime = 0;\n\t\t// The links can be modified through GUI.\n\t\ttargets = getTargetsOf(this);\n\t\tclearLastPositions();\n\t\tsuper.prepare();\n\t}\n",
    "167584": "\tpublic void setContainer(Container container) {\n\t\tthis.container = container;\n\t}\n",
    "167589": "\tpublic void reset() {\n\t\tif (graphics != null)\n\t\t\tgraphics.dispose();\n\t\tgraphics = container.getGraphics();\n\t\tgraphics.clearRect(0, 0, container.getWidth(), container.getHeight());\n\t}\n",
    "167593": "\tprotected void setLinks() {\n\t\tif (container == null) {\n\t\t\tcontainer =\n\t\t\t\tnew OnScreen(\n\t\t\t\t\tthis,\n\t\t\t\t\tgetParent().getName() + \" at \" + (new java.util.Date()));\n\t\t}\n\t\treset();\n\t\tsetColors();\n\t\tsuper.setLinks();\n\t}\n",
    "167598": "\tprotected void quit() {\n\t\tgraphics.dispose();\n\t\tif (container instanceof OnScreen) {\n\t\t\t((OnScreen) container).dispose();\n\t\t\tcontainer = null;\n\t\t}\n\t\tsuper.quit();\n\t}\n",
    "167599": "\tprotected void setLinks() {\n\t\tsuper.setLinks();\n\t\tminNode = getNodeRecursive(\"min\");\n\t\tmaxNode = getNodeRecursive(\"max\");\n\t\tprepareRepaint();\n\t}\n",
    "167609": "\tpublic double getScaleWidth() {\n\t\treturn referenceWidth / container.getWidth();\n\t}\n",
    "167611": "\tpublic void resetBuffer() {\n\t\t// \u5148\u306b\u3001\u5b50Node\u306e\u7247\u4ed8\u3051\u3092\u884c\u3046\u3002\n\t\tsuper.resetBuffer();\n\t\t// \u518d\u63cf\u753b\u30d0\u30c3\u30d5\u30a1\u3092\u6d88\u3059\u3002\n\t\tif (replotBuffer != null) {\n\t\t\treplotBuffer = null;\n\t\t}\n\t\t// initialize replotBuffer\n\t\treplotBuffer = new GraphReplotBuffer[nTarget];\n\t\tfor (int i = 0; i < nTarget; i++) {\n\t\t\treplotBuffer[i] = new GraphReplotBuffer(this, plotDisplay, values, i);\n\t\t}\n\t\tbufferRebuildFlag = true;\n\n\t}\n",
    "167612": "\tpublic double getScaleHeight() {\n\t\treturn referenceHeight / container.getHeight();\n\t}\n",
    "167622": "\tpublic void changeScale() {\n\t\t// \u518d\u63cf\u753b\u6642\u306b\u3001\u30d0\u30c3\u30d5\u30a1\u518d\u69cb\u7bc9\u3092\u884c\u3046\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u308b\u3002\n\t\tbufferRebuildFlag = true;\n\t\t// \u518d\u63cf\u753b\u6307\u793a\n\t\tsuper.changeScale();\n\t}\n",
    "167623": "\tpublic void doRepaint() {\n\t\tNode parent = getParent();\n\t\tif (parent instanceof AbstractGraph) {\n\t\t\t((AbstractGraph) parent).doRepaint();\n\t\t}\n\t}\n",
    "167625": "\tprotected void end() {\n\t\tsuper.end();\n\t\tParameter minNode = (Parameter) ((Axis) axisX).getNodeRecursive(\"min\");\n\t\tParameter maxNode = (Parameter) ((Axis) axisX).getNodeRecursive(\"max\");\n\t\tdouble elapsedTime = getRoot().getNode(\"elapsedTime\").getValue();\n\t\tdouble duration = maxNode.getValue() - minNode.getValue();\n\n\t\tif ((expectedFinalTime < elapsedTime) && (elapsedTime > maxNode.getValue())) {\n\t\t\tmaxNode.setValue(elapsedTime);\n\t\t\tminNode.setValue(elapsedTime - duration);\n\n\t\t\taxisX.max = elapsedTime;\n\t\t\taxisX.min = elapsedTime - duration;\n\n\t\t\tchangeScale();\n\t\t}\n\t\tanalyze(elapsedTime);\n\t}\n",
    "167626": "\tpublic void setAreaChanged() {\n\t\tif (isRepaintNeeded()) {\n\t\tsuper.setAreaChanged();\n\t\t// \u518d\u63cf\u753b\u6642\u306b\u3001\u30d0\u30c3\u30d5\u30a1\u518d\u69cb\u7bc9\u3092\u884c\u3046\u30d5\u30e9\u30b0\u3092\u7acb\u3066\u308b\u3002\n\t\tbufferRebuildFlag = true;\n\t}\n}\n",
    "167631": "\tprotected void prepare() {\n\t\t// \u8a08\u7b97\u6642\u523b\u306e\u521d\u671f\u5316\n\t\tnextTime = 0;\n\t\t// \u6700\u5927\u6642\u523b\u306e\u521d\u671f\u5316 : BasicGraph \u3067\u3001\u4e0a\u66f8\u304d\u3057\u306a\u304a\u3059\u3002\n\t\tmaxTime = -1;\n\n\t\t// target[n] \u3092\u30bb\u30c3\u30c8\u3059\u308b\u3002\n\t\tsetTargets();\n\n\t\t// \u753b\u9762\u30b5\u30a4\u30ba\u306e\u53d6\u5f97\n\t\tIPlot plot = plotDisplay;\n\t\tplot.setSizePage(page.getContainer().getSize());\n\t\tresize(plot);\n\t\t//\n\t\tsuper.prepare();\n\t}\n",
    "167726": "\tpublic Container getContainer() {\n\t\treturn this.container;\n\t}\n",
    "167745": "\tprotected void paintAxises(Graphics2D graphics2d, IPlot plot) {\n\t\t// drow grid and label\n\t\taxisX.plotAxis(graphics2d, plot);\n\t\taxisY.plotAxis(graphics2d, plot);\n\t\tgraphics2d.setColor(Color.gray);\n\t\tgraphics2d.draw(plot.getRectangleView());\n\t}\n",
    "167749": "\tprotected void quit() {\n\t\tif (container instanceof OnScreen) {\n\t\t\t((OnScreen) container).dispose();\n\t\t\tcontainer = null;\n\t\t}\n\t\tsuper.quit();\n\t}\n",
    "167776": "\tprotected void printAxises(Graphics2D graphics2d, IPlot plot) {\n\t\tpaintAxises(graphics2d, plot);\n\t}\n",
    "167804": "\tprotected void measure(double t) {\n\t\tif (isFirst) reset();\n\t\tmaximum_ = Math.max(maximum_, target.getValue());\n\t\tminimum_ = Math.min(minimum_, target.getValue());\n\t}\n",
    "167806": "\tprotected void end() {\n\t\tif (isFirst) reset();\n\t\tmaximum_ *= scale;\n\t\tminimum_ *= scale;\n\t\tmaximum.setValue(maximum_);\n\t\tminimum.setValue(minimum_);\n\t\tsetValue(maximum_ - minimum_);\n\t\tsuper.end();\n\t}\n",
    "167810": "\tprivate void reset() {\n\t\tmaximum_ *= scale;\n\t\tminimum_ *= scale;\n\t\tmaximum.setValue(maximum_);\n\t\tminimum.setValue(minimum_);\n\t\tsetValue(maximum_ - minimum_);\n\t\tmaximum_ = target.getValue();\n\t\tminimum_ = maximum_;\n\t\tresetTime += cycle;\n\t}\n",
    "167813": "\tprotected void measure(double t) {\n\t\tif (resetTime < t) reset();\n\t\tfinal double val = target.getValue();\n\t\tmaximum_ = Math.max(maximum_, val);\n\t\tminimum_ = Math.min(minimum_, val);\n\t}\n",
    "167822": "\tprotected void prepare() {\n\t\ttargets_ = NodeHandler.getTargets(this);\n\t\tsuper.prepare();\n\t}\n",
    "167823": "\tprotected void analyze(double t) {\n\t\tif (isOpen) {\n\t\t\tif (t < onset)\n\t\t\t\treturn;\n\t\t\tif (offset < t){\n\t\t\t\tif (isOpen) {\n\t\t\t\t\tend();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (t < nextTime - epsilon)\n\t\t\t\treturn;\n\t\t\tnextTime += interval;\n\n\t\t\ttry {\n\t\t\t\tString s = Double.toString(t) + MakeValueLine();\n\t\t\t\tcsvFile.write(s);\n\t\t\t\tcsvFile.newLine();\n\t\t\t\tlog.debug(s);\n\t\t\t} catch (IOException e) {\n\t\t\t\tlog.error(\"couldn't write\", e);\n\t\t\t}\n\t\t}\n\t}\n",
    "167833": "\tprotected void prepare() {\n\t\ttargets_.clear();\n\t\tString targetName = null;\n\t\tComponent component;\n\t\tNode target;\n\t\tIterator item = getNodesIterator();\n\t\twhile (item.hasNext()) {\n\t\t\tcomponent = (Component) item.next();\n\t\t\tif (component.isPrefixed(\"target\")) {\n\t\t\t\ttry {\n\t\t\t\t\ttargetName = component.getValueString();\n\t\t\t\t\ttarget = getNode(targetName);\n\t\t\t\t\tif (target instanceof Parameter)\n\t\t\t\t\t\ttargets_.add(target);\n\t\t\t\t} catch (NullPointerException e) {\n\t\t\t\t\tlog.error(getName() + \"cannot find target '\" + targetName\n\t\t\t\t\t\t\t+ \"'.\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.prepare();\n\t}\n",
    "167893": "\tprivate void initialize() {\n\t\tjThisDialog = this;\n\t\tthis.setContentPane(getJContentPane());\n\t\tthis.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n\t}\n",
    "167961": "\tpublic void visit(Component data) {\n\t\t// do nothing\n\t}\n",
    "167968": "\tpublic void visit(Composite parent) {\n\t\tif (parent instanceof IViewer) {\n\t\t\t((IViewer) parent).setContainer(jPanel);\n\t\t\tpage = (IViewer) parent;\n\t\t\tviewers.add(parent);\n//\t\t\tif (parent instanceof RateGraph) {\n//\t\t\t\tjToolBar.add(((RateGraph) parent).getJButton());\n//\t\t\t}\n\t\t\t((IViewer) parent).setFileName(statusProcessor.getFileName());\n        } else {\n\t\t\tIterator item = parent.getNodesIterator();\n\t\t\twhile (item.hasNext())\n\t\t\t\t ((Component) item.next()).accept(this);\n\t\t}\n\t}\n",
    "167971": "\tprivate JTree getJTree() {\n\t\t\n\t\ttreeModel = new TargetTreeModel();\n\t\t//\n\t\tJTree jTree = new CheckedJTree(treeModel);\n\t\tjTree.setRootVisible(false);\n\n\t\tjTree.setVisible(true);\n\t\t// \u5168\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\n\t\tfor(int i = 0; i < jTree.getRowCount();i++) {\n\t\t\tjTree.expandRow(i);\n\t\t}\n\n\t\treturn jTree;\n\t}\n",
    "167972": "\tpublic InputStream getProtocolAsStream() {\n\t\tByteArrayOutputStream byteoutput = new ByteArrayOutputStream();\n\t\tDOMHandler.writeXML(protocol, byteoutput);\n\t\treturn new ByteArrayInputStream(byteoutput.toByteArray());\n\t}\n",
    "167974": "\tpublic String getBaseModel() throws IOException {\n\t\tNode fileName = NodeHandler.getSingleNode(protocol, \"//baseModel/@path\");\n\t\tif (fileName == null) {\n\t\t\tthrow new IOException(\"Tagname baseModel/path was not found in protocol.\");\n\t\t}\n\t\treturn fileName.getNodeValue();\n\t}\n",
    "167976": "\tprivate JButton getJButtonOK() {\n\t\tJButton jButtonOK = null;\n\n\t\tjButtonOK = new JButton();\n\t\tjButtonOK.setText(\"OK\");\n\t\tjButtonOK.addActionListener(new AbstractAction() {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif(ExportCsv() == false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchooser.setSelectedFile(new File(jCsvFile.getText()));\n\t\t\t\tdisposeDialog();\n\t\t\t}\n\t\t});\n\t\treturn jButtonOK;\n\t}\n",
    "167978": "\tpublic String getGenerateModel() throws IOException {\n\t\tNode fileName = NodeHandler.getSingleNode(protocol, \"//generate/xml/@path\");\n\t\tif (fileName == null){\n\t\t\tthrow new IOException(\"An XML file will be generated, when 'generate' 'xml' has an attribute 'path'.\");\n\t\t}\n\t\treturn fileName.getNodeValue();\n\t}\n",
    "167979": "\tpublic int getMaxThreads() {\n\t\tNode threads = NodeHandler.getSingleNode(protocol, \"/randomizer/@threads\");\n\t\tif (threads == null) {\n\t\t\tlog.debug(\"Attribute 'threads' was not found in protocol. Set Maxthreads to '1'.\");\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tint numThreads;\n\t\t\ttry {\n\t\t\t\tnumThreads = Integer.parseInt(threads.getNodeValue());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tlog.error(\"Thread is not a number. Correct tag randomizer attribute 'threads' in protocol.\", e);\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\treturn numThreads;\n\t\t}\n\t}\n",
    "167981": "\tpublic String getLauncher() throws IOException {\n\t\tNode launch = NodeHandler.getSingleNode(protocol, \"//generate/xml/@launch\");\n\t\tif (launch == null){\n\t\t\tthrow new IOException(\"Tagname launch was not found in protocol.\");\n\t\t}\n\t\treturn launch.getNodeValue();\n\t}\n",
    "167982": "\tpublic NodeIterator getEraser() throws IOException {\n\t\tNodeIterator eraser = NodeHandler.getNodeIterator(protocol, \"//erase/eraser\");\n\t\tif (eraser.nextNode() == null) {\n\t\t\tthrow new IOException(\"No eraser was found.\");\n\t\t}\n\t\teraser.previousNode();\n\t\treturn eraser;\n\t}\n",
    "167986": "\tpublic NodeIterator getInserter() throws IOException {\n\t\tNodeIterator inserter = NodeHandler.getNodeIterator(protocol, \"//insert/inserter\");\n\t\tif (inserter.nextNode() == null) {\n\t\t\tthrow new IOException(\"No inserter was found.\");\n\t\t}\n\t\tinserter.previousNode();\n\t\treturn inserter;\n\t}\n",
    "167988": "\tpublic NodeIterator getInserterBefore() throws IOException {\n\t\tNodeIterator insertBefore = NodeHandler.getNodeIterator(protocol, \"//insert/before\");\n\t\tif (insertBefore.nextNode() == null) {\n\t\t\tthrow new IOException(\"No insert/before was found.\");\n\t\t}\n\t\tinsertBefore.previousNode();\n\t\treturn insertBefore;\n\t}\n",
    "167990": "\tprivate JButton getJButtonCancel() {\n\t\tJButton jButtonCancel;\n\t\tjButtonCancel = new JButton();\n\t\tjButtonCancel.setText(\"Cancel\");\n\t\tjButtonCancel.addActionListener(new AbstractAction() {\n\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tjDialog.dispose();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\treturn jButtonCancel;\n\t}\n",
    "167991": "\tpublic NodeIterator getWriter() throws IOException {\n\t\tNodeIterator writer = NodeHandler.getNodeIterator(protocol, \"//write/writer\");\n\t\tif (writer.nextNode() == null) {\n\t\t\tthrow new IOException(\"No writer was found.\");\n\t\t}\n\t\twriter.previousNode();\n\t\treturn writer;\n\t}\n",
    "167993": "\tpublic NodeIterator getMultiplier() throws IOException {\n\t\tNodeIterator multiplier = NodeHandler.getNodeIterator(protocol, \"//write/multiplier\");\n\t\tif (multiplier.nextNode() == null) {\n\t\t\tthrow new IOException(\"No write/multiplier was found.\");\n\t\t}\n\t\tmultiplier.previousNode();\n\t\treturn multiplier;\n\t}\n",
    "167996": "\tpublic boolean hasExchanger() {\n\t\tNodeList nodelist = NodeHandler.getNodeList(protocol, \"//exchange\");\n\t\tboolean f = (nodelist.getLength() > 0);\n\t\tlog.debug(\"The tagname exchange exist, \" + Boolean.toString(f));\n\t\treturn f;\n\t}\n",
    "167999": "\tpublic Node getExchanger() throws IOException {\n\t\tNode exchangeNode = NodeHandler.getSingleNode(protocol, \"//exchange\");\n\t\tif (exchangeNode == null) {\n\t\t\tthrow new IOException(\"No exchanger was found.\");\n\t\t}\n\t\treturn exchangeNode;\n\t}\n",
    "168000": "\tpublic String getIdentification() throws IOException {\n\t\tNode identification = NodeHandler.getSingleNode(protocol, \"//randomizer/@identification\");\n\t\tif (identification == null){\n\t\t\tthrow new IOException(\"Attribute 'identification' was not found in protocol.\");\n\t\t}\n\t\treturn identification.getNodeValue();\n\t}\n",
    "168002": "\tprivate JFormattedTextField getJTimeMin() {\n\n\t\tNumberFormatter maskTime = new NumberFormatter();\n\t\tmaskTime.setMinimum(timeMin);\n\t\tmaskTime.setMaximum(timeMax);\n\t\tif (jTimeMin == null) {\n\t\t\tjTimeMin = new JFormattedTextField(maskTime);\n\t\t\tjTimeMin.setColumns(8);\n\t\t}\n\t\tjTimeMin.setMinimumSize(jTimeMin.getPreferredSize());\n\t\tjTimeMin.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\treturn jTimeMin;\n\t}\n",
    "168003": "\tprivate String getBaseDir() throws IOException {\n\t\tNode baseDir = NodeHandler.getSingleNode(protocol, \"//generate/baseDir/@path\");\n\t\tif (baseDir == null){\n\t\t\tthrow new IOException(\"Tagname baseDir was not found in protocol.\");\n\t\t}\n\t\treturn replaceValue(baseDir.getNodeValue());\n\t}\n",
    "168006": "\tprivate String getXmlDir() throws IOException {\n\t\tNode xmlDir = NodeHandler.getSingleNode(protocol, \"//generate/xmlDir/@path\");\n\t\tif (xmlDir == null){\n\t\t\tthrow new IOException(\"Tagname xmlDir was not found in protocol.\");\n\t\t}\n\t\treturn replaceValue(xmlDir.getNodeValue());\n\t}\n",
    "168007": "\tprivate String getCsvFile() throws IOException {\n\t\tNode csvFile = NodeHandler.getSingleNode(protocol, \"//generate/csvFile/@path\");\n\t\tif (csvFile == null){\n\t\t\tthrow new IOException(\"Tagname csvFile was not found in protocol.\");\n\t\t}\n\t\treturn replaceValue(csvFile.getNodeValue());\n\t}\n",
    "168009": "\tprivate JFormattedTextField getJTimeMax() {\n\n\t\tNumberFormatter maskTime = new NumberFormatter();\n\t\tmaskTime.setMinimum(timeMin);\n\t\tmaskTime.setMaximum(timeMax);\n\t\tif (jTimeMax == null) {\n\t\t\tjTimeMax = new JFormattedTextField(maskTime);\n\t\t\tjTimeMax.setColumns(8);\n\t\t}\n\t\tjTimeMax.setMinimumSize(jTimeMax.getPreferredSize());\n\t\tjTimeMax.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\treturn jTimeMax;\n\t}\n",
    "168010": "\tprivate String getXmlFile() throws IOException {\n\t\tNode xmlFile = NodeHandler.getSingleNode(protocol, \"//generate/xmlFile/@path\");\n\t\tif (xmlFile == null){\n\t\t\tthrow new IOException(\"Tagname xmlFile was not found in protocol.\");\n\t\t}\n\t\treturn replaceValue(xmlFile.getNodeValue());\n\t}\n",
    "168013": "\tpublic File getXmlRootDir() throws IOException {\n\t\tString baseDir = getBaseDir();\n\t\tString xmlDir = getXmlDir();\n\t\treturn new File(baseDir + File.separator + xmlDir);\n\t}\n",
    "168014": "\tprivate JFormattedTextField getJTimeStep() {\n\n\t\tNumberFormatter maskTime = new NumberFormatter();\n\t\tmaskTime.setMinimum(new Double(0.0));\n\t\tif (jTimeStep == null) {\n\t\t\tjTimeStep = new JFormattedTextField(maskTime);\n\t\t\tjTimeStep.setColumns(5);\n\t\t}\n\t\tjTimeStep.setMinimumSize(jTimeMax.getPreferredSize());\n\t\tjTimeStep.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\tjTimeStep.setValue(new Double(0.0));\n\t\treturn jTimeStep;\n\t}\n",
    "168017": "\tpublic File getCsvRootFile() throws IOException {\n\t\tString baseDir = getBaseDir();\n\t\tString csvFile = getCsvFile();\n\t\treturn FileHandler.getNewFile(baseDir + File.separator + csvFile);\n\t}\n",
    "168019": "\tpublic String getTocXML() throws IOException {\n\t\tString baseDir = getBaseDir();\n\t\tString tocFile = getXmlFile();\n\t\treturn replaceValue(baseDir + File.separator + tocFile);\n\t}\n",
    "168021": "\tprivate JTextField getJCsvFile() {\n\t\tjCsvFile = new JTextField();\n\n\t\tif(chooser.getSelectedFile() != null) {\n\t\t\tjCsvFile.setText(chooser.getSelectedFile().getPath());\n\t\t} else {\n\t\t\tjCsvFile.setText(defaultFileName);\n\t\t}\n\t\treturn jCsvFile;\n\t}\n",
    "168023": "\tpublic String getSettings() throws IOException {\n\t\tNode settings = NodeHandler.getSingleNode(protocol, \"//generate/xmlFile/@settings\");\n\t\tif (settings == null){\n\t\t\tthrow new IOException(\"Tagname settings was not found in protocol.\");\n\t\t}\n\t\treturn settings.getNodeValue();\n\t}\n",
    "168024": "\tpublic NodeIterator getXpath(String xpath) throws IOException {\n\t\tNodeIterator nodeIterator = NodeHandler.getNodeIterator(protocol, xpath);\n\t\tif (nodeIterator.nextNode() == null) {\n\t\t\tthrow new IOException(\"Tagname '\" + xpath + \"' was not found in protocol.\");\n\t\t}\n\t\tnodeIterator.previousNode();\n\t\treturn nodeIterator;\n\t}\n",
    "168026": "\tprivate JButton getJButtonBrowse() {\n\t\tJButton jButtonBrowse = null;\n\t\tif (jButtonBrowse == null) {\n\t\t\tjButtonBrowse = new JButton();\n\t\t\tjButtonBrowse.setAction(new AbstractAction(\"Browse\") {\n\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tchooser.setSelectedFile(new File(jCsvFile.getText()));\n\t\t\t\t\tint returnVal = chooser.showSaveDialog(jDialog.getOwner());\n\t\t\t\t\tif(returnVal == JFileChooser.APPROVE_OPTION) {\n\t\t\t\t\t\tjCsvFile.setText(chooser.getSelectedFile().getPath());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn jButtonBrowse;\n\t}\n",
    "168027": "\tpublic Node getNormalizeTo() throws IOException {\n\t\tNode embeddedPath = NodeHandler.getSingleNode(protocol, \"//normalizeTo/@xpath\");\n\t\tif (embeddedPath == null){\n\t\t\tthrow new IOException(\"Tagname normalizeTo was not found in protocol.\");\n\t\t}\n\t\treturn embeddedPath;\n\t}\n",
    "168030": "\tprivate void setProperties() {\n\t\tNodeIterator nodeIterator = NodeHandler.getNodeIterator(protocol, \"//property\");\n\t\tNode node = null;\n\t\tif ((node = nodeIterator.nextNode()) == null)\n\t\t\treturn;\n\t\tproperties_ = new Hashtable();\n\t\tdo {\n\t\t\tString name_ = node.getAttributes().getNamedItem(\"name\").getNodeValue();\n\t\t\tString value_ = node.getAttributes().getNamedItem(\"value\").getNodeValue();\n\t\t\tproperties_.put(name_, value_);\n\t\t\tlog.debug(\"property name=\" + name_ + \", value=\" + value_ + \" is set.\");\n\t\t} while ((node = nodeIterator.nextNode()) != null);\n\n\t}\n",
    "168034": "\tstatic public boolean isRandomizer(InputStream randinput) {\n\t\tString n = DOMHandler.parseXML(randinput).getDocumentElement().getTagName();\n\t\tboolean f = n.equals(\"randomizer\");\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"The tagname of root element is \" + n + \", \" + Boolean.toString(f));\n\t\treturn f;\n\t}\n",
    "168036": "\tstatic public boolean hasExchanger(InputStream randinput) {\n\t\tNodeList nodelist = DOMHandler.parseXML(randinput).getElementsByTagName(\"exchange\");\n\t\tboolean f = (nodelist.getLength() > 0);\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"The tagname exchange exist, \" + Boolean.toString(f));\n\t\treturn f;\n\t}\n",
    "168052": "\tstatic public Document parseXML(InputStream input) {\n\t\tDocument doc = null;\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder db;\n\t\ttry {\n\t\t\tdb = dbf.newDocumentBuilder();\n\t\t\tdb.newDocument();\n\t\t\tdoc = db.parse(input);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Error parsing XML\", e);\n\t\t}\n\t\treturn doc;\n\t}\n",
    "168054": "\tprivate void initRandomizer() throws IOException {\n\t\tdoErase();\n\t\tdoInsert();\n\t\tdoInsertBefore();\n\t\tdoWrite();\n\t\tdoMultiply();\n\t\tinitExchange();\n\t}\n",
    "168056": "    static public Document newInstance() {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            return db.newDocument();\n        } catch (Exception e) {\n\t\t\tlog.error(\"Error creating new instance of DOM Document\", e);\n        }\n        return null;\n    }\n",
    "168058": "    static public Document newInstance(String qualifiedName) {\n        Document doc = null;\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            DOMImplementation domImpl = db.getDOMImplementation();\n            doc = domImpl.createDocument(\"\", qualifiedName, null);\n        } catch (Exception e) {\n\t\t\tlog.error(\"Error creating new instance of DOM Document with the qualified name '\" + qualifiedName + \"'. \", e);\n        }\n        return doc;\n    }\n",
    "168060": "    static public Document getCapsuledDocument(Node node) {\n        Document doc = null;\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            doc = db.newDocument();\n\n            NodeList nodeList = node.getChildNodes();\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                Node childNode = nodeList.item(i);\n                if (childNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Node nodeNew = doc.importNode(childNode, true);\n                    doc.appendChild(nodeNew);\n                }\n            }\n        } catch (Exception e) {\n\t\t\tlog.error(\"Error adding the Node to a new instance of DOM Document\", e);\n        }\n        return doc;\n    }\n",
    "168063": "   static public BufferedReader getDocumentAsReader(Node node) {\n        ByteArrayOutputStream byteoutput = new ByteArrayOutputStream();\n        writeXML(node, byteoutput);\n        return new BufferedReader(new StringReader(byteoutput.toString()));\n    }\n",
    "168068": "   static public InputStream getCapsuledInputStream(Node node) {\n        return getDocumentAsInputStream(getCapsuledDocument(node));\n    }\n",
    "168109": "\tpublic void startExchange() {\n\t\tif (indexIteration_ == numIteration_) {\n\t\t\tif (childExchanger_ != null) {\n\t\t\t\tchildExchanger_.startExchange();\n\t\t\t}\n\t\t\tindexIteration_ = 0;\n\t\t}\n\t\texchange();\n\t\tindexIteration_++;\n\t}\n",
    "168157": "\tprotected void prepare() {\n\t\tcalculateRateConstants(Vm.getValue());\n\t\tsuper.prepare();\n\t}\n",
    "168158": "\tprotected void calculate(double t) {\n\t\tcalculateRateConstants(Vm.getValue());\n\t\tsuper.calculate(t);\n\t}\n",
    "168161": "\tprotected void prepare() {\n\t\tsuper.prepare();\n\t\tstates = new State[(int) number.getValue()];\n\t\tfor (int i = 0; i < states.length; i++) {\n\t\t\tstates[i] = sAP.init(Math.random());\n\t\t}\n\t}\n",
    "168162": "\tprotected void setLinks() {\n\t\tpRP = getNode(\"pRP\");\n\t\tpAP = getNode(\"pAP\");\n\t\tpAI = getNode(\"pAI\");\n\t\tpRI = getNode(\"pRI\");\n\t}\n",
    "168164": "\tprotected void prepare() {\n\t\tsuper.prepare();\n\t\tcalculateSteadyState();\n\t}\n",
    "168165": "\tprotected void calculate(double t) {\n\t\tdouble fpRP = pRP.getValue();\n\t\tdouble fpAP = pAP.getValue();\n\t\tdouble fpAI = pAI.getValue();\n\t\tdouble fpRI = 1 - (fpRP + fpAP + fpAI);\n\n\t\tpRP.addDydt(\n\t\t\t((fpAP * kAPRP) + (fpRI * kRIRP)) - (fpRP * (fkRPAP + kRPRI)));\n\t\tpAP.addDydt(\n\t\t\t((fpAI * kAIAP) + (fpRP * fkRPAP)) - (fpAP * (kAPRP + kAPAI)));\n\t\tpAI.addDydt(\n\t\t\t((fpRI * kRIAI) + (fpAP * kAPAI)) - (fpAI * (kAIRI + kAIAP)));\n\t\tpRI.setValue(fpRI);\n\t}\n",
    "168173": "\tprotected void prepare() {\n\t\tif (Phosphorylation != null && Phosphorylation.getValueString().toUpperCase().equals(\"FALSE\")) {\n\t\t\tPhosphoFlag = false;\n\t\t\tlog.info(\"IKs   is NOT phosphorylated by PKA. \");\n\t\t} else {\n\t\t\tPhosphoFlag = true;\n\t\t\tdouble kcnq1p = KCNQ1p.getValue();\n\t\t\tfinal double b = KCNQ1tot - 2 * kcnq1p  + Yottot + Kyotiao;\n\t\t\tfinal double KCNQ1_Yot = (b - Math.pow(Math.pow(b, 2) - 4 * 1 * (KCNQ1tot - kcnq1p) * (Yottot - kcnq1p), 0.5)) / 2;\n\t\t\tfinal double kcnq1_free = KCNQ1tot - KCNQ1_Yot - kcnq1p;\n\t\t\tKCNQ1free.setValue(kcnq1_free);\n\t\t\ttempi = 0;\n\t\t\tlog.info(\"IKs   is     phosphorylated by PKA. \");\n\t\t}\n\t\tsuper.prepare();\n\t}\n",
    "168236": "\tprotected void calculate(double t) {\n\t\tvalue = number * gj.getValue() * pOpen.getValue() * CONVERT_FROM_PICO_TO_NANO;\n\n\t}\n",
    "168240": "\tprotected void prepare() {\n\t\t// convert pX to mM\n\t\tdouble Ca = Math.pow(10, -1 * pX.getValue()) * 1000;\n\t\tdouble infinity = 1.0 - 1.0 / (1.0 + Math.pow((Kx / Ca), nHill));\n\n\t\t// limit the value of infinity between 0 and 1.\n\t\tif (infinity > 1.0) {\n\t\t\tinfinity = 1.0;\n\t\t} else if (infinity < 0.0) {\n\t\t\tinfinity = 0.0;\n\t\t}\n\n\t\t// calculate rate constants\n\t\tk_backward.setValue(infinity / timeconstant);\n\t\tk_forward.setValue((1.0 - infinity) / timeconstant / Math.pow(Ca, nHill));\n\t\tsuper.prepare();\n\t}\n",
    "168241": "\tprotected void calculate(double t) {\n\t\tdouble open_ = open.getValue();\n\n\t\tdouble rate = -alpha * open_ * Math.pow(ligand.getValue(), nHill)\n\t\t\t\t+ beta * close.getValue();\n\n\t\topen.addDydt(rate);\n\t\tclose.addDydt(-rate);\n\n\t\tvalue = open_;\n\n\t}\n",
    "168256": "\tprotected void prepare() {\n\t\tpermeabilityNa = permeabilityK * relativeP;\n\t\tsuper.prepare();\n\t}\n",
    "168260": "\tprotected void calculate(double t) {\n\t\t//'RATE TO E1 conformation\n\t\talpha = k2 * E2A + k4 * E2B;\n\t\t//'RATE FROM E1 conformation\n\t\tbeta = k1 * E1A + k3 * E1B;\n\n        if (gate != null) {\n\t\t\ty = gate.getValue();\n\t\t\tgate.addDydt(alpha * (1.0 - y) - beta * y);\n\n\t\t} else\n\t\t\ty = alpha / (alpha + beta);\n\n\t\ttotal = amplitude.getValue() * Cm * (y * k1 * E1A - (1.0 - y) * k2 * E2A);\n\n\t\tcNa = stoichiometryNa * total;\n\t\tcK = stoichiometryK * total;\n\t\tcCa = stoichiometryCa * total;\n\t\tsuper.calculate(t);\n\t}\n",
    "168267": "\tprotected void calculate(double dt) {\n\t\tif ((Nai != null) && (Nao != null))\n\t\t\tcNa = permeabilityNa * (Nai.getValue() - Nao.getValue());\n\t\tif ((Ki != null) && (Ko != null))\n\t\t\tcK  = permeabilityK  * (Ki.getValue() - Ko.getValue());\n\t\tif ((Cai != null) && (Cao != null))\n\t\t\tcCa = permeabilityCa * (Cao.getValue() - Cai.getValue());\n\t\ttotal = cNa + cK + cCa;\n\t\tsuper.calculate(dt);\n\t}\n",
    "168270": "\tprotected void calculate(double t) {\n\t\tif (onset <= t) {\n\t\t\tonset = onset + interval;\n\t\t\tapply = testPotential;\n\t\t}\n\t\tif (offset <= t) {\n\t\t\toffset = offset + interval;\n\t\t\tapply = holdingPotential;\n\t\t}\n\t\tdouble dt = timeStep.getValue();\n\t\tdouble delta;\n\t\t//Otherwise Iext becomes too big, resulting into overflow.\n\t\tif (dt < 0.001)\n\t\t\tdelta = 0.001 * 4.0;\n\t\telse\n\t\t\tdelta = dt * 4.0;\n\t\t//Ideal voltage clamp condition\n\t\ttotal = -current.getValue() - (apply - Vm.getValue()) * Cm / delta;\n\t\tcK = total;\n\t\tobservedCurrent.setValue(current.getValue());\n\t\tsuper.calculate(t);\n\t}\n",
    "168277": "\tprotected void prepare() {\n\t\tpermeabilityNa = permeabilityK * relativePNa;\n\t\tsuper.prepare();\n\t}\n",
    "168294": "\tprotected void calculate(double t) {\n\t\tdouble pre = target.getValue();\n\t\ttarget.setValue(\n\t\t\tinfinity - (infinity - pre) * Math.exp(-dt.getValue() / tau));\n\t}\n",
    "168302": "    protected void calculate(double dt) {\n        double newCa = Ca.getValue();\n        double totalCa = newCa + total - free.getValue();\n        for( int i = 0 ; i < REPEAT; i++) {\n            newCa = totalCa / (1.0 + (free.getValue() / Km));\n            free.setValue(total / (1.0 + ( newCa / Km)));\n        }\n        Ca.setValue(newCa);\n    }\n",
    "168311": "\tprivate double calc_Fp(double deltaL) {\n\t\treturn KForceEC * Math.pow(deltaL, 5) + KForceLinearEc * (deltaL);\n\t}\n",
    "168313": "\tprotected void calculate(double t) {\n\t\tsuper.calculate(t);\n\t\tforceExt.setValue(-ForceEcomp + forceCB.getValue());\n\t}\n",
    "168318": "\tprotected void calculate(double t) {\n\t\t//set alias\n\t\thalfSL_ = halfsarcomerelength.getValue();\n\t\th_ = halfSL_ - InextensibleLength.getValue();\n\n\t\th.setValue(h_);\n\t\t// ' new slope of the linear relationship\n\t\tNewCBF = forceFactor * troponin.getCBbound();\n\t\t//'initial value to determine the new half sarcomere length.\n\t\tForceEcomp = KForceEC * Math.pow((ZeroForceEL - halfSL_), 5)\n\t\t\t\t+ KForceLinearEc * (ZeroForceEL - halfSL_);\n\t\tforceCB.setValue(NewCBF * h_);\n\t\tdydtCBL = SlidingRate * (h_ - LowerLimitCB);\n\t\tInextensibleLength.addDydt(dydtCBL);\n\t}\n",
    "168372": "\tprotected void calculate(final double t) {\n\t\t// \"natural\" Buffering capacity for H<sup>+</sup>\n\t\tdouble C0 = (Math.pow(10, - pH.getValue()) - Math.pow(10, (- pH.getValue() - dpH))) / dpH;\n\t\tsetValue(cbuffer / C0);\n\t}\n",
    "168393": "\tprotected void calculate(double t) {\n\t\t//'RATE TO E1 conformation\n\t\talpha = k2 * E2A + k4 * E2B;\n\t\t//'RATE FROM E1 conformation\n\t\tbeta = k1 * E1A + k3 * E1B;\n\t\t\n\t\t// always use differential equation.\n\t\ty = gate.getValue();\n\t\tgate.addDydt(alpha * (1.0 - y) - beta * y);\n\n\t\t// inactivation gate is incorporated\n\t\ttotal = amplitude.getValue() * Cm * (y * k1 * E1A - (1.0 - y) * k2 * E2A)\n\t\t\t\t* (1 - inactive);\n\n\t\tcNa = stoichiometryNa * total;\n\t\tcK = stoichiometryK * total;\n\t\tcCa = stoichiometryCa * total;\n\t\tsuper.calculate(t);\n\t}\n",
    "168425": "\tprotected void calculate(double dt) {\n\t\tif ((Nai != null) && (Nao != null))\n\t\t\tcNa = permeabilityNa * (Nai.getValue() - Nao.getValue()) * Cm;\n\t\tif ((Ki != null) && (Ko != null))\n\t\t\tcK = permeabilityK * (Ki.getValue() - Ko.getValue()) * Cm;\n\t\tif ((Cai != null) && (Cao != null))\n\t\t\tcCa = permeabilityCa * (Cao.getValue() - Cai.getValue()) * Cm;\n\t\tif ((Cli != null) && (Clo != null))\n\t\t\tcCl = permeabilityCl * (Clo.getValue() - Cli.getValue()) * Cm;\n\t\ttotal = cNa + cK + cCa + cCl;\n\t\tsuper.calculate(dt);\n\t}\n",
    "168437": "\tprotected void calculate(double t) {\n\t\tdouble gamma = amplitude * Math.pow((Ko.getValue() / constant), power);\n\t\t// K+ permeability was prepared using the membrane capacitance (Cm0 =\n\t\t// 132).\n\t\tdouble Cm0 = 132;\n\t\tdouble permeabilityK = number * gamma / Cm0;\n\t\tsetValue(permeabilityK);\n\t}\n",
    "168443": "\tprotected void prepare() {\n\t\tcalculate(0);\n\t}\n",
    "168447": "\tprotected void end() {\n\t\tcalculate(0);\n\t\tsuper.end();\n\t}\n",
    "168465": "\tprotected void calculate(double t) {\n\t\t//set alias\n\t\tdouble L_ = L.getValue();\n\t\tX_ = X.getValue();\n\n\t\tfactorCB = A * (TCaCB.getValue() + TCB.getValue());\n\n\t\tif (false) L_ = solve_by_modified_bisection(L_);\n        else L_ = solve_by_Secant(L_);\n        \n\t\tL.setValue(L_);\n\n\t\tsuper.calculate(t);\n\t}\n",
    "168470": "\tprivate double solve_by_modified_bisection(double L_) {\n\t\tdouble ProductA = product(L_);\n        double h = L_ - X_;\n\t\tdouble Resolution, ProductB;\n\t\tif (0 <= ProductA)\n\t\t\t//'elongation of cross bridge\n\t\t\tResolution = 0.000005;\n\t\telse\n\t\t\t//'shortening of cross bridge\n\t\t\tResolution = -0.000005;\n\t\tdo {\n\t\t\tProductB = ProductA;\n\t\t\tif (ProductB == 0)\n\t\t\t\tbreak;\n\t\t\t//change in h\n\t\t\th = h + Resolution;\n\t\t\t//change in halfSL\n\t\t\tL_ = X_ + h;\n\t\t\tif (L_ > La)\n\t\t\t\t//avoid endless cycle due to an error.\n\t\t\t\tbreak;\n\t\t\tProductA = product(L_);\n\t\t} while ((ProductA * ProductB) > 0);\n        return L_;\n\t}\n",
    "168500": "    public void updateUI() {\n\tsuper.updateUI();\n\tif(tree != null) {\n\t    tree.updateUI();\n\t    // Do this so that the editor is referencing the current renderer\n\t    // from the tree. The renderer can potentially change each time\n\t    // laf changes.\n\t    setDefaultEditor(TreeTableModel.class, new TreeTableCellEditor());\n\t}\n\t// Use the tree's default foreground and background colors in the\n\t// table. \n        LookAndFeel.installColorsAndFont(this, \"Tree.background\",\n                                         \"Tree.foreground\", \"Tree.font\");\n    }\n",
    "168507": "    public int getEditingRow() {\n        return (getColumnClass(editingColumn) == TreeTableModel.class) ? -1 :\n\t        editingRow;  \n    }\n",
    "168513": "    private int realEditingRow() {\n\treturn editingRow;\n    }\n",
    "168519": "    public void sizeColumnsToFit(int resizingColumn) { \n\tsuper.sizeColumnsToFit(resizingColumn);\n\tif (getEditingColumn() != -1 && getColumnClass(editingColumn) ==\n\t    TreeTableModel.class) {\n\t    Rectangle cellRect = getCellRect(realEditingRow(),\n\t\t\t\t\t     getEditingColumn(), false);\n            Component component = getEditorComponent();\n\t    component.setBounds(cellRect);\n            component.validate();\n\t}\n    }\n",
    "168525": "    public void setRowHeight(int rowHeight) { \n        super.setRowHeight(rowHeight); \n\tif (tree != null && tree.getRowHeight() != rowHeight) {\n            tree.setRowHeight(getRowHeight()); \n\t}\n    }\n",
    "168526": "    protected void delayedFireTableDataChanged() {\n\tSwingUtilities.invokeLater(new Runnable() {\n\t    public void run() {\n\t\tfireTableDataChanged();\n\t    }\n\t});\n    }\n",
    "168532": "\tpublic void testPlot() throws Exception {\n\t\tEntry.main( new String[] { PROTOCOL_XML } );\n\t}\n",
    "168533": "    public JTree getTree() {\n\treturn tree;\n    }\n",
    "168535": "\tpublic void testUpdateComponent() throws Exception {\n\t\tInputSource is = new InputSource(new FileInputStream(\n\t\t\t\tMATSUOKA_ET_AL_2003));\n\t\tSerializer serializer = SerializerFactory.getSerializer(is);\n\t\tassertNotNull(serializer);\n\n\t\tComposite model = Run.start(serializer, MATSUOKA_ET_AL_2003, null);\n\n\t\tis = new InputSource(new FileInputStream(MATSUOKA_ET_AL_2003));\n\t\tFile file = FileHandler.getNewFile(\"target/results/\" + getName()\n\t\t\t\t+ \".xml\");\n\t\tserializer.update(model, new FileOutputStream(file), is);\n\t}\n",
    "168537": "\tpublic void testReadDuplicateNode() {\n\t\tInputSource source = new InputSource(\n\t\t\t\t\"src/test/resources/org/simBio/serialize/xml/duplicateNode.xml\");\n\t\tXMLSerializer serializer = new XMLSerializer(source);\n\t\ttry {\n\t\t\tserializer.read();\n\t\t\tfail(\"This file has a duplicate and an exception should have been thrown\");\n\t\t} catch (InstantiationException e) {\n\t\t\t// We expect an exception to occur\n\t\t\tassertTrue(true);\n}\n\t}\n",
    "168539": "\tpublic void testRead() {\n\t\tInputSource source = new InputSource(MATSUOKA_ET_AL_2003);\n\t\tXMLSerializer serializer = new XMLSerializer(source);\n\t\ttry {\n\t\t\tserializer.read();\n\t\t} catch (InstantiationException e) {\n\t\t\tfail(\"This xml file does not contain errors, so an exception should not be thrown\");\n\t\t\te.printStackTrace();\n\t\t\tassertFalse(true);\n\t\t}\n\t}\n",
    "168542": "\tpublic void testRepetition() throws Exception {\n\t\t// usually this test can be skipped.\n\t\tif (true) return;\n\t\t\n\t\tString[] ss = {\"src/test/resources/org/simBio/core/compare_HH.xml\"};\n\t\tResultGenerator.main(ss);\n\n\t\tString s = \"org.simBio.bio.hodgkin_huxley_1952.HH\";\n\t\tString f = \"target/IBMJDK142\";\n\t\tFile folder = new File(f);\n\t\tif (!folder.exists()) folder.mkdirs();\n        new Driver(s, f + \"/1st.csv\");\n        new Driver(s, f + \"/2nd.csv\");\n        new Driver(s, f + \"/3rd.csv\");\n    }\n",
    "168544": "    public boolean editCellAt(int row, int column, EventObject e){\n\tboolean retValue = super.editCellAt(row, column, e);\n\tif (retValue && getColumnClass(column) == TreeTableModel.class) {\n\t    repaint(getCellRect(row, column, false));\n\t}\n\treturn retValue;\n    }\n",
    "168547": "    private void csvWrite(double t) throws IOException {\n        if ((t < offset ) && (csvTiming < t)) {\n            csvFile.write(\"\" + t);\n            for (int i = 0; i < model.Y.length; i++) {\n                csvFile.write(\", \");\n                csvFile.write(Double.toString(model.Y[i]));\n            }\n            csvFile.newLine();\n            csvTiming += csvInterval;\n        }\n    }\n",
    "168549": "    private void csvOpen() throws IOException {\n        csvFile = new BufferedWriter(new FileWriter(fileName));\n    }\n",
    "168551": "\tpublic void testMultiThreads() {\n\t\tString[] s1 = {\"src/test/resources/org/simBio/Fig.1B.protocolStub.xml\"};\n\t\tResultGenerator.main(s1);\n\t}\n",
    "168552": "    private void csvClose() throws IOException {\n        csvFile.close();\n    }\n",
    "168553": "\tpublic void updateUI() {\n\t    super.updateUI();\n\t    // Make the tree's cell renderer use the table's cell selection\n\t    // colors. \n\t    TreeCellRenderer tcr = getCellRenderer();\n\t    if (tcr instanceof DefaultTreeCellRenderer) {\n\t\tDefaultTreeCellRenderer dtcr = ((DefaultTreeCellRenderer)tcr); \n\t\t// For 1.1 uncomment this, 1.2 has a bug that will cause an\n\t\t// exception to be thrown if the border selection color is\n\t\t// null.\n\t\t// dtcr.setBorderSelectionColor(null);\n\t\tdtcr.setTextSelectionColor(UIManager.getColor\n\t\t\t\t\t   (\"Table.selectionForeground\"));\n\t\tdtcr.setBackgroundSelectionColor(UIManager.getColor\n\t\t\t\t\t\t(\"Table.selectionBackground\"));\n\t    }\n\t}\n",
    "168554": "\tpublic void testModify1() throws Exception {\n\t\tResultGenerator resultGen = new ResultGenerator();\n\t\tfinal Class c[] = new Class[2];\n\t\tc[0] = Class.forName(\"java.lang.String\");\n\t\tc[1] = Class.forName(\"java.io.InputStream\");\n\t\tfinal Method method = resultGen.getClass().getDeclaredMethod(\"modify\",\n\t\t\t\tc);\n\t\tfinal Object params[] = {\n\t\t\t\tnull,\n\t\t\t\tnew FileInputStream(\n\t\t\t\t\t\t\"src/xml/terashima_et_al_2006/Fig.5.make.xml\") };\n\t\tmethod.setAccessible(true);\n\t\ttry {\n\t\t\tmethod.invoke(resultGen, params);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tfail(\"The underlying method raise an Exception\");\n\t\t}\n\t}\n",
    "168555": "\tpublic void testPlot() throws Exception {\n\t\tParameterSpace ps = new ParameterSpace(null, null);\n\t\tPlotLouncher pl = new PlotLouncher();\n\t\t// Set values for the plots\n\t\tNCXvsCaL.settings();\n\t\t// Overwrite the NCXvsCaL settings for the flag isPlots\n\t\tPlotLouncher.isPlots = isPlots;\n\t\t// Make a XY-plot and a contour plot\n\t\tpl.numPlots = 2;\n\t\tps.addParamSpaceObservers(pl);\n\t\tLogSax2 saxHandler = new TocReader(ps);\n\t\tSAXParser saxParser = SAXParserFactory.newInstance().newSAXParser();\n\t\tsaxParser.parse(new InputSource(TOC_XML), saxHandler);\n\t}\n",
    "168556": "\tpublic void testModify2() throws Exception {\n\t\tResultGenerator resultGen = new ResultGenerator();\n\t\tfinal Class c[] = new Class[2];\n\t\tc[0] = Class.forName(\"java.lang.String\");\n\t\tc[1] = Class.forName(\"java.io.InputStream\");\n\t\tfinal Method method = resultGen.getClass().getDeclaredMethod(\"modify\",\n\t\t\t\tc);\n\t\tfinal Object params[] = { null, null };\n\t\tmethod.setAccessible(true);\n\t\ttry {\n\t\t\tmethod.invoke(resultGen, params);\n\t\t\tfail(\"The underlying method should raise an Exception\");\n\t\t} catch (InvocationTargetException success) {\n\t\t\t// success\n\t\t}\n\t}\n",
    "168558": "\tpublic void testElapsedGreaterThanExpected() {\n\t\tdouble duration = initialMax - initialMin;\n\t\telapsedTimeNode.setValue(401);\n\t\telapsedTime = elapsedTimeNode.getValue();\n\n\t\tg.end();\n\t\tassertEquals(elapsedTime - duration, axisX.getNodeRecursive(\"min\")\n\t\t\t\t.getValue(), 0.0);\n\t\tassertEquals(elapsedTime, axisX.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168561": "\tpublic void setRowHeight(int rowHeight) { \n\t    if (rowHeight > 0) {\n\t\tsuper.setRowHeight(rowHeight); \n\t\tif (JTreeTable.this != null &&\n\t\t    JTreeTable.this.getRowHeight() != rowHeight) {\n\t\t    JTreeTable.this.setRowHeight(getRowHeight()); \n\t\t}\n\t    }\n\t}\n",
    "168563": "\tpublic void testPDataBetweenMinAndMax() {\n\t\tlog.info(\"testDataBetweenMinAndMax()\");\n\t\taxis.p(450, plot, true);\n\n\t\tassertEquals(400, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168565": "\tpublic void testPDataLessThanMin() {\n\t\tdouble delta = (axis.min - axis.max) * scalefactorValue;\n\t\taxis.p(390, plot, true);\n\n\t\tassertEquals(400 + delta, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800 + delta, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168566": "\tpublic void testMain1() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest1.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t        fail(\"Should raise an RuntimeException\");\n\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168567": "\tpublic void setBounds(int x, int y, int w, int h) {\n\t    super.setBounds(x, 0, w, JTreeTable.this.getHeight());\n\t}\n",
    "168568": "\tpublic void testMain2() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest2.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t        fail(\"Should raise an RuntimeException\");\n\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168569": "\tpublic void testPDataGreaterThanMax() {\n\t\tdouble delta = (axis.max - axis.min) * scalefactorValue;\n\t\taxis.p(810, plot, true);\n\n\t\tassertEquals(400 + delta, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800 + delta, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168570": "\tpublic void testMain3() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest3.xml\"};\n\t\ttry {\n\t\tResultGenerator.main(ss);\n        fail(\"Should raise an RuntimeException\");\n\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168571": "\tpublic void testMain4() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest4.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t\t\tfail(\"Should raise an RuntimeException\");\n\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168572": "\tpublic void testPDataBetweenMinAndMaxModeFixed() {\n\t\taxis.extendMode = axis.MODE_FIXED;\n\t\taxis.p(450, plot, true);\n\n\t\tassertEquals(400, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168574": "\tpublic void testMain5() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest5.xml\"};\n\t\tResultGenerator.main(ss);\n\t}\n",
    "168575": "\tpublic void paint(Graphics g) {\n\t    g.translate(0, -visibleRow * getRowHeight());\n\t    super.paint(g);\n\t    // Draw the Table border if we have focus.\n\t    if (highlightBorder != null) {\n\t\thighlightBorder.paintBorder(this, g, 0, visibleRow *\n\t\t\t\t\t    getRowHeight(), getWidth(),\n\t\t\t\t\t    getRowHeight());\n\t    }\n\t}\n",
    "168576": "\tpublic void testMain6() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest6.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t\t\tfail(\"Should raise an RuntimeException\");\n\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168577": "\tpublic void testPDataLessThanMinModeFixed() {\n\t\taxis.extendMode = axis.MODE_FIXED;\n\t\taxis.p(390, plot, true);\n\n\t\tassertEquals(400, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168578": "\tpublic void testMain7() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest7.xml\"};\n\t\tResultGenerator.main(ss);\n\t}\n",
    "168579": "\tpublic void testPDataGreaterThanMaxModeFixed() {\n\t\taxis.extendMode = axis.MODE_FIXED;\n\t\taxis.p(810, plot, true);\n\n\t\tassertEquals(400, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168580": "\tpublic void testMain8() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest8.xml\"};\n\t\tResultGenerator.main(ss);\n\t}\n",
    "168581": "\tpublic void testMain9() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest9.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t        fail(\"Should raise an RuntimeException\");\n\t\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168583": "\tpublic void testPDataBetweenMinAndMaxModeAutoscale() {\n\t\taxis.extendMode = axis.MODE_AUTOSCALE;\n\t\taxis.p(450, plot, true);\n\n\t\tassertEquals(400, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168584": "\tpublic void testMain10() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest10.xml\"};\n\t\tResultGenerator.main(ss);\n\t}\n",
    "168585": "\tpublic void testMain11() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest11.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t        fail(\"Should raise an RuntimeException\");\n\t\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168586": "\tpublic void testPDataLessThanMinModeAutoscale() {\n\t\taxis.extendMode = axis.MODE_AUTOSCALE;\n\t\tdouble delta = (axis.min - axis.max) * scalefactorValue;\n\t\taxis.p(390, plot, true);\n\n\t\tassertEquals(400 + delta, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168587": "\tpublic void testMain12() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest12.xml\"};\n\t\tResultGenerator.main(ss);\n\t}\n",
    "168589": "\tpublic void testMain13() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest13.xml\"};\n\t\tResultGenerator.main(ss);\n\t}\n",
    "168591": "\tpublic void testMain14() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest14.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t        fail(\"Should raise an RuntimeException\");\n\t\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168593": "\tpublic void testPDataGreaterThanMaxModeAutoscale() {\n\t\taxis.extendMode = axis.MODE_AUTOSCALE;\n\t\tdouble delta = (axis.max - axis.min) * scalefactorValue;\n\t\taxis.p(810, plot, true);\n\n\t\tassertEquals(400, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800 + delta, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168594": "\tpublic void testMain15() {\n\t\tString[] ss = {\"src/test/resources/org/simBio/sim/dm/makeTest15.xml\"};\n\t\ttry {\n\t\t\tResultGenerator.main(ss);\n\t        fail(\"Should raise an RuntimeException\");\n\t\t\t} catch (RuntimeException success) {}\n\t}\n",
    "168595": "\tpublic void testParameterChanger1() {\n\t\ttry {\n\t\t\tnew ParameterChanger(null, inputStreamModel);\n\t\t\tfail(\"Should raise an IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException success) {}\n\t}\n",
    "168598": "\tpublic void testParameterChanger2() {\n\t\ttry {\n\t\t\tnew ParameterChanger(inputStreamModel, null);\n\t\t\tfail(\"Should raise an IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException success) {}\n\t}\n",
    "168599": "\tpublic void testParameterChanger3() {\n\t\ttry {\n\t\t\tnew ParameterChanger(null, null);\n\t\t\tfail(\"Should raise an IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException success) {}\n\t}\n",
    "168600": "\tpublic void testPDataLessThanMinLowerExtendRate() {\n\t\tchangeScaleFactorValue(0.9);\n\t\tdouble delta = (axis.min - axis.max) * scalefactorValue;\n\t\taxis.p(390, plot, true);\n\n\t\tassertEquals(400 + delta, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800 + delta, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168601": "\tpublic void testParameterChanger4() {\n\t\ttry {\n\t\t\tnew ParameterChanger(null);\n\t\t\tfail(\"Should raise an IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException success) {}\n\t}\n",
    "168602": "\tpublic void testIsRandomizer() {\n\t\t// randinput is randomizer\n\t\tassertTrue(ParameterChanger.isRandomizer(inputStreamProtocol));\n\t\t// randinput is not randomizer\n\t\tassertFalse(ParameterChanger.isRandomizer(inputStreamModel));\n\t}\n",
    "168604": "\tpublic void testHasExchanger() {\n\t\t// randinput has exchanger\n\t\tassertTrue(ParameterChanger.hasExchanger(inputStreamProtocol));\n\t\t// randinput has no exchanger\n\t\tassertFalse(ParameterChanger.hasExchanger(inputStreamModel));\n\t}\n",
    "168605": "\tpublic void testPDataGreaterThanMaxLowerExtendRate() {\n\t\tchangeScaleFactorValue(0.9);\n\t\tdouble delta = (axis.max - axis.min) * scalefactorValue;\n\t\taxis.p(810, plot, true);\n\n\t\tassertEquals(400 + delta, axis.getNodeRecursive(\"min\").getValue(), 0.0);\n\t\tassertEquals(800 + delta, axis.getNodeRecursive(\"max\").getValue(), 0.0);\n\t}\n",
    "168607": "\tpublic void testDoErase() throws Exception {\n\t\tfinal Method method = changerMake.getClass().getDeclaredMethod(\"doErase\", null);\n\t\tmethod.setAccessible(true);\n\t\ttry {\n\t\t\tmethod.invoke(changerMake, null);\n\t\t\tfail(\"The underlying method should raise an Exception\");\n\t    } catch (InvocationTargetException success) {}\n\t}\n",
    "168609": "\tpublic void testDoInsert() throws Exception {\n\t\tfinal Method method = changerMake.getClass().getDeclaredMethod(\"doInsert\", null);\n\t\tmethod.setAccessible(true);\n\t\tmethod.invoke(changerMake, null);\n\t}\n",
    "168611": "\tpublic void resetRowSelection() {\n\t    if(!updatingListSelectionModel) {\n\t\tupdatingListSelectionModel = true;\n\t\ttry {\n\t\t    super.resetRowSelection();\n\t\t}\n\t\tfinally {\n\t\t    updatingListSelectionModel = false;\n\t\t}\n\t    }\n\t    // Notice how we don't message super if\n\t    // updatingListSelectionModel is true. If\n\t    // updatingListSelectionModel is true, it implies the\n\t    // ListSelectionModel has already been updated and the\n\t    // paths are the only thing that needs to be updated.\n\t}\n",
    "168612": "\tpublic void testDoInsertBefore() throws Exception {\n\t\tfinal Method method = changerMake.getClass().getDeclaredMethod(\"doInsertBefore\", null);\n\t\tmethod.setAccessible(true);\n\t\tmethod.invoke(changerMake, null);\n\t}\n",
    "168613": "\tpublic void testGetBaseModel1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getBaseModel());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168614": "\tpublic void testDoWrite() throws Exception {\n\t\tfinal Method method = changerMake.getClass().getDeclaredMethod(\"doWrite\", null);\n\t\tmethod.setAccessible(true);\n\t\tmethod.invoke(changerMake, null);\n\t}\n",
    "168615": "\tpublic void testGetBaseModel2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getBaseModel());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n\t}\n",
    "168616": "    protected void setUp() throws FileNotFoundException { \n\t\tinputStreamProtocol = new FileInputStream(\"src/test/resources/org/simBio/sim/dm/protocol_A.xml\");\n\t\tinputStreamModel = new FileInputStream(\"src/xml/matsuoka_et_al_2003/model.xml\");\n    \t\n\t\tchangerMake= new ParameterChanger(new FileInputStream(\"src/xml/terashima_et_al_2006/Fig.5.make.xml\"));\n\t\tchangerModel= new ParameterChanger(new FileInputStream(\"src/xml/matsuoka_et_al_2003/model.xml\"), new FileInputStream(\"src/xml/matsuoka_et_al_2003/model.xml\"));\n    }\n",
    "168617": "\tpublic void testGetGenerateModel1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getGenerateModel());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168618": "\tprotected ListSelectionListener createListSelectionListener() {\n\t    return new ListSelectionHandler();\n\t}\n",
    "168619": "\tpublic void testGetGenerateMode2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getGenerateModel());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n\t}\n",
    "168621": "\tpublic void testGetMaxThreads1() {\n\t\tassertEquals(\"Error in max threads, should be '4' in the protocol, \",\n\t\t\t\t\t4, protocolParserProtocol.getMaxThreads());\n\t}\n",
    "168622": "\tprotected void updateSelectedPathsFromSelectedRows() {\n\t    if(!updatingListSelectionModel) {\n\t\tupdatingListSelectionModel = true;\n\t\ttry {\n\t\t    // This is way expensive, ListSelectionModel needs an\n\t\t    // enumerator for iterating.\n\t\t    int        min = listSelectionModel.getMinSelectionIndex();\n\t\t    int        max = listSelectionModel.getMaxSelectionIndex();\n\n\t\t    clearSelection();\n\t\t    if(min != -1 && max != -1) {\n\t\t\tfor(int counter = min; counter <= max; counter++) {\n\t\t\t    if(listSelectionModel.isSelectedIndex(counter)) {\n\t\t\t\tTreePath     selPath = tree.getPathForRow\n\t\t\t\t                            (counter);\n\n\t\t\t\tif(selPath != null) {\n\t\t\t\t    addSelectionPath(selPath);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tfinally {\n\t\t    updatingListSelectionModel = false;\n\t\t}\n\t    }\n\t}\n",
    "168623": "\tpublic void testGetMaxThreads2() {\n\t\tassertEquals(\"Error in max threads, should not exist in the model and therefore be set to '1', \",\n\t\t\t\t\t1, protocolParserMake.getMaxThreads());\n\t}\n",
    "168624": "\tpublic void testModelXmlFiles() throws Exception {\n\t\t\n\t\t// Run models in GUI\n\t\tRunModelInGUI(modelStringList, runComplete);\n\t\t\n\t}\n",
    "168626": "\tpublic void testGetLauncher1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getLauncher());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168628": "\tpublic void testMakeXmlFiles() throws Exception {\n\t\t\n\t\t// Generate model\n\t\tEntry.main(makeStringList);\n\t\t\n\t\t// Run Generated models in GUI\n\t\tRunModelInGUI(generateModelStringList, runComplete);\n\t\t\n\t}\n",
    "168629": "\tpublic void testGetLauncher2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getLauncher());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168633": "\tpublic void testGetEraser1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getEraser());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168638": "\tpublic void testGetEraser2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getEraser());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168639": "\tpublic void run(IAction action) {\n\t\ttry {\n\t\t\tILaunchConfiguration config = createLaunchConfig();\n\t\t\tconfig.launch(ILaunchManager.RUN_MODE, null);\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n",
    "168640": "\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t\tss = (StructuredSelection) selection;\n\t}\n",
    "168641": "\tpublic void testGetInserter1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getInserter());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168646": "\tpublic void testGetInserter2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getInserter());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168650": "\tpublic void testGetInserterBefore1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getInserterBefore());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168653": "\tpublic void run(IAction action) {\n\t\ttry {\n\t\t\tILaunchConfiguration config = createLaunchConfig();\n\t\t\tILaunch launch = config.launch(ILaunchManager.RUN_MODE, null);\n\t\t\twhile (!launch.isTerminated()){\n\t\t\t\t//xml\u751f\u6210\u304c\u7d42\u4e86\u3059\u308b\u307e\u3067\u5f85\u6a5f.\n\t\t\t\t//\u3053\u306e\u65b9\u6cd5\u3067\u306f\u3001\u5f85\u6a5f\u3057\u3066\u3044\u308b\u9593\u3001Eclipse\u304c\u53cd\u5fdc\u3057\u306a\u304f\u306a\u308b\u3002\n\t\t\t\tThread.sleep(10);\n\t\t\t}\n\t\t\t// Eclipse\u3068file system\u3092\u540c\u671f\u3055\u305b\u3001\u751f\u6210\u3057\u305fxml\u3092\u8a8d\u8b58\u3055\u305b\u308b\u3002\n\t\t\tIterator it = ss.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\t((ICompilationUnit) it.next()).getCorrespondingResource().getParent().refreshLocal(IResource.DEPTH_INFINITE, null);\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n",
    "168654": "\tpublic void testGetInserterBefore2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getInserterBefore());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168657": "\tpublic void testGetWriter1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getWriter());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168666": "\tpublic void testGetWriter2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getWriter());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168673": "\tpublic void testGetMultiplier1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserMake.getMultiplier());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168678": "\tpublic void testGetMultiplier2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getMultiplier());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168684": "\tpublic void testGetExchanger1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserProtocol.getExchanger());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168690": "\tpublic void testGetExchanger2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getExchanger());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168694": "\tpublic void testGetIdentification1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserProtocol.getIdentification());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168698": "\tpublic void testGetIdentification2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getIdentification());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168701": "\tpublic void testGetXmlRootDir1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserProtocol.getXmlRootDir());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168703": "\tpublic void testGetXmlRootDir2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getXmlRootDir());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168705": "\tpublic void testGetCsvRootFile1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserProtocol.getCsvRootFile());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168708": "\tpublic void testGetCsvRootFile2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getCsvRootFile());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168712": "\tpublic void testGetTocXML1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserProtocol.getTocXML());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168715": "\tpublic void testGetTocXML2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getTocXML());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168717": "\tpublic void testGetNormalizeTo1() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserProtocol.getNormalizeTo());\n\t\t} catch (IOException e) {\n\t\t\tfail(\"IOException\");\n\t\t}\n\t}\n",
    "168720": "\tpublic void testGetNormalizeTo2() {\n\t\ttry {\n\t\t\tassertNotNull(protocolParserModel.getNormalizeTo());\n\t\t\tfail(\"Should raise an IOException\");\n\t\t} catch (IOException success) {}\n    }\n",
    "168724": "    protected void setUp() throws FileNotFoundException { \n    \tprotocolParserMake = new ProtocolParser(new FileInputStream(\"src/test/resources/org/simBio/sim/dm/makeStub.xml\"));\n    \tprotocolParserProtocol = new ProtocolParser(new FileInputStream(\"src/test/resources/org/simBio/3A_NCXvsCaLStub.xml\"));\n    \tprotocolParserModel = new ProtocolParser(new FileInputStream(\"src/xml/matsuoka_et_al_2003/model.xml\"));\n    }\n",
    "168727": "    protected void setDefaultSelected(boolean b) {\n        defaultSelected = b;\n    }\n",
    "168728": "    protected boolean isDefaultSelected() {\n        return defaultSelected;\n    }\n",
    "168731": "    protected SelectObjectTableModel getModel(boolean selected, String[] columnNames) {\n        Object[][] value = new Object[object.length][2];\n\n        for (int i = 0; i < object.length; i++) {\n            value[i][0] = new Boolean(selected);\n            value[i][1] = object[i];\n        }\n\n        SelectObjectTableModel model = new SelectObjectTableModel(value, columnNames);\n        return model;\n    }\n",
    "168732": "    protected boolean isSaved() {\n        return isSaved;\n    }\n",
    "168734": "    protected JTable getTable() {\n        return table;\n    }\n",
    "168736": "    protected void addSelectedObject(Object o) {\n        Object[] objectNew = new Object[selectedObjects.length + 1];\n\n        for (int i = 0; i < selectedObjects.length; i++) {\n            objectNew[i] = selectedObjects[i];\n        }\n\n        objectNew[selectedObjects.length] = o;\n        selectedObjects = objectNew;\n    }\n",
    "168739": "    protected void cancel() {\n        isSaved = false;\n        this.dispose();\n    }\n",
    "168754": "    private JScrollPane createTable() {\n        String[] columnNames = {colOneName, colTwoName};\n        int[] columnWidth = {10, 100,};\n\n        table = new JTable(getModel(defaultSelected, columnNames));\n\n        for (int i = 0; i < columnNames.length; i++) {\n            table.getColumn(columnNames[i]).setPreferredWidth(columnWidth[i]);\n        }\n\n        JScrollPane scroll = new JScrollPane(table);\n        return scroll;\n    }\n",
    "168756": "    private void inizialize() {\n        Container contenPane = getContentPane();\n        contenPane.add(createTable());\n        contenPane.add(createButtons(), BorderLayout.SOUTH);\n    }\n",
    "168782": "    public boolean isCellEditable(int row, int col) {\n        return (col == 0) ? true : false;\n    }\n",
    "168783": "    public Class getColumnClass(int col) {\n        Vector vector = (Vector) dataVector.elementAt(0);\n        return (vector != null) ? vector.elementAt(col).getClass() : null;\n    }\n",
    "168816": "\tpublic void setSpieler(int position, byte taktic, ISpieler player) {\n\t\tif (position>11) {\n\t\t\treturn;\n\t\t}\n\t\tsetSpielerAtPosition(position,player.getSpielerID(),taktic);\n\t\tplayers[position-1]=player;\n\n\t}\n",
    "168833": "    public byte getPosition() {\n        return SpielerPosition.getPosition(m_iId, m_bTaktik);\n    }\n",
    "168857": "    private JPanel createPanel(String string, JCheckBox checkBox) {\n        final JPanel panel = new JPanel();\n        panel.setLayout(new BorderLayout());\n        panel.setOpaque(false);\n\n        final JPanel innerPanel = new JPanel();\n\n        //innerPanel.setLayout(new BorderLayout());\n        innerPanel.add(checkBox);\n        innerPanel.add(new JLabel(string, JLabel.LEFT));\n        innerPanel.setOpaque(false);\n        panel.add(innerPanel, BorderLayout.WEST);\n        return panel;\n    }\n",
    "168863": "    private void jbInit() {\n        initListeners();\n\n        final JPanel mainPanel = new JPanel();\n        mainPanel.setLayout(new GridLayout(automatic.length+2, 1));\n        mainPanel.setOpaque(false);\n        mainPanel.add (new JLabel()); // empty\n        for (int type=0; type < automatic.length; type++) {\n        \tmainPanel.add(createPanel(PluginProperty.getString(\"Option.Auto\") + \" \"\n        \t\t\t+ PluginProperty.getString(\"FeedbackType.\"+type), \n        \t\t\tautomatic[type]));\n        }\n        mainPanel.add (new JLabel()); // empty\n        setLayout(new BorderLayout());\n        setOpaque(false);\n        add(mainPanel, BorderLayout.CENTER);\n    }\n",
    "168871": "    private int upload(FeedbackObject fo) {\n        try {\n            // Create URL and open it\n            String url = fo.createUrl();\n//            System.out.println (\"Opening: \"+url);\n        \tif (url != null) {\n        \t\tString result = Commons.getModel().getDownloadHelper()\n    \t\t\t\t.getUsalWebPage(url,false);\n        \t\tif (result.toLowerCase().equals(\"success\") ||\n        \t\t\t\tresult.toLowerCase().equals(\"skipped\"))\n        \t\t\treturn FeedbackConstants.UPLOAD_OK;\n        \t\telse if (result.toLowerCase().equals(\"stop\"))\n        \t\t\treturn FeedbackConstants.UPLOAD_STOP;\n        \t\telse\n        \t\t\tSystem.out.println(\"Result='\"+result+\"'\");\n        \t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println (\"Feedback.upload: Exception catched\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn FeedbackConstants.UPLOAD_FAILED;\n    }\n",
    "168992": "\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer(\"--- NtPlayerPosition - \" + name + \" (\" + playerId + \") ---\");\n\t\tsb.append(\"\\n\\trole / posi / behaviour: \" + roleId + \" / \" + positionCode + \" / \" + behaviour);\n\t\tsb.append(\"\\n\\tRatingstars: \" + ratingStars);\n\t\treturn sb.toString();\n\t}\n",
    "169031": "\tprivate DnDJToolBar getJToolBar() {\n\t\tif (jToolBar == null) {\n\t\t\tjToolBar = new DnDJToolBar();\n\t\t\tjToolBar.setOrientation(javax.swing.JToolBar.HORIZONTAL);\n\t\t\tjToolBar.setFont(new java.awt.Font(\"Dialog\", 0, 8));\n\t\t\tjToolBar.setMinimumSize(new java.awt.Dimension(82, 20));\n\t\t\tjToolBar.setPreferredSize(new java.awt.Dimension(82, 20));\n\t\t}\n\t\treturn jToolBar;\n\t}\n",
    "169074": "    public void addApperarence() {\n        apperarence++;\n    }\n",
    "169076": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"Player[\");\n        buffer.append(\"apperarence = \" + apperarence);\n        buffer.append(\"playerId = \" + playerId);\n        buffer.append(\", name = \" + name);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169079": "    public void setAge(int i) {\n        age = i;\n    }\n",
    "169081": "    public int getAge() {\n        return age;\n    }\n",
    "169083": "    public void setExperience(int i) {\n        experience = i;\n    }\n",
    "169086": "    public int getExperience() {\n        return experience;\n    }\n",
    "169089": "    public void setForm(int i) {\n        form = i;\n    }\n",
    "169090": "    public int getForm() {\n        return form;\n    }\n",
    "169093": "    public void setName(String string) {\n        name = string;\n    }\n",
    "169098": "    public void setPlayerId(int i) {\n        playerId = i;\n    }\n",
    "169100": "    public int getPlayerId() {\n        return playerId;\n    }\n",
    "169103": "    public void setSpecialEvent(int i) {\n        specialEvent = i;\n    }\n",
    "169105": "    public int getSpecialEvent() {\n        return specialEvent;\n    }\n",
    "169108": "    public void setStatus(int i) {\n        status = i;\n    }\n",
    "169112": "    public int getStatus() {\n        return status;\n    }\n",
    "169115": "    public void setTSI(int i) {\n        tSI = i;\n    }\n",
    "169119": "    public int getTSI() {\n        return tSI;\n    }\n",
    "169122": "    public void setTeamId(int i) {\n        teamId = i;\n    }\n",
    "169126": "    public int getTeamId() {\n        return teamId;\n    }\n",
    "169128": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"PlayerInfo[\");\n        buffer.append(\"name = \" + name);\n        buffer.append(\", age = \" + age);\n        buffer.append(\", experience = \" + experience);\n        buffer.append(\", form = \" + form);\n        buffer.append(\", playerId = \" + playerId);\n        buffer.append(\", specialEvent = \" + specialEvent);\n        buffer.append(\", status = \" + status);\n        buffer.append(\", tSI = \" + tSI);\n        buffer.append(\", teamId = \" + teamId);\n        buffer.append(\"]\");\n        return buffer.toString();\n    }\n",
    "169131": "    public int getApp() {\n        return app;\n    }\n",
    "169134": "    public double getAvg() {\n        return avg;\n    }\n",
    "169135": "    public double getMax() {\n        return max;\n    }\n",
    "169136": "    public void addMatchLineupPlayer(PlayerPerformance pp) {\n        playerPerf.add(pp);\n    }\n",
    "169137": "    public double getMin() {\n        return min;\n    }\n",
    "169139": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"MatchDetail[\");\n        buffer.append(\"playerPerf = \" + playerPerf);\n        buffer.append(\", match = \" + match);\n        buffer.append(\", rating = \" + rating);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169142": "    public String getPositionDesc() {\n        int posCode = Commons.getModel().getHelper().getPosition(pos);\n\n        return Commons.getModel().getHelper().getNameForPosition((byte) posCode);\n    }\n",
    "169144": "    public void addMatch(double rating) {\n        if (rating > max) {\n            max = rating;\n        }\n\n        if (rating < min) {\n            min = rating;\n        }\n\n        avg = ((avg * app) + rating) / (app + 1d);\n        app++;\n    }\n",
    "169180": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"PositionLineup[\");\n        buffer.append(\"tactics = \" + tactics);\n        buffer.append(\", name = \" + name);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169183": "    public void setId(int i) {\n        id = i;\n    }\n",
    "169188": "    public int getMainPosition() {\n        int pos = -1;\n        int val = -1;\n\n        for (int i = 0; i < 25; i++) {\n            if (app[i].getApp() > val) {\n                pos = i;\n                val = app[i].getApp();\n            }\n        }\n\n        return pos;\n    }\n",
    "169190": "    public RosterRoleData getMainRole() {\n        return app[getMainPosition()];\n    }\n",
    "169193": "    public void setName(String i) {\n        name = i;\n    }\n",
    "169198": "    public List getSecondaryRoles() {\n        int main = getMainPosition();\n        List l = new ArrayList();\n\n        for (int i = 0; i < app.length; i++) {\n            RosterRoleData array_element = app[i];\n\n            if ((array_element.getApp() > 0) && (array_element.getPos() != main)) {\n                l.add(array_element);\n            }\n        }\n\n        return l;\n    }\n",
    "169200": "    public void addMatch(SpotLineup spot) {\n        if (spot.getPosition() > -1) {\n            app[spot.getPosition()].addMatch(spot.getRating());\n        }\n    }\n",
    "169218": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"Filter[\");\n        buffer.append(\"number = \" + number);\n        buffer.append(\", awayGames = \" + awayGames);\n        buffer.append(\", homeGames = \" + homeGames);\n        buffer.append(\", win = \" + win);\n        buffer.append(\", draw = \" + draw);\n        buffer.append(\", defeat = \" + defeat);\n        buffer.append(\", automatic = \" + automatic);\n        buffer.append(\", matches = \" + matches);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169227": "    public String desc() {\n        return name + \" \" + teamId;\n    }\n",
    "169239": "    public SpotReport getSpotReport(int spot) {\n        return (SpotReport) spotReports.get(\"\" + spot);\n    }\n",
    "169241": "    public void setSpotLineup(SpotLineup detail, int spot) {\n        spotLineups[spot - 1] = detail;\n    }\n",
    "169244": "    public void addMatch(MatchDetail matchDetail, boolean showUnavailable) {\n        for (Iterator iter = matchDetail.getPerformances().iterator(); iter.hasNext();) {\n            addPerformance((PlayerPerformance) iter.next(), showUnavailable);\n        }\n\n        addRating(matchDetail.getRating());\n        addStars(matchDetail.getStars());\n        matchNumber++;\n    }\n",
    "169247": "    private void addPerformance(PlayerPerformance pp, boolean showUnavailable) {\n        if ((!showUnavailable) && (pp.getStatus() != PlayerDataManager.AVAILABLE)) {\n            return;\n        }\n\n        SpotReport spotReport = getSpotReport(pp.getId());\n\n        if (spotReport == null) {\n            spotReport = new SpotReport(pp);\n            spotReports.put(pp.getId() + \"\", spotReport);\n        }\n\n        spotReport.addPerformance(pp);\n    }\n",
    "169248": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"TeamLineup[\");\n\n        if (spotLineups == null) {\n            buffer.append(\"spotLineups = \" + \"null\");\n        } else {\n            buffer.append(\"spotLineups = \" + Arrays.asList(spotLineups).toString());\n        }\n\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169251": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"Match[\");\n        buffer.append(\"homeId = \" + homeId);\n        buffer.append(\", awayId = \" + awayId);\n        buffer.append(\", matchId = \" + matchId);\n        buffer.append(\", homeTeam = \" + homeTeam);\n        buffer.append(\", awayTeam = \" + awayTeam);\n        buffer.append(\", homeGoals = \" + homeGoals);\n        buffer.append(\", awayGoals = \" + awayGoals);\n        buffer.append(\", season = \" + season);\n        buffer.append(\", week = \" + week);\n        buffer.append(\", matchType = \" + matchType);\n        buffer.append(\", matchDate = \" + matchDate);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169253": "    private void addStars(double stars) {\n        averageStars = updateAverage(averageStars, stars);\n    }\n",
    "169254": "    public void addPerformance(PlayerPerformance pp) {\n        super.addPerformance(pp);\n        updateTacticDetails(pp);\n    }\n",
    "169255": "    private double updateAverage(double oldValue, double newValue) {\n        double rat = ((oldValue * matchNumber) + newValue) / (matchNumber + 1);\n\n        return rat;\n    }\n",
    "169257": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"PositionReport[\");\n        buffer.append(super.toString());\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169262": "    public void addPerformance(PlayerPerformance pp) {\n        super.addPerformance(pp);\n        updatePositionDetails(pp);\n        updatePlayerAppearance(pp);\n    }\n",
    "169265": "    private void updatePlayerAppearance(PlayerPerformance pp) {\n        String name = \"\" + pp.getSpielerName();\n\n        name = name.replaceAll(\" \", \"\");\n\n        PlayerAppearance playerApperance = (PlayerAppearance) players.get(name);\n\n        if (playerApperance == null) {\n            playerApperance = new PlayerAppearance();\n            playerApperance.setPlayerId(pp.getSpielerId());\n            playerApperance.setName(pp.getSpielerName());\n\n            playerApperance.setStatus(pp.getStatus());\n            players.put(name, playerApperance);\n        }\n\n        playerApperance.addApperarence();\n    }\n",
    "169268": "    private void updatePositionDetails(PlayerPerformance pp) {\n        PositionReport report = (PositionReport) positionReports.get(\"\" + pp.getPositionCode());\n\n        if (report == null) {\n            report = new PositionReport(pp);\n            positionReports.put(\"\" + pp.getPositionCode(), report);\n        }\n\n        report.addPerformance(pp);\n    }\n",
    "169269": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"TacticReport[\");\n        buffer.append(\"tactic = \" + tacticCode);\n        buffer.append(\", \" + super.toString());\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "169273": "    public TeamLineup getLineup() {\n        return teamLineup;\n    }\n",
    "169275": "    public List populate(List matches) {\n        List list = new ArrayList();\n\n        analyzedMatch = new ArrayList();\n\n        for (Iterator iter = matches.iterator(); iter.hasNext();) {\n            Match element = (Match) iter.next();\n\n            if (!isMatchAvailable(element.getMatchId()) && CHPPManager.isDownloadAllowed(element)) {\n                downloadMatch(element.getMatchId());\n            }\n\n            try {\n                MatchDetail md = populateMatch(element);\n\n                if (md != null) {\n                    list.add(md);\n                    analyzedMatch.add(md);\n                }\n            } catch (RuntimeException e) {\n                // DO NOTHING\n            }\n        }\n\n        return list;\n    }\n",
    "169278": "    private Collection getAllTactics(Collection positions) {\n        Collection tactics = new ArrayList();\n\n        for (Iterator iter = positions.iterator(); iter.hasNext();) {\n            PositionReport positionReport = (PositionReport) iter.next();\n\n            tactics.addAll(positionReport.getTacticReports());\n        }\n\n        return tactics;\n    }\n",
    "169279": "    private boolean isMatchAvailable(int matchId) {\n        return Commons.getModel().getHelper().existsMatchInDB(matchId);\n    }\n",
    "169282": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"numberAppearance = \" + appearance);\n        buffer.append(\", averageRating = \" + rating);\n        buffer.append(\", spot = \" + spot);\n        buffer.append(\", position = \" + position);\n\n        return buffer.toString();\n    }\n",
    "169285": "    public List getMatches() {\n        return matchList;\n    }\n",
    "169286": "    private boolean downloadMatch(int matchId) {\n        return Commons.getModel().getHelper().downloadMatchData(matchId);\n    }\n",
    "169287": "    public void addMatch(Match match) {\n        matchList.add(match);\n    }\n",
    "169288": "    public List filterMatches(Filter filter) {\n        int counter = 0;\n        List list = new ArrayList();\n\n        if (filter.isAutomatic()) {\n            for (Iterator iter = matchList.iterator(); iter.hasNext();) {\n                Match match = (Match) iter.next();\n\n                if (isAutomaticIncluded(filter, match)) {\n                    list.add(match);\n                    counter++;\n                }\n\n                if (counter >= filter.getNumber()) {\n                    break;\n                }\n            }\n        } else {\n            List filterMatches = filter.getMatches();\n\n            for (Iterator iter = matchList.iterator(); iter.hasNext();) {\n                Match match = (Match) iter.next();\n\n                if (filterMatches.contains(\"\" + match.getMatchId())) {\n                    list.add(match);\n                }\n            }\n        }\n\n        return list;\n    }\n",
    "169289": "    private int getPosition(TacticReport[] tacticsReport) {\n        if (isSingle(tacticsReport)) {\n            return tacticsReport[0].getTacticCode();\n        }\n\n        if (tacticsReport[0].getPosition() == tacticsReport[1].getPosition()) {\n            return tacticsReport[0].getTacticCode();\n        }\n\n        return -1;\n    }\n",
    "169292": "    public boolean isFavourite(int teamId) {\n        String query = \"select * from TEAMANALYZER_FAVORITES where TEAMID=\" + teamId;\n        ResultSet rs = Commons.getModel().getAdapter().executeQuery(query);\n\n        try {\n            if (rs.next()) {\n                return true;\n            }\n        } catch (SQLException e) {\n            // do Nothing\n        }\n\n        return false;\n    }\n",
    "169293": "    public List getTeams() {\n        List list = new ArrayList();\n        String query = \"select * from TEAMANALYZER_FAVORITES\";\n        ResultSet rs = Commons.getModel().getAdapter().executeQuery(query);\n\n        try {\n            while (rs.next()) {\n                Team team = new Team();\n\n                team.setTeamId(rs.getInt(1));\n                team.setName(rs.getString(2));\n                list.add(team);\n            }\n        } catch (SQLException e) {\n            return new ArrayList();\n        }\n\n        return list;\n    }\n",
    "169295": "    private boolean isSingle(TacticReport[] tacticsReport) {\n        if (tacticsReport.length == 1) {\n            return true;\n        }\n\n        if (tacticsReport[0].getAppearance() > tacticsReport[1].getAppearance()) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169296": "    public void addTeam(Team team) {\n        Commons.getModel().getAdapter().executeUpdate(\"insert into TEAMANALYZER_FAVORITES (TEAMID, NAME) values (\"\n                                                      + team.getTeamId() + \", '\" + team.getName()\n                                                      + \"')\");\n    }\n",
    "169297": "    public void removeTeam(int teamId) {\n        String query = \"delete from TEAMANALYZER_FAVORITES where TEAMID=\" + teamId;\n\n        Commons.getModel().getAdapter().executeUpdate(query);\n    }\n",
    "169298": "    public PlayerInfo getPlayerInfo(int playerId) {\n        HTCalendar cal = getCurrentHTWeek();\n        return getPlayerInfo(playerId, cal.getHTWeek(), cal.getHTSeason());\n    }\n",
    "169299": "    private void checkTable() {\n        try {\n            ResultSet rs = Commons.getModel().getAdapter().executeQuery(\"select * from TEAMANALYZER_FAVORITES\");\n\n            rs.next();\n        } catch (Exception e) {\n            Commons.getModel().getAdapter().executeUpdate(\"CREATE TABLE TEAMANALYZER_FAVORITES(TEAMID integer,NAME varchar(20))\");\n        }\n    }\n",
    "169300": "    public PlayerInfo getPreviousPlayeInfo(int id) {\n        ResultSet rs = Commons.getModel().getAdapter().executeQuery(\"SELECT WEEK FROM TEAMANALYZER_PLAYERDATA WHERE WEEK<\"\n                                                                    + getCurrentWeekNumber()\n                                                                    + \" AND PLAYERID=\" + id\n                                                                    + \" ORDER BY WEEK DESC\");\n\n        try {\n            if (rs.next()) {\n                int week = rs.getInt(\"WEEK\");\n                int season = week / 16;\n                int wk = week % 16;\n                return getPlayerInfo(id, wk, season);\n            }\n        } catch (SQLException e) {\n        }\n\n        return new PlayerInfo();\n    }\n",
    "169302": "    public void setCheckTeamName(boolean b) {\n        isCheckTeamName = b;\n        setValue(\"isCheckTeamName\", b);\n    }\n",
    "169303": "    public void addPlayer(PlayerInfo info) {\n        Commons.getModel().getAdapter().executeUpdate(\"insert into TEAMANALYZER_PLAYERDATA values (\"\n                                                      + info.getTeamId() + \", \"\n                                                      + info.getPlayerId() + \", \"\n                                                      + info.getStatus() + \" , \"\n                                                      + info.getSpecialEvent() + \", \"\n                                                      + info.getTSI() + \", \" + info.getForm()\n                                                      + \", \" + info.getAge() + \", \"\n                                                      + info.getExperience() + \", \"\n                                                      + getCurrentWeekNumber() + \")\");\n    }\n",
    "169305": "    public boolean isCheckTeamName() {\n        return isCheckTeamName;\n    }\n",
    "169306": "    public void updatePlayer(PlayerInfo info) {\n        Commons.getModel().getAdapter().executeUpdate(\"update TEAMANALYZER_PLAYERDATA set \"\n                                                      + \"   SPECIALEVENT=\" + info.getSpecialEvent()\n                                                      + \" , TSI=\" + info.getTSI() + \" , FORM=\"\n                                                      + +info.getForm() + \" , AGE=\" + info.getAge()\n                                                      + \" , EXPERIENCE=\" + info.getExperience()\n                                                      + \" , STATUS=\" + info.getStatus()\n                                                      + \" where PLAYERID=\" + info.getPlayerId()\n                                                      + \" and WEEK=\" + getCurrentWeekNumber());\n    }\n",
    "169309": "    private HTCalendar getCurrentHTWeek() {\n        Calendar date = Calendar.getInstance();\n        date.add(Calendar.HOUR, UserParameter.instance().TimeZoneDifference);\n        return HTCalendarFactory.createTrainingCalendar(Commons.getModel(), date.getTime());\n    }\n",
    "169312": "    private int getCurrentWeekNumber() {\n        HTCalendar ht = getCurrentHTWeek();\n        return ht.getHTWeek() + (ht.getHTSeason() * 16);\n    }\n",
    "169315": "    private void setColumnInvisible(int col) {\n        table.getTableHeader().getColumnModel().getColumn(col).setWidth(0);\n        table.getTableHeader().getColumnModel().getColumn(col).setPreferredWidth(0);\n        table.getTableHeader().getColumnModel().getColumn(col).setMaxWidth(0);\n        table.getTableHeader().getColumnModel().getColumn(col).setMinWidth(0);\n    }\n",
    "169319": "    public void setLoddarStats(boolean b) {\n        isLoddarStats = b;\n        setValue(\"isLoddarStats\", b);\n    }\n",
    "169320": "    private void setColumnWidth(int col, int width) {\n        table.getTableHeader().getColumnModel().getColumn(col).setWidth(width);\n        table.getTableHeader().getColumnModel().getColumn(col).setPreferredWidth(width);\n        table.getTableHeader().getColumnModel().getColumn(col).setMaxWidth(200);\n        table.getTableHeader().getColumnModel().getColumn(col).setMinWidth(0);\n    }\n",
    "169322": "    public boolean isLoddarStats() {\n        return isLoddarStats;\n    }\n",
    "169325": "    private void setRating(Vector row, MatchRating rating) {\n        if (rating == null) {\n            for (int i = 0; i < 7; i++) {\n                row.add(\"\"); //$NON-NLS-1$\n            }\n\n            return;\n        }\n\n        row.add(getRating((int) rating.getMidfield()));\n        row.add(getRating((int) rating.getRightDefense()));\n        row.add(getRating((int) rating.getCentralDefense()));\n        row.add(getRating((int) rating.getLeftDefense()));\n        row.add(getRating((int) rating.getRightAttack()));\n        row.add(getRating((int) rating.getCentralAttack()));\n        row.add(getRating((int) rating.getLeftAttack()));\n    }\n",
    "169326": "    public Team getSelectedTeam() {\n        return (Team) teamCombo.getSelectedItem();\n    }\n",
    "169329": "    private String getRating(int rating) {\n        return RatingUtil.getRating(rating, SystemManager.getConfig().isNumericRating(),\n                                    SystemManager.getConfig().isDescriptionRating(),\n                                    Commons.getModel());\n    }\n",
    "169330": "    public void actionPerformed(ActionEvent ae) {\n        Object compo = ae.getSource();\n        CardLayout cLayout = (CardLayout) (cards.getLayout());\n\n        if (compo == radioAutomatic) {\n            SystemManager.getFilter().setAutomatic(true);\n            autoPanel.reload();\n            cLayout.show(cards, CARD_AUTOMATIC);\n\n            return;\n        } else if (compo == radioManual) {\n            cLayout.show(cards, CARD_MANUAL);\n            SystemManager.getFilter().setAutomatic(false);\n            manualPanel.reload();\n\n            return;\n        }\n    }\n",
    "169336": "    private void fillTeamCombo() {\n        teamComboUpdating = true;\n        teamCombo.removeAllItems();\n\n        int i = 0;\n\n        for (Iterator iter = TeamManager.getTeams().iterator(); iter.hasNext();) {\n            Team element = (Team) iter.next();\n\n            teamCombo.addItem(element);\n\n            if (SystemManager.getActiveTeamId() == element.getTeamId()) {\n                teamCombo.setSelectedItem(element);\n            }\n\n            i++;\n        }\n\n        teamCombo.setMaximumRowCount(i);\n        teamComboUpdating = false;\n    }\n",
    "169337": "    public void setShowPlayerInfo(boolean b) {\n        isShowPlayerInfo = b;\n        setValue(\"isShowPlayerInfo\", b);\n    }\n",
    "169340": "    public boolean isShowPlayerInfo() {\n        return isShowPlayerInfo;\n    }\n",
    "169346": "    public TeamLineupData getMyTeamLineupPanel() {\n        return teamPanel.getMyTeamLineupPanel();\n    }\n",
    "169347": "    public TeamLineupData getOpponentTeamLineupPanel() {\n        return teamPanel.getOpponentTeamLineupPanel();\n    }\n",
    "169348": "    public RosterPanel getRosterPanel() {\n        return rosterPanel;\n    }\n",
    "169351": "    public void jbInit() {\n        JTabbedPane pane = new JTabbedPane();\n\n        pane.setOpaque(false);\n        setOpaque(false);\n        setLayout(new BorderLayout());\n        pane.add(Commons.getModel().getResource().getProperty(\"Aufstellung\"), teamPanel);\n//        pane.add(PluginProperty.getString(\"Players\"), rosterPanel);\n        add(pane, BorderLayout.CENTER);\n    }\n",
    "169353": "    public void reload(TeamLineup lineup, int week, int season) {\n//        rosterPanel.reload();\n        teamPanel.reload(lineup, week, season);\n    }\n",
    "169354": "    public void initCompare() {\n        centerPanel.removeAll();\n        setLayout(new BorderLayout());\n        setOpaque(false);\n        centerPanel.setOpaque(false);\n\n        constraints.anchor = GridBagConstraints.CENTER;\n        constraints.fill = GridBagConstraints.NONE;\n        constraints.weightx = 0.0;\n        constraints.weighty = 0.0;\n        constraints.insets = new Insets(0, 0, 0, 0);\n        centerPanel.setLayout(layout);\n\n        setOpponentPanel(0);\n        setOpponentKeeper(1);\n        setOpponentDefence(2);\n        setOpponentMidfield(3);\n        setOpponentAttack(4);\n        setMyAttack(5);\n        setMyMidfield(6);\n        setMyDefence(7);\n        setMyKeeper(8);\n        setMyPanel(9);\n\n        add(centerPanel, BorderLayout.CENTER);\n    }\n",
    "169355": "    public void initSingle() {\n        centerPanel.removeAll();\n        setLayout(new BorderLayout());\n        setOpaque(false);\n        centerPanel.setOpaque(false);\n\n        constraints.anchor = GridBagConstraints.CENTER;\n        constraints.fill = GridBagConstraints.NONE;\n        constraints.weightx = 0.0;\n        constraints.weighty = 0.0;\n        constraints.insets = new Insets(2, 2, 2, 2);\n        centerPanel.setLayout(layout);\n\n        setOpponentPanel(0);\n        setOpponentKeeper(1);\n        setOpponentDefence(2);\n        setOpponentMidfield(3);\n        setOpponentAttack(4);\n\n        add(centerPanel, BorderLayout.CENTER);\n    }\n",
    "169357": "    public TeamLineupData getMyTeam() {\n        return myTeam;\n    }\n",
    "169363": "    private void setLayout(boolean compare, boolean mixedLIneup) {\n        LineupStylePanel panel;\n\n        if (mixedLIneup) {\n            panel = new MixedLineupPanel(this);\n        } else {\n            panel = new StandardLineupPanel(this);\n        }\n\n        if (compare) {\n            panel.initCompare();\n        } else {\n            panel.initSingle();\n        }\n\n        removeAll();\n        setOpaque(false);\n        add(panel);\n    }\n",
    "169368": "    protected void setMidfieldRatingBar(int line) {\n        constraints.gridx = 0;\n        constraints.gridy = line;\n        constraints.gridwidth = 4;\n        layout.setConstraints(mainPanel.midfield, constraints);\n        centerPanel.add(mainPanel.midfield);\n    }\n",
    "169369": "    private JPanel createPanel(String string, JComponent checkBox) {\n        JPanel panel = Commons.getModel().getGUI().createImagePanel();\n\n        panel.setLayout(new BorderLayout());\n        panel.setOpaque(false);\n\n        JPanel innerPanel = Commons.getModel().getGUI().createImagePanel();\n\n        //innerPanel.setLayout(new BorderLayout());\n        innerPanel.add(checkBox);\n        innerPanel.add(new JLabel(string, JLabel.LEFT));\n        innerPanel.setOpaque(false);\n        panel.add(innerPanel, BorderLayout.WEST);\n\n        return panel;\n    }\n",
    "169383": "    private void setValue(String key, boolean value) {\n        String val = (value) ? \"1\" : \"0\";\n\n        String query = \"update TEAMANALYZER_SETTINGS set VALUE = \" + val + \" where NAME = '\" + key\n                       + \"'\";\n        int count = Commons.getModel().getAdapter().executeUpdate(query);\n\n        if (count == 0) {\n            Commons.getModel().getAdapter().executeUpdate(\"insert into TEAMANALYZER_SETTINGS (NAME, VALUE) values ('\"\n                                                          + key + \"', \" + val + \")\");\n        }\n    }\n",
    "169384": "    protected void setMyKeeper(int line) {\n        JPanel m_clTorwart;\n\n        constraints.gridx = 0;\n        constraints.gridy = line;\n        constraints.gridwidth = 4;\n        m_clTorwart = mainPanel.getMyTeam().getKeeperPanel();\n        m_clTorwart.setOpaque(false);\n        layout.setConstraints(m_clTorwart, constraints);\n        centerPanel.add(m_clTorwart);\n    }\n",
    "169386": "    private boolean getValue(String key, boolean defaultValue) {\n        String query = \"select VALUE from TEAMANALYZER_SETTINGS where NAME='\" + key + \"'\";\n        ResultSet rs = Commons.getModel().getAdapter().executeQuery(query);\n\n        try {\n            rs.next();\n\n            return rs.getBoolean(\"VALUE\");\n        } catch (SQLException e) {\n            return defaultValue;\n        }\n    }\n",
    "169392": "    private void fillCombo() {\n        teams.removeAllItems();\n\n        for (Iterator iter = menu.teams.iterator(); iter.hasNext();) {\n            Team element = (Team) iter.next();\n\n            teams.addItem(element);\n        }\n\n        teams.setEnabled(true);\n        deletebutton.setEnabled(true);\n\n        if (teams.getItemCount() == 0) {\n            teams.setEnabled(false);\n            deletebutton.setEnabled(false);\n        }\n    }\n",
    "169397": "    protected void setMyPanel(int line) {\n        JLabel m_jlTeamName;\n\n        constraints.gridx = 0;\n        constraints.gridy = line;\n        constraints.gridwidth = 4;\n        m_jlTeamName = mainPanel.getMyTeam().getTeamPanel();\n        m_jlTeamName.setOpaque(false);\n        m_jlTeamName.setForeground(Color.white);\n        m_jlTeamName.setFont(m_jlTeamName.getFont().deriveFont(Font.BOLD,\n                                                               gui.UserParameter.instance().schriftGroesse\n                                                               + 3));\n        layout.setConstraints(m_jlTeamName, constraints);\n        centerPanel.add(m_jlTeamName);\n    }\n",
    "169404": "    protected void setOpponentAttack(int line) {\n        constraints.gridx = 1;\n        constraints.gridy = line;\n        constraints.gridwidth = 1;\n\n        JPanel m_clLinkerSturm = mainPanel.getOpponentTeam().getLeftForwardPanel();\n\n        m_clLinkerSturm.setOpaque(false);\n        layout.setConstraints(m_clLinkerSturm, constraints);\n        centerPanel.add(m_clLinkerSturm);\n\n        constraints.gridx = 2;\n        constraints.gridy = line;\n        constraints.gridwidth = 1;\n\n        JPanel m_clRechterSturm = mainPanel.getOpponentTeam().getRightForwardPanel();\n\n        m_clRechterSturm.setOpaque(false);\n        layout.setConstraints(m_clRechterSturm, constraints);\n        centerPanel.add(m_clRechterSturm);\n    }\n",
    "169407": "    public JPanel getKeeperPanel() {\n        return m_clTorwart;\n    }\n",
    "169410": "    public void setLeftAttack(double i) {\n        leftAttack = i;\n    }\n",
    "169414": "    public Class getColumnClass(int column) {\n        if (column == 2) {\n            return ImageIcon.class;\n        }\n\n        return super.getColumnClass(column);\n    }\n",
    "169416": "    public boolean isCellEditable(int row, int column) {\n        if (column != 0) {\n            return false;\n        }\n\n        String available = (String) getValueAt(row, 6);\n\n        if (available.equalsIgnoreCase(\"true\")) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169418": "    public Class getColumnClass(int column) {\n        if (column == 1) {\n            return ImageIcon.class;\n        }\n\n        return super.getColumnClass(column);\n    }\n",
    "169420": "    public boolean isCellEditable(int row, int column) {\n        if ((column > 4) && (column < 9)) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169421": "    protected void setOpponentKeeper(int line) {\n        constraints.gridx = 0;\n        constraints.gridy = line;\n        constraints.gridwidth = 4;\n\n        JPanel m_clTorwart = mainPanel.getOpponentTeam().getKeeperPanel();\n\n        m_clTorwart.setOpaque(false);\n        layout.setConstraints(m_clTorwart, constraints);\n        centerPanel.add(m_clTorwart);\n    }\n",
    "169426": "    protected void setFilter() {\n        List list = new ArrayList();\n        int i = 0;\n\n        for (Iterator iter = availableMatches.iterator(); iter.hasNext();) {\n            Match element = (Match) iter.next();\n            boolean isSelected = ((Boolean) tableModel.getValueAt(i, 0)).booleanValue();\n            boolean isAvailable = Boolean.valueOf((String) tableModel.getValueAt(i, 6))\n                                         .booleanValue();\n\n            if (isSelected && isAvailable) {\n                list.add(\"\" + element.getMatchId());\n            }\n\n            i++;\n        }\n\n        SystemManager.getFilter().setMatches(list);\n    }\n",
    "169429": "    private void addTableListener() {\n        table.addMouseListener(new MouseAdapter() {\n                public void mouseReleased(MouseEvent e) {\n                    if (e.getClickCount() == 2) {\n                        boolean downloadDone = false;\n                        int row = table.getSelectedRow();\n                        String status = (String) tableModel.getValueAt(row, 6);\n\n                        if (!status.equalsIgnoreCase(\"true\")) {\n                            int id = ((Match) availableMatches.get(row)).getMatchId();\n\n                            downloadDone = Commons.getModel().getHelper().downloadMatchData(id);\n                        }\n\n                        e.consume();\n\n                        if (downloadDone) {\n                            tableModel.setValueAt(\"true\", row, 6);\n                        }\n\n                        updateUI();\n                    }\n                }\n            });\n    }\n",
    "169435": "    protected void setOpponentPanel(int line) {\n        constraints.gridx = 0;\n        constraints.gridy = line;\n        constraints.gridwidth = 4;\n\n        JLabel m_jlTeamName = mainPanel.getOpponentTeam().getTeamPanel();\n\n        m_jlTeamName.setOpaque(false);\n        m_jlTeamName.setForeground(Color.white);\n        m_jlTeamName.setFont(m_jlTeamName.getFont().deriveFont(Font.BOLD,\n                                                               gui.UserParameter.instance().schriftGroesse\n                                                               + 3));\n        layout.setConstraints(m_jlTeamName, constraints);\n        centerPanel.add(m_jlTeamName);\n    }\n",
    "169438": "    public TeamLineupData getMyTeamLineupPanel() {\n        return lineupPanel.getMyTeam();\n    }\n",
    "169440": "    public TeamLineupData getOpponentTeamLineupPanel() {\n        return lineupPanel.getOpponentTeam();\n    }\n",
    "169441": "    protected void setRatingBar1(int line) {\n        constraints.gridy = line;\n        constraints.gridwidth = 1;\n\n        constraints.gridx = 3;\n        layout.setConstraints(mainPanel.leftDef, constraints);\n        centerPanel.add(mainPanel.leftDef);\n\n        constraints.gridx = 0;\n        layout.setConstraints(mainPanel.rightDef, constraints);\n        centerPanel.add(mainPanel.rightDef);\n\n        constraints.gridx = 1;\n        constraints.gridwidth = 2;\n        layout.setConstraints(mainPanel.midDef, constraints);\n        centerPanel.add(mainPanel.midDef);\n    }\n",
    "169449": "    protected void setRatingBar2(int line) {\n        constraints.gridy = line;\n        constraints.gridwidth = 1;\n\n        constraints.gridx = 3;\n        layout.setConstraints(mainPanel.leftAtt, constraints);\n        centerPanel.add(mainPanel.leftAtt);\n\n        constraints.gridx = 0;\n        layout.setConstraints(mainPanel.rightAtt, constraints);\n        centerPanel.add(mainPanel.rightAtt);\n\n        constraints.gridx = 1;\n        constraints.gridwidth = 2;\n        layout.setConstraints(mainPanel.midAtt, constraints);\n        centerPanel.add(mainPanel.midAtt);\n    }\n",
    "169451": "    private int convertRating(double rating) {\n        return Commons.getModel().getLineUP().getIntValue4Rating(rating);\n    }\n",
    "169455": "    private void fillPanel(JPanel panel, JPanel playerPanel) {\n        panel.removeAll();\n        panel.add(playerPanel);\n    }\n",
    "169460": "    public void actionPerformed(ActionEvent arg0) {\n        JOptionPane.showMessageDialog(SystemManager.getPlugin().getPluginPanel(),\n                                      new DownloadPanel(),\n                                      PluginProperty.getString(\"Menu.DownloadMatch\"),\n                                      JOptionPane.PLAIN_MESSAGE);\n        ;\n\n        Team selectedTeam = SystemManager.getPlugin().getFilterPanel().getSelectedTeam();\n\n        SystemManager.setActiveTeam(selectedTeam);\n        SystemManager.refresh();\n    }\n",
    "169461": "    public PlayerInfo getPrevious(int playerId) {\n        for (Iterator iter = oldPlayersInfo.iterator(); iter.hasNext();) {\n            PlayerInfo element = (PlayerInfo) iter.next();\n\n            if (element.getPlayerId() == playerId) {\n                return element;\n            }\n        }\n\n        return new PlayerInfo();\n    }\n",
    "169465": "    private int getTacticLevel() {\n        double tacticLevel = 0d;\n\n        switch (Commons.getModel().getLineUP().getTacticType()) {\n            case IMatchDetails.TAKTIK_KONTER:\n                tacticLevel = Commons.getModel().getLineUP().getTacticLevelCounter();\n                break;\n\n            case IMatchDetails.TAKTIK_MIDDLE:\n                tacticLevel = Commons.getModel().getLineUP().getTacticLevelAimAow();\n                break;\n\n            case IMatchDetails.TAKTIK_PRESSING:\n                tacticLevel = Commons.getModel().getLineUP().getTacticLevelPressing();\n                break;\n\n            case IMatchDetails.TAKTIK_WINGS:\n                tacticLevel = Commons.getModel().getLineUP().getTacticLevelAimAow();\n                break;\n        }\n\n        return (int)tacticLevel;\n    }\n",
    "169470": "    private int getTacticSkill(String strSkill) {\n    \ttry {\n    \t\tif (strSkill == null || RecapPanel.VALUE_NA.equals(strSkill)) {\n    \t\t\treturn 0;\n    \t\t}\n    \t\tfor (int m=0; m<21; m++) {\n    \t\t\tif (strSkill.equals(Commons.getModel().getHelper().getNameForSkill(m, false))) {\n    \t\t\t\treturn (m>0?m-1:m); // TeamRatingPanel doesnt handle 'non existant', index 0=disastrous\n    \t\t\t}\n    \t\t}\n    \t} catch (Exception e) {\n    \t\te.printStackTrace();\n    \t}\n    \treturn 0;\n    }\n",
    "169474": "\tpublic String getSelectedTacticType() {\n\t\treturn selectedTacticType;\n\t}\n",
    "169476": "\tpublic String getSelectedTacticSkill() {\n\t\treturn selectedTacticSkill;\n\t}\n",
    "169477": "    public void actionPerformed(ActionEvent arg0) {\n        JOptionPane.showMessageDialog(SystemManager.getPlugin().getPluginPanel(), new AboutPanel(),\n                                      PluginProperty.getString(\"Menu.About\"),\n                                      JOptionPane.PLAIN_MESSAGE);\n        ;\n    }\n",
    "169481": "    private void setColumnWidth(int col, int width) {\n        table.getTableHeader().getColumnModel().getColumn(col).setWidth(width);\n        table.getTableHeader().getColumnModel().getColumn(col).setPreferredWidth(width);\n        table.getTableHeader().getColumnModel().getColumn(col).setMinWidth(0);\n    }\n",
    "169482": "    public void propertyChange(PropertyChangeEvent e) {\n        Number value = (Number) e.getNewValue();\n        int newDivLoc = value.intValue();\n\n        DividerDAO.setDividerPosition(key, newDivLoc);\n    }\n",
    "169484": "    public void actionPerformed(ActionEvent arg0) {\n        for (Iterator iter = TeamManager.getTeams().iterator(); iter.hasNext();) {\n            Team element = (Team) iter.next();\n            System.out.println(\"Downloading \" + element.getName());\n            HattrickManager.downloadPlayers(element.getTeamId());\n        }\n    }\n",
    "169486": "    public JPanel getLeftCentralDefenderPanel() {\n        return m_clLinkeInnenVerteidiger;\n    }\n",
    "169487": "    private RosterPlayerData getPlayerData(SpotLineup spot) {\n        RosterPlayerData data = (RosterPlayerData) players.get(\"\" + spot.getPlayerId());\n\n        if (data == null) {\n            data = new RosterPlayerData();\n            data.setId(spot.getPlayerId());\n            data.setName(spot.getName());\n            players.put(\"\" + spot.getPlayerId(), data);\n        }\n\n        return data;\n    }\n",
    "169488": "    public void setLeftDefence(double i) {\n        leftDefence = i;\n    }\n",
    "169490": "    public double getLeftDefence() {\n        return leftDefence;\n    }\n",
    "169492": "    public JPanel getLeftForwardPanel() {\n        return m_clLinkerSturm;\n    }\n",
    "169494": "    public JPanel getLeftMidfieldPanel() {\n        return m_clLinkeMittelfeld;\n    }\n",
    "169495": "    public Color getBackGround() {\n        return Color.WHITE;\n    }\n",
    "169497": "    public JPanel getLeftWingPanel() {\n        return m_clLinkeFluegel;\n    }\n",
    "169498": "    private void jbInit() {\n        Vector data = new Vector();\n\n        //JPanel main = Commons.getModel().getGUI().createImagePanel();\n        tableModel = new UiRatingTableModel(data, new Vector(Arrays.asList(columns)));\n        table = new JTable(tableModel);\n\n        table.setDefaultRenderer(Object.class, new RatingTableCellRenderer());\n\n        setLayout(new BorderLayout());\n\n        JScrollPane scrollPane = new JScrollPane(table);\n\n        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n\n        //main.add(scrollPane);\n        add(scrollPane);\n    }\n",
    "169499": "    public Dimension getDefaultSize() {\n        int height = 60;\n\n        if (!(this instanceof UserTeamPlayerPanel)) {\n            if (SystemManager.getConfig().isShowPlayerInfo()) {\n                height = height + 50;\n            }\n        }\n\n        if (SystemManager.getConfig().isTacticDetail()) {\n            height = height + 50;\n        }\n\n        return new Dimension(180, height);\n    }\n",
    "169501": "    public JPanel getLeftWingbackPanel() {\n        return m_clLinkeAussenVerteidiger;\n    }\n",
    "169504": "    public void setMiddleAttack(double i) {\n        middleAttack = i;\n    }\n",
    "169505": "    public String format(double number) {\n        return f.format(number);\n    }\n",
    "169508": "    public double getMiddleAttack() {\n        return middleAttack;\n    }\n",
    "169509": "    private String getTacticalRoleDesc(int position) {\n        return Commons.getModel().getHelper().getNameForPosition((byte) position);\n    }\n",
    "169510": "    protected void updateRatingPanel(double rating) {\n        ratingPanel.removeAll();\n        ratingPanel.setLayout(new BorderLayout());\n\n        JPanel starPanel = Commons.getModel().getGUI().createStarPanel((int) Math.round(rating * 2),\n                                                                       true);\n\n        starPanel.setBackground(getBackGround());\n        ratingPanel.add(starPanel, BorderLayout.WEST);\n        ratingPanel.setOpaque(true);\n        ratingPanel.setBackground(getBackGround());\n    }\n",
    "169514": "    public void setMiddleDefence(double i) {\n        middleDefence = i;\n    }\n",
    "169515": "    private void jbInit() {\n        Vector data = new Vector();\n\n        tableModel = new BaseTableModel(data,\n                                        new Vector(Arrays.asList(new Object[]{\n                                                                     \"COL_A\", \"COL_B\", \"COL_C\"\n                                                                 })));\n        table = new JTable(tableModel);\n        table.setRowSelectionAllowed(false);\n        table.setColumnSelectionAllowed(false);\n        this.setLayout(new BorderLayout());\n        this.add(table, BorderLayout.CENTER);\n        table.getTableHeader().getColumnModel().getColumn(1).setMaxWidth(30);\n        table.getTableHeader().getColumnModel().getColumn(2).setMaxWidth(30);\n    }\n",
    "169516": "    private JLabel createLabel(String text, Color farbe, int Bordertype) {\n        JLabel bla = new JLabel(text);\n\n        bla.setHorizontalAlignment(0);\n        bla.setForeground(farbe);\n        bla.setBorder(BorderFactory.createEtchedBorder(Bordertype));\n\n        return bla;\n    }\n",
    "169517": "    public void reload() {\n        homeGames.setSelected(SystemManager.getFilter().isHomeGames());\n        awayGames.setSelected(SystemManager.getFilter().isAwayGames());\n        win.setSelected(SystemManager.getFilter().isWin());\n        draw.setSelected(SystemManager.getFilter().isDraw());\n        defeat.setSelected(SystemManager.getFilter().isDefeat());\n        number.setText(SystemManager.getFilter().getNumber() + \"\");\n        league.setSelected(SystemManager.getFilter().isLeague());\n        cup.setSelected(SystemManager.getFilter().isCup());\n        qualifier.setSelected(SystemManager.getFilter().isQualifier());\n        friendly.setSelected(SystemManager.getFilter().isFriendly());\n    }\n",
    "169519": "    public double getMiddleDefence() {\n        return middleDefence;\n    }\n",
    "169520": "    public Color getBackGround() {\n        return Color.LIGHT_GRAY;\n    }\n",
    "169521": "    protected void setFilter() {\n        SystemManager.getFilter().setAwayGames(awayGames.isSelected());\n        SystemManager.getFilter().setHomeGames(homeGames.isSelected());\n        SystemManager.getFilter().setWin(win.isSelected());\n        SystemManager.getFilter().setDefeat(defeat.isSelected());\n        SystemManager.getFilter().setDraw(draw.isSelected());\n        SystemManager.getFilter().setLeague(league.isSelected());\n        SystemManager.getFilter().setCup(cup.isSelected());\n        SystemManager.getFilter().setFriendly(friendly.isSelected());\n        SystemManager.getFilter().setQualifier(qualifier.isSelected());\n        SystemManager.getFilter().setNumber(number.getValue());\n    }\n",
    "169522": "    public Dimension getDefaultSize() {\n        return new Dimension(180, 60);\n    }\n",
    "169525": "    public void setMidfield(double i) {\n        midfield = i;\n    }\n",
    "169528": "    protected void updateSpecialEvent() {\n        // DO NOTHING\n    }\n",
    "169530": "    public double getMidfield() {\n        return midfield;\n    }\n",
    "169531": "    public void reload(int r1, int r2) {\n        myValue.setText(RatingUtil.getRating(r1, SystemManager.getConfig().isNumericRating(),\n                                             SystemManager.getConfig().isDescriptionRating(),\n                                             Commons.getModel()));\n        opponentValue.setText(RatingUtil.getRating(r2, SystemManager.getConfig().isNumericRating(),\n                                                   SystemManager.getConfig().isDescriptionRating(),\n                                                   Commons.getModel()));\n        arrow.setIcon(Commons.getModel().getHelper().getImageIcon4Veraenderung(r1 - r2));\n    }\n",
    "169534": "    private void jbInit() {\n        JPanel mainPanel = Commons.getModel().getGUI().createImagePanel();\n\n        mainPanel.setBorder(BorderFactory.createRaisedBevelBorder());\n        mainPanel.add(myValue);\n        mainPanel.add(arrow);\n        mainPanel.add(opponentValue);\n        add(mainPanel);\n\n        myValue.setForeground(Color.BLACK);\n        opponentValue.setForeground(Color.BLACK);\n        setForeground(Color.BLACK);\n        setOpaque(false);\n        setFont(getFont().deriveFont(Font.BOLD, gui.UserParameter.instance().schriftGroesse + 3));\n    }\n",
    "169536": "    public void setRightAttack(double i) {\n        rightAttack = i;\n    }\n",
    "169537": "    public int compare(Object o1, Object o2) {\n        int s1 = ((Report) o1).getAppearance();\n        int s2 = ((Report) o2).getAppearance();\n\n        if (s1 > s2) {\n            return -1;\n        }\n\n        if (s2 > s1) {\n            return 1;\n        }\n\n        double n1 = ((Report) o1).getRating();\n        double n2 = ((Report) o2).getRating();\n\n        if (n1 > n2) {\n            return -1;\n        }\n\n        if (n2 > n1) {\n            return 1;\n        }\n\n        return 1;\n    }\n",
    "169540": "    public int compare(Object o1, Object o2) {\n        Date s1 = ((Match) o1).getMatchDate();\n        Date s2 = ((Match) o2).getMatchDate();\n\n        return s2.compareTo(s1);\n    }\n",
    "169541": "    public int compare(Object o1, Object o2) {\n        int s1 = ((RosterPlayerData) o1).getMainPosition();\n        int s2 = ((RosterPlayerData) o2).getMainPosition();\n\n        if (s1 > s2) {\n            return 1;\n        }\n\n        if (s2 > s1) {\n            return -1;\n        }\n\n        double n1 = ((RosterPlayerData) o1).getMainRole().getMax();\n        double n2 = ((RosterPlayerData) o2).getMainRole().getMax();\n\n        if (n1 > n2) {\n            return -1;\n        }\n\n        if (n2 > n1) {\n            return 1;\n        }\n\n        return 0;\n    }\n",
    "169544": "    public int compare(Object o1, Object o2) {\n        int s1 = ((PlayerAppearance) o1).getAppearance();\n        int s2 = ((PlayerAppearance) o2).getAppearance();\n\n        if (s1 > s2) {\n            return -1;\n        }\n\n        if (s2 > s1) {\n            return 1;\n        }\n\n        return 1;\n    }\n",
    "169545": "    public double getRightAttack() {\n        return rightAttack;\n    }\n",
    "169548": "    public JPanel getRightCentralDefenderPanel() {\n        return m_clRechteInnenVerteidiger;\n    }\n",
    "169550": "    public FilterPanel getFilterPanel() {\n        return filterPanel;\n    }\n",
    "169553": "    public MainPanel getMainPanel() {\n        return mainPanel;\n    }\n",
    "169555": "    public void setRightDefence(double i) {\n        rightDefence = i;\n    }\n",
    "169559": "    public boolean hasHeaderLine() {\n        return true;\n    }\n",
    "169561": "    public double getRightDefence() {\n        return rightDefence;\n    }\n",
    "169562": "    public int getPluginID() {\n        return PLUGIN_ID;\n    }\n",
    "169563": "    public int minSortableColumn() {\n        return 3;\n    }\n",
    "169566": "    private double hq(double value) {\n        return (2 * value) / (value + 80);\n    }\n",
    "169567": "    public JPanel getRightForwardPanel() {\n        return m_clRechterSturm;\n    }\n",
    "169568": "    private void jbInit(String[] messages) {\n        GridBagLayout gridBagLayout1 = new GridBagLayout();\n\n        this.setLayout(gridBagLayout1);\n\n        JLabel[] labels = new JLabel[messages.length];\n\n        for (int i = 0; i < labels.length; i++) {\n            labels[i] = new JLabel();\n            labels[i].setText(messages[i]);\n            add(labels[i],\n                new GridBagConstraints(0, i, 1, 1, 0.0, 0.0,\n                    GridBagConstraints.WEST, GridBagConstraints.NONE,\n                    new Insets(5, 5, 0, 5), 0, 0));\n        }\n    }\n",
    "169569": "    public JPanel getPluginPanel() {\n        return pluginPanel;\n    }\n",
    "169571": "    public int getIconHeight() {\n        if ((fPosition == TOP) || (fPosition == BOTTOM)) {\n            return fIcon1.getIconHeight() + fIcon2.getIconHeight();\n        }\n\n        return Math.max(fIcon1.getIconHeight(), fIcon2.getIconHeight());\n    }\n",
    "169572": "    public int getIconWidth() {\n        if ((fPosition == LEFT) || (fPosition == RIGHT)) {\n            return fIcon1.getIconWidth() + fIcon2.getIconWidth();\n        }\n\n        return Math.max(fIcon1.getIconWidth(), fIcon2.getIconWidth());\n    }\n",
    "169573": "    public RatingPanel getRatingPanel() {\n        return ratingPanel;\n    }\n",
    "169574": "    public JPanel getRightMidfieldPanel() {\n        return m_clRechteMittelfeld;\n    }\n",
    "169578": "    public RecapPanel getRecapPanel() {\n        return recapPanel;\n    }\n",
    "169581": "    public JPanel getRightWingPanel() {\n        return m_clRechteFluegel;\n    }\n",
    "169584": "    public JButton getSimButton() {\n        return simButton;\n    }\n",
    "169591": "    public double getVersion() {\n        return PLUGIN_VERSION;\n    }\n",
    "169592": "    public JPanel getRightWingbackPanel() {\n        return m_clRechteAussenVerteidiger;\n    }\n",
    "169593": "    public void refresh() {\n        try {\n            SystemManager.refreshData();\n        } catch (RuntimeException e) {\n            e.printStackTrace();\n        }\n    }\n",
    "169596": "    public void setTeamName(String teamname) {\n        m_jlTeamName.setText(teamname);\n    }\n",
    "169602": "    public JLabel getTeamPanel() {\n        return m_jlTeamName;\n    }\n",
    "169607": "    public int getValue() {\n        String s = getText();\n        int value = 0;\n\n        try {\n            value = Integer.parseInt(s);\n        }\n        catch (Exception e) {\n        }\n\n        return value;\n    }\n",
    "169608": "    public boolean isCellEditable(int row, int column) {\n        return false;\n    }\n",
    "169610": "    private String _getNewString(String str, int offs) {\n        String currentText = getText();\n        int currLen = currentText.length();\n        String newString = \"\";\n\n        if (offs == 0) {\n            newString = str + currentText;\n        }\n        else if (offs >= currLen) {\n            newString = currentText + str;\n        }\n        else {\n            newString = currentText.substring(0, offs) + str\n                + currentText.substring(offs, currLen);\n        }\n\n        return newString;\n    }\n",
    "169611": "    public Class getColumnClass(int column) {\n        if (getValueAt(0, column) == null) {\n            return Object.class;\n        }\n        else {\n            return getValueAt(0, column).getClass();\n        }\n    }\n",
    "169613": "    private boolean _validateNumberString(String str, int offs) {\n        char c;\n\n        String newString = this._getNewString(str, offs);\n\n        int newLength = newString.length();\n\n        if (newLength > _intDigits) {\n            return false;\n        }\n\n        // accepts only numerical digits\n        for (int i = 0; i < str.length(); i++) {\n            c = str.charAt(i);\n\n            if ((c < '0') || (c > '9')) {\n                return false;\n            }\n        }\n\n        newString = this._getNewString(str, offs);\n\n        if (!newString.equals(\"\") && !newString.equals(\".\")) {\n            try {\n                new Double(newString);\n            }\n            catch (NumberFormatException e) {\n                return false;\n            }\n\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n",
    "169620": "    public int getIconHeight() {\n        return fHeight;\n    }\n",
    "169623": "    public int getIconWidth() {\n        return fWidth;\n    }\n",
    "169648": "    public void refresh() {\n        // TODO Reload\n        reload();\n    }\n",
    "169651": "    private void initializeTables() {\n        fansPane.initialize();\n        stadiumPane.initialize();\n        playersPane.initialize();\n        extrasPane.initialize();\n        recapPane.initialize();\n    }\n",
    "169653": "    public void setCupRound(int i) {\n        cupRound = i;\n    }\n",
    "169655": "    public int getCupRound() {\n        return cupRound;\n    }\n",
    "169657": "    public void setLeaguePosition(int i) {\n        leaguePosition = i;\n    }\n",
    "169658": "    public int getLeaguePosition() {\n        return leaguePosition;\n    }\n",
    "169660": "    public void setSeason(int i) {\n        season = i;\n    }\n",
    "169662": "    public int getSeason() {\n        return season;\n    }\n",
    "169663": "    public void setSeasonEvent(int i) {\n        seasonEvent = i;\n    }\n",
    "169665": "    public int getSeasonEvent() {\n        return seasonEvent;\n    }\n",
    "169667": "    public void setSeasonEventType(int i) {\n        seasonEventType = i;\n    }\n",
    "169668": "    public int getSeasonEventType() {\n        return seasonEventType;\n    }\n",
    "169670": "    public void setSeasonResult(int i) {\n        seasonPoint = i;\n    }\n",
    "169672": "    public int getSeasonResult() {\n        return seasonPoint;\n    }\n",
    "169673": "    public void setSerie(int i) {\n        serie = i;\n    }\n",
    "169676": "    public int getSerie() {\n        return serie;\n    }\n",
    "169678": "    public void setArenaExpenses(int arenaExpenses) {\n        this.arenaExpenses = arenaExpenses;\n    }\n",
    "169679": "    public int getArenaExpenses() {\n        return arenaExpenses;\n    }\n",
    "169682": "    public void setCash(int cash) {\n        this.cash = cash;\n    }\n",
    "169683": "    public int getCash() {\n        return cash;\n    }\n",
    "169688": "    public void setExpectedProfitOrLoss(int expectedProfitOrLoss) {\n        this.expectedProfitOrLoss = expectedProfitOrLoss;\n    }\n",
    "169690": "    public int getExpectedProfitOrLoss() {\n        return expectedProfitOrLoss;\n    }\n",
    "169692": "    public void setInterestExpenses(int interestExpenses) {\n        this.interestExpenses = interestExpenses;\n    }\n",
    "169694": "    public int getInterestExpenses() {\n        return interestExpenses;\n    }\n",
    "169698": "    public void setInterestIncome(int interestIncome) {\n        this.interestIncome = interestIncome;\n    }\n",
    "169700": "    public int getInterestIncome() {\n        return interestIncome;\n    }\n",
    "169703": "    public void setSalaries(int salaries) {\n        this.salaries = salaries;\n    }\n",
    "169706": "    public int getSalaries() {\n        return salaries;\n    }\n",
    "169708": "    public void setSeasonAndWeek(int season, int week) {\n        this.season = season;\n        this.week = week;\n    }\n",
    "169709": "    public void setSpectatorsIncome(int spectatorsIncome) {\n        this.spectatorsIncome = spectatorsIncome;\n    }\n",
    "169710": "    public int getWeek() {\n        return week;\n    }\n",
    "169713": "    public int getWeekNumber() {\n        return week + (season * 16);\n    }\n",
    "169714": "    public int getSpectatorsIncome() {\n        return spectatorsIncome;\n    }\n",
    "169715": "    public void addWeek(int i) {\n        week = week + i;\n\n        while (week < 1) {\n            season--;\n            week = week + 16;\n        }\n\n        while (week > 16) {\n            season++;\n            week = week - 16;\n        }\n    }\n",
    "169717": "    public void setSponsorsIncome(int sponsorsIncome) {\n        this.sponsorsIncome = sponsorsIncome;\n    }\n",
    "169718": "    public int compareTo(Object obj) {\n        HTWeek week2 = (HTWeek) obj;\n\n        if (season > week2.season) {\n            return 1;\n        }\n\n        if (season < week2.season) {\n            return -1;\n        }\n\n        if (this.week > week2.week) {\n            return 1;\n        }\n\n        if (this.week < week2.week) {\n            return -1;\n        }\n\n        return 0;\n    }\n",
    "169719": "    public int getArenaExpenses() {\n        return Math.round((float) arenaExpenses / currencyRate);\n    }\n",
    "169720": "    public HTWeek copy() {\n        return new HTWeek(season, week);\n    }\n",
    "169721": "    public int getSponsorsIncome() {\n        return sponsorsIncome;\n    }\n",
    "169723": "    public boolean equals(Object obj) {\n        HTWeek week2 = (HTWeek) obj;\n\n        if ((this.season == week2.season) && (this.week == week2.week)) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169724": "    public int getCash() {\n        return Math.round((float) cash / currencyRate);\n    }\n",
    "169725": "    public void setStaffExpenses(int staffExpenses) {\n        this.staffExpenses = staffExpenses;\n    }\n",
    "169726": "    public String toString() {\n        return season + SEASON_WEEK_SEPARATOR + week;\n    }\n",
    "169727": "    public void setDate(Date date) {\n        this.date = new Timestamp(date.getTime());\n        calendar = HTCalendarFactory.createEconomyCalendar(Commons.getModel(), date);\n    }\n",
    "169729": "    public int getStaffExpenses() {\n        return staffExpenses;\n    }\n",
    "169730": "    public void setDate(Timestamp date) {\n        this.date = date;\n        calendar = HTCalendarFactory.createEconomyCalendar(Commons.getModel(), date);\n    }\n",
    "169732": "    public void setTemporaryExpenses(int temporaryExpenses) {\n        this.temporaryExpenses = temporaryExpenses;\n    }\n",
    "169733": "    public Date getDate() {\n        return calendar.getTime();\n    }\n",
    "169735": "    public int getTemporaryExpenses() {\n        return temporaryExpenses;\n    }\n",
    "169737": "    public int getExpectedProfitOrLoss() {\n        return Math.round((float) expectedProfitOrLoss / currencyRate);\n    }\n",
    "169738": "    public void setTemporaryIncome(int temporaryIncome) {\n        this.temporaryIncome = temporaryIncome;\n    }\n",
    "169739": "    public void setAgeDays(int i) {\n        agedays = i;\n    }\n",
    "169740": "    public int getHTSeason() {\n        return calendar.getHTSeason();\n    }\n",
    "169741": "    public int getTemporaryIncome() {\n        return temporaryIncome;\n    }\n",
    "169742": "    public int getAgeDays() {\n        return agedays;\n    }\n",
    "169743": "    public void setColumn(double[] column) {\n        setCr(C, column);\n    }\n",
    "169744": "    public int getHTWeek() {\n        return calendar.getHTWeek();\n    }\n",
    "169745": "    public void setTotalExpenses(int totalExpenses) {\n        this.totalExpenses = totalExpenses;\n    }\n",
    "169747": "    public void setAttack(double d) {\n        attack = d;\n    }\n",
    "169748": "    public int getInterestExpenses() {\n        return Math.round((float) interestExpenses / currencyRate);\n    }\n",
    "169749": "    public int getTotalExpenses() {\n        return totalExpenses;\n    }\n",
    "169750": "    public double getAttack() {\n        return attack;\n    }\n",
    "169752": "    public void setTotalIncome(int totalIncome) {\n        this.totalIncome = totalIncome;\n    }\n",
    "169753": "    public void setDefense(double d) {\n        defense = d;\n    }\n",
    "169754": "    public int getInterestIncome() {\n        return Math.round((float) interestIncome / currencyRate);\n    }\n",
    "169755": "    public int getTotalIncome() {\n        return totalIncome;\n    }\n",
    "169757": "    public double getDefense() {\n        return defense;\n    }\n",
    "169758": "    public void setColumn(int i, double size) {\n        setCr(C, i, size);\n    }\n",
    "169759": "    public int getSalaries() {\n        return Math.round((float) salaries / currencyRate);\n    }\n",
    "169760": "    public void setYouthSquadExpenses(int youthSquadExpenses) {\n        this.youthSquadExpenses = youthSquadExpenses;\n    }\n",
    "169763": "    public int getYouthSquadExpenses() {\n        return youthSquadExpenses;\n    }\n",
    "169766": "    public int getSpectatorsIncome() {\n        return Math.round((float) spectatorsIncome / currencyRate);\n    }\n",
    "169774": "    public int getSponsorsIncome() {\n        return Math.round((float) sponsorsIncome / currencyRate);\n    }\n",
    "169776": "    public double getColumn(int i) {\n        return crSpec[C][i];\n    }\n",
    "169778": "    public List getBoughtPlayersForWeek(HTWeek week) {\n        List l = new ArrayList();\n\n        for (Iterator iter = teamPlayers.values().iterator(); iter.hasNext();) {\n            TeamPlayerData element = (TeamPlayerData) iter.next();\n\n            if (week.equals(element.getStartWeek())) {\n                l.add(element.getData());\n            }\n        }\n\n        return l;\n    }\n",
    "169779": "    public void setGoalKeeping(double d) {\n        goalKeeping = d;\n    }\n",
    "169780": "    public int getStaffExpenses() {\n        return Math.round((float) staffExpenses / currencyRate);\n    }\n",
    "169782": "    public double getGoalKeeping() {\n        return goalKeeping;\n    }\n",
    "169784": "    public int getTemporaryExpenses() {\n        return Math.round((float) temporaryExpenses / currencyRate);\n    }\n",
    "169785": "    public void setLeadership(int i) {\n        leadership = i;\n    }\n",
    "169786": "    public List getPlayersAvailableAtWeek(HTWeek week) {\n        List l = new ArrayList();\n\n        for (Iterator iter = teamPlayers.values().iterator(); iter.hasNext();) {\n            TeamPlayerData element = (TeamPlayerData) iter.next();\n\n            if ((element.getStartWeek().compareTo(week) <= 0)\n                && (element.getFinalWeek().compareTo(week) > 0)) {\n                l.add(element.getData());\n            }\n        }\n\n        return l;\n    }\n",
    "169788": "    public int getLeadership() {\n        return leadership;\n    }\n",
    "169791": "    public int getTemporaryIncome() {\n        return Math.round((float) temporaryIncome / currencyRate);\n    }\n",
    "169792": "    public void setPassing(double d) {\n        passing = d;\n    }\n",
    "169794": "    public Timestamp getTimestamp() {\n        return date;\n    }\n",
    "169795": "    public double getPassing() {\n        return passing;\n    }\n",
    "169797": "    public HTWeek getSellingWeek(int playerId) {\n        TeamPlayerData tp = getTeamPlayer(playerId);\n\n        if ((tp.getFinalWeek().getWeekNumber() - TeamPlanner.ACTUALWEEK.getWeekNumber()) > 50) {\n            return null;\n        }\n\n        return tp.getFinalWeek();\n    }\n",
    "169798": "    public void setPlayMaking(double d) {\n        playMaking = d;\n    }\n",
    "169799": "    public int getTotalExpenses() {\n        return Math.round((float) totalExpenses / currencyRate);\n    }\n",
    "169801": "    public List getSoldPlayersForWeek(HTWeek week) {\n        List l = new ArrayList();\n\n        for (Iterator iter = teamPlayers.values().iterator(); iter.hasNext();) {\n            TeamPlayerData element = (TeamPlayerData) iter.next();\n            HTWeek pWeek = getSellingWeek(element.getData().getSpielerID());\n\n            if ((pWeek != null) && (week.equals(pWeek))) {\n                l.add(element.getData());\n            }\n        }\n\n        return l;\n    }\n",
    "169802": "    public double getPlayMaking() {\n        return playMaking;\n    }\n",
    "169803": "    public TableLayoutConstraints getConstraints(Component component) {\n        ListIterator iterator = list.listIterator(0);\n\n        while (iterator.hasNext()) {\n            Entry entry = (Entry) iterator.next();\n\n            if (entry.component == component) {\n                return new TableLayoutConstraints(entry.cr1[C], entry.cr1[R],\n                    entry.cr2[C], entry.cr2[R], entry.alignment[C],\n                    entry.alignment[R]);\n            }\n        }\n\n        return null;\n    }\n",
    "169804": "    public int getTotalIncome() {\n        return Math.round((float) totalIncome / currencyRate);\n    }\n",
    "169809": "    public int getYouthSquadExpenses() {\n        return Math.round((float) youthSquadExpenses / currencyRate);\n    }\n",
    "169810": "    public void cancelTransfer(int id, boolean sell) {\n        TeamPlayerData tp = getTeamPlayer(id);\n\n        if (sell) {\n            updateSalaries(tp.getFinalWeek(), tp.getData(), false);\n\n            HTWeek end = TeamPlanner.ACTUALWEEK.copy();\n            end.addWeek(100);\n            tp.setFinalWeek(end);\n        } else {\n            updateSalaries(tp.getStartWeek(), tp.getData(), true);\n            teamPlayers.remove(\"\" + id);\n        }\n    }\n",
    "169811": "    public int compareTo(Object obj) {\n        Date day = ((FinancesOfWeek) obj).calendar.getTime();\n\n        return day.compareTo(calendar.getTime());\n    }\n",
    "169812": "    public void setPlayerName(String string) {\n        playerName = string;\n    }\n",
    "169813": "    public void refreshTable() {\n        String liga = Commons.getModel().getLiga().getLiga();\n        int serie = SeriesUtil.getSeriesLevel(liga);\n        getYearPane(0).setSerie(serie);\n\n        for (int i = 1; i < futureYears.size(); i++) {\n            if (getYearPane(i - 1).getSetting().getSeasonEvent() == 1) {\n                serie--;\n            }\n\n            if (getYearPane(i - 1).getSetting().getSeasonEvent() == -1) {\n                serie++;\n            }\n\n            getYearPane(i).setSerie(serie);\n        }\n    }\n",
    "169814": "    private YearSettingPane getYearPane(int index) {\n        return ((YearSettingPane) futureYears.get(index));\n    }\n",
    "169815": "    public void sellPlayer(HTWeek week, int playerId) {\n        TeamPlayerData tp = getTeamPlayer(playerId);\n        tp.setFinalWeek(week);\n        updateSalaries(week, tp.getData(), true);\n    }\n",
    "169816": "    private void jbInit() {\n        JPanel p = new JPanel();\n\n        int count = WeekHeader.instance().getColumnWeek(IFutureTrainingManager.FUTUREWEEKS - 1)\n                              .getSeason() - TeamPlanner.ACTUALWEEK.getSeason() + 1;\n        p.setLayout(new GridLayout(count, 1));\n\n        for (int i = 0; i < count; i++) {\n            futureYears.add(new YearSettingPane(TeamPlanner.ACTUALWEEK.getSeason() + i));\n            p.add(getYearPane(i));\n        }\n\n        refreshTable();\n\n        setLayout(new BorderLayout());\n        add(p, BorderLayout.CENTER);\n    }\n",
    "169818": "    public int getBaseBalance(HTWeek week) {\n        int columnIndex = getColumnIndex(week);\n        int total = Util.getOperationCell(model, MAINTENANCE_ROW, columnIndex).getBalance();\n        total = total + Util.getOperationCell(model, INCOME_ROW, columnIndex).getBalance();\n        return total;\n    }\n",
    "169819": "    public void setHGap(int hGap) {\n        if (hGap >= 0) {\n            this.hGap = hGap;\n        }\n        else {\n            throw new IllegalArgumentException(\n                \"Parameter hGap must be non-negative.\"); //$NON-NLS-1$\n        }\n    }\n",
    "169820": "    public int getFullBalance(HTWeek week) {\n        int total = getBaseBalance(week);\n        total = total\n                + Util.getOperationCell(model, EXPENSE_ROW, getColumnIndex(week)).getBalance();\n        return total;\n    }\n",
    "169821": "    public void onChange() {\n        TeamPlanner.getRecapPane().refreshTable();\n    }\n",
    "169822": "    private TeamPlayerData getTeamPlayer(int id) {\n        TeamPlayerData tp = (TeamPlayerData) teamPlayers.get(\"\" + id);\n\n        if (tp == null) {\n            tp = new TeamPlayerData();\n\n            HTWeek start = TeamPlanner.ACTUALWEEK.copy();\n            start.addWeek(1);\n            tp.setStartWeek(start);\n\n            HTWeek end = TeamPlanner.ACTUALWEEK.copy();\n            end.addWeek(100);\n            tp.setFinalWeek(end);\n            teamPlayers.put(\"\" + id, tp);\n        }\n\n        return tp;\n    }\n",
    "169823": "    public void setPrice(int i) {\n        price = i;\n    }\n",
    "169824": "    protected void setRows() {\n        addInputRow(\"Size Change\", new StadiumExpansionListener(), false,\n                    new StadiumExpansionInner());\n        addCalculatedRow(\"Maintenance\", new StadiumMaintenanceCalculator());\n        addCalculatedRow(\"Expenses\", new StadiumExpansionCalculator());\n        addCalculatedRow(\"Income\", new StadiumIncomeCalculator());\n    }\n",
    "169825": "    protected void loadInputData() {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            StadiumExpansionInner inner = (StadiumExpansionInner) Util.getOperationData(model,\n                                                                                        SIZE_ROW, i)\n                                                                      .getInner();\n            StadiumExpansionInner total = inner.getTotal();\n            total.setTerraces(Commons.getModel().getStadium().getStehplaetze());\n            total.setSeats(Commons.getModel().getStadium().getSitzplaetze());\n            total.setRoofs(Commons.getModel().getStadium().getUeberdachteSitzplaetze());\n            total.setVips(Commons.getModel().getStadium().getLogen());\n        }\n    }\n",
    "169826": "    public int getId() {\n        return inner.getId();\n    }\n",
    "169827": "    public InnerData getInner() {\n        return inner;\n    }\n",
    "169828": "    public String toString() {\n        return inner.getDescription();\n    }\n",
    "169829": "    private void initSalary() {\n        for (Iterator iter = teamPlayers.values().iterator(); iter.hasNext();) {\n            TeamPlayerData tpd = (TeamPlayerData) iter.next();\n            updateSalaries(tpd.getStartWeek(), tpd.getData(), false);\n        }\n    }\n",
    "169830": "    public int getBalance() {\n        if (isMulti()) {\n            int balance = 0;\n\n            for (Iterator iter = getOperationList().iterator(); iter.hasNext();) {\n                OperationData element = (OperationData) iter.next();\n                balance += element.getInner().getMoney();\n            }\n\n            return balance;\n        } else {\n            return getOperation().getInner().getMoney();\n        }\n    }\n",
    "169831": "    public int getPrice() {\n        return price;\n    }\n",
    "169832": "    public boolean isMulti() {\n        return multi;\n    }\n",
    "169833": "    private void loadTrainees() {\n        Vector players = Commons.getModel().getAllSpieler();\n\n        for (Iterator iter = players.iterator(); iter.hasNext();) {\n            ISpieler player = (ISpieler) iter.next();\n            TeamPlayerData tp = getTeamPlayer(player.getSpielerID());\n            tp.setData(player);\n        }\n    }\n",
    "169834": "    public void setOperation(OperationData data) {\n        int index = 0;\n\n        for (Iterator iter = datas.iterator(); iter.hasNext();) {\n            OperationData element = (OperationData) iter.next();\n\n            if (element.getId() == data.getId()) {\n                datas.remove(index);\n                datas.add(index, data);\n                return;\n            }\n\n            index++;\n        }\n    }\n",
    "169835": "    public OperationData getOperation() {\n        if (isMulti()) {\n            throw new RuntimeException(\"Not Supported\");\n        } else {\n            return (OperationData) datas.get(0);\n        }\n    }\n",
    "169836": "    public List getOperationList() {\n        if (isMulti()) {\n            return datas;\n        } else {\n            throw new RuntimeException(\"Not Supported\");\n        }\n    }\n",
    "169839": "    public int getHGap() {\n        return hGap;\n    }\n",
    "169840": "    public boolean isCellEditable(int row, int col) {\n        return false;\n    }\n",
    "169841": "    public void setSetPieces(double d) {\n        setPieces = d;\n    }\n",
    "169842": "    public void addOperation(InnerData inner) {\n        OperationData data = new OperationData(inner);\n\n        if (isMulti()) {\n            datas.add(data);\n        } else {\n            throw new RuntimeException(\"Not Supported\");\n        }\n    }\n",
    "169843": "    public int getColumnCount() {\n        return colNames.size();\n    }\n",
    "169845": "    public String getColumnName(int col) {\n        return (String) colNames.get(col);\n    }\n",
    "169846": "    public void removeOperation(int id) {\n        if (!isMulti()) {\n            throw new RuntimeException(\"Not Supported\");\n        }\n\n        int index = 0;\n\n        for (Iterator iter = datas.iterator(); iter.hasNext();) {\n            OperationData element = (OperationData) iter.next();\n\n            if (element.getId() == id) {\n                datas.remove(index);\n                return;\n            }\n\n            index++;\n        }\n    }\n",
    "169847": "    public int getRowCount() {\n        return values.size();\n    }\n",
    "169848": "    public String toString() {\n        StringBuffer s = new StringBuffer();\n\n        for (Iterator iter = datas.iterator(); iter.hasNext();) {\n            OperationData element = (OperationData) iter.next();\n            s.append(element.toString());\n\n            if (iter.hasNext()) {\n                s.append(\"\\n\");\n            }\n        }\n\n        return s.toString();\n    }\n",
    "169850": "    public double getSetPieces() {\n        return setPieces;\n    }\n",
    "169851": "    public boolean isCellEditable(int row, int column) {\n        String val = (String) rowEditable.get(\"\" + row);\n\n        if ((val != null) && (val.equalsIgnoreCase(\"true\"))) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169852": "    public void refresh(Vector values) {\n        this.values = values;\n        fireTableDataChanged();\n    }\n",
    "169853": "    public void setEditable(int row, boolean editable) {\n        rowEditable.put(\"\" + row, \"\" + editable);\n    }\n",
    "169854": "    public void setData(double val, int money) {\n        this.money = money;\n        this.value = val;\n    }\n",
    "169855": "    public String getDescription() {\n        return (int) value + \"\";\n    }\n",
    "169856": "    public void setInner(int row, Class c) {\n        rowClass.put(\"\" + row, c);\n    }\n",
    "169857": "    public void setSpeciality(int i) {\n        speciality = i;\n    }\n",
    "169858": "    public int getId() {\n        return 1;\n    }\n",
    "169859": "    public void setMoney(int i) {\n        this.money = i;\n        this.value = i;\n    }\n",
    "169860": "    public InnerData getInnerData(int row) {\n        Class val = (Class) rowClass.get(\"\" + row);\n\n        try {\n            return (InnerData) val.newInstance();\n        } catch (Exception e) {\n            return new NumericInner();\n        }\n    }\n",
    "169861": "    public int getMoney() {\n        return money;\n    }\n",
    "169863": "    public int getSpeciality() {\n        return speciality;\n    }\n",
    "169864": "    public void setMulti(int row, boolean multi) {\n        rowMulti.put(\"\" + row, \"\" + multi);\n    }\n",
    "169866": "    public Comparator getCustomComparator(int column) {\n        if (column == 1) {\n            return new HTWeekComparator();\n        } else {\n            return null;\n        }\n    }\n",
    "169867": "    public boolean isMulti(int row) {\n        String val = (String) rowMulti.get(\"\" + row);\n\n        if ((val != null) && (val.equalsIgnoreCase(\"true\"))) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169868": "        public int compare(Object arg0, Object arg1) {\n            HTWeek d1 = (HTWeek) arg0;\n            HTWeek d2 = (HTWeek) arg1;\n\n            return d1.compareTo(d2);\n        }\n",
    "169869": "    public void setStamina(double d) {\n        stamina = d;\n    }\n",
    "169870": "        public boolean equals(Object arg0) {\n            return false;\n        }\n",
    "169871": "    public void setValueAt(Object value, int row, int col) {\n        if (value instanceof String) {\n            int input = 0;\n\n            try {\n                input = Integer.parseInt((String) value);\n            } catch (Exception e) {\n                // Ignore.\n            } finally {\n                OperationCell cell = (OperationCell) getValueAt(row, col);\n\n                if (!cell.isMulti()) {\n                    NumericInner inner = (NumericInner) cell.getOperation().getInner();\n                    inner.setMoney(input);\n                } else {\n                    //MultiPArt not enabled for direct wrinting\n                    // Skip it\n                    return;\n                }\n\n                //super.setValueAt(cell, row, col);\n            }\n        } else {\n            super.setValueAt(value, row, col);\n        }\n\n        this.fireTableDataChanged();\n    }\n",
    "169872": "    public float getLayoutAlignmentX(Container parent) {\n        return 0.5f;\n    }\n",
    "169873": "    public int getBaseBalance(HTWeek week) {\n        return 0;\n    }\n",
    "169874": "    public Comparator getCustomComparator(int column) {\n        return null;\n    }\n",
    "169875": "    public int getFullBalance(HTWeek week) {\n        return getBaseBalance(week);\n    }\n",
    "169876": "    public double getStamina() {\n        return stamina;\n    }\n",
    "169877": "    public void onChange() {\n        // No Panel need to be notified of this\t\t\n    }\n",
    "169878": "    public int getBaseBalance(HTWeek week) {\n        int columnIndex = getColumnIndex(week);\n        int money = Util.getOperationCell(model, YOUTH_ROW, columnIndex).getBalance();\n        money = money + Util.getOperationCell(model, STAFFSALARY_ROW, columnIndex).getBalance();\n        money = money + Util.getOperationCell(model, SPONSOR_ROW, columnIndex).getBalance();\n        return money;\n    }\n",
    "169879": "    protected void setRows() {\n        addCalculatedRow(\"Week Base\", new WeekBaseRecapCalculator());\n        addCalculatedRow(\"Week Total\", new WeekRecapCalculator());\n        addCalculatedRow(\"Running Total\", new TotalRecapCalculator());\n    }\n",
    "169880": "    public int getFullBalance(HTWeek week) {\n        int bal = getBaseBalance(week);\n        int columnIndex = getColumnIndex(week);\n        bal += Util.getOperationCell(model, STAFF_ROW, columnIndex).getBalance();\n        return bal;\n    }\n",
    "169881": "    protected void loadInputData() {\n    }\n",
    "169882": "    public void setTSI(int i) {\n        TSI = i;\n    }\n",
    "169884": "    protected void setRows() {\n        addManualRow(\"Youth\");\n        addInputRow(\"Staff\", new StaffListener(), false, new StaffInner());\n        addCalculatedRow(\"Staff Expense\", new StaffCalculator());\n        addCalculatedRow(\"Sponsor Income\", new SponsorCalculator());\n    }\n",
    "169885": "    public void setSerie(int newSerie) {\n        serie = newSerie;\n        setting = null;\n    }\n",
    "169886": "    public int getTSI() {\n        return TSI;\n    }\n",
    "169889": "    public void doCalculate(int row, TableModel model) {\n    }\n",
    "169890": "    public YearSetting getSetting() {\n        if (setting == null) {\n            setting = new YearSetting();\n            setting.setSeason(season);\n            setting.setCupRound(((CBItem) cupRound.getSelectedItem()).getId());\n            setting.setSeasonEvent(((CBItem) seasonEvent.getSelectedItem()).getId());\n            setting.setSeasonEventType(((CBItem) seasonEventType.getSelectedItem()).getId());\n            setting.setSeasonResult(((CBItem) seasonPoint.getSelectedItem()).getId());\n            setting.setLeaguePosition(((CBItem) leaguePosition.getSelectedItem()).getId());\n            setting.setSerie(serie);\n        }\n\n        return setting;\n    }\n",
    "169891": "    public void doExecute(OperationCell cell, HTWeek week) {\n        return;\n    }\n",
    "169892": "    public void setWeek(int i) {\n        week = i;\n    }\n",
    "169893": "    public void actionPerformed(ActionEvent e) {\n        setting = null;\n\n        // Remove it\t\t\n        removeListeners();\n\n        if (e.getSource() == seasonEvent) {\n            setSeasonEventType();\n            calculateSeasonResult();\n            calculateLeaguePosition();\n        }\n\n        if (e.getSource() == seasonEventType) {\n            calculateSeasonResult();\n            calculateLeaguePosition();\n        }\n\n        if (e.getSource() == seasonPoint) {\n            calculateLeaguePosition();\n        }\n\n        // Add listeners\n        initializeListeners();\n\n        onChange();\n    }\n",
    "169894": "    public int getBaseBalance(HTWeek week) {\n        int columnIndex = getColumnIndex(week);\n        return Util.getOperationCell(model, SALARY_ROW, columnIndex).getBalance();\n    }\n",
    "169896": "    public int getFullBalance(HTWeek week) {\n        int total = getBaseBalance(week);\n        int columnIndex = getColumnIndex(week);\n\n        for (int row = 1; row < 5; row++) {\n            total = total + Util.getOperationCell(model, row, columnIndex).getBalance();\n        }\n\n        return total;\n    }\n",
    "169897": "    public void loadInputData() {\n        //seasonEvent.setSelectedIndex(1);\n        //seasonPoint.setSelectedIndex(4);\n        //leaguePosition.setSelectedIndex(4);\n    }\n",
    "169898": "    public void setWing(double d) {\n        wing = d;\n    }\n",
    "169900": "    protected void onChange() {\n        TeamPlanner.getFuturePane().refreshTable();\n        TeamPlanner.getFansPane().refreshTable();\n        TeamPlanner.getStadiumPane().refreshTable();\n        TeamPlanner.getExtrasPane().refreshTable();\n        TeamPlanner.getRecapPane().refreshTable();\n    }\n",
    "169901": "    public double getWing() {\n        return wing;\n    }\n",
    "169903": "    public float getLayoutAlignmentY(Container parent) {\n        return 0.5f;\n    }\n",
    "169906": "    public int getAggressivity() {\n    \treturn aggressivity;\n    }\n",
    "169909": "    public int getHonesty() {\n    \treturn honesty;\n    }\n",
    "169911": "    private void calculateSeasonResult() {\n        int eventType = ((CBItem) seasonEvent.getSelectedItem()).getId();\n\n        // Direct Promotion\n        if (eventType == 2) {\n            seasonPoint.setSelectedIndex(6);\n        }\n\n        // Promotion Qualifier\n        if (eventType == 1) {\n            seasonPoint.setSelectedIndex(5);\n        }\n\n        // Normal\n        if (eventType == 0) {\n            seasonPoint.setSelectedIndex(4);\n        }\n\n        // Releagation Qualifier\n        if (eventType == -1) {\n            seasonPoint.setSelectedIndex(3);\n        }\n\n        // Direct Releagation\n        if (eventType == -2) {\n            seasonPoint.setSelectedIndex(1);\n        }\n    }\n",
    "169912": "    public int getPopularity() {\n    \treturn popularity;\n    }\n",
    "169913": "    protected void setRows() {\n        addInputRow(\"Trainees\", new TraineesListener(), true, new PlayersInner());\n        addInputRow(\"Buy\", new BuyPlayerListener(), true, new PlayersInner());\n        addInputRow(\"Sell\", new SellPlayerListener(), true, new PlayersInner());\n        addManualRow(\"Extra\");\n        addManualRow(\"Trading\");\n        addCalculatedRow(\"Salary\", new SalaryCalculator());\n    }\n",
    "169914": "    private void fillCupResult() {\n        for (int i = 1; i <= 16; i++) {\n            cupRound.addItem(new CBItem(\"ROUND \" + i, i));\n        }\n\n        cupRound.setSelectedIndex(0);\n    }\n",
    "169915": "    public void normalizeSkill() {\n        // Removed Disastrous since cause problems in calculation\n        if (wing < 2) {\n            wing = 2;\n        }\n\n        if (passing < 2) {\n            passing = 2;\n        }\n\n        if (playMaking < 2) {\n            playMaking = 2;\n        }\n\n        if (defense < 2) {\n            defense = 2;\n        }\n\n        if (setPieces < 2) {\n            setPieces = 2;\n        }\n\n        if (attack < 2) {\n            attack = 2;\n        }\n\n        if (goalKeeping < 2) {\n            goalKeeping = 2;\n        }\n\n        if (stamina < 2) {\n            stamina = 2;\n        }\n    }\n",
    "169916": "    protected void loadInputData() {\n        refreshSkillups();\n    }\n",
    "169918": "    private void fillLeaguePosition() {\n        for (int i = 1; i <= 8; i++) {\n            leaguePosition.addItem(new CBItem(\"\" + i, i));\n        }\n\n        leaguePosition.setSelectedIndex(3);\n    }\n",
    "169919": "    public int getFansAt(HTWeek week) {\n        int fans = Commons.getModel().getVerein().getFans();\n        int columnIndex = getColumnIndex(week);\n\n        for (int i = 0; i < columnIndex; i++) {\n            OperationData data = Util.getOperationData(model, FANS_ROW, i);\n            NumericInner ss = (NumericInner) data.getInner();\n            fans = fans + (int) ss.getValue();\n        }\n\n        return fans;\n    }\n",
    "169921": "    public double getFansMoraleAt(HTWeek week) {\n        int columnIndex = getColumnIndex(week);\n        OperationData data = Util.getOperationData(model, FANSMORALE_ROW, columnIndex);\n        NumericInner ss = (NumericInner) data.getInner();\n        return ss.getValue();\n    }\n",
    "169923": "    private void fillSeasonEvent() {\n        seasonEvent.addItem(new CBItem(\"RELEGATION\", -1));\n        seasonEvent.addItem(new CBItem(\"NORMAL\", 0));\n        seasonEvent.addItem(new CBItem(\"PROMOTION\", 1));\n        seasonEvent.setSelectedIndex(1);\n    }\n",
    "169924": "    public String getDescription() {\n        if (getSize() > 0) {\n            return \"Build \" + getSize();\n        } else if (getSize() < 0) {\n            return \"Demolish \" + (-getSize());\n        }\n\n        return \"\";\n    }\n",
    "169925": "    public void onChange() {\n        TeamPlanner.getStadiumPane().refreshTable();\n    }\n",
    "169926": "    public int getNumColumn() {\n        return crSpec[C].length;\n    }\n",
    "169927": "    protected void setRows() {\n        addCalculatedRow(\"Sponsor Morale\", new SponsorMoraleCalculator());\n        addCalculatedRow(\"Fans Morale\", new FansMoraleCalculator());\n        addCalculatedRow(\"Fans\", new FansCalculator());\n    }\n",
    "169930": "    public void setMoney(int i) {\n        throw new RuntimeException(\"Not Supported\");\n    }\n",
    "169931": "    private void fillSeasonResult() {\n        seasonPoint.addItem(new CBItem(\"0-6\", 1));\n        seasonPoint.addItem(new CBItem(\"7-12\", 2));\n        seasonPoint.addItem(new CBItem(\"13-18\", 3));\n        seasonPoint.addItem(new CBItem(\"19-24\", 4));\n        seasonPoint.addItem(new CBItem(\"25-30\", 5));\n        seasonPoint.addItem(new CBItem(\"31-36\", 6));\n        seasonPoint.addItem(new CBItem(\"37-42\", 7));\n        seasonPoint.setSelectedIndex(3);\n    }\n",
    "169933": "    public int getMoney() {\n        double money = 0;\n\n        if (getSize() != 0) {\n            money = 10000;\n        }\n\n        money += getCost(terraces, 60, 6);\n        money += getCost(seats, 100, 6);\n        money += getCost(roofs, 120, 6);\n        money += getCost(vips, 400, 6);\n        return (int) money;\n    }\n",
    "169935": "    public void setRoofs(int i) {\n        roofs = i;\n    }\n",
    "169936": "    private void initializeListeners() {\n        seasonEvent.addActionListener(this);\n        seasonEventType.addActionListener(this);\n        seasonPoint.addActionListener(this);\n        leaguePosition.addActionListener(this);\n        cupRound.addActionListener(this);\n    }\n",
    "169938": "    public int getRoofs() {\n        return roofs;\n    }\n",
    "169940": "    public void setSeats(int i) {\n        seats = i;\n    }\n",
    "169943": "    public int getSeats() {\n        return seats;\n    }\n",
    "169944": "    public int getSize() {\n        return vips + terraces + roofs + seats;\n    }\n",
    "169946": "    private void removeListeners() {\n        seasonEvent.removeActionListener(this);\n        seasonEventType.removeActionListener(this);\n        seasonPoint.removeActionListener(this);\n        leaguePosition.removeActionListener(this);\n        cupRound.removeActionListener(this);\n    }\n",
    "169947": "    public void setTerraces(int i) {\n        terraces = i;\n    }\n",
    "169948": "    public void doCalculate(int row, TableModel model) {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            int money = Util.getOperationCell(model, StadiumPane.SIZE_ROW, i).getBalance();\n            OperationCell cell = Util.getOperationCell(model, row, i);\n            cell.getOperation().getInner().setMoney(-money);\n        }\n    }\n",
    "169950": "    private int getCupRounds() {\n        return 16;\n    }\n",
    "169952": "    public int getTerraces() {\n        return terraces;\n    }\n",
    "169953": "    public void doExecute(OperationCell cell, HTWeek week) {\n        this.targetCell = cell;\n        this.week = week;\n\n        StadiumExpansionDialog dialog = new StadiumExpansionDialog(this,\n                                                                   (StadiumExpansionInner) cell.getOperation()\n                                                                                               .getInner());\n        dialog.setVisible(true);\n    }\n",
    "169954": "    private boolean isHome(int round, int teamRank) {\n        int teams = (int) Math.pow(2, getCupRounds() - round + 1);\n\n        if (teamRank > (teams / 2)) {\n            return true;\n        }\n\n        return false;\n    }\n",
    "169955": "    public StadiumExpansionInner getTotal() {\n        if (total == null) {\n            total = new StadiumExpansionInner();\n        }\n\n        return total;\n    }\n",
    "169956": "    public void doCalculate(int row, TableModel model) {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            HTWeek week = WeekHeader.instance().getColumnWeek(i);\n            StadiumExpansionInner stadiumSize = TeamPlanner.getStadiumPane().getStadiumSize(week);\n            double money = 0;\n            money = money + (stadiumSize.getTerraces() * 0.5);\n            money = money + (stadiumSize.getSeats() * 0.7);\n            money = money + (stadiumSize.getRoofs() * 1.0);\n            money = money + (stadiumSize.getVips() * 2.5);\n\n            OperationCell cell = (OperationCell) model.getValueAt(row, i);\n            cell.getOperation().getInner().setMoney((int) (-money));\n        }\n    }\n",
    "169958": "    private int getIncome(HTWeek week, int size, boolean isCupMatch) {\n        double attendance = getAttendanceAt(week);\n\n        if (isCupMatch) {\n            // TODO Is this ok to approx cup extra income?\n            attendance = attendance * 1.2d;\n        }\n\n        if (attendance > size) {\n            attendance = size;\n        }\n\n        double perc = (attendance * 1.0d) / (size * 1.0d);\n\n        double multiplier = 7 + (perc * 0.4);\n        int money = (int) (attendance * multiplier);\n        return money;\n    }\n",
    "169959": "    public void setAssistantCoaches(int i) {\n        assistantCoaches = i;\n    }\n",
    "169960": "    public int getNumRow() {\n        return crSpec[R].length;\n    }\n",
    "169961": "    public void setVips(int i) {\n        vips = i;\n    }\n",
    "169962": "    public int getAssistantCoaches() {\n        return assistantCoaches;\n    }\n",
    "169964": "    public int getVips() {\n        return vips;\n    }\n",
    "169965": "    public void setAssistantKeeper(int i) {\n        assistantKeeper = i;\n    }\n",
    "169966": "    private int getSeriesSize(int level) {\n        int size = 8 * (int) Math.pow(4, level - 1);\n\n        if (size > 8192) {\n            size = 8192;\n        }\n\n        return size;\n    }\n",
    "169967": "    public void addRoofs(int i) {\n        roofs += i;\n    }\n",
    "169968": "    public int getAssistantKeeper() {\n        return assistantKeeper;\n    }\n",
    "169969": "    public void addSeats(int i) {\n        seats += i;\n    }\n",
    "169971": "    public String getDescription() {\n        if (getChanges() > 0) {\n            return \"Hired \" + getChanges();\n        } else if (getChanges() < 0) {\n            return \"Fired \" + (-getChanges());\n        }\n\n        return \"\";\n    }\n",
    "169972": "    public void addTerraces(int i) {\n        terraces += i;\n    }\n",
    "169973": "    public void setDoctor(int i) {\n        doctor = i;\n    }\n",
    "169975": "    public void addVips(int i) {\n        vips += i;\n    }\n",
    "169976": "    public int getDoctor() {\n        return doctor;\n    }\n",
    "169978": "    private int getLevelSponsor(int level) {\n        switch (level) {\n            case 1:\n                return 120000;\n\n            case 2:\n                return 60000;\n\n            case 3:\n                return 25000;\n\n            case 4:\n                return 18000;\n\n            case 5:\n                return 14000;\n\n            case 6:\n                return 11000;\n        }\n\n        return 10000;\n    }\n",
    "169979": "    private double getCost(double number, int build, int destroy) {\n        if (number > 0) {\n            return number * build;\n        } else {\n            return number * destroy;\n        }\n    }\n",
    "169980": "    public int getFired() {\n        int fired = Math.min(0, assistantCoaches);\n        fired += Math.min(0, assistantKeeper);\n        fired += Math.min(0, phisio);\n        fired += Math.min(0, psico);\n        fired += Math.min(0, doctor);\n        fired += Math.min(0, spokesman);\n        return fired;\n    }\n",
    "169981": "    private double getWeekMultiplier(int spokesman, int week) {\n        // TODO DO it properly as an incremental curve over the season\n        double max = 1.0 + (spokesman / 20.0);\n        return 1.0 + ((max * week) / 16.0d);\n    }\n",
    "169982": "    public void doCalculate(int row, TableModel model) {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            HTWeek week = WeekHeader.instance().getColumnWeek(i);\n            int money = TeamPlanner.getExtrasPane().getStaff(week).getMoney();\n            OperationCell cell = Util.getOperationCell(model, row, i);\n            cell.getOperation().getInner().setMoney(money);\n        }\n    }\n",
    "169986": "    public void doExecute(OperationCell cell, HTWeek week) {\n        this.targetCell = cell;\n        this.week = week;\n\n        StaffDialog dialog = new StaffDialog(this, (StaffInner) cell.getOperation().getInner());\n        dialog.setVisible(true);\n    }\n",
    "169990": "    public String getDescription() {\n        StringBuffer sb = new StringBuffer();\n        sb.append(player.getName());\n        sb.append(\" (\");\n        sb.append(player.getSpielerID());\n        return sb.toString();\n    }\n",
    "169991": "    public int getId() {\n        return player.getSpielerID();\n    }\n",
    "169993": "    public void setMoney(int i) {\n        this.money = i;\n    }\n",
    "169994": "    public int getMoney() {\n        if (expenses) {\n            return getFired() * 1500;\n        }\n\n        return getChanges() * -1500;\n    }\n",
    "169996": "    public void setRow(double[] row) {\n        setCr(R, row);\n    }\n",
    "169999": "    public ISpieler getPlayer() {\n        return player;\n    }\n",
    "170000": "    public void setPhisio(int i) {\n        phisio = i;\n    }\n",
    "170004": "    public int getPhisio() {\n        return phisio;\n    }\n",
    "170006": "    private void jbInit() {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.add(p, BorderLayout.NORTH);\n        pack();\n    }\n",
    "170007": "    public void setPsico(int i) {\n        psico = i;\n    }\n",
    "170010": "    public int getPsico() {\n        return psico;\n    }\n",
    "170012": "    public void setSpokesman(int i) {\n        spokesman = i;\n    }\n",
    "170016": "    public int getSpokesman() {\n        return spokesman;\n    }\n",
    "170017": "    private void jbInit() {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.add(panel, BorderLayout.NORTH);\n        pack();\n    }\n",
    "170018": "    public StaffInner getTotal() {\n        if (total == null) {\n            total = new StaffInner();\n            total.expenses = false;\n        }\n\n        return total;\n    }\n",
    "170019": "    public void setFixedSell() {\n        type.setSelectedIndex(0);\n        type.setEnabled(false);\n    }\n",
    "170024": "    public void setRow(int i, double size) {\n        setCr(R, i, size);\n    }\n",
    "170026": "    public void addAssistantCoaches(int i) {\n        assistantCoaches += i;\n    }\n",
    "170029": "    public void addAssistantKeeper(int i) {\n        assistantKeeper += i;\n    }\n",
    "170031": "    public void addDoctor(int i) {\n        doctor += i;\n    }\n",
    "170032": "    private void jbInit() {\n        type.addItem(\"Fixed Date\");\n        type.addItem(\"Linked Date\");\n        panel = Commons.getModel().getGUI().createImagePanel();\n        panel.setLayout(new BorderLayout());\n\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.add(panel, BorderLayout.CENTER);\n        pack();\n    }\n",
    "170034": "    public PlayerData getPlayerData() {\n        return tempSpieler;\n    }\n",
    "170035": "    public void addPhisio(int i) {\n        phisio += i;\n    }\n",
    "170038": "    public void addPsico(int i) {\n        psico += i;\n    }\n",
    "170041": "    public void addSpokesman(int i) {\n        spokesman += i;\n    }\n",
    "170043": "    public void doExecute(OperationCell cell, HTWeek week) {\n        this.week = week;\n        dialog.reload(week);\n        dialog.setVisible(true);\n    }\n",
    "170044": "    public int getPrice() {\n        String epv = jtfEPV.getText();\n\n        try {\n            return dfPrice.parse(epv).intValue();\n        } catch (Exception e) {\n        }\n\n        return 0;\n    }\n",
    "170045": "    private int getChanges() {\n        return assistantCoaches + assistantKeeper + psico + phisio + doctor + spokesman;\n    }\n",
    "170047": "    public void doExecute(OperationCell cell, HTWeek week) {\n        dialog.reload(week);\n        dialog.setVisible(true);\n    }\n",
    "170048": "    public void doExecute(OperationCell cell, HTWeek week) {\n        this.week = week;\n\n        if (cell.getOperationList().size() > 0) {\n            traineesDialog.reload(cell.getOperationList());\n            traineesDialog.setVisible(true);\n        }\n    }\n",
    "170051": "    public void doCalculate(int row, TableModel model) {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            OperationCell cell = Util.getOperationCell(model, row, i);\n            HTWeek week = WeekHeader.instance().getColumnWeek(i);\n            int salary = TeamPlayerManager.getSalary(week);\n            cell.getOperation().getInner().setMoney(-salary);\n        }\n    }\n",
    "170052": "    public void doCalculate(int row, TableModel model) {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            HTWeek week = WeekHeader.instance().getColumnWeek(i);\n            int account = TeamPlanner.getStadiumPane().getBaseBalance(week);\n            account = account + TeamPlanner.getPlayersPane().getBaseBalance(week);\n            account = account + TeamPlanner.getExtrasPane().getBaseBalance(week);\n\n            OperationCell cell = Util.getOperationCell(model, row, i);\n            cell.getOperation().getInner().setMoney(account);\n        }\n    }\n",
    "170053": "    public void doCalculate(int row, TableModel model) {\n        int account = 10000;\n\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            account += Util.getOperationCell(model, RecapPane.WEEKTOTAL_ROW, i).getBalance();\n\n            OperationCell cell = Util.getOperationCell(model, row, i);\n            cell.getOperation().getInner().setMoney(account);\n        }\n    }\n",
    "170054": "    public void doCalculate(int row, TableModel model) {\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            HTWeek week = WeekHeader.instance().getColumnWeek(i);\n            int account = TeamPlanner.getStadiumPane().getFullBalance(week);\n            account = account + TeamPlanner.getPlayersPane().getFullBalance(week);\n            account = account + TeamPlanner.getExtrasPane().getFullBalance(week);\n\n            OperationCell cell = Util.getOperationCell(model, row, i);\n            cell.getOperation().getInner().setMoney(account);\n        }\n    }\n",
    "170055": "    public int getColumnIndex(HTWeek week) {\n        return columns.indexOf(week);\n    }\n",
    "170056": "    public double getRow(int i) {\n        return crSpec[R][i];\n    }\n",
    "170057": "    public HTWeek getColumnWeek(int columnIndex) {\n        return (HTWeek) columns.get(columnIndex);\n    }\n",
    "170058": "    public Vector getValues() {\n        return columns;\n    }\n",
    "170059": "    public void reload() {\n        this.columns = new Vector();\n\n        for (int i = 0; i < IFutureTrainingManager.FUTUREWEEKS; i++) {\n            HTWeek week = TeamPlanner.ACTUALWEEK.copy();\n            week.addWeek(i + 1);\n            columns.add(week);\n        }\n    }\n",
    "170060": "    public void initialize() {\n        loadInputData();\n        refreshTable();\n        initializeListeners();\n    }\n",
    "170063": "    private double getWeekChange(int weekNumber, int results) {\n        //TODO morale depends also on spokesman,\n        if (weekNumber < 2) {\n            return 0;\n        }\n\n        // TODO Depends on weeknumber also? like log?\n        switch (results) {\n            case 1:\n                return -0.8;\n\n            case 2:\n                return -0.25d;\n\n            case 3:\n                return -0.15;\n\n            case 4:\n                return 0.15;\n\n            case 5:\n                return 0.3d;\n\n            case 6:\n                return 0.5d;\n\n            case 7:\n                return 1.0d;\n\n            default:\n                return 0.0d;\n        }\n    }\n",
    "170064": "    public void refreshTable() {\n        int count = 0;\n\n        // Changed input field, recalculate all calculated rows\n        for (Iterator iter = calcRows.iterator(); iter.hasNext();) {\n            Calculator listener = (Calculator) iter.next();\n            listener.doCalculate(inputRows.size() + count, model);\n            count++;\n        }\n\n        table.updateUI();\n    }\n",
    "170067": "    protected int getColumnIndex(HTWeek week) {\n        return WeekHeader.instance().getColumnIndex(week);\n    }\n",
    "170069": "    private int getFanIncrease(int fans, double fanMorale) {\n        // TODO Fans depends on number of fans and series\n        int intValue = (int) fanMorale;\n\n        switch (intValue) {\n            case 1:\n                return -25;\n\n            case 2:\n                return -18;\n\n            case 3:\n                return -7;\n\n            case 4:\n                return 4;\n\n            case 5:\n                return 9;\n\n            case 6:\n                return 14;\n\n            case 7:\n                return 18;\n        }\n\n        return 0;\n    }\n",
    "170070": "    public void refresh() {\n    }\n",
    "170071": "    protected HTWeek getColumnWeek(int columnIndex) {\n        return WeekHeader.instance().getColumnWeek(columnIndex);\n    }\n",
    "170072": "    public void refresh() {\n        Vector values = FinanzenDAO.getFinancesHistory(16);\n\n        historyTableModel.refresh(values);\n    }\n",
    "170073": "    private void markierenComboBox(javax.swing.JComboBox combobox, int id) {\n        final javax.swing.ComboBoxModel model = combobox.getModel();\n\n        for (int i = 0; i < model.getSize(); i++) {\n            if (((CBItem) (model.getElementAt(i))).getId() == id) {\n                combobox.setSelectedItem(model.getElementAt(i));\n                break;\n            }\n        }\n    }\n",
    "170074": "    public Rectangle getCellBounds(int index0, int index1) {\n        Rectangle rect0 = table.getCellRect(index0, 0, true);\n        Rectangle rect1 = table.getCellRect(index1, 0, true);\n        int y;\n        int height;\n\n        if (rect0.y < rect1.y) {\n            y = rect0.y;\n            height = (rect1.y + rect1.height) - y;\n        } else {\n            y = rect1.y;\n            height = (rect0.y + rect0.height) - y;\n        }\n\n        return new Rectangle(0, y, getFixedCellWidth(), height);\n    }\n",
    "170075": "    protected void addCalculatedRow(String text, Calculator listener) {\n        addCalculatedRow(text, listener, new NumericInner());\n    }\n",
    "170077": "    public Object getElementAt(int index) {\n        return null;\n    }\n",
    "170078": "    public int getSize() {\n        return table.getRowCount();\n    }\n",
    "170080": "    protected void addCalculatedRow(String text, Calculator listener, InnerData inner) {\n        model.setEditable(inputRows.size(), false);\n        model.setMulti(inputRows.size(), false);\n        model.setInner(inputRows.size(), inner.getClass());\n        calcRows.add(listener);\n        rowHeader.add(text);\n    }\n",
    "170084": "    protected void addInputRow(String text, InputListener listener, boolean multi, InnerData inner) {\n        model.setEditable(inputRows.size(), false);\n        model.setMulti(inputRows.size(), multi);\n        model.setInner(inputRows.size(), inner.getClass());\n        inputRows.add(listener);\n        rowHeader.add(text);\n    }\n",
    "170085": "    public void setVGap(int vGap) {\n        if (vGap >= 0) {\n            this.vGap = vGap;\n        }\n        else {\n            throw new IllegalArgumentException(\n                \"Parameter vGap must be non-negative.\"); //$NON-NLS-1$\n        }\n    }\n",
    "170089": "    protected void addManualRow(String text) {\n        model.setEditable(inputRows.size(), true);\n        model.setMulti(inputRows.size(), false);\n        model.setInner(inputRows.size(), NumericInner.class);\n        inputRows.add(new DefaultInputListener());\n        rowHeader.add(text);\n    }\n",
    "170092": "    private void setColumnWidths() {\n        for (int i = table.getColumnCount() - 1; i >= 0; i--) {\n            table.getColumnModel().getColumn(i).setMinWidth(MIN_COLUMN_WIDTH);\n        }\n    }\n",
    "170096": "    private void initializeListeners() {\n        table.addMouseListener(new MouseActionListener());\n        model.addTableModelListener(new OperationModelListener());\n    }\n",
    "170103": "        public void mouseClicked(MouseEvent e) {\n            if (e.getClickCount() == 2) {\n                int row = table.getSelectedRow();\n\n                if (row >= inputRows.size()) {\n                    return;\n                }\n\n                int column = table.getSelectedColumn();\n                InputListener listener = (InputListener) inputRows.get(row);\n                OperationCell cell = (OperationCell) model.getValueAt(row, column);\n\n                listener.doExecute(cell, getColumnWeek(column));\n                table.updateUI();\n                model.fireTableDataChanged();\n            }\n        }\n",
    "170106": "        public void tableChanged(TableModelEvent e) {\n            int row = table.getSelectedRow();\n\n            if (row < inputRows.size()) {\n                refreshTable();\n            }\n\n            onChange();\n        }\n",
    "170108": "    public int getVGap() {\n        return vGap;\n    }\n",
    "170128": "    public void addLayoutComponent(String name, Component component) {\n        addLayoutComponent(component, name);\n    }\n",
    "170130": "    private double getCoolnessScore(TreeSet flags) {\n    \tdouble ret = 0;\n    \tif (flags != null) {\n    \t\tfor (Iterator i=flags.iterator(); i.hasNext(); ) {\n    \t\t\tFlagObject fo = (FlagObject)i.next();\n    \t\t\tif (fo != null) {\n    \t\t\t\tret += fo.getCoolness();\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn ret;\n    }\n",
    "170163": "    public void deleteColumn(int i) {\n        deleteCr(C, i);\n    }\n",
    "170171": "    public void deleteRow(int i) {\n        deleteCr(R, i);\n    }\n",
    "170179": "    public void insertColumn(int i, double size) {\n        insertCr(C, i, size);\n    }\n",
    "170197": "    public void insertRow(int i, double size) {\n        insertCr(R, i, size);\n    }\n",
    "170205": "    public void setLigaId(int i) {\n        ligaId = i;\n    }\n",
    "170206": "    public int getLigaId() {\n        return ligaId;\n    }\n",
    "170207": "    public String getName() {\n        return getPluginName() + \" \" + getVersion();\n    }\n",
    "170210": "    public String getPluginName() {\n        return \"Team of the Week\";\n    }\n",
    "170213": "    public double getVersion() {\n        return VERSION;\n    }\n",
    "170214": "    public String toString() {\n        return name + \" \" + season;\n    }\n",
    "170216": "    public void refresh() {\n        ui.reloadData(true);\n    }\n",
    "170218": "    public void setPants(String string) {\n        pants = string;\n    }\n",
    "170221": "    public void invalidateLayout(Container target) {\n        dirty = true;\n    }\n",
    "170222": "    public String getPants() {\n        return pants;\n    }\n",
    "170223": "    public int getPositionCode() {\n        return PositionCode;\n    }\n",
    "170224": "    public void setShirt(String string) {\n        shirt = string;\n    }\n",
    "170225": "    public float getRating() {\n        return Rating;\n    }\n",
    "170226": "    public String getShirt() {\n        return shirt;\n    }\n",
    "170227": "    public int getSpielerID() {\n        return SpielerID;\n    }\n",
    "170228": "    public void setSocks(String string) {\n        socks = string;\n    }\n",
    "170230": "    public String getSocks() {\n        return socks;\n    }\n",
    "170232": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"MatchLineupPlayer[\");\n        buffer.append(\"TeamID = \").append(TeamID);\n        buffer.append(\", PositionCode = \").append(PositionCode);\n        buffer.append(\", SpielerID = \").append(SpielerID);\n        buffer.append(\", Rating = \").append(Rating);\n        buffer.append(\", nname = \").append(nname);\n        buffer.append(\"]\");\n        return buffer.toString();\n    }\n",
    "170234": "    public LineupPanel getLineup() {\n        return p;\n    }\n",
    "170235": "    public void stateChanged(ChangeEvent e) {\n        JSpinner week = (JSpinner) e.getSource();\n        TotW.setWeek(((Integer) week.getValue()).intValue());\n        TotW.forceRefresh(false);\n    }\n",
    "170237": "    public void actionPerformed(ActionEvent arg0) {\n        List teams = DBManager.getMatchList(TotW.getWeek(), TotW.getSeason());\n\n        for (Iterator iter = teams.iterator(); iter.hasNext();) {\n            String id = (String) iter.next();\n\n            try {\n                int matchId = Integer.parseInt(id);\n                Commons.getModel().getHelper().downloadMatchData(matchId);\n            } catch (Exception e) {\n            }\n        }\n\n        TotW.forceRefresh(true);\n    }\n",
    "170238": "    public void actionPerformed(ActionEvent arg0) {\n        SpinnerNumberModel cSNM = null;\n        JComboBox league = (JComboBox) arg0.getSource();\n        LigaItem item = (LigaItem) league.getSelectedItem();\n        TotW.setSeason(item.getSeason());\n        TotW.setLiga(item.getLigaId());\n        TotW.setWeek(1);\n\n        if (TotW.getModel().getBasics().getSeason() == TotW.getSeason()) {\n            cSNM = new SpinnerNumberModel(1, 1, TotW.getMaxWeek(), 1);\n        } else {\n            cSNM = new SpinnerNumberModel(1, 1, 14, 1);\n        }\n\n        weekSpinner.setModel(cSNM);\n        TotW.forceRefresh(true);\n    }\n",
    "170239": "    public void actionPerformed(ActionEvent arg0) {\n        List teams = DBManager.getTeamList(TotW.getWeek(), TotW.getSeason());\n\n        for (Iterator iter = teams.iterator(); iter.hasNext();) {\n            String id = (String) iter.next();\n\n            try {\n                TeamColorDAO.store(downloadTeam(Integer.parseInt(id)));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        TotW.forceRefresh(true);\n    }\n",
    "170240": "    public void reloadData(boolean isSeason) {\n        MatchLineupPlayer[] sl = LineupCalculator.calcBestLineup(TotW.getWeek(), TotW.getSeason(),\n                                                                 true);\n        fillLineup(bestOfWeek, sl, false);\n        sl = LineupCalculator.calcBestLineup(TotW.getWeek(), TotW.getSeason(), false);\n        fillLineup(worstOfWeek, sl, false);\n\n        if (isSeason) {\n            sl = LineupCalculator.calcBestLineup(-1, TotW.getSeason(), true);\n            fillLineup(bestOfYear, sl, false);\n            sl = LineupCalculator.calcBestLineup(-1, TotW.getSeason(), false);\n            fillLineup(worstOfYear, sl, false);\n        }\n    }\n",
    "170255": "    private void fillPanel(JPanel panel, MatchLineupPlayer mlp) {\n        fillPanel(panel, mlp, false);\n    }\n",
    "170258": "    private void fillSeasonCombo(JComboBox seasonCombo) {\n        Iterator it = DBManager.getLeagues().iterator();\n\n        while (it.hasNext()) {\n            seasonCombo.addItem(it.next());\n        }\n    }\n",
    "170263": "    private int toInt(float i) {\n        return (new Float(i * 2.0F)).intValue();\n    }\n",
    "170281": "    public Dimension minimumLayoutSize(Container container) {\n        return calculateLayoutSize(container, MINIMUM);\n    }\n",
    "170300": "    public int getPluginID() {\n        return 11;\n    }\n",
    "170301": "    public String getPluginName() {\n        return \"SeriesStats\";\n    }\n",
    "170302": "    public double getVersion() {\n        return 1.0;\n    }\n",
    "170303": "    public void refresh() {\n        Date now = new Date();\n        long nowLong = now.getTime();\n\n        IDB.append(\"\" + nowLong + \": refresh\");\n    }\n",
    "170307": "    public Dimension preferredLayoutSize(Container container) {\n        return calculateLayoutSize(container, PREFERRED);\n    }\n",
    "170322": "    public void removeLayoutComponent(Component component) {\n        // Remove the component\n        ListIterator iterator = list.listIterator(0);\n\n        while (iterator.hasNext()) {\n            Entry entry = (Entry) iterator.next();\n\n            if (entry.component == component) {\n                iterator.remove();\n            }\n        }\n\n        // Indicate that the cell sizes are not known since\n        dirty = true;\n    }\n",
    "170323": "    public JCheckBox getBox() {\n        return jcbBox;\n    }\n",
    "170324": "    public void aAL(ActionListener AL) {\n        jcbBox.addActionListener(AL);\n    }\n",
    "170325": "    public void aIL(ItemListener IL) {\n        jcbBox.addItemListener(IL);\n    }\n",
    "170327": "    public boolean is() {\n        if (isSelected) {\n            isSelected = false;\n        } else {\n            isSelected = true;\n        }\n\n        return isSelected;\n    }\n",
    "170328": "    public void rAL(ActionListener AL) {\n        jcbBox.removeActionListener(AL);\n    }\n",
    "170343": "\tpublic void refresh() {\n\t\t// TODO Implement this\n\t\tSystem.out.println(\"SeriesPanel Tab Refresh\");\n\t}\n",
    "170344": "    public String toString() {\n        int counter;\n\n        String value = \"TableLayout {{\"; //$NON-NLS-1$\n\n        if (crSpec[C].length > 0) {\n            for (counter = 0; counter < (crSpec[C].length - 1); counter++) {\n                value += (crSpec[C][counter] + \", \"); //$NON-NLS-1$\n            }\n\n            value += (crSpec[C][crSpec[C].length - 1] + \"}, {\"); //$NON-NLS-1$\n        }\n        else {\n            value += \"}, {\"; //$NON-NLS-1$\n        }\n\n        if (crSpec[R].length > 0) {\n            for (counter = 0; counter < (crSpec[R].length - 1); counter++) {\n                value += (crSpec[R][counter] + \", \"); //$NON-NLS-1$\n            }\n\n            value += (crSpec[R][crSpec[R].length - 1] + \"}}\"); //$NON-NLS-1$\n        }\n        else {\n            value += \"}}\"; //$NON-NLS-1$\n",
    "170347": "    private void refreshPanelBewertung() {\n        // TODO Implement this\n        System.out.println(\"Repainting Called\");\n    }\n",
    "170349": "    public void refresh() {\n        // TODO Implement this\n        System.out.println(\"GeneralPanel Tab Refresh\");\n    }\n",
    "170350": "    public void actionPerformed(ActionEvent event) {\n        if (event.getSource().equals(JCBDivision)) {\n            RefreshTeamBox();\n            RefreshTypeBox();\n        }\n\n        refreshablePanel.refresh();\n    }\n",
    "170356": "    private void RefreshTypeBox() {\n        try {\n            this.JCBType.removeActionListener(this);\n\n            // Clear ComboBox\n            this.JCBType.removeAllItems();\n            this.JCBType.addItem(\"Average\");\n\n            this.JCBType.addActionListener(this);\n        } catch (Exception e) {\n            if (true) {\n                SeriesStats.getIDB().append(\"---ooo---\");\n                SeriesStats.getIDB().append(e);\n            }\n        }\n    }\n",
    "170357": "    public void setTeam1AttackCenter(double value) {\n        this.Team1AttackCenter.setText(this.generateText(value));\n        this.Team1AttackCenterValue = value;\n    }\n",
    "170359": "    private String prepareLigaString(int s, String l, int lid) {\n        return Commons.getModel().getResource().getProperty(\"Season\") + \" \" + s + \" \"\n               + Commons.getModel().getResource().getProperty(\"Liga\") + \" \" + l + \" (\" + lid + \")\";\n    }\n",
    "170363": "    public void setTeam1AttackLeft(double value) {\n        this.Team1AttackLeft.setText(this.generateText(value));\n        this.Team1AttackLeftValue = value;\n    }\n",
    "170374": "    public void setTeam1AttackRight(double value) {\n        this.Team1AttackRight.setText(this.generateText(value));\n        this.Team1AttackRightValue = value;\n    }\n",
    "170377": "    public void setValue(int newValue) {\n        value = newValue;\n    }\n",
    "170378": "    public int getValue() {\n        return value;\n    }\n",
    "170379": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"Skillup[\"); //$NON-NLS-1$\n        buffer.append(\", type = \" + type); //$NON-NLS-1$\n        buffer.append(\", value = \" + value); //$NON-NLS-1$\n        buffer.append(\", htSeason = \" + htSeason); //$NON-NLS-1$\n        buffer.append(\", htWeek = \" + htWeek); //$NON-NLS-1$\n        buffer.append(\", trainType = \" + trainType); //$NON-NLS-1$\n        buffer.append(\"]\"); //$NON-NLS-1$\n\n        return buffer.toString();\n    }\n",
    "170381": "    public ISkillup getSkillup() {\n        return skillup;\n    }\n",
    "170383": "    public void setTeam1Attitude(double value) {\n        this.Team1Attitude.setText(this.generateText(value));\n    }\n",
    "170384": "    public void setAmountSkillups(int amount) {\n        this.skillups = amount;\n    }\n",
    "170387": "    public int getAmountSkillups() {\n        return skillups;\n    }\n",
    "170389": "    public double getAverageForm() {\n        return avgForm;\n    }\n",
    "170391": "    public void setTeam1DefenseCenter(double value) {\n        this.Team1DefenseCenter.setText(this.generateText(value));\n        this.Team1DefenseCenterValue = value;\n    }\n",
    "170392": "    public void setAverageTSI(int avgTSI) {\n        this.avgTSI = avgTSI;\n    }\n",
    "170393": "    public int getAverageTSI() {\n        return avgTSI;\n    }\n",
    "170395": "    public int getFormDecrease() {\n        return formDecrease;\n    }\n",
    "170396": "    public int getFormIncrease() {\n        return formIncrease;\n    }\n",
    "170397": "    public void setTeam1DefenseLeft(double value) {\n        this.Team1DefenseLeft.setText(this.generateText(value));\n        this.Team1DefenseLeftValue = value;\n    }\n",
    "170399": "    public int getHRFafterUpdate() {\n        return this.hrfIdAfter;\n    }\n",
    "170400": "    public int getHRFbeforeUpdate() {\n        return this.hrfIdBefore;\n    }\n",
    "170401": "    public int getHattrickSeason() {\n        return trainseason;\n    }\n",
    "170403": "    public int getHattrickWeek() {\n        return trainweek;\n    }\n",
    "170404": "    public void setTeam1DefenseRight(double value) {\n        this.Team1DefenseRight.setText(this.generateText(value));\n        this.Team1DefenseRightValue = value;\n    }\n",
    "170405": "    public int getTSIDecrease() {\n        return tsiDecrease;\n    }\n",
    "170407": "    public int getTSIIncrease() {\n        return tsiIncrease;\n    }\n",
    "170409": "    public void setTotalTSI(int totalTSI) {\n        this.totalTSI = totalTSI;\n    }\n",
    "170411": "    public void setTeam1HomeAway(double value) {\n        this.Team1HomeAway.setText(this.generateText(value));\n    }\n",
    "170412": "    public int getTotalTSI() {\n        return totalTSI;\n    }\n",
    "170413": "    public void setTrainingType(int trainingType) {\n        this.trainingType = trainingType;\n    }\n",
    "170414": "    public int getTrainingType() {\n        return trainingType;\n    }\n",
    "170417": "    public void setTeam1Midfield(double value) {\n        this.Team1Midfield.setText(this.generateText(value));\n        this.Team1MidfieldValue = value;\n    }\n",
    "170420": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"TrainWeekEffect[\");\n        buffer.append(\" HT season = \" + trainseason);\n        buffer.append(\", HT week = \" + trainweek);\n        buffer.append(\", hrf before = \" + hrfIdBefore);\n        buffer.append(\", hrf after = \" + hrfIdAfter);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "170424": "    public void setTeam1System(double value) {\n        this.Team1System.setText(this.generateText(value));\n    }\n",
    "170425": "    public void setStaminaTrainingPart(int staminaTrainingPart) {\n        this.staminaTrainingPart = staminaTrainingPart;\n    }\n",
    "170426": "    public int getStaminaTrainingPart() {\n        return staminaTrainingPart;\n    }\n",
    "170428": "    public void setIntensitaet(int intensity) {\n        intensitaet = intensity;\n    }\n",
    "170429": "    public int getIntensitaet() {\n        return intensitaet;\n    }\n",
    "170430": "    public void setSeason(int season) {\n        this.season = season;\n    }\n",
    "170431": "    protected int assignAbsoluteSize(int z, int availableSize) {\n        int numCr = crSpec[z].length;\n\n        for (int counter = 0; counter < numCr; counter++) {\n            if ((crSpec[z][counter] >= 1.0) || (crSpec[z][counter] == 0.0)) {\n                crSize[z][counter] = (int) (crSpec[z][counter] + 0.5);\n                availableSize -= crSize[z][counter];\n            }\n        }\n\n        return availableSize;\n    }\n",
    "170433": "    public void setTyp(int type) {\n        typ = type;\n    }\n",
    "170434": "    public void setTeam1Tactic(double value) {\n        this.Team1Tactic.setText(this.generateText(value));\n    }\n",
    "170435": "    public int getTyp() {\n        return typ;\n    }\n",
    "170437": "    public void setWeek(int week) {\n        this.week = week;\n    }\n",
    "170439": "    public String toString() {\n        StringBuffer buffer = new StringBuffer();\n\n        buffer.append(\"HattrickTrainingWeek[\");\n        buffer.append(\"intensitaet = \" + intensitaet);\n        buffer.append(\", season = \" + season);\n        buffer.append(\", typ = \" + typ);\n        buffer.append(\", week = \" + week);\n        buffer.append(\"]\");\n\n        return buffer.toString();\n    }\n",
    "170441": "    public void setTeam1Tacticskill(double value) {\n        this.Team1Tacticskill.setText(this.generateText(value));\n    }\n",
    "170444": "    public List getFutureTrainings() {\n        return futureModel.getTrainingsData();\n    }\n",
    "170445": "    public OutputPanel getOutput() {\n        return output;\n    }\n",
    "170447": "    public Vector getOldTrainings() {\n        return oldTableModel.getTrainingsData();\n    }\n",
    "170448": "    public void reload() {\n        output.reload();\n        recap.reload();\n        analyzer.reload();\n        effect.reload();\n    }\n",
    "170449": "    public void reload() {\n        oldTableModel.populate();\n        futureModel.populate();\n        updateUI();\n    }\n",
    "170450": "    private void jbInit() {\n        setLayout(new BorderLayout());\n\n        JTabbedPane pane = new JTabbedPane();\n\n        pane.addTab(Commons.getModel().getResource().getProperty(\"Training\"), output);\n        pane.addTab(PluginProperty.getString(\"MainPanel.Prediction\"), recap);\n        pane.addTab(PluginProperty.getString(\"MainPanel.Analyzer\"), analyzer);\n        pane.addTab(PluginProperty.getString(\"MainPanel.Effect\"), effect);\n        add(pane, BorderLayout.CENTER);\n    }\n",
    "170452": "    public void setTeam1Teamspirit(double value) {\n        this.Team1Teamspirit.setText(this.generateText(value));\n    }\n",
    "170455": "    private float getSkillMaxValue(int index) {\n        if (index == 7) {\n            return 9f;\n        } else {\n            return 20f;\n        }\n    }\n",
    "170456": "    protected void resetFutureTraininhgs() {\n        IHOMiniModel p_IHMM_miniModel = Commons.getModel();\n        List futureTrainings = p_IHMM_miniModel.getFutureTrainingWeeks();\n\n        for (Iterator iter = futureTrainings.iterator(); iter.hasNext();) {\n            IFutureTrainingWeek train = (IFutureTrainingWeek) iter.next();\n            train.setIntensitaet(intensity.getSelectedIndex());\n            train.setStaminaTrainingPart(staminaTrainingPart.getSelectedIndex());\n            train.setTyp(Trainings.getTrainingCode((String) training.getSelectedItem()));\n            p_IHMM_miniModel.saveFutureTraining(train);\n        }\n\n        futureModel.populate();\n        TrainingExperience.getTrainPanel().updateUI();\n        TrainingExperience.refreshPlayerDetail();\n    }\n",
    "170458": "    private double getSkillValue(IFuturePlayer spieler, int skillIndex) {\n        switch (skillIndex) {\n            case ISpieler.SKILL_TORWART:\n                return spieler.getGoalkeeping();\n\n            case ISpieler.SKILL_TORSCHUSS:\n                return spieler.getAttack();\n\n            case ISpieler.SKILL_VERTEIDIGUNG:\n                return spieler.getDefense();\n\n            case ISpieler.SKILL_PASSSPIEL:\n                return spieler.getPassing();\n\n            case ISpieler.SKILL_SPIELAUFBAU:\n                return spieler.getPlaymaking();\n\n            case ISpieler.SKILL_STANDARDS:\n                return spieler.getSetpieces();\n\n            case ISpieler.SKILL_KONDITION:\n                return spieler.getStamina();\n\n            case ISpieler.SKILL_FLUEGEL:\n                return spieler.getCross();\n        }\n\n        return 0;\n    }\n",
    "170462": "    public void setTeam2AttackCenter(double value) {\n        this.Team2AttackCenter.setText(this.generateText(value));\n        this.Team2AttackCenterValue = value;\n    }\n",
    "170472": "    public void setTeam2AttackLeft(double value) {\n        this.Team2AttackLeft.setText(this.generateText(value));\n        this.Team2AttackLeftValue = value;\n    }\n",
    "170478": "    public boolean isCellEditable(int row, int column) {\n        return (column == 2 || column == 3 || column == 4);\n    }\n",
    "170481": "    public void setTeam2AttackRight(double value) {\n        this.Team2AttackRight.setText(this.generateText(value));\n        this.Team2AttackRightValue = value;\n    }\n",
    "170482": "    public int getColumnCount() {\n        return columnNames.length;\n    }\n",
    "170484": "    public void fillWithData() {\n        p_V_data = p_IHMM_HOMiniModel.getAllSpieler();\n        fireTableDataChanged();\n    }\n",
    "170485": "    public int getRowCount() {\n        return p_V_data.size();\n    }\n",
    "170486": "    public Vector getTrainingsData() {\n        return p_V_trainingsVector;\n    }\n",
    "170487": "    private double getTrainingLength (ISpieler player, int skillIndex) {\n        return player.getTrainingLength(Skills.getTrainedSkillCode(skillIndex),\n                TrainingExperience.getStaffPanel()\n                                  .getCoTrainerNumber(),\n                TrainingExperience.getStaffPanel()\n                                  .getKeeperTrainerNumber(),\n                TrainingExperience.getStaffPanel()\n                                  .getTrainerLevelNumber(),\n                p_IHMM_HOMiniModel.getTeam()\n                                  .getTrainingslevel(),\n                p_IHMM_HOMiniModel.getTeam()\n                                  .getStaminaTrainingPart());    \t\n    }\n",
    "170488": "    public Object getValueAt(int row, int column) {\n        Object[] aobj = (Object[]) p_V_data.get(row);\n\n        return aobj[column];\n    }\n",
    "170491": "    public void setTeam2Attitude(double value) {\n        this.Team2Attitude.setText(this.generateText(value));\n    }\n",
    "170492": "    private double getOffset(ISpieler player, int skill) {\n        double offset = player.getSubskill4SkillWithOffset(skill);\n        double length = getTrainingLength(player, skill);\n        return offset * length;\n    }\n",
    "170496": "    private VerticalIndicator createIcon(ISpieler spieler, int skillIndex) {\n        double point = getOffset(spieler, skillIndex);\n        double trainingLength = getTrainingLength(spieler, skillIndex);\n\n        VerticalIndicator vi = new VerticalIndicator(p_IHMM_HOMiniModel.getHelper().round(point, 1),\n                                                     p_IHMM_HOMiniModel.getHelper().round(trainingLength, 1));\n\n        return vi;\n    }\n",
    "170497": "    public String getToolTipText(MouseEvent e) {\n        TableModel tableModel = (TableModel) getModel();\n        java.awt.Point p = e.getPoint();\n        int rowIndex = rowAtPoint(p);\n        int type = ISkillup.SKILLUP_FUTURE;\n\n        try {\n            type = Integer.parseInt((String) tableModel.getValueAt(rowIndex, 3));\n        } catch (NumberFormatException ex) {\n        }\n\n        if (type == ISkillup.SKILLUP_REAL) {\n            Object obj = tableModel.getValueAt(rowIndex, 4);\n\n            return obj.toString();\n        }\n\n        return \"\"; //$NON-NLS-1$\n    }\n",
    "170500": "        public int filterRGB(int x, int y, int rgb) {\n            if (transparency && ((rgb | 0xff000000) == transparentColor)) {\n                return 0;\n            } else if (rgb == oldColor) {\n                return newColor;\n            } else {\n                return rgb;\n            }\n        }\n",
    "170501": "    public void setTeam2DefenseCenter(double value) {\n        this.Team2DefenseCenter.setText(this.generateText(value));\n        this.Team2DefenseCenterValue = value;\n    }\n",
    "170504": "    public double getPercentage() {\n        return actual / total * 100d;\n    }\n",
    "170505": "    public void change(int lvl1, int lvl2) {\n        level1 = lvl1;\n        level2 = lvl2;\n\n        String desc = \"\"; //$NON-NLS-1$\n\n        if (lvl1 > 0) {\n            desc = desc + Commons.getModel().getResource().getProperty(\"Aktuell\") + lvl1 + \"% \"; //$NON-NLS-1$ //$NON-NLS-2$\n        }\n\n        if (lvl2 > 0) {\n            desc = desc + PluginProperty.getString(\"Final\") + lvl2 + \"% \"; //$NON-NLS-1$ //$NON-NLS-2$\n        }\n\n        setToolTipText(desc);\n\n        paintImmediately(getBounds());\n    }\n",
    "170506": "    public String getText() {\n        return actual + \"(\" + total + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n    }\n",
    "170507": "    public String getToolTipText() {\n        return actual + \"(\" + total + \")\"; //$NON-NLS-1$ //$NON-NLS-2$\n    }\n",
    "170510": "    private void setLevelBar(java.awt.Graphics2D g2d, int level, ColorModus cm) {\n        int height = getHeight();\n        int width = getWidth() - 10;\n        int laenge = (int) ((float) width * ((float) level / 100f));\n\n        g2d.setColor(cm.dunkel);\n        g2d.fillRect(5, (int) (height / 3), laenge, (int) (height / 3));\n        g2d.setColor(cm.mittel);\n        g2d.fillRect(6, (int) (height / 2.6f), laenge - 2, (int) (height / 5));\n        g2d.setColor(cm.hell);\n        g2d.fillRect(7, (int) (height / 2.3f), laenge - 3, (int) (height / 8));\n    }\n",
    "170512": "    public void setLevel(float value) {\n        this.end = (int) (value * length);\n        paintImmediately(getBounds());\n    }\n",
    "170513": "    public void setTeam2DefenseLeft(double value) {\n        this.Team2DefenseLeft.setText(this.generateText(value));\n        this.Team2DefenseLeftValue = value;\n    }\n",
    "170526": "    public void setTeam2DefenseRight(double value) {\n        this.Team2DefenseRight.setText(this.generateText(value));\n        this.Team2DefenseRightValue = value;\n    }\n",
    "170527": "    protected int assignRelativeSize(int z, int availableSize) {\n        int relativeSize = (availableSize < 0) ? 0 : availableSize;\n        int numCr = crSpec[z].length;\n\n        for (int counter = 0; counter < numCr; counter++) {\n            if ((crSpec[z][counter] > 0.0) && (crSpec[z][counter] < 1.0)) {\n                crSize[z][counter] = (int) ((crSpec[z][counter] * relativeSize)\n                    + 0.5);\n\n                availableSize -= crSize[z][counter];\n            }\n        }\n\n        return availableSize;\n    }\n",
    "170533": "    public void reload() {\n        OutputTableSorter otm = (OutputTableSorter) m_jtOutputTable.getModel();\n\n        otm.fillWithData();\n    }\n",
    "170537": "    public void setTeam2HomeAway(double value) {\n        this.Team2HomeAway.setText(this.generateText(value));\n    }\n",
    "170542": "    public void reload() {\n        this.skillups = getSkillups(Commons.getModel().getAllSpieler());\n        this.skillupsOld = getSkillups(Commons.getModel().getAllOldSpieler());\n        updateFilterPanel();\n        updateTableModel();\n\n        updateUI();\n    }\n",
    "170544": "    public void setTeam2Midfield(double value) {\n        this.Team2Midfield.setText(this.generateText(value));\n        this.Team2MidfieldValue = value;\n    }\n",
    "170545": "    public JTable getLockedTable() {\n        return fixed;\n    }\n",
    "170547": "    public JTable getScrollTable() {\n        return scroll;\n    }\n",
    "170548": "    public void addRow(ISkillup skillup) {\n        Vector v = new Vector();\n\n        v.add(Skills.getSkillDescription(skillup.getType()) + \": \" //$NON-NLS-1$\n              + Commons.getModel().getHelper().getNameForSkill(skillup.getValue(), true));\n        v.add(\"\" + skillup.getHtWeek()); //$NON-NLS-1$\n        v.add(\"\" + skillup.getHtSeason()); //$NON-NLS-1$\n        v.add(\"\" + skillup.getTrainType()); //$NON-NLS-1$\n        v.add(\"\" + skillup.getDate()); //$NON-NLS-1$\n        v.add(\"\" + skillup.getType()); //$NON-NLS-1$\n        tableModel.insertRow(0, v);\n    }\n",
    "170553": "    public void setTeam2System(double value) {\n        this.Team2System.setText(this.generateText(value));\n    }\n",
    "170556": "    private Map getSkillups(List players) {\n        Map skillupsByType = new HashMap();\n\n        for (Iterator iter = players.iterator(); iter.hasNext();) {\n            ISpieler player = (ISpieler) iter.next();\n\n            OldTrainingManager otm = new OldTrainingManager(player);\n\n            List skillups = otm.getAllSkillups();\n\n            for (Iterator iterator = skillups.iterator(); iterator.hasNext();) {\n                ISkillup skillup = (ISkillup) iterator.next();\n                Integer skillType = new Integer(skillup.getType());\n\n                List skillChanges = (List) skillupsByType.get(skillType);\n\n                if (skillChanges == null) {\n                    skillChanges = new Vector();\n                    skillupsByType.put(skillType, skillChanges);\n                }\n\n                skillChanges.add(new SkillChange(player, skillup));\n            }\n        }\n\n        return skillupsByType;\n    }\n",
    "170560": "    public void setTeam2Tactic(double value) {\n        this.Team2Tactic.setText(this.generateText(value));\n    }\n",
    "170562": "    public int getCoTrainerNumber() {\n        return coTrainerNumber;\n    }\n",
    "170564": "    public int getKeeperTrainerNumber() {\n        return keeperTrainerNumber;\n    }\n",
    "170565": "    public int getTrainerLevelNumber() {\n        return trainerLevelNumber;\n    }\n",
    "170567": "    public void setTeam2Tacticskill(double value) {\n        this.Team2Tacticskill.setText(this.generateText(value));\n    }\n",
    "170568": "    public void reload() {\n        setKeeper(Commons.getModel().getVerein().getTorwartTrainer());\n        setCoTrainer(Commons.getModel().getVerein().getCoTrainer());\n        setTrainer(Commons.getModel().getTrainer().getTrainer() - 1);\n    }\n",
    "170569": "    public List getAllSkillups() {\n        return allSkillups;\n    }\n",
    "170570": "    private void setAssistantComboBox() {\n        coTrainer = new JComboBox();\n\n        for (int i = 0; i < 11; i++) {\n            coTrainer.addItem(new Integer(i));\n        }\n    }\n",
    "170572": "    private void setCoTrainer(int value) {\n        if (value > 10) {\n            value = 10;\n        }\n\n        try {\n            coTrainer.setSelectedIndex(value);\n        } catch (Exception e) {\n        }\n    }\n",
    "170574": "    private void setKeeper(int value) {\n        if (value > 10) {\n            value = 10;\n        }\n\n        try {\n            keeperTrainer.setSelectedIndex(value);\n        } catch (Exception e) {\n        }\n    }\n",
    "170577": "    public void setTeam2Teamspirit(double value) {\n        this.Team2Teamspirit.setText(this.generateText(value));\n    }\n",
    "170578": "    private void setKeeperAssistantComboBox() {\n        keeperTrainer = new JComboBox();\n\n        for (int i = 0; i < 11; i++) {\n            keeperTrainer.addItem(new Integer(i));\n        }\n    }\n",
    "170579": "    public String getPluginName() {\n        return PLUGINNAME; //$NON-NLS-1$\n    }\n",
    "170580": "    private void setTrainer(int value) {\n        if (value > 10) {\n            value = 10;\n        }\n\n        try {\n            trainerLevel.setSelectedIndex(value);\n        } catch (Exception e) {\n        }\n    }\n",
    "170581": "    public void refresh() {\n        // reset the selected player\n        activePlayer = null;\n\n        // reload the trainingPanel\n        trainPanel.reload();\n\n        // reload the staff, could have changed\n        staffPanel.reload();\n\n        // recalculate and update the main panel\t\t\n        tabbedPanel.reload();\n\n        // and finally recalculate the player previsions\n        refreshPlayerDetail();\n    }\n",
    "170582": "    private void setTrainerComboBox() {\n        IHOMiniModel model = Commons.getModel();\n\n        trainerLevel = new JComboBox();\n\n        for (int i = 1; i < 9; i++) {\n            trainerLevel.addItem(model.getHelper().getNameForSkill(i, false));\n        }\n    }\n",
    "170583": "    public String getName() {\n        return getPluginName() + \" \" + getVersion(); //$NON-NLS-1$\n    }\n",
    "170585": "    public int getPluginID() {\n        return PLUGINID;\n    }\n",
    "170586": "    public boolean updateDifferences() {\n        return true;\n    }\n",
    "170588": "    public double getVersion() {\n        return PLUGINVERSION;\n    }\n",
    "170592": "    public void setFilter(int filterMode) {\n        playersTable.setFilter(filterMode);\n    }\n",
    "170593": "    protected int getSelectedPlayer() {\n        int row = this.playersTable.getSelectedRow();\n\n        if (row >= 0) {\n            Integer playerId = (Integer) playersTable.getValueAt(row, PlayersTableModel.COL_ID);\n\n            return playerId.intValue();\n        }\n\n        return 0;\n    }\n",
    "170595": "        public void valueChanged(ListSelectionEvent e) {\n            if (!e.getValueIsAdjusting()) {\n                detailsPanel.refresh(getSelectedPlayer());\n            }\n        }\n",
    "170597": "    public void setFilter(int filterMode) {\n        playersPanel.setFilter(filterMode);\n    }\n",
    "170598": "    public Class getColumnClass(int c) {\n        //return getValueAt(0, c).getClass();\n        return Object.class;\n    }\n",
    "170600": "    public int getColumnCount() {\n        return vColumnNames.size();\n    }\n",
    "170601": "    protected void calculateOffset(int z, Insets inset) {\n        int numCr = crSpec[z].length;\n\n        crOffset[z] = new int[numCr + 1];\n        crOffset[z][0] = (z == C) ? inset.left : inset.top;\n\n        for (int counter = 0; counter < numCr; counter++) {\n            crOffset[z][counter + 1] = crOffset[z][counter]\n                + crSize[z][counter];\n        }\n    }\n",
    "170603": "    public String getColumnName(int c) {\n        return (String) vColumnNames.get(c);\n    }\n",
    "170606": "    public String getColumnName(int c) {\n        return columnNames[c];\n    }\n",
    "170609": "    public void refresh(int playerId) {\n        this.playerId = playerId;\n        generateData();\n        this.fireTableDataChanged();\n    }\n",
    "170612": "    public boolean isCellEditable(int row, int column) {\n        return tableModel.isCellEditable(modelIndex(row), column);\n    }\n",
    "170613": "    public String getToolTipText(MouseEvent e) {\n        String tip = null;\n        java.awt.Point p = e.getPoint();\n        int rowIndex = rowAtPoint(p);\n        int colIndex = columnAtPoint(p);\n        int realColumnIndex = convertColumnIndexToModel(colIndex);\n\n        if (realColumnIndex == DetailsTableModel.COL_EVENT) { //HIGHLIGHT\n\n            // column\n            tip = adattaLunghezza(getValueAt(rowIndex, colIndex).toString());\n        } else { //another column\n            tip = super.getToolTipText(e);\n        }\n\n        return tip;\n    }\n",
    "170617": "    public void refresh(int filterMode) {\n        this.m_typePlayer = filterMode;\n\n        this.generateData2();\n        this.fireTableDataChanged();\n    }\n",
    "170618": "    public Class getColumnClass(int column) {\n        return tableModel.getColumnClass(column);\n    }\n",
    "170621": "    private String aCapo() {\n        return new String(\"<br>\");\n    }\n",
    "170624": "    private String adattaLunghezza(String testo) {\n        String risultato = \"\";\n\n        for (int i = 0, troncamento = 0; i < (testo.length() - 1); i++, troncamento++) {\n            risultato += testo.charAt(i);\n\n            if (troncamento >= 40) {\n                // andare a capo se c'\ufffd uno spazio dopo\n                if (testo.charAt(i + 1) == ' ') {\n                    risultato += aCapo();\n                    troncamento = 0;\n                }\n            }\n        }\n\n        return risultato;\n    }\n",
    "170625": "    public void setColumnComparator(Class type, Comparator comparator) {\n        if (comparator == null) {\n            columnComparators.remove(type);\n        } else {\n            columnComparators.put(type, comparator);\n        }\n    }\n",
    "170627": "    private double approssima(double valore) {\n        long approx = (new Double(valore * 10.0)).longValue();\n        return approx / 10.0;\n    }\n",
    "170630": "    public void setFilter(int filterMode) {\n        playersTableModel.refresh(filterMode);\n    }\n",
    "170632": "    public void prova() {\n    }\n",
    "170633": "    public int getColumnCount() {\n        return (tableModel == null) ? 0 : tableModel.getColumnCount();\n    }\n",
    "170636": "    private void incrementaValoreColonna(int rowFind, int colonna) {\n        // solo se presenti\n        if (rowFind != -1) {\n            data[rowFind][colonna] = new Integer(((Integer) data[rowFind][colonna]).intValue() + 1);\n        }\n    }\n",
    "170637": "    public void refresh(int playerId) {\n        detailsTable.refresh(playerId);\n    }\n",
    "170639": "    public int getPluginID() {\n        return 21; // this is your pluginID\n    }\n",
    "170640": "    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n",
    "170641": "    public String getColumnName(int column) {\n        return tableModel.getColumnName(column);\n    }\n",
    "170643": "    private List reloadData() {\n        final IHOMiniModel model = Commons.getModel();\n        this.players = new Vector(model.getAllSpieler());\n        this.oldplayers = new Vector(model.getAllOldSpieler());\n\n        final List transfers = TransfersDAO.getTransfers(0, true, true);\n\n        historyPane.refresh();\n        transferTypePane.refresh(transfers);\n        return transfers;\n    }\n",
    "170647": "    private int getActualPlayerType() {\n        if (skillups > 0) {\n            return TransferTypes.TRAINED_ROSTER;\n        }\n\n        if (isStarter()) {\n            return TransferTypes.STARTER_ROSTER;\n        }\n\n        return TransferTypes.BACKUP_ROSTER;\n    }\n",
    "170648": "    public TableModel getModel() {\n        return tableModel;\n    }\n",
    "170649": "    private int getOldPlayerType() {\n        if ((getWeekOnRoster() <= 3) && (skillups == 0)) {\n            return TransferTypes.DAY_TRADING;\n        }\n\n        if ((getWeekOnRoster() <= 6) && (skillups == 1)) {\n            return TransferTypes.SKILL_TRADING;\n        }\n\n        if ((experienceSkillups > 0) && (experience >= 5) && (leadership >= 5)) {\n            return TransferTypes.FUTURE_TRAINER;\n        }\n\n        if (skillups == 0) {\n            if (isStarter()) {\n                return TransferTypes.OLD_STARTER;\n            }\n\n            return TransferTypes.OLD_BACKUP;\n        }\n\n        return TransferTypes.OLD_TRAINED;\n    }\n",
    "170651": "    private void uploadTransfers(List transfers) {\n        for (Iterator iter = transfers.iterator(); iter.hasNext();) {\n            final PlayerTransfer pt = (PlayerTransfer) iter.next();\n\n            if (!TransferStatusDAO.isUploaded(pt.getTransferID())) {\n                if (upload(pt)) {\n                    TransferStatusDAO.setUploaded(pt.getTransferID());\n                }\n            }\n        }\n    }\n",
    "170653": "    private int getTeamPlayerType() {\n        if (age > 20) {\n            return TransferTypes.ORIGINAL_ROSTER;\n        }\n\n        return TransferTypes.YOUTH_PULL;\n    }\n",
    "170655": "    private void setTransfersUploaded(List transfers) {\n    \tif (transfers == null) return;\n        for (Iterator iter = transfers.iterator(); iter.hasNext();) {\n            PlayerTransfer pt = (PlayerTransfer) iter.next();\n            if (pt != null) {\n            \tTransferStatusDAO.setUploaded(pt.getTransferID());\n            }\n        }\n    }\n",
    "170656": "    private int getWeekOnRoster() {\n        return endWeek - startWeek;\n    }\n",
    "170661": "    public boolean isSorting() {\n        return sortingColumns.size() != 0;\n    }\n",
    "170662": "    private void refreshPlayerTable(List values) {\n        final DefaultTableSorter sorter = (DefaultTableSorter) playerTable.getModel();\n        sorter.setTableModel(new PlayerTransferTableModel(values));\n        playerTable.getColumnModel().getColumn(3).setPreferredWidth(150);\n        playerTable.getColumnModel().getColumn(4).setCellRenderer(new IconCellRenderer());\n        playerTable.getColumnModel().getColumn(4).setMaxWidth(20);\n        playerTable.getColumnModel().getColumn(4).setPreferredWidth(150);\n    }\n",
    "170664": "    private void jbInit() {\n        initListeners();\n\n        final JPanel mainPanel = new JPanel();\n        mainPanel.setLayout(new GridLayout(1, 1));\n        mainPanel.setOpaque(false);\n        mainPanel.add(createPanel(PluginProperty.getString(\"Option.Auto\"), automatic)); //$NON-NLS-1$\n\n        setLayout(new BorderLayout());\n        setOpaque(false);\n        add(mainPanel, BorderLayout.CENTER);\n    }\n",
    "170667": "    public void setSortingStatus(int column, int status) {\n        Directive directive = getDirective(column);\n\n        if (directive != EMPTY_DIRECTIVE) {\n            sortingColumns.remove(directive);\n        }\n\n        if (status != NOT_SORTED) {\n            sortingColumns.add(new Directive(column, status));\n        }\n\n        sortingStatusChanged();\n    }\n",
    "170679": "    public int getSortingStatus(int column) {\n        return getDirective(column).direction;\n    }\n",
    "170705": "    public void setTableHeader(JTableHeader tableHeader) {\n        if (this.tableHeader != null) {\n            this.tableHeader.removeMouseListener(mouseListener);\n\n            TableCellRenderer defaultRenderer = this.tableHeader.getDefaultRenderer();\n\n            if (defaultRenderer instanceof SortableHeaderRenderer) {\n                this.tableHeader.setDefaultRenderer(((SortableHeaderRenderer) defaultRenderer).tableCellRenderer);\n            }\n        }\n\n        this.tableHeader = tableHeader;\n\n        if (this.tableHeader != null) {\n            this.tableHeader.addMouseListener(mouseListener);\n            this.tableHeader.setDefaultRenderer(new SortableHeaderRenderer(this.tableHeader\n                                                                           .getDefaultRenderer()));\n        }\n    }\n",
    "170719": "    public JTableHeader getTableHeader() {\n        return tableHeader;\n    }\n",
    "170737": "        public Object copy() throws CloneNotSupportedException {\n            return clone();\n        }\n",
    "170739": "    public void setTableModel(TableModel tableModel) {\n        if (this.tableModel != null) {\n            this.tableModel.removeTableModelListener(tableModelListener);\n        }\n\n        this.tableModel = tableModel;\n\n        if (this.tableModel != null) {\n            this.tableModel.addTableModelListener(tableModelListener);\n        }\n\n        clearSortingState();\n        fireTableStructureChanged();\n    }\n",
    "170751": "    public TableModel getTableModel() {\n        return tableModel;\n    }\n",
    "170758": "    public void createRegisteredMethods( JavaClass jclass, IClassFileLocation location ) {\n        Method[] methods = jclass.getMethods();\n        for ( int i = 0; i < methods.length; i++ ) {\n            if ( !( methods[ i ].isAbstract() ) \n                    && !( methods[ i ].isNative() ) ) {\n                this.rMethodList.add( createRegisteredMethod( methods[i], jclass, location ) );\n            }\n        }\n    }\n",
    "170762": "    public void setValueAt(Object aValue, int row, int column) {\n        tableModel.setValueAt(aValue, modelIndex(row), column);\n    }\n",
    "170770": "    public static RegisteredMethod getRegisteredMethod( String id ) {\n        Map rMethodMap = registeredMethodMap;\n        // if the method is not registered yet, register it\n        if (!rMethodMap.containsKey(id)) {\n            StringTokenizer tokenizer = new StringTokenizer(id, \":\"); //$NON-NLS-1$\n            String className = tokenizer.nextToken();\n            registerClass(className);\n        }\n        RegisteredMethod method = ( RegisteredMethod )rMethodMap.get(id);\n        return method;\n    }\n",
    "170778": "    public Object getValueAt(int row, int column) {\n        return tableModel.getValueAt(modelIndex(row), column);\n    }\n",
    "170782": "        public String toString() {\n            TableLayoutConstraints c = new TableLayoutConstraints(cr1[C],\n                    cr1[R], cr2[C], cr2[R], alignment[C], alignment[R]);\n\n            return \"(\" + c + \") \" + component; //$NON-NLS-1$ //$NON-NLS-2$\n        }\n",
    "170788": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof IBasicBlock) {\n            IBasicBlock compBlock = (IBasicBlock) obj;\n            if (compBlock.getStartLine()== this.startLine\n                    && compBlock.getEndLine() == this.endLine\n                    && compBlock.getRegisteredMethod().equals(this.method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "170789": "    public int modelIndex(int viewIndex) {\n        return getViewToModel()[viewIndex].modelIndex;\n    }\n",
    "170795": "    public void weaveCallbacks() {\n        Method[] methods = getClassGen().getMethods();\n        for ( int i = 0; i < methods.length; i++ ) {\n            if ( !( methods[i].isAbstract() ) \n                    && !( methods[i].isNative() )) {\n                methods[ i ] = weaveCallbacksToMethod( getClassGen(), methods[ i ] );\n            }\n        }\n        getClassGen().setMethods( methods );\n//        new ByteCodePrinter(classGen.getJavaClass()).printBytecode();\n//        debugActions(classGen);\n    }\n",
    "170796": "    protected Comparator getComparator(int column) {\n        Class columnType = tableModel.getColumnClass(column);\n        Comparator comparator = (Comparator) columnComparators.get(columnType);\n\n        if (comparator != null) {\n            return comparator;\n        }\n\n        if (Comparable.class.isAssignableFrom(columnType)) {\n            return COMPARABLE_COMAPRATOR;\n        }\n\n        return LEXICAL_COMPARATOR;\n    }\n",
    "170800": "    public String toString() {\n        String result = \"[ \"; //$NON-NLS-1$\n        boolean afterfirstIteration = false;\n        for (Iterator iter = this.enteredBlocks.iterator(); iter.hasNext();) {\n            if (afterfirstIteration) {\n                result += \", \"; //$NON-NLS-1$\n            }\n            RuntimeBasicBlockWrapper element = (RuntimeBasicBlockWrapper) iter.next();\n            result += \"(\"; //$NON-NLS-1$\n            if (!element.isEntered()) {\n                result += \"!\"; //$NON-NLS-1$\n            }\n            result += element.getStartLine() + \",\"; //$NON-NLS-1$\n            if (!element.isExited()) {\n                result += \"!\";  //$NON-NLS-1$\n            }\n            result += element.getEndLine() + \")\"  ; //$NON-NLS-1$\n            afterfirstIteration = true;\n        }\n        result += \" ]\"; //$NON-NLS-1$\n        return result;\n    }\n",
    "170802": "    protected Icon getHeaderRendererIcon(int column, int size) {\n        Directive directive = getDirective(column);\n\n        if (directive == EMPTY_DIRECTIVE) {\n            return null;\n        }\n\n        return new Arrow(directive.direction == DESCENDING, size, sortingColumns.indexOf(directive));\n    }\n",
    "170809": "    private Directive getDirective(int column) {\n        for (int i = 0; i < sortingColumns.size(); i++) {\n            Directive directive = (Directive) sortingColumns.get(i);\n\n            if (directive.column == column) {\n                return directive;\n            }\n        }\n\n        return EMPTY_DIRECTIVE;\n    }\n",
    "170815": "    private void cancelSorting() {\n        sortingColumns.clear();\n        sortingStatusChanged();\n    }\n",
    "170820": "    private InstructionHandle skipToNextBlockDelimiter(InstructionHandle runnerHandle) {\n        while (!(runnerHandle.getInstruction() \n                instanceof BlockDelimiter)) {\n            runnerHandle = runnerHandle.getNext();\n        }\n        return runnerHandle;\n    }\n",
    "170821": "    private void clearSortingState() {\n        viewToModel = null;\n        modelToView = null;\n    }\n",
    "170826": "    private void sortingStatusChanged() {\n        clearSortingState();\n        fireTableDataChanged();\n\n        if (tableHeader != null) {\n            tableHeader.repaint();\n        }\n    }\n",
    "170832": "        public int getIconHeight() {\n            return size;\n        }\n",
    "170833": "    public void printBytecode() {\n        printBytecode(System.out);\n    }\n",
    "170841": "        public int getIconWidth() {\n            return size;\n        }\n",
    "170850": "  public void accept(Visitor v) {\n    v.visitSourceFile(this);\n  }\n",
    "170854": "  public void accept(Visitor v) {\n    v.visitConstantUtf8(this);\n  }\n",
    "170855": "  public void accept(Visitor v) {\n    v.visitLocalVariableTable(this);\n  }\n",
    "170860": "  public void accept(Visitor v) {\n    v.visitField(this);\n  }\n",
    "170863": "  public void accept(Visitor v) {\n    v.visitConstantClass(this);\n  }    \n",
    "170868": "        public int compareTo(Object o) {\n            int row1 = modelIndex;\n            int row2 = ((Row) o).modelIndex;\n\n            for (Iterator it = sortingColumns.iterator(); it.hasNext();) {\n                Directive directive = (Directive) it.next();\n                int column = directive.column;\n                Object o1 = tableModel.getValueAt(row1, column);\n                Object o2 = tableModel.getValueAt(row2, column);\n\n                int comparison = 0;\n\n                // Define null less than everything, except null.\n                if ((o1 == null) && (o2 == null)) {\n                    comparison = 0;\n                } else if (o1 == null) {\n                    comparison = -1;\n                } else if (o2 == null) {\n                    comparison = 1;\n                } else {\n                    comparison = getComparator(column).compare(o1, o2);\n                }\n\n                if (comparison != 0) {\n                    return (directive.direction == DESCENDING) ? (-comparison) : comparison;\n                }\n            }\n\n            return 0;\n        }\n",
    "170870": "  public void accept(Visitor v) {\n    v.visitCode(this);\n  }\n",
    "170879": "  public void accept(Visitor v) {\n    v.visitLineNumber(this);\n  }    \n",
    "170884": "   public void accept(Visitor v) {\n     System.err.println(\"Visiting non-standard Signature object\");\n     v.visitSignature(this);\n   }\n",
    "170885": "  public void accept(Visitor v) {\n    v.visitMethod(this);\n  }\n",
    "170893": "  public void accept(Visitor v) {\n    v.visitCodeException(this);\n  }    \n",
    "170897": "  public void accept(Visitor v) {\n    v.visitConstantInteger(this);\n  }\n",
    "170901": "  public void accept(Visitor v) {\n    v.visitSynthetic(this);\n  }    \n",
    "170906": "  public void accept(Visitor v) {\n    v.visitConstantDouble(this);\n  }    \n",
    "170908": "  public void accept(Visitor v) {\n    v.visitExceptionTable(this);\n  }\n",
    "170909": "  public void accept(Visitor v) {\n    v.visitConstantString(this);\n  }    \n",
    "170919": "  public void accept(Visitor v) {\n    v.visitUnknown(this);\n  }    \n",
    "170921": "  public void accept(Visitor v) {\n    v.visitLocalVariable(this);\n  }\n",
    "170923": "  public Object clone() {\n    Object o = null;\n\n    try {\n      o = super.clone();\n    } catch(CloneNotSupportedException e) {\n      e.printStackTrace(); // Never occurs\n    }\n\n    return o;\n  }\n",
    "170932": "  public void accept(Visitor v) {\n    v.visitInnerClass(this);\n  }    \n",
    "170934": "  public void accept(Visitor v) {\n    v.visitJavaClass(this);\n  }\n",
    "170935": "   public void accept(Visitor v) {\n     v.visitStackMap(this);\n   }\n",
    "170942": "  public void accept(Visitor v) {\n    v.visitLineNumberTable(this);\n  }    \n",
    "170950": "  public void accept(Visitor v) {\n    v.visitConstantValue(this);\n  }    \n",
    "170957": "   public void accept(Visitor v) {\n     System.err.println(\"Visiting non-standard PMGClass object\");\n   }\n",
    "170958": "  public void accept(Visitor v) {\n    v.visitInnerClasses(this);\n  }    \n",
    "170962": "  public void dump(OutputStream file) throws IOException {\n    dump(new DataOutputStream(file));\n  }\n",
    "170964": "  public void accept(Visitor v) {\n    v.visitConstantFieldref(this);\n  }    \n",
    "170966": "  public void accept(Visitor v) {\n    v.visitConstantPool(this);\n  }    \n",
    "170979": "  public Constant getConstant(int index) {\n    if (index >= constant_pool.length || index < 0)\n      throw new ClassFormatException(\"Invalid constant pool reference: \" +\n                 index + \". Constant pool size is: \" +\n                 constant_pool.length);\n    return constant_pool[index];\n  }\n",
    "170987": "  public void accept(Visitor v) {\n    v.visitStackMapEntry(this);\n  }\n",
    "170988": "  public void accept(Visitor v) {\n    v.visitConstantNameAndType(this);\n  }\n",
    "170990": "  public void accept(Visitor v) {\n    v.visitConstantFloat(this);\n  }    \n",
    "170995": "  public void accept(Visitor v) {\n    v.visitConstantMethodref(this);\n  }    \n",
    "171008": "  public void accept(Visitor v) {\n    v.visitConstantLong(this);\n  }    \n",
    "171009": "  public void accept(Visitor v) {\n    v.visitConstantInterfaceMethodref(this);\n  }    \n",
    "171012": "  public void accept(Visitor v) {\n    v.visitDeprecated(this);\n  }    \n",
    "171016": "    public void extendMessage(String pre, String post){\n        if (pre  == null) pre=\"\";\n        if (detailMessage == null) detailMessage=\"\";\n        if (post == null) post=\"\";\n        detailMessage = pre+detailMessage+post;\n    }\n",
    "171019": "    public String getMessage(){\n        return detailMessage;\n    }\n",
    "171032": "    public LocalVariableInfo getLocalVariableInfo(int slot){\n        if (slot < 0 || slot >= localVariableInfos.length){\n            throw new AssertionViolatedException(\"Slot number for local variable information out of range.\");\n        }\n        return localVariableInfos[slot];\n    }\n",
    "171039": "    public String toString(){\n    // The run-time check below is needed because we don't want to omit inheritance\n    // of \"EmptyVisitor\" and provide a thousand empty methods.\n    // However, in terms of performance this would be a better idea.\n    // If some new \"Node\" is defined in BCEL (such as some concrete \"Attribute\"), we\n    // want to know that this class has also to be adapted.\n    if (tostring == null) throw new AssertionViolatedException(\"Please adapt '\"+getClass()+\"' to deal with objects of class '\"+n.getClass()+\"'.\");\n        return tostring;\n    }\n",
    "171041": "    private String toString(Node obj){\n        String ret;\n        try{\n            ret = obj.toString();\n        }\n        catch(RuntimeException e){\n            String s = obj.getClass().getName();\n            s = s.substring(s.lastIndexOf(\".\")+1);\n            ret = \"<<\"+s+\">>\";\n    }\n    catch(ClassFormatError e){ /* BCEL can be harsh e.g. trying to convert the \"signature\" of a ReturnaddressType LocalVariable (shouldn't occur, but people do crazy things) */\n      String s = obj.getClass().getName();\n      s = s.substring(s.lastIndexOf(\".\")+1);\n      ret = \"<<\"+s+\">>\";\n        }\n        return ret;\n    }\n",
    "171046": "    public LocalVariablesInfo getLocalVariablesInfo(int method_nr){\n        if (this.verify() != VerificationResult.VR_OK) return null; // It's cached, don't worry.\n        if (method_nr < 0 || method_nr >= localVariablesInfos.length){\n            throw new AssertionViolatedException(\"Method number out of range.\");\n        }\n        return localVariablesInfos[method_nr];\n    }\n",
    "171074": "  public void setFileName(String file_name) {\n    this.file_name = file_name;\n  }    \n",
    "171099": "    private void constant_pool_entries_satisfy_static_constraints(){\n        // Most of the consistency is handled internally by BCEL; here\n        // we only have to verify if the indices of the constants point\n        // to constants of the appropriate type and such.\n        JavaClass jc = Repository.lookupClass(myOwner.getClassName());\n        new CPESSC_Visitor(jc); // constructor implicitely traverses jc\n    }\n",
    "171108": "  public void setSourceFileName(String source_file_name) {\n    this.source_file_name = source_file_name;\n  }    \n",
    "171124": "    public Type getType(int offset){\n        return (Type) types.get(Integer.toString(offset));\n    }\n",
    "171125": "    public String getName(int offset){\n        return (String) (names.get(Integer.toString(offset)));\n    }\n",
    "171126": "    public void add(String name, int startpc, int length, Type t) throws LocalVariableInfoInconsistentException{\n        for (int i=startpc; i<=startpc+length; i++){ // incl/incl-notation!\n            add(i,name,t);\n        }\n    }\n",
    "171127": "    private void add(int offset, String name, Type t) throws LocalVariableInfoInconsistentException{\n        if (getName(offset) != null){\n            if (! getName(offset).equals(name)){\n                throw new LocalVariableInfoInconsistentException(\"At bytecode offset '\"+offset+\"' a local variable has two different names: '\"+getName(offset)+\"' and '\"+name+\"'.\");\n            }\n        }\n        if (getType(offset) != null){\n            if (! getType(offset).equals(t)){\n                throw new LocalVariableInfoInconsistentException(\"At bytecode offset '\"+offset+\"' a local variable has two different types: '\"+getType(offset)+\"' and '\"+t+\"'.\");\n            }\n        }\n        setName(offset, name);\n        setType(offset, t);\n    }\n",
    "171133": "  public void setRepository(de.uka.ipd.coverage.org.apache.bcel.util.Repository repository) {\n    this.repository = repository;\n  }\n",
    "171143": "    public int getMethodNo(){\n        return method_no;\n    }\n",
    "171152": "        private int max_locals(){\n            return Repository.lookupClass(myOwner.getClassName()).getMethods()[method_no].getCode().getMaxLocals();\n        }\n",
    "171158": "  protected void processWindowEvent(WindowEvent e) {\n    super.processWindowEvent(e);\n    if (e.getID() == WindowEvent.WINDOW_CLOSING) {\n      System.exit(0);\n    }\n  }\n",
    "171160": "        private void constraintViolated(Instruction i, String message) {\n            throw new StaticCodeInstructionOperandConstraintException(\"Instruction \"+i+\" constraint violated: \"+message);\n        }\n",
    "171162": "    public VerificationResult verify(){\n        if (verificationResult == null){\n            verificationResult = do_verify();\n        }\n        return verificationResult;\n    }\n",
    "171163": "    public void addMessage(String message){\n        messages.add(message);\n    }\n",
    "171172": "    public String toString(){\n        String s=\"Local Variables:\\n\";\n        s += locals;\n        s += \"OperandStack:\\n\";\n        s += stack;\n        return s;\n    }\n",
    "171173": "        private void indexValid(Instruction i, int idx){\n            if (idx < 0 || idx >= cpg.getSize()){\n                constraintViolated(i, \"Illegal constant pool index '\"+idx+\"'.\");\n            }\n        }\n",
    "171174": "    protected Object clone(){\n        LocalVariables lvs = new LocalVariables(locals.length);\n        for (int i=0; i<locals.length; i++){\n            lvs.locals[i] = this.locals[i];\n        }\n        return lvs;\n    }\n",
    "171175": "    public Type get(int i){\n        return locals[i];\n    }\n",
    "171176": "    public LocalVariables getClone(){\n        return (LocalVariables) this.clone();\n    }\n",
    "171177": "    public int maxLocals(){\n        return locals.length;\n    }\n",
    "171178": "    public void set(int i, Type type){\n        if (type == Type.BYTE || type == Type.SHORT || type == Type.BOOLEAN || type == Type.CHAR){\n            throw new AssertionViolatedException(\"LocalVariables do not know about '\"+type+\"'. Use Type.INT instead.\");\n        }\n        locals[i] = type;\n    }\n",
    "171179": "    private OperandStack stack(){\n        return frame.getStack();\n    }\n",
    "171182": "    public void merge(LocalVariables lv){\n\n        if (this.locals.length != lv.locals.length){\n            throw new AssertionViolatedException(\"Merging LocalVariables of different size?!? From different methods or what?!?\");\n        }\n\n        for (int i=0; i<locals.length; i++){\n            merge(lv, i);\n        }\n    }\n",
    "171184": "        public void visitLoadClass(LoadClass o){\n            ObjectType t = o.getLoadClassType(cpg);\n            if (t != null){// null means \"no class is loaded\"\n                Verifier v = VerifierFactory.getVerifier(t.getClassName());\n                VerificationResult vr = v.doPass1();\n                if (vr.getStatus() != VerificationResult.VERIFIED_OK){\n                    constraintViolated((Instruction) o, \"Class '\"+o.getLoadClassType(cpg).getClassName()+\"' is referenced, but cannot be loaded: '\"+vr+\"'.\");\n                }\n            }\n        }\n",
    "171185": "    public String toString(){\n        String s = new String();\n        for (int i=0; i<locals.length; i++){\n            s += Integer.toString(i)+\": \"+locals[i]+\"\\n\";\n        }\n        return s;\n    }\n",
    "171186": "    public void initializeObject(UninitializedObjectType u){\n        for (int i=0; i<locals.length; i++){\n            if (locals[i] == u){\n                locals[i] = u.getInitialized();\n            }\n        }\n    }\n",
    "171187": "    private LocalVariables locals(){\n        return frame.getLocals();\n    }\n",
    "171194": "    public void setConstantPoolGen(ConstantPoolGen cpg){\n        this.cpg = cpg;\n    }\n",
    "171196": "    public void setFrame(Frame f){\n        this.frame = f;\n    }\n",
    "171198": "    public void setFrame(Frame f){\n        this.frame = f;\n        //if (singleInstance.mg == null || singleInstance.cpg == null) throw new AssertionViolatedException(\"Forgot to set important values first.\");\n    }\n",
    "171200": "    //public void visitWIDE(WIDE o){\n    // The WIDE instruction is modelled as a flag\n    // of the embedded instructions in BCEL.\n    // Therefore BCEL checks for possible errors\n    // when parsing in the .class file: We don't\n    // have even the possibilty to care for WIDE\n    // here.\n    //}\n",
    "171201": "    public void visitAALOAD(AALOAD o){\n        stack().pop();                                                        // pop the index int\n//System.out.print(stack().peek());\n        Type t = stack().pop(); // Pop Array type\n        if (t == Type.NULL){\n            stack().push(Type.NULL);\n        }    // Do nothing stackwise --- a NullPointerException is thrown at Run-Time\n        else{\n            ArrayType at = (ArrayType) t;    \n            stack().push(at.getElementType());\n        }\n    }\n",
    "171204": "    public void visitAASTORE(AASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171206": "    public void visitACONST_NULL(ACONST_NULL o){\n        stack().push(Type.NULL);\n    }\n",
    "171208": "        public void visitINSTANCEOF(INSTANCEOF o){\n            indexValid(o, o.getIndex());\n            Constant c = cpg.getConstant(o.getIndex());\n            if (!    (c instanceof ConstantClass)){\n                constraintViolated(o, \"Expecting a CONSTANT_Class operand, but found a '\"+c+\"'.\");\n            }\n        }\n",
    "171210": "    public void visitALOAD(ALOAD o){\n        stack().push(locals().get(o.getIndex()));\n    }\n",
    "171211": "    public void setMethodGen(MethodGen mg){\n        this.mg = mg;\n    }\n",
    "171212": "    public void visitANEWARRAY(ANEWARRAY o){\n        stack().pop(); //count\n        stack().push( new ArrayType(o.getType(cpg), 1) );\n    }\n",
    "171213": "        public void visitCHECKCAST(CHECKCAST o){\n            indexValid(o, o.getIndex());\n            Constant c = cpg.getConstant(o.getIndex());\n            if (!    (c instanceof ConstantClass)){\n                constraintViolated(o, \"Expecting a CONSTANT_Class operand, but found a '\"+c+\"'.\");\n            }\n        }\n",
    "171215": "    public void visitARETURN(ARETURN o){\n        stack().pop();\n    }\n",
    "171216": "    private void indexOfInt(Instruction o, Type index){\n        if (! index.equals(Type.INT))\n                constraintViolated(o, \"The 'index' is not of type int but of type \"+index+\".\");\n    }\n",
    "171217": "    public void visitARRAYLENGTH(ARRAYLENGTH o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171218": "        public void visitNEW(NEW o){\n            indexValid(o, o.getIndex());\n            Constant c = cpg.getConstant(o.getIndex());\n            if (!    (c instanceof ConstantClass)){\n                constraintViolated(o, \"Expecting a CONSTANT_Class operand, but found a '\"+c+\"'.\");\n            }\n            else{\n                ConstantUtf8 cutf8 = (ConstantUtf8) (cpg.getConstant( ((ConstantClass) c).getNameIndex() ));\n                Type t = Type.getType(\"L\"+cutf8.getBytes()+\";\");\n                if (t instanceof ArrayType){\n                    constraintViolated(o, \"NEW must not be used to create an array.\");\n                }\n            }\n            \n        }\n",
    "171220": "    public void visitASTORE(ASTORE o){\n        locals().set(o.getIndex(), stack().pop());\n        //System.err.println(\"TODO-DEBUG:    set LV '\"+o.getIndex()+\"' to '\"+locals().get(o.getIndex())+\"'.\");\n    }\n",
    "171221": "    private void referenceTypeIsInitialized(Instruction o, ReferenceType r){\n        if (r instanceof UninitializedObjectType){\n            constraintViolated(o, \"Working on an uninitialized object '\"+r+\"'.\");\n        }\n    }\n",
    "171223": "    public void visitATHROW(ATHROW o){\n        Type t = stack().pop();\n        stack().clear();\n        if (t.equals(Type.NULL))\n            stack().push(Type.getType(\"Ljava/lang/NullPointerException;\"));\n        else\n            stack().push(t);\n    }\n",
    "171225": "    public void visitBALOAD(BALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171226": "    private void valueOfInt(Instruction o, Type value){\n        if (! value.equals(Type.INT))\n                constraintViolated(o, \"The 'value' is not of type int but of type \"+value+\".\");\n    }\n",
    "171227": "        public void visitANEWARRAY(ANEWARRAY o){\n            indexValid(o, o.getIndex());\n            Constant c = cpg.getConstant(o.getIndex());\n            if (!    (c instanceof ConstantClass)){\n                constraintViolated(o, \"Expecting a CONSTANT_Class operand, but found a '\"+c+\"'.\");\n            }\n            Type t = o.getType(cpg);\n            if (t instanceof ArrayType){\n                int dimensions = ((ArrayType) t).getDimensions();\n                if (dimensions >= 255){\n                    constraintViolated(o, \"Not allowed to create an array with more than 255 dimensions.\");\n                }\n            }\n        }\n",
    "171228": "    public void visitBASTORE(BASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171230": "    public void visitBIPUSH(BIPUSH o){\n        stack().push(Type.INT);\n    }\n",
    "171231": "    private boolean arrayrefOfArrayType(Instruction o, Type arrayref){\n        if (! ((arrayref instanceof ArrayType) || arrayref.equals(Type.NULL)) )\n                constraintViolated(o, \"The 'arrayref' does not refer to an array but is of type \"+arrayref+\".\");\n        return (arrayref instanceof ArrayType);\n    }\n",
    "171232": "        public void visitNEWARRAY(NEWARRAY o){\n            byte t = o.getTypecode();\n            if (!    (    (t == Constants.T_BOOLEAN)    ||\n                            (t == Constants.T_CHAR)            ||\n                            (t == Constants.T_FLOAT)        ||\n                            (t == Constants.T_DOUBLE)        ||\n                            (t == Constants.T_BYTE)            ||\n                            (t == Constants.T_SHORT)        ||\n                            (t == Constants.T_INT)            ||\n                            (t == Constants.T_LONG)    )    ){\n                constraintViolated(o, \"Illegal type code '+t+' for 'atype' operand.\");\n            }\n        }\n",
    "171233": "    public void visitCALOAD(CALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171235": "    public void visitCASTORE(CASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171236": "    private void _visitStackAccessor(Instruction o){\n        int consume = o.consumeStack(cpg); // Stack values are always consumed first; then produced.\n        if (consume > stack().slotsUsed()){\n            constraintViolated((Instruction) o, \"Cannot consume \"+consume+\" stack slots: only \"+stack().slotsUsed()+\" slot(s) left on stack!\\nStack:\\n\"+stack());\n        }\n\n        int produce = o.produceStack(cpg) - ((Instruction) o).consumeStack(cpg); // Stack values are always consumed first; then produced.\n        if ( produce + stack().slotsUsed() > stack().maxStack() ){\n            constraintViolated((Instruction) o, \"Cannot produce \"+produce+\" stack slots: only \"+(stack().maxStack()-stack().slotsUsed())+\" free stack slot(s) left.\\nStack:\\n\"+stack());\n        }\n    }\n",
    "171237": "        public void visitILOAD(ILOAD o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171239": "    public void visitCHECKCAST(CHECKCAST o){\n        // It's possibly wrong to do so, but SUN's\n        // ByteCode verifier seems to do (only) this, too.\n        // TODO: One could use a sophisticated analysis here to check\n        //       if a type cannot possibly be cated to another and by\n        //       so doing predict the ClassCastException at run-time.\n        stack().pop();\n        stack().push(o.getType(cpg));\n    }\n",
    "171240": "    public void visitD2F(D2F o){\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171241": "    public void visitLoadClass(LoadClass o){\n        ObjectType t = o.getLoadClassType(cpg);\n        if (t != null){// null means \"no class is loaded\"\n            Verifier v = VerifierFactory.getVerifier(t.getClassName());\n            VerificationResult vr = v.doPass2();\n            if (vr.getStatus() != VerificationResult.VERIFIED_OK){\n                constraintViolated((Instruction) o, \"Class '\"+o.getLoadClassType(cpg).getClassName()+\"' is referenced, but cannot be loaded and resolved: '\"+vr+\"'.\");\n            }\n        }\n    }\n",
    "171242": "        public void visitFLOAD(FLOAD o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171244": "    public void visitD2I(D2I o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171245": "    public void visitStackConsumer(StackConsumer o){\n        _visitStackAccessor((Instruction) o);\n    }\n",
    "171246": "    public void visitD2L(D2L o){\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "171247": "        public void visitALOAD(ALOAD o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171249": "    public void visitDADD(DADD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171250": "        public void visitISTORE(ISTORE o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171251": "    public void visitStackProducer(StackProducer o){\n        _visitStackAccessor((Instruction) o);\n    }\n",
    "171252": "    public void visitDALOAD(DALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171254": "    public void visitDASTORE(DASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171255": "        public void visitFSTORE(FSTORE o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171256": "    public void visitCPInstruction(CPInstruction o){\n        int idx = o.getIndex();\n        if ((idx < 0) || (idx >= cpg.getSize())){\n            throw new AssertionViolatedException(\"Huh?! Constant pool index of instruction '\"+o+\"' illegal? Pass 3a should have checked this!\");\n        }\n    }\n",
    "171257": "    public void visitDCMPG(DCMPG o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171260": "    public void visitDCMPL(DCMPL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171261": "        public void visitASTORE(ASTORE o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171263": "    public void visitDCONST(DCONST o){\n        stack().push(Type.DOUBLE);\n    }\n",
    "171265": "    public void visitDDIV(DDIV o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171266": "        public void visitIINC(IINC o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171267": "     public void visitInvokeInstruction(InvokeInstruction o){\n         // visitLoadClass(o) has been called before: Every FieldOrMethod\n         // implements LoadClass.\n         // visitCPInstruction(o) has been called before.\n        //TODO\n     }\n",
    "171268": "    public void visitDLOAD(DLOAD o){\n        stack().push(Type.DOUBLE);\n    }\n",
    "171270": "    public void visitDMUL(DMUL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171271": "        public void visitRET(RET o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative.\");\n            }\n            else{\n                int maxminus1 =  max_locals()-1;\n                if (idx > maxminus1){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-1 '\"+maxminus1+\"'.\");\n                }\n            }\n        }\n",
    "171272": "    public void visitStackInstruction(StackInstruction o){\n        _visitStackAccessor(o);\n    }\n",
    "171273": "    public void visitDNEG(DNEG o){\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171275": "        public void visitLLOAD(LLOAD o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n            }\n            else{\n                int maxminus2 =  max_locals()-2;\n                if (idx > maxminus2){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-2 '\"+maxminus2+\"'.\");\n                }\n            }\n        }\n",
    "171276": "    public void visitDREM(DREM o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171277": "    public void visitLocalVariableInstruction(LocalVariableInstruction o){\n        if (locals().maxLocals() <= (o.getType(cpg).getSize()==1? o.getIndex() : o.getIndex()+1) ){\n            constraintViolated(o, \"The 'index' is not a valid index into the local variable array.\");\n        }\n    }\n",
    "171278": "    public void visitDRETURN(DRETURN o){\n        stack().pop();\n    }\n",
    "171280": "        public void visitDLOAD(DLOAD o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n            }\n            else{\n                int maxminus2 =  max_locals()-2;\n                if (idx > maxminus2){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-2 '\"+maxminus2+\"'.\");\n                }\n            }\n        }\n",
    "171281": "    public void visitDSTORE(DSTORE o){\n        locals().set(o.getIndex(), stack().pop());\n        locals().set(o.getIndex()+1, Type.UNKNOWN);\n    }\n",
    "171283": "    public void visitDSUB(DSUB o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171285": "        public void visitLSTORE(LSTORE o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n            }\n            else{\n                int maxminus2 =  max_locals()-2;\n                if (idx > maxminus2){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-2 '\"+maxminus2+\"'.\");\n                }\n            }\n        }\n",
    "171286": "    public void visitDUP(DUP o){\n        Type t = stack().pop();\n        stack().push(t);\n        stack().push(t);\n    }\n",
    "171288": "        public void visitDSTORE(DSTORE o){\n            int idx = o.getIndex();\n            if (idx < 0){\n                constraintViolated(o, \"Index '\"+idx+\"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]\");\n            }\n            else{\n                int maxminus2 =  max_locals()-2;\n                if (idx > maxminus2){\n                    constraintViolated(o, \"Index '\"+idx+\"' must not be greater than max_locals-2 '\"+maxminus2+\"'.\");\n                }\n            }\n        }\n",
    "171289": "    public void visitDUP_X1(DUP_X1 o){\n        Type w1 = stack().pop();\n        Type w2 = stack().pop();\n        stack().push(w1);\n        stack().push(w2);\n        stack().push(w1);\n    }\n",
    "171291": "    public void visitDUP_X2(DUP_X2 o){\n        Type w1 = stack().pop();\n        Type w2 = stack().pop();\n        if (w2.getSize() == 2){\n            stack().push(w1);\n            stack().push(w2);\n            stack().push(w1);\n        }\n        else{\n            Type w3 = stack().pop();\n            stack().push(w1);\n            stack().push(w3);\n            stack().push(w2);\n            stack().push(w1);\n        }\n    }\n",
    "171293": "        public void visitLOOKUPSWITCH(LOOKUPSWITCH o){\n            int[] matchs = o.getMatchs();\n            int max = Integer.MIN_VALUE;\n            for (int i=0; i<matchs.length; i++){\n                if (matchs[i] == max && i != 0){\n                    constraintViolated(o, \"Match '\"+matchs[i]+\"' occurs more than once.\");\n                }\n                if (matchs[i] < max){\n                    constraintViolated(o, \"Lookup table must be sorted but isn't.\");\n                }\n                else{\n                    max = matchs[i];\n                }\n            }\n        }\n",
    "171295": "    public void visitDUP2(DUP2 o){\n        Type t = stack().pop();\n        if (t.getSize() == 2){\n            stack().push(t);\n            stack().push(t);\n        }\n        else{ // t.getSize() is 1\n            Type u = stack().pop();\n            stack().push(u);\n            stack().push(t);\n            stack().push(u);\n            stack().push(t);\n        }\n    }\n",
    "171296": "    public void visitDUP2_X1(DUP2_X1 o){\n        Type t = stack().pop();\n        if (t.getSize() == 2){\n            Type u = stack().pop();\n            stack().push(t);\n            stack().push(u);\n            stack().push(t);\n        }\n        else{ //t.getSize() is1\n            Type u = stack().pop();\n            Type v = stack().pop();\n            stack().push(u);\n            stack().push(t);\n            stack().push(v);\n            stack().push(u);\n            stack().push(t);\n        }\n    }\n",
    "171297": "    public void visitAALOAD(AALOAD o){\n        Type arrayref = stack().peek(1);\n        Type index    = stack().peek(0);\n        \n        indexOfInt(o, index);\n        if (arrayrefOfArrayType(o, arrayref)){\n            if (! (((ArrayType) arrayref).getElementType() instanceof ReferenceType)){\n                constraintViolated(o, \"The 'arrayref' does not refer to an array with elements of a ReferenceType but to an array of \"+((ArrayType) arrayref).getElementType()+\".\");\n            }    \n            referenceTypeIsInitialized(o, (ReferenceType) (((ArrayType) arrayref).getElementType()));\n        }\n    }\n",
    "171299": "    private void field_and_method_refs_are_valid(){\n        JavaClass jc = Repository.lookupClass(myOwner.getClassName());\n        DescendingVisitor v = new DescendingVisitor(jc, new FAMRAV_Visitor(jc));\n        v.visit();\n    }\n",
    "171303": "    public void visitF2D(F2D o){\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171306": "    public void visitF2I(F2I o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171307": "        public void visitGETSTATIC(GETSTATIC o){\n            String field_name = o.getFieldName(cpg);\n            JavaClass jc = Repository.lookupClass(o.getClassType(cpg).getClassName());\n            Field[] fields = jc.getFields();\n            Field f = null;\n            for (int i=0; i<fields.length; i++){\n                if (fields[i].getName().equals(field_name)){\n                    f = fields[i];\n                    break;\n                }\n            }\n            if (f == null){\n                throw new AssertionViolatedException(\"Field not found?!?\");\n            }\n\n            if (! (f.isStatic())){\n                constraintViolated(o, \"Referenced field '\"+f+\"' is not static which it should be.\");\n            }\n        }\n",
    "171308": "    public void visitACONST_NULL(ACONST_NULL o){\n        // Nothing needs to be done here.\n    }\n",
    "171309": "    public void visitF2L(F2L o){\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "171311": "    public void visitFADD(FADD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171313": "    public void visitALOAD(ALOAD o){\n        //visitLoadInstruction(LoadInstruction) is called before.\n        \n        // Nothing else needs to be done here.\n    }\n",
    "171314": "    public void visitFALOAD(FALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171317": "    public void visitFASTORE(FASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171318": "    public void visitANEWARRAY(ANEWARRAY o){\n        if (!stack().peek().equals(Type.INT))\n            constraintViolated(o, \"The 'count' at the stack top is not of type '\"+Type.INT+\"' but of type '\"+stack().peek()+\"'.\");\n        // The runtime constant pool item at that index must be a symbolic reference to a class,\n        // array, or interface type. See Pass 3a.\n    }\n",
    "171319": "    public void visitFCMPG(FCMPG o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171320": "        public boolean innerClassReferenced(){\n            return hasInnerClass;\n        }\n",
    "171323": "    public void visitFCMPL(FCMPL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171324": "        public void visitConstantClass(ConstantClass obj){\n            Constant c = cp.getConstant(obj.getNameIndex());\n            if (c instanceof ConstantUtf8){ //Ignore the case where it's not a ConstantUtf8 here, we'll find out later.\n                String classname = ((ConstantUtf8) c).getBytes();\n                if (classname.startsWith(jc.getClassName().replace('.','/')+\"$\")){\n                    hasInnerClass = true;\n                }\n            }\n        }\n",
    "171326": "    public ObjectType getExceptionType(){\n        return catchtype;\n    }\n",
    "171327": "    public InstructionHandle getHandlerStart(){\n        return handlerpc;\n    }\n",
    "171329": "    public boolean equals(Object o){\n        if (! (o instanceof UninitializedObjectType)) return false;\n        return initialized.equals(((UninitializedObjectType)o).initialized);\n    }\n",
    "171331": "    public void visitFCONST(FCONST o){\n        stack().push(Type.FLOAT);\n    }\n",
    "171332": "    public void visitARRAYLENGTH(ARRAYLENGTH o){\n        Type arrayref = stack().peek(0);\n        arrayrefOfArrayType(o, arrayref);\n    }\n",
    "171334": "        public String toString(){\n            String ret = \"Subroutine: Local variable is '\"+localVariable+\"', JSRs are '\"+theJSRs+\"', RET is '\"+theRET+\"', Instructions: '\"+instructions.toString()+\"'.\";\n            \n            ret += \" Accessed local variable slots: '\";\n            int[] alv = getAccessedLocalsIndices();\n            for (int i=0; i<alv.length; i++){\n                ret += alv[i]+\" \";\n            }\n            ret+=\"'.\";\n\n            ret += \" Recursively (via subsub...routines) accessed local variable slots: '\";\n            alv = getRecursivelyAccessedLocalsIndices();\n            for (int i=0; i<alv.length; i++){\n                ret += alv[i]+\" \";\n            }\n            ret+=\"'.\";\n\n            return ret;\n        }\n",
    "171337": "    public void visitFDIV(FDIV o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171338": "    public void visitASTORE(ASTORE o){\n        if (! ( (stack().peek() instanceof ReferenceType) || (stack().peek() instanceof ReturnaddressType) ) ){\n            constraintViolated(o, \"The 'objectref' is not of a ReferenceType or of ReturnaddressType but of \"+stack().peek()+\".\");\n        }\n        if (stack().peek() instanceof ReferenceType){\n            referenceTypeIsInitialized(o, (ReferenceType) (stack().peek()) );\n        }\n    }\n",
    "171340": "        private void _getRecursivelyAccessedLocalsIndicesHelper(HashSet s, Subroutine[] subs){\n            for (int i=0; i<subs.length; i++){\n                int[] lvs = subs[i].getAccessedLocalsIndices();\n                for (int j=0; j<lvs.length; j++){\n                    s.add(new Integer(lvs[j]));\n                }\n                if(subs[i].subSubs().length != 0){\n                    _getRecursivelyAccessedLocalsIndicesHelper(s, subs[i].subSubs());\n                }\n            }\n        }\n",
    "171342": "    public void visitFLOAD(FLOAD o){\n        stack().push(Type.FLOAT);\n    }\n",
    "171343": "    public Subroutine getSubroutine(InstructionHandle leader){\n        Subroutine ret = (Subroutine) subroutines.get(leader);\n        \n        if (ret == null){\n            throw new AssertionViolatedException(\"Subroutine requested for an InstructionHandle that is not a leader of a subroutine.\");\n        }\n\n        if (ret == TOPLEVEL){\n            throw new AssertionViolatedException(\"TOPLEVEL special subroutine requested; use getTopLevel().\");\n        }\n        \n        return ret;\n    }\n",
    "171344": "        private boolean objarrayequals(Object[] o, Object[] p){\n            if (o.length != p.length){\n                return false;\n            }\n            \n            for (int i=0; i<o.length; i++){\n                if (! (o[i].equals(p[i])) ){\n                    return false;\n                }\n            }\n            \n            return true;\n        }\n",
    "171346": "    public Subroutine subroutineOf(InstructionHandle any){\n        Iterator i = subroutines.values().iterator();\n        while (i.hasNext()){\n            Subroutine s = (Subroutine) i.next();\n            if (s.contains(any)) return s;\n        }\nSystem.err.println(\"DEBUG: Please verify '\"+any+\"' lies in dead code.\");\n        return null;\n        //throw new AssertionViolatedException(\"No subroutine for InstructionHandle found (DEAD CODE?).\");\n    }\n",
    "171347": "    protected Object clone(){\n        OperandStack newstack = new OperandStack(this.maxStack);\n        newstack.stack = (ArrayList) this.stack.clone();\n        return newstack;\n    }\n",
    "171348": "    public void clear(){\n        stack = new ArrayList();\n    }\n",
    "171349": "    public boolean equals(Object o){\n        if (!(o instanceof OperandStack)) return false;\n        OperandStack s = (OperandStack) o;\n        return this.stack.equals(s.stack);\n    }\n",
    "171350": "    public OperandStack getClone(){\n        return (OperandStack) this.clone();\n    }\n",
    "171351": "    public void visitFMUL(FMUL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171352": "    public Subroutine getTopLevel(){\n        return TOPLEVEL;\n    }\n",
    "171353": "    public boolean isEmpty(){\n        return stack.isEmpty();\n    }\n",
    "171354": "    public int maxStack(){\n        return this.maxStack;\n    }\n",
    "171355": "    public Type peek(){\n        return peek(0);\n    }\n",
    "171356": "    public Type peek(int i){\n        return (Type) stack.get(size()-i-1);\n    }\n",
    "171357": "    public void visitBALOAD(BALOAD o){\n        Type arrayref = stack().peek(1);\n        Type index    = stack().peek(0);\n        indexOfInt(o, index);\n        if (arrayrefOfArrayType(o, arrayref)){\n            if (! ( (((ArrayType) arrayref).getElementType().equals(Type.BOOLEAN)) ||\n                    (((ArrayType) arrayref).getElementType().equals(Type.BYTE)) ) ){\n                constraintViolated(o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\"+((ArrayType) arrayref).getElementType()+\"'.\");\n            }\n        }\n    }\n",
    "171358": "    public Type pop(){\n        Type e = (Type) stack.remove(size()-1);\n        return e;\n    }\n",
    "171359": "    public String toString(){\n        return \"---\\n\"+subroutines.toString()+\"\\n---\\n\";\n    }\n",
    "171360": "    public Type pop(int i){\n        for (int j=0; j<i; j++){\n            pop();\n        }\n        return null;\n    }\n",
    "171361": "    public void push(Type type){\n        if (type == null) throw new AssertionViolatedException(\"Cannot push NULL onto OperandStack.\");\n        if (type == Type.BOOLEAN || type == Type.CHAR || type == Type.BYTE || type == Type.SHORT){\n            throw new AssertionViolatedException(\"The OperandStack does not know about '\"+type+\"'; use Type.INT instead.\");\n        }\n        if (slotsUsed() >= maxStack){\n            throw new AssertionViolatedException(\"OperandStack too small, should have thrown proper Exception elsewhere. Stack: \"+this);\n        }\n        stack.add(type);\n    }\n",
    "171363": "    public void visitFNEG(FNEG o){\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171364": "    public int slotsUsed(){\n        /*  XXX change this to a better implementation using a variable\n            that keeps track of the actual slotsUsed()-value monitoring\n            all push()es and pop()s.\n        */\n        int slots = 0;\n        for (int i=0; i<stack.size(); i++){\n            slots += peek(i).getSize();\n        }\n        return slots;\n    }\n",
    "171366": "    public String toString(){\n        String s = \"Slots used: \"+slotsUsed()+\" MaxStack: \"+maxStack+\".\\n\";\n        for (int i=0; i<size(); i++){\n            s+=peek(i)+\" (Size: \"+peek(i).getSize()+\")\\n\";\n        }\n        return s;\n    }\n",
    "171369": "    public void initializeObject(UninitializedObjectType u){\n        for (int i=0; i<stack.size(); i++){\n            if (stack.get(i) == u){\n                stack.set(i, u.getInitialized());\n            }\n        }\n    }\n",
    "171371": "    public void visitBASTORE(BASTORE o){\n        Type arrayref = stack().peek(2);\n        Type index    = stack().peek(1);\n        Type value    = stack().peek(0);\n\n        indexOfInt(o, index);\n        valueOfInt(o, value);\n        if (arrayrefOfArrayType(o, arrayref)){\n            if (! ( (((ArrayType) arrayref).getElementType().equals(Type.BOOLEAN)) ||\n                    (((ArrayType) arrayref).getElementType().equals(Type.BYTE)) ) )\n                    constraintViolated(o, \"The 'arrayref' does not refer to an array with elements of a Type.BYTE or Type.BOOLEAN but to an array of '\"+((ArrayType) arrayref).getElementType()+\"'.\");\n        }\n    }\n",
    "171376": "    public void visitFREM(FREM o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171382": "        public String toString(){\n        //TODO: Put information in the brackets, e.g.\n        //      Is this an ExceptionHandler? Is this a RET? Is this the start of\n        //      a subroutine?\n            String ret = getInstruction().toString(false)+\"\\t[InstructionContext]\";\n            return ret;\n        }\n",
    "171384": "    public void visitBIPUSH(BIPUSH o){\n        // Nothing to do...\n    }\n",
    "171385": "        private boolean mergeInFrames(Frame inFrame){\n            // TODO: Can be performance-improved.\n            Frame inF = (Frame) inFrames.get(lastExecutionJSR());\n            OperandStack oldstack = inF.getStack().getClone();\n            LocalVariables oldlocals = inF.getLocals().getClone();\n            try{\n                inF.getStack().merge(inFrame.getStack());\n                inF.getLocals().merge(inFrame.getLocals());\n            }\n            catch (StructuralCodeConstraintException sce){\n                extendMessageWithFlow(sce);\n                throw sce;\n            }\n            if (    oldstack.equals(inF.getStack()) &&\n                        oldlocals.equals(inF.getLocals()) ){\n                return false;\n            }\n            else{\n                return true;\n            }\n        }\n",
    "171387": "    public void visitFRETURN(FRETURN o){\n        stack().pop();\n    }\n",
    "171388": "    public int getStatus(){\n        return numeric;\n    }\n",
    "171389": "        private String getExecutionChain(){\n            String s = this.toString();\n            for (int i=executionPredecessors.size()-1; i>=0; i--){\n                s = executionPredecessors.get(i)+\"\\n\" + s;\n            }\n            return s;\n        }\n",
    "171391": "    public boolean equals(Object o){\n        if (! (o instanceof VerificationResult)) return false;\n        VerificationResult other = (VerificationResult) o;\n        return ((other.numeric == this.numeric) && (other.detailMessage.equals(this.detailMessage)));\n    }\n",
    "171392": "    public String toString(){\n        String ret=\"\";\n        if (numeric == VERIFIED_NOTYET)   ret = \"VERIFIED_NOTYET\";\n        if (numeric == VERIFIED_OK)       ret = \"VERIFIED_OK\";\n        if (numeric == VERIFIED_REJECTED) ret = \"VERIFIED_REJECTED\";\n        ret+=\"\\n\"+detailMessage+\"\\n\";\n        return ret;\n    }\n",
    "171394": "    public VerificationResult doPass1(){\n        if (p1v == null){\n            p1v = new Pass1Verifier(this);\n        }\n        return p1v.verify();\n    }\n",
    "171396": "    public VerificationResult doPass2(){\n        if (p2v == null){\n            p2v = new Pass2Verifier(this);\n        }\n        return p2v.verify();\n    }\n",
    "171397": "    public VerificationResult doPass3a(int method_no){\n        String key = Integer.toString(method_no);\n        Pass3aVerifier p3av;\n        p3av = (Pass3aVerifier) (p3avs.get(key));\n        if (p3avs.get(key) == null){\n            p3av = new Pass3aVerifier(this, method_no);\n            p3avs.put(key, p3av);\n        }\n        return p3av.verify();\n    }\n",
    "171398": "        private InstructionContextImpl lastExecutionJSR(){\n            \n            int size = executionPredecessors.size();\n            int retcount = 0;\n            \n            for (int i=size-1; i>=0; i--){\n                InstructionContextImpl current = (InstructionContextImpl) (executionPredecessors.get(i));\n                Instruction currentlast = current.getInstruction().getInstruction();\n                if (currentlast instanceof RET) retcount++;\n                if (currentlast instanceof JsrInstruction){\n                    retcount--;\n                    if (retcount == -1) return current;\n                }\n            }\n            return null;\n        }\n",
    "171399": "    public VerificationResult doPass3b(int method_no){\n        String key = Integer.toString(method_no);\n        Pass3bVerifier p3bv;\n        p3bv = (Pass3bVerifier) (p3bvs.get(key));\n        if (p3bvs.get(key) == null){\n            p3bv = new Pass3bVerifier(this, method_no);\n            p3bvs.put(key, p3bv);\n        }\n        return p3bv.verify();\n    }\n",
    "171400": "    public void visitBREAKPOINT(BREAKPOINT o){\n        throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as BREAKPOINT.\");\n    }\n",
    "171401": "    public void visitFSTORE(FSTORE o){\n        locals().set(o.getIndex(), stack().pop());\n    }\n",
    "171402": "    public void flush(){\n        p1v = null;\n        p2v = null;\n        p3avs.clear();\n        p3bvs.clear();\n    }\n",
    "171403": "    public InstructionContext contextOf(InstructionHandle inst){\n        InstructionContext ic = (InstructionContext) instructionContexts.get(inst);\n        if (ic == null){\n            throw new AssertionViolatedException(\"InstructionContext requested for an InstructionHandle that's not known!\");\n        }\n        return ic;\n    }\n",
    "171412": "  public void storeClass(JavaClass clazz) {\n    _loadedClasses.put(clazz.getClassName(), clazz);\n    clazz.setRepository(this);\n }\n",
    "171413": "  public void removeClass(JavaClass clazz) {\n    _loadedClasses.remove(clazz.getClassName());\n  }\n",
    "171414": "    public void visitFSUB(FSUB o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171415": "  public JavaClass findClass(String className) {\n    return (JavaClass)_loadedClasses.get(className);\n  }\n",
    "171417": "  public JavaClass loadClass(Class clazz) throws ClassNotFoundException {\n    String className = clazz.getName();\n    String name      = className;\n    int    i         = name.lastIndexOf('.');\n\n    if(i > 0) {\n      name = name.substring(i + 1);\n    }\n\n    return loadClass(clazz.getResourceAsStream(name + \".class\"), className);\n  }\n",
    "171418": "    public void visitCALOAD(CALOAD o){\n        Type arrayref = stack().peek(1);\n        Type index = stack().peek(0);\n        \n        indexOfInt(o, index);\n        arrayrefOfArrayType(o, arrayref);\n    }\n",
    "171421": "  public void clear() {\n    _loadedClasses.clear();\n  }\n",
    "171422": "    public void visitGETFIELD(GETFIELD o){\n        stack().pop();\n        Type t = o.getFieldType(cpg);\n        if (    t.equals(Type.BOOLEAN)    ||\n                    t.equals(Type.CHAR)            ||\n                    t.equals(Type.BYTE)         ||\n                    t.equals(Type.SHORT)        )\n            t = Type.INT;\n        stack().push(t);\n    }\n",
    "171433": "    public void visitGETSTATIC(GETSTATIC o){\n        Type t = o.getFieldType(cpg);\n        if (    t.equals(Type.BOOLEAN)    ||\n                    t.equals(Type.CHAR)            ||\n                    t.equals(Type.BYTE)         ||\n                    t.equals(Type.SHORT)        )\n            t = Type.INT;\n        stack().push(t);\n    }\n",
    "171436": "  public InputStream getInputStream(String name, String suffix) throws IOException {\n    InputStream is = null;\n\n    try {\n      is = getClass().getClassLoader().getResourceAsStream(name + suffix);\n    } catch(Exception e) { }\n\n    if(is != null)\n      return is;\n    \n    return getClassFile(name, suffix).getInputStream();\n  }\n",
    "171438": "    public void visitCASTORE(CASTORE o){\n        Type arrayref = stack().peek(2);\n        Type index = stack().peek(1);\n        Type value = stack().peek(0);\n        \n        indexOfInt(o, index);\n        valueOfInt(o, value);\n        if (arrayrefOfArrayType(o, arrayref)){\n            if (! ((ArrayType) arrayref).getElementType().equals(Type.CHAR) ){\n                constraintViolated(o, \"The 'arrayref' does not refer to an array with elements of type char but to an array of type \"+((ArrayType) arrayref).getElementType()+\".\");\n            }\n        }\n    }\n",
    "171444": "    public void visitGOTO(GOTO o){\n        // no stack changes.\n    }\n",
    "171453": "    public void visitGOTO_W(GOTO_W o){\n        // no stack changes.\n    }\n",
    "171463": "    public void visitI2B(I2B o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171469": "  public JavaClass findClass( String className ) {\n    if ( loadedClasses.containsKey( className )) {\n      return (JavaClass) loadedClasses.get( className );\n    } else {\n      return null;\n    }\n  }\n",
    "171473": "    public void visitI2C(I2C o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171480": "    public void visitD2F(D2F o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171482": "    public void visitI2D(I2D o){\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171487": "  public void dump(DataOutputStream out) throws IOException {\n    super.dump(out);\n    out.writeInt(match_length);       // npairs\n\n    for(int i=0; i < match_length; i++) {\n      out.writeInt(match[i]);         // match-offset pairs\n      out.writeInt(indices[i] = getTargetOffset(targets[i]));\n    }\n  }\n",
    "171490": "  public void accept(Visitor v) {\n    v.visitVariableLengthInstruction(this);\n    v.visitStackProducer(this);\n    v.visitBranchInstruction(this);\n    v.visitSelect(this);\n    v.visitLOOKUPSWITCH(this);\n  }\n",
    "171494": "    public void visitI2F(I2F o){\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171499": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitISTORE(this);\n  }\n",
    "171501": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitFASTORE(this);\n  }\n",
    "171503": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitDCMPL(this);\n  }\n",
    "171505": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitPopInstruction(this);\n    v.visitTypedInstruction(this);\n    v.visitLocalVariableInstruction(this);\n    v.visitStoreInstruction(this);\n  }\n",
    "171506": "    public void visitD2I(D2I o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171507": "  public void accept(Visitor v) {\n    v.visitIMPDEP1(this);\n  }\n",
    "171508": "    public void visitI2L(I2L o){\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "171518": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ICMPEQ(this);\n  }\n",
    "171519": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLMUL(this);\n  }\n",
    "171521": "    public void visitI2S(I2S o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171523": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFGE(this);\n  }\n",
    "171525": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitStackProducer(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitInvokeInstruction(this);\n    v.visitINVOKESPECIAL(this);\n  }\n",
    "171526": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitD2F(this);\n  }\n",
    "171527": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLSHL(this);\n  }\n",
    "171529": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitReturnInstruction(this);\n    v.visitARETURN(this);\n  }\n",
    "171530": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n    out.writeShort(index);\n    out.writeByte(nargs);\n    out.writeByte(0);\n  }\n",
    "171533": "    public void visitD2L(D2L o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171534": "    public void visitIADD(IADD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171539": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitStackProducer(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitInvokeInstruction(this);\n    v.visitINVOKEINTERFACE(this);\n  }\n",
    "171540": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIADD(this);\n  }\n",
    "171542": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitFALOAD(this);\n  }\n",
    "171544": "    public void visitIALOAD(IALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171545": "  public void addInterface(String name) {\n    interface_vec.add(name);\n  }\n",
    "171546": "  protected void adjustSize() {\n    if(index + 3 >= size) {\n      Constant[] cs = constants;\n\n      size      *= 2;\n      constants  = new Constant[size];\n      System.arraycopy(cs, 0, constants, 0, index);\n    }\n  }\n",
    "171547": "  public void removeInterface(String name) {\n    interface_vec.remove(name);\n  }\n",
    "171548": "  public int lookupString(String str) {\n    Index index = (Index)string_table.get(str);\n    return (index != null)? index.index : -1;\n  }\n",
    "171551": "    public void visitDADD(DADD o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171552": "    public void visitIAND(IAND o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171553": "  public void setMajor(int major) {\n    this.major = major;\n  }    \n",
    "171555": "  public void setMinor(int minor) {\n    this.minor = minor;\n  }    \n",
    "171557": "  public int lookupClass(String str) {\n    Index index = (Index)class_table.get(str.replace('.', '/'));\n    return (index != null)? index.index : -1;\n  }\n",
    "171559": "    public void visitIASTORE(IASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171564": "    public void visitDALOAD(DALOAD o){\n        indexOfInt(o, stack().peek());\n        if (stack().peek(1) == Type.NULL){\n            return;\n        } \n        if (! (stack().peek(1) instanceof ArrayType)){\n            constraintViolated(o, \"Stack next-to-top must be of type double[] but is '\"+stack().peek(1)+\"'.\");\n        }\n        Type t = ((ArrayType) (stack().peek(1))).getBasicType();\n        if (t != Type.DOUBLE){\n            constraintViolated(o, \"Stack next-to-top must be of type double[] but is '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171566": "    public void visitICONST(ICONST o){\n        stack().push(Type.INT);\n    }\n",
    "171567": "  public int addClass(ObjectType type) {\n    return addClass(type.getClassName());\n  }\n",
    "171569": "  public int addArrayClass(ArrayType type) {\n    return addClass_(type.getSignature());\n  }\n",
    "171571": "    public void visitIDIV(IDIV o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171572": "  public int lookupInteger(int n) {\n    for(int i=1; i < index; i++) {\n      if(constants[i] instanceof ConstantInteger) {\n    ConstantInteger c = (ConstantInteger)constants[i];\n\n    if(c.getBytes() == n)\n      return i;\n      }\n    }\n\n    return -1;\n  }\n",
    "171576": "    public void visitIF_ACMPEQ(IF_ACMPEQ o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171577": "  public int lookupFloat(float n) {\n    int bits = Float.floatToIntBits(n);\n\n    for(int i=1; i < index; i++) {\n      if(constants[i] instanceof ConstantFloat) {\n    ConstantFloat c = (ConstantFloat)constants[i];\n\n    if(Float.floatToIntBits(c.getBytes()) == bits)\n      return i;\n      }\n    }\n\n    return -1;\n  }\n",
    "171580": "  public void replaceMethod(Method old, Method new_) {\n    if(new_ == null)\n      throw new ClassGenException(\"Replacement method must not be null\");\n\n    int i = method_vec.indexOf(old);\n\n    if(i < 0)\n      method_vec.add(new_);\n    else\n      method_vec.set(i, new_);\n  }\n",
    "171581": "    public void visitIF_ACMPNE(IF_ACMPNE o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171582": "  public int lookupUtf8(String n) {\n    Index index = (Index)utf8_table.get(n);\n\n    return (index != null)? index.index : -1;\n  }\n",
    "171583": "  public void replaceField(Field old, Field new_) {\n    if(new_ == null)\n      throw new ClassGenException(\"Replacement method must not be null\");\n\n    int i = field_vec.indexOf(old);\n\n    if(i < 0)\n      field_vec.add(new_);\n    else\n      field_vec.set(i, new_);\n  }\n",
    "171586": "    public void visitIF_ICMPEQ(IF_ICMPEQ o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171588": "  public int lookupLong(long n) {\n    for(int i=1; i < index; i++) {\n      if(constants[i] instanceof ConstantLong) {\n    ConstantLong c = (ConstantLong)constants[i];\n\n    if(c.getBytes() == n)\n      return i;\n      }\n    }\n\n    return -1;\n  }\n",
    "171591": "    public void visitIF_ICMPGE(IF_ICMPGE o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171593": "  public int lookupDouble(double n) {\n    long bits = Double.doubleToLongBits(n);\n\n    for(int i=1; i < index; i++) {\n      if(constants[i] instanceof ConstantDouble) {\n    ConstantDouble c = (ConstantDouble)constants[i];\n    \n    if(Double.doubleToLongBits(c.getBytes()) == bits)\n      return i;\n      }\n    }\n\n    return -1;\n  }\n",
    "171596": "    public void visitIF_ICMPGT(IF_ICMPGT o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171598": "  public int lookupNameAndType(String name, String signature) {\n    Index index = (Index)n_a_t_table.get(name + NAT_DELIM + signature);\n    return (index != null)? index.index : -1;\n  }\n",
    "171601": "    public void visitIF_ICMPLE(IF_ICMPLE o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171602": "    public void visitDCMPG(DCMPG o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171603": "  public int lookupMethodref(String class_name, String method_name, String signature) {\n    Index index = (Index)cp_table.get(class_name + METHODREF_DELIM + method_name +\n                      METHODREF_DELIM + signature);\n    return (index != null)? index.index : -1;\n  }\n",
    "171605": "    public void visitIF_ICMPLT(IF_ICMPLT o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171610": "    public void visitIF_ICMPNE(IF_ICMPNE o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "171613": "  public int lookupInterfaceMethodref(String class_name, String method_name, String signature) {\n    Index index = (Index)cp_table.get(class_name + IMETHODREF_DELIM + method_name +\n                      IMETHODREF_DELIM + signature);\n    return (index != null)? index.index : -1;\n  }\n",
    "171615": "    public void visitIFEQ(IFEQ o){\n        stack().pop();\n    }\n",
    "171618": "    public void visitIFGE(IFGE o){\n        stack().pop();\n    }\n",
    "171621": "    public void visitDCMPL(DCMPL o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171625": "    public void visitIFGT(IFGT o){\n        stack().pop();\n    }\n",
    "171626": "  public void addObserver(ClassObserver o) {\n    if(observers == null)\n      observers = new ArrayList();\n\n    observers.add(o);\n  }\n",
    "171627": "    public void visitDCONST(DCONST o){\n        // There's nothing to be done here.\n    }\n",
    "171628": "  public int lookupFieldref(String class_name, String field_name, String signature) {\n    Index index = (Index)cp_table.get(class_name + FIELDREF_DELIM + field_name +\n                      FIELDREF_DELIM + signature);\n    return (index != null)? index.index : -1;\n  }\n",
    "171629": "  public void removeObserver(ClassObserver o) {\n    if(observers != null)\n      observers.remove(o);\n  }\n",
    "171631": "    public void visitIFLE(IFLE o){\n        stack().pop();\n    }\n",
    "171632": "  public void update() {\n    if(observers != null)\n      for(Iterator e = observers.iterator(); e.hasNext(); )\n    ((ClassObserver)e.next()).notify(this);\n  }\n",
    "171636": "    public void visitDDIV(DDIV o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171638": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitCASTORE(this);\n  }\n",
    "171639": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitFSUB(this);\n  }\n",
    "171640": "  public void dump(DataOutputStream out) throws IOException {\n    index = getTargetOffset();\n    if(opcode == de.uka.ipd.coverage.org.apache.bcel.Constants.JSR)\n      super.dump(out);\n    else { // JSR_W\n      index = getTargetOffset();\n      out.writeByte(opcode);\n      out.writeInt(index);\n    }\n  }\n",
    "171643": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitVariableLengthInstruction(this);\n    v.visitBranchInstruction(this);\n    v.visitJsrInstruction(this);\n    v.visitJSR(this);\n  }\n",
    "171644": "    public void visitIFLT(IFLT o){\n        stack().pop();\n    }\n",
    "171645": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitISHR(this);\n  }\n",
    "171646": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitPopInstruction(this);\n    v.visitStackInstruction(this);\n    v.visitPOP2(this);\n  }\n",
    "171648": "  public void dump(DataOutputStream out) throws IOException {\n    super.dump(out);\n\n    int low = (match_length > 0)? match[0] : 0;\n    out.writeInt(low);\n\n    int high = (match_length > 0)? match[match_length - 1] : 0;\n    out.writeInt(high);\n\n    for(int i=0; i < match_length; i++)     // jump offsets\n      out.writeInt(indices[i] = getTargetOffset(targets[i]));\n  }\n",
    "171650": "  public void accept(Visitor v) {\n    v.visitVariableLengthInstruction(this);\n    v.visitStackProducer(this);\n    v.visitBranchInstruction(this);\n    v.visitSelect(this);\n    v.visitTABLESWITCH(this);\n  }\n",
    "171651": "    public void visitDLOAD(DLOAD o){\n        //visitLoadInstruction(LoadInstruction) is called before.\n        \n        // Nothing else needs to be done here.\n    }\n",
    "171654": "    public void visitIFNE(IFNE o){\n        stack().pop();\n    }\n",
    "171659": "  public void accept(Visitor v) {\n    v.visitUnconditionalBranch(this);\n    v.visitExceptionThrower(this);\n    v.visitATHROW(this);\n  }\n",
    "171662": "    public void visitIFNONNULL(IFNONNULL o){\n        stack().pop();\n    }\n",
    "171663": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFEQ(this);\n  }\n",
    "171666": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ICMPLE(this);\n  }\n",
    "171667": "    public void visitDMUL(DMUL o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171670": "  public InstructionHandle physicalSuccessor(){\n    InstructionHandle ih = this.target;\n    \n    // Rewind!\n    while(ih.getPrev() != null)\n      ih = ih.getPrev();\n    \n    // Find the handle for \"this\" JsrInstruction object.\n    while(ih.getInstruction() != this)\n      ih = ih.getNext();\n    \n    InstructionHandle toThis = ih;\n    \n    while(ih != null){\n        ih = ih.getNext();\n        if ((ih != null) && (ih.getInstruction() == this))\n        throw new RuntimeException(\"physicalSuccessor() called on a shared JsrInstruction.\");\n    }\n    \n    // Return the physical successor        \n    return toThis.getNext();\n  }\n",
    "171672": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLREM(this);\n  }\n",
    "171674": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitSASTORE(this);\n  }\n",
    "171677": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitBASTORE(this);\n  }\n",
    "171678": "    public void visitIFNULL(IFNULL o){\n        stack().pop();\n    }\n",
    "171681": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ICMPGT(this);\n  }\n",
    "171690": "    public void visitIINC(IINC o){\n        // stack is not changed.\n    }\n",
    "171694": "    public void visitDNEG(DNEG o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171702": "    public void visitILOAD(ILOAD o){\n        stack().push(Type.INT);\n    }\n",
    "171707": "  public void cancelInitValue() {\n    value = null;\n  }\n",
    "171712": "  public Field getField() {\n    String      signature       = getSignature();\n    int         name_index      = cp.addUtf8(name);\n    int         signature_index = cp.addUtf8(signature);\n\n    if(value != null) {\n      checkType(type);\n      int index = addConstant();\n      addAttribute(new ConstantValue(cp.addUtf8(\"ConstantValue\"),\n                     2, index, cp.getConstantPool()));\n    }\n\n    return new Field(access_flags, name_index, signature_index, getAttributes(),\n             cp.getConstantPool());\n  }\n",
    "171713": "    public void visitIMUL(IMUL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171718": "    public void visitDREM(DREM o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171720": "  public void addObserver(FieldObserver o) {\n    if(observers == null)\n      observers = new ArrayList();\n\n    observers.add(o);\n  }\n",
    "171722": "  public void removeObserver(FieldObserver o) {\n    if(observers != null)\n      observers.remove(o);\n  }\n",
    "171724": "    public void visitINEG(INEG o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171725": "  public void update() {\n    if(observers != null)\n      for(Iterator e = observers.iterator(); e.hasNext(); )\n    ((FieldObserver)e.next()).notify(this);\n  }\n",
    "171731": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitDLOAD(this);\n  }\n",
    "171733": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLSUB(this);\n  }\n",
    "171736": "    public void visitINSTANCEOF(INSTANCEOF o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171737": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFNE(this);\n  }\n",
    "171739": "  public void dump(DataOutputStream out) throws IOException {\n    if(wide()) // Need WIDE prefix ?\n      out.writeByte(Constants.WIDE);\n\n    out.writeByte(opcode);\n\n    if(length > 1) { // Otherwise ILOAD_n, instruction, e.g.\n      if(wide())\n    out.writeShort(n);\n      else\n    out.writeByte(n);\n    }\n  }\n",
    "171741": "  public String toString(boolean verbose) {\n    if(((opcode >= Constants.ILOAD_0) &&\n    (opcode <= Constants.ALOAD_3)) ||\n       ((opcode >= Constants.ISTORE_0) &&\n    (opcode <= Constants.ASTORE_3)))\n      return super.toString(verbose);\n    else\n      return super.toString(verbose) + \" \" + n;\n  }\n",
    "171742": "    public void visitDRETURN(DRETURN o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171746": "  public void setIndex(int n) { \n    if((n < 0) || (n > Constants.MAX_SHORT))\n      throw new ClassGenException(\"Illegal value: \" + n);\n\n    this.n = n;\n\n    if(n >= 0 && n <= 3) { // Use more compact instruction xLOAD_n\n      opcode = (short)(c_tag + n);\n      length = 1;\n    } else {\n      opcode = canon_tag;\n      \n      if(wide()) // Need WIDE prefix ?\n    length = 4;\n      else\n    length = 2;\n    }\n  }\n",
    "171749": "    public void visitINVOKEINTERFACE(INVOKEINTERFACE o){\n        stack().pop();    //objectref\n        for (int i=0; i<o.getArgumentTypes(cpg).length; i++){\n            stack().pop();\n        }\n        // We are sure the invoked method will xRETURN eventually\n        // We simulate xRETURNs functionality here because we\n        // don't really \"jump into\" and simulate the invoked\n        // method.\n        if (o.getReturnType(cpg) != Type.VOID){\n            Type t = o.getReturnType(cpg);\n            if (    t.equals(Type.BOOLEAN)    ||\n                        t.equals(Type.CHAR)            ||\n                        t.equals(Type.BYTE)         ||\n                        t.equals(Type.SHORT)        )\n                t = Type.INT;\n            stack().push(t);\n        }\n    }\n",
    "171751": "  public Type getType(ConstantPoolGen cp) {\n    switch(canon_tag) {\n    case Constants.ILOAD: case Constants.ISTORE: \n      return Type.INT;\n    case Constants.LLOAD: case Constants.LSTORE: \n      return Type.LONG;\n    case Constants.DLOAD: case Constants.DSTORE: \n      return Type.DOUBLE;\n    case Constants.FLOAD: case Constants.FSTORE: \n      return Type.FLOAT;\n    case Constants.ALOAD: case Constants.ASTORE:\n      return Type.OBJECT;\n\n    default: throw new ClassGenException(\"Oops: unknown case in switch\" + canon_tag);\n    }\n  }\n",
    "171753": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitI2B(this);\n  }\n",
    "171755": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitL2D(this);\n  }\n",
    "171758": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitStackConsumer(this);\n    v.visitPopInstruction(this);\n    v.visitTypedInstruction(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitFieldInstruction(this);\n    v.visitPUTFIELD(this);\n  }\n",
    "171760": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitStackProducer(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitInvokeInstruction(this);\n    v.visitINVOKESTATIC(this);\n  }\n",
    "171762": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitASTORE(this);\n  }\n",
    "171764": "    public void visitDSTORE(DSTORE o){\n        //visitStoreInstruction(StoreInstruction) is called before.\n        \n        // Nothing else needs to be done here.\n    }\n",
    "171765": "  public void dump(DataOutputStream out) throws IOException {\n    super.dump(out);\n    out.writeShort(b);\n  }\n",
    "171775": "  public void accept(Visitor v) {\n    v.visitPushInstruction(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitConstantPushInstruction(this);\n    v.visitSIPUSH(this);\n  }\n",
    "171778": "  public void dump(DataOutputStream out) throws IOException {\n    if(wide)\n      out.writeByte(de.uka.ipd.coverage.org.apache.bcel.Constants.WIDE);\n\n    out.writeByte(opcode);\n\n    if(wide)\n      out.writeShort(index);\n    else\n      out.writeByte(index);\n  }\n",
    "171780": "    public void visitINVOKESTATIC(INVOKESTATIC o){\n        for (int i=0; i<o.getArgumentTypes(cpg).length; i++){\n            stack().pop();\n        }\n        // We are sure the invoked method will xRETURN eventually\n        // We simulate xRETURNs functionality here because we\n        // don't really \"jump into\" and simulate the invoked\n        // method.\n        if (o.getReturnType(cpg) != Type.VOID){\n            Type t = o.getReturnType(cpg);\n            if (    t.equals(Type.BOOLEAN)    ||\n                        t.equals(Type.CHAR)            ||\n                        t.equals(Type.BYTE)         ||\n                        t.equals(Type.SHORT)        )\n                t = Type.INT;\n            stack().push(t);\n        }\n    }\n",
    "171786": "    public void visitDSUB(DSUB o){\n        if (stack().peek() != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack top is not of type 'double', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.DOUBLE){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'double', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171787": "  public void accept(Visitor v) {\n    v.visitRET(this);\n  }\n",
    "171789": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitI2C(this);\n  }\n",
    "171792": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ICMPLT(this);\n  }\n",
    "171793": "  public void dump(DataOutputStream out) throws IOException {\n    index = getTargetOffset();\n    out.writeByte(opcode);\n    out.writeInt(index);\n  }\n",
    "171796": "    public void visitINVOKEVIRTUAL(INVOKEVIRTUAL o){\n        stack().pop(); //objectref\n        for (int i=0; i<o.getArgumentTypes(cpg).length; i++){\n            stack().pop();\n        }\n        // We are sure the invoked method will xRETURN eventually\n        // We simulate xRETURNs functionality here because we\n        // don't really \"jump into\" and simulate the invoked\n        // method.\n        if (o.getReturnType(cpg) != Type.VOID){\n            Type t = o.getReturnType(cpg);\n            if (    t.equals(Type.BOOLEAN)    ||\n                        t.equals(Type.CHAR)            ||\n                        t.equals(Type.BYTE)         ||\n                        t.equals(Type.SHORT)        )\n                t = Type.INT;\n            stack().push(t);\n        }\n    }\n",
    "171797": "  public void accept(Visitor v) {\n    v.visitUnconditionalBranch(this);\n    v.visitBranchInstruction(this);\n    v.visitGotoInstruction(this);\n    v.visitGOTO_W(this);\n  }\n",
    "171800": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitFCMPG(this);\n  }\n",
    "171803": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitStackProducer(this);\n    v.visitARRAYLENGTH(this);\n  }\n",
    "171808": "  public void accept(Visitor v) {\n    v.visitPushInstruction(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitConstantPushInstruction(this);\n    v.visitICONST(this);\n  }\n",
    "171809": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitBALOAD(this);\n  }\n",
    "171810": "    public void visitIOR(IOR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171813": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFNONNULL(this);\n  }\n",
    "171816": "    public void visitDUP(DUP o){\n        if (stack().peek().getSize() != 1){\n            constraintViolated(o, \"Won't DUP type on stack top '\"+stack().peek()+\"' because it must occupy exactly one slot, not '\"+stack().peek().getSize()+\"'.\");\n        }\n    }\n",
    "171819": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n    out.writeShort(index);\n  }\n",
    "171820": "  public String toString(boolean verbose) {\n    return super.toString(verbose) + \" \" + index;\n  }\n",
    "171826": "    public void visitIREM(IREM o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171827": "  public void setIndex(int index) { \n    if(index < 0)\n      throw new ClassGenException(\"Negative index value: \" + index);\n\n    this.index = index;\n  }\n",
    "171834": "  public LineNumber getLineNumber() {\n    return new LineNumber(ih.getPosition(), src_line);\n  }\n",
    "171840": "    public void visitIRETURN(IRETURN o){\n        stack().pop();\n    }\n",
    "171842": "    public void visitDUP_X1(DUP_X1 o){\n        if (stack().peek().getSize() != 1){\n            constraintViolated(o, \"Type on stack top '\"+stack().peek()+\"' should occupy exactly one slot, not '\"+stack().peek().getSize()+\"'.\");\n        }\n        if (stack().peek(1).getSize() != 1){\n            constraintViolated(o, \"Type on stack next-to-top '\"+stack().peek(1)+\"' should occupy exactly one slot, not '\"+stack().peek(1).getSize()+\"'.\");\n        }\n    }\n",
    "171845": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitISHL(this);\n  }\n",
    "171846": "  public void accept(Visitor v) {\n    v.visitStackInstruction(this);\n    v.visitDUP2_X1(this);\n  }\n",
    "171848": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitF2D(this);\n  }\n",
    "171849": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitStackProducer(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitInvokeInstruction(this);\n    v.visitINVOKEVIRTUAL(this);\n  }\n",
    "171851": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitIALOAD(this);\n  }\n",
    "171852": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitF2I(this);\n  }\n",
    "171854": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitAASTORE(this);\n  }\n",
    "171855": "    public void visitISHL(ISHL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171857": "  public void dump(DataOutputStream out) throws IOException {\n    super.dump(out);\n    out.writeByte(b);\n  }\n",
    "171864": "  public void accept(Visitor v) {\n    v.visitPushInstruction(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitConstantPushInstruction(this);\n    v.visitBIPUSH(this);\n  }\n",
    "171866": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIUSHR(this);\n  }\n",
    "171867": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLAND(this);\n  }\n",
    "171869": "    public void visitISHR(ISHR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171878": "    public void visitISTORE(ISTORE o){\n        locals().set(o.getIndex(), stack().pop());\n    }\n",
    "171885": "  public InstructionList createPrintln(String s) {\n    InstructionList il      = new InstructionList();\n    int             out     = cp.addFieldref(\"java.lang.System\", \"out\",\n                         \"Ljava/io/PrintStream;\");\n    int             println = cp.addMethodref(\"java.io.PrintStream\", \"println\",\n                          \"(Ljava/lang/String;)V\");\n\n    il.append(new GETSTATIC(out));\n    il.append(new PUSH(cp, s));\n    il.append(new INVOKEVIRTUAL(println));\n\n    return il;\n  }\n",
    "171887": "    public void visitDUP2(DUP2 o){\n        if (stack().peek().getSize() == 2){\n            return; // Form 2, okay.\n        }\n        else{ //stack().peek().getSize() == 1.\n            if (stack().peek(1).getSize() != 1){\n                constraintViolated(o, \"If stack top's size is 1, then stack next-to-top's size must also be 1. But it is '\"+stack().peek(1)+\"' of size '\"+stack().peek(1).getSize()+\"'.\");\n            }\n        }\n    }\n",
    "171888": "    public void visitISUB(ISUB o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171890": "  public Instruction createConstant(Object value) {\n    PUSH push;\n\n    if(value instanceof Number)\n      push = new PUSH(cp, (Number)value);\n    else if(value instanceof String)\n      push = new PUSH(cp, (String)value);\n    else if(value instanceof Boolean)\n      push = new PUSH(cp, (Boolean)value);\n    else if(value instanceof Character)\n      push = new PUSH(cp, (Character)value);\n    else\n      throw new ClassGenException(\"Illegal type: \" + value.getClass());\n\n    return push.getInstruction();\n  }\n",
    "171897": "    public void visitIUSHR(IUSHR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171900": "  public FieldInstruction createFieldAccess(String class_name, String name, Type type, short kind) {\n    int    index;\n    String signature  = type.getSignature();\n\n    index = cp.addFieldref(class_name, name, signature);\n\n    switch(kind) {\n    case Constants.GETFIELD:  return new GETFIELD(index);\n    case Constants.PUTFIELD:  return new PUTFIELD(index);\n    case Constants.GETSTATIC: return new GETSTATIC(index);\n    case Constants.PUTSTATIC: return new PUTSTATIC(index);\n\n    default:\n      throw new RuntimeException(\"Oops: Unknown getfield kind:\" + kind);\n    }\n  }\n",
    "171906": "    public void visitIXOR(IXOR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171913": "    public void visitJSR(JSR o){\n        stack().push(new ReturnaddressType(o.physicalSuccessor()));\n//System.err.println(\"TODO-----------:\"+o.physicalSuccessor());\n    }\n",
    "171921": "    public void visitJSR_W(JSR_W o){\n        stack().push(new ReturnaddressType(o.physicalSuccessor()));\n    }\n",
    "171928": "    public void visitL2D(L2D o){\n        stack().pop();\n        stack().push(Type.DOUBLE);\n    }\n",
    "171935": "    public void visitF2D(F2D o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171937": "    public void visitL2F(L2F o){\n        stack().pop();\n        stack().push(Type.FLOAT);\n    }\n",
    "171943": "  public Instruction createNewArray(Type t, short dim) {\n    if(dim == 1) {\n      if(t instanceof ObjectType)\n    return new ANEWARRAY(cp.addClass((ObjectType)t));\n      else if(t instanceof ArrayType)\n    return new ANEWARRAY(cp.addArrayClass((ArrayType)t));\n      else\n    return new NEWARRAY(((BasicType)t).getType());\n    } else {\n      ArrayType at;\n\n      if(t instanceof ArrayType)\n    at = (ArrayType)t;\n      else\n    at = new ArrayType(t, dim);\n\n      return new MULTIANEWARRAY(cp.addArrayClass(at), dim);\n    }\n  }\n",
    "171945": "    public void visitL2I(L2I o){\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "171950": "    public void visitF2I(F2I o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171952": "    public void visitLADD(LADD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "171960": "    public void visitLALOAD(LALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "171965": "    public void visitF2L(F2L o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "171967": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFNULL(this);\n  }\n",
    "171969": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitDSUB(this);\n  }\n",
    "171970": "  public void accept(Visitor v) {\n    v.visitIMPDEP2(this);\n  }\n",
    "171971": "    public void visitLAND(LAND o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "171973": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitTypedInstruction(this);\n    v.visitLocalVariableInstruction(this);\n    v.visitLoadInstruction(this);\n  }\n",
    "171977": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFGT(this);\n  }\n",
    "171978": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitALOAD(this);\n  }\n",
    "171980": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitReturnInstruction(this);\n    v.visitFRETURN(this);\n  }\n",
    "171982": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitDCMPG(this);\n  }\n",
    "171984": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitD2L(this);\n  }\n",
    "171986": "    public void visitLASTORE(LASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "171988": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ACMPNE(this);\n  }\n",
    "171991": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ICMPGE(this);\n  }\n",
    "171992": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitReturnInstruction(this);\n    v.visitIRETURN(this);\n  }\n",
    "171994": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitReturnInstruction(this);\n    v.visitLRETURN(this);\n  }\n",
    "171995": "    public void visitFADD(FADD o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "171997": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFLE(this);\n  }\n",
    "171999": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitI2L(this);\n  }\n",
    "172001": "    public void visitLCMP(LCMP o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "172002": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n\n    index = getTargetOffset();\n\n    if(Math.abs(index) >= 32767) // too large for short\n      throw new ClassGenException(\"Branch target offset too large for short\");\n\n    out.writeShort(index); // May be negative, i.e., point backwards\n  }\n",
    "172007": "  protected int updatePosition(int offset, int max_offset) {\n    position += offset;\n    return 0;\n  }\n",
    "172009": "  public String toString(boolean verbose) {\n    String s = super.toString(verbose);\n    String t = \"null\";\n\n    if(verbose) {\n      if(target != null) {\n    if(target.getInstruction() == this)\n      t = \"<points to itself>\";\n    else if(target.getInstruction() == null)\n      t = \"<null instruction!!!?>\";\n    else\n      t = target.getInstruction().toString(false); // Avoid circles\n      }\n    } else {\n      if(target != null) {\n    index = getTargetOffset();\n    t = \"\" + (index + position);\n      }\n    }\n\n    return s + \" -> \" + t;\n  }\n",
    "172012": "    public void visitLCONST(LCONST o){\n        stack().push(Type.LONG);\n    }\n",
    "172018": "    public void visitFALOAD(FALOAD o){\n        indexOfInt(o, stack().peek());\n        if (stack().peek(1) == Type.NULL){\n            return;\n        } \n        if (! (stack().peek(1) instanceof ArrayType)){\n            constraintViolated(o, \"Stack next-to-top must be of type float[] but is '\"+stack().peek(1)+\"'.\");\n        }\n        Type t = ((ArrayType) (stack().peek(1))).getBasicType();\n        if (t != Type.FLOAT){\n            constraintViolated(o, \"Stack next-to-top must be of type float[] but is '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172021": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitLASTORE(this);\n  }\n",
    "172022": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitDASTORE(this);\n  }\n",
    "172024": "  public void accept(Visitor v) {\n    v.visitStackInstruction(this);\n    v.visitDUP_X1(this);\n  }\n",
    "172025": "    public void visitLDC(LDC o){\n        Constant c = cpg.getConstant(o.getIndex());\n        if (c instanceof ConstantInteger){\n            stack().push(Type.INT);\n        }\n        if (c instanceof ConstantFloat){\n            stack().push(Type.FLOAT);\n        }\n        if (c instanceof ConstantString){\n            stack().push(Type.STRING);\n        }\n    }\n",
    "172028": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitFCMPL(this);\n  }\n",
    "172030": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitLCMP(this);\n  }\n",
    "172032": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitI2F(this);\n  }\n",
    "172033": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitFLOAD(this);\n  }\n",
    "172035": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitINEG(this);\n  }\n",
    "172036": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitILOAD(this);\n  }\n",
    "172038": "    public void visitLDC_W(LDC_W o){\n        Constant c = cpg.getConstant(o.getIndex());\n        if (c instanceof ConstantInteger){\n            stack().push(Type.INT);\n        }\n        if (c instanceof ConstantFloat){\n            stack().push(Type.FLOAT);\n        }\n        if (c instanceof ConstantString){\n            stack().push(Type.STRING);\n        }\n    }\n",
    "172047": "    public void visitLDC2_W(LDC2_W o){\n        Constant c = cpg.getConstant(o.getIndex());\n        if (c instanceof ConstantLong){\n            stack().push(Type.LONG);\n        }\n        if (c instanceof ConstantDouble){\n            stack().push(Type.DOUBLE);\n        }\n    }\n",
    "172053": "    public void visitLDIV(LDIV o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172057": "    public void visitFCMPG(FCMPG o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172062": "    public void visitLLOAD(LLOAD o){\n        stack().push(locals().get(o.getIndex()));\n    }\n",
    "172065": "  public LineNumberGen addLineNumber(InstructionHandle ih, int src_line) {\n    LineNumberGen l = new LineNumberGen(ih, src_line);\n    line_number_vec.add(l);\n    return l;\n  }\n",
    "172068": "    public void visitLMUL(LMUL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172070": "  public void removeLineNumber(LineNumberGen l) {\n    line_number_vec.remove(l);  \n  }\n",
    "172071": "    public void visitFCMPL(FCMPL o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172074": "  public void removeLineNumbers() {\n    line_number_vec.clear();\n  }\n",
    "172076": "    public void visitLNEG(LNEG o){\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172079": "  public void accept(Visitor v) {\n    v.visitLoadClass(this);\n    v.visitExceptionThrower(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitCHECKCAST(this);\n  }\n",
    "172080": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitI2S(this);\n  }\n",
    "172083": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ACMPEQ(this);\n  }\n",
    "172084": "  public void accept(Visitor v) {\n    v.visitLoadClass(this);\n    v.visitAllocationInstruction(this);\n    v.visitExceptionThrower(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitANEWARRAY(this);\n  }\n",
    "172086": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitSALOAD(this);\n  }\n",
    "172087": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitStackInstruction(this);\n    v.visitDUP(this);\n  }\n",
    "172088": "    public void visitLOOKUPSWITCH(LOOKUPSWITCH o){\n        stack().pop(); //key\n    }\n",
    "172089": "    public void visitFCONST(FCONST o){\n        // nothing to do here.\n    }\n",
    "172091": "  public CodeException getCodeException(ConstantPoolGen cp) {\n    return new CodeException(start_pc.getPosition(),\n                 end_pc.getPosition() + end_pc.getInstruction().getLength(),\n                 handler_pc.getPosition(),\n                 (catch_type == null)? 0 : cp.addClass(catch_type));\n  }\n",
    "172097": "  public void removeExceptionHandler(CodeExceptionGen c) {\n    exception_vec.remove(c);  \n  }\n",
    "172099": "    public void visitLOR(LOR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172104": "  public void removeExceptionHandlers() {\n    exception_vec.clear();\n  }\n",
    "172107": "    public void visitFDIV(FDIV o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172108": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLOR(this);\n  }\n",
    "172109": "    public void visitLREM(LREM o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172110": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLUSHR(this);\n  }\n",
    "172111": "  public LocalVariable getLocalVariable(ConstantPoolGen cp) {\n    int start_pc        = start.getPosition();\n    int length          = end.getPosition() - start_pc;\n\n    if(length > 0)\n      length += end.getInstruction().getLength();\n    \n    int name_index      = cp.addUtf8(name);\n    int signature_index = cp.addUtf8(type.getSignature());\n\n    return new LocalVariable(start_pc, length, name_index,\n                 signature_index, index, cp.getConstantPool());\n  }\n",
    "172113": "  public void addException(String class_name) {\n    throws_vec.add(class_name);\n  }\n",
    "172118": "    public void visitLRETURN(LRETURN o){\n        stack().pop();\n    }\n",
    "172120": "  public void removeException(String c) {\n    throws_vec.remove(c);  \n  }\n",
    "172126": "    public void visitFLOAD(FLOAD o){\n        //visitLoadInstruction(LoadInstruction) is called before.\n        \n        // Nothing else needs to be done here.\n    }\n",
    "172127": "  public void removeExceptions() {\n    throws_vec.clear();  \n  }\n",
    "172129": "    public void visitLSHL(LSHL o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172136": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIF_ICMPNE(this);\n  }\n",
    "172137": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitLSTORE(this);\n  }\n",
    "172138": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIMUL(this);\n  }\n",
    "172139": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitIASTORE(this);\n  }\n",
    "172140": "    public void visitLSHR(LSHR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172141": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitLLOAD(this);\n  }\n",
    "172149": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitAALOAD(this);\n  }\n",
    "172150": "    public void visitFMUL(FMUL o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172153": "    public void visitLSTORE(LSTORE o){\n        locals().set(o.getIndex(), stack().pop());\n        locals().set(o.getIndex()+1, Type.UNKNOWN);        \n    }\n",
    "172155": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitFieldInstruction(this);\n    v.visitGETSTATIC(this);\n  }\n",
    "172156": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitD2I(this);\n  }\n",
    "172157": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n    out.writeByte(type);\n  }\n",
    "172160": "  public void accept(Visitor v) {\n    v.visitAllocationInstruction(this);\n    v.visitExceptionThrower(this);\n    v.visitStackProducer(this);\n    v.visitNEWARRAY(this);\n  }\n",
    "172161": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitStackConsumer(this);\n    v.visitMONITOREXIT(this);\n  }\n",
    "172164": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitFDIV(this);\n  }\n",
    "172165": "    public void visitLSUB(LSUB o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172166": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitDMUL(this);\n  }\n",
    "172167": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitLALOAD(this);\n  }\n",
    "172168": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitI2D(this);\n  }\n",
    "172170": "    public void visitFNEG(FNEG o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172171": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode); // Common for all instructions\n  }\n",
    "172173": "  public void removeNOPs() {\n    if(il != null) {\n      InstructionHandle next;\n      /* Check branch instructions.\n       */\n      for(InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n    next = ih.next;\n\n    if((next != null) && (ih.getInstruction() instanceof NOP)) {\n      try {\n        il.delete(ih);\n      } catch(TargetLostException e) {\n        InstructionHandle[] targets = e.getTargets();\n        \n        for(int i=0; i < targets.length; i++) {\n          InstructionTargeter[] targeters = targets[i].getTargeters();\n          \n          for(int j=0; j < targeters.length; j++)\n        targeters[j].updateTarget(targets[i], next);\n        }\n      }\n    }\n      }\n    }\n  }\n",
    "172174": "  public String toString(boolean verbose) {\n    if(verbose)\n      return getName() + \"[\" + opcode + \"](\" + length + \")\";\n    else\n      return getName();\n  }\n",
    "172177": "    public void visitLUSHR(LUSHR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172179": "  public Instruction copy() {\n    Instruction i = null;\n\n    // \"Constant\" instruction, no need to duplicate\n    if(InstructionConstants.INSTRUCTIONS[this.getOpcode()] != null)\n      i = this;\n    else {\n      try {\n    i = (Instruction)clone();\n      } catch(CloneNotSupportedException e) {\n    System.err.println(e);\n      }\n    }\n\n    return i;\n  }\n",
    "172181": "    public void visitFREM(FREM o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172182": "  public int consumeStack(ConstantPoolGen cpg) {\n    return Constants.CONSUME_STACK[opcode];\n  }\n",
    "172183": "  public void   setMaxLocals(int m)  { max_locals = m; }\n",
    "172184": "  public int produceStack(ConstantPoolGen cpg) {\n    return Constants.PRODUCE_STACK[opcode];\n  }\n",
    "172188": "    public void visitLXOR(LXOR o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.LONG);\n    }\n",
    "172190": "  public boolean equals(Object that) {\n    return (that instanceof Instruction)?\n      cmp.equals(this, (Instruction)that) : false;\n  }\n",
    "172191": "  public void   setMaxStack(int m)  { max_stack = m; }\n",
    "172193": "    public void visitFRETURN(FRETURN o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172194": "  public void accept(Visitor v) {\n    v.visitLoadClass(this);\n    v.visitExceptionThrower(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitINSTANCEOF(this);\n  }\n",
    "172195": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitDNEG(this);\n  }\n",
    "172198": "    public void visitMONITORENTER(MONITORENTER o){\n        stack().pop();\n    }\n",
    "172202": "    public void visitFSTORE(FSTORE o){\n        //visitStoreInstruction(StoreInstruction) is called before.\n        \n        // Nothing else needs to be done here.\n    }\n",
    "172204": "    public void visitMONITOREXIT(MONITOREXIT o){\n        stack().pop();\n    }\n",
    "172206": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitFADD(this);\n  }\n",
    "172207": "  public void dump(DataOutputStream out) throws IOException {\n    if(wide) // Need WIDE prefix ?\n      out.writeByte(de.uka.ipd.coverage.org.apache.bcel.Constants.WIDE);\n\n    out.writeByte(opcode);\n\n    if(wide) {\n      out.writeShort(n);\n      out.writeShort(c);\n    } else {\n      out.writeByte(n);\n      out.writeByte(c);\n    }\n  }\n",
    "172211": "  public void accept(Visitor v) {\n    v.visitLocalVariableInstruction(this);\n    v.visitIINC(this);\n  }\n",
    "172213": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitFMUL(this);\n  }\n",
    "172214": "  public void accept(Visitor v) {\n    v.visitStackInstruction(this);\n    v.visitDUP_X2(this);\n  }\n",
    "172215": "    public void visitMULTIANEWARRAY(MULTIANEWARRAY o){\n        for (int i=0; i<o.getDimensions(); i++){\n            stack().pop();\n        }\n        stack().push(o.getType(cpg));\n    }\n",
    "172217": "  public Instruction swapInstruction(Instruction i) {\n    Instruction oldInstruction = instruction;\n    instruction = i;\n    return oldInstruction;\n  }\n",
    "172218": "  protected int updatePosition(int offset, int max_offset) {\n    i_position += offset;\n    return 0;\n  }\n",
    "172221": "    public void visitFSUB(FSUB o){\n        if (stack().peek() != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack top is not of type 'float', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.FLOAT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'float', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172223": "    public void visitNEW(NEW o){\n        stack().push(new UninitializedObjectType((ObjectType) (o.getType(cpg))));\n    }\n",
    "172224": "  public void removeAllTargeters() {\n    if(targeters != null)\n      targeters.clear();\n  }\n",
    "172225": "  public void removeTargeter(InstructionTargeter t) {\n    targeters.remove(t);\n  }\n",
    "172226": "  public void addTargeter(InstructionTargeter t) {\n    if(targeters == null)\n      targeters = new HashSet();\n\n    //if(!targeters.contains(t))\n    targeters.add(t);\n  }\n",
    "172231": "    public void visitNEWARRAY(NEWARRAY o){\n        stack().pop();\n        stack().push(o.getType());\n    }\n",
    "172232": "  public void addAttribute(Object key, Object attr) {\n    if(attributes == null)\n      attributes = new HashMap(3);\n    \n    attributes.put(key, attr);\n  }\n",
    "172233": "  public void removeAttribute(Object key) {\n    if(attributes != null)\n      attributes.remove(key);\n  }\n",
    "172235": "  public Object getAttribute(Object key) {\n    if(attributes != null)\n      return attributes.get(key);\n\n    return null;\n  }\n",
    "172238": "  public void accept(Visitor v) {\n    instruction.accept(v);\n  }\n",
    "172240": "    public void visitNOP(NOP o){\n    }\n",
    "172244": "  public boolean referencesClass(){\n    JavaClass jc = Repository.lookupClass(class_name);\n    if (jc == null)\n      return false;\n    else\n      return jc.isClass();\n  }\n",
    "172245": "  public boolean referencesInterface(){\n    JavaClass jc = Repository.lookupClass(class_name);\n    if (jc == null)\n      return false;\n    else\n      return !jc.isClass();\n  }\n",
    "172247": "  public boolean accessibleTo(ObjectType accessor) {\n    JavaClass jc = Repository.lookupClass(class_name);\n\n    if(jc.isPublic()) {\n      return true;\n    } else {\n      JavaClass acc = Repository.lookupClass(accessor.class_name);\n      return acc.getPackageName().equals(jc.getPackageName());\n    }\n  }\n",
    "172248": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIDIV(this);\n  }\n",
    "172249": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitISUB(this);\n  }\n",
    "172251": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n\n    if(length == 2)\n      out.writeByte(index);\n    else // Applies for LDC_W\n      out.writeShort(index);\n  }\n",
    "172253": "    public void visitPOP(POP o){\n        stack().pop();\n    }\n",
    "172257": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitLDC(this);\n  }\n",
    "172258": "  public void accept(Visitor v) {\n    v.visitNOP(this);\n  }\n",
    "172260": "    public void visitGETSTATIC(GETSTATIC o){\n        // Field must be static: see Pass 3a.\n    }\n",
    "172263": "  public void accept(Visitor v) {\n    v.visitPushInstruction(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitConstantPushInstruction(this);\n    v.visitDCONST(this);\n  }\n",
    "172265": "    public void visitPOP2(POP2 o){\n        Type t = stack().pop();\n        if (t.getSize() == 1){\n            stack().pop();\n        }        \n    }\n",
    "172266": "  protected void addHandle() {\n    next    = bh_list;\n    bh_list = this;\n  }\n",
    "172269": "  public void setTarget(InstructionHandle ih) {\n    bi.setTarget(ih);\n  }\n",
    "172270": "  public void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) {\n    bi.updateTarget(old_ih, new_ih);\n  }\n",
    "172273": "  public void setInstruction(Instruction i) {\n    super.setInstruction(i);\n\n    if(!(i instanceof BranchInstruction))\n      throw new ClassGenException(\"Assigning \" + i +\n                  \" to branch handle which is not a branch instruction\");\n\n    bi = (BranchInstruction)i;\n  }\n",
    "172274": "  public void accept(Visitor v) {\n    v.visitStackInstruction(this);\n    v.visitDUP2_X2(this);\n  }\n",
    "172277": "    public void visitPUTFIELD(PUTFIELD o){\n        stack().pop();\n        stack().pop();\n    }\n",
    "172278": "  public void accept(Visitor v) {\n    v.visitPushInstruction(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitConstantPushInstruction(this);\n    v.visitLCONST(this);\n  }\n",
    "172281": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitDADD(this);\n  }\n",
    "172282": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLSHR(this);\n  }\n",
    "172283": "  protected int updatePosition(int offset, int max_offset) {\n    position += offset; // Additional offset caused by preceding SWITCHs, GOTOs, etc.\n\n    short old_length = length;\n\n    /* Alignment on 4-byte-boundary, + 1, because of tag byte.\n     */\n    padding = (4 - ((position + 1) % 4)) % 4;\n    length  = (short)(fixed_length + padding); // Update length\n\n    return length - old_length;\n  }\n",
    "172284": "    public void visitGOTO(GOTO o){\n        // nothing to do here.\n    }\n",
    "172285": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n\n    for(int i=0; i < padding; i++) // Padding bytes\n      out.writeByte(0);\n\n    index = getTargetOffset();     // Write default target offset\n    out.writeInt(index);\n  }\n",
    "172287": "    public void visitPUTSTATIC(PUTSTATIC o){\n        stack().pop();\n    }\n",
    "172290": "  public void setTarget(int i, InstructionHandle target) {\n    notifyTarget(targets[i], target, this);\n    targets[i] = target;\n  }\n",
    "172293": "  public void accept(Visitor v) {\n    v.visitBREAKPOINT(this);\n  }\n",
    "172294": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitFREM(this);\n  }\n",
    "172296": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitStackInstruction(this);\n    v.visitDUP2(this);\n  }\n",
    "172297": "    public void visitRET(RET o){\n        // do nothing, return address\n        // is in in the local variables.\n    }\n",
    "172298": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitReturnInstruction(this);\n    v.visitDRETURN(this);\n  }\n",
    "172299": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitDSTORE(this);\n  }\n",
    "172300": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIXOR(this);\n  }\n",
    "172301": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLNEG(this);\n  }\n",
    "172303": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitTypedInstruction(this);\n    v.visitACONST_NULL(this);\n  }\n",
    "172304": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitDREM(this);\n  }\n",
    "172305": "  public void setMaxLocals() {\n    if(il != null) {\n      int max = isStatic()? 0 : 1;\n\n      if(arg_types != null)\n    for(int i=0; i < arg_types.length; i++)\n      max += arg_types[i].getSize();\n\n      for(InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {\n    Instruction ins = ih.getInstruction();\n\n    if((ins instanceof LocalVariableInstruction) ||\n       (ins instanceof RET) || (ins instanceof IINC))\n    {\n      int index = ((IndexedInstruction)ins).getIndex() +\n        ((TypedInstruction)ins).getType(cp).getSize();\n\n      if(index > max)\n        max = index;\n    }\n      }\n\n      max_locals = max;\n    } else\n      max_locals = 0;\n  }\n",
    "172306": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLDIV(this);\n  }\n",
    "172307": "    public void visitGOTO_W(GOTO_W o){\n        // nothing to do here.\n    }\n",
    "172308": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLADD(this);\n  }\n",
    "172309": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitStackConsumer(this);\n    v.visitMONITORENTER(this);\n  }\n",
    "172311": "    public void visitRETURN(RETURN o){\n        // do nothing.\n    }\n",
    "172313": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitPushInstruction(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitLDC2_W(this);\n  }\n",
    "172315": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitStackConsumer(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitFieldInstruction(this);\n    v.visitGETFIELD(this);\n  }\n",
    "172317": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitDALOAD(this);\n  }\n",
    "172318": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIREM(this);\n  }\n",
    "172325": "    public void visitSALOAD(SALOAD o){\n        stack().pop();\n        stack().pop();\n        stack().push(Type.INT);\n    }\n",
    "172331": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitLXOR(this);\n  }\n",
    "172332": "  public boolean equals(Object rat){\n    if(!(rat instanceof ReturnaddressType))\n      return false;\n\n    return ((ReturnaddressType)rat).returnTarget.equals(this.returnTarget);\n  }    \n",
    "172335": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitBranchInstruction(this);\n    v.visitIfInstruction(this);\n    v.visitIFLT(this);\n  }\n",
    "172337": "    public void visitI2B(I2B o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172338": "  public int consumeStack(ConstantPoolGen cpg) {\n      String signature = getSignature(cpg);\n      Type[] args      = Type.getArgumentTypes(signature);\n      int    sum;\n\n      if(opcode == Constants.INVOKESTATIC)\n    sum = 0;\n      else\n    sum = 1;  // this reference\n\n      int n = args.length;\n      for (int i = 0; i < n; i++)\n    sum += args[i].getSize();\n\n      return sum;\n   }\n",
    "172340": "    public void visitSASTORE(SASTORE o){\n        stack().pop();\n        stack().pop();\n        stack().pop();\n    }\n",
    "172341": "  public int produceStack(ConstantPoolGen cpg) {\n    return getReturnType(cpg).getSize();\n  }\n",
    "172345": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitArrayInstruction(this);\n    v.visitCALOAD(this);\n  }\n",
    "172346": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitDDIV(this);\n  }\n",
    "172347": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitStackConsumer(this);\n    v.visitReturnInstruction(this);\n    v.visitRETURN(this);\n  }\n",
    "172348": "  public void addObserver(MethodObserver o) {\n    if(observers == null)\n      observers = new ArrayList();\n\n    observers.add(o);\n  }\n",
    "172349": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIAND(this);\n  }\n",
    "172351": "  public void accept(Visitor v) {\n    v.visitExceptionThrower(this);\n    v.visitStackConsumer(this);\n    v.visitPopInstruction(this);\n    v.visitTypedInstruction(this);\n    v.visitLoadClass(this);\n    v.visitCPInstruction(this);\n    v.visitFieldOrMethod(this);\n    v.visitFieldInstruction(this);\n    v.visitPUTSTATIC(this);\n  }\n",
    "172352": "    public void visitSIPUSH(SIPUSH o){\n        stack().push(Type.INT);\n    }\n",
    "172353": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitL2F(this);\n  }\n",
    "172354": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitStackProducer(this);\n    v.visitStackInstruction(this);\n    v.visitSWAP(this);\n  }\n",
    "172355": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitL2I(this);\n  }\n",
    "172356": "  public void removeObserver(MethodObserver o) {\n    if(observers != null)\n      observers.remove(o);\n  }\n",
    "172357": "    public void visitI2C(I2C o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172358": "    public void visitSWAP(SWAP o){\n        Type t = stack().pop();\n        Type u = stack().pop();\n        stack().push(t);\n        stack().push(u);\n    }\n",
    "172359": "  public void update() {\n    if(observers != null)\n      for(Iterator e = observers.iterator(); e.hasNext(); )\n    ((MethodObserver)e.next()).notify(this);\n  }\n",
    "172360": "    public void visitTABLESWITCH(TABLESWITCH o){\n        stack().pop();\n    }\n",
    "172363": "  public void accept(Visitor v) {\n    v.visitStackConsumer(this);\n    v.visitPopInstruction(this);\n    v.visitStackInstruction(this);\n    v.visitPOP(this);\n  }\n",
    "172364": "  public void accept(Visitor v) {\n    v.visitLoadClass(this);\n    v.visitAllocationInstruction(this);\n    v.visitExceptionThrower(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitNEW(this);\n  }\n",
    "172365": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitIOR(this);\n  }\n",
    "172368": "  public void accept(Visitor v) {\n    v.visitStackProducer(this);\n    v.visitBranchInstruction(this);\n    v.visitJsrInstruction(this);\n    v.visitJSR_W(this);\n  }\n",
    "172369": "  public void dump(DataOutputStream out) throws IOException {\n    index = getTargetOffset();\n    if(opcode == de.uka.ipd.coverage.org.apache.bcel.Constants.GOTO)\n      super.dump(out);\n    else { // GOTO_W\n      index = getTargetOffset();\n      out.writeByte(opcode);\n      out.writeInt(index);\n    }\n  }\n",
    "172370": "  protected int updatePosition(int offset, int max_offset) {\n    int i = getTargetOffset(); // Depending on old position value\n\n    position += offset; // Position may be shifted by preceding expansions\n\n    if(Math.abs(i) >= (32767 - max_offset)) { // to large for short (estimate)\n      opcode = de.uka.ipd.coverage.org.apache.bcel.Constants.GOTO_W;\n      length = 5;\n      return 2; // 5 - 3\n    }\n\n    return 0;\n  }\n",
    "172371": "    public void visitI2D(I2D o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172372": "  public void accept(Visitor v) {\n    v.visitVariableLengthInstruction(this);\n    v.visitUnconditionalBranch(this);\n    v.visitBranchInstruction(this);\n    v.visitGotoInstruction(this);\n    v.visitGOTO(this);\n  }\n",
    "172374": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitArithmeticInstruction(this);\n    v.visitFNEG(this);\n  }\n",
    "172375": "  public void accept(Visitor v) {\n    super.accept(v);\n    v.visitFSTORE(this);\n  }\n",
    "172376": "  public void dump(DataOutputStream out) throws IOException {\n    out.writeByte(opcode);\n    out.writeShort(index);\n    out.writeByte(dimensions);\n  }\n",
    "172377": "  public InstructionHandle findHandle(int pos) {\n    InstructionHandle[] ihs = getInstructionHandles();\n    return findHandle(ihs, byte_positions, length, pos);\n  }\n",
    "172380": "  public void accept(Visitor v) {\n    v.visitTypedInstruction(this);\n    v.visitStackProducer(this);\n    v.visitStackConsumer(this);\n    v.visitConversionInstruction(this);\n    v.visitF2L(this);\n  }\n",
    "172385": "  public InstructionHandle append(InstructionHandle ih, InstructionList il) {\n    if(il == null)\n      throw new ClassGenException(\"Appending null InstructionList\");\n\n    if(il.isEmpty()) // Nothing to do\n      return ih;\n\n    InstructionHandle next = ih.next, ret = il.start;\n\n    ih.next = il.start;\n    il.start.prev = ih;\n\n    il.end.next = next;\n\n    if(next != null) // i == end ?\n      next.prev = il.end;\n    else\n      end = il.end; // Update end ...\n\n    length += il.length; // Update length\n\n    il.clear();\n\n    return ret;\n  }\n",
    "172386": "  public void accept(Visitor v) {\n    v.visitPushInstruction(this);\n    v.visitStackProducer(this);\n    v.visitTypedInstruction(this);\n    v.visitConstantPushInstruction(this);\n    v.visitFCONST(this);\n  }\n",
    "172396": "  public void accept(Visitor v) {\n    v.visitLoadClass(this);\n    v.visitAllocationInstruction(this);\n    v.visitExceptionThrower(this);\n    v.visitTypedInstruction(this);\n    v.visitCPInstruction(this);\n    v.visitMULTIANEWARRAY(this);\n  }\n",
    "172406": "  public InstructionHandle append(Instruction i, InstructionList il) {\n    InstructionHandle ih;\n\n    if((ih = findInstruction2(i)) == null) // Also applies for empty list\n      throw new ClassGenException(\"Instruction \" + i +\n                  \" is not contained in this list.\");\n\n    return append(ih, il);\n  }\n",
    "172420": "  public InstructionHandle append(InstructionList il) {\n    if(il == null)\n      throw new ClassGenException(\"Appending null InstructionList\");\n\n    if(il.isEmpty()) // Nothing to do\n      return null;\n\n    if(isEmpty()) {\n      start  = il.start;\n      end    = il.end;\n      length = il.length;\n\n      il.clear();\n\n      return start;\n    } else\n      return append(end, il);  // was end.instruction\n  }\n",
    "172425": "    public void visitI2F(I2F o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172452": "  private void append(InstructionHandle ih) {\n    if(isEmpty()) {\n      start = end = ih;\n      ih.next = ih.prev = null;\n    }\n    else {\n      end.next = ih;\n      ih.prev  = end;\n      ih.next  = null;\n      end      = ih;\n    }\n    \n    length++; // Update length\n  }\n",
    "172477": "  public InstructionHandle append(Instruction i) {\n    InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n    append(ih);\n\n    return ih;\n  }\n",
    "172484": "    public void visitI2L(I2L o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172491": "  public BranchHandle append(BranchInstruction i) {\n    BranchHandle ih = BranchHandle.getBranchHandle(i);\n    append(ih);\n\n    return ih;\n  }\n",
    "172506": "  public InstructionHandle append(Instruction i, Instruction j) {\n    return append(i, new InstructionList(j)); \n  }\n",
    "172521": "  public InstructionHandle append(Instruction i, CompoundInstruction c) { \n    return append(i, c.getInstructionList()); \n  }\n",
    "172527": "    private List getSourceLineNumbers(List byteCodePositions) {\n        LineNumberTable lnt = this.dfp.getRegisteredMethodDeprecated().getMethod().getLineNumberTable();\n        List result = new ArrayList(byteCodePositions.size());\n        for (Iterator iter = byteCodePositions.iterator(); iter.hasNext();) {\n            Integer byteCodePos = (Integer) iter.next();\n            int sourcecodeLine = lnt.getSourceLine(byteCodePos.intValue());\n            result.add(new Integer(sourcecodeLine));\n        }\n        return result;\n    }\n",
    "172530": "  public InstructionHandle append(CompoundInstruction c) {\n    return append(c.getInstructionList()); \n  }\n",
    "172540": "    public void removeUnnecessaryBlocks(Integer index) {\n        while(enteredBlocks.size() > 1 &&\n                !(containsLoad(getLastSSABasicBlockWrapper(),\n                    index,\n                    enteredBlocks.size() == 1))) {\n            enteredBlocks.removeLast();\n        }\n    }\n",
    "172541": "  public InstructionHandle append(InstructionHandle ih, CompoundInstruction c) {\n    return append(ih, c.getInstructionList()); \n  }\n",
    "172542": "    public void visitI2S(I2S o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172549": "  public InstructionHandle append(InstructionHandle ih, Instruction i) {\n    return append(ih, new InstructionList(i));\n  }\n",
    "172554": "    private void removeDuplicates(List definitionFreePaths) {\n        // put all elements in a hashmap.\n        // then use the keyset as definitionFreePath list.\n        Map map = new HashMap();\n        for (Iterator iter = definitionFreePaths.iterator(); iter.hasNext();) {\n            Object element = iter.next();\n            map.put(element, element);\n        }\n        definitionFreePaths.clear();\n        for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {\n            DefinitionFreePath element = (DefinitionFreePath) iter.next();\n            definitionFreePaths.add(element);\n        }\n    }\n",
    "172556": "  public BranchHandle append(InstructionHandle ih, BranchInstruction i) {\n    BranchHandle    bh = BranchHandle.getBranchHandle(i);\n    InstructionList il = new InstructionList();\n    il.append(bh);\n\n    append(ih, il);\n\n    return bh;\n  }\n",
    "172561": "  public InstructionHandle insert(InstructionHandle ih, InstructionList il) {\n    if(il == null)\n      throw new ClassGenException(\"Inserting null InstructionList\");\n\n    if(il.isEmpty()) // Nothing to do\n      return ih;\n\n    InstructionHandle prev = ih.prev, ret = il.start;\n\n    ih.prev = il.end;\n    il.end.next = ih;\n\n    il.start.prev = prev;\n\n    if(prev != null) // ih == start ?\n      prev.next = il.start;\n    else\n      start = il.start; // Update start ...\n\n    length += il.length; // Update length\n\n    il.clear();\n\n    return ret;\n  }\n",
    "172565": "    private List getDefinedVariableSSAIndices(SsaBasicBlockWrapper wrapper) {\n//        InstructionHandle[] handles = wrapper.getInstructionHandles();\n        List indices = new ArrayList();\n//        for (int i = 0; i < handles.length; i++) {\n//            if (handles[i].getInstruction() instanceof StoreInstruction) {\n//                StoreInstruction store = \n//                    (StoreInstruction) handles[i].getInstruction();\n////                List keys = wrapper.getKeys(new Integer(store.getIndex()));\n//                assert keys.size() < 2 : \" Es gibt tatsaechlich mehr als 2 Eintraege fuer einen value\"; //$NON-NLS-1$\n//                indices.addAll(keys);\n//            }\n//        }\n        return indices;\n    }\n",
    "172568": "  public InstructionHandle insert(InstructionList il) {\n    if(isEmpty()) {\n      append(il); // Code is identical for this case\n      return start;\n    }\n    else\n      return insert(start, il); \n  }\n",
    "172569": "    public void visitIADD(IADD o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172574": "  private void insert(InstructionHandle ih) {\n    if(isEmpty()) {\n      start = end = ih;\n      ih.next = ih.prev = null;\n    } else {\n      start.prev = ih;\n      ih.next    = start;\n      ih.prev    = null;\n      start      = ih;\n    }\n\n    length++;\n  }\n",
    "172579": "  public InstructionHandle insert(Instruction i, InstructionList il) {\n    InstructionHandle ih;\n\n    if((ih = findInstruction1(i)) == null)\n      throw new ClassGenException(\"Instruction \" + i +\n                  \" is not contained in this list.\");\n    \n    return insert(ih, il);\n  }\n",
    "172584": "  public InstructionHandle insert(Instruction i) {\n    InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n    insert(ih);\n\n    return ih;\n  }\n",
    "172585": "    public boolean hasSameDefinitionAs(DefinitionFreePath dfp) {\n        return getDefinition().equals(dfp.getDefinition());\n    }\n",
    "172590": "  public BranchHandle insert(BranchInstruction i) {\n    BranchHandle ih = BranchHandle.getBranchHandle(i);\n    insert(ih);\n    return ih;\n  }\n",
    "172592": "    public void visitIALOAD(IALOAD o){\n        indexOfInt(o, stack().peek());\n        if (stack().peek(1) == Type.NULL){\n            return;\n        } \n        if (! (stack().peek(1) instanceof ArrayType)){\n            constraintViolated(o, \"Stack next-to-top must be of type int[] but is '\"+stack().peek(1)+\"'.\");\n        }\n        Type t = ((ArrayType) (stack().peek(1))).getBasicType();\n        if (t != Type.INT){\n            constraintViolated(o, \"Stack next-to-top must be of type int[] but is '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172595": "    public void triggerFinished() {\n        this.finished = true;\n    }\n",
    "172596": "  public InstructionHandle insert(Instruction i, Instruction j) {\n    return insert(i, new InstructionList(j));\n  }\n",
    "172607": "  public InstructionHandle insert(Instruction i, CompoundInstruction c) { \n    return insert(i, c.getInstructionList()); \n  }\n",
    "172611": "    protected void generateSSACompatibleForm() {\n        InstructionList il = methodGen.getInstructionList();\n        replaceIINCInstructions(il);\n        replaceFieldsWithLocalVariables(il);\n        setArgumentStores(il);\n    }\n",
    "172613": "  public InstructionHandle insert(CompoundInstruction c) {\n    return insert(c.getInstructionList()); \n  }\n",
    "172619": "  public InstructionHandle insert(InstructionHandle ih, Instruction i) {\n    return insert(ih, new InstructionList(i));\n  }\n",
    "172620": "    public void visitIAND(IAND o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172626": "  public InstructionHandle insert(InstructionHandle ih, CompoundInstruction c) {\n    return insert(ih, c.getInstructionList()); \n  }\n",
    "172631": "  public BranchHandle insert(InstructionHandle ih, BranchInstruction i) {\n    BranchHandle    bh = BranchHandle.getBranchHandle(i);\n    InstructionList il = new InstructionList();\n    il.append(bh);\n\n    insert(ih, il);\n\n    return bh;\n  }\n",
    "172634": "    public void tryFinishing() {\n        SsaBasicBlockWrapper[] preds = getPredecessorWrappers();\n        if (isPredecessorsInSSAForm(preds)) {\n            InstructionHandle runningHandle = blockFirstHandle;\n            while (runningHandle != blockLastHandle.getNext()) {\n                if (runningHandle.getInstruction() instanceof PhiDashFunction\n                        && !(runningHandle.getInstruction() instanceof PhiFunction)) {\n                    PhiFunction phiF = new PhiFunction(\n                            (PhiDashFunction) runningHandle.getInstruction());\n                    for (int i = 0; i < preds.length; i++) {\n                        phiF.addPredecessorIndex(preds[i].getSSAIndex(phiF\n                                .getOriginalIndex()));\n                    }\n                    runningHandle.setInstruction(phiF);\n                }\n                runningHandle = runningHandle.getNext();\n            }\n        }\n    }\n",
    "172642": "  public void move(InstructionHandle ih, InstructionHandle target) {\n    move(ih, ih, target);\n  }\n",
    "172666": "  public void delete(InstructionHandle ih) throws TargetLostException {\n    remove(ih.prev, ih.next);\n  }\n",
    "172675": "  public void delete(Instruction i) throws TargetLostException {\n    InstructionHandle ih;\n\n    if((ih = findInstruction1(i)) == null)\n      throw new ClassGenException(\"Instruction \" + i +\n                  \" is not contained in this list.\");\n    delete(ih);\n  }\n",
    "172676": "    public void visitICONST(ICONST o){\n        //nothing to do here.\n    }\n",
    "172696": "    private LocalVariableGen createLocalVariableAsFieldReplacement(FieldInstruction inst) {\n        ConstantPoolGen cpg = methodGen.getConstantPool();\n        LocalVariableGen lvar = methodGen\n                .addLocalVariable(\"ssaReplacementForField \"  //$NON-NLS-1$\n                                  + inst.getFieldName(cpg) + \"[\" //$NON-NLS-1$\n                                  + inst.getIndex() + \"]\", //$NON-NLS-1$\n                                  inst.getType(cpg),\n                                  methodGen.getInstructionList().getStart(),\n                                  methodGen.getInstructionList().getEnd());\n        return lvar;\n    }\n",
    "172698": "  public void delete(Instruction from, Instruction to) throws TargetLostException {\n    InstructionHandle from_ih, to_ih;\n\n    if((from_ih = findInstruction1(from)) == null)\n      throw new ClassGenException(\"Instruction \" + from +\n                  \" is not contained in this list.\");\n\n    if((to_ih = findInstruction2(to)) == null)\n      throw new ClassGenException(\"Instruction \" + to +\n                  \" is not contained in this list.\");\n    delete(from_ih, to_ih);\n  }\n",
    "172705": "  private InstructionHandle findInstruction1(Instruction i) {\n    for(InstructionHandle ih=start; ih != null; ih = ih.next)\n      if(ih.instruction == i)\n    return ih;\n\n    return null;\n  }\n",
    "172711": "    public void visitIDIV(IDIV o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172714": "  private InstructionHandle findInstruction2(Instruction i) {\n    for(InstructionHandle ih=end; ih != null; ih = ih.prev)\n      if(ih.instruction == i)\n    return ih;\n\n    return null;\n  }\n",
    "172728": "    public void visitIF_ACMPEQ(IF_ACMPEQ o){\n        if (!(stack().peek() instanceof ReferenceType)){\n            constraintViolated(o, \"The value at the stack top is not of a ReferenceType, but of type '\"+stack().peek()+\"'.\");\n        }\n        referenceTypeIsInitialized(o, (ReferenceType) (stack().peek()) );\n    \n        if (!(stack().peek(1) instanceof ReferenceType)){\n            constraintViolated(o, \"The value at the stack next-to-top is not of a ReferenceType, but of type '\"+stack().peek(1)+\"'.\");\n        }\n        referenceTypeIsInitialized(o, (ReferenceType) (stack().peek(1)) );\n        \n    }\n",
    "172743": "    public void visitIF_ACMPNE(IF_ACMPNE o){\n        if (!(stack().peek() instanceof ReferenceType)){\n            constraintViolated(o, \"The value at the stack top is not of a ReferenceType, but of type '\"+stack().peek()+\"'.\");\n            referenceTypeIsInitialized(o, (ReferenceType) (stack().peek()) );\n        }\n        if (!(stack().peek(1) instanceof ReferenceType)){\n            constraintViolated(o, \"The value at the stack next-to-top is not of a ReferenceType, but of type '\"+stack().peek(1)+\"'.\");\n            referenceTypeIsInitialized(o, (ReferenceType) (stack().peek(1)) );\n        }\n    }\n",
    "172759": "    public void computeWithHighPriority( JavaClass jc ) {\n        synchronized( getThreadPool() ) {\n            synchronized( jc ) {\n                TestedClassEvaluation orig = ( TestedClassEvaluation )this.tcs.get( jc );\n                if( orig == null || orig.getTestedClass().hasCompleteCoverage() ) {\n                    //already evaluated\n                    return;\n                }\n                TestedClassEvaluation tce = ( TestedClassEvaluation )orig.clone();\n                tce.setHighPriority();\n                getThreadPool().execute( tce );\n                boolean interrupted = true;\n                while( interrupted ) { \n                    try {\n                        jc.wait();\n                        interrupted = false;\n                    } catch( InterruptedException e ) {\n                        interrupted = true;\n                    }\n                }\n            }\n        }\n    }\n",
    "172760": "    public boolean add(Object item) {\n        if (!contains(item)) {\n            return super.add(item);\n        }\n        return false;\n    }\n",
    "172777": "    public void startTiming(String name) {\n        long startTime = Calendar.getInstance().getTimeInMillis();\n        this.currentlyTiming.put(name, new Long(startTime)); \n    }\n",
    "172779": "    public void visitIF_ICMPEQ(IF_ICMPEQ o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172780": "    public void stopTiming(String name) {\n        long stopTime = Calendar.getInstance().getTimeInMillis();\n        if (currentlyTiming.containsKey(name)) {\n            Long startTimeL = (Long) this.currentlyTiming.get(name);\n            long resultingTime = stopTime - startTimeL.longValue();\n            this.timedObjects.put(name, new Long(resultingTime));\n        }\n    }\n",
    "172783": "    public void printTimedObjects() {\n        System.out.println(this.timedObjects.size() + \" Objects timed: \");\n        for (Iterator iter = this.timedObjects.keySet().iterator(); iter.hasNext();) {\n            String element = (String) iter.next();\n            Long key = (Long) this.timedObjects.get(element);\n            System.out.println(element + \": \" + key + \"ms\");\n        }\n    }\n",
    "172787": "    public void killMeasurements() {\n        this.timedObjects = new HashMap();\n    }\n",
    "172817": "    public void visitIF_ICMPGE(IF_ICMPGE o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172820": "    protected void initializeJavaProject(IJavaElement javaElement, ILaunchConfigurationWorkingCopy config) {\n        IJavaProject javaProject = javaElement.getJavaProject();\n        String name = null;\n        if (javaProject != null && javaProject.exists()) {\n            name = javaProject.getElementName();\n        }\n        config.setAttribute(IJavaLaunchConfigurationConstants.ATTR_PROJECT_NAME, name);\n    }\n",
    "172843": "    protected IType chooseType(IType[] types, String mode) {\n        ElementListSelectionDialog dialog= new ElementListSelectionDialog(getShell(), new JavaElementLabelProvider(JavaElementLabelProvider.SHOW_POST_QUALIFIED));\n        dialog.setElements(types);\n        dialog.setTitle(\"\"); //$NON-NLS-1$\n        if (mode.equals(ILaunchManager.DEBUG_MODE)) {\n            dialog.setMessage(\"\");  //$NON-NLS-1$\n        } else {\n            dialog.setMessage(\"\"); //$NON-NLS-1$\n        }\n        dialog.setMultipleSelection(false);\n        if (dialog.open() == Window.OK) {\n            return (IType)dialog.getFirstResult();\n        }\n        return null;\n    }\n",
    "172847": "    public void visitIF_ICMPGT(IF_ICMPGT o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172866": "    protected ILaunchConfigurationType getJUnitLaunchConfigType() {\n        ILaunchManager lm= DebugPlugin.getDefault().getLaunchManager();\n        return lm.getLaunchConfigurationType(CoverageLaunchConfigurationDelegate.COVERAGE_LAUNCH_CONFIGURATION_ID);        \n    }    \n",
    "172876": "  public void replaceConstantPool(ConstantPoolGen old_cp, ConstantPoolGen new_cp) {\n    for(InstructionHandle ih=start; ih != null; ih = ih.next) {\n      Instruction i = ih.instruction;\n\n      if(i instanceof CPInstruction) {\n    CPInstruction ci = (CPInstruction)i;\n    Constant      c  = old_cp.getConstant(ci.getIndex());\n    ci.setIndex(new_cp.addConstant(c, old_cp));\n      }\n    }    \n  }\n",
    "172881": "    protected Shell getShell() {\n        return Display.getDefault().getActiveShell();\n    }\n",
    "172886": "    public void visitIF_ICMPLE(IF_ICMPLE o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172911": "  public void dispose() {\n    // Traverse in reverse order, because ih.next is overwritten\n    for(InstructionHandle ih=end; ih != null; ih = ih.prev)\n      /* Causes BranchInstructions to release target and targeters, because it\n       * calls dispose() on the contained instruction.\n       */\n      ih.dispose();\n\n    clear();\n  }\n",
    "172918": "    public void visitIF_ICMPLT(IF_ICMPLT o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172946": "    public void visitIF_ICMPNE(IF_ICMPNE o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "172967": "    public void visitIFEQ(IFEQ o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "172989": "    public void visitIFGE(IFGE o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173011": "  public void addObserver(InstructionListObserver o) {\n    if(observers == null)\n      observers = new ArrayList();\n\n    observers.add(o);\n  }\n",
    "173016": "    public void visitIFGT(IFGT o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173021": "  public void removeObserver(InstructionListObserver o) {\n    if(observers != null)\n      observers.remove(o);\n  }\n",
    "173029": "  public void update() {\n    if(observers != null)\n      for(Iterator e = observers.iterator(); e.hasNext(); )\n    ((InstructionListObserver)e.next()).notify(this);\n  }\n",
    "173031": "    public void visitIFLE(IFLE o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173058": "    public void clearCache() {\n        for (int i = 0; i < markers.length; i++) {\n            ConcreteMarker marker = markers[i];\n            \n            marker.clearCache();\n        }\n        \n        markerTable = null;\n    }\n",
    "173059": "    private Map getMarkerMap() {\n        if (markerTable == null) {\n            markerTable = new HashMap();\n            \n            for (int idx = 0; idx < markers.length; idx++) {\n                ConcreteMarker marker = markers[idx];\n                markerTable.put(marker.getMarker(), marker);\n            }\n        }\n        \n        return markerTable;\n    }\n",
    "173061": "    public ConcreteMarker getMarker(IMarker toFind) {\n        return (ConcreteMarker) getMarkerMap().get(toFind);\n    }\n",
    "173064": "    public void visitIFLT(IFLT o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173069": "    //public Collection getMarkers() {\n    //    return markers;\n    //}\n",
    "173071": "    public int getItemCount() {\n        return markers.length;\n    }\n",
    "173073": "    public int getErrors() {\n        return getMarkerCounts()[IMarker.SEVERITY_ERROR];\n    }\n",
    "173075": "    public int getInfos() {\n        return getMarkerCounts()[IMarker.SEVERITY_INFO];\n    }\n",
    "173081": "    public int getWarnings() {\n        return getMarkerCounts()[IMarker.SEVERITY_WARNING];\n    }\n",
    "173085": "    public void addSecondaryMarker(IMarker marker, boolean notifyListeners) {\n        this.secondaryMarkerList.add(marker);\n        if (notifyListeners) {\n            notifyListenersAdd(new IMarker[] {marker});\n        }\n    }\n",
    "173095": "    public void visitIFNE(IFNE o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173122": "    public void visitIFNONNULL(IFNONNULL o){\n        if (!(stack().peek() instanceof ReferenceType)){\n            constraintViolated(o, \"The value at the stack top is not of a ReferenceType, but of type '\"+stack().peek()+\"'.\");\n        }\n        referenceTypeIsInitialized(o, (ReferenceType) (stack().peek()) );    \n    }\n",
    "173159": "    public void visitIFNULL(IFNULL o){\n        if (!(stack().peek() instanceof ReferenceType)){\n            constraintViolated(o, \"The value at the stack top is not of a ReferenceType, but of type '\"+stack().peek()+\"'.\");\n        }\n        referenceTypeIsInitialized(o, (ReferenceType) (stack().peek()) );    \n    }\n",
    "173163": "    public void setResource(IResource resource) {\n        this.resource = resource;\n    }\n",
    "173166": "    protected void configureShell(Shell newShell) {\n        super.configureShell(newShell);\n        if (title == null)\n            newShell.setText(Messages.getString(\"propertiesDialog.title\")); //$NON-NLS-1$\n        else\n            newShell.setText(title);\n    }\n",
    "173172": "    private void createCreationTimeArea(Composite parent) {\n        String creation = Messages\n                .getString(\"propertiesDialog.creationTime.text\");//$NON-NLS-1$\n\n        Font font = parent.getFont();\n        Composite composite = new Composite(parent, SWT.NONE);\n        GridLayout layout = new GridLayout();\n        layout.numColumns = 2;\n        composite.setLayout(layout);\n\n        Label label = new Label(composite, SWT.NONE);\n        label.setText(creation);\n        label.setFont(font);\n\n        creationTime = new Label(composite, SWT.NONE);\n        creationTime.setFont(font);\n    }\n",
    "173175": "    protected void createButtonsForButtonBar(Composite parent) {\n        createButton(parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL,\n                true);\n        createButton(parent, IDialogConstants.CANCEL_ID,\n                IDialogConstants.CANCEL_LABEL, false);\n    }\n",
    "173179": "    public void visitIINC(IINC o){\n        // Mhhh. In BCEL, at this time \"IINC\" is not a LocalVariableInstruction.\n        if (locals().maxLocals() <= (o.getType(cpg).getSize()==1? o.getIndex() : o.getIndex()+1) ){\n            constraintViolated(o, \"The 'index' is not a valid index into the local variable array.\");\n        }\n\n        indexOfInt(o, locals().get(o.getIndex()));\n    }\n",
    "173186": "    protected void createAttributesArea(Composite parent) {\n    }\n",
    "173202": "    protected Table createTable(Composite parent) {\n        Table table = new Table(parent, SWT.H_SCROLL | SWT.V_SCROLL | SWT.MULTI | SWT.FULL_SELECTION);\n        table.setLinesVisible(true);\n        table.setFont(parent.getFont());\n        return table;\n    }\n",
    "173203": "    public void visitILOAD(ILOAD o){\n        // All done by visitLocalVariableInstruction(), visitLoadInstruction()\n    }\n",
    "173208": "    protected void markDirty() {\n        dirty = true;\n    }\n",
    "173221": "    public void markDirty() {\n        dirty = true;\n    }\n",
    "173223": "    private void setButtonSize(Button button, GridData buttonData) {\n        buttonData.heightHint =\n            convertVerticalDLUsToPixels(IDialogConstants.BUTTON_HEIGHT);\n        int widthHint =\n            convertHorizontalDLUsToPixels(IDialogConstants.BUTTON_WIDTH);\n        buttonData.widthHint =\n            Math.max(\n                widthHint,\n                button.computeSize(SWT.DEFAULT, SWT.DEFAULT, true).x);\n        button.setLayoutData(buttonData);\n    }\n",
    "173226": "    public void visitIMPDEP1(IMPDEP1 o){\n        throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as IMPDEP1.\");\n    }\n",
    "173231": "    private void getAllSupertypes(ArrayList result) {\n        MarkerType[] supers = getSupertypes();\n        for (int i = 0; i < supers.length; ++i) {\n            MarkerType sup = supers[i];\n            if (!result.contains(sup)) {\n                result.add(sup);\n                sup.getAllSupertypes(result);\n            }\n        }\n    }\n",
    "173236": "    protected Map getMarkerAttributes() {\n        Map attrs;\n        if (initialAttributes == null) {\n            attrs = initialAttributes;\n        } else {\n            attrs = new HashMap();\n        }\n        attrs.put(IMarker.MESSAGE, descriptionText.getText());\n        return attrs;\n    }\n",
    "173237": "    public boolean isSubtypeOf(MarkerType superType) {\n        if (id.equals(superType.getId())) {\n            return true;\n        }\n        for (int i = 0; i < supertypeIds.length; ++i) {\n            MarkerType sup = model.getType(supertypeIds[i]);\n            if (sup != null && sup.isSubtypeOf(superType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "173240": "    public void run() {\n        // Get the markers from the clipboard\n        MarkerTransfer transfer = MarkerTransfer.getInstance();\n        IMarker[] markerData = (IMarker[]) clipboard.getContents(transfer);\n        paste(markerData);\n    }\n",
    "173241": "    private void createMarker(IProgressMonitor monitor) throws CoreException {\n        if (resource == null)\n            return;\n\n        monitor.worked(10);\n        marker = resource.createMarker(type);\n        monitor.worked(40);\n    }\n",
    "173245": "    public void run() {\n        if (!isEnabled()) {\n            return;\n        }\n        IMarker marker = getMarker();\n        if (marker == null) {\n            return;\n        }\n        IMarkerResolution[] resolutions = getResolutions(marker);\n        if (resolutions.length == 0) {\n            MessageDialog.openInformation(\n                part.getSite().getShell(),\n                Messages.getString(\"resolveMarkerAction.dialogTitle\"),  //$NON-NLS-1$\n                Messages.getString(\"resolveMarkerAction.noResolutionsLabel\")); //$NON-NLS-1$\n            return;\n        }     \n        MarkerResolutionSelectionDialog d = new MarkerResolutionSelectionDialog(part.getSite().getShell(), resolutions);\n        if (d.open() != Dialog.OK)\n            return;\n        Object[] result = d.getResult();\n        if (result != null && result.length > 0)\n            ((IMarkerResolution)result[0]).run(marker);            \n    }\n",
    "173246": "    private IMarker getMarker() {\n        IStructuredSelection selection = getStructuredSelection();\n        // only enable for single selection\n        if (selection.size() != 1)\n            return null;\n        return (IMarker) selection.getFirstElement();\n    }\n",
    "173248": "    protected void updateEnablement() {\n        descriptionText.setEditable(isEditable());\n    }\n",
    "173250": "            public void widgetSelected(SelectionEvent e) {\n                \n                int column = getViewer().getTable().indexOf((TableColumn) e.widget);\n                if (column == getSorter().getTopPriority())\n                    getSorter().reverseTopPriority();\n                else {\n                    getSorter().setTopPriority(column);\n                }\n                setSorter(getSorter());\n            }\n",
    "173253": "    public void visitIMPDEP2(IMPDEP2 o){\n        throw new AssertionViolatedException(\"In this JustIce verification pass there should not occur an illegal instruction such as IMPDEP2.\");\n    }\n",
    "173256": "    public void change(Collection changes) {\n        Iterator iter = changes.iterator();\n        \n        while (iter.hasNext()) {\n            Object next = iter.next();\n            boolean isVisible = false;\n            synchronized(visibleItems) {\n                if (visibleItems.contains(next)) {\n                    visibleItems.remove(next);\n                    visibleItems.add(next);\n                    pendingChanges.add(next);\n                    isVisible = true;\n                    hasPendingChanges = true;\n                }                \n            }\n            \n            if (!isVisible) {\n                if (insertionsInMiddle.contains(next)) {\n                    insertionsInMiddle.remove(next);\n                    insertionsInMiddle.add(next);\n                    hasPendingChanges = true;\n                } else if (insertionsAtEnd.contains(next)) {\n                    insertionsAtEnd.remove(next);\n                    insertionsAtEnd.add(next);\n                    hasPendingChanges = true;\n                }\n            }\n        }\n    }\n",
    "173261": "    protected boolean selectMarker(ConcreteMarker marker) {\n        return true;\n    }\n",
    "173262": "    private int nextChange(int maximumToChange) {\n        Collection result = SortUtil.removeFirst(pendingChanges, maximumToChange);\n        \n        viewer.update(result.toArray(), null);\n        \n        return result.size();\n    }\n",
    "173264": "    private int nextRemoval(int maximumToRemove) {\n        ArrayList result = new ArrayList(maximumToRemove);\n            \n        int counter = maximumToRemove;\n        \n        Iterator iter = pendingRemovals.iterator();\n        while (iter.hasNext() && counter > 0) {\n            Object next = iter.next();\n            \n            result.add(next);\n            \n            if (lastVisible != null && lastVisible.equals(next)) {\n                lastDirty = true;\n            }\n            \n            iter.remove();\n            counter--;\n        }\n        \n        synchronized(visibleItems) {\n            visibleItems.removeAll(result);\n        }\n        \n        viewer.remove(result.toArray());\n        \n        if (lastDirty) {\n            lastVisible = viewer.getElementAt(viewer.getTable().getItemCount() - 1);\n        }\n        \n        return result.size();\n    }\n",
    "173265": "    private Set getWorkingSetAsSetOfPaths() {\n        if (cachedWorkingSet == null) {\n            HashSet result = new HashSet();\n            \n            addResourcesAndChildren(result, getResourcesInWorkingSet());\n            \n            cachedWorkingSet = result;\n        }\n        \n        return cachedWorkingSet;\n    }\n",
    "173267": "    private int nextInsertionInMiddle(int maximumToInsert) {\n        \n        refreshQueues(new NullProgressMonitor());\n        \n        Collection result = SortUtil.removeFirst(insertionsInMiddle, maximumToInsert);\n        \n        synchronized(visibleItems) {            \n            visibleItems.addAll(result);\n        }\n        \n        // We manually compute the insertion position because setting a sorter on \n        // the viewer would force a refresh, which can be very slow with a large number\n        // of items.\n        \n        Iterator iter = result.iterator();\n        while (iter.hasNext()) {\n            Object element = iter.next();\n            \n            int insertionPos = getInsertPosition(element);\n            viewer.insert(element, insertionPos);\n        }\n                \n        return result.size();\n    }\n",
    "173270": "    private int nextInsertionAtEnd(int maximumToInsert) {\n        refreshQueues(new NullProgressMonitor());\n        \n        List result = new ArrayList(maximumToInsert);\n        \n        Iterator iter = insertionsAtEnd.iterator();\n        for (int counter = 0; counter < maximumToInsert && iter.hasNext(); counter++) {\n            lastVisible = iter.next();\n            \n            result.add(lastVisible);\n            \n            iter.remove();\n        }\n        \n        synchronized(visibleItems) {\n            visibleItems.addAll(result);\n        }\n        \n        viewer.add(result.toArray());\n        \n        return result.size();\n    }\n",
    "173271": "    public void visitIMUL(IMUL o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173274": "    public void reset() {\n        synchronized(this.visibleItems) {\n            this.visibleItems.removeAll(this.pendingRemovals);\n            \n            this.insertionsInMiddle.addAll(this.visibleItems);\n            this.lastVisible = null;\n            this.lastDirty = true;\n            \n            this.visibleItems.clear();\n        }\n        this.pendingRemovals.clear();\n        this.hasPendingChanges = true;\n    }\n",
    "173275": "    protected IWorkbenchSiteProgressService getProgressService() {\n        IWorkbenchSiteProgressService service = null;\n        Object siteService =\n            getSite().getAdapter(IWorkbenchSiteProgressService.class);\n        if(siteService != null)\n            service = (IWorkbenchSiteProgressService) siteService;\n        return service;\n    }\n",
    "173278": "    public boolean hasPendingChanges() {\n        return hasPendingChanges;\n    }\n",
    "173282": "    public int workRemaining() {\n        return pendingRemovals.size() + insertionsAtEnd.size() + insertionsInMiddle.size() + pendingChanges.size();\n    }\n",
    "173285": "    private boolean isEnclosed(IResource element) {\n        if (workingSet == null) {\n            return false;\n        }\n        Set workingSetPaths = getWorkingSetAsSetOfPaths();\n        \n        return workingSetPaths.contains(element.getFullPath().toString());\n    }\n",
    "173291": "    public void setFocusResource(IResource[] resources) {\n        focusResource = resources;\n    }\n",
    "173293": "    public void visitINEG(INEG o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173295": "    public void refreshQueues(IProgressMonitor mon) {\n        if (lastDirty) {\n            if (mon.isCanceled()) {\n                return;\n            }\n            HashSet newInsertionsInMiddle = new HashSet();\n            SortUtil.partition(newInsertionsInMiddle, insertionsAtEnd, insertionsAtEnd,\n                    insertionsInMiddle, sortOrder, lastVisible, mon);\n            \n            if (mon.isCanceled()) {\n                insertionsInMiddle.removeAll(insertionsAtEnd);\n            } else {\n                insertionsInMiddle = newInsertionsInMiddle;\n                lastDirty = false;\n            }\n        }\n    }\n",
    "173299": "    private int getInsertPosition(Object element) {\n        Table table = viewer.getTable();\n        if(sortOrder == null)\n            return table.getItemCount();\n        int count = table.getItemCount();\n        int min = 0, max = count - 1;\n        while (min <= max) {\n            int mid = (min + max) / 2;\n            Object data = table.getItem(mid).getData();\n            int compare = sortOrder.compare(data, element);\n            if (compare == 0) {\n                // find first item > element\n                while (compare == 0) {\n                    ++mid;\n                    if (mid >= count) {\n                        break;\n                    }\n                    data = table.getItem(mid).getData();\n                    compare = sortOrder.compare(data, element);\n                }\n                return mid;\n            }\n            if (compare < 0)\n                min = mid + 1;\n            else\n                max = mid - 1;\n        }\n        return min;        \n    }    \n",
    "173307": "    public TableViewer getViewer() {\n        return viewer;\n    }\n",
    "173311": "    public void clearCache() {\n        resourceNameKey = null;\n        descriptionKey = null;\n        inFolderKey = null;        \n    }\n",
    "173312": "    public void refresh() {\n        clearCache();\n        \n        description = Util.getProperty(IMarker.MESSAGE, marker);\n        resourceName = marker.getResource().getName();\n        inFolder = Util.getContainerName(marker);\n        line = marker.getAttribute(IMarker.LINE_NUMBER, -1);\n        try {\n            creationTime = marker.getCreationTime();\n        } catch (CoreException e) {\n            creationTime = 0;\n        }\n        \n        try {\n            type = marker.getType();\n        } catch (CoreException e1) {\n            type = \"\"; //$NON-NLS-1$\n        }        \n    }\n",
    "173313": "    private Set newEndSet() {\n        if (sortOrder == null) {\n            return new HashSet();\n        } else {\n            return new TreeSet(sortOrder);\n        }\n    }\n",
    "173324": "    public void run() {\n        IStructuredSelection selection = getStructuredSelection();\n        if (selection == null || selection.isEmpty() || clipboard == null)\n            return;\n        List list = selection.toList();\n        IMarker[] markers = new IMarker[list.size()];\n        list.toArray(markers);\n        setClipboard(markers, createMarkerReport(markers));\n    }\n",
    "173326": "    protected void refresh() {\n        \n        if(uiJob == null)\n            createUIJob();\n    \n        if (refreshJob == null) {\n            \n            refreshJob = new RestartableJob(\n                Messages.format(\"MarkerView.refreshTitle\", new Object[] {getTitle()}),//$NON-NLS-1$\n                new IRunnableWithProgress() {\n                    public void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {\n                        internalRefresh(monitor);\n                    }\n                },\n                getProgressService());            \n        }\n        \n        refreshJob.restart();        \n    }    \n",
    "173327": "    public void selectionChanged(IStructuredSelection selection) {\n        setEnabled(selection != null && !selection.isEmpty());\n    }\n",
    "173334": "    private String getWellKnownLabel(String type) {\n        if (type.equals(IMarker.PROBLEM))\n            return \"Problem\";//$NON-NLS-1$\n        if (type.equals(IMarker.TASK))\n            return \"Task\";//$NON-NLS-1$\n        if (type.equals(\"org.eclipse.jdt.core.problem\"))//$NON-NLS-1$\n            return \"Java Problem\";//$NON-NLS-1$\n        return type;\n    }\n",
    "173341": "    public void run() {\n        if (!isEnabled()) {\n            return;\n        }\n        final IStructuredSelection selection = getStructuredSelection();\n        if (selection.isEmpty()) {\n            return;\n        }\n        try {\n            ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable() {\n                public void run(IProgressMonitor monitor) throws CoreException {\n                    for (Iterator iter = selection.iterator(); iter.hasNext();) {\n                        Object o = iter.next();\n                        if (o instanceof IMarker) {\n                            IMarker marker = (IMarker) o;\n                            marker.delete();\n                        }\n                    }\n                }\n            }, null);\n        } \n        catch (CoreException e) {\n            ErrorDialog.openError(part.getSite().getShell(), Messages.getString(\"RemoveMarker.errorTitle\"), null, e.getStatus()); //$NON-NLS-1$\n        }\n    }\n",
    "173342": "    private void createJob(String name) {\n        theJob = new Job(name) {\n            protected IStatus run(IProgressMonitor innerMonitor) {\n                try {\n                    synchronized(lock) {\n                        restartNeeded = false;\n                        currentMonitor = innerMonitor;\n                    }\n                    runnable.run(innerMonitor);\n                } catch (InvocationTargetException e) {\n                    return StatusUtil.newStatus(IStatus.ERROR, e.toString(), e.getTargetException());\n                } catch (InterruptedException e) {\n                    return Status.CANCEL_STATUS;\n                }\n                if (innerMonitor.isCanceled()) {\n                    return Status.CANCEL_STATUS;\n                } else {\n                    return Status.OK_STATUS;\n                }\n            }\n        };\n        \n        theJob.setPriority(Job.DECORATE);\n        theJob.setSystem(true);\n    }\n",
    "173348": "    public void restart() {\n        synchronized(lock) {\n            if (currentMonitor == null) {\n                scheduleInService();\n            } else if (!restartNeeded) {\n                restartNeeded = true;\n                theJob.cancel();\n            }\n        }\n    }\n",
    "173351": "    public void schedule() {\n        synchronized(lock) {\n            if (currentMonitor == null) {\n                scheduleInService();\n            } else {\n                if (currentMonitor.isCanceled()) {\n                    restartNeeded = true;\n                }\n            }\n        }\n    }\n",
    "173353": "    private void scheduleInService() {\n        if(progressService == null)\n            theJob.schedule();\n        else\n            progressService.schedule(theJob,0,true);\n    }\n",
    "173356": "    public void cancel() {\n        synchronized(lock) {\n            theJob.cancel();\n            restartNeeded = false;\n        }\n    }\n",
    "173364": "        public IStatus runInUIThread(IProgressMonitor monitor) {\n            \n            // If we can't get the lock, terminate without blocking the UI thread.\n            if (lock.getDepth() > 0) {\n                lastWorked = 0;\n                return Status.OK_STATUS;\n            }\n            \n            lock.acquire();            \n            try {\n                if (!PlatformUI.isWorkbenchRunning()) {\n                    controlExists = false;\n                } else {    \n                    controlExists = controlExists();\n                    if (controlExists) {\n                        lastWorked = updateViewer();\n                    }\n                }\n            } finally {\n                lock.release();\n            }\n            \n            return Status.OK_STATUS;\n        }\n",
    "173368": "    public void setSorter(TableSorter c) {\n        if (sortOrder != c) {\n            sortOrder = c;\n            scheduleUpdate();\n        }\n    }\n",
    "173374": "    public void set(Collection newVisibleItems, IProgressMonitor mon) {\n        lock.acquire();\n        \n        try {\n            queues.set(newVisibleItems, mon);\n                \n            scheduleUpdate();\n        } finally {\n            lock.release();\n        }\n    }\n",
    "173378": "    protected void configureShell(Shell newShell) {\n        super.configureShell(newShell);\n        newShell.setText(Messages.getString(\"filtersDialog.title\")); //$NON-NLS-1$\n    }\n",
    "173379": "    private TableViewer getViewer() {\n        return queues.getViewer();\n    }\n",
    "173380": "    public boolean hasPendingChanges() {\n        return queues.hasPendingChanges() || sortOrder != queues.getSorter();\n    }\n",
    "173383": "    private int totalWork() {\n        return queues.workRemaining() + 1;\n    }\n",
    "173387": "    public void cancelPendingChanges() {\n        updateJob.cancel();\n        \n        lock.acquire();\n        try {\n            queues.cancelPending();\n        } finally {\n            lock.release();\n        }\n    }\n",
    "173388": "    protected Button createCheckbox(Composite parent, String text, boolean grabRow) {\n        Button button = new Button(parent, SWT.CHECK);\n        if (grabRow) {\n            GridData gridData = new GridData(GridData.FILL_HORIZONTAL);\n            button.setLayoutData(gridData);\n        }\n        button.setText(text);\n        button.addSelectionListener(selectionListener);\n        button.setFont(parent.getFont());\n        return button;\n    }\n",
    "173391": "    private int updateViewer() {\n        \n        int result;\n        \n        // Note that this method is only called when we have the lock so acquiring it here\n        // does nothing... but we re-acquire it anyway in case future refactoring causes\n        // this to be called when we don't own the lock.\n        lock.acquire();\n        try {\n            if (getViewer().getSorter() != null) {\n                getViewer().setSorter(null);\n            }\n            \n            resync();\n            \n            result = queues.nextUpdate();\n        } finally {\n            lock.release();\n        }\n        \n        return result;\n    }    \n",
    "173394": "    protected Combo createCombo(Composite parent, String[] items, int selectionIndex) {\n        Combo combo = new Combo(parent, SWT.DROP_DOWN | SWT.READ_ONLY);\n        combo.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        combo.setFont(parent.getFont());\n        combo.setItems(items);\n        combo.select(selectionIndex);\n        combo.addSelectionListener(selectionListener);\n        return combo;\n    }\n",
    "173399": "    public void run() {\n        view.openFiltersDialog();\n    }\n",
    "173407": "    protected void createSeparatorLine(Composite parent) {\n        // Build the separator line\n        Label separator = new Label(parent, SWT.HORIZONTAL | SWT.SEPARATOR);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 1;\n        separator.setLayoutData(gd);\n    }\n",
    "173412": "    protected Button createRadioButton(Composite parent, String text) {\n        Button button = new Button(parent, SWT.RADIO);\n        button.setText(text);\n        button.setFont(parent.getFont());\n        button.addSelectionListener(selectionListener);\n        return button;\n    }\n",
    "173421": "    private void performDragSetData(DragSourceEvent event) {\n        if (MarkerTransfer.getInstance().isSupportedType(event.dataType)) {\n            event.data = ((IStructuredSelection) getViewer().getSelection()).toArray();\n            return;\n        }\n        if (TextTransfer.getInstance().isSupportedType(event.dataType)) {\n            List selection = ((IStructuredSelection) getViewer().getSelection()).toList();\n            try {\n                IMarker[] markers = new IMarker[selection.size()];\n                selection.toArray(markers);\n                if (markers != null) {\n                    event.data = copyAction.createMarkerReport(markers);\n                }\n            } catch (ArrayStoreException e) {\n                //do nothing\n            }\n        }\n    }\n",
    "173438": "    public void visitIOR(IOR o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173442": "    protected void createOnOffArea(Composite parent) {\n        Font font = parent.getFont();\n        Composite composite = new Composite(parent, SWT.NONE);\n        composite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        composite.setFont(font);\n        composite.setLayout(new GridLayout());\n        filterEnabledButton = createCheckbox(composite,\n            Messages.getString(\"filtersDialog.onOff\"), //$NON-NLS-1$\n            false);\n        filterEnabledButton.setFont(composite.getFont());\n        filterEnabledButton.setLayoutData(new GridData());\n        filterEnabledButton.addSelectionListener(selectionListener);\n    }\n",
    "173478": "    public void visitIREM(IREM o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173502": "    protected List getSelectedTypes() {\n        return Arrays.asList(typesViewer.getCheckedElements());\n    }\n",
    "173508": "    private int getMarkerLimit() {\n        MarkerFilter filter = getFilter();\n\n        if (!filter.isEnabled() || !filter.getFilterOnMarkerLimit()) {\n            return -1;\n        }\n        \n        return filter.getMarkerLimit();            \n    }\n",
    "173509": "    public void visitIRETURN(IRETURN o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173521": "    public void visitISHL(ISHL o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173522": "    protected void updateStatusMessage() {\n        ISelection selection = getViewer().getSelection();\n        \n        if (selection instanceof IStructuredSelection)\n            updateStatusMessage((IStructuredSelection) selection);\n        else \n            updateStatusMessage(null);\n    }\n",
    "173527": "    protected void updateStatusMessage(IStructuredSelection selection) {\n        String message = \"\"; //$NON-NLS-1$\n        \n        if (selection == null || selection.size() == 0){\n            // Show stats on all items in the view\n            message = updateSummaryVisible();\n        } else if (selection.size() == 1) {\n            // Use the Message attribute of the marker\n            ConcreteMarker marker = (ConcreteMarker)selection.getFirstElement();\n            message = marker.getDescription(); //$NON-NLS-1$\n        } else if (selection.size() > 1) {\n            // Show stats on only those items in the selection\n            message = updateSummarySelected(selection);\n        }\n        getViewSite().getActionBars().getStatusLineManager().setMessage(message);        \n    }\n",
    "173532": "    public void visitISHR(ISHR o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173533": "    protected void widgetSelected(SelectionEvent e) {\n        updateEnabledState();\n        markDirty();\n    }\n",
    "173538": "    public void setSelection(IStructuredSelection structuredSelection, boolean reveal) {\n        TableViewer viewer = getViewer();\n        \n        List newSelection = new ArrayList(structuredSelection.size());\n        \n        for (Iterator i = structuredSelection.iterator(); i.hasNext();) {\n            Object next = i.next();\n            if (next instanceof IMarker) {\n                ConcreteMarker marker = currentMarkers.getMarker((IMarker)next);\n                if (marker != null) {\n                    newSelection.add(marker);\n                }\n            }\n        }\n\n        if (viewer != null)\n            viewer.setSelection(new StructuredSelection(newSelection), reveal);\n    }\n",
    "173545": "    public void visitISTORE(ISTORE o){\n        //visitStoreInstruction(StoreInstruction) is called before.\n        \n        // Nothing else needs to be done here.\n    }\n",
    "173556": "    private void createUIJob(){\n        uiJob = new WorkbenchJob(Messages.getString(\"MarkerView.refreshProgress\")) { //$NON-NLS-1$\n            \n            public IStatus runInUIThread(IProgressMonitor monitor) {                        \n                updateStatusMessage();\n                updateTitle();\n                return Status.OK_STATUS;\n            }\n        };\n        uiJob.setPriority(Job.INTERACTIVE);\n        uiJob.setSystem(true);\n    }\n",
    "173557": "    public void visitISUB(ISUB o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173577": "    public void visitIUSHR(IUSHR o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173600": "    public void visitIXOR(IXOR o){\n        if (stack().peek() != Type.INT){\n            constraintViolated(o, \"The value at the stack top is not of type 'int', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.INT){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'int', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173617": "    protected void handleProjectButtonSelected() {\n        IJavaProject project = chooseJavaProject();\n        if (project == null) {\n            return;\n        }\n        \n        String projectName = project.getElementName();\n        this.fProjText.setText(projectName);        \n    }\n",
    "173640": "    public void visitJSR(JSR o){\n        // nothing to do here.\n    }\n",
    "173666": "    public void visitJSR_W(JSR_W o){\n        // nothing to do here.\n    }\n",
    "173669": "    public ProcessingInstruction setTarget(String newTarget) {\n        String reason;\n        if ((reason = Verifier.checkProcessingInstructionTarget(newTarget))\n                                    != null) {\n            throw new IllegalTargetException(newTarget, reason);\n        }\n\n        target = newTarget;\n        return this;\n    }\n",
    "173670": "    public String getValue() {\n        return rawData;\n    }\n",
    "173672": "    public String getTarget() {\n        return target;\n    }\n",
    "173674": "    public String getData() {\n        return rawData;\n    }\n",
    "173676": "    public List getPseudoAttributeNames() {\n      Set mapDataSet = mapData.entrySet();\n      List nameList = new ArrayList();\n      for (Iterator i = mapDataSet.iterator(); i.hasNext();) {\n         String wholeSet = (i.next()).toString();\n         String attrName = wholeSet.substring(0,(wholeSet.indexOf(\"=\")));\n         nameList.add(attrName);\n      }\n      return nameList;\n    }\n",
    "173678": "    public ProcessingInstruction setData(String data) {\n        String reason = Verifier.checkProcessingInstructionData(data);\n        if (reason != null) {\n            throw new IllegalDataException(data, reason);\n        }\n\n        this.rawData = data;\n        this.mapData = parseData(data);\n        return this;\n    }\n",
    "173679": "    public ProcessingInstruction setData(Map data) {\n        String temp = toString(data);\n\n        String reason = Verifier.checkProcessingInstructionData(temp);\n        if (reason != null) {\n            throw new IllegalDataException(temp, reason);\n        }\n\n        this.rawData = temp;\n        this.mapData = data;\n        return this;\n    }\n",
    "173681": "    public void visitL2D(L2D o){\n        if (stack().peek() != Type.LONG){\n            constraintViolated(o, \"The value at the stack top is not of type 'long', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173682": "    public String getPseudoAttributeValue(String name) {\n        return (String)mapData.get(name);\n    }\n",
    "173684": "    public ProcessingInstruction setPseudoAttribute(String name, String value) {\n        String reason = Verifier.checkProcessingInstructionData(name);\n        if (reason != null) {\n            throw new IllegalDataException(name, reason);\n        }\n\n        reason = Verifier.checkProcessingInstructionData(value);\n        if (reason != null) {\n            throw new IllegalDataException(value, reason);\n        }\n\n        this.mapData.put(name, value);\n        this.rawData = toString(mapData);\n        return this;\n    }\n",
    "173686": "    public boolean removePseudoAttribute(String name) {\n        if ((mapData.remove(name)) != null) {\n            rawData = toString(mapData);\n            return true;\n        }\n\n        return false;\n    }\n",
    "173688": "    private String toString(Map mapData) {\n        StringBuffer rawData = new StringBuffer();\n\n        Iterator i = mapData.keySet().iterator();\n        while (i.hasNext()) {\n            String name = (String)i.next();\n            String value = (String)mapData.get(name);\n            rawData.append(name)\n                   .append(\"=\\\"\")\n                   .append(value)\n                   .append(\"\\\" \");\n        }\n        // Remove last space, if we did any appending\n        if (rawData.length() > 0) {\n            rawData.setLength(rawData.length() - 1);\n        }\n\n        return rawData.toString();\n    }\n",
    "173692": "    public String toString() {\n        return new StringBuffer()\n            .append(\"[ProcessingInstruction: \")\n            .append(new org.jdom.output.XMLOutputter().outputString(this))\n            .append(\"]\")\n            .toString();\n    }\n",
    "173694": "    public Object clone() {\n        ProcessingInstruction pi = (ProcessingInstruction) super.clone();\n\n        // target and rawdata are immutable and references copied by\n        // Object.clone()\n\n        // Create a new Map object for the clone (since Map isn't Cloneable)\n        if (mapData != null) {\n            pi.mapData = parseData(rawData);\n        }\n        return pi;\n    }\n",
    "173696": "    public String getElementName() {\n        return elementName;\n    }\n",
    "173697": "    public void visitL2F(L2F o){\n        if (stack().peek() != Type.LONG){\n            constraintViolated(o, \"The value at the stack top is not of type 'long', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173698": "    public DocType setElementName(String elementName) {\n        // This can contain a colon so we use checkXMLName()\n        // instead of checkElementName()\n        String reason = Verifier.checkXMLName(elementName);\n        if (reason != null) {\n            throw new IllegalNameException(elementName, \"DocType\", reason);\n        }\n        this.elementName = elementName;\n        return this;\n    }\n",
    "173700": "    public String getPublicID() {\n        return publicID;\n    }\n",
    "173702": "    public DocType setPublicID(String publicID) {\n        String reason = Verifier.checkPublicID(publicID);\n        if (reason != null) {\n            throw new IllegalDataException(publicID, \"DocType\", reason);\n        }\n        this.publicID = publicID;\n\n        return this;\n    }\n",
    "173703": "    public String getSystemID() {\n        return systemID;\n    }\n",
    "173704": "    public DocType setSystemID(String systemID) {\n        String reason = Verifier.checkSystemLiteral(systemID);\n        if (reason != null) {\n            throw new IllegalDataException(systemID, \"DocType\", reason);\n        }\n        this.systemID = systemID;\n\n        return this;\n    }\n",
    "173706": "    public String getValue() {\n        return \"\";  // doctypes don't have an XPath string value\n    }\n",
    "173708": "    public void setInternalSubset(String newData) {\n        internalSubset = newData;\n    }\n",
    "173709": "    public String getInternalSubset() {\n        return internalSubset;\n    }\n",
    "173711": "    public String toString() {\n        return new StringBuffer()\n            .append(\"[DocType: \")\n            .append(new org.jdom.output.XMLOutputter().outputString(this))\n            .append(\"]\")\n            .toString();\n    }\n",
    "173714": "    public Document createDocument() throws JDOMException {\n        try {\n            return\n                (Document)Class.forName(\n                    \"oracle.xml.parser.XMLDocument\")\n                    .newInstance();\n\n        } catch (Exception e) {\n            throw new JDOMException(e.getClass().getName() + \": \" +\n                                  e.getMessage() + \" when creating document\", e);\n        }\n    }\n",
    "173716": "    public Document createDocument() throws JDOMException {\n        try {\n            return\n                (Document)Class.forName(\n                    \"org.apache.crimson.tree.XmlDocument\")\n                    .newInstance();\n\n        } catch (Exception e) {\n            throw new JDOMException(e.getClass().getName() + \": \" +\n                                  e.getMessage() + \" when creating document\", e);\n        }\n    }\n",
    "173717": "    public void visitL2I(L2I o){\n        if (stack().peek() != Type.LONG){\n            constraintViolated(o, \"The value at the stack top is not of type 'long', but of type '\"+stack().peek()+\"'.\");\n        }\n    }\n",
    "173723": "    public Document createDocument() throws JDOMException {\n        try {\n            return (Document)Class.forName(\n                \"org.apache.xerces.dom.DocumentImpl\").newInstance();\n        } catch (Exception e) {\n            throw new JDOMException(e.getClass().getName() + \": \" +\n                                  e.getMessage() + \" when creating document\", e);\n        }\n    }\n",
    "173726": "    public Document createDocument(DocType doctype) throws JDOMException {\n        if (doctype == null) {\n            return createDocument();\n        }\n  \n        DOMImplementation domImpl = createDocument().getImplementation();\n        DocumentType domDocType = domImpl.createDocumentType(\n                                      doctype.getElementName(),\n                                      doctype.getPublicID(),\n                                      doctype.getSystemID());\n\n        // Set the internal subset if possible\n        setInternalSubset(domDocType, doctype.getInternalSubset());\n\n        return domImpl.createDocument(\"http://temporary\",\n                                      doctype.getElementName(),\n                                      domDocType);\n    }\n",
    "173727": "    public Document createDocument() throws JDOMException {\n        try {\n            return\n                (Document)Class.forName(\n                    \"oracle.xml.parser.v2.XMLDocument\")\n                    .newInstance();\n\n        } catch (Exception e) {\n            throw new JDOMException(e.getClass().getName() + \": \" +\n                                  e.getMessage() + \" when creating document\", e);\n        }\n    }\n",
    "173728": "    protected void setInternalSubset(DocumentType dt, String s) {\n        if (dt == null || s == null) return;\n\n        // Default behavior is to attempt a setInternalSubset() call using\n        // reflection.  This method is not part of the DOM spec, but it's\n        // available on Xerces 1.4.4+.  It's not currently in Crimson.\n        try {\n            Class dtclass = dt.getClass();\n            Method setInternalSubset = dtclass.getMethod(\n                \"setInternalSubset\", new Class[] {java.lang.String.class});\n            setInternalSubset.invoke(dt, new Object[] {s});\n        }\n        catch (Exception e) {\n            // ignore\n        }\n    }\n",
    "173730": "    public Document createDocument() throws JDOMException {\n        try {\n            return\n                (Document)Class.forName(\n                    \"org.apache.xerces.dom.DocumentImpl\")\n                    .newInstance();\n\n        } catch (Exception e) {\n            throw new JDOMException(e.getClass().getName() + \": \" +\n                                  e.getMessage() + \" while creating document\", e);\n        }\n    }\n",
    "173734": "   public List selectNodes(Object context) throws JDOMException {\n      try {\n         currentContext = context;\n\n         return xPath.selectNodes(context);\n      }\n      catch (JaxenException ex1) {\n         throw new JDOMException(\"XPath error while evaluating \\\"\" +\n                        xPath.toString() + \"\\\": \" + ex1.getMessage(), ex1);\n      }\n      finally {\n         currentContext = null;\n      }\n   }\n",
    "173735": "   public Object selectSingleNode(Object context) throws JDOMException {\n      try {\n         currentContext = context;\n\n         return xPath.selectSingleNode(context);\n      }\n      catch (JaxenException ex1) {\n         throw new JDOMException(\"XPath error while evaluating \\\"\" +\n                        xPath.toString() + \"\\\": \" + ex1.getMessage(), ex1);\n      }\n      finally {\n         currentContext = null;\n      }\n   }\n",
    "173736": "    public void printStackTrace() {\n        // Print the stack trace for this exception.\n        super.printStackTrace();\n\n        Throwable parent = this;\n        Throwable child;\n\n        // Print the stack trace for each nested exception.\n        while((child = getNestedException(parent)) != null) {\n            System.err.print(\"Caused by: \");\n            child.printStackTrace();\n            // Any nested JDOMException will print its own children,\n            // so we need to break out of here.\n            if (child instanceof JDOMException) {\n                break;\n            }\n            parent = child;\n        }\n    }\n",
    "173737": "   public String valueOf(Object context) throws JDOMException {\n      try {\n         currentContext = context;\n\n         return xPath.stringValueOf(context);\n      }\n      catch (JaxenException ex1) {\n         throw new JDOMException(\"XPath error while evaluating \\\"\" +\n                        xPath.toString() + \"\\\": \" + ex1.getMessage(), ex1);\n      }\n      finally {\n         currentContext = null;\n      }\n   }\n",
    "173738": "    public void printStackTrace(PrintStream s) {\n        // Print the stack trace for this exception.\n        super.printStackTrace(s);\n\n        Throwable parent = this;\n        Throwable child;\n\n        // Print the stack trace for each nested exception.\n        while((child = getNestedException(parent)) != null) {\n            s.print(\"Caused by: \");\n            child.printStackTrace(s);\n            // Any nested JDOMException will print its own children,\n            // so we need to break out of here.\n            if (child instanceof JDOMException) {\n                break;\n            }\n            parent = child;\n        }\n    }\n",
    "173739": "   public Number numberValueOf(Object context) throws JDOMException {\n      try {\n         currentContext = context;\n\n         return xPath.numberValueOf(context);\n      }\n      catch (JaxenException ex1) {\n         throw new JDOMException(\"XPath error while evaluating \\\"\" +\n                        xPath.toString() + \"\\\": \" + ex1.getMessage(), ex1);\n      }\n      finally {\n         currentContext = null;\n      }\n   }\n",
    "173741": "    public void printStackTrace(PrintWriter w) {\n        // Print the stack trace for this exception.\n        super.printStackTrace(w);\n\n        Throwable parent = this;\n        Throwable child;\n\n        // Print the stack trace for each nested exception.\n        while((child = getNestedException(parent)) != null) {\n            w.print(\"Caused by: \");\n            child.printStackTrace(w);\n            // Any nested JDOMException will print its own children,\n            // so we need to break out of here.\n            if (child instanceof JDOMException) {\n                break;\n            }\n            parent = child;\n        }\n    }\n",
    "173744": "    public void visitLADD(LADD o){\n        if (stack().peek() != Type.LONG){\n            constraintViolated(o, \"The value at the stack top is not of type 'long', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.LONG){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'long', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173745": "   public void addNamespace(Namespace namespace) {\n      try {\n         xPath.addNamespace(namespace.getPrefix(), namespace.getURI());\n      }\n      catch (JaxenException ex1) { /* Can't happen here. */ }\n   }\n",
    "173746": "   public String getXPath() {\n      return (xPath.toString());\n   }\n",
    "173749": "   private void setXPath(String expr) throws JDOMException {\n      try {\n         xPath = new JDOMXPath(expr);\n         xPath.setNamespaceContext(new NSContext());\n      }\n      catch (Exception ex1) {\n         throw new JDOMException(\n                        \"Invalid XPath expression: \\\"\" + expr + \"\\\"\", ex1);\n      }\n   }\n",
    "173753": "   public void addNamespace(String prefix, String uri) {\n      addNamespace(Namespace.getNamespace(prefix, uri));\n   }\n",
    "173758": "      public String translateNamespacePrefixToUri(String prefix) {\n         if ((prefix == null) || (prefix.length() == 0)) {\n            return null;\n         }\n\n         String uri = super.translateNamespacePrefixToUri(prefix);\n         if (uri == null) {\n            Object ctx = currentContext;\n            if (ctx != null) {\n               Element elt = null;\n\n               // Get closer element node\n               if (ctx instanceof Element) {\n                  elt = (Element)ctx;\n               } else if (ctx instanceof Attribute) {\n                  elt = ((Attribute)ctx).getParent();\n               } else if (ctx instanceof Content) {\n                  elt = ((Content) ctx).getParentElement();\n               } else if (ctx instanceof Document) {\n                  elt = ((Document)ctx).getRootElement();\n               }\n\n               if (elt != null) {\n                  Namespace ns = elt.getNamespace(prefix);\n                  if (ns != null) {\n                     uri = ns.getURI();\n                  }\n               }\n            }\n         }\n         return uri;\n      }\n",
    "173759": "    public boolean add(Object obj) {\n        if (obj instanceof Attribute) {\n            Attribute attribute = (Attribute) obj;\n            int duplicate = indexOfDuplicate(attribute);\n            if (duplicate < 0) {\n                add(size(), attribute);\n            }\n            else {\n                set(duplicate, attribute);\n            }\n        }\n        else if (obj == null) {\n            throw new IllegalAddException(\"Cannot add null attribute\");\n        }\n        else {\n            throw new IllegalAddException(\"Class \" +\n                                          obj.getClass().getName() +\n                                          \" is not an attribute\");\n        }\n        return true;\n    }\n",
    "173760": "      private Object readResolve() throws ObjectStreamException {\n         try {\n            return XPath.newInstance(this.xPath);\n         }\n         catch (JDOMException ex1) {\n            throw new InvalidObjectException(\n                        \"Can't create XPath object for expression \\\"\" +\n                        this.xPath + \"\\\": \" + ex1.toString());\n         }\n      }\n",
    "173761": "    public void add(int index, Object obj) {\n        if (obj instanceof Attribute) {\n            Attribute attribute = (Attribute) obj;\n            int duplicate = indexOfDuplicate(attribute);\n            if (duplicate >= 0) {\n                throw new IllegalAddException(\"Cannot add duplicate attribute\");\n            }\n            add(index, attribute);\n        }\n        else if (obj == null) {\n            throw new IllegalAddException(\"Cannot add null attribute\");\n        }\n        else {\n            throw new IllegalAddException(\"Class \" +\n                                          obj.getClass().getName() +\n                                          \" is not an attribute\");\n        }\n        modCount++;\n    }\n",
    "173763": "    public Element getParent() {\n        return (Element) parent;\n    }\n",
    "173765": "    public boolean addAll(Collection collection) {\n        return addAll(size(), collection);\n    }\n",
    "173767": "    public void visitLALOAD(LALOAD o){\n        indexOfInt(o, stack().peek());\n        if (stack().peek(1) == Type.NULL){\n            return;\n        } \n        if (! (stack().peek(1) instanceof ArrayType)){\n            constraintViolated(o, \"Stack next-to-top must be of type long[] but is '\"+stack().peek(1)+\"'.\");\n        }\n        Type t = ((ArrayType) (stack().peek(1))).getBasicType();\n        if (t != Type.LONG){\n            constraintViolated(o, \"Stack next-to-top must be of type long[] but is '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173770": "    public Document getDocument() {\n        if (parent != null) {\n            return ((Element)parent).getDocument();\n        }\n        return null;\n    }\n",
    "173771": "    public boolean addAll(int index, Collection collection) {\n        if (index<0 || index>size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index +\n                                                \" Size: \" + size());\n        }\n\n        if ((collection == null) || (collection.size() == 0)) {\n            return false;\n        }\n        ensureCapacity(size() + collection.size());\n\n        int count = 0;\n\n        try {\n            Iterator i = collection.iterator();\n            while (i.hasNext()) {\n                Object obj = i.next();\n                add(index + count, obj);\n                count++;\n            }\n        }\n        catch (RuntimeException exception) {\n            for (int i = 0; i < count; i++) {\n                remove(index);\n            }\n            throw exception;\n        }\n\n        return true;\n    }\n",
    "173775": "    public void clear() {\n        if (elementData != null) {\n            for (int i = 0; i < size; i++) {\n                Attribute attribute = elementData[i];\n                attribute.setParent(null);\n            }\n            elementData = null;\n            size = 0;\n        }\n        modCount++;\n    }\n",
    "173776": "    protected Attribute setParent(Element parent) {\n        this.parent = parent;\n        return this;\n    }\n",
    "173779": "    private void ensureCapacity(int minCapacity) {\n        if (elementData == null) {\n            elementData = new Attribute[Math.max(minCapacity, INITIAL_ARRAY_SIZE)];\n        }\n        else {\n            int oldCapacity = elementData.length;\n            if (minCapacity > oldCapacity) {\n                Attribute oldData[] = elementData;\n                int newCapacity = (oldCapacity * 3)/2 + 1;\n                if (newCapacity < minCapacity)\n                    newCapacity = minCapacity;\n                elementData = new Attribute[newCapacity];\n                System.arraycopy(oldData, 0, elementData, 0, size);\n            }\n        }\n    }\n",
    "173781": "    public Attribute detach() {\n        Element p = getParent();\n        if (p != null) {\n            p.removeAttribute(this.getName(), this.getNamespace());\n        }\n        return this;\n    }\n",
    "173784": "    public Object get(int index) {\n        if (index<0 || index>=size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index +\n                                                \" Size: \" + size());\n        }\n\n        return elementData[index];\n    }\n",
    "173788": "    public Object remove(int index) {\n        if (index<0 || index>=size)\n            throw new IndexOutOfBoundsException(\"Index: \" + index +\n                                                \" Size: \" + size());\n\n        Attribute old = elementData[index];\n        old.setParent(null);\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            System.arraycopy(elementData, index+1, elementData, index,numMoved);\n        elementData[--size] = null; // Let gc do its work\n        modCount++;\n        return old;\n    }\n",
    "173791": "    public Attribute setName(String name) {\n        String reason;\n        if ((reason = Verifier.checkAttributeName(name)) != null) {\n            throw new IllegalNameException(name, \"attribute\", reason);\n        }\n        this.name = name;\n        return this;\n    }\n",
    "173793": "    public Object set(int index, Object obj) {\n        if (obj instanceof Attribute) {\n            Attribute attribute = (Attribute) obj;\n            int duplicate = indexOfDuplicate(attribute);\n            if ((duplicate >= 0) && (duplicate != index)) {\n                throw new IllegalAddException(\"Cannot set duplicate attribute\");\n            }\n            return set(index, attribute);\n        }\n        else if (obj == null) {\n            throw new IllegalAddException(\"Cannot add null attribute\");\n        }\n        else {\n            throw new IllegalAddException(\"Class \" +\n                                          obj.getClass().getName() +\n                                          \" is not an attribute\");\n        }\n    }\n",
    "173796": "    public String getQualifiedName() {\n        // Note: Any changes here should be reflected in\n        // XMLOutputter.printQualifiedName()\n        String prefix = namespace.getPrefix();\n        if ((prefix != null) && (!prefix.equals(\"\"))) {\n            return new StringBuffer(prefix)\n                .append(':')\n                .append(getName())\n                .toString();\n        } else {\n            return getName();\n        }\n    }\n",
    "173797": "    public void visitLAND(LAND o){\n        if (stack().peek() != Type.LONG){\n            constraintViolated(o, \"The value at the stack top is not of type 'long', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.LONG){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'long', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173798": "    private int indexOfDuplicate(Attribute attribute) {\n        int duplicate = -1;\n        String name = attribute.getName();\n        Namespace namespace = attribute.getNamespace();\n        duplicate = indexOf(name, namespace);\n        return duplicate;\n    }\n",
    "173802": "    public int size() {\n        return size;\n    }\n",
    "173803": "    public String getNamespacePrefix() {\n        return namespace.getPrefix();\n    }\n",
    "173806": "    public String toString() {\n        return super.toString();\n    }\n",
    "173807": "    public String getNamespaceURI() {\n        return namespace.getURI();\n    }\n",
    "173808": "    public List transform(List inputNodes) throws XSLTransformException {\n        JDOMSource source = new JDOMSource(inputNodes);\n        JDOMResult result = new JDOMResult();\n        try {\n            templates.newTransformer().transform(source, result);\n            return result.getResult();\n        }\n        catch (TransformerException e) {\n            throw new XSLTransformException(\"Could not perform transformation\", e);\n        }\n    }\n",
    "173809": "  public void setDocument(Document source) {\n    super.setInputSource(new JDOMInputSource(source));\n  }\n",
    "173810": "    public Document transform(Document inputDoc) throws XSLTransformException {\n        JDOMSource source = new JDOMSource(inputDoc);\n        JDOMResult result = new JDOMResult();\n        try {\n            templates.newTransformer().transform(source, result);\n            return result.getDocument();\n        }\n        catch (TransformerException e) {\n            throw new XSLTransformException(\"Could not perform transformation\", e);\n        }\n    }\n",
    "173811": "    public Namespace getNamespace() {\n        return namespace;\n    }\n",
    "173812": "  public Document getDocument() {\n    Object   src = ((JDOMInputSource)getInputSource()).getSource();\n    Document doc = null;\n\n    if (src instanceof Document) {\n      doc = (Document)src;\n    }\n    return doc;\n  }\n",
    "173813": "  public void setResult(List result) {\n    this.result  = result;\n    this.queried = false;\n  }\n",
    "173814": "  public void setNodes(List source) {\n    super.setInputSource(new JDOMInputSource(source));\n  }\n",
    "173815": "    public Attribute setNamespace(Namespace namespace) {\n        if (namespace == null) {\n            namespace = Namespace.NO_NAMESPACE;\n        }\n\n        // Verify the attribute isn't trying to be in a default namespace\n        // Attributes can't be in a default namespace\n        if (namespace != Namespace.NO_NAMESPACE &&\n            namespace.getPrefix().equals(\"\")) {\n            throw new IllegalNameException(\"\", \"attribute namespace\",\n                \"An attribute namespace without a prefix can only be the \" +\n                \"NO_NAMESPACE namespace\");\n        }\n        this.namespace = namespace;\n        return this;\n    }\n",
    "173816": "  public List getNodes() {\n    Object   src   = ((JDOMInputSource)getInputSource()).getSource();\n    List     nodes = null;\n\n    if (src instanceof List) {\n      nodes = (List)src;\n    }\n    return nodes;\n  }\n",
    "173817": "  public List getResult() {\n    List nodes = Collections.EMPTY_LIST;\n\n    // Retrieve result from the document builder if not set.\n    this.retrieveResult();\n\n    if (result instanceof List) {\n      nodes = (List)result;\n    }\n    else {\n      if ((result instanceof Document) && (queried == false)) {\n        List content = ((Document)result).getContent();\n        nodes = new ArrayList(content.size());\n\n        while (content.size() != 0)\n        {\n          Object o = content.remove(0);\n          nodes.add(o);\n        }\n        result = nodes;\n      }\n    }\n    queried = true;\n\n    return (nodes);\n  }\n",
    "173821": "  public void setDocument(Document document) {\n    this.result  = document;\n    this.queried = false;\n  }\n",
    "173823": "    public Attribute setValue(String value) {\n        String reason = null;\n        if ((reason = Verifier.checkCharacterData(value)) != null) {\n            throw new IllegalDataException(value, \"attribute\", reason);\n        }\n        this.value = value;\n        return this;\n    }\n",
    "173824": "  public XMLReader getXMLReader() {\n    if (this.xmlReader == null) {\n      this.xmlReader = new DocumentReader();\n    }\n    return this.xmlReader;\n  }\n",
    "173825": "  public Document getDocument() {\n    Document doc = null;\n\n    // Retrieve result from the document builder if not set.\n    this.retrieveResult();\n\n    if (result instanceof Document) {\n      doc = (Document)result;\n    }\n    else {\n      if ((result instanceof List) && (queried == false)) {\n        // Try to create a document from the result nodes\n        try {\n          JDOMFactory f = this.getFactory();\n          if (f == null) { f = new DefaultJDOMFactory(); }\n\n          doc = f.document(null);\n          doc.setContent((List)result);\n\n          result = doc;\n        }\n        catch (RuntimeException ex1) {\n          // Some of the result nodes are not valid children of a\n          // Document node. => return null.\n        }\n      }\n    }\n    queried = true;\n\n    return (doc);\n  }\n",
    "173827": "    public int getAttributeType() {\n        return type;\n    }\n",
    "173828": "  public void setFactory(JDOMFactory factory) {\n    this.factory = factory;\n  }\n",
    "173830": "    public Attribute setAttributeType(int type) {\n        if ((type < UNDECLARED_TYPE) || (type > ENUMERATED_TYPE)) {\n            throw new IllegalDataException(String.valueOf(type),\n                                        \"attribute\", \"Illegal attribute type\");\n        }\n        this.type = type;\n        return this;\n    }\n",
    "173831": "  public JDOMFactory getFactory() {\n    return this.factory;\n  }\n",
    "173832": "    public Reader getCharacterStream() {\n      Object src    = this.getSource();\n      Reader reader = null;\n\n      if (src instanceof Document) {\n        // Get an in-memory string representation of the document\n        // and return a reader on it.\n        reader = new StringReader(\n                            new XMLOutputter().outputString((Document)src));\n      }\n      else {\n        if (src instanceof List) {\n          reader = new StringReader(\n                            new XMLOutputter().outputString((List)src));\n        }\n        // Else: No source, no reader!\n      }\n      return reader;\n    }\n",
    "173833": "    public void parse(String systemId) throws SAXNotSupportedException {\n      throw new SAXNotSupportedException(\n                       \"Only JDOM Documents are supported as input\");\n    }\n",
    "173834": "  private void retrieveResult() {\n    if (result == null) {\n      this.setResult(((DocumentBuilder)this.getHandler()).getResult());\n    }\n  }\n",
    "173835": "    public String toString() {\n        return new StringBuffer()\n            .append(\"[Attribute: \")\n            .append(getQualifiedName())\n            .append(\"=\\\"\")\n            .append(value)\n            .append(\"\\\"\")\n            .append(\"]\")\n            .toString();\n    }\n",
    "173836": "    public void parse(InputSource input) throws SAXException {\n      if (input instanceof JDOMInputSource) {\n        try {\n          Object source = ((JDOMInputSource)input).getSource();\n          if (source instanceof Document) {\n            this.output((Document)source);\n          }\n          else {\n            this.output((List)source);\n          }\n        }\n        catch (JDOMException e) {\n          throw new SAXException(e.getMessage(), e);\n        }\n      }\n      else {\n        throw new SAXNotSupportedException(\n                         \"Only JDOM Documents are supported as input\");\n      }\n    }\n",
    "173838": "    public Object clone() {\n        Attribute attribute = null;\n\n        try {\n            attribute = (Attribute) super.clone();\n        } catch(CloneNotSupportedException ce) {\n            // Won't happen\n        }\n\n        // Name, namespace, and value are references to imutable objects\n        // and are copied by super.clone() (aka Object.clone())\n\n        // super.clone() copies reference to set parent to null\n        attribute.parent = null;\n        return attribute;\n    }\n",
    "173839": "    public void visitLCMP(LCMP o){\n        if (stack().peek() != Type.LONG){\n            constraintViolated(o, \"The value at the stack top is not of type 'long', but of type '\"+stack().peek()+\"'.\");\n        }\n        if (stack().peek(1) != Type.LONG){\n            constraintViolated(o, \"The value at the stack next-to-top is not of type 'long', but of type '\"+stack().peek(1)+\"'.\");\n        }\n    }\n",
    "173841": "    public int getIntValue() throws DataConversionException {\n        try {\n            return Integer.parseInt(value.trim());\n        } catch (NumberFormatException e) {\n            throw new DataConversionException(name, \"int\");\n        }\n    }\n",
    "173842": "    public void setFormat(Format newFormat) {\n        this.userFormat = (Format) newFormat.clone();\n        this.currentFormat = userFormat;\n    }\n",
    "173843": "    public List getResult() {\n      // Flush remaining text content in case the last text segment is\n      // outside an element.\n      try {\n        this.flushCharacters();\n      }\n      catch (SAXException e) { /* Ignore... */  }\n      return this.getDetachedContent(dummyRoot);\n    }\n",
    "173844": "    public long getLongValue() throws DataConversionException {\n        try {\n            return Long.parseLong(value.trim());\n        } catch (NumberFormatException e) {\n            throw new DataConversionException(name, \"long\");\n        }\n    }\n",
    "173845": "    private List getDetachedContent(Element elt) {\n      List content = elt.getContent();\n      List nodes   = new ArrayList(content.size());\n\n      while (content.size() != 0)\n      {\n        Object o = content.remove(0);\n        nodes.add(o);\n      }\n      return (nodes);\n    }\n",
    "173846": "    public float getFloatValue() throws DataConversionException {\n        try {\n            // Avoid Float.parseFloat() to support JDK 1.1\n            return Float.valueOf(value.trim()).floatValue();\n        } catch (NumberFormatException e) {\n            throw new DataConversionException(name, \"float\");\n        }\n    }\n",
    "173847": "    public Format getFormat() {\n        return (Format) userFormat.clone();\n    }\n",
    "173848": "    public List getResult() {\n      List result = null;\n\n      if (this.saxHandler != null) {\n        // Retrieve result from SAX content handler.\n        result = this.saxHandler.getResult();\n\n        // Detach the (non-reusable) SAXHandler instance.\n        this.saxHandler = null;\n\n        // And get ready for the next transformation.\n        this.startDocumentReceived = false;\n      }\n      return result;\n    }\n",
    "173849": "    public double getDoubleValue() throws DataConversionException {\n        try {\n            // Avoid Double.parseDouble() to support JDK 1.1\n            return Double.valueOf(value.trim()).doubleValue();\n        } catch (NumberFormatException e) {\n            throw new DataConversionException(name, \"double\");\n        }\n    }\n",
    "173850": "    public void visitLCONST(LCONST o){\n        // Nothing to do here.\n    }\n",
    "173853": "    public boolean getBooleanValue() throws DataConversionException {\n        String valueTrim = value.trim();\n        if ((valueTrim.equalsIgnoreCase(\"true\")) ||\n            (valueTrim.equalsIgnoreCase(\"on\")) ||\n            (valueTrim.equalsIgnoreCase(\"1\")) ||\n            (valueTrim.equalsIgnoreCase(\"yes\"))) {\n            return true;\n        } else if ((valueTrim.equalsIgnoreCase(\"false\")) ||\n                   (valueTrim.equalsIgnoreCase(\"off\")) ||\n                   (valueTrim.equalsIgnoreCase(\"0\")) ||\n                   (valueTrim.equalsIgnoreCase(\"no\"))) {\n            return false;\n        } else {\n            throw new DataConversionException(name, \"boolean\");\n        }\n    }\n",
    "173854": "    public void startDocument() throws SAXException {\n      this.startDocumentReceived = true;\n\n      // Reset any previously set result.\n      setResult(null);\n\n      // Create the actual JDOM document builder and register it as\n      // ContentHandler on the superclass (XMLFilterImpl): this\n      // implementation will take care of propagating the LexicalHandler\n      // events.\n      this.saxHandler = new FragmentHandler(getFactory());\n      super.setContentHandler(this.saxHandler);\n\n      // And propagate event.\n      super.startDocument();\n    }\n",
    "173860": "    public void push(Namespace ns) {\n        prefixes.push(ns.getPrefix());\n        uris.push(ns.getURI());\n    }      \n"
}
