{
    "321": "\tpublic int getPushesLowerbound() {\n\t\treturn pushesLowerbound;\n\t}\n",
    "323": "\tpublic void setPushesLowerbound(int pushesLowerbound) {\n\t\tthis.pushesLowerbound = pushesLowerbound;\n\t}\n",
    "324": "\t\tpublic void play() {\n\t\t\t\n\t\t\t// If no sound file is there nothing can be played.\n\t\t\tif(currentSoundFilename.equals(\"\"))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// Check if the this sound must be read from another file (the user has\n\t\t\t// chosen another sound to be played).\n\t\t\tString settingsFileName = Settings.get(soundSettingsKey);\n\t\t\tif(!currentSoundFilename.equals(settingsFileName)) {\n\t\t\t\tloadClip(settingsFileName);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Stop the currently playing sound to play the new sound if necessary.\n\t\t\tif (clip.isRunning()) {\n\t\t\t\tclip.stop();\n\t\t\t}\n\t\t\t\n\t\t\t// Rewind to the beginning.\n\t\t\tclip.setFramePosition(0); \n\t\t\t\n\t\t\t// Start playing.\n\t\t\tclip.start();    \n\t\t}\n",
    "343": "\tpublic int getInfluenceValue(int boxNo1, int boxNo2) {\n\t\treturn influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),\n\t\t\t\t                               board.boxData.getBoxPosition(boxNo2) );\n\t}\n",
    "351": "\tpublic void setPositions(int[] positions){\n\t\tthis.positions = positions;\n\t}\n",
    "352": "\tpublic int getPlayerPosition() {\n\t\treturn positions[positions.length-1];\n\t}\n",
    "355": "\tpublic int getPulledBoxNumber() {\n\t\treturn pulledBoxNo;\n\t}\n",
    "357": "\tpublic int getStartBoxPosition() {\n\t\treturn startPosition;\n\t}\n",
    "359": "\tpublic int getTargetBoxPosition() {\n\t\treturn targetPosition;\n\t}\n",
    "361": "    public BoardPositionPackingSequence getPrecedingBoardPosition() {\n    \treturn precedingBoardPosition;\n    }\n",
    "364": "\tpublic int compareTo(BoardPositionPackingSequence boardPosition) {\n\t\treturn boardPosition.getRelevance() - getRelevance();\n\t}\n",
    "373": "\tpublic boolean isForcedPush() {\n\t\treturn isPushForced;\n\t}\n",
    "376": "\tfinal public void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "412": "\tpublic boolean isSolverStoppedDueToOutOfMemory() {\n\t\treturn isSolverStoppedDueToOutOfMemory;\n\t}\n",
    "428": "    final protected IBoardPositionMoves getBestBoardPosition(){\n\n\t\t// Nimmt die Liste aller Stellungen mit einer bestimmten L\u00f6sungspfadl\u00e4nge auf\n\t\tLinkedList<IBoardPositionMoves> boardPositionList;\n\t\t\n\t\tfor(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {\n\t\t\n\t\t\t// Liste der Stellungen mit der aktuellen Pfadl\u00e4nge holen. \n\t\t\tboardPositionList = boardPositionQueue.get(solutionLength);\n\t\t\t\n\t\t\tif(boardPositionList.size() > 0){\t \n\t\t\t    shortestSolutionPathLength = solutionLength;\n\t\t\t    \n\t\t\t\t// Die zuletzt eingef\u00fcgte Stellung zur\u00fcckgeben\n\t    \t\treturn boardPositionList.removeLast();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "437": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn precedingBoardPosition;\n\t}\n",
    "440": "\tfinal public int getDirection() {\n\t\treturn positionData >>> 13;\n\t}\n",
    "442": "\tpublic int getBoxNo() {\n\t\treturn positionData & ((1 << 10) - 1);\n\t}\n",
    "445": "\tprotected String creatorName() {\n\t\treturn Texts.getText(\"solver\");\n\t}\n",
    "446": "\tfinal public int getPlayerPosition() {\n\t\treturn playerPosition;\n\t}\n",
    "448": "\tfinal public void setPositions(int[] positions) {\n\t\tthis.positions = positions;\n\t}\n",
    "450": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn null;\n\t}\n",
    "454": "\tfinal public void setSearchDirection(SearchDirection searchDirection) {\n\n\t\tif (searchDirection == SearchDirection.FORWARD) {\n\t\t\tforwardsSearch  = true;\n\t\t} else {\n\t\t\tbackwardsSearch = true;\n\t\t}\n\t}\n",
    "458": "\tfinal public int getDirection() {\n\t\treturn 0;\n\t}\n",
    "459": "\tpublic int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (BoardPosition currentBoardPosition = this; currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition()) {\n\t\t\tif (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn pushesCount;\n\t}\n",
    "461": "\tfinal public int getBoxNo() {\n\t\treturn NO_BOX_PUSHED;\n\t}\n",
    "463": "\tpublic void setMaximumSolutionLength(short maximumSolutionLength) {\n\t\tmaximumPushesCurrentIteration = maximumSolutionLength;\n\t}\n",
    "464": "\tfinal public int getPlayerPosition() {\n\t\treturn positions[boxCount];\n\t}\n",
    "466": "\tpublic short getMaximumSolutionLength() {\n\t\treturn maximumPushesCurrentIteration;\n\t}\n",
    "467": "\tfinal public int getPushesCount() {\n\t\treturn 0;\n\t}\n",
    "472": "\tprotected String solutionByMeAt(Date date) {\n\t\treturn  Texts.getText(\"createdBy\")\n\t\t      + \" \" + creatorName()\n\t\t      + \" \" + Utilities.dateString(date);\n\t}\n",
    "476": "\tfinal public void setMovesCount(int movesCount) {\n\t\tthis.movesCount = (short) movesCount;\n\t}\n",
    "487": "\tpublic int getIndexPackingSequence() {\n\t\treturn indexPackingSequence;\n\t}\n",
    "489": "\tpublic void setIndexPackingSequence(int indexPackingSequence) {\n\t\tthis.indexPackingSequence = indexPackingSequence;\n\t}\n",
    "494": "\tprotected boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "496": "\tfinal public boolean isBoxInactive() {\n\t\treturn (positionData & INACTIVE_BOX) > 0;\n\t}\n",
    "497": "\tpublic void setCorralDeadlock() {\n\t\tisDeadlock = true;\n\t}\n",
    "498": "\tpublic void setNotCorralDeadlock() {\n\t\tisNotDeadlock = true;\n\t}\n",
    "499": "\t\tpublic boolean getValue() {\n\t\t\t/*\n\t\t\t * Since we here are inside of class Settings, we should not get\n\t\t\t * an IllegalAccessException.\n\t\t\t * Hence, we catch the exceptions here, and return false,\n\t\t\t * just in case.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\treturn field.getBoolean(null);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "500": "\tprotected String solutionByMeNow() {\n\t\treturn solutionByMeAt(null);\n\t}\n",
    "501": "\tpublic void setCorralNo(int corralNo) {\n\t\tthis.corralNo = corralNo;\n\t}\n",
    "503": "\tpublic void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "504": "\tpublic int getCorralNo() {\n\t\treturn corralNo;\n\t}\n",
    "506": "\tpublic boolean isCorralDeadlock() {\n\t\treturn isDeadlock;\n\t}\n",
    "507": "\tpublic boolean isNotCorralDeadlock() {\n\t\treturn isNotDeadlock;\n\t}\n",
    "508": "\tpublic boolean isClassified() {\n\t\treturn isDeadlock || isNotDeadlock;\n\t}\n",
    "510": "\tpublic boolean isBeeingAnalyzed() {\n\t\treturn !isDeadlock && !isNotDeadlock;\n\t}\n",
    "513": "\tpublic CBoard getClone() {\n\t\treturn new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);\n\t}\n",
    "514": "\t\tpublic void setValue(boolean value) {\n\t\t\t/*\n\t\t\t * Regarding exceptions see comment in \"getValue\"\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tfield.setBoolean(null, value);\n\t\t\t\tSystem.out.println(\"Setting: DebugVar: \"+field.getName()+\" set to \"+value);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// well... forget it.\n\t\t}\n",
    "517": "\tprivate boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {\n\t\t\n\t\tint indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;\n\t\t\n\t\t// Compare byte by byte of both box configurations.\n\t\tfor(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {\n\t\t\tif (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n",
    "523": "\tpublic int getMaxCapacity() {\n\t\treturn maxCapacity;\n\t}\n",
    "524": "\tpublic void add(int boardPositionIndex, int boardPositionPredecessor) {\n\t\t\n\t\t// The moves queue also contains an arbitrary number of span markers.\n\t\t// Therefore after every added board position there must be done\n\t\t// a check whether the memory block is already full.\n\t\tadd(boardPositionIndex      );\n\t\tadd(boardPositionPredecessor);\n\t}\n",
    "531": "\tpublic void jumpOverBoardPosition(int boardPosition) {\n\t\n\t\t// \"Remove\" all values from the queue which are equal to the passed one\n\t\t// FFS/hm: does the caller guarantee that the Q cannot become empty by this?\n\t\twhile(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {\n\t\t\tremoveBoardPosition();\n\t\t}\n\t}\n",
    "535": "\tpublic int removeLastBoardPosition() {\n\t\t\t\t\t\t\n\t\tif(nextIndexToWrite == 0) {\n\t\t\t\n\t\t\t// The previous memory block becomes the new current memory block.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\n\t\t}\n\t\t\n\t\treturn memoryBlockToWrite.memory[--nextIndexToWrite];\n\t}\n",
    "538": "\tpublic void jumpXBoardPositionsBackwards(int jumpCount) {\n\t\t\n\t\twhile(jumpCount > nextIndexToWrite) {\n\t\t\t\t\t\t\t\n\t\t\t// Assign the previous memory block of the queue.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\t\n\t\t\tjumpCount -= nextIndexToWrite;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\t\t\t\t\t\n\t\t}\n\t\tnextIndexToWrite -= jumpCount;\n\t}\n",
    "542": "\tpublic boolean isEmpty() {\n\t\t// This method is only called for the moves queue which has recycling activated.\n\t\treturn memoryBlockToRead == memoryBlockToWrite\n\t\t    && nextIndexToRead   == nextIndexToWrite;\n\t}\n",
    "547": "\tpublic boolean isGenerationStoppedDueToFullStorage() {\n\t\treturn generationStoppedDueToFullStorage;\n\t}\n",
    "551": "\tpublic int getBoxConfigurationNumber() {\n\t\treturn uniqueBoxConfigurationNumber;\n\t}\n",
    "561": "\tpublic boolean isBetterMovesPushesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( movesCount , other.movesCount,\n\t\t                                   pushesCount, other.pushesCount )\n\t\t     < 0 ;\n\t}\n",
    "563": "\tpublic boolean isBetterPushesMovesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( pushesCount, other.pushesCount,\n\t\t                                   movesCount , other.movesCount  )\n\t\t     < 0 ;\n\t}\n",
    "568": "\tpublic void add(OptimizerBoardPosition boardPosition) {\n\n\t\t// Ensure that a real board position has been passed.\n        if (boardPosition == null)\n            throw new NullPointerException();\n\t\t\n\t\t// Double the size of the queue if it is full.\n\t\tif (count >= queue.length) {\n\t\t\tqueue = Arrays.copyOf(queue, queue.length * 2);\t\n\t\t}\t\t\n\t\t\n\t\t// Add the new value at the correct position. \n\t\tsiftUp(count, boardPosition);\n\t\t\n\t\t// One more board position has been stored => increase the counter.\n\t\tcount++;\n\t}\n",
    "570": "\tpublic int size() {\n\t\treturn count;\n\t}\n",
    "572": "\tpublic OptimizerBoardPosition removeFirst() {\n\n\t\tif (count == 0)\n\t\t\treturn null;\n\n\t\t// The head of the queue must be returned.\n\t\tOptimizerBoardPosition result = queue[0];\n\t\t\n\t\t// The head of the queue has (logically) been removed => adjust the size.\n\t\t--count;\n\t\t\n\t\t// Remove the last board position.\n\t\tOptimizerBoardPosition x = queue[count];\n\t\tqueue[count] = null;\n\t\t\n\t\t// If there is at least one board position left in the queue then \n\t\t// shift the board positions so the queue has a new head.\n\t\tif (count != 0)\n\t\t\tsiftDown(0, x);\n\n\t\treturn result;\n\t}\n",
    "576": "\tprivate void addLogTextStyle(final String text, final String stylename) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tStyledDocument doc = optimizerLog.getStyledDocument(); \n\t\t\t\t\tdoc.insertString(doc.getLength(), text+\"\\n\", doc.getStyle(stylename));\t\t\t\n\t\t\t\t} catch (BadLocationException e) {\t/* ignore */ }\n\t\t\t}\n\t\t});\n\t}\n",
    "577": "\t private void siftDown(int position, OptimizerBoardPosition boardPosition) {\n\t\t \n\t\t // Calculate the half of the size as the maximum position the loop must go to.\n\t\t int half = count >>> 1;        \n\t\t \n\t\t while (position < half) {\n\t\t\t int childIndex = (position << 1) + 1; // assuming the left child is the \"better\" board position\n\t\t\t OptimizerBoardPosition child = queue[childIndex];\n\t\t\t int rightChildIndex = childIndex + 1;\n\t\t\t if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)\n\t\t\t\t child = queue[childIndex = rightChildIndex];\n\t\t\t if (boardPosition.compareTo(child) <= 0)\n\t\t\t\t break;\n\t\t\t queue[position] = child;\n\t\t\t position = childIndex;\n\t\t }\n\t\t \n\t\t queue[position] = boardPosition;\n\t }\n",
    "580": "\tpublic int getNumberOfStoredBoardPositions() {\n\t\treturn count.get();\n\t}\n",
    "601": "\tpublic void removeAllMarkings() {\n\t\tmarkedSquares = null;\n\t}\n",
    "608": "\tpublic void showDeadlockQueryStats() {\n\t\tdlqTotStats.sumFrom(dlqCurStats);\n\t\tif ( ! dlqTotStats.equals(dlqCurStats)) {\n\t\t\tshow1DLQStats(\"total\", dlqTotStats, 0);\n\t\t}\n\t\t\n\t\tshow1DLQStats(\"this time\", dlqCurStats, dlqTotStats.dlqAsked);\n\t\tdlqCurStats.clear();\n\t}\n",
    "610": "\tprivate int getBoxConfigurationIndex(int boardPositionIndex) {\n\t\t// The board position may just been locked by another thread. However,\n\t\t// this method is only called for already completely stored board positions.\n\t\t// Hence, the index can't hold just the \"LOCKED\" value but must\n\t\t// always also contain a valid box configuration index.\n\t\treturn table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); \n\t}\n",
    "613": "\tfinal private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {\n\t\tfor (int i = 0; i < packedBoardByteSize; i++) {\n\t\t\tbyte b2 = boxConfigurationArray[indexInArray + i];\n\t\t\t// \"b2\" is a subset, if all its 1-bits survive the ANDing with the first byte\n\t\t\tif ((boxConfiguration1[i] & b2) != b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "617": "\tprivate int getPlayerPosition(int boardPositionIndex) {\n\t\t// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.\n\t\treturn table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;\n\t}\t\n",
    "619": "\t\tfinal private void doubleTreeSize() {\n\t\n\t\t\t// Double the tree size.\n\t\t\tint[] newArrayPointers = new int[2*2*treeSizeMax];\n\t\t\tSystem.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);\n\t\t\tarrayPointers = newArrayPointers;\n\t\n\t\t\tbyte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];\n\t\t\tSystem.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);\n\t\t\ttreeData = newArrayData;\n\t\n\t\t\ttreeSizeMax <<= 1;\n\t\t}\n",
    "626": "\t\tfinal private int treeToSortedListRecursively(int indexInTree, int last) {\n\t\n\t\t\t// If the end of the tree has been reached return the last index.\n\t\t\tif (indexInTree == -1) {\n\t\t\t\treturn last;\n\t\t\t}\n\t\n\t\t\t// Left side of the tree.\n\t\t\tint d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);\n\t\t\tsortedList[d++] = indexInTree;\n\t\n\t\t\t// Right side of the tree.\n\t\t\treturn (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));\n\t\t}\n",
    "637": "\tfinal public int getNumberOfSelectedObject() {\n\t\treturn currentlyMarkedObject;\n\t}\n",
    "638": "\t\tfinal private void binaryTreeToBinaryHeap() {\n\t\t\n\t\t\tbyte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];\n\t\t\n\t\t\tfor (int i=0, indexInVector = 0; i<treeSize; i++) {\n\t\t\t\tSystem.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);\n\t\t\t\tindexInVector += packedBoardByteSize;\n\t\t\t}\n\t\t\n\t\t\ttreeData = treeDataTemp;\n\t\t\tarrayPointers = null;\n\t\t}\n",
    "641": "\tfinal public void mouseWheelMoved(MouseWheelEvent evt) {\n\n\t\tint scrollDirection = evt.getWheelRotation();\n\n\t\t// Scrollen nach oben\n\t\tif (scrollDirection < 0 && currentlyMarkedObject > 0) {\n\t\t\tcurrentlyMarkedObject--;\n\t\t}\n\n\t\t// Scrollen nach unten\n\t\tif (scrollDirection > 0 && currentlyMarkedObject < 4) {\n\t\t\tcurrentlyMarkedObject++;\n\t\t}\n\n\t\tapplication.redraw(false);\n\t}\n",
    "643": "\tpublic void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {\n\t\t\n\t\t// Set/delete the \"processed\"-flag. This needn't to be done using compareAndSwap\n\t\t// because all of the other information stored at that offset have already been \n\t\t// stored and cannot change anymore while this method is executed.\n\t\tint currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);\n\t\tif(processedStatus == true)\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);\n\t\telse\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));\n\t}\n",
    "648": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * View on the levels\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "651": "\t\tprotected void finalize() {\n\t\t\tarrayPointers = null;\n\t\t\tsortedList = null;\n\t\t\ttreeData = null;\n\t\t}\n",
    "653": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * Language settings\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "656": "\tprivate void createPanel() {\n\t\t\n\t\tsetLayout(new BorderLayout());\n\n\t\tJPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));\n\t\tguiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));\n\n\t\t// Just a quick and dirty test coding ...\n\t\tNimRODFontDialog d = new NimRODFontDialog(null);\n\t\tComponent[] c = d.getContentPane().getComponents();\n\t\tguiPanel.add(c[0]);\n\t\t\n\t\tadd(guiPanel, BorderLayout.NORTH);\n\t}\n",
    "663": "\tprivate void updateElements() {\n\t\tfinal boolean selected = checkboxGUI.isSelected();\n\t\t\n\t\ttextfieldGUI.setEnabled(selected);\n\t\tlabelGUI.setEnabled(selected);\n\t}\n",
    "666": "\tpublic Double getValueAsDouble() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;\n\t}\n",
    "669": "\tpublic Integer getValueAsInteger() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;\n\t}\n",
    "670": "\tpublic void enterMeForTypeDate(JTable table) {\n\t\ttable.setDefaultRenderer(java.util.Date.class, this);\n\t}\n",
    "672": "\tpublic void addLevel(Level level) {\n\t\tdisplayedLevels.add(level);\n\t\tif (displayedLevels.size() < levelsPerPage) {\n\t\t\tlastLevelIndex = displayedLevels.size() - 1;\n\t\t} else {\n\t\t\tlastLevelIndex = levelsPerPage - 1;\n\t\t}\n\t}\n",
    "675": "\tpublic boolean isFieldActive() {\n\t\treturn textfieldGUI.isEnabled();\n\t}\n",
    "676": "\tpublic void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {\n\t\tfor(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {\n\t\t\taddLevel(collection.getLevel(levelNo));\n\t\t}\n\t}\n",
    "677": "\tpublic double setValue(double value) {\n\n\t\tdouble rc = value;\n\t\tif (value > maximumValue) {\n\t\t\trc = maximumValue;\n\t\t} else if (value < minimumValue) {\n\t\t\trc = minimumValue;\n\t\t} else {\n\t\t\trc = value;\n\t\t}\n\t\ttextfieldGUI.setValue(rc);\n\n\t\treturn rc;\t\t\n\t}\n",
    "684": "\tpublic void actionPerformed(ActionEvent actionevent) {\n\t\tif (actionevent.getActionCommand() == \"okbutton\") {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "685": "\tpublic void informAllUnsync(Generator<E> eventgen) {\n\t\t/*\n\t\t * We must not directly use (weakhashmap.keySet()), since it still\n\t\t * is coupled to the weakhashmap itself, which needs synchronization.\n\t\t * Hence we first must obtain a copy.\n\t\t */\n\t\tfor (L listener : getListenersCopy()) {\n\t\t\tfinal E evt = ((eventgen != null) ? eventgen.generate() : null);\n\t\t\tcaller.call(listener, evt);\n\t\t}\n\t}\n",
    "687": "\tpublic void setToStart() {\n\t\tsetTo(true);\n\t}\n",
    "688": "\tpublic void setToStop() {\n\t\tsetTo(false);\n\t}\n",
    "690": "\tprivate void setTo( boolean forStart ) {\n\t\tString textkey = (forStart ? startkey           : stopkey          );\n\t\tString action  = (forStart ? startActionCommand : stopActionCommand);\n\t\t\n\t\tsetText(Texts.getText( textkey ));\n\t\tsetActionCommand( action );\n\t\t\n\t\tsetupBorder(forStart);\n\t\tsetupBgColor(forStart);\n\t}\n",
    "693": "\tprivate void setupBorder(boolean forStart) {\n\t\tsetBorder( useBorder ? makeBorder(forStart) : null );\n\t}\n",
    "694": "\tprivate void setupBgColor(boolean forStart) {\n\t\tif (useBgColor) {\n\t\t\tint rgb = (forStart ? bgColorStart : bgColorStop);\n\t\t\t\n\t\t\tsetBackground( new Color(rgb) );\n\t\t\tsetOpaque(false);\n\t\t} else {\n\t\t\t// FFS/hm: should we actively put away a background color?\n\t\t}\n\t}\n",
    "696": "\tpublic Border makeBorder(boolean forStart) {\n\t\tint rgb = (forStart ? borderColorStart : borderColorStop);\n\t\treturn makeRgbBorder(rgb, useRoundedCorners);\n\t}\n",
    "697": "\tpublic Border makeStartBorder() {\n\t\treturn makeBorder(true);\n\t}\n",
    "699": "\tpublic Border makeStopBorder() {\n\t\treturn makeBorder(false);\n\t}\n",
    "703": "\tpublic void setUseBorder(boolean useBorder) {\n\t\tthis.useBorder = useBorder;\n\t}\n",
    "706": "\tpublic void setUseBgColor(boolean useBgColor) {\n\t\tthis.useBgColor = useBgColor;\n\t}\n",
    "710": "\tpublic void setBorderColorStart(int borderColorStart) {\n\t\tthis.borderColorStart = borderColorStart;\n\t}\n",
    "715": "\tpublic void setBorderColorStop(int borderColorStop) {\n\t\tthis.borderColorStop = borderColorStop;\n\t}\n",
    "718": "\tpublic void setBgColorStart(int bgColorStart) {\n\t\tthis.bgColorStart = bgColorStart;\n\t}\n",
    "721": "\tpublic void setBgColorStop(int bgColorStop) {\n\t\tthis.bgColorStop = bgColorStop;\n\t}\n",
    "722": "\tstatic private boolean isOutsideClip(int x, int y, int xlen, int ylen, Rectangle clip) {\n\n\t\t// Non-existing rectangle stands for the complete plane => nothing is outside of the complete plane.\n\t\t// We are \"outside\" of \"clip\", if we do not intersect with it.\n\t\treturn clip != null && ! clip.intersects(x, y, xlen, ylen);\n\t\t\n\t}\n",
    "741": "\tpublic boolean hasAlias() {\n\t\treturn (alias.length() > 0);\n\t}\n",
    "743": "\tpublic String getAlias() {\n\t\treturn alias;\n\t}\n",
    "746": "\tpublic void setAlias(String newAlias) {\n\t\talias = newAlias;\n\t}\n",
    "747": "\tpublic String getPath() {\n\t\treturn path;\n\t}\n",
    "750": "\tpublic String getName() {\n\t\tif (hasAlias()) {\n\t\t\treturn alias;\n\t\t}\n\t\treturn path;\n\t}\n",
    "752": "\tpublic String getDisplayName() {\n\t\tif (hasAlias()) {\n\t\t\treturn '[' + alias + ']';\n\t\t}\n\t\treturn path;\n\t}\n",
    "753": "\tprivate BufferedImage extractGraphicTwoCoordinates(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tPoint graphicCoordinates = getPoint(graphicName);\n\t\t\tif(graphicCoordinates != null) {\n\t\t\t\treturn entireGraphic.getSubimage(graphicCoordinates.x * graphicWidth,\n\t\t\t\t\t\t                         graphicCoordinates.y * graphicHeight,\n\t\t\t\t\t\t                         graphicWidth, graphicHeight);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "754": "\tpublic Color getColor() {\n\t\treturn color;\n\t}\n",
    "755": "\tpublic void setColor(String color) {\n\t\tthis.color = parseColor(color);\n\t}\n",
    "756": "\tpublic void setBoardToDisplay(Board board) {\n\n\t\t// Save the reference.\n\t\tthis.board = board;\n\n\t\t// Create new array for storing information about which positions have to be drawn when repainting.\n\t\tgraphicStatus = new byte[board.size];\n\n\t\t// Initialize the debug array used for showing numbers on the board.\n\t\tArrays.fill(numbersToShow, -1);\n\n\t\t// Reset the transformation of the board.\n\t\ttransformBoard(-1);\n\t}\n",
    "758": "\tpublic String getColorString() {\n\t\treturn colorToString(color);\n\t}\n",
    "759": "\tprivate BufferedImage extractGraphicOneCoordinate(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tint xCoordinate = getInt(graphicName, -1);\n\t\t\tif(xCoordinate == -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn entireGraphic.getSubimage(xCoordinate * graphicWidth, 0, graphicWidth, graphicHeight);\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "764": "\tprivate String trimValue(String propertyValue) {\n\t\n\t\tif (propertyValue == null || propertyValue.length() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\n\t\tint lastpos = propertyValue.indexOf('#');\n\t\tif (lastpos == -1) {\n\t\t\tlastpos = propertyValue.length() - 1;\n\t\t}\n\t\t\n\t\t\n\t\tfor(; lastpos >= 0 ; --lastpos ) {\n\t\t\tchar c = propertyValue.charAt(lastpos);\n\t\t\tif (c != ' ' && c != '\\t') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Now, \"lastpos\" indexes the last char to be retained (or -1 if there is none)\n\t\t\n\t\t// Return the trimmed value.\n\t\treturn propertyValue.substring(0, lastpos + 1);\n\t}\n",
    "772": "\tstatic public String getTransformationAsString() {\n\n\t\t// If the level isn't displayed transformed return an empty String.\n\t\tif (getRotationValue() == ROTATION_BY_0_DEGREES && isLevelFlippedHorizontally() == false) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Build the transformation string and return it.\n\t\tString transformationString = \"View: Rotated \"\n\t\t\t                        + getRotationAsString()\n\t\t\t                        + \" degrees clockwise\";\n\t\tif (isLevelFlippedHorizontally()) {\n\t\t\ttransformationString += \", flipped horizontally.\";\n\t\t} else {\n\t\t\ttransformationString += \".\";\n\t\t}\n\n\t\treturn transformationString;\n\t}\n",
    "774": "\tpublic T generate() {\n\t\treturn base;\n\t}\n",
    "779": "\tfinal private JButton createToolBarButton(String iconName, String actionCommand, String toolTipText) {\n\n\t\t// Create and initialize the button.\n\t\tJButton button = new JButton(Utilities.getIcon(iconName, null));\n\t\tbutton.setActionCommand(actionCommand);\n\t\tbutton.setToolTipText(toolTipText);\n\t\tbutton.addActionListener(this);\n\n\t\t// The buttons must be clicked with the mouse.\n\t\tbutton.setFocusable(false);\n\n\t\treturn button;\n\t}\n",
    "781": "\tpublic Skin getCurrentSkin() {\n\t\treturn skin;\n\t}\n",
    "784": "\tprivate String getString(String name, String ... defaultValue) {\n\t\n\t\t// Get the value of the property.\n\t\tString propertyValue = trimValue(properties.getProperty(name));\n\t\n\t\t// If the the property couldn't be found set the default value.\n\t\tif (propertyValue == null) {\n\t\t\tif(defaultValue.length > 0) {\n\t\t\t\treturn defaultValue[0];\n\t\t\t}\n\t\t}\n\t\n\t\treturn propertyValue;\n\t}\n",
    "785": "\tfinal private JButton createToolBarButtonByKey(String iconName, String actionCommand, String toolTipTextKey) {\n\t\tString toolTipText = Texts.getText(toolTipTextKey);\n\t\treturn createToolBarButton(iconName, actionCommand, toolTipText);\n\t}\n",
    "787": "\tpublic void setSkinAnimationDelay(int delay) {\n\n\t\t// Save the delay in the settings.\n\t\tSettings.set(\"skinAnimationDelay\", \"\" + delay);\n\n\t\t// If a timer is running set the new delay value.\n\t\tif (animationTimer != null && animationTimer.isRunning()) {\n\t\t\tanimationTimer.setDelay(delay);\n\t\t}\n\t}\n",
    "793": "\tpublic void setViewDirection(int viewDirection) {\n\t\tthis.viewDirection = (byte) viewDirection;\n\t}\n",
    "800": "\tpublic void setMaximumScalingFactor(int maximumScalingFactor) {\n\n\t\tmaximumScaling = maximumScalingFactor;\n\n\t\trecalculateGraphicSizes();\n\t\trepaint();\n\n\t\t// Save the zooming factor.\n\t\tSettings.set(\"maximumScaling\", \"\" + maximumScaling);\n\t}\n",
    "805": "\tpublic void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "806": "\tpublic void transformBoard(int transformationValue) {\n\n\t\t// Tell it to the Transformation class.\n\t\tTransformation.transform(transformationValue);\n\n\t\t// Since the transformation may have exchanged height and width, we force a\n\t\t// recalculation of the graphics, as if we had loaded a new level.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Show new graphics\n\t\trepaint();\n\t}\n",
    "808": "\tpublic void setLevelToDisplay(Level levelToBeDisplayed) {\n\t\t\n\t\t// Create an own board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Set the passed level on the board.\n\t\ttry {\n\t\t\tboard.setBoardFromString(levelToBeDisplayed.getBoardDataAsString());\n\t\t} catch (Exception e) {\n\t\t\t// Show the error message.\n\t\t\tUtilities.showExceptionError(this, e);\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "810": "\tpublic void setBoardToDisplay(String boardAsString) {\n\t\t\n\t\t// Create an new board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Create an own board from the board of the level.\n\t\ttry {\n\t\t\tboard.setBoardFromString(boardAsString);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "813": "\tpublic void setInfoBarVisible(boolean visibleStatus) {\n\t\tisInfoBarVisible = visibleStatus;\n\t}\n",
    "814": "\tpublic void setBoardToDisplay(Board board) {\n\t\t\n\t\tthis.board = board;\n\t\t\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "816": "\tpublic Board getBoard() {\n\t\treturn board;\n\t}\n",
    "819": "\tpublic Level getDisplayedLevel() {\n\t\treturn displayedLevel;\n\t}\n",
    "821": "\tpublic int getSquareWidth() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicWidth;\n\t}\n",
    "823": "\tpublic int getSquareHeight() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicHeight;\n\t}\n",
    "824": "\tfinal public void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "827": "\tprivate void setInitialBoardPosition() {\n\t\tboard      = boardInitial.boardElements.clone();\n\t\tplayerPosX = boardInitial.playerPositionX;\n\t\tplayerPosY = boardInitial.playerPositionY;\n\t}\n",
    "835": "\tpublic void paintImmediately() {\n\t\tpaintImmediately(0, 0, getWidth(), getHeight());\n\t}\n",
    "840": "\tprivate void packBoxConfiguration(byte[] newPackedBoxConfiguration, byte[] unpackedBoxConfiguration) {\n\n\t\tint bytePosition = 0, bitPosition = 0;\n\n\t\t// Loop over all internal box positions.\n\t\tfor (int i = 0; i < boxPositionsCount; i++) {\n\n\t\t\tbytePosition = i >> 3;\n\t\t\tbitPosition  = i & 7;\n\n\t\t\tif ((unpackedBoxConfiguration[boxInternalToExternalPosition[i]] & BOX) == BOX)\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] |= 1 << bitPosition;\n\t\t\telse\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] &= (255 - (1 << bitPosition));\n\t\t}\n\t}\n",
    "856": "\tprivate void setVisited(int boardPositionIndex) {\n\t\tint bytePosition = (boardPositionIndex >>> 3), bitPosition = (boardPositionIndex & 7);\n\t\tvisitedData[bytePosition] |= (1 << bitPosition);\n\t}\n",
    "863": "\tfinal public void setCursor(int cursor) {\n\n\t\t// Set the specified predefined cursor.\n\t\tmainBoardDisplay.setCursor(Cursor.getPredefinedCursor(cursor));\n\t}\n",
    "865": "\tprotected void adjustToBoard(Point p) {\n\t\t\n\t\t// Clip both point coordinates at their allowed minimum (inclusive).\n\t\tif( p.x < xOffset ) {\n\t\t\tp.x = xOffset;\n\t\t}\n\t\tif( p.y < yOffset ) {\n\t\t\tp.y = yOffset;\n\t\t}\n\t\t\n\t\t// Compute maximal point coordinates, inclusive...\n\t\tint xmax = xOffset + Transformation.getOutputLevelWidth()  * skin.graphicWidth  - 1;\n\t\tint ymax = yOffset + Transformation.getOutputLevelHeight() * skin.graphicHeight - 1;\n\t\t\n\t\t// ... and use them to clip off larger values:\n\t\tif( p.x > xmax ) {\n\t\t\tp.x = xmax;\n\t\t}\n\t\tif( p.y > ymax ) {\n\t\t\tp.y = ymax;\t\n\t\t}\n\t}\n",
    "866": "\tprivate void paintExtSqRect(int xmin, int ymin, int extWidth, int extHeight) {\n\t\tint pixXmin   = xOffset + xmin * skin.graphicWidth;\n\t\tint pixYmin   = yOffset + ymin * skin.graphicHeight;\n\t\tint pixWidth  =      extWidth  * skin.graphicWidth;\n\t\tint pixHeight =      extHeight * skin.graphicHeight;\n\t\t\n\t\tif (pixWidth > 0 || pixHeight > 0) {\n\t\t\trepaint(pixXmin, pixYmin, pixWidth, pixHeight);\n\t\t\tpaintMovesPushes();\n\t\t}\n\t}\n",
    "870": "\tpublic int getInfluenceDistance(int startSquare, int targetSquare) {\n\t\treturn influenceDistances[startSquare][targetSquare];\n\t}\n",
    "871": "\tfinal public void setNewLanguage() {\n\n\t\t// Create a new menu bar and and a new tool bar according to the new language.\n\t\tapplication.setJMenuBar(createMenuBar());\n\t\tcreateToolBar();\n\t}\n",
    "872": "\tprivate boolean isVisited(int boardPositionIndex) {\n\t\tint i = (boardPositionIndex >>> 3), j = (boardPositionIndex & 7);\n\t\treturn (visitedData[i] & (1 << j)) > 0;\n\t}\n",
    "874": "\tfinal public void addPlayerMove(int direction) {\n\t\taddMovement(direction, -1);\n\t}\n",
    "876": "\t\tpublic void clear() {\n\t\t\tminX = Integer.MAX_VALUE;\n\t\t\tmaxX = Integer.MIN_VALUE;\n\t\t\tminY = Integer.MAX_VALUE;\n\t\t\tmaxY = Integer.MIN_VALUE;\n\t\t}\n",
    "877": "\tfinal public HistoryElement getSuccessorMovement() {\n\t\tif (hasSuccessorMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( ++currentMovementNo );\n\t}\n",
    "878": "\tfinal public HistoryElement getPrecedingMovement() {\n\t\tif (hasPrecedingMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( currentMovementNo-- );\n\t}\n",
    "881": "\tfinal public HistoryElement getMovement(int movementNo) {\n\n\t\tif (movementNo < 0 || movementNo > movementHistory.size() - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get(movementNo);\n\t}\n",
    "882": "\tfinal public int getCurrentMovementNo() {\n\t\treturn currentMovementNo;\t\n\t}\n",
    "883": "\t\tpublic boolean isEmpty() {\n\t\t\treturn (minX > maxX) || (minY > maxY);\n\t\t}\n",
    "884": "\tfinal public int getMovementsCount() {\n\t\treturn movementHistory.size();\n\t}\n",
    "885": "\tfinal public int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (HistoryElement historyElement : movementHistory) {\n\t\t\tif (historyElement.pushedBoxNo != -1) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\t\treturn pushesCount;\n\t}\n",
    "889": "\tfinal public String getLURDString() {\n\t\treturn getLURDString(0, currentMovementNo);\n\t}\n",
    "890": "\t\tpublic void add(int x, int y) {\n\t\t\tminX = Math.min(minX, x);\n\t\t\tmaxX = Math.max(maxX, x);\n\t\t\tminY = Math.min(minY, y);\n\t\t\tmaxY = Math.max(maxY, y);\n\t\t}\n",
    "891": "\tfinal public String getLURDStringTotal() {\n\t\treturn getLURDString(0, getMovementsCount() - 1);\n\t}\n",
    "893": "\tfinal public void setHistoryToStart() {\n\t\tcurrentMovementNo = -1;\n\t}\n",
    "895": "\tfinal public void setMovementNo(int movementNo) {\n\t\tcurrentMovementNo = movementNo;\n\t}\n",
    "897": "\tfinal public void setStartOfCombinedMovement() {\n\t\tisStartOfCombinedMovement = true;\n\t}\n",
    "898": "\t\tpublic void addExternal(int externalPos) {\n\t\t\tif (externalPos != -1) {\n\t\t\t\tint externalWidth = Transformation.getOutputLevelWidth();\n\t\t\t\tint extX = externalPos % externalWidth;\n\t\t\t\tint extY = externalPos / externalWidth;\n\t\t\t\t\n\t\t\t\tadd(extX, extY);\n\t\t\t}\n\t\t}\n",
    "900": "\tfinal public void goToPrecedingMovement() {\n\t\tcurrentMovementNo--;\n\t}\n",
    "903": "\tfinal public void goToNextMovement() {\n\t\t++currentMovementNo;\n\t}\n",
    "904": "\t\tpublic void addInternal(int internalPos) {\n\t\t\tif (internalPos != -1) {\n\t\t\t\tint externalPos = Transformation.getExternalPosition(internalPos);\n\t\t\t\t\n\t\t\t\taddExternal(externalPos);\n\t\t\t}\n\t\t}\n",
    "905": "\tfinal public boolean hasPrecedingMovement() {\n\t\treturn currentMovementNo >= 0;\n\t}\n",
    "908": "\tfinal public boolean hasSuccessorMovement() {\n\t\treturn (currentMovementNo + 1) < movementHistory.size();\n\t}\n",
    "910": "\tprivate void paintMovesPushes() {\n\t\t// Moves and pushes are displayed as part of the history slider panel.\n\t\tif (historySliderPanel != null) {\n\t\t\t// We have to include the textual representation, as well as the graphical\n\t\t\t// slider representation.  That includes most of the area.\n\t\t\tint w = historySliderPanel.getWidth();\n\t\t\tint h = historySliderPanel.getHeight();\n\t\t\t\n\t\t\t// Redraw the slider. This needn't to be done immediately. Repaint is much\n\t\t\t// faster then paintImmediately.\n\t\t\thistorySliderPanel.repaint(0, 0, w, h);\n\t\t}\n\t}\n",
    "911": "\tfinal public int combinedLengthPreceding() {\n\t\tint steps = 0;\n\t\t\n\t\tfor( int mNo = currentMovementNo; mNo >= 0 ; --mNo ) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn steps;\n\t}\n",
    "913": "\tfinal public int combinedLengthSuccessor() {\n\t\tint steps = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\t++mNo;\n\t\t\t\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn steps;\n\t}\n",
    "915": "\tfinal public int countCombinedForward() {\n\t\tint starts = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\t++starts;\n\t\t\t} else if( starts == 0 ) {\n\t\t\t\t++starts;\n\t\t\t}\n\t\t\t++mNo;\n\t\t}\n\t\t\n\t\treturn starts;\n\t}\n",
    "918": "\tfinal public float averageLengthCombinedForward() {\n\t\tint len = getMovementsCount() - currentMovementNo;\n\t\tif( len <= 0 ) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tint cntcombined = countCombinedForward();\n\t\treturn (float)len / cntcombined;\n\t}\n",
    "932": "\tpublic boolean isABoxBeenMoved() {\n\t\treturn pushedBoxNo != -1;\n\t}\n",
    "939": "\tprivate MouseListener getMouseListener() {\n\t\treturn new MouseAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e) {\n\t\t\t\tif(e.getClickCount() > 1) {\n\t\t\t\t\tint index = locationToIndex(e.getPoint());\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// This action can be disabled (for instance when the solver is running).\n\t\t\t\t\t\tif(!isTakeSolutionAsHistoryEnabled) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSolution clickedSolution = (Solution) listModel.getElementAt(index);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the selected solution as new history in the game.\n\t\t\t\t\t\tapplication.takeSolutionForHistory(clickedSolution);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n",
    "941": "\tfinal public void setEditorMenuItemEnabled(boolean enabled) {\n\t\teditorMenuItem.setEnabled(enabled);\n\t}\n",
    "948": "\tfinal public JMenuItem getSaveLevelMenuItem() {\n\t\treturn saveLevelMenuItem;\n\t}\n",
    "954": "\tfinal public JButton getInfoButton() {\n\t\treturn infoButton;\n\t}\n",
    "960": "\tfinal public void setModeDependentObjectStatus() {\n\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component button : playModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isPlayModeActivated());\n\t\t\t\t}\n\n\t\t\t\tfor (AbstractButton button : editorModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isEditorModeActivated());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "966": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boardPositionIndex, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boardPositionIndex / playerSquaresCount);\n\t\tint playerPosition = boardPositionIndex % playerSquaresCount;\n\t\tdebugDisplayBoxConfiguration(temp, playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "969": "\tpublic void setSolutionColor(Solution solution, Color color) {\n\t\tif(color == null) {\n\t\t\tcoloredSolutions.remove(solution);\n\t\t} else {\n\t\t\tcoloredSolutions.put(solution, color);\n\t\t}\n\t}\n",
    "971": "\tfinal public void setSolverDependentObjectsEnabled(final boolean enabledStatus) {\n\t\t\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : solverModeDependentObjects) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "972": "\t\tpublic boolean isValidNewSolution() {\n\t\t\treturn this != INVALID_SOLUTION && this != DUPLICATE_SOLUTION;\n\t\t}\n",
    "973": "\tpublic void setAllSolutionsUncolored() {\n\t\tcoloredSolutions.clear();\n\t}\n",
    "974": "\tprivate void setSelectedViewRow(int viewrowindex) {\n\t\tif (       (viewrowindex >= 0)\n\t\t\t\t&& (tableModelSolutionData != null)\n\t\t\t\t&& (tableModelSolutionData.getRowCount() > 0)\n\t\t\t\t&& (tableSolutionData != null)) {\n\t\t\tListSelectionModel lsm = tableSolutionData.getSelectionModel();\n\t\t\tlsm.setSelectionInterval(viewrowindex, viewrowindex);\n\t\t}\n\t}\n",
    "976": "\tpublic void addActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.register(actionListener);\n\t}\n",
    "979": "\tprotected void showNoSolutionsSelected() {\n\t\tUtilities.showInfoNoteTextKey(getParent(), \"solutionList.noSolutionSelected\");\n\t}\n",
    "980": "\tpublic void removeActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.unregister(actionListener);\n\t}\n",
    "982": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boxConfigurationIndex, int playerPosition, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boxConfigurationIndex);\n\t\tdebugDisplayBoxConfiguration(temp,playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "984": "\tfinal public void setUndoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : undoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "985": "\t\tpublic void mouseDragged(MouseEvent evt) {\n\t\t\n\t\t\tif(isMouseDragged == false) {\n\t\t\t\n\t\t\t\tstartOfLastDrag = evt.getWhen();\n\t\t\t\t\n\t\t\t\t// Save the dragged status.\n\t\t\t\tisMouseDragged = true;\n\t\t\t}\n\t\t\t\n\t\t\tmousePressed(evt);\n\t\t}\t\t\n",
    "987": "\tprivate void informThemHere(final Solution solution, final String action) {\n\t\tactionListenerSet.informAllSync(makeActionGenerator(solution, action));\n\t}\n",
    "989": "\tprivate void informListeners(final Solution solution, final String action) {\n\t\n\t\t// The GUI should be updated in the EDT.\n\t\tif(SwingUtilities.isEventDispatchThread()) {\n\t\t\tinformThemHere(solution, action);\n\t\t}\n\t\telse {\n\t\t\t// Update the GUI before this thread continues. \n\t\t\ttry {\n\t\t\t\tSwingUtilities.invokeAndWait(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tinformThemHere(solution, action);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t} catch (InvocationTargetException e) { /* just continue */ }\n\t\t}\n\t}\n",
    "993": "\tpublic void setTakeSolutionAsHistoryVisible(boolean isVisible) {\n\t\tisTakeSolutionAsHistoryEnabled = isVisible;\n\t}\n",
    "996": "\tfinal public void setRedoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : redoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "1000": "\t\tpublic void addSolutionToBeHighlighted(Solution solution) {\n\t\t\thighlightedSolutions.put(solution, 10);\n\t\t\t\n\t\t\t// Inform this thread that new solutions are to be highlighted.\n\t\t\tsynchronized(this) {\n\t\t\t\tnotify();\n\t\t\t}\n\t\t}\n",
    "1002": "\t\tpublic void removeAllSolutionsToBeHighlighted() {\n\t\t\thighlightedSolutions.clear();\n\t\t}\n",
    "1006": "\t\tpublic Integer getHighlightIntensity(Solution solution) {\n\t\t\treturn highlightedSolutions.get(solution);\n\t\t}\n",
    "1014": "\tfinal public void setInvalidLevelModeDependentObjectsEnabled(boolean enabledStatus) {\n\n\t\tfor (Component component : invalidLevelModeDependentObjects) {\n\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t}\n\n\t\t// An invalid level can't have a movement history.\n\t\t// Hence, disable the undo/redo buttons.\n\t\tsetUndoButtonsEnabled(enabledStatus);\n\t\tsetRedoButtonsEnabled(enabledStatus);\n\n\t\t// Enable the editor menu item so the user can open the editor.\n\t\tsetEditorMenuItemEnabled(true);\n\t}\n",
    "1015": "\tpublic boolean isValidLastChanged() {\n\t\tif (lastChanged != null) {\n\t\t\tif (lastChanged.getTime() > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1025": "\tfinal public void setDebugMenuVisible(boolean isToBeVisible) {\n\t\tfor (Component component : debugModeDependentObjects) {\n\t\t\tcomponent.setVisible(isToBeVisible);\n\t\t}\n\t}\n",
    "1035": "\tpublic SolutionsGUI getSolutionsView() {\n\t\treturn solutionsGUI;\n\t}\n",
    "1041": "\tfinal public void update(String expression) {\n\n\t\ttry {\n\t\t\tStatement st = conn.createStatement();\n\n\t\t\t// Run the query.\n\t\t\tif (st.executeUpdate(expression) == -1) {\n\t\t\t\tSystem.out.println(\"db error: \" + expression);\n\t\t\t}\n\n\t\t\t// Close the Statement object.\n\t\t\tst.close();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n",
    "1046": "\tprivate void waitForDeadlockIdentification() {\n\t\ttry {\n\t\t\tif(deadlockIdentification.isAlive()) {\n\t\t\t\toptimizerGUI.setInfoText(Texts.getText(\"optimizer.waitingForDeadlockDetection\"));\n\t\t\t\tdeadlockIdentification.join();\n\t\t\t}\n\t\t} catch (InterruptedException e) {}\n\t}\n",
    "1049": "\tfinal public void saveLevel(Level level, String fileName) throws IOException {\n\n\t\t// Create a PrintWriter for writing the data to hard disk.\n\t\tPrintWriter levelFile = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));\n\n\t\t// Write the level data to the file.\n\t\twriteLevelToFile(level, levelFile);\n\n\t\t// Check the error status.\n\t\tboolean isFileSavingFailed = levelFile.checkError();\n\n\t\t// Close the file.\n\t\tlevelFile.close();\n\n\t\t// Throw exception in the case of an error.\n\t\tif (isFileSavingFailed) {\n\t\t\tthrow new IOException(Texts.getText(\"errorBySaving\"));\n\t\t}\n\t}\n",
    "1055": "\tfinal public int getSquareCharacter(int xPosition, int yPosition) {\n\n\t\t// Select the line by the Y coordinate\n\t\tif (yPosition < 0 || yPosition >= boardData.size()) {\n\t\t\treturn ' ';\n\t\t}\n\t\tfinal String line = boardData.get(yPosition);\n\t\t\n\t\t// The level lines need not be filled with spaces at the end.\n\t\t// Such a line may be shorter than the level width.\n\t\tif (xPosition < 0 || xPosition >= line.length()) {\n\t\t\treturn ' ';\n\t\t}\n\n\t\treturn line.charAt(xPosition);\n\t}\n",
    "1066": "\tprotected void refreshView() {\n\t\tactionPerformed(new ActionEvent(this, 0, \"refreshView\"));\n\t}\n",
    "1071": "\t\tpublic int getID() {\n\t\t\treturn ID;\n\t\t}\n",
    "1092": "\tprotected void updateComboBoxAuthors() {\n\t\t\n\t\t// Update all needed ComoboBoxes of this view.\n\t\tsuper.updateComboBoxAuthors(comboBoxAuthors, selectionAuthor);\n\t\t\n\t\t// When adding new items the combo boxes should not fire actions.\n\t\t// (If this isn't set the combo boxes refresh the views every time their content changes)\n\t\tdoNotFireActions = true;\n\t\t\n\t\t// The selection ComboBox's first item is always the wildcard \"*\".\n\t\tselectionAuthor.insertItemAt(new ComboBoxEntry(\"*\", 0), 0);\n\t\t\n\t\t// Set the wildcard as selected.\n\t\tselectionAuthor.setSelectedIndex(0);\n\t\t\n\t\t// Actions may be fired again.\n\t\tdoNotFireActions = false;\n\t}\n",
    "1097": "    protected void finalize() {\n    \tdatabaseViews.dispose();\n    \tdatabaseViews = null;\n    }\n",
    "1098": "    \tstatic public void authorsNamesChanged() {\n    \t\tfor(int i=0; i<changeInAuthorView.length; i++) {\n    \t\t\tchangeInAuthorView[i] = true;\n    \t\t}\n    \t}\n",
    "1100": "    \tstatic public void collectionNamesChanged() {\n    \t\tfor(int i=0; i<changeInCollectionView.length; i++) {\n    \t\t\tchangeInCollectionView[i] = true;\n    \t\t}\n    \t}\n",
    "1102": "    \tstatic public void changeInAssignmentView() {\n    \t\tfor(int i=0; i<changeInAssignmentView.length; i++) {\n    \t\t\tchangeInAssignmentView[i] = true;\n    \t\t}\n    \t}\n",
    "1103": "    \tstatic public void changeInLevelView() {\n    \t\tfor(int i=0; i<changeInLevelView.length; i++) {\n    \t\t\tchangeInLevelView[i] = true;\n    \t\t}\n    \t}\n",
    "1107": "    \tstatic public void resetUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = false;\n        \tchangeInCollectionView[view] = false;\n        \tchangeInAssignmentView[view] = false;\n        \tchangeInLevelView[view]      = false;\n    \t}\n",
    "1108": "    \tstatic public void setUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = true;\n        \tchangeInCollectionView[view] = true;\n        \tchangeInAssignmentView[view] = true;\n        \tchangeInLevelView[view]      = true;\n    \t}\n",
    "1114": "\tprotected void updateAdditionalInformation() {\n\t\tint firstSelectedRow = tableLevelData.convertRowIndexToModel(tableLevelData.getSelectionModel().getMinSelectionIndex());\n\t\tvalueChanged(new ListSelectionEvent(tableLevelData.getSelectionModel(), firstSelectedRow, firstSelectedRow, false));\n\t}\n",
    "1115": "\tfinal public int getNumberOfStoredBoardPositions() {\n\t\treturn count;\n\t}\n",
    "1120": "\tfinal public void clear() {\n\t\t// This code is similar to hash table.clear()\n\t\tEntry tab[] = table;\n\t\t\n\t\tfor (int index = tab.length; --index >= 0;) {\n\t\t\ttab[index] = null;\n\t\t}\n\t\tcount = 0;\n\t}\n",
    "1123": "\t\tpublic Object getBoardPosition() {\n\t\t\treturn boardPosition;\n\t\t}\n",
    "1125": "\tprotected Object getSelectedCollection() {\n\t\treturn selectionCollection.getSelectedItem();\n\t}\n",
    "1127": "\tprotected int bytesPerAtom() {\n\t\treturn (4);\n\t}\n",
    "1129": "\tprotected int bytesPerLine() {\n\t\treturn (72);\n\t}\n",
    "1135": "\t\tprotected int decodeLinePrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException {\n\t\t\treturn (bytesPerLine());\n\t\t}\n",
    "1138": "\t\tprotected void decodeAtom(PushbackInputStream aStream, OutputStream bStream, int l) throws IOException {\n\t\t\tthrow new IOException();\n\t\t}\n",
    "1144": "\t\tpublic byte decodeBuffer(String inputString)[] throws IOException {\n\t\t\tbyte    inputBuffer[] = new byte[inputString.length()];\n\t\t\tByteArrayInputStream inStream;\n\t\t\tByteArrayOutputStream outStream;\n\n\t\t\tinputBuffer = inputString.getBytes();\n\t\t\tinStream = new ByteArrayInputStream(inputBuffer);\n\t\t\toutStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(inStream, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1146": "\t\tpublic byte decodeBuffer(InputStream in)[] throws IOException {\n\t\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(in, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1150": "\tpublic void setStep(int msStep) {\n\t\tstepMillis = msStep;\n\t}\n",
    "1152": "\tpublic int getStep() {\n\t\treturn stepMillis;\n\t}\n",
    "1153": "\tpublic void setLength(int len) {\n\t\tintendedLength = len;\n\t}\n",
    "1155": "\tpublic int getLength() {\n\t\treturn intendedLength;\n\t}\n",
    "1157": "\tstatic public Delays makeDelayNormal() {\n\t\treturn makeDelayNormal(0);\n\t}\n",
    "1158": "\tstatic public Delays makeDelayNormal(int seqLength) {\n\t\treturn new Delays(Settings.delayValue, seqLength);\n\t}\n",
    "1159": "\tstatic public Delays makeDelayUndoRedo() {\n\t\treturn makeDelayUndoRedo(0);\n\t}\n",
    "1161": "\tprivate void saveButtonActionPerformed() {\n\n\t\t// Save properties to a file.\n\t\tsaveProperties(newLanguageProperties, getFilepathFromLanguageCode(newLanguageCode));\n\n\t\t// Make new backup copy of properties.\n\t\tlastSavedNewLanguageProperties = (Properties) newLanguageProperties.clone();\n\t}\n",
    "1162": "\tstatic public Delays makeDelayUndoRedo(int seqLength) {\n\t\treturn new Delays(Settings.delayValueUndoRedo, seqLength);\n\t}\n",
    "1163": "\tpublic void start() {\n\t\tif ( ! started ) {\n\t\t\tlastNow = System.currentTimeMillis();\n\t\t\tstarted = true;\n\t\t}\n\t}\n",
    "1164": "\tpublic void stop() {\n\t\tstarted = false;\n\t}\n",
    "1169": "\tprivate int effStepInt( boolean slowstep ) {\n\t\tfloat step = effStep(slowstep);\n\t\tint  istep = Math.round(step);\n\t\t\n\t\t// When we would tell a zero delay (or even less), but the original\n\t\t// intention was a positive delay, we shall return the smallest\n\t\t// possible positive value: 1.\n\t\tif( istep <= 0 ) {\n\t\t\tif( stepMillis > 0 ) {\n\t\t\t\tistep = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Never consider negative values\n\t\tif( istep < 0 ) {\n\t\t\tistep = 0;\n\t\t}\n\t\t\n\t\treturn istep;\n\t}\n",
    "1172": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start the backward search.\n\t\t\t\t\tbackwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\t}\n",
    "1173": "\tstatic public void main(String[] argv) {\n\n\t\t// Check for debug parameters.\n\t\tfor(String parameter : argv) {\n\t\t\tif(parameter.equalsIgnoreCase(\"-debug\")) {\n\t\t\t\tSettings.isDebugModeActivated = true;\t\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugSettings\")) {\n\t\t\t\tSettings.isSettingsDebugModeActivated = true;\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugTiming\")) {\n\t\t\t\tSettings.isTimingDebugModeActivated = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Save the information whether this program is started as \"web start application\".\n\t\tSettings.isStartedAsWebStartApplication =\n\t\t\t\t\t   (argv.length > 0 && argv[0].equals(\"-webstart\"))\n\t\t\t\t\t|| (argv.length > 1 && argv[1].equals(\"-webstart\"));\n\t\t\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew JSoko().startProgram();\n\t\t\t}\n\t\t});\n\t}\n",
    "1174": "\tpublic void sleep(boolean reassertIntr) {\n\t\tsleep(reassertIntr, false);\n\t}\n",
    "1177": "\tprivate char decryptCharcode(int c, int start, int end, int offset) {\n\t\t\n\t\tc+=offset;\n\t\tif(offset > 0 && c > end){\n\t\t\tc= (start+(c-end-1));\n\t\t}\n\t\telse if(offset < 0 && c < start){\n\t\t\tc= (end-(start-c-1));\n\t\t}\n\t\treturn (char) c;\n\t}\n",
    "1179": "\tprivate void restoreButtonActionPerformed(ActionEvent evt) {\n\t\tnewLanguageProperties = (Properties) lastSavedNewLanguageProperties.clone();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\trefreshTranslationTextAreas();\n\t}\n",
    "1183": "\tprotected void stateChanged() {\n\t\tChangeEvent e = new ChangeEvent(this);\n\t\tfor (ChangeListener listener : changeListeners) {\n\t\t\tlistener.stateChanged(e);\n\t\t}\n\t}\n",
    "1186": "\tpublic void addValueListener(ChangeListener listener) {\n\t\tchangeListeners.add(listener);\n\t}\n",
    "1188": "\tpublic double getValueAsDouble() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn (Double) currentValue;\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn ((Integer) currentValue).doubleValue();\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1189": "\tpublic int getValueAsInteger() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn ((Double) currentValue).intValue();\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn (Integer) currentValue;\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1193": "\tpublic void setMinRAMinMiB(long minRAMinMiB) {\n\t\tthis.minRAMinMiB = minRAMinMiB;\n\t}\n",
    "1194": "\tprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n\t\tif (minRAMinMiB >= 0) {\n\t\t\t// We are limited...\n\t\t\tif (size() >= 2) {\n\t\t\t\t// We are large enough to loose an entry...\n\t\t\t\tif (Utilities.getMaxUsableRAMinMiB() < minRAMinMiB) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1197": "\tpublic V getV(K key) {\n\t\treturn map.get(key);\n\t}\n",
    "1199": "\tpublic void add(K key, V value) {\n\t\tmap.put(key, value);\n\t}\n",
    "1200": "\tpublic void trimToSize() {\n\t\t// we cannot do anything useful, here\n\t}\n",
    "1215": "\tfinal public Object clone() {\n\t\treturn new BoxData(this);\n\t}\n",
    "1216": "\tfinal public void setBoxStartPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1218": "\tfinal public void setBoxPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1219": "\tfinal public void setBoxPositions(int[] newBoxPositions) {\n\n\t\t// We must use a copy of the the array!\n\t\t// The caller does not donate this object, he will continue\n\t\t// to use and modify that array, while we expect to own this array.\n\t\tboxPositions = newBoxPositions.clone();\n\t}\n",
    "1221": "\tfinal public void setBoxActive(int boxNo) {\n\t\tisBoxInactive[boxNo] = false;\n\t}\n",
    "1223": "\tfinal public void setBoxInactive(int boxNo) {\n\t\tisBoxInactive[boxNo] = true;\n\n\t\t// An inactive box cannot be part of a corral\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1224": "\tfinal public boolean isBoxActive(int boxNo) {\n\t\treturn isBoxInactive[boxNo] == false;\n\t}\n",
    "1225": "\tfinal public boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "1226": "\tfinal public void setBoxFrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = true;\n\t}\n",
    "1227": "\tpublic void setLevelForPlaying(int levelNo) {\n\t\tsetLevelForPlaying(currentLevelCollection.getLevel(levelNo));\n\t}\n",
    "1228": "\tfinal public boolean isBoxFrozen(int boxNo) {\n\t\treturn isBoxFrozen[boxNo];\n\t}\n",
    "1230": "\tfinal public void setBoxUnfrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = false;\n\t}\n",
    "1231": "\tfinal public void setBoxInCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = true;\n\t}\n",
    "1232": "\tfinal public void removeBoxFromCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1233": "\tfinal public boolean isBoxInCorral(int boxNo) {\n\t\treturn isBoxInCorral[boxNo];\n\t}\n",
    "1234": "\tfinal public int getBoxPosition(int boxNo) {\n\t\treturn boxPositions[boxNo];\n\t}\n",
    "1236": "\tfinal public boolean isEveryBoxOnAGoal() {\n\n\t\t// Check all boxes for \"on goal\"\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated boxes\n\t\t\tif (isBoxInactive(boxNo))\n\t\t\t\tcontinue;\n\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1237": "\tpublic int getBoxesOnGoalsCount() {\n\t\tint boxesOnGoalsCount = 0;\n\t\tfor(int boxNo=0; boxNo<boxCount; boxNo++) {\n\t\t\t// TODO: explain why inactive boxes are not ignored Answer: bad programming. this method\n\t\t\t// is only used when a new level is loaded and all boxes are active. Inactive boxes are\n\t\t\t// only there during deadlock detection. Nevertheless, I think it's better to check for \n\t\t\t// inactive boxes here, too. I will have a look at this at some time. \n\t\t\tif(board.isGoal(getBoxPosition(boxNo))) {\n\t\t\t\tboxesOnGoalsCount++;\n\t\t\t}\n\t\t}\n\t\treturn boxesOnGoalsCount;\n\t}\n",
    "1238": "\tfinal public boolean isEveryBoxOnABackwardGoal() {\n\n\t\tint[] backwardGoalPositions = board.getGoalPositionsBackward();\n\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tif (isBoxInactive(boxNo)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBox(backwardGoalPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1239": "\tfinal public boolean isEveryCorralBoxOnAGoal() {\n\n\t\t// check all boxes\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated and non-corral boxes\n\t\t\tif (isBoxInactive(boxNo) || isBoxInCorral(boxNo) == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1242": "\tfinal public void setAllBoxesNotFrozen() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tisBoxFrozen[boxNo] = false;\n\t\t}\n\t}\n",
    "1243": "\tpublic long length() {\n\t\treturn size;\n\t}\n",
    "1244": "\tpublic byte getAt(long lax) {\n\t\tif ((lax < 0) || (lax >= size)) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"lax=\"+lax+\",size=\"+size);\n\t\t}\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ]);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\treturn (arrvec[(int)blockno][(int)eleminx]);\n\t}\n",
    "1246": "\tpublic byte putAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] = val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] = val);\n\t}\n",
    "1248": "\tpublic byte orAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] |= val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] |= val);\n\t}\n",
    "1253": "\tpublic long getNumBitsAt( long bitlax, int totbits ) {\n\t\tif (totbits > 64 || totbits < 0) {\n\t\t\tthrow new java.lang.UnsupportedOperationException(\"bits=\"+totbits);\n\t\t}\n\t\t// asserted: 0 <= totbits <= 64\n\t\tlong result = 0;\n\t\t\n\t\tint  resoff = 0;\n\t\twhile (totbits > resoff) {\n\t\t\tint  toget  = totbits - resoff;\n\t\t\tbyte bitoff = (byte)(bitlax & 0x07);\t// [0..7]\n\t\t\tlong lax    = bitlax >>> 3;\n\n\t\t\tint bitlen = 8 - bitoff;\t\t// so many in this byte [1..8]\n\t\t\tif (bitlen > toget) {\n\t\t\t\tbitlen = toget;\n\t\t\t}\n\t\t\tlong v    = getAt(lax) & 0xffL;\n\t\t\tv      >>>= bitoff;\n\t\t\tv        &= (1L << bitlen) - 1;\n\n\t\t\tresult |= (v << resoff);\n\t\t\tresoff += bitlen;\n\t\t\tbitlax += bitlen;\n\t\t}\n\t\treturn result;\n\t}\n",
    "1257": "\tpublic void showMissingFileDialog(String filePath, int messageType) {\n\t\tJOptionPane.showMessageDialog(\n\t\t\t\tparent,\n\t\t\t\t\"File: \" + filePath + \" is missing!\",\n\t\t\t\t\"Error\",\n\t\t\t\tmessageType);\n\n\t\tif (messageType == JOptionPane.ERROR_MESSAGE) {\n\t\t\tsetBlankProject();\n\t\t}\n\t}\n",
    "1258": "\tpublic boolean isEmpty() {\n\t\treturn root == null;\n\t}\n",
    "1259": "\tpublic void clear() {\n\t\tthis.root      = null;\n\t\tthis.elemcount = 0;\n\t}\n",
    "1264": "\tprivate Properties loadPropertiesByFilename(String fileName) throws IOException {\n\n\t\t// Create new properties.\n\t\tProperties tempProp = new Properties();\n\n\t\t// Get input stream to the property file.\n\t\tInputStream inPropFile = Utilities.getInputStream(fileName);\n\t\t\n\t\ttry {\n\t\t\t// Load properties.\n\t\t\ttempProp.load(inPropFile);\n\t\t\t\n\t\t\t// Close file.\n\t\t\tinPropFile.close();\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\n\t\t// Return the read properties.\n\t\treturn tempProp;\n\n\t}\n",
    "1268": "\tprivate Properties loadPropertiesByLanguageCode(String languageCode) throws IOException {\n\n\t\t// Return the read properties.\n\t\treturn loadPropertiesByFilename(getFilepathFromLanguageCode(languageCode));\n\n\t}\n",
    "1275": "\tpublic V rd(long inx) {\n\t\treturn rd(root, MAX_DEP, inx);\n\t}\n",
    "1277": "\tprivate void paput(Inner<V> pa, byte painx, Node<V> nref) {\n\t\tif (pa == null) {\n\t\t\troot = nref;\n\t\t} else {\n\t\t\t// Store leaf where we found the null in the last step\n\t\t\tpa.iput(painx, nref);\n\t\t}\n\t}\n",
    "1278": "\tprivate void reloadGUI() {\n\t\tchangeLanguageComboBoxes();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\tloadLanguageTexts(HINT_LANGUAGE_COLUMN);\n\n\t\t// Set new and hint language combo boxes for default values.\n\t\tString language = (new Locale(Settings.get(\"newTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\n\t\tnewLanguageComboBox.setSelectedItem(language);\n\n\t\tlanguage = (new Locale(Settings.get(\"hintTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\t\thintLanguageComboBox.setSelectedItem(language);\n\n\t\t// By default select the first row of the table.\n\t\tif (table.getRowCount() > 0) {\n\t\t\ttable.changeSelection(0, NEW_LANGUAGE_COLUMN, false, false);\n\t\t}\n\t}\n",
    "1279": "\tpublic void redraw(boolean waitForEnter) {\n\n\t\t// Draw the new GUI.\n\t\tapplicationGUI.mainBoardDisplay.repaint();\n\n\t\t// For debugging purposes wait for \"Enter\"\n\t\tif (waitForEnter) {\n\t\t\tJDialog dialog = new JOptionPane(\"\").createDialog(null, \"Waiting for Enter\");\n\t\t\tdialog.setLocation(getX() + getWidth() + 45, getY() + 10);\n\t\t\tdialog.setVisible(true);\n\t\t\t// Beginners explanation: The above dialog is \"modal\", and hence freezes\n\t\t\t// all other graphics activity.  That way \"we wait\" by being frozen.\n\t\t\t// When \"setVisible(true)\" returns, the dialog is done!\n\t\t}\n\t}\n",
    "1281": "\tpublic V wr(long inx, V val) {\n\t\treturn wr(root, MAX_DEP, inx, val);\n\t}\n",
    "1283": "\tfinal public void removeBox(int position) {\n\t\tboxesArray[position] = false;\n\t}\n",
    "1287": "\tprivate void calculateLowerboundOfAllLevel() {\n\n\t\tfinal int maxLevelNo = currentLevelCollection.getNumberOfLevels();\n\t\tint[] lowerbounds = new int[1 + maxLevelNo];\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tsetLevelForPlaying(levelNo);\n\t\t\tlowerbounds[levelNo] = board.lowerbound.calculateLowerbound(SearchDirection.FORWARD);\n\t\t}\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tSystem.out.printf(\"Level: %3d  Name: %-60s Lowerbound: %3d \\n\",\n\t\t\t\t\tlevelNo, currentLevelCollection.getLevel(levelNo).getTitle(), lowerbounds[levelNo]);\n\t\t}\n\t}\n",
    "1290": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start a new forward search.\n\t\t\t\t\tforwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\n\t\t\t}\n",
    "1291": "\tfinal public void removeBoxByNumber(int boxNo) {\n\t\tboxesArray[boxData.getBoxPosition(boxNo)] = false;\n\t}\n",
    "1296": "\tpublic boolean isPlayModeActivated() {\n\t\treturn gameMode == GameMode.PLAY;\n\t}\n",
    "1300": "\tfinal public void removeBox(int x, int y) {\n\t\tboxesArray[x + width * y] = false;\n\t}\n",
    "1304": "\tpublic boolean isEditorModeActivated() {\n\t\treturn gameMode == GameMode.EDITOR;\n\t}\n",
    "1308": "\tfinal public void removeWall(int position) {\n\t\twallsArray[position] -= ((wallsArray[position] > 0) ? 1 : 0);\n\t}\n",
    "1313": "\tprivate void setInvalidLevelMode() {\n\t\tapplicationGUI.setInvalidLevelModeDependentObjectsEnabled(false);\n\t\tgameMode = GameMode.INVALID_LEVEL;\n\t}\n",
    "1319": "\tfinal public void removeWall(int x, int y) {\n\t\twallsArray[x + width * y] -= ((wallsArray[x + width * y] > 0) ? 1 : 0);\n\t}\n",
    "1344": "\tfinal public void removeGoal(int position) {\n\t\tgoalsArray[position] = false;\n\t}\n",
    "1373": "\tfinal public void removeGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = false;\n\t}\n",
    "1378": "\tpublic long firstInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(true, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1384": "\tpublic long lastInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(false, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1393": "\tfinal public void removePlayer() {\n\t\tplayerPosition = NO_PLAYER;\n\t}\n",
    "1453": "\tfinal public void setBox(int position) {\n\t\tboxesArray[position] = true;\n\t}\n",
    "1496": "    public String send(){\n        //do real logic\n        return (\"success\");\n    }\n",
    "1503": "\tfinal public void setBox(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t}\n",
    "1518": "\tprivate int nextLockId() {\n\t\tif (nextLockId==Integer.MAX_VALUE) nextLockId = Integer.MIN_VALUE;\n\t\treturn nextLockId++;\n\t}\n",
    "1519": "\tprivate void decrementLock(Object key, Lock lock) throws CacheException {\n\t\t//decrement the lock\n\t\tlock.unlock( cache.nextTimestamp() );\n\t\tif ( cache instanceof ClusterCache)\n\t\t\t((ClusterCache)cache).putQuiet(key, lock);\n\t\telse\n\t\t\tcache.put(key, lock);\n\t}\n",
    "1534": "    public Object get(Object key) throws CacheException {\n        try {\n            if ( log.isDebugEnabled() ) {\n                log.debug(\"key: \" + key);\n            }\n            if (key == null) {\n                return null;\n            } \n            else {\n                Element element = cache.get( (Serializable) key );\n                if (element == null) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug(\"Element for \" + key + \" is null\");\n                    }\n                    return null;\n                } \n                else {\n                    return element.getValue();\n                }\n            }\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1536": "\tfinal public void setBoxWithNo(int boxNo, int position) {\n\t\tboxesArray[position] = true;\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1537": "    public void put(Object key, Object value) throws CacheException {\n        try {\n            Element element = new Element( (Serializable) key, (Serializable) value );\n            cache.put(element);\n        } \n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n",
    "1538": "    public void remove(Object key) throws CacheException {\n        try {\n            cache.remove( (Serializable) key );\n        } \n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1540": "    public void clear() throws CacheException {\n        try {\n            cache.removeAll();\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (IOException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1542": "    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1543": "    public void lock(Object key) throws CacheException {\n    }\n",
    "1545": "    public void unlock(Object key) throws CacheException {\n    }\n",
    "1546": "\tprivate void setUndoRedoFromHistory() {\n\t\tapplicationGUI.setUndoButtonsEnabled(movementHistory.hasPrecedingMovement());\n\t\tapplicationGUI.setRedoButtonsEnabled(movementHistory.hasSuccessorMovement());\n\t}\n",
    "1547": "\t\tpublic long getFreshTimestamp() {\n\t\t\treturn freshTimestamp;\n\t\t}\n",
    "1548": "    public long nextTimestamp() {\n        return Timestamper.next();\n    }\n",
    "1549": "    public int getTimeout() {\n        // 60 second lock timeout\n        return Timestamper.ONE_MS * 60000;\n    }\n",
    "1550": "\t\tpublic Object getValue() {\n\t\t\treturn value;\n\t\t}\n",
    "1552": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\treturn new Lock(timeout, id, version);\n\t\t}\n",
    "1554": "\t\tpublic boolean isLock() {\n\t\t\treturn false;\n\t\t}\n",
    "1555": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn freshTimestamp < txTimestamp;\n\t\t}\n",
    "1558": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\t// we really could refresh the item if it  \n\t\t\t// is not a lock, but it might be slower\n\t\t\t//return freshTimestamp < txTimestamp\n\t\t\treturn  ( version!=null && newVersion!=null)&& comparator.compare(version, newVersion) < 0;\n\t\t}\n",
    "1561": "\tfinal public void setBoxWithNo(int boxNo, int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1563": "\tpublic boolean greaterThan(LockMode mode) {\n\t\treturn level > mode.level;\n\t}\n",
    "1564": "\tpublic boolean lessThan(LockMode mode) {\n\t\treturn level < mode.level;\n\t}\n",
    "1572": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\tconcurrentLock = true;\n\t\t\tmultiplicity++;\n\t\t\tthis.timeout = timeout;\n\t\t\treturn this;\n\t\t}\n",
    "1579": "\t\tpublic void unlock(long currentTimestamp) {\n\t\t\tif ( --multiplicity == 0 ) {\n\t\t\t\tunlockTimestamp = currentTimestamp;\n\t\t\t}\n\t\t}\n",
    "1587": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\tif (timeout < txTimestamp) return true;\n\t\t\tif (multiplicity>0) return false;\n\t\t\treturn version==null || newVersion==null? \n\t\t\t\tunlockTimestamp < txTimestamp :\n\t\t\t\tcomparator.compare(version, newVersion) < 0; //by requiring <, we rely on lock timeout in the case of an unsuccessful update!\n\t\t}\n",
    "1592": "\t\tpublic boolean wasLockedConcurrently() {\n\t\t\treturn concurrentLock;\n\t\t}\n",
    "1599": "\t\tpublic boolean isLock() {\n\t\t\treturn true;\n\t\t}\n",
    "1605": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn false;\n\t\t}\n",
    "1617": "\tfinal public void setBoxOnGoal(int position) {\n\t\tboxesArray[position] = true;\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1634": "    public Mapper createMapper() throws BuildException {\n        if (_mapper != null) {\n            throw new BuildException(\"Cannot define more than one mapper\");\n        }\n        _mapper = new Mapper(this.getProject());\n        return _mapper;\n    }\n",
    "1638": "\tprivate void exportLevelToClipboard(boolean withRLE) {\n\t\texportLevelToClipboard(withRLE, false);\n\t}\n",
    "1647": "\tfinal public void setBoxOnGoal(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1665": "\tfinal public void setGoal(int position) {\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1680": "\tfinal public void setGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1692": "\tfinal public void setWall(int position) {\n\t\twallsArray[position]++;\n\t}\n",
    "1704": "\tfinal public void setWall(int x, int y) {\n\t\twallsArray[x + width * y]++;\n\t}\n",
    "1716": "\tfinal public void setBoxNo(int boxNo, int position) {\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1727": "\tfinal public void setBoxNo(int boxNo, int x, int y) {\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1738": "\tfinal public void setAdvancedSimpleDeadlock(int position) {\n\t\tadvancedSimpleDeadlockSquareForwards[position] = true;\n\t}\n",
    "1761": "\tfinal public void setPlayerPosition(int position) {\n\t\tplayerPosition = position;\n\t}\n",
    "1778": "\tfinal public void setPlayerPosition(int x, int y) {\n\t\tplayerPosition = x + width * y;\n\t}\n",
    "1808": "\tfinal public boolean isCorralForcerSquare(int position) {\n\t\treturn corralForcer[position];\n\t}\n",
    "1837": "\tfinal public boolean isCorralForcerSquare(int x, int y) {\n\t\treturn corralForcer[x + width * y];\n\t}\n",
    "1865": "\tfinal public boolean isBox(int position) {\n\t\treturn boxesArray[position];\n\t}\n",
    "1889": "\tfinal public boolean isBox(int x, int y) {\n\t\treturn boxesArray[x + width * y];\n\t}\n",
    "1911": "\tfinal public boolean isWall(int position) {\n\t\treturn wallsArray[position] > 0;\n\t}\n",
    "1916": "\tpublic boolean isABoxSelected() {\n\t\treturn isABoxSelected;\n\t}\n",
    "1931": "\tfinal public boolean isWall(int x, int y) {\n\t\treturn wallsArray[x + width * y] > 0;\n\t}\n",
    "1946": "\tpublic boolean isHighLightingOfPlayerReachableSquaresActivated() {\n\t\treturn isHighLightOfPlayerSquaresActivated;\n\t}\n",
    "1956": "\tpublic void setAntInstallLib(File antInstallLib) {\n\t\tthis.antInstallLib = antInstallLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antInstallLib,\"tikal-antinstaller.jar\"));\n\t\tset.setFile(new File(antInstallLib,\"sysout.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1958": "\tpublic void setAntLib(File antLib) {\n\t\tthis.antLib = antLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antLib,\"tikal-ant.jar\"));\n\t\tset.setFile(new File(antLib,\"ant-launcher.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1959": "\tfinal public boolean isGoal(int position) {\n\t\treturn goalsArray[position];\n\t}\n",
    "1991": "\tpublic int getSelectedBoxPosition() {\n\t\treturn selectedBoxPosition;\n\t}\n",
    "2003": "\tfinal public boolean isGoal(int x, int y) {\n\t\treturn goalsArray[x + width * y];\n\t}\n",
    "2086": "\tpublic boolean isGoalOrWall(int position) {\n\t\treturn goalsArray[position] || wallsArray[position] > 0;\n\t}\n",
    "2156": "\tprivate void redoMovementInOwnThread(final boolean redoAllMovements) {\n\t\t\n\t\tmovePlayerThread = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tredoMovement(redoAllMovements);\n\n\t\t\t\t// The \"setUndoRedoFromHistory()\" has happened already.\n\n\t\t\t\t// This thread has finished its work. The thread isn't needed any more.\n\t\t\t\tmovePlayerThread = null;\n\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2159": "\tfinal public boolean isCorralForcer(int position) {\n\t\treturn corralForcer[position] == true;\n\t}\n",
    "2165": "    public List getKeysWithExpiryCheck() throws IllegalStateException, CacheException {\n        List allKeyList = getKeys();\n        //remove keys of expired elements\n        ArrayList nonExpiredKeys = new ArrayList(allKeyList.size());\n        int allKeyListSize = allKeyList.size();\n        for (int i = 0; i < allKeyListSize; i++) {\n            Serializable key = (Serializable) allKeyList.get(i);\n            Element element = getQuiet(key);\n            if (element != null) {\n                nonExpiredKeys.add(key);\n            }\n        }\n        nonExpiredKeys.trimToSize();\n        return nonExpiredKeys;\n    }\n",
    "2169": "\tfinal public boolean isGoalBackwardsSearch(int position) {\n\t\treturn goalSquareBackwardsSearch[position];\n\t}\n",
    "2175": "    public long getMemoryStoreSize() throws IllegalStateException {\n        checkStatus();\n        return memoryStore.getSize();\n    }\n",
    "2177": "    public int getDiskStoreSize() throws IllegalStateException {\n        checkStatus();\n        if (overflowToDisk) {\n            return diskStore.getSize();\n        } else {\n            return 0;\n        }\n    }\n",
    "2180": "\tfinal public boolean isGoalBackwardsSearch(int x, int y) {\n\t\treturn goalSquareBackwardsSearch[x + width * y];\n\t}\n",
    "2181": "    public Status getStatus() {\n        return status;\n    }\n",
    "2186": "\tprivate void undoMovementInOwnThread() {\n\n\t\tmovePlayerThread = new Thread() {\n\t\t\t@SuppressWarnings(\"synthetic-access\")\n\t\t\tpublic void run() {\n\t\t\t\tundoMovement();\n\n\t\t\t\t// Enable / disable the undo / redo button depending on the history status.\n\t\t\t\tsetUndoRedoFromHistory();\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2187": "    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n    }\n",
    "2191": "    public int getMemoryStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return memoryStoreHitCount;\n    }\n",
    "2193": "\tfinal public boolean isEmptySquare(int position) {\n\t\treturn ! (boxesArray[position] || wallsArray[position] > 0 || goalsArray[position]);\n\t}\n",
    "2195": "    public int getDiskStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return diskStoreHitCount;\n    }\n",
    "2196": "    private Method findCreateMethod(Class objClass, String name) {\n        final String methodName = makeMethodName(\"create\", name);\n        final Method[] methods = objClass.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            final Method method = methods[i];\n            if (!method.getName().equals(methodName)) {\n                continue;\n            }\n            if (Modifier.isStatic(method.getModifiers())) {\n                continue;\n            }\n            if (method.getParameterTypes().length != 0) {\n                continue;\n            }\n            if (method.getReturnType().isPrimitive() || method.getReturnType().isArray()) {\n                continue;\n            }\n            return method;\n        }\n\n        return null;\n    }\n",
    "2197": "    private String makeMethodName(final String prefix, final String name) {\n        return prefix + Character.toUpperCase(name.charAt(0)) + name.substring(1);\n    }\n",
    "2198": "    public int getMissCountNotFound() throws IllegalStateException {\n        checkStatus();\n        return missCountNotFound;\n    }\n",
    "2203": "    public int getMissCountExpired() throws IllegalStateException {\n        checkStatus();\n        return missCountExpired;\n    }\n",
    "2205": "\tfinal public boolean isEmptySquare(int x, int y) {\n\t\treturn ! (   boxesArray[x + width * y]\n\t\t          || wallsArray[x + width * y] > 0\n\t\t          || goalsArray[x + width * y]     );\n\t}\n",
    "2207": "    public String getName() {\n        return name;\n    }\n",
    "2208": "    private String getLocation() {\n        return locator.getSystemId() + ':' + locator.getLineNumber();\n    }\n",
    "2209": "    public long getTimeToIdleSeconds() {\n        return timeToIdleSeconds;\n    }\n",
    "2211": "    public long getTimeToLiveSeconds() {\n        return timeToLiveSeconds;\n    }\n",
    "2213": "\tfinal public boolean isAccessible(int position) {\n\t\treturn ! (wallsArray[position] > 0 || boxesArray[position]);\n\t}\n",
    "2219": "    public boolean isOverflowToDisk() {\n        return overflowToDisk;\n    }\n",
    "2221": "    public int getMaxElementsInMemory() {\n        return maxElementsInMemory;\n    }\n",
    "2223": "\tfinal public boolean isAccessible(int x, int y) {\n\t\treturn ! (wallsArray[x + width * y] > 0 || boxesArray[x + width * y]);\n\t}\n",
    "2224": "    public MemoryStoreEvictionPolicy getMemoryStoreEvictionPolicy() {\n        return memoryStoreEvictionPolicy;\n    }\n",
    "2225": "    public String getDiskCachePath() {\n        if (diskStore != null) {\n            return diskStore.path;\n        } else {\n            return null;\n        }\n    }\n",
    "2227": "    public Set getCacheKeySet() {\n        return caches.keySet();\n    }\n",
    "2229": "    public boolean isExpired(Element element) throws IllegalStateException, NullPointerException {\n        checkStatus();\n        boolean expired;\n        synchronized (element) {\n            if (element.getValue() == null) {\n                expired = true;\n            }\n            if (!eternal) {\n                expired = checkExpirationForNotEternal(element);\n            } else {\n                expired = false;\n            }\n            if (LOG.isDebugEnabled()) {\n                Serializable key = null;\n                if (element != null) {\n                    key = element.getKey();\n                }\n                LOG.debug(getName() + \": Is element with key \" + key + \" expired?: \" + expired);\n            }\n            return expired;\n        }\n    }\n",
    "2233": "\tfinal public boolean isAccessibleBox(int position) {\n\t\treturn ! (   wallsArray[position] > 0\n\t\t\t\t  || boxesArray[position]\n\t\t\t\t  || simpleDeadlockSquareForwards[position]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[position] );\n\t}\n",
    "2235": "    public Object clone() throws CloneNotSupportedException {\n        if (!(memoryStore == null && diskStore == null)) {\n            throw new CloneNotSupportedException(\"Cannot clone an initialized cache.\");\n        }\n        //added by yanai\n        Cache cache = (Cache) super.clone();\n        cache.cacheEventNotificationService = new CacheEventNotificationService(cache);\n        return cache;\n       //end of add\n    }\n",
    "2238": "        public void setClass(String fullyQualifiedClassPath) {\n            this.fullyQualifiedClassPath = fullyQualifiedClassPath;\n        }\n",
    "2241": "\tfinal public boolean isAccessibleBox(int x, int y) {\n\t\treturn ! (   wallsArray[x + width * y] > 0\n\t\t\t\t  || boxesArray[x + width * y]\n\t\t\t\t  || simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[x + width * y] );\n\t}\n",
    "2242": "        public void setName(String name) {\n            this.name = name;\n        }\n",
    "2243": "    public CacheEventNotificationService getCacheEventNotificationService() {\n        return cacheEventNotificationService;\n    }\n",
    "2244": "        public void setMaxElementsInMemory(int maxElementsInMemory) {\n            this.maxElementsInMemory = maxElementsInMemory;\n        }\n",
    "2247": "    public void notifyElementRemoved(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener = (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementRemoved(cache, element);\n        }\n    }\n",
    "2248": "        public void setMemoryStoreEvictionPolicy(String memoryStoreEvictionPolicy) {\n            this.memoryStoreEvictionPolicy = MemoryStoreEvictionPolicy.fromString(memoryStoreEvictionPolicy);\n        }\n",
    "2251": "    public void notifyElementExpiry(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener =  (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementExpired(cache, element);\n        }\n    }\n",
    "2252": "    public boolean registerListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.add(cacheEventListener);\n    }\n",
    "2253": "    public boolean unregisterListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.remove(cacheEventListener);\n    }\n",
    "2254": "    public Set getCacheEventListeners() {\n        return cacheEventListeners;\n    }\n",
    "2255": "\tfinal public boolean isWallOrIllegalSquare(int position) {\n\t\treturn     wallsArray[position] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2261": "        public void setEternal(boolean eternal) {\n            this.eternal = eternal;\n        }\n",
    "2266": "\tpublic boolean isLevelValid() {\n\n\t\tStringBuilder validityMessage = new StringBuilder();\n\n\t\t// Let the board check if it is valid.\n\t\tboolean levelIsValid = board.isValid(validityMessage);\n\n\t\t// If the level is invalid the editor mustn't be left and the\n\t\t// reason for the invalidity is displayed.\n\t\tif (levelIsValid == false) {\n\t\t\tdisplayInfotext(validityMessage.toString());\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(false);\n\t\t} else {\n\t\t\tdisplayInfotext(\"\");\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(true);\n\t\t}\n\n\t\treturn levelIsValid;\n\t}\n",
    "2268": "\tpublic void sendNotification(ClusterNotification message) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"sendNotification : \" + message);\n\t\tbus.sendNotification(message);\n\t}\n",
    "2270": "        public void setTimeToIdleSeconds(int timeToIdleSeconds) {\n            this.timeToIdleSeconds = timeToIdleSeconds;\n        }\n",
    "2272": "\tpublic Serializable getCache() {\n\t\treturn \"BroadcastingManager: \" + bus.getLocalAddress();\n\t}\n",
    "2273": "\tpublic void memberJoined(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"A new member at address '\" + address + \"' has joined the cluster\");\n\t\t}\n\t}\n",
    "2274": "\tpublic void memberLeft(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"Member at address '\" + address + \"' left the cluster\");\n\t\t}\n\t}\n",
    "2278": "        public void setTimeToLiveSeconds(int timeToLiveSeconds) {\n            this.timeToLiveSeconds = timeToLiveSeconds;\n        }\n",
    "2280": "\tfinal public boolean isWallOrIllegalSquare(int x, int y) {\n\t\treturn     wallsArray[x + width * y] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2281": "    public void shutdown() {\n        if (status.equals(Status.STATUS_SHUTDOWN)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"CacheManager already shutdown\");\n            }\n            return;\n        }\n        synchronized (CacheManager.class) {\n            allCacheManagersDiskStorePaths.remove(diskStorePath);\n            Enumeration allCaches = caches.elements();\n            while (allCaches.hasMoreElements()) {\n                Cache cache = (Cache) allCaches.nextElement();\n                if (cache != null) {\n                    cache.dispose();\n                }\n            }\n            if ( getBroadcastingManager()!=null) getBroadcastingManager().stop();\n            status = Status.STATUS_SHUTDOWN;\n            \n            //only delete singleton if the singleton is shutting down.\n            if (this == singleton) {\n                singleton = null;\n            }\n        }\n    }\n",
    "2283": "        public void setOverflowToDisk(boolean overflowToDisk) {\n            this.overflowToDisk = overflowToDisk;\n        }\n",
    "2285": "        public void setDiskPersistent(boolean diskPersistent) {\n            this.diskPersistent = diskPersistent;\n        }\n",
    "2288": "        public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {\n            this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;\n        }\n",
    "2291": "\tfinal public boolean isOuterSquareOrWall(int position) {\n\t\treturn    ! playersReachableSquaresOnlyWallsAtLevelStart[position]\n\t\t       || wallsArray[position] > 0;\n\t}\n",
    "2311": "\tfinal public boolean isSimpleDeadlockSquare(int position) {\n\t\treturn     simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position]\n\t\t\t\t|| simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2329": "\tpublic void start(BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\t}\n",
    "2331": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t}\n",
    "2338": "    protected void giveFocusToProjectsNames() {\n        projectsNamesCombo.setFocus();\n    }\n",
    "2351": "\tfinal public boolean isSimpleDeadlockSquare(int x, int y) {\n\t\treturn     simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2362": "\tpublic void setCurrentCollection(LevelCollection levelCollection) {\n\n\t\tcurrentLevelCollection = levelCollection;\n\n\t\t// Update the combo box showing all levels.\n\t\tupdateLevelComboBox();\n\t\t\n//\t\tif (Settings.isDebugModeActivated) {\n//\t\t\tSystem.out.println( \"Set collection with \"\n//\t\t\t\t\t            + levelCollection.getNumberOfLevels() + \" levels\" );\n//\t\t\tSystem.out.println( \"  ID = \" + levelCollection.getDatabaseID());\n//\t\t\tSystem.out.println( \"  title = \" + levelCollection.getTitle());\n//\t\t}\n\t}\n",
    "2377": "\tprotected String handleDirectoryBrowse(String path) {\n\t\tDirectoryDialog directoryDialog = new DirectoryDialog(getShell());\n\t\tif (path != null && !\"\".equals(path)) {\n\t\t\tdirectoryDialog.setFilterPath(path);\n\t\t}\n\t\tString dirName = directoryDialog.open();\n\n\t\treturn dirName;\n\t}\n",
    "2378": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareForwards[position];\n\t}\n",
    "2418": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2441": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2449": "\tpublic String collectionTitleOfLevelID(int levelID) {\n\t\tif (findLevelByID(levelID) != null) {\n\t\t\treturn currentLevelCollection.getTitle();\n\t\t}\n\t\treturn null;\n\t}\n",
    "2455": "    public Serializable save(Object obj) throws HibernateException {\n\n        if (obj==null) throw new NullPointerException(\"attempted to save null\");\n\n        Object object = unproxy(obj); //throws exception if uninitialized\n\n        EntityEntry e = getEntry(object);\n        if ( e!=null ) {\n            if ( e.status==DELETED ) {\n                forceFlush(e);\n            }\n            else {\n                log.trace( \"object already associated with session\" );\n                return e.id;\n            }\n        }\n\n        Serializable id = saveWithGeneratedIdentifier(object, Cascades.ACTION_SAVE_UPDATE, null); //id might be generated by SQL insert\n        reassociateProxy(obj, id); //TODO: move into saveWithGeneratedIdentifier()?\n        return id;\n\n    }\n",
    "2463": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2478": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int position) {\n\t\treturn advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2488": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int x, int y) {\n\t\treturn advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2500": "\tfinal public boolean isBoxOnGoal(int position) {\n\t\treturn boxesArray[position] && goalsArray[position];\n\t}\n",
    "2512": "\tfinal public boolean isBoxOnGoal(int x, int y) {\n\t\treturn boxesArray[x + width * y] && goalsArray[x + width * y];\n\t}\n",
    "2521": "\tfinal public boolean isPlayerInLevel() {\n\t\treturn playerPosition != NO_PLAYER;\n\t}\n",
    "2528": "\tfinal public boolean isMarked(int position) {\n\t\treturn marked[position];\n\t}\n",
    "2543": "\tfinal public boolean isMarked(int x, int y) {\n\t\treturn marked[x + width * y];\n\t}\n",
    "2552": "\tfinal public void removeMarking(int position) {\n\t\tmarked[position] = false;\n\t}\n",
    "2561": "\tfinal public void removeMarking(int x, int y) {\n\t\tmarked[x + width * y] = false;\n\t}\n",
    "2569": "\tfinal public void removeAllMarking() {\n\t\tArrays.fill(marked, false);\t\t\t// this is not time critical\n\t}\n",
    "2576": "\tfinal public void setMarking(int position) {\n\t\tmarked[position] = true;\n\t}\n",
    "2580": "    private void reassociateProxy(LazyInitializer li, HibernateProxy proxy) throws MappingException {\n        if ( li.getSession()!=this ) {\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key( li.getIdentifier(), persister );\n            if ( !proxiesByKey.containsKey(key) ) proxiesByKey.put(key, proxy); // any earlier proxy takes precedence\n            HibernateProxyHelper.getLazyInitializer( proxy ).setSession(this);\n        }\n    }\n",
    "2583": "\tfinal public void setMarking(int x, int y) {\n\t\tmarked[x + width * y] = true;\n\t}\n",
    "2591": "\tfinal public void assignMarking(int position, boolean markValue) {\n\t\tmarked[position] = markValue;\n\t}\n",
    "2600": "\tfinal public void flipMarking(int position) {\n\t\tmarked[position] = ! marked[position];\n\t}\n",
    "2608": "\tfinal public int getBoxNo(int position) {\n\t\treturn boxNumbers[position];\n\t}\n",
    "2616": "\tfinal public int getGoalNo(int position) {\n\t\treturn goalsNumbers[position];\n\t}\n",
    "2625": "\tfinal public int getGoalPosition(int goalNo) {\n\t\treturn goalsPositions[goalNo];\n\t}\n",
    "2633": "\tfinal public int getPlayerDistance(int fromSquare, int toSquare) {\n\t\treturn playerDistances[fromSquare][toSquare];\n\t}\n",
    "2641": "\tfinal public void setBoardPosition(IBoardPosition position) {\n\t\tsetBoardPosition(position.getPositions());\n\t}\n",
    "2650": "\tfinal public void setBoardPosition(int[] positions) {\n\n\t\t// remove all boxes from the board\n\t\tremoveAllBoxes();\n\n\t\t// store the new box positions in our box data object\n\t\tboxData.setBoxPositions(positions);\n\n\t\t// Put the new boxes into the board\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tsetBoxWithNo(boxNo, positions[boxNo]);\n\t\t}\n\n\t\t// set up the new player location\n\t\tplayerPosition = positions[boxCount];\n\t}\n",
    "2659": "\tfinal public void removeAllBoxes() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tremoveBox(boxData.getBoxPosition(boxNo));\n\t\t}\n\t}\n",
    "2668": "\tfinal public void setGoalsBackwardsSearch() {\n\n\t\tint goalNo = 0;\n\n\t\t// Set up the new goals for backwards search, and clear the old ones\n\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\tif (isBox(position) && isOuterSquareOrWall(position) == false) {\n\t\t\t\tgoalSquareBackwardsSearch[position] = true;\n\t\t\t\tgoalsPositionsBackwardsSearch[goalNo++] = position;\n\t\t\t} else {\n\t\t\t\tgoalSquareBackwardsSearch[position] = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "2683": "    public List find(String query) throws HibernateException {\n        return find(query, NO_ARGS, NO_TYPES);\n    }\n",
    "2781": "\t\tpublic int getBoxDistanceForwardsPlayerPositionIndependentNo(int boxNo, int goalNo) {\n\t\t\treturn getBoxDistanceForwardsPlayerPositionIndependent(boxData.getBoxPosition(boxNo), goalsPositions[goalNo]);\n\t\t}\n",
    "2880": "\tpublic void run(IAction action) {\n\t\tUpdateManagerDialog d = new UpdateManagerDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());\n\t\td.open();\n\t}\n",
    "2881": "\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t}\n",
    "2882": "\tpublic void dispose() {\n\t}\n",
    "2883": "\tpublic void init(IWorkbenchWindow window) {\n\t\tthis.window = window;\n\t}\n",
    "2930": "    protected boolean allowNewContainerName() {\n        return false;\n    }\n",
    "2961": "    public void aboutToOpen() {\n        determineWhiteCheckedDescendents(root);\n        checkNewTreeElements(treeContentProvider.getElements(root));\n\n        //select the first element in the list\n        Object[] elements = treeContentProvider.getElements(root);\n        Object primary = elements.length > 0 ? elements[0] : null;\n        if (primary != null) {\n            treeViewer.setSelection(new StructuredSelection(primary));\n        }\n        treeViewer.getControl().setFocus();\n    }\n",
    "2963": "    public void addCheckStateListener(ICheckStateListener listener) {\n        addListenerObject(listener);\n    }\n",
    "2964": "    private ITreeContentProvider getResourceProvider(final int resourceType) {\n        return new WorkbenchContentProvider() {\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic Object[] getChildren(Object o) {\n                //input element case\n                if (o instanceof ArrayList) {\n                    return ((ArrayList) o).toArray();\n                } \n               return new Object[0];            \t\n            }\n        };\n    }\n",
    "2965": "    protected boolean areAllChildrenWhiteChecked(Object treeElement) {\n        Object[] children = treeContentProvider.getChildren(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n            if (!whiteCheckedTreeItems.contains(children[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n        }\n\n        return true;\n    }\n",
    "2970": "    protected boolean areAllElementsChecked(Object treeElement) {\n        List checkedElements = (List) checkedStateStore.get(treeElement);\n        if (checkedElements == null) {\n\t\t\treturn false;\n\t\t}\n        return true;\n    }\n",
    "2971": "    protected void checkNewTreeElements(Object[] elements) {\n        for (int i = 0; i < elements.length; ++i) {\n            Object currentElement = elements[i];\n            boolean checked = checkedStateStore.containsKey(currentElement);\n            treeViewer.setChecked(currentElement, checked);\n            treeViewer.setGrayed(currentElement, checked\n                    && !whiteCheckedTreeItems.contains(currentElement));\n        }\n    }\n",
    "2972": "    protected Iterator getSelectedResourcesIterator() {\n        return this.resourceGroup.getAllCheckedListItems().iterator();\n    }\n",
    "2974": "    public void checkStateChanged(final CheckStateChangedEvent event) {\n\n        //Potentially long operation - show a busy cursor\n        BusyIndicator.showWhile(treeViewer.getControl().getDisplay(),\n            new Runnable() {\n                public void run() {\n                    if (event.getCheckable().equals(treeViewer)) {\n\t\t\t\t\t\ttreeItemChecked(event.getElement(), event\n                                .getChecked());\n\t\t\t\t\t}\n\n                    notifyCheckStateChangeListeners(event);\n                }\n            });\n    }\n",
    "2975": "    protected List getTypesToExport() {\n        return selectedTypes;\n    }\n",
    "2980": "    protected List getWhiteCheckedResources() {\n        return this.resourceGroup.getAllWhiteCheckedItems();\n    }\n",
    "2981": "    protected void createTreeViewer(Composite parent, boolean useHeightHint) {\n        Tree tree = new Tree(parent, SWT.CHECK | SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_BOTH);\n        if (useHeightHint) {\n\t\t\tdata.heightHint = PREFERRED_HEIGHT;\n\t\t}\n        tree.setLayoutData(data);\n        tree.setFont(parent.getFont());\n\n        treeViewer = new CheckboxTreeViewer(tree);\n        treeViewer.setContentProvider(treeContentProvider);\n        treeViewer.setLabelProvider(treeLabelProvider);\n        treeViewer.addTreeListener(this);\n        treeViewer.addCheckStateListener(this);\n        treeViewer.addSelectionChangedListener(this);\n    }\n",
    "2986": "    protected boolean hasExportableExtension(String resourceName) {\n        if (selectedTypes == null) {\n\t\t\treturn true;\n\t\t}\n\n        int separatorIndex = resourceName.lastIndexOf(\".\"); //$NON-NLS-1$\n        if (separatorIndex == -1) {\n\t\t\treturn false;\n\t\t}\n\n        String extension = resourceName.substring(separatorIndex + 1);\n\n        Iterator it = selectedTypes.iterator();\n        while (it.hasNext()) {\n            if (extension.equalsIgnoreCase((String) it.next())) {\n\t\t\t\treturn true;\n\t\t\t}\n        }\n\n        return false;\n    }\n",
    "2987": "    protected boolean determineShouldBeWhiteChecked(Object treeElement) {\n        return areAllChildrenWhiteChecked(treeElement)\n                && areAllElementsChecked(treeElement);\n    }\n",
    "2990": "    protected void determineWhiteCheckedDescendents(Object treeElement) {\n        // always go through all children first since their white-checked\n        // statuses will be needed to determine the white-checked status for\n        // this tree element\n        Object[] children = treeContentProvider.getElements(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n\t\t\tdetermineWhiteCheckedDescendents(children[i]);\n\t\t}\n\n        // now determine the white-checked status for this tree element\n        if (determineShouldBeWhiteChecked(treeElement)) {\n\t\t\tsetWhiteChecked(treeElement, true);\n\t\t}\n    }\n",
    "2991": "    protected void saveWidgetValues() {\n        // allow subclasses to save values\n        internalSaveWidgetValues();\n    }\n",
    "2992": "    public void expandAll() {\n        treeViewer.expandAll();\n    }\n",
    "2993": "    protected void setupBasedOnInitialSelections() {\n\n        Iterator it = this.initialResourceSelection.iterator();\n        while (it.hasNext()) {\n            IResource currentResource = (IResource) it.next();\n            if (currentResource.getType() != IResource.FILE) {\n\t\t\t\tthis.resourceGroup.initialCheckTreeItem(currentResource);\n\t\t\t}\n        }\n    }\n",
    "2995": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3005": "    protected boolean saveDirtyEditors() {\n        return IDEWorkbenchPlugin.getDefault().getWorkbench().saveAllEditors(\n                true);\n    }\n",
    "3008": "    public List getAllCheckedListItems() {\n\n        final ArrayList returnValue = new ArrayList();\n\n        IElementFilter passThroughFilter = new IElementFilter() {\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Collection elements,\n                    IProgressMonitor monitor) {\n                returnValue.addAll(elements);\n            }\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Object[] elements,\n                    IProgressMonitor monitor) {\n                for (int i = 0; i < elements.length; i++) {\n                    returnValue.add(elements[i]);\n                }\n            }\n        };\n\n        try {\n            getAllCheckedListItems(passThroughFilter, null);\n        } catch (InterruptedException exception) {\n            return new ArrayList();\n        }\n        return returnValue;\n\n    }\n",
    "3009": "    protected void updateWidgetEnablements() {\n\n        boolean pageComplete = determinePageCompletion();\n        setPageComplete(pageComplete);\n        if (pageComplete) {\n\t\t\tsetMessage(null);\n\t\t}\n        super.updateWidgetEnablements();\n    }\n",
    "3010": "\t\tfinal public PlayersReachableSquares getClone() {\n\t\t\treturn new PlayersReachableSquares(playersReachableSquaresArray, indicatorReachableSquare);\n\t\t}\n",
    "3012": "    public Object instantiate(ClassPersister persister, Serializable id) throws HibernateException {\n        Object result = interceptor.instantiate( persister.getMappedClass(), id );\n        if (result==null) result = persister.instantiate(id);\n        return result;\n    }\n",
    "3013": "    protected void addDestinationItem(String value) {\n        destinationNameField.add(value);\n    }\n",
    "3017": "    public List getAllWhiteCheckedItems() {\n\n        List result = new ArrayList();\n\n        //Iterate through the children of the root as the root is not in the store\n        Object[] children = treeContentProvider.getChildren(root);\n        for (int i = 0; i < children.length; ++i) {\n            findAllWhiteCheckedItems(children[i], result);\n        }\n\n        return result;\n    }\n",
    "3018": "    public int getCheckedElementCount() {\n        return checkedStateStore.size();\n    }\n",
    "3022": "    protected void createDirectoryStructureOptions(Composite optionsGroup, Font font) {\n        // create directory structure radios\n        createDirectoryStructureButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createDirectoryStructureButton.setText(DataTransferMessages.FileExport_createDirectoryStructure);\n        createDirectoryStructureButton.setSelection(false);\n        createDirectoryStructureButton.setFont(font);\n\n        // create directory structure radios\n        createSelectionOnlyButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createSelectionOnlyButton.setText(DataTransferMessages.FileExport_createSelectedDirectories);\n        createSelectionOnlyButton.setSelection(true);\n        createSelectionOnlyButton.setFont(font);\n    }\n",
    "3024": "\t\tfinal public int getPlayerPositionTopLeft() {\n\n\t\t\t// Calculate squares reachable by the player.\n\t\t\tupdate();\n\n\t\t\t// This is just the square with the smallest index.\n\t\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\t\tif (isSquareReachable(position)) {\n\t\t\t\t\treturn position;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The player can't reach any square.\n\t\t\treturn -1;\n\t\t}\n",
    "3028": "    private void grayUpdateHierarchy(Object treeElement) {\n\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setGrayChecked(treeElement, shouldBeAtLeastGray);\n\n        if (whiteCheckedTreeItems.contains(treeElement)) {\n\t\t\twhiteCheckedTreeItems.remove(treeElement);\n\t\t}\n\n        // proceed up the tree element hierarchy\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3029": "    public void initialCheckTreeItem(Object element) {\n        treeItemChecked(element, true);\n        selectAndReveal(element);\n    }\n",
    "3030": "    protected boolean ensureDirectoryExists(File directory) {\n        if (!directory.exists()) {\n            if (!queryYesNoQuestion(DataTransferMessages.DataTransfer_createTargetDirectory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n            if (!directory.mkdirs()) {\n                displayErrorDialog(DataTransferMessages.DataTransfer_directoryCreationError);\n                giveFocusToDestination();\n                return false;\n            }\n        }\n\n        return true;\n    }\n",
    "3032": "    protected boolean ensureTargetIsValid(File targetDirectory) {\n        if (targetDirectory.exists() && !targetDirectory.isDirectory()) {\n            displayErrorDialog(DataTransferMessages.FileExport_directoryExists);\n            giveFocusToDestination();\n            return false;\n        }\n\n        return ensureDirectoryExists(targetDirectory);\n    }\n",
    "3035": "    protected boolean executeExportOperation(FileSystemExportOperation op) {\n        op.setCreateLeadupStructure(createDirectoryStructureButton\n                .getSelection());\n        op.setOverwriteFiles(overwriteExistingFilesCheckbox.getSelection());\n\n        try {\n            getContainer().run(true, true, op);\n        } catch (InterruptedException e) {\n            return false;\n        } catch (InvocationTargetException e) {\n            displayErrorDialog(e.getTargetException());\n            return false;\n        }\n\n        IStatus status = op.getStatus();\n        if (!status.isOK()) {\n            ErrorDialog.openError(getContainer().getShell(),\n                    DataTransferMessages.DataTransfer_exportProblems,\n                    null, // no special message\n                    status);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3038": "\t\tfinal public PlayersReachableSquaresOnlyWalls getClone() {\n\t\t\treturn new PlayersReachableSquaresOnlyWalls(playersReachableSquaresOnlyWallsArray, reachableSquareIndicatorOnlyWalls);\n\t\t}\n",
    "3043": "    protected String getDestinationLabel() {\n        return DataTransferMessages.FileExport_toDirectory;\n    }\n"
}
