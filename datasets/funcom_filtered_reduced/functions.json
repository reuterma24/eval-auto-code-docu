{
    "321": "\tpublic int getPushesLowerbound() {\n\t\treturn pushesLowerbound;\n\t}\n",
    "323": "\tpublic void setPushesLowerbound(int pushesLowerbound) {\n\t\tthis.pushesLowerbound = pushesLowerbound;\n\t}\n",
    "324": "\t\tpublic void play() {\n\t\t\t\n\t\t\t// If no sound file is there nothing can be played.\n\t\t\tif(currentSoundFilename.equals(\"\"))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// Check if the this sound must be read from another file (the user has\n\t\t\t// chosen another sound to be played).\n\t\t\tString settingsFileName = Settings.get(soundSettingsKey);\n\t\t\tif(!currentSoundFilename.equals(settingsFileName)) {\n\t\t\t\tloadClip(settingsFileName);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Stop the currently playing sound to play the new sound if necessary.\n\t\t\tif (clip.isRunning()) {\n\t\t\t\tclip.stop();\n\t\t\t}\n\t\t\t\n\t\t\t// Rewind to the beginning.\n\t\t\tclip.setFramePosition(0); \n\t\t\t\n\t\t\t// Start playing.\n\t\t\tclip.start();    \n\t\t}\n",
    "343": "\tpublic int getInfluenceValue(int boxNo1, int boxNo2) {\n\t\treturn influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),\n\t\t\t\t                               board.boxData.getBoxPosition(boxNo2) );\n\t}\n",
    "351": "\tpublic void setPositions(int[] positions){\n\t\tthis.positions = positions;\n\t}\n",
    "352": "\tpublic int getPlayerPosition() {\n\t\treturn positions[positions.length-1];\n\t}\n",
    "355": "\tpublic int getPulledBoxNumber() {\n\t\treturn pulledBoxNo;\n\t}\n",
    "357": "\tpublic int getStartBoxPosition() {\n\t\treturn startPosition;\n\t}\n",
    "359": "\tpublic int getTargetBoxPosition() {\n\t\treturn targetPosition;\n\t}\n",
    "361": "    public BoardPositionPackingSequence getPrecedingBoardPosition() {\n    \treturn precedingBoardPosition;\n    }\n",
    "364": "\tpublic int compareTo(BoardPositionPackingSequence boardPosition) {\n\t\treturn boardPosition.getRelevance() - getRelevance();\n\t}\n",
    "373": "\tpublic boolean isForcedPush() {\n\t\treturn isPushForced;\n\t}\n",
    "376": "\tfinal public void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "412": "\tpublic boolean isSolverStoppedDueToOutOfMemory() {\n\t\treturn isSolverStoppedDueToOutOfMemory;\n\t}\n",
    "428": "    final protected IBoardPositionMoves getBestBoardPosition(){\n\n\t\t// Nimmt die Liste aller Stellungen mit einer bestimmten L\u00f6sungspfadl\u00e4nge auf\n\t\tLinkedList<IBoardPositionMoves> boardPositionList;\n\t\t\n\t\tfor(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {\n\t\t\n\t\t\t// Liste der Stellungen mit der aktuellen Pfadl\u00e4nge holen. \n\t\t\tboardPositionList = boardPositionQueue.get(solutionLength);\n\t\t\t\n\t\t\tif(boardPositionList.size() > 0){\t \n\t\t\t    shortestSolutionPathLength = solutionLength;\n\t\t\t    \n\t\t\t\t// Die zuletzt eingef\u00fcgte Stellung zur\u00fcckgeben\n\t    \t\treturn boardPositionList.removeLast();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "437": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn precedingBoardPosition;\n\t}\n",
    "440": "\tfinal public int getDirection() {\n\t\treturn positionData >>> 13;\n\t}\n",
    "442": "\tpublic int getBoxNo() {\n\t\treturn positionData & ((1 << 10) - 1);\n\t}\n",
    "445": "\tprotected String creatorName() {\n\t\treturn Texts.getText(\"solver\");\n\t}\n",
    "446": "\tfinal public int getPlayerPosition() {\n\t\treturn playerPosition;\n\t}\n",
    "448": "\tfinal public void setPositions(int[] positions) {\n\t\tthis.positions = positions;\n\t}\n",
    "450": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn null;\n\t}\n",
    "454": "\tfinal public void setSearchDirection(SearchDirection searchDirection) {\n\n\t\tif (searchDirection == SearchDirection.FORWARD) {\n\t\t\tforwardsSearch  = true;\n\t\t} else {\n\t\t\tbackwardsSearch = true;\n\t\t}\n\t}\n",
    "458": "\tfinal public int getDirection() {\n\t\treturn 0;\n\t}\n",
    "459": "\tpublic int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (BoardPosition currentBoardPosition = this; currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition()) {\n\t\t\tif (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn pushesCount;\n\t}\n",
    "461": "\tfinal public int getBoxNo() {\n\t\treturn NO_BOX_PUSHED;\n\t}\n",
    "463": "\tpublic void setMaximumSolutionLength(short maximumSolutionLength) {\n\t\tmaximumPushesCurrentIteration = maximumSolutionLength;\n\t}\n",
    "464": "\tfinal public int getPlayerPosition() {\n\t\treturn positions[boxCount];\n\t}\n",
    "466": "\tpublic short getMaximumSolutionLength() {\n\t\treturn maximumPushesCurrentIteration;\n\t}\n",
    "467": "\tfinal public int getPushesCount() {\n\t\treturn 0;\n\t}\n",
    "472": "\tprotected String solutionByMeAt(Date date) {\n\t\treturn  Texts.getText(\"createdBy\")\n\t\t      + \" \" + creatorName()\n\t\t      + \" \" + Utilities.dateString(date);\n\t}\n",
    "476": "\tfinal public void setMovesCount(int movesCount) {\n\t\tthis.movesCount = (short) movesCount;\n\t}\n",
    "487": "\tpublic int getIndexPackingSequence() {\n\t\treturn indexPackingSequence;\n\t}\n",
    "489": "\tpublic void setIndexPackingSequence(int indexPackingSequence) {\n\t\tthis.indexPackingSequence = indexPackingSequence;\n\t}\n",
    "494": "\tprotected boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "496": "\tfinal public boolean isBoxInactive() {\n\t\treturn (positionData & INACTIVE_BOX) > 0;\n\t}\n",
    "497": "\tpublic void setCorralDeadlock() {\n\t\tisDeadlock = true;\n\t}\n",
    "498": "\tpublic void setNotCorralDeadlock() {\n\t\tisNotDeadlock = true;\n\t}\n",
    "499": "\t\tpublic boolean getValue() {\n\t\t\t/*\n\t\t\t * Since we here are inside of class Settings, we should not get\n\t\t\t * an IllegalAccessException.\n\t\t\t * Hence, we catch the exceptions here, and return false,\n\t\t\t * just in case.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\treturn field.getBoolean(null);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "500": "\tprotected String solutionByMeNow() {\n\t\treturn solutionByMeAt(null);\n\t}\n",
    "501": "\tpublic void setCorralNo(int corralNo) {\n\t\tthis.corralNo = corralNo;\n\t}\n",
    "503": "\tpublic void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "504": "\tpublic int getCorralNo() {\n\t\treturn corralNo;\n\t}\n",
    "506": "\tpublic boolean isCorralDeadlock() {\n\t\treturn isDeadlock;\n\t}\n",
    "507": "\tpublic boolean isNotCorralDeadlock() {\n\t\treturn isNotDeadlock;\n\t}\n",
    "508": "\tpublic boolean isClassified() {\n\t\treturn isDeadlock || isNotDeadlock;\n\t}\n",
    "510": "\tpublic boolean isBeeingAnalyzed() {\n\t\treturn !isDeadlock && !isNotDeadlock;\n\t}\n",
    "513": "\tpublic CBoard getClone() {\n\t\treturn new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);\n\t}\n",
    "514": "\t\tpublic void setValue(boolean value) {\n\t\t\t/*\n\t\t\t * Regarding exceptions see comment in \"getValue\"\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tfield.setBoolean(null, value);\n\t\t\t\tSystem.out.println(\"Setting: DebugVar: \"+field.getName()+\" set to \"+value);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// well... forget it.\n\t\t}\n",
    "517": "\tprivate boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {\n\t\t\n\t\tint indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;\n\t\t\n\t\t// Compare byte by byte of both box configurations.\n\t\tfor(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {\n\t\t\tif (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n",
    "523": "\tpublic int getMaxCapacity() {\n\t\treturn maxCapacity;\n\t}\n",
    "524": "\tpublic void add(int boardPositionIndex, int boardPositionPredecessor) {\n\t\t\n\t\t// The moves queue also contains an arbitrary number of span markers.\n\t\t// Therefore after every added board position there must be done\n\t\t// a check whether the memory block is already full.\n\t\tadd(boardPositionIndex      );\n\t\tadd(boardPositionPredecessor);\n\t}\n",
    "531": "\tpublic void jumpOverBoardPosition(int boardPosition) {\n\t\n\t\t// \"Remove\" all values from the queue which are equal to the passed one\n\t\t// FFS/hm: does the caller guarantee that the Q cannot become empty by this?\n\t\twhile(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {\n\t\t\tremoveBoardPosition();\n\t\t}\n\t}\n",
    "535": "\tpublic int removeLastBoardPosition() {\n\t\t\t\t\t\t\n\t\tif(nextIndexToWrite == 0) {\n\t\t\t\n\t\t\t// The previous memory block becomes the new current memory block.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\n\t\t}\n\t\t\n\t\treturn memoryBlockToWrite.memory[--nextIndexToWrite];\n\t}\n",
    "538": "\tpublic void jumpXBoardPositionsBackwards(int jumpCount) {\n\t\t\n\t\twhile(jumpCount > nextIndexToWrite) {\n\t\t\t\t\t\t\t\n\t\t\t// Assign the previous memory block of the queue.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\t\n\t\t\tjumpCount -= nextIndexToWrite;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\t\t\t\t\t\n\t\t}\n\t\tnextIndexToWrite -= jumpCount;\n\t}\n",
    "542": "\tpublic boolean isEmpty() {\n\t\t// This method is only called for the moves queue which has recycling activated.\n\t\treturn memoryBlockToRead == memoryBlockToWrite\n\t\t    && nextIndexToRead   == nextIndexToWrite;\n\t}\n",
    "547": "\tpublic boolean isGenerationStoppedDueToFullStorage() {\n\t\treturn generationStoppedDueToFullStorage;\n\t}\n",
    "551": "\tpublic int getBoxConfigurationNumber() {\n\t\treturn uniqueBoxConfigurationNumber;\n\t}\n",
    "561": "\tpublic boolean isBetterMovesPushesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( movesCount , other.movesCount,\n\t\t                                   pushesCount, other.pushesCount )\n\t\t     < 0 ;\n\t}\n",
    "563": "\tpublic boolean isBetterPushesMovesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( pushesCount, other.pushesCount,\n\t\t                                   movesCount , other.movesCount  )\n\t\t     < 0 ;\n\t}\n",
    "568": "\tpublic void add(OptimizerBoardPosition boardPosition) {\n\n\t\t// Ensure that a real board position has been passed.\n        if (boardPosition == null)\n            throw new NullPointerException();\n\t\t\n\t\t// Double the size of the queue if it is full.\n\t\tif (count >= queue.length) {\n\t\t\tqueue = Arrays.copyOf(queue, queue.length * 2);\t\n\t\t}\t\t\n\t\t\n\t\t// Add the new value at the correct position. \n\t\tsiftUp(count, boardPosition);\n\t\t\n\t\t// One more board position has been stored => increase the counter.\n\t\tcount++;\n\t}\n",
    "570": "\tpublic int size() {\n\t\treturn count;\n\t}\n",
    "572": "\tpublic OptimizerBoardPosition removeFirst() {\n\n\t\tif (count == 0)\n\t\t\treturn null;\n\n\t\t// The head of the queue must be returned.\n\t\tOptimizerBoardPosition result = queue[0];\n\t\t\n\t\t// The head of the queue has (logically) been removed => adjust the size.\n\t\t--count;\n\t\t\n\t\t// Remove the last board position.\n\t\tOptimizerBoardPosition x = queue[count];\n\t\tqueue[count] = null;\n\t\t\n\t\t// If there is at least one board position left in the queue then \n\t\t// shift the board positions so the queue has a new head.\n\t\tif (count != 0)\n\t\t\tsiftDown(0, x);\n\n\t\treturn result;\n\t}\n",
    "576": "\tprivate void addLogTextStyle(final String text, final String stylename) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tStyledDocument doc = optimizerLog.getStyledDocument(); \n\t\t\t\t\tdoc.insertString(doc.getLength(), text+\"\\n\", doc.getStyle(stylename));\t\t\t\n\t\t\t\t} catch (BadLocationException e) {\t/* ignore */ }\n\t\t\t}\n\t\t});\n\t}\n",
    "577": "\t private void siftDown(int position, OptimizerBoardPosition boardPosition) {\n\t\t \n\t\t // Calculate the half of the size as the maximum position the loop must go to.\n\t\t int half = count >>> 1;        \n\t\t \n\t\t while (position < half) {\n\t\t\t int childIndex = (position << 1) + 1; // assuming the left child is the \"better\" board position\n\t\t\t OptimizerBoardPosition child = queue[childIndex];\n\t\t\t int rightChildIndex = childIndex + 1;\n\t\t\t if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)\n\t\t\t\t child = queue[childIndex = rightChildIndex];\n\t\t\t if (boardPosition.compareTo(child) <= 0)\n\t\t\t\t break;\n\t\t\t queue[position] = child;\n\t\t\t position = childIndex;\n\t\t }\n\t\t \n\t\t queue[position] = boardPosition;\n\t }\n",
    "580": "\tpublic int getNumberOfStoredBoardPositions() {\n\t\treturn count.get();\n\t}\n",
    "601": "\tpublic void removeAllMarkings() {\n\t\tmarkedSquares = null;\n\t}\n",
    "608": "\tpublic void showDeadlockQueryStats() {\n\t\tdlqTotStats.sumFrom(dlqCurStats);\n\t\tif ( ! dlqTotStats.equals(dlqCurStats)) {\n\t\t\tshow1DLQStats(\"total\", dlqTotStats, 0);\n\t\t}\n\t\t\n\t\tshow1DLQStats(\"this time\", dlqCurStats, dlqTotStats.dlqAsked);\n\t\tdlqCurStats.clear();\n\t}\n",
    "610": "\tprivate int getBoxConfigurationIndex(int boardPositionIndex) {\n\t\t// The board position may just been locked by another thread. However,\n\t\t// this method is only called for already completely stored board positions.\n\t\t// Hence, the index can't hold just the \"LOCKED\" value but must\n\t\t// always also contain a valid box configuration index.\n\t\treturn table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); \n\t}\n",
    "613": "\tfinal private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {\n\t\tfor (int i = 0; i < packedBoardByteSize; i++) {\n\t\t\tbyte b2 = boxConfigurationArray[indexInArray + i];\n\t\t\t// \"b2\" is a subset, if all its 1-bits survive the ANDing with the first byte\n\t\t\tif ((boxConfiguration1[i] & b2) != b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "617": "\tprivate int getPlayerPosition(int boardPositionIndex) {\n\t\t// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.\n\t\treturn table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;\n\t}\t\n",
    "619": "\t\tfinal private void doubleTreeSize() {\n\t\n\t\t\t// Double the tree size.\n\t\t\tint[] newArrayPointers = new int[2*2*treeSizeMax];\n\t\t\tSystem.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);\n\t\t\tarrayPointers = newArrayPointers;\n\t\n\t\t\tbyte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];\n\t\t\tSystem.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);\n\t\t\ttreeData = newArrayData;\n\t\n\t\t\ttreeSizeMax <<= 1;\n\t\t}\n",
    "626": "\t\tfinal private int treeToSortedListRecursively(int indexInTree, int last) {\n\t\n\t\t\t// If the end of the tree has been reached return the last index.\n\t\t\tif (indexInTree == -1) {\n\t\t\t\treturn last;\n\t\t\t}\n\t\n\t\t\t// Left side of the tree.\n\t\t\tint d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);\n\t\t\tsortedList[d++] = indexInTree;\n\t\n\t\t\t// Right side of the tree.\n\t\t\treturn (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));\n\t\t}\n",
    "637": "\tfinal public int getNumberOfSelectedObject() {\n\t\treturn currentlyMarkedObject;\n\t}\n",
    "638": "\t\tfinal private void binaryTreeToBinaryHeap() {\n\t\t\n\t\t\tbyte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];\n\t\t\n\t\t\tfor (int i=0, indexInVector = 0; i<treeSize; i++) {\n\t\t\t\tSystem.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);\n\t\t\t\tindexInVector += packedBoardByteSize;\n\t\t\t}\n\t\t\n\t\t\ttreeData = treeDataTemp;\n\t\t\tarrayPointers = null;\n\t\t}\n",
    "641": "\tfinal public void mouseWheelMoved(MouseWheelEvent evt) {\n\n\t\tint scrollDirection = evt.getWheelRotation();\n\n\t\t// Scrollen nach oben\n\t\tif (scrollDirection < 0 && currentlyMarkedObject > 0) {\n\t\t\tcurrentlyMarkedObject--;\n\t\t}\n\n\t\t// Scrollen nach unten\n\t\tif (scrollDirection > 0 && currentlyMarkedObject < 4) {\n\t\t\tcurrentlyMarkedObject++;\n\t\t}\n\n\t\tapplication.redraw(false);\n\t}\n",
    "643": "\tpublic void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {\n\t\t\n\t\t// Set/delete the \"processed\"-flag. This needn't to be done using compareAndSwap\n\t\t// because all of the other information stored at that offset have already been \n\t\t// stored and cannot change anymore while this method is executed.\n\t\tint currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);\n\t\tif(processedStatus == true)\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);\n\t\telse\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));\n\t}\n",
    "648": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * View on the levels\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "651": "\t\tprotected void finalize() {\n\t\t\tarrayPointers = null;\n\t\t\tsortedList = null;\n\t\t\ttreeData = null;\n\t\t}\n",
    "653": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * Language settings\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "656": "\tprivate void createPanel() {\n\t\t\n\t\tsetLayout(new BorderLayout());\n\n\t\tJPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));\n\t\tguiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));\n\n\t\t// Just a quick and dirty test coding ...\n\t\tNimRODFontDialog d = new NimRODFontDialog(null);\n\t\tComponent[] c = d.getContentPane().getComponents();\n\t\tguiPanel.add(c[0]);\n\t\t\n\t\tadd(guiPanel, BorderLayout.NORTH);\n\t}\n",
    "663": "\tprivate void updateElements() {\n\t\tfinal boolean selected = checkboxGUI.isSelected();\n\t\t\n\t\ttextfieldGUI.setEnabled(selected);\n\t\tlabelGUI.setEnabled(selected);\n\t}\n",
    "666": "\tpublic Double getValueAsDouble() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;\n\t}\n",
    "669": "\tpublic Integer getValueAsInteger() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;\n\t}\n",
    "670": "\tpublic void enterMeForTypeDate(JTable table) {\n\t\ttable.setDefaultRenderer(java.util.Date.class, this);\n\t}\n",
    "672": "\tpublic void addLevel(Level level) {\n\t\tdisplayedLevels.add(level);\n\t\tif (displayedLevels.size() < levelsPerPage) {\n\t\t\tlastLevelIndex = displayedLevels.size() - 1;\n\t\t} else {\n\t\t\tlastLevelIndex = levelsPerPage - 1;\n\t\t}\n\t}\n",
    "675": "\tpublic boolean isFieldActive() {\n\t\treturn textfieldGUI.isEnabled();\n\t}\n",
    "676": "\tpublic void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {\n\t\tfor(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {\n\t\t\taddLevel(collection.getLevel(levelNo));\n\t\t}\n\t}\n",
    "677": "\tpublic double setValue(double value) {\n\n\t\tdouble rc = value;\n\t\tif (value > maximumValue) {\n\t\t\trc = maximumValue;\n\t\t} else if (value < minimumValue) {\n\t\t\trc = minimumValue;\n\t\t} else {\n\t\t\trc = value;\n\t\t}\n\t\ttextfieldGUI.setValue(rc);\n\n\t\treturn rc;\t\t\n\t}\n",
    "684": "\tpublic void actionPerformed(ActionEvent actionevent) {\n\t\tif (actionevent.getActionCommand() == \"okbutton\") {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "685": "\tpublic void informAllUnsync(Generator<E> eventgen) {\n\t\t/*\n\t\t * We must not directly use (weakhashmap.keySet()), since it still\n\t\t * is coupled to the weakhashmap itself, which needs synchronization.\n\t\t * Hence we first must obtain a copy.\n\t\t */\n\t\tfor (L listener : getListenersCopy()) {\n\t\t\tfinal E evt = ((eventgen != null) ? eventgen.generate() : null);\n\t\t\tcaller.call(listener, evt);\n\t\t}\n\t}\n",
    "687": "\tpublic void setToStart() {\n\t\tsetTo(true);\n\t}\n",
    "688": "\tpublic void setToStop() {\n\t\tsetTo(false);\n\t}\n",
    "690": "\tprivate void setTo( boolean forStart ) {\n\t\tString textkey = (forStart ? startkey           : stopkey          );\n\t\tString action  = (forStart ? startActionCommand : stopActionCommand);\n\t\t\n\t\tsetText(Texts.getText( textkey ));\n\t\tsetActionCommand( action );\n\t\t\n\t\tsetupBorder(forStart);\n\t\tsetupBgColor(forStart);\n\t}\n",
    "693": "\tprivate void setupBorder(boolean forStart) {\n\t\tsetBorder( useBorder ? makeBorder(forStart) : null );\n\t}\n",
    "694": "\tprivate void setupBgColor(boolean forStart) {\n\t\tif (useBgColor) {\n\t\t\tint rgb = (forStart ? bgColorStart : bgColorStop);\n\t\t\t\n\t\t\tsetBackground( new Color(rgb) );\n\t\t\tsetOpaque(false);\n\t\t} else {\n\t\t\t// FFS/hm: should we actively put away a background color?\n\t\t}\n\t}\n",
    "696": "\tpublic Border makeBorder(boolean forStart) {\n\t\tint rgb = (forStart ? borderColorStart : borderColorStop);\n\t\treturn makeRgbBorder(rgb, useRoundedCorners);\n\t}\n",
    "697": "\tpublic Border makeStartBorder() {\n\t\treturn makeBorder(true);\n\t}\n",
    "699": "\tpublic Border makeStopBorder() {\n\t\treturn makeBorder(false);\n\t}\n",
    "703": "\tpublic void setUseBorder(boolean useBorder) {\n\t\tthis.useBorder = useBorder;\n\t}\n",
    "706": "\tpublic void setUseBgColor(boolean useBgColor) {\n\t\tthis.useBgColor = useBgColor;\n\t}\n",
    "710": "\tpublic void setBorderColorStart(int borderColorStart) {\n\t\tthis.borderColorStart = borderColorStart;\n\t}\n",
    "715": "\tpublic void setBorderColorStop(int borderColorStop) {\n\t\tthis.borderColorStop = borderColorStop;\n\t}\n",
    "718": "\tpublic void setBgColorStart(int bgColorStart) {\n\t\tthis.bgColorStart = bgColorStart;\n\t}\n",
    "721": "\tpublic void setBgColorStop(int bgColorStop) {\n\t\tthis.bgColorStop = bgColorStop;\n\t}\n",
    "722": "\tstatic private boolean isOutsideClip(int x, int y, int xlen, int ylen, Rectangle clip) {\n\n\t\t// Non-existing rectangle stands for the complete plane => nothing is outside of the complete plane.\n\t\t// We are \"outside\" of \"clip\", if we do not intersect with it.\n\t\treturn clip != null && ! clip.intersects(x, y, xlen, ylen);\n\t\t\n\t}\n",
    "741": "\tpublic boolean hasAlias() {\n\t\treturn (alias.length() > 0);\n\t}\n",
    "743": "\tpublic String getAlias() {\n\t\treturn alias;\n\t}\n",
    "746": "\tpublic void setAlias(String newAlias) {\n\t\talias = newAlias;\n\t}\n",
    "747": "\tpublic String getPath() {\n\t\treturn path;\n\t}\n",
    "750": "\tpublic String getName() {\n\t\tif (hasAlias()) {\n\t\t\treturn alias;\n\t\t}\n\t\treturn path;\n\t}\n",
    "752": "\tpublic String getDisplayName() {\n\t\tif (hasAlias()) {\n\t\t\treturn '[' + alias + ']';\n\t\t}\n\t\treturn path;\n\t}\n",
    "753": "\tprivate BufferedImage extractGraphicTwoCoordinates(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tPoint graphicCoordinates = getPoint(graphicName);\n\t\t\tif(graphicCoordinates != null) {\n\t\t\t\treturn entireGraphic.getSubimage(graphicCoordinates.x * graphicWidth,\n\t\t\t\t\t\t                         graphicCoordinates.y * graphicHeight,\n\t\t\t\t\t\t                         graphicWidth, graphicHeight);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "754": "\tpublic Color getColor() {\n\t\treturn color;\n\t}\n",
    "755": "\tpublic void setColor(String color) {\n\t\tthis.color = parseColor(color);\n\t}\n",
    "756": "\tpublic void setBoardToDisplay(Board board) {\n\n\t\t// Save the reference.\n\t\tthis.board = board;\n\n\t\t// Create new array for storing information about which positions have to be drawn when repainting.\n\t\tgraphicStatus = new byte[board.size];\n\n\t\t// Initialize the debug array used for showing numbers on the board.\n\t\tArrays.fill(numbersToShow, -1);\n\n\t\t// Reset the transformation of the board.\n\t\ttransformBoard(-1);\n\t}\n",
    "758": "\tpublic String getColorString() {\n\t\treturn colorToString(color);\n\t}\n",
    "759": "\tprivate BufferedImage extractGraphicOneCoordinate(BufferedImage entireGraphic, String graphicName) {\n\t\n\t\ttry {\n\t\t\tint xCoordinate = getInt(graphicName, -1);\n\t\t\tif(xCoordinate == -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn entireGraphic.getSubimage(xCoordinate * graphicWidth, 0, graphicWidth, graphicHeight);\n\t\t} catch (Exception e) {\n\t\t\tif(Settings.isDebugModeActivated) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "764": "\tprivate String trimValue(String propertyValue) {\n\t\n\t\tif (propertyValue == null || propertyValue.length() == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\n\t\tint lastpos = propertyValue.indexOf('#');\n\t\tif (lastpos == -1) {\n\t\t\tlastpos = propertyValue.length() - 1;\n\t\t}\n\t\t\n\t\t\n\t\tfor(; lastpos >= 0 ; --lastpos ) {\n\t\t\tchar c = propertyValue.charAt(lastpos);\n\t\t\tif (c != ' ' && c != '\\t') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Now, \"lastpos\" indexes the last char to be retained (or -1 if there is none)\n\t\t\n\t\t// Return the trimmed value.\n\t\treturn propertyValue.substring(0, lastpos + 1);\n\t}\n",
    "772": "\tstatic public String getTransformationAsString() {\n\n\t\t// If the level isn't displayed transformed return an empty String.\n\t\tif (getRotationValue() == ROTATION_BY_0_DEGREES && isLevelFlippedHorizontally() == false) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// Build the transformation string and return it.\n\t\tString transformationString = \"View: Rotated \"\n\t\t\t                        + getRotationAsString()\n\t\t\t                        + \" degrees clockwise\";\n\t\tif (isLevelFlippedHorizontally()) {\n\t\t\ttransformationString += \", flipped horizontally.\";\n\t\t} else {\n\t\t\ttransformationString += \".\";\n\t\t}\n\n\t\treturn transformationString;\n\t}\n",
    "774": "\tpublic T generate() {\n\t\treturn base;\n\t}\n",
    "779": "\tfinal private JButton createToolBarButton(String iconName, String actionCommand, String toolTipText) {\n\n\t\t// Create and initialize the button.\n\t\tJButton button = new JButton(Utilities.getIcon(iconName, null));\n\t\tbutton.setActionCommand(actionCommand);\n\t\tbutton.setToolTipText(toolTipText);\n\t\tbutton.addActionListener(this);\n\n\t\t// The buttons must be clicked with the mouse.\n\t\tbutton.setFocusable(false);\n\n\t\treturn button;\n\t}\n",
    "781": "\tpublic Skin getCurrentSkin() {\n\t\treturn skin;\n\t}\n",
    "784": "\tprivate String getString(String name, String ... defaultValue) {\n\t\n\t\t// Get the value of the property.\n\t\tString propertyValue = trimValue(properties.getProperty(name));\n\t\n\t\t// If the the property couldn't be found set the default value.\n\t\tif (propertyValue == null) {\n\t\t\tif(defaultValue.length > 0) {\n\t\t\t\treturn defaultValue[0];\n\t\t\t}\n\t\t}\n\t\n\t\treturn propertyValue;\n\t}\n",
    "785": "\tfinal private JButton createToolBarButtonByKey(String iconName, String actionCommand, String toolTipTextKey) {\n\t\tString toolTipText = Texts.getText(toolTipTextKey);\n\t\treturn createToolBarButton(iconName, actionCommand, toolTipText);\n\t}\n",
    "787": "\tpublic void setSkinAnimationDelay(int delay) {\n\n\t\t// Save the delay in the settings.\n\t\tSettings.set(\"skinAnimationDelay\", \"\" + delay);\n\n\t\t// If a timer is running set the new delay value.\n\t\tif (animationTimer != null && animationTimer.isRunning()) {\n\t\t\tanimationTimer.setDelay(delay);\n\t\t}\n\t}\n",
    "793": "\tpublic void setViewDirection(int viewDirection) {\n\t\tthis.viewDirection = (byte) viewDirection;\n\t}\n",
    "800": "\tpublic void setMaximumScalingFactor(int maximumScalingFactor) {\n\n\t\tmaximumScaling = maximumScalingFactor;\n\n\t\trecalculateGraphicSizes();\n\t\trepaint();\n\n\t\t// Save the zooming factor.\n\t\tSettings.set(\"maximumScaling\", \"\" + maximumScaling);\n\t}\n",
    "805": "\tpublic void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "806": "\tpublic void transformBoard(int transformationValue) {\n\n\t\t// Tell it to the Transformation class.\n\t\tTransformation.transform(transformationValue);\n\n\t\t// Since the transformation may have exchanged height and width, we force a\n\t\t// recalculation of the graphics, as if we had loaded a new level.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Show new graphics\n\t\trepaint();\n\t}\n",
    "808": "\tpublic void setLevelToDisplay(Level levelToBeDisplayed) {\n\t\t\n\t\t// Create an own board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Set the passed level on the board.\n\t\ttry {\n\t\t\tboard.setBoardFromString(levelToBeDisplayed.getBoardDataAsString());\n\t\t} catch (Exception e) {\n\t\t\t// Show the error message.\n\t\t\tUtilities.showExceptionError(this, e);\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "810": "\tpublic void setBoardToDisplay(String boardAsString) {\n\t\t\n\t\t// Create an new board.\n\t\tboard = new Board(application);\n\t\t\n\t\t// Create an own board from the board of the level.\n\t\ttry {\n\t\t\tboard.setBoardFromString(boardAsString);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "813": "\tpublic void setInfoBarVisible(boolean visibleStatus) {\n\t\tisInfoBarVisible = visibleStatus;\n\t}\n",
    "814": "\tpublic void setBoardToDisplay(Board board) {\n\t\t\n\t\tthis.board = board;\n\t\t\n\t\t// Array containing the information which graphic has to be drawn at a specific position.\n\t\tgraphicStatus = new byte[board.height * board.width];\n\t\t\n\t\t// New level means every thing has to be recalculated to refresh the Panel.\n\t\tisRecalculationNecessary = true;\n\n\t\t// Repaint this Panel.\n\t\trepaint();\n\t}\n",
    "816": "\tpublic Board getBoard() {\n\t\treturn board;\n\t}\n",
    "819": "\tpublic Level getDisplayedLevel() {\n\t\treturn displayedLevel;\n\t}\n",
    "821": "\tpublic int getSquareWidth() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicWidth;\n\t}\n",
    "823": "\tpublic int getSquareHeight() {\n\t\tif (skin == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn skin.graphicHeight;\n\t}\n",
    "824": "\tfinal public void recalculateGraphicSizes() {\n\t\tisRecalculationNecessary = true;\n\t}\n",
    "827": "\tprivate void setInitialBoardPosition() {\n\t\tboard      = boardInitial.boardElements.clone();\n\t\tplayerPosX = boardInitial.playerPositionX;\n\t\tplayerPosY = boardInitial.playerPositionY;\n\t}\n",
    "835": "\tpublic void paintImmediately() {\n\t\tpaintImmediately(0, 0, getWidth(), getHeight());\n\t}\n",
    "840": "\tprivate void packBoxConfiguration(byte[] newPackedBoxConfiguration, byte[] unpackedBoxConfiguration) {\n\n\t\tint bytePosition = 0, bitPosition = 0;\n\n\t\t// Loop over all internal box positions.\n\t\tfor (int i = 0; i < boxPositionsCount; i++) {\n\n\t\t\tbytePosition = i >> 3;\n\t\t\tbitPosition  = i & 7;\n\n\t\t\tif ((unpackedBoxConfiguration[boxInternalToExternalPosition[i]] & BOX) == BOX)\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] |= 1 << bitPosition;\n\t\t\telse\n\t\t\t\tnewPackedBoxConfiguration[bytePosition] &= (255 - (1 << bitPosition));\n\t\t}\n\t}\n",
    "856": "\tprivate void setVisited(int boardPositionIndex) {\n\t\tint bytePosition = (boardPositionIndex >>> 3), bitPosition = (boardPositionIndex & 7);\n\t\tvisitedData[bytePosition] |= (1 << bitPosition);\n\t}\n",
    "863": "\tfinal public void setCursor(int cursor) {\n\n\t\t// Set the specified predefined cursor.\n\t\tmainBoardDisplay.setCursor(Cursor.getPredefinedCursor(cursor));\n\t}\n",
    "865": "\tprotected void adjustToBoard(Point p) {\n\t\t\n\t\t// Clip both point coordinates at their allowed minimum (inclusive).\n\t\tif( p.x < xOffset ) {\n\t\t\tp.x = xOffset;\n\t\t}\n\t\tif( p.y < yOffset ) {\n\t\t\tp.y = yOffset;\n\t\t}\n\t\t\n\t\t// Compute maximal point coordinates, inclusive...\n\t\tint xmax = xOffset + Transformation.getOutputLevelWidth()  * skin.graphicWidth  - 1;\n\t\tint ymax = yOffset + Transformation.getOutputLevelHeight() * skin.graphicHeight - 1;\n\t\t\n\t\t// ... and use them to clip off larger values:\n\t\tif( p.x > xmax ) {\n\t\t\tp.x = xmax;\n\t\t}\n\t\tif( p.y > ymax ) {\n\t\t\tp.y = ymax;\t\n\t\t}\n\t}\n",
    "866": "\tprivate void paintExtSqRect(int xmin, int ymin, int extWidth, int extHeight) {\n\t\tint pixXmin   = xOffset + xmin * skin.graphicWidth;\n\t\tint pixYmin   = yOffset + ymin * skin.graphicHeight;\n\t\tint pixWidth  =      extWidth  * skin.graphicWidth;\n\t\tint pixHeight =      extHeight * skin.graphicHeight;\n\t\t\n\t\tif (pixWidth > 0 || pixHeight > 0) {\n\t\t\trepaint(pixXmin, pixYmin, pixWidth, pixHeight);\n\t\t\tpaintMovesPushes();\n\t\t}\n\t}\n",
    "870": "\tpublic int getInfluenceDistance(int startSquare, int targetSquare) {\n\t\treturn influenceDistances[startSquare][targetSquare];\n\t}\n",
    "871": "\tfinal public void setNewLanguage() {\n\n\t\t// Create a new menu bar and and a new tool bar according to the new language.\n\t\tapplication.setJMenuBar(createMenuBar());\n\t\tcreateToolBar();\n\t}\n",
    "872": "\tprivate boolean isVisited(int boardPositionIndex) {\n\t\tint i = (boardPositionIndex >>> 3), j = (boardPositionIndex & 7);\n\t\treturn (visitedData[i] & (1 << j)) > 0;\n\t}\n",
    "874": "\tfinal public void addPlayerMove(int direction) {\n\t\taddMovement(direction, -1);\n\t}\n",
    "876": "\t\tpublic void clear() {\n\t\t\tminX = Integer.MAX_VALUE;\n\t\t\tmaxX = Integer.MIN_VALUE;\n\t\t\tminY = Integer.MAX_VALUE;\n\t\t\tmaxY = Integer.MIN_VALUE;\n\t\t}\n",
    "877": "\tfinal public HistoryElement getSuccessorMovement() {\n\t\tif (hasSuccessorMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( ++currentMovementNo );\n\t}\n",
    "878": "\tfinal public HistoryElement getPrecedingMovement() {\n\t\tif (hasPrecedingMovement() == false) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get( currentMovementNo-- );\n\t}\n",
    "881": "\tfinal public HistoryElement getMovement(int movementNo) {\n\n\t\tif (movementNo < 0 || movementNo > movementHistory.size() - 1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn movementHistory.get(movementNo);\n\t}\n",
    "882": "\tfinal public int getCurrentMovementNo() {\n\t\treturn currentMovementNo;\t\n\t}\n",
    "883": "\t\tpublic boolean isEmpty() {\n\t\t\treturn (minX > maxX) || (minY > maxY);\n\t\t}\n",
    "884": "\tfinal public int getMovementsCount() {\n\t\treturn movementHistory.size();\n\t}\n",
    "885": "\tfinal public int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (HistoryElement historyElement : movementHistory) {\n\t\t\tif (historyElement.pushedBoxNo != -1) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\t\treturn pushesCount;\n\t}\n",
    "889": "\tfinal public String getLURDString() {\n\t\treturn getLURDString(0, currentMovementNo);\n\t}\n",
    "890": "\t\tpublic void add(int x, int y) {\n\t\t\tminX = Math.min(minX, x);\n\t\t\tmaxX = Math.max(maxX, x);\n\t\t\tminY = Math.min(minY, y);\n\t\t\tmaxY = Math.max(maxY, y);\n\t\t}\n",
    "891": "\tfinal public String getLURDStringTotal() {\n\t\treturn getLURDString(0, getMovementsCount() - 1);\n\t}\n",
    "893": "\tfinal public void setHistoryToStart() {\n\t\tcurrentMovementNo = -1;\n\t}\n",
    "895": "\tfinal public void setMovementNo(int movementNo) {\n\t\tcurrentMovementNo = movementNo;\n\t}\n",
    "897": "\tfinal public void setStartOfCombinedMovement() {\n\t\tisStartOfCombinedMovement = true;\n\t}\n",
    "898": "\t\tpublic void addExternal(int externalPos) {\n\t\t\tif (externalPos != -1) {\n\t\t\t\tint externalWidth = Transformation.getOutputLevelWidth();\n\t\t\t\tint extX = externalPos % externalWidth;\n\t\t\t\tint extY = externalPos / externalWidth;\n\t\t\t\t\n\t\t\t\tadd(extX, extY);\n\t\t\t}\n\t\t}\n",
    "900": "\tfinal public void goToPrecedingMovement() {\n\t\tcurrentMovementNo--;\n\t}\n",
    "903": "\tfinal public void goToNextMovement() {\n\t\t++currentMovementNo;\n\t}\n",
    "904": "\t\tpublic void addInternal(int internalPos) {\n\t\t\tif (internalPos != -1) {\n\t\t\t\tint externalPos = Transformation.getExternalPosition(internalPos);\n\t\t\t\t\n\t\t\t\taddExternal(externalPos);\n\t\t\t}\n\t\t}\n",
    "905": "\tfinal public boolean hasPrecedingMovement() {\n\t\treturn currentMovementNo >= 0;\n\t}\n",
    "908": "\tfinal public boolean hasSuccessorMovement() {\n\t\treturn (currentMovementNo + 1) < movementHistory.size();\n\t}\n",
    "910": "\tprivate void paintMovesPushes() {\n\t\t// Moves and pushes are displayed as part of the history slider panel.\n\t\tif (historySliderPanel != null) {\n\t\t\t// We have to include the textual representation, as well as the graphical\n\t\t\t// slider representation.  That includes most of the area.\n\t\t\tint w = historySliderPanel.getWidth();\n\t\t\tint h = historySliderPanel.getHeight();\n\t\t\t\n\t\t\t// Redraw the slider. This needn't to be done immediately. Repaint is much\n\t\t\t// faster then paintImmediately.\n\t\t\thistorySliderPanel.repaint(0, 0, w, h);\n\t\t}\n\t}\n",
    "911": "\tfinal public int combinedLengthPreceding() {\n\t\tint steps = 0;\n\t\t\n\t\tfor( int mNo = currentMovementNo; mNo >= 0 ; --mNo ) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn steps;\n\t}\n",
    "913": "\tfinal public int combinedLengthSuccessor() {\n\t\tint steps = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\t++mNo;\n\t\t\t\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++steps;\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn steps;\n\t}\n",
    "915": "\tfinal public int countCombinedForward() {\n\t\tint starts = 0;\n\t\tint mNo = currentMovementNo;\n\t\t\n\t\tfor(;;) {\n\t\t\tHistoryElement histElem = getMovement(mNo);\n\t\t\t\n\t\t\tif( histElem == null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( histElem.isStartOfCombinedMovement ) {\n\t\t\t\t++starts;\n\t\t\t} else if( starts == 0 ) {\n\t\t\t\t++starts;\n\t\t\t}\n\t\t\t++mNo;\n\t\t}\n\t\t\n\t\treturn starts;\n\t}\n",
    "918": "\tfinal public float averageLengthCombinedForward() {\n\t\tint len = getMovementsCount() - currentMovementNo;\n\t\tif( len <= 0 ) {\n\t\t\treturn 0.0f;\n\t\t}\n\t\tint cntcombined = countCombinedForward();\n\t\treturn (float)len / cntcombined;\n\t}\n",
    "932": "\tpublic boolean isABoxBeenMoved() {\n\t\treturn pushedBoxNo != -1;\n\t}\n",
    "939": "\tprivate MouseListener getMouseListener() {\n\t\treturn new MouseAdapter() {\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e) {\n\t\t\t\tif(e.getClickCount() > 1) {\n\t\t\t\t\tint index = locationToIndex(e.getPoint());\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// This action can be disabled (for instance when the solver is running).\n\t\t\t\t\t\tif(!isTakeSolutionAsHistoryEnabled) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tSolution clickedSolution = (Solution) listModel.getElementAt(index);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Set the selected solution as new history in the game.\n\t\t\t\t\t\tapplication.takeSolutionForHistory(clickedSolution);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n",
    "941": "\tfinal public void setEditorMenuItemEnabled(boolean enabled) {\n\t\teditorMenuItem.setEnabled(enabled);\n\t}\n",
    "948": "\tfinal public JMenuItem getSaveLevelMenuItem() {\n\t\treturn saveLevelMenuItem;\n\t}\n",
    "954": "\tfinal public JButton getInfoButton() {\n\t\treturn infoButton;\n\t}\n",
    "960": "\tfinal public void setModeDependentObjectStatus() {\n\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component button : playModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isPlayModeActivated());\n\t\t\t\t}\n\n\t\t\t\tfor (AbstractButton button : editorModeDependentObjects) {\n\t\t\t\t\tbutton.setEnabled(application.isEditorModeActivated());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "966": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boardPositionIndex, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boardPositionIndex / playerSquaresCount);\n\t\tint playerPosition = boardPositionIndex % playerSquaresCount;\n\t\tdebugDisplayBoxConfiguration(temp, playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "969": "\tpublic void setSolutionColor(Solution solution, Color color) {\n\t\tif(color == null) {\n\t\t\tcoloredSolutions.remove(solution);\n\t\t} else {\n\t\t\tcoloredSolutions.put(solution, color);\n\t\t}\n\t}\n",
    "971": "\tfinal public void setSolverDependentObjectsEnabled(final boolean enabledStatus) {\n\t\t\n\t\t// Ensure to change status on the EDT (event dispatcher thread),\n\t\t// because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : solverModeDependentObjects) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "972": "\t\tpublic boolean isValidNewSolution() {\n\t\t\treturn this != INVALID_SOLUTION && this != DUPLICATE_SOLUTION;\n\t\t}\n",
    "973": "\tpublic void setAllSolutionsUncolored() {\n\t\tcoloredSolutions.clear();\n\t}\n",
    "974": "\tprivate void setSelectedViewRow(int viewrowindex) {\n\t\tif (       (viewrowindex >= 0)\n\t\t\t\t&& (tableModelSolutionData != null)\n\t\t\t\t&& (tableModelSolutionData.getRowCount() > 0)\n\t\t\t\t&& (tableSolutionData != null)) {\n\t\t\tListSelectionModel lsm = tableSolutionData.getSelectionModel();\n\t\t\tlsm.setSelectionInterval(viewrowindex, viewrowindex);\n\t\t}\n\t}\n",
    "976": "\tpublic void addActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.register(actionListener);\n\t}\n",
    "979": "\tprotected void showNoSolutionsSelected() {\n\t\tUtilities.showInfoNoteTextKey(getParent(), \"solutionList.noSolutionSelected\");\n\t}\n",
    "980": "\tpublic void removeActionListener(ActionListener actionListener) {\n\t\tactionListenerSet.unregister(actionListener);\n\t}\n",
    "982": "\tprivate void debugDisplayBoardPosition(BoxConfigurationStorageHashtable storage, int boxConfigurationIndex, int playerPosition, final boolean graphicOutput, final boolean waitForEnter) {\n\t\tbyte[] temp = new byte[packedBoardByteSize];\n\t\tstorage.copyBoxConfiguration(temp, boxConfigurationIndex);\n\t\tdebugDisplayBoxConfiguration(temp,playerPosition, graphicOutput, waitForEnter);\n\t}\n",
    "984": "\tfinal public void setUndoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : undoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "985": "\t\tpublic void mouseDragged(MouseEvent evt) {\n\t\t\n\t\t\tif(isMouseDragged == false) {\n\t\t\t\n\t\t\t\tstartOfLastDrag = evt.getWhen();\n\t\t\t\t\n\t\t\t\t// Save the dragged status.\n\t\t\t\tisMouseDragged = true;\n\t\t\t}\n\t\t\t\n\t\t\tmousePressed(evt);\n\t\t}\t\t\n",
    "987": "\tprivate void informThemHere(final Solution solution, final String action) {\n\t\tactionListenerSet.informAllSync(makeActionGenerator(solution, action));\n\t}\n",
    "989": "\tprivate void informListeners(final Solution solution, final String action) {\n\t\n\t\t// The GUI should be updated in the EDT.\n\t\tif(SwingUtilities.isEventDispatchThread()) {\n\t\t\tinformThemHere(solution, action);\n\t\t}\n\t\telse {\n\t\t\t// Update the GUI before this thread continues. \n\t\t\ttry {\n\t\t\t\tSwingUtilities.invokeAndWait(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tinformThemHere(solution, action);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t} catch (InvocationTargetException e) { /* just continue */ }\n\t\t}\n\t}\n",
    "993": "\tpublic void setTakeSolutionAsHistoryVisible(boolean isVisible) {\n\t\tisTakeSolutionAsHistoryEnabled = isVisible;\n\t}\n",
    "996": "\tfinal public void setRedoButtonsEnabled(final boolean enabledStatus) {\n\n\t\t// Ensure to change status on the EDT, because this method may be called from a background thread.\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tfor (Component component : redoButtons) {\n\t\t\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n",
    "1000": "\t\tpublic void addSolutionToBeHighlighted(Solution solution) {\n\t\t\thighlightedSolutions.put(solution, 10);\n\t\t\t\n\t\t\t// Inform this thread that new solutions are to be highlighted.\n\t\t\tsynchronized(this) {\n\t\t\t\tnotify();\n\t\t\t}\n\t\t}\n",
    "1002": "\t\tpublic void removeAllSolutionsToBeHighlighted() {\n\t\t\thighlightedSolutions.clear();\n\t\t}\n",
    "1006": "\t\tpublic Integer getHighlightIntensity(Solution solution) {\n\t\t\treturn highlightedSolutions.get(solution);\n\t\t}\n",
    "1014": "\tfinal public void setInvalidLevelModeDependentObjectsEnabled(boolean enabledStatus) {\n\n\t\tfor (Component component : invalidLevelModeDependentObjects) {\n\t\t\tcomponent.setEnabled(enabledStatus);\n\t\t}\n\n\t\t// An invalid level can't have a movement history.\n\t\t// Hence, disable the undo/redo buttons.\n\t\tsetUndoButtonsEnabled(enabledStatus);\n\t\tsetRedoButtonsEnabled(enabledStatus);\n\n\t\t// Enable the editor menu item so the user can open the editor.\n\t\tsetEditorMenuItemEnabled(true);\n\t}\n",
    "1015": "\tpublic boolean isValidLastChanged() {\n\t\tif (lastChanged != null) {\n\t\t\tif (lastChanged.getTime() > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1025": "\tfinal public void setDebugMenuVisible(boolean isToBeVisible) {\n\t\tfor (Component component : debugModeDependentObjects) {\n\t\t\tcomponent.setVisible(isToBeVisible);\n\t\t}\n\t}\n",
    "1035": "\tpublic SolutionsGUI getSolutionsView() {\n\t\treturn solutionsGUI;\n\t}\n",
    "1041": "\tfinal public void update(String expression) {\n\n\t\ttry {\n\t\t\tStatement st = conn.createStatement();\n\n\t\t\t// Run the query.\n\t\t\tif (st.executeUpdate(expression) == -1) {\n\t\t\t\tSystem.out.println(\"db error: \" + expression);\n\t\t\t}\n\n\t\t\t// Close the Statement object.\n\t\t\tst.close();\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n",
    "1046": "\tprivate void waitForDeadlockIdentification() {\n\t\ttry {\n\t\t\tif(deadlockIdentification.isAlive()) {\n\t\t\t\toptimizerGUI.setInfoText(Texts.getText(\"optimizer.waitingForDeadlockDetection\"));\n\t\t\t\tdeadlockIdentification.join();\n\t\t\t}\n\t\t} catch (InterruptedException e) {}\n\t}\n",
    "1049": "\tfinal public void saveLevel(Level level, String fileName) throws IOException {\n\n\t\t// Create a PrintWriter for writing the data to hard disk.\n\t\tPrintWriter levelFile = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));\n\n\t\t// Write the level data to the file.\n\t\twriteLevelToFile(level, levelFile);\n\n\t\t// Check the error status.\n\t\tboolean isFileSavingFailed = levelFile.checkError();\n\n\t\t// Close the file.\n\t\tlevelFile.close();\n\n\t\t// Throw exception in the case of an error.\n\t\tif (isFileSavingFailed) {\n\t\t\tthrow new IOException(Texts.getText(\"errorBySaving\"));\n\t\t}\n\t}\n",
    "1055": "\tfinal public int getSquareCharacter(int xPosition, int yPosition) {\n\n\t\t// Select the line by the Y coordinate\n\t\tif (yPosition < 0 || yPosition >= boardData.size()) {\n\t\t\treturn ' ';\n\t\t}\n\t\tfinal String line = boardData.get(yPosition);\n\t\t\n\t\t// The level lines need not be filled with spaces at the end.\n\t\t// Such a line may be shorter than the level width.\n\t\tif (xPosition < 0 || xPosition >= line.length()) {\n\t\t\treturn ' ';\n\t\t}\n\n\t\treturn line.charAt(xPosition);\n\t}\n",
    "1066": "\tprotected void refreshView() {\n\t\tactionPerformed(new ActionEvent(this, 0, \"refreshView\"));\n\t}\n",
    "1071": "\t\tpublic int getID() {\n\t\t\treturn ID;\n\t\t}\n",
    "1092": "\tprotected void updateComboBoxAuthors() {\n\t\t\n\t\t// Update all needed ComoboBoxes of this view.\n\t\tsuper.updateComboBoxAuthors(comboBoxAuthors, selectionAuthor);\n\t\t\n\t\t// When adding new items the combo boxes should not fire actions.\n\t\t// (If this isn't set the combo boxes refresh the views every time their content changes)\n\t\tdoNotFireActions = true;\n\t\t\n\t\t// The selection ComboBox's first item is always the wildcard \"*\".\n\t\tselectionAuthor.insertItemAt(new ComboBoxEntry(\"*\", 0), 0);\n\t\t\n\t\t// Set the wildcard as selected.\n\t\tselectionAuthor.setSelectedIndex(0);\n\t\t\n\t\t// Actions may be fired again.\n\t\tdoNotFireActions = false;\n\t}\n",
    "1097": "    protected void finalize() {\n    \tdatabaseViews.dispose();\n    \tdatabaseViews = null;\n    }\n",
    "1098": "    \tstatic public void authorsNamesChanged() {\n    \t\tfor(int i=0; i<changeInAuthorView.length; i++) {\n    \t\t\tchangeInAuthorView[i] = true;\n    \t\t}\n    \t}\n",
    "1100": "    \tstatic public void collectionNamesChanged() {\n    \t\tfor(int i=0; i<changeInCollectionView.length; i++) {\n    \t\t\tchangeInCollectionView[i] = true;\n    \t\t}\n    \t}\n",
    "1102": "    \tstatic public void changeInAssignmentView() {\n    \t\tfor(int i=0; i<changeInAssignmentView.length; i++) {\n    \t\t\tchangeInAssignmentView[i] = true;\n    \t\t}\n    \t}\n",
    "1103": "    \tstatic public void changeInLevelView() {\n    \t\tfor(int i=0; i<changeInLevelView.length; i++) {\n    \t\t\tchangeInLevelView[i] = true;\n    \t\t}\n    \t}\n",
    "1107": "    \tstatic public void resetUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = false;\n        \tchangeInCollectionView[view] = false;\n        \tchangeInAssignmentView[view] = false;\n        \tchangeInLevelView[view]      = false;\n    \t}\n",
    "1108": "    \tstatic public void setUpdateFlags(int view) {\n    \t\tchangeInAuthorView[view]     = true;\n        \tchangeInCollectionView[view] = true;\n        \tchangeInAssignmentView[view] = true;\n        \tchangeInLevelView[view]      = true;\n    \t}\n",
    "1114": "\tprotected void updateAdditionalInformation() {\n\t\tint firstSelectedRow = tableLevelData.convertRowIndexToModel(tableLevelData.getSelectionModel().getMinSelectionIndex());\n\t\tvalueChanged(new ListSelectionEvent(tableLevelData.getSelectionModel(), firstSelectedRow, firstSelectedRow, false));\n\t}\n",
    "1115": "\tfinal public int getNumberOfStoredBoardPositions() {\n\t\treturn count;\n\t}\n",
    "1120": "\tfinal public void clear() {\n\t\t// This code is similar to hash table.clear()\n\t\tEntry tab[] = table;\n\t\t\n\t\tfor (int index = tab.length; --index >= 0;) {\n\t\t\ttab[index] = null;\n\t\t}\n\t\tcount = 0;\n\t}\n",
    "1123": "\t\tpublic Object getBoardPosition() {\n\t\t\treturn boardPosition;\n\t\t}\n",
    "1125": "\tprotected Object getSelectedCollection() {\n\t\treturn selectionCollection.getSelectedItem();\n\t}\n",
    "1127": "\tprotected int bytesPerAtom() {\n\t\treturn (4);\n\t}\n",
    "1129": "\tprotected int bytesPerLine() {\n\t\treturn (72);\n\t}\n",
    "1135": "\t\tprotected int decodeLinePrefix(PushbackInputStream aStream, OutputStream bStream) throws IOException {\n\t\t\treturn (bytesPerLine());\n\t\t}\n",
    "1138": "\t\tprotected void decodeAtom(PushbackInputStream aStream, OutputStream bStream, int l) throws IOException {\n\t\t\tthrow new IOException();\n\t\t}\n",
    "1144": "\t\tpublic byte decodeBuffer(String inputString)[] throws IOException {\n\t\t\tbyte    inputBuffer[] = new byte[inputString.length()];\n\t\t\tByteArrayInputStream inStream;\n\t\t\tByteArrayOutputStream outStream;\n\n\t\t\tinputBuffer = inputString.getBytes();\n\t\t\tinStream = new ByteArrayInputStream(inputBuffer);\n\t\t\toutStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(inStream, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1146": "\t\tpublic byte decodeBuffer(InputStream in)[] throws IOException {\n\t\t\tByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\t\t\tdecodeBuffer(in, outStream);\n\t\t\treturn (outStream.toByteArray());\n\t\t}\n",
    "1150": "\tpublic void setStep(int msStep) {\n\t\tstepMillis = msStep;\n\t}\n",
    "1152": "\tpublic int getStep() {\n\t\treturn stepMillis;\n\t}\n",
    "1153": "\tpublic void setLength(int len) {\n\t\tintendedLength = len;\n\t}\n",
    "1155": "\tpublic int getLength() {\n\t\treturn intendedLength;\n\t}\n",
    "1157": "\tstatic public Delays makeDelayNormal() {\n\t\treturn makeDelayNormal(0);\n\t}\n",
    "1158": "\tstatic public Delays makeDelayNormal(int seqLength) {\n\t\treturn new Delays(Settings.delayValue, seqLength);\n\t}\n",
    "1159": "\tstatic public Delays makeDelayUndoRedo() {\n\t\treturn makeDelayUndoRedo(0);\n\t}\n",
    "1161": "\tprivate void saveButtonActionPerformed() {\n\n\t\t// Save properties to a file.\n\t\tsaveProperties(newLanguageProperties, getFilepathFromLanguageCode(newLanguageCode));\n\n\t\t// Make new backup copy of properties.\n\t\tlastSavedNewLanguageProperties = (Properties) newLanguageProperties.clone();\n\t}\n",
    "1162": "\tstatic public Delays makeDelayUndoRedo(int seqLength) {\n\t\treturn new Delays(Settings.delayValueUndoRedo, seqLength);\n\t}\n",
    "1163": "\tpublic void start() {\n\t\tif ( ! started ) {\n\t\t\tlastNow = System.currentTimeMillis();\n\t\t\tstarted = true;\n\t\t}\n\t}\n",
    "1164": "\tpublic void stop() {\n\t\tstarted = false;\n\t}\n",
    "1169": "\tprivate int effStepInt( boolean slowstep ) {\n\t\tfloat step = effStep(slowstep);\n\t\tint  istep = Math.round(step);\n\t\t\n\t\t// When we would tell a zero delay (or even less), but the original\n\t\t// intention was a positive delay, we shall return the smallest\n\t\t// possible positive value: 1.\n\t\tif( istep <= 0 ) {\n\t\t\tif( stepMillis > 0 ) {\n\t\t\t\tistep = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Never consider negative values\n\t\tif( istep < 0 ) {\n\t\t\tistep = 0;\n\t\t}\n\t\t\n\t\treturn istep;\n\t}\n",
    "1172": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start the backward search.\n\t\t\t\t\tbackwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\t}\n",
    "1173": "\tstatic public void main(String[] argv) {\n\n\t\t// Check for debug parameters.\n\t\tfor(String parameter : argv) {\n\t\t\tif(parameter.equalsIgnoreCase(\"-debug\")) {\n\t\t\t\tSettings.isDebugModeActivated = true;\t\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugSettings\")) {\n\t\t\t\tSettings.isSettingsDebugModeActivated = true;\n\t\t\t}\n\t\t\tif(parameter.equalsIgnoreCase(\"-debugTiming\")) {\n\t\t\t\tSettings.isTimingDebugModeActivated = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Save the information whether this program is started as \"web start application\".\n\t\tSettings.isStartedAsWebStartApplication =\n\t\t\t\t\t   (argv.length > 0 && argv[0].equals(\"-webstart\"))\n\t\t\t\t\t|| (argv.length > 1 && argv[1].equals(\"-webstart\"));\n\t\t\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew JSoko().startProgram();\n\t\t\t}\n\t\t});\n\t}\n",
    "1174": "\tpublic void sleep(boolean reassertIntr) {\n\t\tsleep(reassertIntr, false);\n\t}\n",
    "1177": "\tprivate char decryptCharcode(int c, int start, int end, int offset) {\n\t\t\n\t\tc+=offset;\n\t\tif(offset > 0 && c > end){\n\t\t\tc= (start+(c-end-1));\n\t\t}\n\t\telse if(offset < 0 && c < start){\n\t\t\tc= (end-(start-c-1));\n\t\t}\n\t\treturn (char) c;\n\t}\n",
    "1179": "\tprivate void restoreButtonActionPerformed(ActionEvent evt) {\n\t\tnewLanguageProperties = (Properties) lastSavedNewLanguageProperties.clone();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\trefreshTranslationTextAreas();\n\t}\n",
    "1183": "\tprotected void stateChanged() {\n\t\tChangeEvent e = new ChangeEvent(this);\n\t\tfor (ChangeListener listener : changeListeners) {\n\t\t\tlistener.stateChanged(e);\n\t\t}\n\t}\n",
    "1186": "\tpublic void addValueListener(ChangeListener listener) {\n\t\tchangeListeners.add(listener);\n\t}\n",
    "1188": "\tpublic double getValueAsDouble() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn (Double) currentValue;\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn ((Integer) currentValue).doubleValue();\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1189": "\tpublic int getValueAsInteger() {\n\t\tObject currentValue = getValue();\n\t\tif (currentValue instanceof Double) {\n\t\t\treturn ((Double) currentValue).intValue();\n\t\t}\n\t\tif (currentValue instanceof Integer) {\n\t\t\treturn (Integer) currentValue;\n\t\t}\n\n\t\treturn 0;\n\t}\n",
    "1193": "\tpublic void setMinRAMinMiB(long minRAMinMiB) {\n\t\tthis.minRAMinMiB = minRAMinMiB;\n\t}\n",
    "1194": "\tprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n\t\tif (minRAMinMiB >= 0) {\n\t\t\t// We are limited...\n\t\t\tif (size() >= 2) {\n\t\t\t\t// We are large enough to loose an entry...\n\t\t\t\tif (Utilities.getMaxUsableRAMinMiB() < minRAMinMiB) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "1197": "\tpublic V getV(K key) {\n\t\treturn map.get(key);\n\t}\n",
    "1199": "\tpublic void add(K key, V value) {\n\t\tmap.put(key, value);\n\t}\n",
    "1200": "\tpublic void trimToSize() {\n\t\t// we cannot do anything useful, here\n\t}\n",
    "1215": "\tfinal public Object clone() {\n\t\treturn new BoxData(this);\n\t}\n",
    "1216": "\tfinal public void setBoxStartPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1218": "\tfinal public void setBoxPosition(int boxNo, int boxPosition) {\n\t\tboxPositions[boxNo] = boxPosition;\n\t}\n",
    "1219": "\tfinal public void setBoxPositions(int[] newBoxPositions) {\n\n\t\t// We must use a copy of the the array!\n\t\t// The caller does not donate this object, he will continue\n\t\t// to use and modify that array, while we expect to own this array.\n\t\tboxPositions = newBoxPositions.clone();\n\t}\n",
    "1221": "\tfinal public void setBoxActive(int boxNo) {\n\t\tisBoxInactive[boxNo] = false;\n\t}\n",
    "1223": "\tfinal public void setBoxInactive(int boxNo) {\n\t\tisBoxInactive[boxNo] = true;\n\n\t\t// An inactive box cannot be part of a corral\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1224": "\tfinal public boolean isBoxActive(int boxNo) {\n\t\treturn isBoxInactive[boxNo] == false;\n\t}\n",
    "1225": "\tfinal public boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "1226": "\tfinal public void setBoxFrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = true;\n\t}\n",
    "1227": "\tpublic void setLevelForPlaying(int levelNo) {\n\t\tsetLevelForPlaying(currentLevelCollection.getLevel(levelNo));\n\t}\n",
    "1228": "\tfinal public boolean isBoxFrozen(int boxNo) {\n\t\treturn isBoxFrozen[boxNo];\n\t}\n",
    "1230": "\tfinal public void setBoxUnfrozen(int boxNo) {\n\t\tisBoxFrozen[boxNo] = false;\n\t}\n",
    "1231": "\tfinal public void setBoxInCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = true;\n\t}\n",
    "1232": "\tfinal public void removeBoxFromCorral(int boxNo) {\n\t\tisBoxInCorral[boxNo] = false;\n\t}\n",
    "1233": "\tfinal public boolean isBoxInCorral(int boxNo) {\n\t\treturn isBoxInCorral[boxNo];\n\t}\n",
    "1234": "\tfinal public int getBoxPosition(int boxNo) {\n\t\treturn boxPositions[boxNo];\n\t}\n",
    "1236": "\tfinal public boolean isEveryBoxOnAGoal() {\n\n\t\t// Check all boxes for \"on goal\"\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated boxes\n\t\t\tif (isBoxInactive(boxNo))\n\t\t\t\tcontinue;\n\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1237": "\tpublic int getBoxesOnGoalsCount() {\n\t\tint boxesOnGoalsCount = 0;\n\t\tfor(int boxNo=0; boxNo<boxCount; boxNo++) {\n\t\t\t// TODO: explain why inactive boxes are not ignored Answer: bad programming. this method\n\t\t\t// is only used when a new level is loaded and all boxes are active. Inactive boxes are\n\t\t\t// only there during deadlock detection. Nevertheless, I think it's better to check for \n\t\t\t// inactive boxes here, too. I will have a look at this at some time. \n\t\t\tif(board.isGoal(getBoxPosition(boxNo))) {\n\t\t\t\tboxesOnGoalsCount++;\n\t\t\t}\n\t\t}\n\t\treturn boxesOnGoalsCount;\n\t}\n",
    "1238": "\tfinal public boolean isEveryBoxOnABackwardGoal() {\n\n\t\tint[] backwardGoalPositions = board.getGoalPositionsBackward();\n\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tif (isBoxInactive(boxNo)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBox(backwardGoalPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1239": "\tfinal public boolean isEveryCorralBoxOnAGoal() {\n\n\t\t// check all boxes\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\t// ignore deactivated and non-corral boxes\n\t\t\tif (isBoxInactive(boxNo) || isBoxInCorral(boxNo) == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (board.isBoxOnGoal(boxPositions[boxNo]) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "1242": "\tfinal public void setAllBoxesNotFrozen() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tisBoxFrozen[boxNo] = false;\n\t\t}\n\t}\n",
    "1243": "\tpublic long length() {\n\t\treturn size;\n\t}\n",
    "1244": "\tpublic byte getAt(long lax) {\n\t\tif ((lax < 0) || (lax >= size)) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\"lax=\"+lax+\",size=\"+size);\n\t\t}\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ]);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\treturn (arrvec[(int)blockno][(int)eleminx]);\n\t}\n",
    "1246": "\tpublic byte putAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] = val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] = val);\n\t}\n",
    "1248": "\tpublic byte orAt(long lax, byte val) {\n\t\tif (lax < blocksize) {\n\t\t\t// the simple case: one flat array\n\t\t\treturn (arrvec[0][ (int)lax ] |= val);\n\t\t}\n\t\tlong blockno = lax / blocksize;\n\t\tlong eleminx = lax % blocksize;\n\t\t// FFS/hm: index out of range\n\t\treturn (arrvec[(int)blockno][(int)eleminx] |= val);\n\t}\n",
    "1253": "\tpublic long getNumBitsAt( long bitlax, int totbits ) {\n\t\tif (totbits > 64 || totbits < 0) {\n\t\t\tthrow new java.lang.UnsupportedOperationException(\"bits=\"+totbits);\n\t\t}\n\t\t// asserted: 0 <= totbits <= 64\n\t\tlong result = 0;\n\t\t\n\t\tint  resoff = 0;\n\t\twhile (totbits > resoff) {\n\t\t\tint  toget  = totbits - resoff;\n\t\t\tbyte bitoff = (byte)(bitlax & 0x07);\t// [0..7]\n\t\t\tlong lax    = bitlax >>> 3;\n\n\t\t\tint bitlen = 8 - bitoff;\t\t// so many in this byte [1..8]\n\t\t\tif (bitlen > toget) {\n\t\t\t\tbitlen = toget;\n\t\t\t}\n\t\t\tlong v    = getAt(lax) & 0xffL;\n\t\t\tv      >>>= bitoff;\n\t\t\tv        &= (1L << bitlen) - 1;\n\n\t\t\tresult |= (v << resoff);\n\t\t\tresoff += bitlen;\n\t\t\tbitlax += bitlen;\n\t\t}\n\t\treturn result;\n\t}\n",
    "1257": "\tpublic void showMissingFileDialog(String filePath, int messageType) {\n\t\tJOptionPane.showMessageDialog(\n\t\t\t\tparent,\n\t\t\t\t\"File: \" + filePath + \" is missing!\",\n\t\t\t\t\"Error\",\n\t\t\t\tmessageType);\n\n\t\tif (messageType == JOptionPane.ERROR_MESSAGE) {\n\t\t\tsetBlankProject();\n\t\t}\n\t}\n",
    "1258": "\tpublic boolean isEmpty() {\n\t\treturn root == null;\n\t}\n",
    "1259": "\tpublic void clear() {\n\t\tthis.root      = null;\n\t\tthis.elemcount = 0;\n\t}\n",
    "1264": "\tprivate Properties loadPropertiesByFilename(String fileName) throws IOException {\n\n\t\t// Create new properties.\n\t\tProperties tempProp = new Properties();\n\n\t\t// Get input stream to the property file.\n\t\tInputStream inPropFile = Utilities.getInputStream(fileName);\n\t\t\n\t\ttry {\n\t\t\t// Load properties.\n\t\t\ttempProp.load(inPropFile);\n\t\t\t\n\t\t\t// Close file.\n\t\t\tinPropFile.close();\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\n\t\t// Return the read properties.\n\t\treturn tempProp;\n\n\t}\n",
    "1268": "\tprivate Properties loadPropertiesByLanguageCode(String languageCode) throws IOException {\n\n\t\t// Return the read properties.\n\t\treturn loadPropertiesByFilename(getFilepathFromLanguageCode(languageCode));\n\n\t}\n",
    "1275": "\tpublic V rd(long inx) {\n\t\treturn rd(root, MAX_DEP, inx);\n\t}\n",
    "1277": "\tprivate void paput(Inner<V> pa, byte painx, Node<V> nref) {\n\t\tif (pa == null) {\n\t\t\troot = nref;\n\t\t} else {\n\t\t\t// Store leaf where we found the null in the last step\n\t\t\tpa.iput(painx, nref);\n\t\t}\n\t}\n",
    "1278": "\tprivate void reloadGUI() {\n\t\tchangeLanguageComboBoxes();\n\n\t\tloadLanguageTexts(NEW_LANGUAGE_COLUMN);\n\t\tloadLanguageTexts(HINT_LANGUAGE_COLUMN);\n\n\t\t// Set new and hint language combo boxes for default values.\n\t\tString language = (new Locale(Settings.get(\"newTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\n\t\tnewLanguageComboBox.setSelectedItem(language);\n\n\t\tlanguage = (new Locale(Settings.get(\"hintTranslationLanguage\"))).getDisplayLanguage(getUserLocale());\n\t\thintLanguageComboBox.setSelectedItem(language);\n\n\t\t// By default select the first row of the table.\n\t\tif (table.getRowCount() > 0) {\n\t\t\ttable.changeSelection(0, NEW_LANGUAGE_COLUMN, false, false);\n\t\t}\n\t}\n",
    "1279": "\tpublic void redraw(boolean waitForEnter) {\n\n\t\t// Draw the new GUI.\n\t\tapplicationGUI.mainBoardDisplay.repaint();\n\n\t\t// For debugging purposes wait for \"Enter\"\n\t\tif (waitForEnter) {\n\t\t\tJDialog dialog = new JOptionPane(\"\").createDialog(null, \"Waiting for Enter\");\n\t\t\tdialog.setLocation(getX() + getWidth() + 45, getY() + 10);\n\t\t\tdialog.setVisible(true);\n\t\t\t// Beginners explanation: The above dialog is \"modal\", and hence freezes\n\t\t\t// all other graphics activity.  That way \"we wait\" by being frozen.\n\t\t\t// When \"setVisible(true)\" returns, the dialog is done!\n\t\t}\n\t}\n",
    "1281": "\tpublic V wr(long inx, V val) {\n\t\treturn wr(root, MAX_DEP, inx, val);\n\t}\n",
    "1283": "\tfinal public void removeBox(int position) {\n\t\tboxesArray[position] = false;\n\t}\n",
    "1287": "\tprivate void calculateLowerboundOfAllLevel() {\n\n\t\tfinal int maxLevelNo = currentLevelCollection.getNumberOfLevels();\n\t\tint[] lowerbounds = new int[1 + maxLevelNo];\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tsetLevelForPlaying(levelNo);\n\t\t\tlowerbounds[levelNo] = board.lowerbound.calculateLowerbound(SearchDirection.FORWARD);\n\t\t}\n\n\t\tfor (int levelNo = 1; levelNo <= maxLevelNo; levelNo++) {\n\t\t\tSystem.out.printf(\"Level: %3d  Name: %-60s Lowerbound: %3d \\n\",\n\t\t\t\t\tlevelNo, currentLevelCollection.getLevel(levelNo).getTitle(), lowerbounds[levelNo]);\n\t\t}\n\t}\n",
    "1290": "\t\t\tpublic void run() {\n\n\t\t\t\ttry {\n\t\t\t\t\t// Start a new forward search.\n\t\t\t\t\tforwardSearch();\n\n\t\t\t\t} catch (OutOfMemoryError e) {\n\t\t\t\t\t// Stop the optimizer by setting the proper stop reason.\n\t\t\t\t\toptimizerStatus = OptimizerStatus.STOPPED_DUE_TO_OUT_OF_MEMORY;\n\t\t\t\t}\n\n\t\t\t}\n",
    "1291": "\tfinal public void removeBoxByNumber(int boxNo) {\n\t\tboxesArray[boxData.getBoxPosition(boxNo)] = false;\n\t}\n",
    "1296": "\tpublic boolean isPlayModeActivated() {\n\t\treturn gameMode == GameMode.PLAY;\n\t}\n",
    "1300": "\tfinal public void removeBox(int x, int y) {\n\t\tboxesArray[x + width * y] = false;\n\t}\n",
    "1304": "\tpublic boolean isEditorModeActivated() {\n\t\treturn gameMode == GameMode.EDITOR;\n\t}\n",
    "1308": "\tfinal public void removeWall(int position) {\n\t\twallsArray[position] -= ((wallsArray[position] > 0) ? 1 : 0);\n\t}\n",
    "1313": "\tprivate void setInvalidLevelMode() {\n\t\tapplicationGUI.setInvalidLevelModeDependentObjectsEnabled(false);\n\t\tgameMode = GameMode.INVALID_LEVEL;\n\t}\n",
    "1319": "\tfinal public void removeWall(int x, int y) {\n\t\twallsArray[x + width * y] -= ((wallsArray[x + width * y] > 0) ? 1 : 0);\n\t}\n",
    "1344": "\tfinal public void removeGoal(int position) {\n\t\tgoalsArray[position] = false;\n\t}\n",
    "1373": "\tfinal public void removeGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = false;\n\t}\n",
    "1378": "\tpublic long firstInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(true, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1384": "\tpublic long lastInx() {\n\t\tif (isEmpty()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tArrEntry<V> e = findFiLa(false, true, null);\n\t\treturn e.inx;\n\t}\n",
    "1393": "\tfinal public void removePlayer() {\n\t\tplayerPosition = NO_PLAYER;\n\t}\n",
    "1453": "\tfinal public void setBox(int position) {\n\t\tboxesArray[position] = true;\n\t}\n",
    "1496": "    public String send(){\n        //do real logic\n        return (\"success\");\n    }\n",
    "1503": "\tfinal public void setBox(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t}\n",
    "1518": "\tprivate int nextLockId() {\n\t\tif (nextLockId==Integer.MAX_VALUE) nextLockId = Integer.MIN_VALUE;\n\t\treturn nextLockId++;\n\t}\n",
    "1519": "\tprivate void decrementLock(Object key, Lock lock) throws CacheException {\n\t\t//decrement the lock\n\t\tlock.unlock( cache.nextTimestamp() );\n\t\tif ( cache instanceof ClusterCache)\n\t\t\t((ClusterCache)cache).putQuiet(key, lock);\n\t\telse\n\t\t\tcache.put(key, lock);\n\t}\n",
    "1534": "    public Object get(Object key) throws CacheException {\n        try {\n            if ( log.isDebugEnabled() ) {\n                log.debug(\"key: \" + key);\n            }\n            if (key == null) {\n                return null;\n            } \n            else {\n                Element element = cache.get( (Serializable) key );\n                if (element == null) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug(\"Element for \" + key + \" is null\");\n                    }\n                    return null;\n                } \n                else {\n                    return element.getValue();\n                }\n            }\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1536": "\tfinal public void setBoxWithNo(int boxNo, int position) {\n\t\tboxesArray[position] = true;\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1537": "    public void put(Object key, Object value) throws CacheException {\n        try {\n            Element element = new Element( (Serializable) key, (Serializable) value );\n            cache.put(element);\n        } \n        catch (IllegalArgumentException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n\n    }\n",
    "1538": "    public void remove(Object key) throws CacheException {\n        try {\n            cache.remove( (Serializable) key );\n        } \n        catch (ClassCastException e) {\n            throw new CacheException(e);\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1540": "    public void clear() throws CacheException {\n        try {\n            cache.removeAll();\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (IOException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1542": "    public void destroy() throws CacheException {\n        try {\n            CacheManager.getInstance().removeCache( cache.getName() );\n        } \n        catch (IllegalStateException e) {\n            throw new CacheException(e);\n        } \n        catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n",
    "1543": "    public void lock(Object key) throws CacheException {\n    }\n",
    "1545": "    public void unlock(Object key) throws CacheException {\n    }\n",
    "1546": "\tprivate void setUndoRedoFromHistory() {\n\t\tapplicationGUI.setUndoButtonsEnabled(movementHistory.hasPrecedingMovement());\n\t\tapplicationGUI.setRedoButtonsEnabled(movementHistory.hasSuccessorMovement());\n\t}\n",
    "1547": "\t\tpublic long getFreshTimestamp() {\n\t\t\treturn freshTimestamp;\n\t\t}\n",
    "1548": "    public long nextTimestamp() {\n        return Timestamper.next();\n    }\n",
    "1549": "    public int getTimeout() {\n        // 60 second lock timeout\n        return Timestamper.ONE_MS * 60000;\n    }\n",
    "1550": "\t\tpublic Object getValue() {\n\t\t\treturn value;\n\t\t}\n",
    "1552": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\treturn new Lock(timeout, id, version);\n\t\t}\n",
    "1554": "\t\tpublic boolean isLock() {\n\t\t\treturn false;\n\t\t}\n",
    "1555": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn freshTimestamp < txTimestamp;\n\t\t}\n",
    "1558": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\t// we really could refresh the item if it  \n\t\t\t// is not a lock, but it might be slower\n\t\t\t//return freshTimestamp < txTimestamp\n\t\t\treturn  ( version!=null && newVersion!=null)&& comparator.compare(version, newVersion) < 0;\n\t\t}\n",
    "1561": "\tfinal public void setBoxWithNo(int boxNo, int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1563": "\tpublic boolean greaterThan(LockMode mode) {\n\t\treturn level > mode.level;\n\t}\n",
    "1564": "\tpublic boolean lessThan(LockMode mode) {\n\t\treturn level < mode.level;\n\t}\n",
    "1572": "\t\tpublic Lock lock(long timeout, int id) {\n\t\t\tconcurrentLock = true;\n\t\t\tmultiplicity++;\n\t\t\tthis.timeout = timeout;\n\t\t\treturn this;\n\t\t}\n",
    "1579": "\t\tpublic void unlock(long currentTimestamp) {\n\t\t\tif ( --multiplicity == 0 ) {\n\t\t\t\tunlockTimestamp = currentTimestamp;\n\t\t\t}\n\t\t}\n",
    "1587": "\t\tpublic boolean isPuttable(long txTimestamp, Object newVersion, Comparator comparator) {\n\t\t\tif (timeout < txTimestamp) return true;\n\t\t\tif (multiplicity>0) return false;\n\t\t\treturn version==null || newVersion==null? \n\t\t\t\tunlockTimestamp < txTimestamp :\n\t\t\t\tcomparator.compare(version, newVersion) < 0; //by requiring <, we rely on lock timeout in the case of an unsuccessful update!\n\t\t}\n",
    "1592": "\t\tpublic boolean wasLockedConcurrently() {\n\t\t\treturn concurrentLock;\n\t\t}\n",
    "1599": "\t\tpublic boolean isLock() {\n\t\t\treturn true;\n\t\t}\n",
    "1605": "\t\tpublic boolean isGettable(long txTimestamp) {\n\t\t\treturn false;\n\t\t}\n",
    "1617": "\tfinal public void setBoxOnGoal(int position) {\n\t\tboxesArray[position] = true;\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1634": "    public Mapper createMapper() throws BuildException {\n        if (_mapper != null) {\n            throw new BuildException(\"Cannot define more than one mapper\");\n        }\n        _mapper = new Mapper(this.getProject());\n        return _mapper;\n    }\n",
    "1638": "\tprivate void exportLevelToClipboard(boolean withRLE) {\n\t\texportLevelToClipboard(withRLE, false);\n\t}\n",
    "1647": "\tfinal public void setBoxOnGoal(int x, int y) {\n\t\tboxesArray[x + width * y] = true;\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1665": "\tfinal public void setGoal(int position) {\n\t\tgoalsArray[position] = true;\n\t}\n",
    "1680": "\tfinal public void setGoal(int x, int y) {\n\t\tgoalsArray[x + width * y] = true;\n\t}\n",
    "1692": "\tfinal public void setWall(int position) {\n\t\twallsArray[position]++;\n\t}\n",
    "1704": "\tfinal public void setWall(int x, int y) {\n\t\twallsArray[x + width * y]++;\n\t}\n",
    "1716": "\tfinal public void setBoxNo(int boxNo, int position) {\n\t\tboxNumbers[position] = boxNo;\n\t}\n",
    "1727": "\tfinal public void setBoxNo(int boxNo, int x, int y) {\n\t\tboxNumbers[x + width * y] = boxNo;\n\t}\n",
    "1738": "\tfinal public void setAdvancedSimpleDeadlock(int position) {\n\t\tadvancedSimpleDeadlockSquareForwards[position] = true;\n\t}\n",
    "1761": "\tfinal public void setPlayerPosition(int position) {\n\t\tplayerPosition = position;\n\t}\n",
    "1778": "\tfinal public void setPlayerPosition(int x, int y) {\n\t\tplayerPosition = x + width * y;\n\t}\n",
    "1808": "\tfinal public boolean isCorralForcerSquare(int position) {\n\t\treturn corralForcer[position];\n\t}\n",
    "1837": "\tfinal public boolean isCorralForcerSquare(int x, int y) {\n\t\treturn corralForcer[x + width * y];\n\t}\n",
    "1865": "\tfinal public boolean isBox(int position) {\n\t\treturn boxesArray[position];\n\t}\n",
    "1889": "\tfinal public boolean isBox(int x, int y) {\n\t\treturn boxesArray[x + width * y];\n\t}\n",
    "1911": "\tfinal public boolean isWall(int position) {\n\t\treturn wallsArray[position] > 0;\n\t}\n",
    "1916": "\tpublic boolean isABoxSelected() {\n\t\treturn isABoxSelected;\n\t}\n",
    "1931": "\tfinal public boolean isWall(int x, int y) {\n\t\treturn wallsArray[x + width * y] > 0;\n\t}\n",
    "1946": "\tpublic boolean isHighLightingOfPlayerReachableSquaresActivated() {\n\t\treturn isHighLightOfPlayerSquaresActivated;\n\t}\n",
    "1956": "\tpublic void setAntInstallLib(File antInstallLib) {\n\t\tthis.antInstallLib = antInstallLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antInstallLib,\"tikal-antinstaller.jar\"));\n\t\tset.setFile(new File(antInstallLib,\"sysout.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1958": "\tpublic void setAntLib(File antLib) {\n\t\tthis.antLib = antLib;\n\t\tFileSet set = new FileSet();\n\t\tset.setFile(new File(antLib,\"tikal-ant.jar\"));\n\t\tset.setFile(new File(antLib,\"ant-launcher.jar\"));\n\t\taddZipGroupFileset(set);\n\t}\n",
    "1959": "\tfinal public boolean isGoal(int position) {\n\t\treturn goalsArray[position];\n\t}\n",
    "1991": "\tpublic int getSelectedBoxPosition() {\n\t\treturn selectedBoxPosition;\n\t}\n",
    "2003": "\tfinal public boolean isGoal(int x, int y) {\n\t\treturn goalsArray[x + width * y];\n\t}\n",
    "2086": "\tpublic boolean isGoalOrWall(int position) {\n\t\treturn goalsArray[position] || wallsArray[position] > 0;\n\t}\n",
    "2156": "\tprivate void redoMovementInOwnThread(final boolean redoAllMovements) {\n\t\t\n\t\tmovePlayerThread = new Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tredoMovement(redoAllMovements);\n\n\t\t\t\t// The \"setUndoRedoFromHistory()\" has happened already.\n\n\t\t\t\t// This thread has finished its work. The thread isn't needed any more.\n\t\t\t\tmovePlayerThread = null;\n\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2159": "\tfinal public boolean isCorralForcer(int position) {\n\t\treturn corralForcer[position] == true;\n\t}\n",
    "2165": "    public List getKeysWithExpiryCheck() throws IllegalStateException, CacheException {\n        List allKeyList = getKeys();\n        //remove keys of expired elements\n        ArrayList nonExpiredKeys = new ArrayList(allKeyList.size());\n        int allKeyListSize = allKeyList.size();\n        for (int i = 0; i < allKeyListSize; i++) {\n            Serializable key = (Serializable) allKeyList.get(i);\n            Element element = getQuiet(key);\n            if (element != null) {\n                nonExpiredKeys.add(key);\n            }\n        }\n        nonExpiredKeys.trimToSize();\n        return nonExpiredKeys;\n    }\n",
    "2169": "\tfinal public boolean isGoalBackwardsSearch(int position) {\n\t\treturn goalSquareBackwardsSearch[position];\n\t}\n",
    "2175": "    public long getMemoryStoreSize() throws IllegalStateException {\n        checkStatus();\n        return memoryStore.getSize();\n    }\n",
    "2177": "    public int getDiskStoreSize() throws IllegalStateException {\n        checkStatus();\n        if (overflowToDisk) {\n            return diskStore.getSize();\n        } else {\n            return 0;\n        }\n    }\n",
    "2180": "\tfinal public boolean isGoalBackwardsSearch(int x, int y) {\n\t\treturn goalSquareBackwardsSearch[x + width * y];\n\t}\n",
    "2181": "    public Status getStatus() {\n        return status;\n    }\n",
    "2186": "\tprivate void undoMovementInOwnThread() {\n\n\t\tmovePlayerThread = new Thread() {\n\t\t\t@SuppressWarnings(\"synthetic-access\")\n\t\t\tpublic void run() {\n\t\t\t\tundoMovement();\n\n\t\t\t\t// Enable / disable the undo / redo button depending on the history status.\n\t\t\t\tsetUndoRedoFromHistory();\t\t\t}\n\t\t};\n\t\tmovePlayerThread.start();\n\t}\n",
    "2187": "    public void setDocumentLocator(Locator locator) {\n        this.locator = locator;\n    }\n",
    "2191": "    public int getMemoryStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return memoryStoreHitCount;\n    }\n",
    "2193": "\tfinal public boolean isEmptySquare(int position) {\n\t\treturn ! (boxesArray[position] || wallsArray[position] > 0 || goalsArray[position]);\n\t}\n",
    "2195": "    public int getDiskStoreHitCount() throws IllegalStateException {\n        checkStatus();\n        return diskStoreHitCount;\n    }\n",
    "2196": "    private Method findCreateMethod(Class objClass, String name) {\n        final String methodName = makeMethodName(\"create\", name);\n        final Method[] methods = objClass.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            final Method method = methods[i];\n            if (!method.getName().equals(methodName)) {\n                continue;\n            }\n            if (Modifier.isStatic(method.getModifiers())) {\n                continue;\n            }\n            if (method.getParameterTypes().length != 0) {\n                continue;\n            }\n            if (method.getReturnType().isPrimitive() || method.getReturnType().isArray()) {\n                continue;\n            }\n            return method;\n        }\n\n        return null;\n    }\n",
    "2197": "    private String makeMethodName(final String prefix, final String name) {\n        return prefix + Character.toUpperCase(name.charAt(0)) + name.substring(1);\n    }\n",
    "2198": "    public int getMissCountNotFound() throws IllegalStateException {\n        checkStatus();\n        return missCountNotFound;\n    }\n",
    "2203": "    public int getMissCountExpired() throws IllegalStateException {\n        checkStatus();\n        return missCountExpired;\n    }\n",
    "2205": "\tfinal public boolean isEmptySquare(int x, int y) {\n\t\treturn ! (   boxesArray[x + width * y]\n\t\t          || wallsArray[x + width * y] > 0\n\t\t          || goalsArray[x + width * y]     );\n\t}\n",
    "2207": "    public String getName() {\n        return name;\n    }\n",
    "2208": "    private String getLocation() {\n        return locator.getSystemId() + ':' + locator.getLineNumber();\n    }\n",
    "2209": "    public long getTimeToIdleSeconds() {\n        return timeToIdleSeconds;\n    }\n",
    "2211": "    public long getTimeToLiveSeconds() {\n        return timeToLiveSeconds;\n    }\n",
    "2213": "\tfinal public boolean isAccessible(int position) {\n\t\treturn ! (wallsArray[position] > 0 || boxesArray[position]);\n\t}\n",
    "2219": "    public boolean isOverflowToDisk() {\n        return overflowToDisk;\n    }\n",
    "2221": "    public int getMaxElementsInMemory() {\n        return maxElementsInMemory;\n    }\n",
    "2223": "\tfinal public boolean isAccessible(int x, int y) {\n\t\treturn ! (wallsArray[x + width * y] > 0 || boxesArray[x + width * y]);\n\t}\n",
    "2224": "    public MemoryStoreEvictionPolicy getMemoryStoreEvictionPolicy() {\n        return memoryStoreEvictionPolicy;\n    }\n",
    "2225": "    public String getDiskCachePath() {\n        if (diskStore != null) {\n            return diskStore.path;\n        } else {\n            return null;\n        }\n    }\n",
    "2227": "    public Set getCacheKeySet() {\n        return caches.keySet();\n    }\n",
    "2229": "    public boolean isExpired(Element element) throws IllegalStateException, NullPointerException {\n        checkStatus();\n        boolean expired;\n        synchronized (element) {\n            if (element.getValue() == null) {\n                expired = true;\n            }\n            if (!eternal) {\n                expired = checkExpirationForNotEternal(element);\n            } else {\n                expired = false;\n            }\n            if (LOG.isDebugEnabled()) {\n                Serializable key = null;\n                if (element != null) {\n                    key = element.getKey();\n                }\n                LOG.debug(getName() + \": Is element with key \" + key + \" expired?: \" + expired);\n            }\n            return expired;\n        }\n    }\n",
    "2233": "\tfinal public boolean isAccessibleBox(int position) {\n\t\treturn ! (   wallsArray[position] > 0\n\t\t\t\t  || boxesArray[position]\n\t\t\t\t  || simpleDeadlockSquareForwards[position]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[position] );\n\t}\n",
    "2235": "    public Object clone() throws CloneNotSupportedException {\n        if (!(memoryStore == null && diskStore == null)) {\n            throw new CloneNotSupportedException(\"Cannot clone an initialized cache.\");\n        }\n        //added by yanai\n        Cache cache = (Cache) super.clone();\n        cache.cacheEventNotificationService = new CacheEventNotificationService(cache);\n        return cache;\n       //end of add\n    }\n",
    "2238": "        public void setClass(String fullyQualifiedClassPath) {\n            this.fullyQualifiedClassPath = fullyQualifiedClassPath;\n        }\n",
    "2241": "\tfinal public boolean isAccessibleBox(int x, int y) {\n\t\treturn ! (   wallsArray[x + width * y] > 0\n\t\t\t\t  || boxesArray[x + width * y]\n\t\t\t\t  || simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t  || advancedSimpleDeadlockSquareForwards[x + width * y] );\n\t}\n",
    "2242": "        public void setName(String name) {\n            this.name = name;\n        }\n",
    "2243": "    public CacheEventNotificationService getCacheEventNotificationService() {\n        return cacheEventNotificationService;\n    }\n",
    "2244": "        public void setMaxElementsInMemory(int maxElementsInMemory) {\n            this.maxElementsInMemory = maxElementsInMemory;\n        }\n",
    "2247": "    public void notifyElementRemoved(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener = (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementRemoved(cache, element);\n        }\n    }\n",
    "2248": "        public void setMemoryStoreEvictionPolicy(String memoryStoreEvictionPolicy) {\n            this.memoryStoreEvictionPolicy = MemoryStoreEvictionPolicy.fromString(memoryStoreEvictionPolicy);\n        }\n",
    "2251": "    public void notifyElementExpiry(Element element) {\n        Iterator iterator = cacheEventListeners.iterator();\n        while (iterator.hasNext()) {\n            CacheEventListener cacheEventListener =  (CacheEventListener) iterator.next();\n            cacheEventListener.notifyElementExpired(cache, element);\n        }\n    }\n",
    "2252": "    public boolean registerListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.add(cacheEventListener);\n    }\n",
    "2253": "    public boolean unregisterListener(CacheEventListener cacheEventListener) {\n        return cacheEventListeners.remove(cacheEventListener);\n    }\n",
    "2254": "    public Set getCacheEventListeners() {\n        return cacheEventListeners;\n    }\n",
    "2255": "\tfinal public boolean isWallOrIllegalSquare(int position) {\n\t\treturn     wallsArray[position] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2261": "        public void setEternal(boolean eternal) {\n            this.eternal = eternal;\n        }\n",
    "2266": "\tpublic boolean isLevelValid() {\n\n\t\tStringBuilder validityMessage = new StringBuilder();\n\n\t\t// Let the board check if it is valid.\n\t\tboolean levelIsValid = board.isValid(validityMessage);\n\n\t\t// If the level is invalid the editor mustn't be left and the\n\t\t// reason for the invalidity is displayed.\n\t\tif (levelIsValid == false) {\n\t\t\tdisplayInfotext(validityMessage.toString());\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(false);\n\t\t} else {\n\t\t\tdisplayInfotext(\"\");\n\t\t\tapplicationGUI.setEditorMenuItemEnabled(true);\n\t\t}\n\n\t\treturn levelIsValid;\n\t}\n",
    "2268": "\tpublic void sendNotification(ClusterNotification message) {\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"sendNotification : \" + message);\n\t\tbus.sendNotification(message);\n\t}\n",
    "2270": "        public void setTimeToIdleSeconds(int timeToIdleSeconds) {\n            this.timeToIdleSeconds = timeToIdleSeconds;\n        }\n",
    "2272": "\tpublic Serializable getCache() {\n\t\treturn \"BroadcastingManager: \" + bus.getLocalAddress();\n\t}\n",
    "2273": "\tpublic void memberJoined(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"A new member at address '\" + address + \"' has joined the cluster\");\n\t\t}\n\t}\n",
    "2274": "\tpublic void memberLeft(Address address) {\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"Member at address '\" + address + \"' left the cluster\");\n\t\t}\n\t}\n",
    "2278": "        public void setTimeToLiveSeconds(int timeToLiveSeconds) {\n            this.timeToLiveSeconds = timeToLiveSeconds;\n        }\n",
    "2280": "\tfinal public boolean isWallOrIllegalSquare(int x, int y) {\n\t\treturn     wallsArray[x + width * y] > 0\n\t\t\t\t|| simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2281": "    public void shutdown() {\n        if (status.equals(Status.STATUS_SHUTDOWN)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"CacheManager already shutdown\");\n            }\n            return;\n        }\n        synchronized (CacheManager.class) {\n            allCacheManagersDiskStorePaths.remove(diskStorePath);\n            Enumeration allCaches = caches.elements();\n            while (allCaches.hasMoreElements()) {\n                Cache cache = (Cache) allCaches.nextElement();\n                if (cache != null) {\n                    cache.dispose();\n                }\n            }\n            if ( getBroadcastingManager()!=null) getBroadcastingManager().stop();\n            status = Status.STATUS_SHUTDOWN;\n            \n            //only delete singleton if the singleton is shutting down.\n            if (this == singleton) {\n                singleton = null;\n            }\n        }\n    }\n",
    "2283": "        public void setOverflowToDisk(boolean overflowToDisk) {\n            this.overflowToDisk = overflowToDisk;\n        }\n",
    "2285": "        public void setDiskPersistent(boolean diskPersistent) {\n            this.diskPersistent = diskPersistent;\n        }\n",
    "2288": "        public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {\n            this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;\n        }\n",
    "2291": "\tfinal public boolean isOuterSquareOrWall(int position) {\n\t\treturn    ! playersReachableSquaresOnlyWallsAtLevelStart[position]\n\t\t       || wallsArray[position] > 0;\n\t}\n",
    "2311": "\tfinal public boolean isSimpleDeadlockSquare(int position) {\n\t\treturn     simpleDeadlockSquareForwards[position]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[position]\n\t\t\t\t|| simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2329": "\tpublic void start(BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\t}\n",
    "2331": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t}\n",
    "2338": "    protected void giveFocusToProjectsNames() {\n        projectsNamesCombo.setFocus();\n    }\n",
    "2351": "\tfinal public boolean isSimpleDeadlockSquare(int x, int y) {\n\t\treturn     simpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| advancedSimpleDeadlockSquareForwards[x + width * y]\n\t\t\t\t|| simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2362": "\tpublic void setCurrentCollection(LevelCollection levelCollection) {\n\n\t\tcurrentLevelCollection = levelCollection;\n\n\t\t// Update the combo box showing all levels.\n\t\tupdateLevelComboBox();\n\t\t\n//\t\tif (Settings.isDebugModeActivated) {\n//\t\t\tSystem.out.println( \"Set collection with \"\n//\t\t\t\t\t            + levelCollection.getNumberOfLevels() + \" levels\" );\n//\t\t\tSystem.out.println( \"  ID = \" + levelCollection.getDatabaseID());\n//\t\t\tSystem.out.println( \"  title = \" + levelCollection.getTitle());\n//\t\t}\n\t}\n",
    "2377": "\tprotected String handleDirectoryBrowse(String path) {\n\t\tDirectoryDialog directoryDialog = new DirectoryDialog(getShell());\n\t\tif (path != null && !\"\".equals(path)) {\n\t\t\tdirectoryDialog.setFilterPath(path);\n\t\t}\n\t\tString dirName = directoryDialog.open();\n\n\t\treturn dirName;\n\t}\n",
    "2378": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareForwards[position];\n\t}\n",
    "2418": "\tfinal public boolean isSimpleDeadlockSquareForwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2441": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int position) {\n\t\treturn simpleDeadlockSquareBackwards[position];\n\t}\n",
    "2449": "\tpublic String collectionTitleOfLevelID(int levelID) {\n\t\tif (findLevelByID(levelID) != null) {\n\t\t\treturn currentLevelCollection.getTitle();\n\t\t}\n\t\treturn null;\n\t}\n",
    "2455": "    public Serializable save(Object obj) throws HibernateException {\n\n        if (obj==null) throw new NullPointerException(\"attempted to save null\");\n\n        Object object = unproxy(obj); //throws exception if uninitialized\n\n        EntityEntry e = getEntry(object);\n        if ( e!=null ) {\n            if ( e.status==DELETED ) {\n                forceFlush(e);\n            }\n            else {\n                log.trace( \"object already associated with session\" );\n                return e.id;\n            }\n        }\n\n        Serializable id = saveWithGeneratedIdentifier(object, Cascades.ACTION_SAVE_UPDATE, null); //id might be generated by SQL insert\n        reassociateProxy(obj, id); //TODO: move into saveWithGeneratedIdentifier()?\n        return id;\n\n    }\n",
    "2463": "\tfinal public boolean isSimpleDeadlockSquareBackwardsDebug(int x, int y) {\n\t\treturn simpleDeadlockSquareBackwards[x + width * y];\n\t}\n",
    "2478": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int position) {\n\t\treturn advancedSimpleDeadlockSquareForwards[position];\n\t}\n",
    "2488": "\tfinal public boolean isAdvancedSimpleDeadlockSquareForwards(int x, int y) {\n\t\treturn advancedSimpleDeadlockSquareForwards[x + width * y];\n\t}\n",
    "2500": "\tfinal public boolean isBoxOnGoal(int position) {\n\t\treturn boxesArray[position] && goalsArray[position];\n\t}\n",
    "2512": "\tfinal public boolean isBoxOnGoal(int x, int y) {\n\t\treturn boxesArray[x + width * y] && goalsArray[x + width * y];\n\t}\n",
    "2521": "\tfinal public boolean isPlayerInLevel() {\n\t\treturn playerPosition != NO_PLAYER;\n\t}\n",
    "2528": "\tfinal public boolean isMarked(int position) {\n\t\treturn marked[position];\n\t}\n",
    "2543": "\tfinal public boolean isMarked(int x, int y) {\n\t\treturn marked[x + width * y];\n\t}\n",
    "2552": "\tfinal public void removeMarking(int position) {\n\t\tmarked[position] = false;\n\t}\n",
    "2561": "\tfinal public void removeMarking(int x, int y) {\n\t\tmarked[x + width * y] = false;\n\t}\n",
    "2569": "\tfinal public void removeAllMarking() {\n\t\tArrays.fill(marked, false);\t\t\t// this is not time critical\n\t}\n",
    "2576": "\tfinal public void setMarking(int position) {\n\t\tmarked[position] = true;\n\t}\n",
    "2580": "    private void reassociateProxy(LazyInitializer li, HibernateProxy proxy) throws MappingException {\n        if ( li.getSession()!=this ) {\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key( li.getIdentifier(), persister );\n            if ( !proxiesByKey.containsKey(key) ) proxiesByKey.put(key, proxy); // any earlier proxy takes precedence\n            HibernateProxyHelper.getLazyInitializer( proxy ).setSession(this);\n        }\n    }\n",
    "2583": "\tfinal public void setMarking(int x, int y) {\n\t\tmarked[x + width * y] = true;\n\t}\n",
    "2591": "\tfinal public void assignMarking(int position, boolean markValue) {\n\t\tmarked[position] = markValue;\n\t}\n",
    "2600": "\tfinal public void flipMarking(int position) {\n\t\tmarked[position] = ! marked[position];\n\t}\n",
    "2608": "\tfinal public int getBoxNo(int position) {\n\t\treturn boxNumbers[position];\n\t}\n",
    "2616": "\tfinal public int getGoalNo(int position) {\n\t\treturn goalsNumbers[position];\n\t}\n",
    "2625": "\tfinal public int getGoalPosition(int goalNo) {\n\t\treturn goalsPositions[goalNo];\n\t}\n",
    "2633": "\tfinal public int getPlayerDistance(int fromSquare, int toSquare) {\n\t\treturn playerDistances[fromSquare][toSquare];\n\t}\n",
    "2641": "\tfinal public void setBoardPosition(IBoardPosition position) {\n\t\tsetBoardPosition(position.getPositions());\n\t}\n",
    "2650": "\tfinal public void setBoardPosition(int[] positions) {\n\n\t\t// remove all boxes from the board\n\t\tremoveAllBoxes();\n\n\t\t// store the new box positions in our box data object\n\t\tboxData.setBoxPositions(positions);\n\n\t\t// Put the new boxes into the board\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tsetBoxWithNo(boxNo, positions[boxNo]);\n\t\t}\n\n\t\t// set up the new player location\n\t\tplayerPosition = positions[boxCount];\n\t}\n",
    "2659": "\tfinal public void removeAllBoxes() {\n\t\tfor (int boxNo = 0; boxNo < boxCount; boxNo++) {\n\t\t\tremoveBox(boxData.getBoxPosition(boxNo));\n\t\t}\n\t}\n",
    "2668": "\tfinal public void setGoalsBackwardsSearch() {\n\n\t\tint goalNo = 0;\n\n\t\t// Set up the new goals for backwards search, and clear the old ones\n\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\tif (isBox(position) && isOuterSquareOrWall(position) == false) {\n\t\t\t\tgoalSquareBackwardsSearch[position] = true;\n\t\t\t\tgoalsPositionsBackwardsSearch[goalNo++] = position;\n\t\t\t} else {\n\t\t\t\tgoalSquareBackwardsSearch[position] = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "2683": "    public List find(String query) throws HibernateException {\n        return find(query, NO_ARGS, NO_TYPES);\n    }\n",
    "2781": "\t\tpublic int getBoxDistanceForwardsPlayerPositionIndependentNo(int boxNo, int goalNo) {\n\t\t\treturn getBoxDistanceForwardsPlayerPositionIndependent(boxData.getBoxPosition(boxNo), goalsPositions[goalNo]);\n\t\t}\n",
    "2880": "\tpublic void run(IAction action) {\n\t\tUpdateManagerDialog d = new UpdateManagerDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());\n\t\td.open();\n\t}\n",
    "2881": "\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t}\n",
    "2882": "\tpublic void dispose() {\n\t}\n",
    "2883": "\tpublic void init(IWorkbenchWindow window) {\n\t\tthis.window = window;\n\t}\n",
    "2930": "    protected boolean allowNewContainerName() {\n        return false;\n    }\n",
    "2961": "    public void aboutToOpen() {\n        determineWhiteCheckedDescendents(root);\n        checkNewTreeElements(treeContentProvider.getElements(root));\n\n        //select the first element in the list\n        Object[] elements = treeContentProvider.getElements(root);\n        Object primary = elements.length > 0 ? elements[0] : null;\n        if (primary != null) {\n            treeViewer.setSelection(new StructuredSelection(primary));\n        }\n        treeViewer.getControl().setFocus();\n    }\n",
    "2963": "    public void addCheckStateListener(ICheckStateListener listener) {\n        addListenerObject(listener);\n    }\n",
    "2964": "    private ITreeContentProvider getResourceProvider(final int resourceType) {\n        return new WorkbenchContentProvider() {\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic Object[] getChildren(Object o) {\n                //input element case\n                if (o instanceof ArrayList) {\n                    return ((ArrayList) o).toArray();\n                } \n               return new Object[0];            \t\n            }\n        };\n    }\n",
    "2965": "    protected boolean areAllChildrenWhiteChecked(Object treeElement) {\n        Object[] children = treeContentProvider.getChildren(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n            if (!whiteCheckedTreeItems.contains(children[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n        }\n\n        return true;\n    }\n",
    "2970": "    protected boolean areAllElementsChecked(Object treeElement) {\n        List checkedElements = (List) checkedStateStore.get(treeElement);\n        if (checkedElements == null) {\n\t\t\treturn false;\n\t\t}\n        return true;\n    }\n",
    "2971": "    protected void checkNewTreeElements(Object[] elements) {\n        for (int i = 0; i < elements.length; ++i) {\n            Object currentElement = elements[i];\n            boolean checked = checkedStateStore.containsKey(currentElement);\n            treeViewer.setChecked(currentElement, checked);\n            treeViewer.setGrayed(currentElement, checked\n                    && !whiteCheckedTreeItems.contains(currentElement));\n        }\n    }\n",
    "2972": "    protected Iterator getSelectedResourcesIterator() {\n        return this.resourceGroup.getAllCheckedListItems().iterator();\n    }\n",
    "2974": "    public void checkStateChanged(final CheckStateChangedEvent event) {\n\n        //Potentially long operation - show a busy cursor\n        BusyIndicator.showWhile(treeViewer.getControl().getDisplay(),\n            new Runnable() {\n                public void run() {\n                    if (event.getCheckable().equals(treeViewer)) {\n\t\t\t\t\t\ttreeItemChecked(event.getElement(), event\n                                .getChecked());\n\t\t\t\t\t}\n\n                    notifyCheckStateChangeListeners(event);\n                }\n            });\n    }\n",
    "2975": "    protected List getTypesToExport() {\n        return selectedTypes;\n    }\n",
    "2980": "    protected List getWhiteCheckedResources() {\n        return this.resourceGroup.getAllWhiteCheckedItems();\n    }\n",
    "2981": "    protected void createTreeViewer(Composite parent, boolean useHeightHint) {\n        Tree tree = new Tree(parent, SWT.CHECK | SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_BOTH);\n        if (useHeightHint) {\n\t\t\tdata.heightHint = PREFERRED_HEIGHT;\n\t\t}\n        tree.setLayoutData(data);\n        tree.setFont(parent.getFont());\n\n        treeViewer = new CheckboxTreeViewer(tree);\n        treeViewer.setContentProvider(treeContentProvider);\n        treeViewer.setLabelProvider(treeLabelProvider);\n        treeViewer.addTreeListener(this);\n        treeViewer.addCheckStateListener(this);\n        treeViewer.addSelectionChangedListener(this);\n    }\n",
    "2986": "    protected boolean hasExportableExtension(String resourceName) {\n        if (selectedTypes == null) {\n\t\t\treturn true;\n\t\t}\n\n        int separatorIndex = resourceName.lastIndexOf(\".\"); //$NON-NLS-1$\n        if (separatorIndex == -1) {\n\t\t\treturn false;\n\t\t}\n\n        String extension = resourceName.substring(separatorIndex + 1);\n\n        Iterator it = selectedTypes.iterator();\n        while (it.hasNext()) {\n            if (extension.equalsIgnoreCase((String) it.next())) {\n\t\t\t\treturn true;\n\t\t\t}\n        }\n\n        return false;\n    }\n",
    "2987": "    protected boolean determineShouldBeWhiteChecked(Object treeElement) {\n        return areAllChildrenWhiteChecked(treeElement)\n                && areAllElementsChecked(treeElement);\n    }\n",
    "2990": "    protected void determineWhiteCheckedDescendents(Object treeElement) {\n        // always go through all children first since their white-checked\n        // statuses will be needed to determine the white-checked status for\n        // this tree element\n        Object[] children = treeContentProvider.getElements(treeElement);\n        for (int i = 0; i < children.length; ++i) {\n\t\t\tdetermineWhiteCheckedDescendents(children[i]);\n\t\t}\n\n        // now determine the white-checked status for this tree element\n        if (determineShouldBeWhiteChecked(treeElement)) {\n\t\t\tsetWhiteChecked(treeElement, true);\n\t\t}\n    }\n",
    "2991": "    protected void saveWidgetValues() {\n        // allow subclasses to save values\n        internalSaveWidgetValues();\n    }\n",
    "2992": "    public void expandAll() {\n        treeViewer.expandAll();\n    }\n",
    "2993": "    protected void setupBasedOnInitialSelections() {\n\n        Iterator it = this.initialResourceSelection.iterator();\n        while (it.hasNext()) {\n            IResource currentResource = (IResource) it.next();\n            if (currentResource.getType() != IResource.FILE) {\n\t\t\t\tthis.resourceGroup.initialCheckTreeItem(currentResource);\n\t\t\t}\n        }\n    }\n",
    "2995": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3005": "    protected boolean saveDirtyEditors() {\n        return IDEWorkbenchPlugin.getDefault().getWorkbench().saveAllEditors(\n                true);\n    }\n",
    "3008": "    public List getAllCheckedListItems() {\n\n        final ArrayList returnValue = new ArrayList();\n\n        IElementFilter passThroughFilter = new IElementFilter() {\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Collection elements,\n                    IProgressMonitor monitor) {\n                returnValue.addAll(elements);\n            }\n\n            @SuppressWarnings(\"unchecked\")\n\t\t\tpublic void filterElements(Object[] elements,\n                    IProgressMonitor monitor) {\n                for (int i = 0; i < elements.length; i++) {\n                    returnValue.add(elements[i]);\n                }\n            }\n        };\n\n        try {\n            getAllCheckedListItems(passThroughFilter, null);\n        } catch (InterruptedException exception) {\n            return new ArrayList();\n        }\n        return returnValue;\n\n    }\n",
    "3009": "    protected void updateWidgetEnablements() {\n\n        boolean pageComplete = determinePageCompletion();\n        setPageComplete(pageComplete);\n        if (pageComplete) {\n\t\t\tsetMessage(null);\n\t\t}\n        super.updateWidgetEnablements();\n    }\n",
    "3010": "\t\tfinal public PlayersReachableSquares getClone() {\n\t\t\treturn new PlayersReachableSquares(playersReachableSquaresArray, indicatorReachableSquare);\n\t\t}\n",
    "3012": "    public Object instantiate(ClassPersister persister, Serializable id) throws HibernateException {\n        Object result = interceptor.instantiate( persister.getMappedClass(), id );\n        if (result==null) result = persister.instantiate(id);\n        return result;\n    }\n",
    "3013": "    protected void addDestinationItem(String value) {\n        destinationNameField.add(value);\n    }\n",
    "3017": "    public List getAllWhiteCheckedItems() {\n\n        List result = new ArrayList();\n\n        //Iterate through the children of the root as the root is not in the store\n        Object[] children = treeContentProvider.getChildren(root);\n        for (int i = 0; i < children.length; ++i) {\n            findAllWhiteCheckedItems(children[i], result);\n        }\n\n        return result;\n    }\n",
    "3018": "    public int getCheckedElementCount() {\n        return checkedStateStore.size();\n    }\n",
    "3022": "    protected void createDirectoryStructureOptions(Composite optionsGroup, Font font) {\n        // create directory structure radios\n        createDirectoryStructureButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createDirectoryStructureButton.setText(DataTransferMessages.FileExport_createDirectoryStructure);\n        createDirectoryStructureButton.setSelection(false);\n        createDirectoryStructureButton.setFont(font);\n\n        // create directory structure radios\n        createSelectionOnlyButton = new Button(optionsGroup, SWT.RADIO\n                | SWT.LEFT);\n        createSelectionOnlyButton.setText(DataTransferMessages.FileExport_createSelectedDirectories);\n        createSelectionOnlyButton.setSelection(true);\n        createSelectionOnlyButton.setFont(font);\n    }\n",
    "3024": "\t\tfinal public int getPlayerPositionTopLeft() {\n\n\t\t\t// Calculate squares reachable by the player.\n\t\t\tupdate();\n\n\t\t\t// This is just the square with the smallest index.\n\t\t\tfor (int position = firstRelevantSquare; position < lastRelevantSquare; position++) {\n\t\t\t\tif (isSquareReachable(position)) {\n\t\t\t\t\treturn position;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// The player can't reach any square.\n\t\t\treturn -1;\n\t\t}\n",
    "3028": "    private void grayUpdateHierarchy(Object treeElement) {\n\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setGrayChecked(treeElement, shouldBeAtLeastGray);\n\n        if (whiteCheckedTreeItems.contains(treeElement)) {\n\t\t\twhiteCheckedTreeItems.remove(treeElement);\n\t\t}\n\n        // proceed up the tree element hierarchy\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3029": "    public void initialCheckTreeItem(Object element) {\n        treeItemChecked(element, true);\n        selectAndReveal(element);\n    }\n",
    "3030": "    protected boolean ensureDirectoryExists(File directory) {\n        if (!directory.exists()) {\n            if (!queryYesNoQuestion(DataTransferMessages.DataTransfer_createTargetDirectory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n            if (!directory.mkdirs()) {\n                displayErrorDialog(DataTransferMessages.DataTransfer_directoryCreationError);\n                giveFocusToDestination();\n                return false;\n            }\n        }\n\n        return true;\n    }\n",
    "3032": "    protected boolean ensureTargetIsValid(File targetDirectory) {\n        if (targetDirectory.exists() && !targetDirectory.isDirectory()) {\n            displayErrorDialog(DataTransferMessages.FileExport_directoryExists);\n            giveFocusToDestination();\n            return false;\n        }\n\n        return ensureDirectoryExists(targetDirectory);\n    }\n",
    "3035": "    protected boolean executeExportOperation(FileSystemExportOperation op) {\n        op.setCreateLeadupStructure(createDirectoryStructureButton\n                .getSelection());\n        op.setOverwriteFiles(overwriteExistingFilesCheckbox.getSelection());\n\n        try {\n            getContainer().run(true, true, op);\n        } catch (InterruptedException e) {\n            return false;\n        } catch (InvocationTargetException e) {\n            displayErrorDialog(e.getTargetException());\n            return false;\n        }\n\n        IStatus status = op.getStatus();\n        if (!status.isOK()) {\n            ErrorDialog.openError(getContainer().getShell(),\n                    DataTransferMessages.DataTransfer_exportProblems,\n                    null, // no special message\n                    status);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3038": "\t\tfinal public PlayersReachableSquaresOnlyWalls getClone() {\n\t\t\treturn new PlayersReachableSquaresOnlyWalls(playersReachableSquaresOnlyWallsArray, reachableSquareIndicatorOnlyWalls);\n\t\t}\n",
    "3043": "    protected String getDestinationLabel() {\n        return DataTransferMessages.FileExport_toDirectory;\n    }\n",
    "3044": "    public void removeCheckStateListener(ICheckStateListener listener) {\n        removeListenerObject(listener);\n    }\n",
    "3046": "    protected String getDestinationValue() {\n        return destinationNameField.getText().trim();\n    }\n",
    "3050": "    protected void giveFocusToDestination() {\n        destinationNameField.setFocus();\n    }\n",
    "3053": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn playersReachableSquaresOnlyWallsArray[position] == reachableSquareIndicatorOnlyWalls;\n\t\t}\n",
    "3054": "    protected void handleDestinationBrowseButtonPressed() {\n        DirectoryDialog dialog = new DirectoryDialog(getContainer().getShell(),\n                SWT.SAVE);\n        dialog.setMessage(SELECT_DESTINATION_MESSAGE);\n        dialog.setText(SELECT_DESTINATION_TITLE);\n        dialog.setFilterPath(getDestinationValue());\n        String selectedDirectoryName = dialog.open();\n\n        if (selectedDirectoryName != null) {\n            setErrorMessage(null);\n            setDestinationValue(selectedDirectoryName);\n        }\n    }\n",
    "3055": "    public void setRoot(Object newRoot) {\n        this.root = newRoot;\n        initialize();\n    }\n",
    "3056": "    public void handleEvent(Event e) {\n        Widget source = e.widget;\n\n        if (source == destinationBrowseButton) {\n\t\t\thandleDestinationBrowseButtonPressed();\n\t\t}\n\n        updatePageCompletion();\n    }\n",
    "3057": "    protected void setTreeChecked(Object treeElement, boolean state) {\n\n        if (!state) {\n\t\t\tcheckedStateStore.remove(treeElement);\n\t\t}\n\n        setWhiteChecked(treeElement, state);\n        treeViewer.setChecked(treeElement, state);\n        treeViewer.setGrayed(treeElement, false);\n\n        // now logically check/uncheck all children as well if it has been expanded\n        if (expandedTreeNodes.contains(treeElement)) {\n            Object[] children = treeContentProvider.getChildren(treeElement);\n            for (int i = 0; i < children.length; ++i) {\n                setTreeChecked(children[i], state);\n            }\n        }\n    }\n",
    "3060": "    private void internalSaveWidgetValues() {\n        // update directory names history\n        IDialogSettings settings = getDialogSettings();\n        if (settings != null) {\n            String[] directoryNames = settings\n                    .getArray(STORE_DESTINATION_NAMES_ID);\n            if (directoryNames == null) {\n\t\t\t\tdirectoryNames = new String[0];\n\t\t\t}\n\n            directoryNames = addToHistory(directoryNames, getDestinationValue());\n            settings.put(STORE_DESTINATION_NAMES_ID, directoryNames);\n\n            // options\n            settings.put(STORE_OVERWRITE_EXISTING_FILES_ID,\n                    overwriteExistingFilesCheckbox.getSelection());\n\n            settings.put(STORE_CREATE_STRUCTURE_ID,\n                    createDirectoryStructureButton.getSelection());\n\n        }\n    }\n",
    "3061": "    public Object narrowProxy(Object proxy, ClassPersister persister, Key key, Object object) throws HibernateException {\n\n        if ( !persister.getConcreteProxyClass().isAssignableFrom( proxy.getClass() ) ) {\n\n            if ( log.isWarnEnabled() ) log.warn(\n                \"Narrowing proxy to \" + persister.getConcreteProxyClass() + \" - this operation breaks ==\"\n            );\n\n            if (object!=null) {\n                proxiesByKey.remove(key);\n                return object; //return the proxied object\n            }\n            else {\n                proxy = persister.createProxy( key.getIdentifier(), this );\n                proxiesByKey.put(key, proxy); //overwrite old proxy\n                return proxy;\n            }\n\n        }\n        else {\n            return proxy;\n        }\n    }\n",
    "3062": "    public void setTreeSorter(ViewerSorter sorter) {\n        treeViewer.setSorter(sorter);\n    }\n",
    "3063": "    protected void restoreWidgetValues() {\n        IDialogSettings settings = getDialogSettings();\n        if (settings != null) {\n            String[] directoryNames = settings\n                    .getArray(STORE_DESTINATION_NAMES_ID);\n            if (directoryNames == null) {\n\t\t\t\treturn; // ie.- no settings stored\n\t\t\t}\n\n            // destination\n            setDestinationValue(directoryNames[0]);\n            for (int i = 0; i < directoryNames.length; i++) {\n\t\t\t\taddDestinationItem(directoryNames[i]);\n\t\t\t}\n\n            // options\n            overwriteExistingFilesCheckbox.setSelection(settings\n                    .getBoolean(STORE_OVERWRITE_EXISTING_FILES_ID));\n\n            boolean createDirectories = settings\n                    .getBoolean(STORE_CREATE_STRUCTURE_ID);\n            createDirectoryStructureButton.setSelection(createDirectories);\n            createSelectionOnlyButton.setSelection(!createDirectories);\n        }\n    }\n",
    "3066": "\t\tfinal public boolean isSquareReachable(int x, int y) {\n\t\t\treturn playersReachableSquaresOnlyWallsArray[x + width * y] == reachableSquareIndicatorOnlyWalls;\n\t\t}\n",
    "3067": "    public void treeCollapsed(TreeExpansionEvent event) {\n        // We don't need to do anything with this\n    }\n",
    "3068": "    protected void setDestinationValue(String value) {\n        destinationNameField.setText(value);\n    }\n",
    "3069": "    public void treeExpanded(TreeExpansionEvent event) {\n        expandTreeElement(event.getElement());\n    }\n",
    "3070": "    protected boolean validateDestinationGroup() {\n        String destinationValue = getDestinationValue();\n        if (destinationValue.length() == 0) {\n            setMessage(destinationEmptyMessage());\n            return false;\n        }\n\n        String conflictingContainer = getConflictingContainerNameFor(destinationValue);\n        if (conflictingContainer == null) {\n\t\t\tsetErrorMessage(null);\n\t\t} else {\n            setErrorMessage(NLS.bind(DataTransferMessages.FileExport_conflictingContainer, conflictingContainer));\n            giveFocusToDestination();\n            return false;\n        }\n\n        return true;\n    }\n",
    "3072": "    public Object proxyFor(ClassPersister persister, Key key, Object impl) throws HibernateException {\n        if ( !persister.hasProxy() ) return impl;\n        Object proxy = proxiesByKey.get(key);\n        if (proxy!=null) {\n            return narrowProxy(proxy, persister, key, impl);\n        }\n        else {\n            return impl;\n        }\n    }\n",
    "3073": "    protected void treeItemChecked(Object treeElement, boolean state) {\n\n        // recursively adjust all child tree elements appropriately\n        setTreeChecked(treeElement, state);\n\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent == null) {\n\t\t\treturn;\n\t\t}\n\n        // now update upwards in the tree hierarchy \n        if (state) {\n\t\t\tgrayCheckHierarchy(parent);\n\t\t} else {\n\t\t\tungrayCheckHierarchy(parent);\n\t\t}\n\n        //Update the hierarchy but do not white select the parent\n        grayUpdateHierarchy(parent);\n    }\n",
    "3075": "    protected void ungrayCheckHierarchy(Object treeElement) {\n        if (!determineShouldBeAtLeastGrayChecked(treeElement)) {\n\t\t\tcheckedStateStore.remove(treeElement);\n\t\t}\n\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n\t\t\tungrayCheckHierarchy(parent);\n\t\t}\n    }\n",
    "3077": "    protected void updateHierarchy(Object treeElement) {\n\n        boolean whiteChecked = determineShouldBeWhiteChecked(treeElement);\n        boolean shouldBeAtLeastGray = determineShouldBeAtLeastGrayChecked(treeElement);\n\n        treeViewer.setChecked(treeElement, shouldBeAtLeastGray);\n        setWhiteChecked(treeElement, whiteChecked);\n        if (whiteChecked) {\n\t\t\ttreeViewer.setGrayed(treeElement, false);\n\t\t} else {\n\t\t\ttreeViewer.setGrayed(treeElement, shouldBeAtLeastGray);\n\t\t}\n\n        // proceed up the tree element hierarchy but gray select all of them\n        Object parent = treeContentProvider.getParent(treeElement);\n        if (parent != null) {\n            grayUpdateHierarchy(parent);\n        }\n    }\n",
    "3078": "    protected String destinationEmptyMessage() {\n        return DataTransferMessages.FileExport_destinationEmpty;\n    }\n",
    "3081": "    protected String getConflictingContainerNameFor(String targetDirectory) {\n\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IPath testPath = new Path(targetDirectory);\n\n        if (root.getLocation().isPrefixOf(testPath)) {\n\t\t\treturn DataTransferMessages.FileExport_rootName;\n\t\t}\n\n\t    IContainer[] containers = root.findContainersForLocation(testPath);\n\t    if (containers.length > 0){\n    \t\treturn containers[0].getName();\n\t    }\n\n        return null;\n\n    }\n",
    "3082": "    public void setFocus() {\n        this.treeViewer.getTree().setFocus();\n    }\n",
    "3095": "    protected int countSelectedResources() throws CoreException {\n        int result = 0;\n        Iterator resources = resourcesToExport.iterator();\n\n        while (resources.hasNext()) {\n\t\t\tresult += countChildrenOf((IResource) resources.next());\n\t\t}\n\n        return result;\n    }\n",
    "3096": "    protected void createLeadupDirectoriesFor(IResource childResource) {\n        IPath resourcePath = childResource.getFullPath().removeLastSegments(1);\n        makePathTree(resourcePath);\n    }\n",
    "3098": "    protected void createLeadupDirectoriesFor(IPath childPath) {\n        IPath resourcePath = childPath.removeLastSegments(1);\n        makePathTree(resourcePath);\n    }\n",
    "3100": "    private void makePathTree(IPath tree) {\n        IPath targetPath = tree.removeLastSegments(tree.segmentCount() - 1);\n        for (int i = 1; i < tree.segmentCount(); i++) {\n        \ttargetPath = targetPath.append(tree.segment(i));\n            if (!targetPath.toFile().exists())\n            \ttargetPath.toFile().mkdir();\n        }    \t\n    }\n",
    "3107": "    public void addUninitializedEntity(Key key, Object object, LockMode lockMode) {\n        addEntity(key, object);\n        addEntry( object, LOADING, null, key.getIdentifier(), null, lockMode, true, null /*getPersister(object)*/, false ); //temporary\n    }\n",
    "3116": "    protected boolean isDescendent(List resources, IResource child) {\n        if (child.getType() == IResource.PROJECT) {\n\t\t\treturn false;\n\t\t}\n\n        IResource parent = child.getParent();\n        if (resources.contains(parent)) {\n\t\t\treturn true;\n\t\t}\n\n        return isDescendent(resources, parent);\n    }\n",
    "3122": "    public void setCreateContainerDirectories(boolean value) {\n        createContainerDirectories = value;\n    }\n",
    "3124": "    public void setCreateLeadupStructure(boolean value) {\n        createLeadupStructure = value;\n    }\n",
    "3126": "    public void setOverwriteFiles(boolean value) {\n        if (value) {\n\t\t\toverwriteState = OVERWRITE_ALL;\n\t\t}\n    }\n",
    "3127": "    public void postHydrate(ClassPersister persister, Serializable id, Object[] values, Object object, LockMode lockMode) throws HibernateException {\n        //persister.setIdentifier(object, id);\n        Object version = Versioning.getVersion(values, persister);\n        addEntry(object, LOADING, values, id, version, lockMode, true, persister, false);\n\n        if ( log.isTraceEnabled() && version!=null ) log.trace(\"Version: \" + version);\n    }\n",
    "3129": "\t\tfinal public boolean isSquareReachable(int position) {\n\t\t\treturn boxReachableSquaresArray[position] == indicatorReachableSquare;\n\t\t}\n",
    "3135": "    private ZipFile getSpecifiedSourceFile(String fileName) {\n        if (fileName.length() == 0)\n            return null;\n\n        try {\n            return new ZipFile(fileName);\n        } catch (ZipException e) {\n           addError(DataTransferMessages.ZipImport_badFormat, e);\n        } catch (IOException e) {\n           addError(DataTransferMessages.ZipImport_couldNotRead, e);\n        }\n\n        return null;\n    }\n",
    "3137": "    protected boolean closeZipFile(ZipFile file) {\n        try {\n            file.close();\n        } catch (IOException e) {\n            addError(NLS.bind(DataTransferMessages.ZipImport_couldNotClose, file.getName()), e);\n            return false;\n        }\n\n        return true;\n    }\n",
    "3189": "\tprivate void initializeValues() {\n\t\tfinal IPreferenceStore store = getPreferenceStore();\n\t\tfor (Iterator iter = fFields.iterator(); iter.hasNext();) {\n\t\t\t((Field)iter.next()).initializeValue(store);\n\t\t}\n\t}\n",
    "3200": "\tprotected IPreferenceStore doGetPreferenceStore() {\n\t\treturn CVSUIPlugin.getPlugin().getPreferenceStore();\n\t}\n",
    "3201": "\tprotected void createImageDescriptor(String id) {\n\t\tURL url = FileLocator.find(CVSUIPlugin.getPlugin().getBundle(), new Path(ICVSUIConstants.ICON_PATH + id), null);\n\t\tImageDescriptor desc = ImageDescriptor.createFromURL(url);\n\t\timageDescriptors.put(id, desc);\n\t}\n",
    "3205": "\tpublic void setCompressionLevel(int level) {\n\t\tcompressionLevel = level;\n\t}\n",
    "3207": "\tpublic int getCompressionLevel() {\n\t\treturn compressionLevel;\n\t}\n",
    "3209": "\tpublic ImageDescriptor getImageDescriptor(String id) {\n\t\treturn (ImageDescriptor)imageDescriptors.get(id);\n\t}\n",
    "3211": "\tpublic void setDefaultTextKSubstOption(KSubstOption ksubst) {\n\t\tdefaultTextKSubstOption = ksubst;\n\t}\n",
    "3214": "\tpublic KSubstOption getDefaultTextKSubstOption() {\n\t\treturn defaultTextKSubstOption;\n\t}\n",
    "3215": "\tprivate String getPreviousBugId(String string){\n\t\tif(string.startsWith(BUG_ID_INITIAL)){\n\t\t\tint newLineIndex = string.indexOf(LINE_SEPARATOR);\n\t\t\treturn string.substring(BUG_ID_INITIAL.length(), newLineIndex);\n\t\t}\n\t\treturn \"\";\t\n\t}\n",
    "3217": "\tpublic boolean getPruneEmptyDirectories() {\n\t\treturn pruneEmptyDirectories;\n\t}\n",
    "3218": "\tprivate String getPreviousComment(String string){\n\t\tif(string.startsWith(BUG_ID_INITIAL)){\n\t\t\tint newLineIndex = string.indexOf(LINE_SEPARATOR);\n\t\t\treturn string.substring(newLineIndex+LINE_SEPARATOR.length(), string.length());\n\t\t}\n\t\treturn string;\t\t\n\t}\n",
    "3221": "\tpublic void setPruneEmptyDirectories(boolean prune) {\n\t\tpruneEmptyDirectories = prune;\n\t}\n",
    "3226": "\tpublic int getTimeout() {\n\t\treturn communicationsTimeout;\n\t}\n",
    "3230": "\tpublic void setTimeout(int timeout) {\n\t\tthis.communicationsTimeout = Math.max(0, timeout);\n\t}\n",
    "3231": "\tprivate Label createLabel(Composite parent, String text, int horizontalSpan) {\n\t\tLabel label = new Label(parent, SWT.LEFT);\n\t\tlabel.setText(text);\n\t\tGridData data = new GridData();\n\t\tdata.horizontalSpan = horizontalSpan;\n\t\tdata.horizontalAlignment = GridData.FILL;\n\t\tlabel.setLayoutData(data);\n\t\treturn label;\n\t}\n",
    "3232": "\tprivate Button createCheckBox(Composite group, String label) {\n\t\tButton button = new Button(group, SWT.CHECK | SWT.LEFT);\n\t\tbutton.setText(label);\n\t\tGridData data = new GridData();\n\t\tdata.horizontalSpan = 2;\n\t\tbutton.setLayoutData(data);\n\t\treturn button;\n\t}\t\n",
    "3233": "\tpublic void setQuietness(QuietOption option) {\n\t\t\tthis.quietness = option;\n\t}\n",
    "3237": "\tpublic QuietOption getQuietness() {\n\t\treturn quietness;\n\t}\n",
    "3243": "\tpublic void setConsoleListener(IConsoleListener consoleListener) {\n\t    ConsoleListeners.getInstance().addListener(consoleListener);\n\t}\n",
    "3253": "\tprotected void performDefaults() {\n\t\tsuper.performDefaults();\n        initializeValues();\n\t\t\n        verifyValidation();\n\t}\n",
    "3254": "\tpublic String getCvsRshCommand() {\n\t\treturn cvsRshCommand;\n\t}\n",
    "3258": "\tpublic void setCvsRshCommand(String cvsRshCommand) {\n\t\tthis.cvsRshCommand = cvsRshCommand;\n\t}\n",
    "3260": "\tpublic boolean isUseProjectNameOnCheckout() {\n\t\treturn getPreferenceStore().getBoolean(ICVSUIConstants.PREF_USE_PROJECT_NAME_ON_CHECKOUT);\n\t}\n",
    "3262": "\tpublic String getCvsRshParameters() {\n\t\treturn cvsRshParameters;\n\t}\n",
    "3265": "\tpublic void setCvsRshParameters(String cvsRshParameters) {\n\t\tthis.cvsRshParameters = cvsRshParameters;\n\t}\n",
    "3270": "\tpublic String getCvsServer() {\n\t\treturn cvsServer;\n\t}\n",
    "3271": "\tprivate void initializeValues() {\n\t\t\n\t\t// populate the previous comment list\n\t\tfor (int i = 0; i < comments.length; i++) {\n\t\t\tpreviousCommentsCombo.add(flattenText(comments[i]));\n\t\t}\n\t\t\n\t\t// We don't want to have an initial selection\n\t\t// (see bug 32078: http://bugs.eclipse.org/bugs/show_bug.cgi?id=32078)\n\t\tpreviousCommentsCombo.setText(\"\"); //$NON-NLS-1$\n\t\t\n\t\tif (commentProperties == null && oldComment == null) text.setText(\"\"); //$NON-NLS-1$\n\t\tcomment = text.getText();\n\t}\n",
    "3275": "\tpublic void setCvsServer(String cvsServer) {\n\t\tthis.cvsServer = cvsServer;\n\t}\n",
    "3277": "\tprivate void signalCtrlEnter() {\n\t\tfirePropertyChangeChange(OK_REQUESTED, null, null);\n\t}\n",
    "3278": "\tpublic String getComment() {\n\t\tIPreferenceStore store = SVNUIPlugin.getPlugin().getPreferenceStore();\n\t\tif(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){\n\t\t\tif(comment.length() > 0 && bugId.length() > 0)\n\t\t\tcomment = bugId + comment;\n\t\t}\n\t\tif (comment != null && comment.length() > 0) finished();\n\t\tif(store.getBoolean(ISVNUIConstants.PREF_BUG_ID_FIELD)){\n\t\t\tif(comment.length() > 0 && bugId.length() == 0)\n\t\treturn comment;\n\t}\n\t\treturn comment;\t\n\t}\n",
    "3280": "\tpublic boolean getFetchAbsentDirectories() {\n\t\treturn fetchAbsentDirectories;\n\t}\n",
    "3288": "\tpublic void setFetchAbsentDirectories(boolean fetchAbsentDirectories) {\n\t\tthis.fetchAbsentDirectories = fetchAbsentDirectories;\n\t}\n",
    "3296": "    private void setSvnClientInterface(String clientInterface) {\n        if (CmdLineClientAdapterFactory.COMMANDLINE_CLIENT.equals(clientInterface))\n            clientInterface = JavaSvnClientAdapterFactory.JAVASVN_CLIENT;\n        SVNProviderPlugin.getPlugin().getSVNClientManager().setSvnClientInterface(clientInterface);\n    }\n",
    "3297": "    private void setSvnClientConfigDir(String configDir) {\n        SVNProviderPlugin plugin = SVNProviderPlugin.getPlugin();\n        SVNClientManager svnClientManager = plugin.getSVNClientManager();\n        if (\"\".equals(configDir)) { //$NON-NLS-1$\n        \tsvnClientManager.setConfigDir(null);\n        } else {\n        \tFile configDirFile = new File(configDir);\n            svnClientManager.setConfigDir(configDirFile);\n        }\n    }\n",
    "3305": "\t\tpublic IProject getProject() {\n\t\t\treturn project;\n\t\t}\n",
    "3306": "\t\tpublic void setProject(IProject project) {\n\t\t\tthis.project = project;\n\t\t}\n",
    "3308": "\tpublic boolean isReplaceUnmanaged() {\n\t\treturn replaceUnmanaged;\n\t}\n",
    "3313": "\tpublic void setReplaceUnmanaged(boolean replaceUnmanaged) {\n\t\tthis.replaceUnmanaged = replaceUnmanaged;\n\t}\n",
    "3321": "\tpublic void addRepositoryListener(ICVSListener listener) {\n\t\tKnownRepositories.getInstance().addRepositoryListener(listener);\n\t}\n",
    "3327": "\t\tstatic public InstallerProject create(IJavaProject javaProject) {\n\t\t\tInstallerProject result = null;\n\t\t\ttry {\n\t\t\t\tInstallerProject.addTikalInstallerNature(javaProject);\n\t\t\t\tresult = (InstallerProject)javaProject.getProject().getNature(InstallerPlugin.NATURE_ID);\n\t\t\t\tif(result != null)\n\t\t\t\t\tresult.setJavaProject(javaProject);\n\t\t\t} catch(CoreException ex) {\n\t\t\t\tex.printStackTrace();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n",
    "3329": "\tpublic void addDecoratorEnablementListener(ICVSDecoratorEnablementListener listener) {\n\t\tsynchronized(decoratorEnablementListeners) {\n\t\t\tdecoratorEnablementListeners.add(listener);\n\t\t}\n\t}\n",
    "3332": "\t\tstatic public InstallerProject create(IProject project) {\n\n\t\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\t\tif(javaProject != null) {\n\t\t\t\treturn InstallerProject.create(javaProject);\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\t\n",
    "3350": "    private void doLoadByObject(Object object, Serializable id, LockMode lockMode) throws HibernateException {\n\n        Class clazz = object.getClass();\n        if ( getEntry(object)!=null ) throw new PersistentObjectException(\n            \"attempted to load into an instance that was already associated with the Session: \" +\n            MessageHelper.infoString(clazz, id)\n        );\n        Object result = doLoad(clazz, id, object, lockMode, true);\n        ObjectNotFoundException.throwIfNull(result, id, clazz);\n        if (result!=object) throw new NonUniqueObjectException(id, clazz);\n\n    }\n",
    "3370": "\tpublic boolean isDetermineVersionEnabled() {\n\t\treturn determineVersionEnabled;\n\t}\n",
    "3377": "\tpublic void setDetermineVersionEnabled(boolean determineVersionEnabled) {\n\t\tthis.determineVersionEnabled = determineVersionEnabled;\n\t}\n",
    "3379": "\tpublic String getComment() {\n\t    if ((projectProperties != null) && (issue != null) && (issue.length() > 0)) {\n\t        if (projectProperties.isAppend()) \n\t            return commitCommentArea.getComment() + \"\\n\" + projectProperties.getResolvedMessage(issue) + \"\\n\"; //$NON-NLS-1$ //$NON-NLS-2$\n\t        else\n\t            return projectProperties.getResolvedMessage(issue) + \"\\n\" + commitCommentArea.getComment(); //$NON-NLS-1$\n\t    }\n\t\treturn commitCommentArea.getComment();\n\t}\n",
    "3383": "\tpublic FileModificationManager getFileModificationManager() {\n\t\treturn fileModificationManager;\n\t}\n",
    "3475": "\tpublic void setExcludesDirs(String[] excludesDirs) {\n\t\tthis.excludesDirs = excludesDirs;\n\t}\n",
    "3478": "\tpublic void setIncludesDirs(String[] includesDirs) {\n\t\tthis.includesDirs = includesDirs;\n\t}\n",
    "3498": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] toFiles) {\n\t\tFileNameMapper mapper = null;\n\t\tmapper = new IdentityMapper();\n\t\tbuildMap(fromDir, toDir, files, mapper, toFiles);\n\n\t}\n",
    "3520": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] dirs) {\n\t\tboolean flatten = false;\n\t\tFileNameMapper mapper = null;\n\t\tif (mapperElement != null) {\n\t\t\tmapper = mapperElement.getImplementation();\n\t\t} else if (flatten) {\n\t\t\tmapper = new FlatFileNameMapper();\n\t\t} else {\n\t\t\tmapper = new IdentityMapper();\n\t\t}\n\t\tbuildMap(fromDir, toDir, files, mapper);\n\n\t}\n",
    "3543": "\tprivate void scan(File fromDir, File toDir, String[] files, String[] dirs) {\n\t\tFileNameMapper mapper = null;\n\t\tmapper = new IdentityMapper();\n\t\tbuildMap(fromDir, toDir, files, mapper);\n\n\t}\n",
    "3589": "    public void setOptional(boolean optional) {\n        this.optional = optional;\n    }\n",
    "3590": "    public void setFile(String file) {\n        // I don't think we can use File - different rules\n        // for relative paths.\n        this.file = file;\n    }\n",
    "3597": "    public void setClasspath(Path classpath) {\n        if (this.classpath == null) {\n            this.classpath = classpath;\n        } else {\n            this.classpath.append(classpath);\n        }\n    }\n",
    "3599": "    public Path createClasspath() {\n        if (this.classpath == null) {\n            this.classpath = new Path(getProject());\n        }\n        return this.classpath.createPath();\n    }\n",
    "3600": "    public void setClasspathRef(Reference r) {\n        createClasspath().setRefid(r);\n    }\n",
    "3611": "\tpublic URL getResource(String resourceName) {\n\t\tURL result = null;\n\n\t\twhile (_policy .hasNext() && result == null) {\n\t\t\tresult = _policy.next().getResource(resourceName);\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "3612": "\tpublic Class loadClass(String className) throws ClassNotFoundException {\n\t\tClass result = null;\n\n\t\twhile (_policy .hasNext() && result == null) {\n\t\t\ttry {\n\t\t\t\tresult = _policy.next().loadClass(className);\n\t\t\t} catch (ClassNotFoundException ignore) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\tif (result == null) {\n\t\t\tthrow new ClassNotFoundException(className);\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "3613": "\tpublic boolean hasNext() {\n\t\treturn _iterator.hasNext();\n\t}\n",
    "3614": "\tpublic ClassLoader next() {\n\t\treturn (ClassLoader) _iterator.next();\n\t}\n",
    "3615": "\tpublic void reset() {\n\t\tinit();\n\t}\n",
    "3648": "\tpublic boolean isDebugEnabled() {\n\t\tLevel l = Level.DEBUG;\n\t\tif (!_log.isEnabledFor(l)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn l.isGreaterOrEqual(_log.getEffectiveLevel());\n\t}\n",
    "3651": "\tpublic void debug(Object message) {\n\t\t_log.log(Level.DEBUG, message, null);\n\t}\n",
    "3653": "\tpublic void debug(Object message, Throwable t) {\n\t\t_log.log(Level.DEBUG, message, t);\n\t}\n",
    "3655": "\tpublic boolean isInfoEnabled() {\n\t\tLevel l = Level.INFO;\n\t\tif (!_log.isEnabledFor(l)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn l.isGreaterOrEqual(_log.getEffectiveLevel());\n\t}\n",
    "3659": "\tpublic void info(Object message) {\n\t\t_log.log(Level.INFO, message, null);\n\t}\n",
    "3665": "\tpublic void info(Object message, Throwable t) {\n\t\t_log.log(Level.INFO, message, t);\n\t}\n",
    "3670": "\tpublic void warn(Object message) {\n\t\t_log.log(Level.WARN, message, null);\n\t}\n",
    "3674": "\tpublic void warn(Object message, Throwable t) {\n\t\t_log.log(Level.WARN, message, t);\n\t}\n",
    "3679": "\tpublic void error(Object message) {\n\t\t_log.log(Level.ERROR, message, null);\n\t}\n",
    "3685": "\tpublic void error(Object message, Throwable t) {\n\t\t_log.log(Level.ERROR, message, t);\n\t}\n",
    "3689": "\tpublic void fatal(Object message) {\n\t\t_log.log(Level.FATAL, message, null);\n\t}\n",
    "3695": "\tpublic void fatal(Object message, Throwable t) {\n\t\t_log.log(Level.FATAL, message, t);\n\t}\n",
    "3701": "\tpublic void log(Level l, Object message) {\n\t\t_log.log(l, message, null);\n\t}\n",
    "3704": "    public String getJHObject(String target) {\n        // crack the definition string.\n        if (!definition.startsWith(VIEWER_TAG)) {\n            logger.warn(\"Called with a incorrect definition: \" + definition);\n            return definition; // do nothing\n        }\n        String text = null;\n        try {\n            text = definition.substring(VIEWER_TAG.length());\n            PopupObject popup = new PopupObject(props);\n            text = popup.getJHObject(target, text);\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Error handling definition. \" + definition + \" : \" + e.getMessage());\n            text = definition;\n        }\n        return text;\n    }\n",
    "3705": "\tpublic void log(Level l, Object message, Throwable t) {\n\t\t_log.log(l, message, t);\n\t}\n",
    "3708": "    public String getProjectName() {\n        return projectName;\n    }\n",
    "3709": "    private String paramStr(String name, String value) {\n        return \"<param name=\\\"\" + name +\"\\\" value=\\\"\" + value + \"\\\">\\n\"; \n    }\n",
    "3711": "    private boolean setPlayerMediaLocation() { \n        \n        String location = null;\n        if (baseDoc.getBase().getProtocol() != \"file\")\n            messages.append(\"Unable to handle the \" + baseDoc.getBase().getProtocol() + \" protocol.\\r\\n\");\n        else {\n            try {\n                URL linkUrl = new URL(baseDoc.getBase(), strUrl);\n                location = linkUrl.toString().replaceFirst(\"file:/\", \"file://\");\n            }\n            catch (MalformedURLException e) {\n                messages.append(\"Couldn't form URL \" + e.getMessage() + \"\\r\\n\");\n            }\n        }\n        \n        if (location != null) {\n            messages.append(\"Media file: \" + location + \"\\r\\n\");\n            player.setMediaLocation(location);\n            return true;\n        }\n        return false; // can' handle this yet\n    }\n",
    "3712": "    public String getSourceFolder() {\n        return sourceFolder;\n    }\n",
    "3715": "    public void setSourceFolder(String sourceFolder) {\n        this.sourceFolder = sourceFolder;\n    }\n",
    "3716": "    private String getParent(URL url) {\n        int end = url.getPath().lastIndexOf(\"/\");\n        if (end >= 0)\n            return url.getPath().substring(0, end + 1);\n        else\n            return url.getPath();  \n    }\n",
    "3717": "    public String getTargetFolder() {\n        return targetFolder;\n    }\n",
    "3720": "    public void setViewData(View view) {\n        baseDoc = (HTMLDocument)view.getDocument();\n        super.setViewData(view);\n    }\n",
    "3721": "    public String getSourceName() {\n        return sourceName;\n    }\n",
    "3722": "    private void createTempObject(String url) {\n        // File fin = new File();\n    }\n",
    "3723": "    public void setSourceName(String sourceName) {\n        this.sourceName = sourceName;\n    }\n",
    "3724": "    public void actionPerformed(ActionEvent event) {\n        strUrl = this.getContent();\n        if (jd == null)\n            createDialog();\n        showVideo();\n    }\n",
    "3726": "    public boolean accept(File f) { \n        if (f.isDirectory())\n            return true;\n        String ext = FileManager.getExtension(f);\n        return (ext.equals(\".hhp\"));\n    }\n",
    "3727": "    public String getDescription() {\n        return (\"hhp - HTML Help project files\");\n    }\n",
    "3729": "    private void createDialog() {\n        // set up the messages area\n        jd = new JDialog();\n        contentPane = jd.getContentPane();\n\n        messages = new JTextArea();\n        messages.setLineWrap(true);\n        messages.setWrapStyleWord(true);\n        messages.setEditable(false);\n        messagePanel = new JScrollPane();\n        \n        messagePanel.setOpaque(false);\n        messagePanel.setRequestFocusEnabled(false);\n        messagePanel.setPreferredSize(new java.awt.Dimension(400, 200));\n        messagePanel.setViewportView(messages);\n        contentPane.add(messagePanel, BorderLayout.NORTH);\n        northComponent = messagePanel;\n        \n        jd.pack();\n        jd.show();\n        jd.requestFocusInWindow();        \n    }\n",
    "3736": "    private void centre() {\n        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n        Dimension winSize = getSize();\n        setLocation((screen.width - winSize.width)/2, (screen.height - winSize.height)/2);\n    }\n",
    "3737": "        public void realizeComplete(RealizeCompleteEvent event) {\n            Component vc = player.getVisualComponent();\n            messagePanel.setVisible(false);\n           \n            if (vc != null) {\n                contentPane.add(vc,BorderLayout.CENTER);\n                centerComponent = vc;\n            } else {\n                if (centerComponent != null) {\n                    contentPane.remove(centerComponent);\n                    contentPane.validate();\n                }\n            }\n            Component cpc = player.getControlPanelComponent();\n            if (cpc != null) {\n                contentPane.add(cpc, BorderLayout.SOUTH);\n                southComponent = cpc;\n            } else {\n                if (southComponent != null) {\n                    contentPane.remove(southComponent);\n                    contentPane.validate();\n                }\n            }\n            jd.addWindowListener(new WindowHandler());\n            jd.pack();\n            jd.setTitle(strUrl);\n            jd.show();           \n        }\n",
    "3738": "    private void setLicenceText() {\n        URL url = getClass().getResource(\"/resources/licence.html\");\n        try {\n            informationArea.setPage(url);\n        }\n        catch (IOException e) {\n            informationArea.setText(\"Unable to open licence page. This program is copyrighted.  Please do not use and re-install.\");\n        }\n    }\n",
    "3742": "    public void display() {\n        setLicenceText();\n        pack();\n        centre();\n        setVisible(true); \n        toFront();\n        \n    }\n",
    "3743": "        public void windowClosing(WindowEvent e) {\n            if (player != null) {\n                player.stopAndDeallocate();\n                player.close();\n            }\n            \n            jd.dispose();\n        }\n",
    "3745": "    public void init() {\n        logger.debug(\"Initialise the application.\");\n        configProps = new PropertyManager(\"configuration.properties\");\n        window = new MainFrame(this);\n        window.pack();\n        window.setVisible(true);   \n    }\n",
    "3746": "    public void close() {\n        // nothing to do\n    }\n",
    "3747": "    public String getDefaultSource() {\n        return configProps.getProperty(\"defaultSource\", \"\");\n    }\n",
    "3748": "        protected void checkNamespace(String uri) {\n\n        }\n",
    "3749": "    public boolean requiresLayout() {\n        return true;\n    }\n",
    "3750": "    public void setDefaultSource(String defaultSource) {\n        configProps.setProperty(\"defaultSource\", defaultSource);\n    }\n",
    "3751": "    public void append(LoggingEvent event) {\n        if (textArea != null) {\n            Level level = event.getLevel();\n            if (level == Level.FATAL)\n                textArea.append(\"[FATAL] \");\n            else if (level == Level.WARN)\n                textArea.append(\"[WARN] \");\n            else if (level == Level.INFO)\n                textArea.append(\"[INFO] \");\n            else if (level == Level.DEBUG)\n                textArea.append(\"[DEBUG] \");\n            else \n                textArea.append(\"[----] \");\n            \n            textArea.append(event.getRenderedMessage());\n            textArea.append(\"\\n\");\n            \n        }\n    }\n",
    "3753": "    public String getDefaultTarget() {\n        return configProps.getProperty(\"defaultTarget\", \"\");\n    }\n",
    "3754": "    public void setTextArea(JTextArea argTextArea) {\n        textArea = argTextArea;\n    }\n",
    "3756": "    public void saveConfig() {\n        logger.debug(\"Save the configuration properties.\");\n        configProps.store();\n    }\n",
    "3760": "     static public void copyFile(File in, File out) throws Exception {\n        FileInputStream fis  = new FileInputStream(in);\n        FileOutputStream fos = new FileOutputStream(out);\n        byte[] buf = new byte[1024];\n        int i = 0;\n        while((i=fis.read(buf))!=-1) {\n            fos.write(buf, 0, i);\n        }\n        fis.close();\n        fos.close();\n    }\n",
    "3764": "        public AntHandler getCurrentAntHandler() {\n            return currentHandler;\n        }\n",
    "3765": "     static public String makeAbsolute(String currentPath, String defaultDir) {\n         File file = new File(currentPath);\n         if (file.isAbsolute())\n             return currentPath;\n         else\n             return combine(defaultDir, file.getName());\n     }\n",
    "3768": "     static public String buildPath(String dir, String fileName, String ext) {\n         return combine(dir, fileName + ext);\n     }\n",
    "3769": "    public String getLanguage(int encType) {\n        if (encType == INDEX) {\n            return m_props.getProperty(\"index_lang\", \"en\");\n        }\n        else if (encType == MAP) {\n            return m_props.getProperty(\"map_lang\", \"en\");\n        }\n        else if (encType == TOC) {\n            return m_props.getProperty(\"toc_lang\", \"en\");\n        }\n        else if (encType == HS) {\n            return m_props.getProperty(\"hs_lang\", \"en\");\n        }        \n        return \"en\";\n    }\n",
    "3770": "    static public String changeDirectory(String path, String newDir) {\n        String fileName = \"\";\n        try {\n            File file = new File(path);\n            fileName = file.getName();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        \n        return combine(newDir, fileName);\n    }\n",
    "3772": "    static public String getDirectory(String path) {\n        String dir = path;\n        try {\n            File file = new File(path);\n            dir = file.getParent();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        return dir;\n    }\n",
    "3773": "    public String getInputEncoding(int encType) {\n        if (encType == HTML) {\n            return m_props.getProperty(\"html_in\", \"UTF-8\");\n        }\n        else if (encType == CSS) {\n            return m_props.getProperty(\"css_in\", \"UTF-8\");\n        }\n        else if (encType == HPP) {\n            return m_props.getProperty(\"hpp_in\", \"UTF-8\");\n        }\n        else if (encType == JS) {\n            return m_props.getProperty(\"js_in\", \"UTF-8\");\n        }\n        else if (encType == HCC) {\n            return m_props.getProperty(\"hcc_in\", \"UTF-8\");\n        }\n        m_logger.warn(\"Attempted to get input encoding for unrecognised encoding type.\");\n        return \"UTF-8\";\n    }\n",
    "3774": "    static public String getName(String path) {\n        String name = path;\n        try {\n            File file = new File(path);\n            name = file.getName();\n        }\n        catch (NullPointerException e) {\n            // okay\n        }\n        return name;\n        \n    }\n",
    "3777": "    public int getEncodingJTidyR7(String enc) {\n        if (enc.equalsIgnoreCase(\"ASCII\")) {\n            return org.w3c.tidy.Configuration.ASCII;\n        }\n        else if (enc.equalsIgnoreCase(\"ISO2022\")) {\n            return org.w3c.tidy.Configuration.ISO2022;\n        }\n        else if (enc.equalsIgnoreCase(\"LATIN1\")) {\n            return org.w3c.tidy.Configuration.LATIN1;\n        }\n        else if (enc.equalsIgnoreCase(\"MACROMAN\")) {\n            return org.w3c.tidy.Configuration.MACROMAN;\n        }\n        else if (enc.equalsIgnoreCase(\"RAW\")) {\n            return org.w3c.tidy.Configuration.RAW;\n        }\n        else if (enc.equalsIgnoreCase(\"UTF8\")) {\n            return org.w3c.tidy.Configuration.UTF8;\n        }\n        else {\n            return org.w3c.tidy.Configuration.UTF8;\n        }\n    \n    }\n",
    "3778": "    static public String getExtension(File f) {\n        return getExtension(f.getPath());\n    }\n",
    "3780": "    static public String getExtension(String path) {\n        int extStart = path.lastIndexOf(\".\");\n        if (extStart >= 0)\n            return path.substring(extStart).toLowerCase();\n        else\n            return \"\";  \n    }\n",
    "3782": "    static public String changeExtension(String path, String newExtension) {\n        String retStr;\n        int extStart = path.lastIndexOf(\".\");\n        if (extStart >= 0)\n            retStr = path.substring(0, extStart);\n        else\n            retStr = path;\n        if (newExtension.length() > 0) \n            retStr += (newExtension.charAt(0) == '.' ? newExtension : \".\" + newExtension);\n        return retStr;\n    }\n",
    "3787": "    static public boolean isExistingDirectory(String name) {\n        File file = new File(name);\n        return file != null && file.exists() && file.isDirectory();\n    }\n",
    "3788": "    public BufferedReader getBufferedFileReader(String inname, int encType) throws java.io.FileNotFoundException {\n        String enc = getInputEncoding(encType);\n        boolean encodingValid = false;\n        try {\n            encodingValid = Charset.isSupported(enc);\n        }\n        catch (Exception e) {\n            m_logger.warn(\"Unable to use encoding \" + enc + \".  \" + e.getMessage());\n        }\n        if (encodingValid) {\n            m_logger.info(\"Reader created with encoding \" + enc);\n            return new BufferedReader(new InputStreamReader(new FileInputStream(inname), Charset.forName(enc)));\n        }\n        else {\n            return new BufferedReader(new InputStreamReader(new FileInputStream(inname)));\n        }\n    }\n",
    "3791": "    static public boolean isExistingFile(String name) {\n        File file = new File(name);\n        return file != null && file.exists() && file.isFile();\n    }\n",
    "3792": "    public BufferedReader getBufferedReader(InputStream in, int encType) {\n        String enc = getInputEncoding(encType);\n        boolean encodingValid = false;\n        try {\n            encodingValid = Charset.isSupported(enc);\n        }\n        catch (Exception e) {\n            m_logger.warn(\"Unable to use encoding \" + enc + \".  \" + e.getMessage());\n        }\n        if (encodingValid) {\n            m_logger.info(\"Reader created with encoding \" + enc);\n            return new BufferedReader(new InputStreamReader(in, Charset.forName(enc)));\n        }\n        else {\n            return new BufferedReader(new InputStreamReader(in));\n        }\n    }\n",
    "3793": "    public String parse(HTMLDoc doc, Node node) {\n        if (node.getNodeName().equals(\"a\"))\n            return parseAnchor(doc, node);\n        else if (node.getNodeName().equals(\"script\"))\n            return parseScript(doc, node);\n        \n        return null;\n            \n    }\n",
    "3794": "    static public String toUri(String name) {\n        File file = new File(name);\n        String uri;\n        // Convert the file object to a URL\n        URL url = null;\n        try {\n            // The file need not exist. It is made into an absolute path\n            // by prefixing the current working directory\n            url = file.toURL();          // file:/d:/almanac1.4/java.io/filename\n            uri = url.toString();\n        } \n        catch (MalformedURLException e) {\n            uri = \"\";\n        }\n        return uri;\n    }\n",
    "3796": "    public boolean run() {\n        return true;\n    }\n",
    "3798": "   protected void logRunHeader(String header) {\n        logger.info(header);\n        logger.info(\"Source name: \" + sourceName);\n        logger.info(\"Target folder: \" + project.getTargetFolder());\n    }\n",
    "3800": "    protected void logRunFooter() {\n        // do nothing\n    }\n",
    "3801": "        public void setDocumentLocator(Locator locator) {\n            context.setLocator(locator);\n        }\n",
    "3802": "    private boolean createHTMLFile(String text, String targetName, String source) {\n        String htmlOut = \"<html><head><title>popup</title></head><body>\" + text + \"</body></html>\";\n        ByteArrayInputStream in = new ByteArrayInputStream(htmlOut.getBytes());\n        ParserHTML parser = new ParserHTML(project, source); \n        return parser.run((InputStream)in, targetName);\n    }\n",
    "3803": "    protected void logMessageAtLine(String message) {\n        logger.info(\"Line \" + lineNumber + \": \" + message);\n    }\n",
    "3805": "    protected void logWarningAtLine(String message) {\n        logger.warn(\"Line \" + lineNumber + \": \" + message);\n    }\n",
    "3806": "    private String getPopupIdName(String text) {\n        int start;\n        int end;\n        try {\n            start = text.indexOf(popupSignature);\n            end = start + popupSignature.length();\n            \n            while (CharUtility.isAsciiVariable(text.charAt(end)) ) {\n                end++;\n            }\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Could not decode popup id from \" + text);\n            return null;\n        }\n        if (start >= 0 && end > start) \n            return text.substring(start, end);\n        return null;\n        \n    }\n",
    "3807": "    protected boolean startReader(int encType) {\n        boolean bOkay = true;\n        reader = null;\n        lineNumber = 0;\n        try {\n            // reader = new BufferedReader(new FileReader(sourceName));\n            reader = EncodingManager.getInstance().getBufferedFileReader(sourceName, encType);\n        }\n        catch(FileNotFoundException e) {\n            logger.warn(\"Cannot open file \" + sourceName + \": \" + e.toString());\n            \n            bOkay = false;\n        }\n        return bOkay;\n    }\n",
    "3809": "    private void processSource(String name) {\n        if (sourceFiles.contains(name)) {\n            logger.debug(\"Already handled \" + name);\n            return;\n        }\n\n        sourceFiles.add(name);\n        \n        File f = new File(name);\n        String line;\n        boolean processing = true;\n        while (processing) {\n            processing = false;\n        }\n    \n    }\n",
    "3810": "    protected String getLine() {\n        String retLine = null;\n        try {\n            retLine = reader.readLine();\n            lineNumber++;\n        }\n        \n        catch (IOException e) {\n            logger.warn(\"IO error reading \" + sourceName + \"at line \" + lineNumber + \": \" + e.toString());\n            \n        }\n        return retLine;\n    }\n",
    "3814": "    private void handleAssignments(String line) {\n        String[] elements = line.split(\"=\");\n        if (elements.length > 1) {\n            String attribute = elements[0].trim().toUpperCase();\n            String value = elements[1].trim();\n            if (attribute.equals(\"TITLE\")) {\n                title = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value );\n            } \n            else if (attribute.equals(\"INDEX FILE\")) {\n                indexName = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value );\n            }\n            else if (attribute.equals(\"CONTENTS FILE\")) {\n                contentsName = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value);\n            }\n            else if (attribute.equals(\"DEFAULT TOPIC\")) {\n                defaultTopic = value;\n                logger.debug(\"Set attribute \" + attribute + \" to \" + value);\n            }\n        }\n    }\n",
    "3816": "    public void setMap(HashMap argMap) {\n        map = argMap;\n    }\n",
    "3818": "    public String getIndexName() {\n        return indexName;\n    }\n",
    "3819": "        public void endElement(String uri, String name, String qName) throws SAXException {\n            currentHandler.onEndElement(uri, name, context);\n            AntHandler prev = (AntHandler) antHandlers.pop();\n            currentHandler = prev;\n            if (currentHandler != null) {\n                currentHandler.onEndChild(uri, name, qName, context);\n            }\n        }\n",
    "3821": "    public void buildMap(XMLDoc doc) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        element = doc.addElement(null, \"maps\");\n        doc.addElement((org.w3c.dom.Node)element, \"homeID\", defaultTopicId);\n        element = doc.addElement((org.w3c.dom.Node)element, \"mapref\");\n        doc.setAttribute(element, \"location\", project.getProjectName() + \".jhm\");\n    }\n",
    "3822": "    public String getQuotedText(String text, boolean toHTML) {\n        StringBuffer out = new StringBuffer(100);\n        int end = text.length();\n        try {\n            int start = text.indexOf('\\\"');\n            start++;\n            while (start < end) {\n                if (text.charAt(start) == '\\\"')\n                    break;\n                if (text.charAt(start) == '\\\\')\n                    out.append(unescape(text.charAt(++start), toHTML));\n                else\n                    out.append(text.charAt(start));\n                start++;\n            }\n        }\n        catch (IndexOutOfBoundsException e) {\n            logger.warn(\"Error finding javascript quoted line: \" + e.getMessage());\n            return null;\n        }\n        return out.toString();\n    }\n",
    "3823": "    public String getContentsName() {\n        return contentsName;\n    }\n",
    "3824": "    private String unescape(char esc, boolean toHTML) {\n        if (esc == 'n')\n            return toHTML ? \"<br>\" : \"\\n\";\n        else if (esc == 'r')\n            return toHTML ? \"\" : \"\\r\"; // ignored as only handle \\n\n        else if (esc == 't')\n            return toHTML ? \"&nbsp;&nbsp;&nbsp;&nbsp;\" : \"\\r\";\n        else if (esc == '\\\\')\n            return \"\\\\\";\n        else if (esc == 'f')\n            return toHTML ? \"<hr>\" : \"\\f\";\n        else if (esc == '\\'')\n            return \"\\'\";\n        else if (esc == '\\\"')\n            return \"\\\"\";\n        else\n            return String.valueOf(esc); // ignore the escaping\n    }\n",
    "3825": "    public void buildView(XMLDoc doc, String merge, String name, String label, String typeName, String data ) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        \n        element = doc.addElement(null, \"view\");\n     \n        doc.setAttribute(element, \"xml:lang\", EncodingManager.getInstance().getLanguage(EncodingManager.HS));\n        doc.setAttribute(element, \"mergetype\", merge);\n        doc.addElement((org.w3c.dom.Node)element, \"name\", name);\n        doc.addElement((org.w3c.dom.Node)element, \"label\", label);\n        doc.addElement((org.w3c.dom.Node)element, \"type\", typeName);\n        doc.addElement((org.w3c.dom.Node)element, \"data\", data);\n      \n        \n    }\n",
    "3826": "    public String getTitle() {\n        return title;\n    }\n",
    "3829": "    public HashMap getLinks() {\n        return links;\n    }\n",
    "3831": "    public String getDefaultTopic() {\n        return defaultTopic;\n    }\n",
    "3833": "    public void setDefaultTopicId(String id) {\n        defaultTopicId = id;\n    }\n",
    "3835": "    public String getDefaultTopicId() {\n        return defaultTopicId;\n    }\n",
    "3837": "    public HashSet getHtmlFiles() {\n        return htmlFiles;\n    }\n",
    "3838": "    public boolean write(BufferedWriter writer) throws IOException {\n        logger.debug(\"Writing the HTMLDoc to file.\");\n        if (htmlDoc == null) {\n            logger.warn(\"Attempt to write a null XML document.\");\n            return false;\n        }\n        // writer.write(\"<?xml version='1.0' encoding='ISO-8859-1' ?>\");\n        writer.write(NEW_LINE);\n        writer.write(getDocTypeString());\n        String rawText = getDocumentNode(htmlDoc.getDocumentElement(), \" \");\n        writer.write(replaceText(rawText));\n        return true;\n    }\n",
    "3839": "    public  void setLinks(HashMap argLinks) {\n        links = argLinks;\n    }\n",
    "3840": "    public String getFileName() {\n        return fileName;\n    }\n",
    "3844": "     private void buildDocument(XMLDoc doc) {\n        org.w3c.dom.Node node;\n        org.w3c.dom.Element element;\n        doc.setAttribute(null, \"version\", \"2.0\");\n        doc.setAttribute(null, \"xml:lang\", EncodingManager.getInstance().getLanguage(EncodingManager.MAP));\n        doc.addComment(null, \"Map IDs\");\n\n        // iterate through the map adding the links\n        Set set = links.entrySet();\n        Iterator it = set.iterator();\n        while (it.hasNext()) {\n            Map.Entry ent = (Map.Entry)it.next();\n            String target = (String)ent.getValue();\n            String url = (String)ent.getKey();\n            addID(doc, target, url);\n        }\n    }\n",
    "3845": "    public boolean run() {\n        logRunHeader(\"Parsing css file.\");\n        FileInputStream in = null;\n\n        try {\n            in = new FileInputStream(sourceName);\n        }\n        catch (FileNotFoundException e) {\n            logger.warn(\"Error reading css file: \" + e.getMessage());\n            return false;\n        }\n       \n        return run(in, sourceName);\n    }\n",
    "3846": "     private void addID(XMLDoc doc, String target, String url) {\n        org.w3c.dom.Element element;\n        element = doc.addElement(null, \"mapID\");\n        doc.setAttribute(element, \"target\", target);\n        doc.setAttribute(element, \"url\", url); \n     }\n",
    "3848": "        public void startPrefixMapping(String prefix, String uri) {\n            context.startPrefixMapping(prefix, uri);\n        }\n",
    "3851": "    public boolean run() {\n        logRunHeader(\"Parsing HTML file.\");\n        FileInputStream in = null;\n\n        try {\n            in = new FileInputStream(sourceName);\n        }\n        catch (FileNotFoundException e) {\n            logger.warn(\"Error reading HTML file: \" + e.getMessage());\n            return false;\n        }\n       \n        return run(in, sourceName);\n        \n        \n    }\n",
    "3852": "    public String replaceQuotes(String str) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == QUOTE) \n                buf.append(QUOTE_ENTITY);\n            else\n                buf.append(str.charAt(i));\n        }\n        return buf.toString();\n    } \n",
    "3853": "    private void copyImageFile(String image) {\n        File fin =new File(FileManager.buildPath(sourceFolder, image, \"\"));\n        File fout = new File(FileManager.buildPath(project.getTargetFolder(), image, \"\"));\n        if (!fin.exists()) \n            logger.warn(\"Image \" + fin.getPath() + \"does not exist.\");\n        else {\n            logger.info(\"Copy \" + fin.getPath() + \" to \" + fout.getPath());\n            try {\n                FileManager.copyFile(fin, fout);\n            }\n            catch (Exception e) {\n                logger.warn(\"Error copying files. \" + e.toString());\n            }\n        }\n    }\n",
    "3856": "    private String replaceElement(org.w3c.dom.Node node) {\n        String nodeName = node.getNodeName();\n        // handle any popup information\n        String popup = popupParser.parse(this, node); \n        if (popup != null)\n            return popup;\n        \n        if (nodeName.equals(\"object\")) {\n            return objectParser.parse(this, node);\n        }\n        else if (nodeName.equals(\"embed\")) {\n            objectParser.handleEmbed(this, node);\n        }\n        \n        if (replaceElements == null)\n            return null;\n        return replaceElements.getProperty(nodeName);\n    }\n",
    "3857": "    private void createFullIndexItem(org.w3c.dom.Element parentIndexItem) {\n        if (!skipElement(currentIndexItem, currentName)) {\n            currentIndexItem = xmlDoc.addElement(parentIndexItem, \"indexitem\");\n            xmlDoc.setAttribute(currentIndexItem, \"text\", currentName);\n            String mapID = (String)map.get(currentTarget);\n            if (mapID == null) {\n                // couldn't find the mapID\n                mapID = handleUnknownTarget(currentTarget);\n            }\n            xmlDoc.setAttribute(currentIndexItem, \"target\", mapID);\n        }\n    }\n",
    "3859": "        public void endPrefixMapping(String prefix) {\n            context.endPrefixMapping(prefix);\n        }\n",
    "3860": "    private String handleUnknownTarget(String url) {\n        String id = null;\n        logger.debug(\"Unknown target \" + url);\n        String[] parts = url.split(\"#\");\n        if (parts.length > 1) {\n            logger.debug(\"Anchor so add to map.\");\n            id = (String)map.get(parts[0]);\n            if (id != null) {\n                // okay the target document does exist so we can add the anchor\n                id = id + \"#\" + parts[1] + \"_\"; // form a new map id\n                map.put(url, id);\n            }\n            else\n                logger.warn(\"Anchor to missing target file found. \" + url);\n        }\n        \n        return id;\n    }\n",
    "3862": "    private String replaceText(String str) {\n        return TextReplacer.replaceText(replaceText, str);\n    }\n",
    "3864": "    private void createTargetlessIndexItem(org.w3c.dom.Element parentIndexItem) {\n        if (!skipElement(currentIndexItem, currentName)) {\n            currentIndexItem = xmlDoc.addElement(parentIndexItem, \"indexitem\");\n            xmlDoc.setAttribute(currentIndexItem, \"text\", currentName);\n        }\n    }\n",
    "3865": "    public void handleEmbed(HTMLDoc doc, Node node) {\n       if (currentNode != null) {\n           source = doc.getAttribute(node, \"src\");\n       } \n    }\n",
    "3866": "    private String getLinkText(String classID) {\n        if (classID == null) \n            return \"\";\n        String classText = null;\n        \n        classText = props.getProperty(classID, props.getProperty(\"unknownClass\", \"Unknown object.  Not supported in JavaHelp\"));\n        if (source == null)\n           return classText;\n        \n        if (classText.startsWith(PopupSecondaryViewer.VIEWER_TAG)) {\n            PopupSecondaryViewer sv = new PopupSecondaryViewer(props, classText.replace(\"__SOURCE__\", source));\n            return sv.getJHObject(source);\n        }\n        else\n            return classText.replace(\"__SOURCE__\", source);\n    }\n",
    "3867": "    private String handleWrapperTag(org.w3c.dom.Node node, StringBuffer nodeStr) {\n        String endWrapper = \"\";\n        if (node.getNodeName().equals(\"table\")) {\n            String color = getAttribute(node, \"bgcolor\");\n            if (color != null) {\n                nodeStr.append(\"<div style=\\\"background-color:\" +  color + \"\\\">\\n\");\n                endWrapper = \"</div>\\n\";\n            }\n        }\n        return endWrapper;\n    }\n",
    "3869": "    public String getDocTypeString() {\n        StringBuffer buffer = new StringBuffer(1000);\n        String str;\n        buffer.append(\"<!DOCTYPE \");\n        buffer.append(docType.getName());\n        if ((str = docType.getSystemId()) != null)\n            buffer.append(\"\\n   SYSTEM \\\"\" + str + \"\\\"\");\n        if ((str = docType.getPublicId()) != null)\n            buffer.append(\"\\n   PUBLIC \\\"\" + str + \"\\\"\");\n        if ((str = docType.getInternalSubset()) != null)\n            buffer.append(\"\\n   [\" + str + \"]\");\n        if (namespace != null)\n            buffer.append(\"\\n   \\\"\" + namespace + \"\\\"\");\n        \n        buffer.append(\">\\n\");\n        return buffer.toString();\n        \n    }\n",
    "3870": "    private String additionalChildren(org.w3c.dom.Node node) {\n        if (node.getNodeName().equals(\"head\")) {\n            // we need to put the encoding string at the top or JavaHelp seems to ignore it.\n            return EncodingManager.getInstance().getEncodingTag(EncodingManager.HTML) + \"\\n\";\n        }\n        return \"\";\n    } \n",
    "3871": "    private boolean skipElement(org.w3c.dom.Element prev, String text) {\n        String oldText = xmlDoc.getAttribute(prev, \"text\");\n        if (oldText == null)\n            return false;\n        return oldText.equals(text);\n    }\n",
    "3872": "    public boolean write(BufferedWriter writer, String tag) throws IOException {\n        if (doc == null) {\n            logger.warn(\"Attempt to write a null XML document.\");\n            return false;\n        }\n        writer.write(tag);\n        writer.write(NEW_LINE);\n        writer.write(getDocTypeString());\n        writer.write(getDocumentNode(doc.getDocumentElement(), \"\"));\n        return true;\n    }\n",
    "3881": "    public HashMap getMap() {\n        return map;\n    }\n",
    "3883": "    public String replaceQuotes(String str) {\n        if (str == null) {\n            return \"\";\n        }\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == QUOTE) \n                buf.append(QUOTE_ENTITY);\n            else\n                buf.append(str.charAt(i));\n        }\n        return buf.toString();\n    }\n",
    "3971": "        public void onEndElement(String uri, String tag, AntXMLContext context) {\n            context.setCurrentTarget(context.getImplicitTarget());\n        }\n",
    "4041": "        public void onEndElement(String uri, String tag, AntXMLContext context) {\n            context.popWrapper();\n        }\n",
    "4413": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t    \tif (extension.equals(WEIGHTS_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4415": "\tpublic String getDescription(){\n\t\treturn WEIGHTS_DESCRIPTION;\n\t}\n",
    "4417": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t\t\tif (extension.equals(LOG_FILE_EXTENSION)) {\n\t\t        return true;\n\t\t\t} else {\n\t\t\t    return false;\n\t\t\t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4419": "\tpublic String getDescription(){\n\t\treturn LOG_FILE_DESCRIPTION;\n\t}\n",
    "4421": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t\tif (extension != null) {\n\t    \tif (extension.equals(PERFORMANCE_CONFIG_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4422": "\tpublic String getDescription(){\n\t\treturn PERFORMANCE_CONFIG_DESCRIPTION;\n\t}\n",
    "4437": "\tpublic boolean accept(File f){\n\t\tif(f.isDirectory()){\n\t\t\treturn true;\n\t\t}\n\t\tString extension = f.getName();\n\t\tint index = extension.lastIndexOf('.');\n\t\tif(index == -1){\n\t\t\treturn false;\n\t\t}\n\t\textension = extension.substring(index).toLowerCase();\n\t    if (extension != null) {\n\t    \tif (extension.equals(CASEBASE_EXTENSION)) {\n\t\t        return true;\n\t    \t} else {\n\t    \t\treturn false;\n\t    \t}\n\t    }\n\n\t    return false;\n\t}\n",
    "4438": "\tpublic String getDescription(){\n\t\treturn CASEBASE_DESCRIPTION;\n\t}\n",
    "4448": "    public void TeamNameMissing(CaseEvent ce){\n\tSystem.err.println(\"The Log File doesn't contain initialization messages.\");\n\tSystem.err.println(\"Please run again with the third parameter.\");\n\tSystem.err.println(\" \");\n\tdisplayUsage();\n\tSystem.exit(1);\n    }\n",
    "4451": "    public void GotInputs(CaseEvent ce){\n\tm_lastInputs=ce.getAgentInputs();\n    }\n",
    "4453": "    public void GotActions(CaseEvent ce){\n\tm_actionList=ce.getAgentActions();\n\tCase c = new Case(m_lastInputs,m_actionList);\n\tm_casebase.addCase(c);\n    }\n",
    "4459": "    public CaseBase getCaseBase(){\n\treturn new CaseBase(this.m_casebase);\n    }\n",
    "4462": "    public void writeCaseBaseFile() throws IOException {\n\t\t\n\tCaseBaseIO.saveCaseBase(this.m_casebase,this.m_outputFileName);\n\t\t\n    }\n",
    "4464": "\tpublic void setHorizontalPosition(String pos){\n\t\t//check params\n\t\tif(pos == null){\n\t\t\tthrow new IllegalArgumentException(\"Horizonal position of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM)){\n\t\t\tthrow new IllegalArgumentException(\"Horizonal position of a flag set to an invalid value: \" + pos);\n\t\t}\n\t\t\n\t\tthis.m_horizontal = pos;\n\t}\n",
    "4467": "\tpublic String getHorizontalPosition(){\n\t\treturn this.m_horizontal;\n\t}\n",
    "4471": "\tpublic void setVerticalPosition(String pos){\n\t\t//check params\n\t\tif(pos == null){\n\t\t\tthrow new IllegalArgumentException(\"Vertical position of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!pos.equals(FlagFeature.c_TOP) && !pos.equals(FlagFeature.c_BOTTOM) && !pos.equals(FlagFeature.c_CENTER) && !pos.equals(FlagFeature.c_LEFT) && !pos.equals(FlagFeature.c_RIGHT)){\n\t\t\tthrow new IllegalArgumentException(\"Vertical position of a flag set to an invalid value: \" + pos);\n\t\t}\n\t\t\n\t\tthis.m_vertical = pos;\n\t}\n",
    "4472": "\tpublic String getVerticalPosition(){\n\t\treturn this.m_vertical;\n\t}\n",
    "4473": "        public String toString(){\n\t    String result=super.toString()+\":\";\n\t    result+=Float.toString(this.m_distanceChange)+\":\";\n\t    result+=Float.toString(this.m_directionChange);\n\t    return result;\n\t}\n",
    "4476": "        public RoboCupSimulation2DSpatialObject copyOfThis(){\n\t    RoboCupSimulation2DSpatialObject copy=new RoboCupSimulation2DSpatialObject(this.getFeatureName());\n\t    copy.setDistance(this.getDistance());\n\t    copy.setDirection(this.getDirection());\n\t    copy.setDistanceChange(this.m_distanceChange);\n\t    copy.setDirectionChange(this.m_directionChange);\n\t    return copy;\n\t}\n",
    "4477": "\tpublic void setOutOfBounds(boolean out){\n\t\tthis.m_outOfBounds = out;\n\t}\n",
    "4478": "\tpublic void setDistanceChange(float distChange){\n\t\tthis.m_distanceChange = distChange;\n\t}\n",
    "4479": "\tpublic boolean isOutOfBounds(){\n\t\treturn this.m_outOfBounds;\n\t}\n",
    "4480": "\tpublic void setDirectionChange(float dirChange){\n\t\tthis.m_directionChange = dirChange;\n\t}\n",
    "4481": "\tpublic void setFlagNumber(int num){\n\t\tthis.m_flagNumber = num;\n\t}\n",
    "4483": "\tpublic float getDistanceChange(){\n\t\treturn this.m_distanceChange;\n\t}\n",
    "4485": "\tpublic float getDirectionChange(){\n\t\treturn this.m_directionChange;\n\t}\n",
    "4486": "\tpublic int getFlagNumber(){\n\t\treturn this.m_flagNumber;\n\t}\n",
    "4488": "\tpublic void setLocation(String s){\n\t\t//check parameters\n\t\tif(s == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given.\");\n\t\t}\n\t\t//check for invalid locations\n\t\tString lowerside = s.toLowerCase();\n\t\tif( !(lowerside.equals(LineFeature.c_LOCATION_LEFT)) && !(lowerside.equals(LineFeature.c_LOCATION_RIGHT)) && !(lowerside.equals(LineFeature.c_LOCATION_TOP)) && !(lowerside.equals(LineFeature.c_LOCATION_BOTTOM))){\n\t\t\tthrow new IllegalArgumentException(\"Illegal line position: \" + lowerside);\n\t\t}\n\t\t\n\t\tthis.m_location = lowerside;\n\t}\n",
    "4489": "\tprivate String browseForExistingFile(int fileType) {\n\t\tthis.fileChooser.resetChoosableFileFilters();\n\t\tswitch(fileType){\n\t\tcase CASE_BASE_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new CaseBaseFileFilter());\n\t\t\tbreak;\n\t\tcase WEIGHTS_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new WeightsFileFilter());\n\t\t\tbreak;\n\t\tcase CONFIG_FILE:\n\t\t\tthis.fileChooser.addChoosableFileFilter(new PerformanceConfigFileFilter());\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint returnVal = this.fileChooser.showOpenDialog(this);\n\t\t\n\t\tif(returnVal == JFileChooser.APPROVE_OPTION){\n\t\t\treturn fileChooser.getSelectedFile().getAbsolutePath();\n\t\t}\n        else {\n            return \"\";\n        }\n\t}\n",
    "4490": "\tpublic void setBox(String box){\n\t\t//check params\n\t\tif(box == null){\n\t\t\tthrow new IllegalArgumentException(\"Box location of a flag set to a null value.\");\n\t\t}\n\t\t\n\t\t//make sure a valid value was given\n\t\tif(!box.equals(FlagFeature.c_GOAL_BOX) && !box.equals(FlagFeature.c_PENALTY_BOX) ){\n\t\t\tthrow new IllegalArgumentException(\"Box location of a flag set to an invalid value: \" + box);\n\t\t}\n\t\t\n\t\tthis.m_box = box;\n\t}\n",
    "4491": "\tpublic String getLocation(){\n\t\treturn new String(this.m_location);\n\t}\n",
    "4494": "\tpublic float getBodyDirection() {\n\t\treturn this.m_bodyDirection;\n\t}\n",
    "4495": "\tpublic String getBox(){\n\t\treturn this.m_box;\n\t}\n",
    "4496": "\tpublic void setBodyDirection(float direction) {\n\t\tthis.m_bodyDirection = direction;\n\t}\n",
    "4498": "\tpublic float getHeadDirection() {\n\t\treturn this.m_headDirection;\n\t}\n",
    "4500": "\tpublic void setHeadDirection(float direction) {\n\t\tthis.m_headDirection = direction;\n\t}\n",
    "4501": "\tpublic boolean isGoalie() {\n\t\treturn this.m_isGoalie;\n\t}\n",
    "4502": "\tpublic void setSide(String side){\n\t\t//test the params\n\t\tif(side == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given.\");\n\t\t}\n\t\t//make sure a valid side selected\n\t\tString lowerside = side.toLowerCase();\n\t\tif( !(lowerside.equals(GoalFeature.c_SIDE_LEFT)) && !(lowerside.equals(GoalFeature.c_SIDE_RIGHT))){\n\t\t\tthrow new IllegalArgumentException(\"Invalid side given for goal.\");\n\t\t}\n\t\t\n\t\t//save the side\n\t\tthis.m_side = lowerside;\n\t}\n",
    "4503": "\tpublic void setIsGoalie(boolean goalie) {\n\t\tthis.m_isGoalie = goalie;\n\t}\n",
    "4505": "\tpublic String getSide(){\n\t\treturn new String(this.m_side);\n\t}\n",
    "4506": "\tpublic int getUniformNumber() {\n\t\treturn this.m_uniformNumber;\n\t}\n",
    "4509": "\tpublic void setUniformNumber(int number) {\n\t\tthis.m_uniformNumber = number;\n\t}\n",
    "4511": "        public TurnNeckAction copyThis(){\n\t    return new TurnNeckAction(this);\n\t}\n",
    "4512": "        public DashAction copyThis(){\n\t    return new DashAction(this);\n\t}\n",
    "4513": "\tpublic float getDashPower(){\n\t\treturn this.m_power;\n\t}\n",
    "4515": "\tpublic float getTurnNeckAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4516": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"power\") == 0)\n\t\treturn Float.toString(this.m_power);\n\t    return \"\";\n\t}\n",
    "4517": "        public CatchAction copyThis(){\n\t    return new CatchAction(this);\n\t}\n",
    "4518": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"angle\") == 0)\n\t\treturn Float.toString(this.m_angle);\n\t    return \"\";\n\t}\n",
    "4520": "\tpublic float getCatchAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4521": "        public KickAction copyThis(){\n\t    return new KickAction(this);\n\t}\n",
    "4523": "\tprivate void runLog2CaseBase(){\n\t\tString input = this.jInputFileName.getText();\n\t\tString output = this.jOutputFileName.getText();\n\t\tString team = this.jTeamName.getText();\n\t\ttry{\n\t\t\tLogFile2CaseBase builder = new LogFile2CaseBase(input, output, team);\n\t\t\tbuilder.parseLogFile();\n\t\t\tbuilder.writeCaseBaseFile();\n\t\t\tJOptionPane.showMessageDialog(this, \"Case base written to \" + output, \"Complete\", JOptionPane.INFORMATION_MESSAGE);\n\t\t}catch(Exception e){\n\t\t\tJOptionPane.showMessageDialog(this, \"Error: \" + e.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n",
    "4525": "\tpublic float getKickPower(){\n\t\treturn this.m_power;\n\t}\n",
    "4527": "        public TurnAction copyThis(){\n\t    return new TurnAction(this);\n\t}\n",
    "4528": "\tpublic float getKickAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4530": "        public String getAttrib(String attrib){\n\t    if(attrib.compareTo(\"power\") == 0)\n\t\treturn Float.toString(this.m_power);\n\t    if(attrib.compareTo(\"angle\") == 0)\n\t\treturn Float.toString(this.m_angle);\n\t    return \"\";\n\t}\n",
    "4531": "\tpublic float getTurnAngle(){\n\t\treturn this.m_angle;\n\t}\n",
    "4533": "\tpublic void see(AgentInputs inputs){\n\t\t  this.m_vision.store(inputs);\n\t  }\n",
    "4535": "\tpublic void setTimeOver(boolean b) {\n\t\tthis.m_timeOver = b;\n\t}\n",
    "4539": "\tprivate void displayAboutMessage(){\n\t\tJOptionPane.showMessageDialog(this, this.c_ABOUTMESSAGE, \"About RCSImitate\", JOptionPane.PLAIN_MESSAGE);\n\t}\n",
    "4541": "    public void run(){\n\ttry {\n\t    execute();\n\t} catch (Exception e) {\n\t    System.out.println(\"Fatal Error: \" + e.getMessage());\n\t}\n    }\n",
    "4542": "    private void initAgent(CaseBase cb) {\n\t    CaseBaseSearch cbSearch = new NearestNeighbourSearch(1);\n\t    ActionEstimation ae = new LastActionEstimate();\n\t    ActionSelection actionSelection = new ClosestNeighbourSelection(ae);\n\t    \n\t    // Create an agent with the dummy case base\n\t    agent = new Agent(cb,cbSearch,actionSelection);\n    }\n",
    "4546": "    private void initWeights(String weightsFile) {\n        // If no file was specified, use default values\n        if (weightsFile == null) {\n            weights = new Weights(0.0f);\n            weights.setWeight(BallFeature.c_BALL, 1.0f);\n            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);\n            return;\n        }\n\n        try {\n            weights = WeightsIO.loadWeights(weightsFile);\n        }\n        catch (FileNotFoundException fnfe) {\n            // If an error occurs, use default values\n            weights = new Weights(0.0f);\n            weights.setWeight(BallFeature.c_BALL, 1.0f);\n            weights.setWeight(TeammatePlayerFeature.c_TEAMMATE, 1.0f);\n        }\n    }\n",
    "4547": "\tprivate void displayHelpLog2CaseBaseMessage(){\n\t\tJOptionPane.showMessageDialog(this, this.c_HELPLOG2CASEBASEMESSAGE, \"Help\", JOptionPane.PLAIN_MESSAGE);\n\t}\n",
    "4548": "    public void move(double x, double y){\n\t//the message will be (move X Y)\n\tsend(\"(move \" + Double.toString(x) + \" \" + Double.toString(y) + \")\");\n    }\n",
    "4549": "    public void addCEListener(CaseEventListener cel){\n\tCEListeners.add(cel);\n    }\n",
    "4550": "    public void turn(double moment){\n\t//the message will be (turn moment)\n\tsend(\"(turn \" + Double.toString(moment) + \")\");\n    }\n",
    "4552": "    public void removeCEListener(CaseEventListener cel){\n\tCEListeners.remove(cel);\n    }\n",
    "4553": "    public void turn_neck(double moment){\n\t//the message will be (turn_neck moment)\n\tsend(\"(turn_neck \" + Double.toString(moment) + \")\");\n    }\n",
    "4555": "    public void performTests() {\n\tapplyPreprocessing(testBase, testFilenameRoot);\n\t\n\tapplyPreprocessing(agentBase, agentFilenameRoot);\n\n\t// the global values must after the weights are final\n\tsetGlobalValues(weights);\n\n\t// reset the test classes\n\tinitTests();\n\t\n\tinitAgent(agentBase);\n\t\n\trunTests(testBase);\n\t\n\tsaveExpectedAndReceived();\n\t\n\tSystem.out.println(\"[\" + getTime() + \"]: Results:\\n\");\n\t\n\tSystem.out.println(getReportString());\n\t\n\t// Space out the output\n\tSystem.out.println();\n\t\n\t// Outputs result data to text files\n\toutputResultToFile();\n\toutputExpectedActualToFile();\n    }\n",
    "4556": "    public void ClientInit(ParsingEvent pe){\n\tm_teamName=pe.get(\"team_name\");\n\tCaseEvent ce = new CaseEvent(this,m_teamName);\n\tfor(CaseEventListener cel:CEListeners) cel.Connecting(ce);\n    }\n",
    "4557": "    public void dash(double power){\n\t//the message will be (dash power)\n\tsend(\"(dash \" + Double.toString(power) + \")\");\n    }\n",
    "4558": "    public void ServerInit(ParsingEvent pe){\n\tCaseEvent ce = new CaseEvent(this);\n\tfor(CaseEventListener cel:CEListeners) cel.Connected(ce);\n    }\n",
    "4559": "    public void kick(double power, double direction){\n\t//the message will be (kick power direction)\n\tsend(\"(kick \" + Double.toString(power) + \" \" + Double.toString(direction) + \")\");\n    }\n",
    "4561": "    private void outputResultToFile(){\n    \ttry{\n\t    \tPrintStream output = new PrintStream(new File(\"Results-\" + testID + \".txt\"));\n\t    \toutput.println(\"[\" + getTime() + \"]: Results:\\n\");\n\t    \toutput.println(getReportString());\n\t    \toutput.close();\n    \t}catch(IOException e){\n    \t\tSystem.out.println(\"Result File Creation Error\");\n    \t}\n    }\n",
    "4562": "    public void say(String message){\n\t//message will be (say message)\n\tsend(\"(say \" + message + \")\");\n    }\n",
    "4563": "    public void Sensing(ParsingEvent pe){\n\tif(m_teamName.equals(\"\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);\n\t}\n\telse{\n\t    if(m_lastInputs.getNumberSensoryItems()>0){\n\t\tCaseEvent ce = new CaseEvent(this,m_actionList);\n\t\tfor(CaseEventListener cel:CEListeners) cel.GotActions(ce);\n\t    }\n\t    m_lastInputs = new AgentInputs();\n\t    m_actionList = new ArrayList<AgentAction>();\n\t}\n    }\n",
    "4565": "    private void outputExpectedActualToFile(){\n    \tif(saveArtifacts){\n\t    \ttry{\n\t    \t\tPrintStream output = new PrintStream(new File(\"Expected-Actual-\" + testID + \".txt\"));\n\t    \t\toutput.println(saveExpectedAndReceived());\n\t    \t\toutput.close();\n\t    \t}catch(IOException e){\n\t    \t\tSystem.out.println(\"Expected Acutal File Creation Error\");\n\t    \t}\n    \t}\n    }\n",
    "4566": "    public void changeView(String angle, String quality){\n\t//message will be (change_view angle quality)\n\tsend(\"(change_view \" + angle + \" \" + quality + \")\");\n    }\n",
    "4567": "    public void SeeReceived(ParsingEvent pe){\n\tm_lastInputs = new AgentInputs();\n    }\n",
    "4569": "    public void catchBall(String direction){\n\t//message will be (catch direction)\n\tsend(\"(catch \" + direction + \")\");\n    }\n",
    "4571": "    private void applyPreprocessing(CaseBase cb, StringBuilder filenameRoot) {\n\tfor (String action : preprocessingActions) {\n\t    if (action.matches(\"(?i)(NoActionsFilter)|(naf)\")) {\n\t\tapplyNoActionsFilter(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(FeatureDistancePresort)|(fdp)\")) {\n\t\tapplyFeatureDistancePresort(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(SequentialBackwardGeneration)|(sbg)\")) {\n\t\tapplySequentialBackwardGeneration(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(ZeroWeightFilter)|(zwf)\")) {\n\t\tapplyZeroWeightFilter(cb, filenameRoot);\n\t    }\n\t    else if (action.matches(\"(?i)(RoughSetFeatureSelection)|(rsfs)\")) {\n\t\tapplyRoughSetFeatureSelection(cb, filenameRoot);\n\t    }\n\t}\n    }\n",
    "4573": "    protected void init(){\n\t//the message is (init teamname (version 8))\n        send(\"(init \" + this.m_teamname + \" (version 8))\");\n    }\n",
    "4574": "    private void execute() throws HibernateException {\n\n        log.trace(\"executing flush\");\n\n        try {\n            // we need to lock the collection caches before\n            // executing entity inserts/updates in order to\n            // account for bidi associations\n            beforeExecutionsAll(collectionRemovals);\n            beforeExecutionsAll(collectionUpdates);\n            beforeExecutionsAll(collectionCreations);\n\n            // now actually execute SQL and update the\n            // second-level cache\n            executeAll(insertions);\n            executeAll(updates);\n            executeAll(collectionRemovals);\n            executeAll(collectionUpdates);\n            executeAll(collectionCreations);\n            executeAll(deletions);\n        }\n        catch (HibernateException he) {\n            log.error(\"Could not synchronize database state with session\");\n            throw he;\n        }\n    }\n",
    "4575": "    public void Controling(ParsingEvent pe){\n\tif(m_lastInputs.getNumberSensoryItems()>0){\n\t    CaseEvent ce = new CaseEvent(this,m_lastInputs);\n\t    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);\n\t}\n    }\n",
    "4576": "    public void Sensing(ParsingEvent pe){\n\tif(m_teamName.equals(\"\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TeamNameMissing(ce);\n\t}\n    }\n",
    "4577": "    private void send(String message){\n\tbyte[] buffer = new byte[RCSImitate.MSG_SIZE];\n\tbuffer = message.getBytes();\n\n\tDatagramPacket packet \n\t    = new DatagramPacket(buffer, buffer.length, this.m_serverhost, this.m_serverport);\n\n\ttry{\n\t    this.m_socket.send(packet);\n\t}catch(IOException e){\n\t    System.err.println(\"Socket sending error : \" + e);\n\t}\n    }\n",
    "4578": "    private void applyNoActionsFilter(CaseBase cb, StringBuilder filenameRoot) {\n\tSystem.out.println(\"[\" + getTime() + \"]: Applying No Actions Filter ...\");\n\tNoActionsFilter naf = new NoActionsFilter();\n\tcb.setCaseList(naf.filter(cb).getCaseList());\n\t\n\tfilenameRoot.append(\"-naf\");\n\t\n\tif (saveArtifacts) {\n\t    // Save the new case base\n\t    System.out.println(\"[\" + getTime() + \"]: Saving CaseBase to \" + filenameRoot.toString() + \".cb\");\n\t    try {\n\t\tCaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + \".cb\");\n\t    }\n\t    catch (IOException ioe) {\n\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving CaseBase after applying NoActionsFilter failed.\");\n\t    }\n\t}\n    }\n",
    "4579": "    private void setObjectPosition(RoboCupSimulation2DSpatialObject so,\n\t\t\t    ParsingEvent pe){//this sets the parameters that are common to all field objects\n\tif(pe.contains(\"dir_change\")) so.setDirectionChange(Float.parseFloat(pe.get(\"dir_change\")));\n\tif(pe.contains(\"dist_change\")) so.setDistanceChange(Float.parseFloat(pe.get(\"dist_change\")));\n\tif(pe.contains(\"direction\")) so.setDirection(Float.parseFloat(pe.get(\"direction\")));\n\tif(pe.contains(\"distance\")) so.setDistance(Float.parseFloat(pe.get(\"distance\")));\n    }\n",
    "4580": "    public void SeeReceived(ParsingEvent pe){\n\tif(m_lastInputs.getNumberSensoryItems()>0){\n\t    CaseEvent ce = new CaseEvent(this,m_actionList);\n\t    for(CaseEventListener cel:CEListeners) cel.GotActions(ce);\n\t}\n\tm_lastInputs = new AgentInputs();\n\tm_actionList = new ArrayList<AgentAction>();\n    }\n",
    "4581": "    private String receive() {\n\tbyte[] buffer = new byte[RCSImitate.MSG_SIZE];\n\tDatagramPacket packet = new DatagramPacket(buffer, RCSImitate.MSG_SIZE);\n\ttry{\n\t    this.m_socket.receive(packet);\n\t}catch(IOException e){\n\t    System.err.println(\"Socket receiving error : \" + e);\n\t}\n\treturn new String(buffer);\n    }\n",
    "4586": "    public void SeeParsed(ParsingEvent pe){\n\t    CaseEvent ce = new CaseEvent(this,m_lastInputs);\n\t    for(CaseEventListener cel:CEListeners) cel.GotInputs(ce);\n    }\n",
    "4588": "    public void Goal(ParsingEvent pe){\n\tGoalFeature gf = new GoalFeature();\n\tif(pe.contains(\"name\"))\n\t    gf.setSide(pe.get(\"name\"));\n\tsetObjectPosition(gf,pe);\n\tm_lastInputs.addSensoryItem(gf);\n    }\n",
    "4589": "    private void applyRoughSetFeatureSelection(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying RoughSetFeatureSelection\");\n\t\tweights = WeightAdjuster.featureSelect(WeightAdjuster.ROUGH_SET_FEATURE_SELECTION, cb);\n\t\t\n\t\tfilenameRoot.append(\"-rsfs\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save generated Weights object\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving generated Weights object to \" + filenameRoot.toString() + \".weights\");\n\t\t\ttry {\n\t\t\t\tWeightsIO.saveWeights(weights, filenameRoot.toString() + \".weights\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException iae) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving generated Weights failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4592": "    public void Ball(ParsingEvent pe){\n\tBallFeature bf = new BallFeature();\n\tsetObjectPosition(bf,pe);\n\tm_lastInputs.addSensoryItem(bf);\n    }\n",
    "4593": "    private void applySequentialBackwardGeneration(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying SequentialBackwardGeneration\");\n\t\tweights = WeightAdjuster.featureSelect(WeightAdjuster.SEQUENTIAL_BACKWARD_GENERATION, cb);\n\t\t\n\t\tfilenameRoot.append(\"-sbg\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save generated Weights object\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving generated Weights object to \" + filenameRoot.toString() + \".weights\");\n\t\t\ttry {\n\t\t\t\tWeightsIO.saveWeights(weights, filenameRoot.toString() + \".weights\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException iae) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving generated Weights failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4596": "    public void Flag(ParsingEvent pe){\n\tFlagFeature flag = new FlagFeature();\n\tString name=pe.get(\"name\");\n\tif(pe.contains(\"Box\")) flag.setBox(pe.get(\"Box\"));\n\tif(pe.contains(\"hp\")) \n\t    flag.setHorizontalPosition(pe.get(\"hp\"));\n\tif(pe.contains(\"vp\")) \n\t    flag.setVerticalPosition(pe.get(\"vp\"));\n\tif(pe.contains(\"flag_number\")){\n\t    flag.setFlagNumber(Integer.parseInt(pe.get(\"flag_number\")));\n\t    flag.setOutOfBounds(true);\n\t} else\n\t    flag.setOutOfBounds(false);\n\tsetObjectPosition(flag,pe);\n\tm_lastInputs.addSensoryItem(flag);\n    }\n",
    "4599": "\tprivate void applyZeroWeightFilter(CaseBase cb, StringBuilder filenameRoot) {\n\t\tSystem.out.println(\"[\" + getTime() + \"]: Applying Zero Weight Filter\");\n\t\tZeroWeightFilter zwf = new ZeroWeightFilter(weights);\n\t\tcb.setCaseList(zwf.filter(cb).getCaseList());\n\t\t\n\t\tfilenameRoot.append(\"-zwf\");\n\t\t\n\t\tif (saveArtifacts) {\n\t\t\t// Save the new case base\n\t\t\tSystem.out.println(\"[\" + getTime() + \"]: Saving CaseBase to \" + filenameRoot.toString() + \".cb\");\n\t\t\ttry {\n\t\t\t\tCaseBaseIO.saveCaseBase(cb, filenameRoot.toString() + \".cb\");\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tSystem.err.println(\"[\" + getTime() + \"]: Saving CaseBase after applying ZeroWeightFilter failed.\");\n\t\t\t}\n\t\t}\n\t}\n",
    "4600": "    public void Line(ParsingEvent pe){\n\tLineFeature lf = new LineFeature();\n\tif(pe.contains(\"name\")) lf.setLocation(pe.get(\"name\"));\n\tsetObjectPosition(lf,pe);\n\tm_lastInputs.addSensoryItem(lf);\n    }\n",
    "4601": "    public void TimeOver(CaseEvent ce){\n\tthis.m_timeOver = true;\n\tthis.m_brain.setTimeOver(true);\n    }\n",
    "4604": "    public void Catch(ParsingEvent pe){\n\tCatchAction catchAct = new CatchAction();\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(catchAct);\n    }\n",
    "4605": "    private void setGlobalValues(Weights w) {\n        GlobalDistanceMeasure gd = new OrderIndexMatchingAlgorithm(w);\n\t\tCase.setGlobalDistanceCalculation(gd);\n\t\t\n\t\tSensoryItem.setDistanceCalculation(new EqualityDistanceAlgorithm());\n\t\tSensoryItem.setPenaltyDistanceCalculation(new ConstantPenalty(100));\n\t\tSpatial2DObject.setDistanceCalculation(new PolarDistanceAlgorithm());\n    }\n",
    "4609": "    public void Dash(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tDashAction dash = new DashAction(power);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(dash);\n    }\n",
    "4615": "    public void Kick(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tKickAction kick = new KickAction(power,angle);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(kick);\n    }\n",
    "4616": "    public void Catch(ParsingEvent pe){\n\tCatchAction catchAct = new CatchAction();\n\tm_actionList.add(catchAct);\n    }\n",
    "4620": "    public void Turn(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tTurnAction turn = new TurnAction(angle);\n\tif(m_actionList.size()<1)\n\t    m_actionList.add(turn);\n    }\n",
    "4621": "    public void Dash(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tDashAction dash = new DashAction(power);\n\tm_actionList.add(dash);\n    }\n",
    "4623": "    private void showResults() {\n        System.out.println(\"[\" + getTime() + \"]: Results:\\n\");\n        \n        System.out.println(getReportString());\n        \n        // Space out the output\n        System.out.println();\n    }\n",
    "4625": "    public void Kick(ParsingEvent pe){\n\tfloat power =Float.parseFloat(pe.get(\"power\"));\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tKickAction kick = new KickAction(power,angle);\n\tm_actionList.add(kick);\n    }\n",
    "4626": "    public void TurnNeck(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"neck_angle\"));\n\tTurnNeckAction turnNeck = new TurnNeckAction(angle);\n\t//m_actionList.add(turnNeck);\n    }\n",
    "4628": "    public void Turn(ParsingEvent pe){\n\tfloat angle =Float.parseFloat(pe.get(\"direction\"));\n\tTurnAction turn = new TurnAction(angle);\n\tm_actionList.add(turn);\n    }\n",
    "4629": "    public void Hear(ParsingEvent pe){\n\tString who=pe.get(\"who\");\n\tString what=pe.get(\"what\");\n\tif(who.equals(\"referee\") && what.equals(\"time_over\")){\n\t    CaseEvent ce = new CaseEvent(this);\n\t    for(CaseEventListener cel:CEListeners) cel.TimeOver(ce);\n\t}\t    \n    }\n",
    "4772": "\tpublic Case getCase(){\n\t\treturn this.m_case;\n\t}\n",
    "4773": "\tpublic AgentAction getAction(){\n\t\treturn this.m_action;\n\t}\n",
    "4776": "\tpublic AgentAction senseEnvironment(Case c) {\n\t\t//check the parameters\n\t\tif(c == null){\n\t\t\tthrow new IllegalArgumentException(\"Null Case given to senseEnvironment\");\n\t\t}\n\t\tAgentInputs av = c.getInputs();\n\t\t\n\t\tlong startTime = System.currentTimeMillis();\n\t\tAgentAction action = this.m_agent.senseEnvironment(av);\n\t\tlong endTime = System.currentTimeMillis();\n\t\t\n\t\tthis.m_totalTime += endTime - startTime;\n\t\tthis.m_numInputs ++;\n\t\t\n\t\treturn action;\n\t}\n",
    "4778": "\tpublic float getMeanExecutionTime(){\n\t\t//make sure we don't divide by zero\n\t\tif(this.m_numInputs == 0){\n\t\t\treturn 0.0f;\n\t\t}\n\t\treturn ((float)this.m_totalTime)/this.m_numInputs;\n\t}\n",
    "4785": "         public AgentAction copyThis(){\n\t     AgentAction newAgent = null;\n\t     \n\t     Class<? extends AgentAction> clazz = this.getClass();\n\t     \n\t     Constructor<? extends AgentAction> constructor;\n\t     \n\t     try {\n\t\t constructor = clazz.getConstructor(clazz);\n\t\t newAgent = constructor.newInstance(this);\n\t     }\n\t     catch (Exception e) {\n\t\t e.printStackTrace();\n\t\t System.exit(1);\n\t     }\n\t     \n\t     return newAgent;\n\t }\n",
    "4787": "\tpublic String getActionName(){\n\t\treturn this.m_name;\n\t}\n",
    "4788": "    public int getCasebaseSize(){\n    \treturn this.m_casebase.size();\n    }\n",
    "4789": "         public String toString(){\n\t     String result=super.toString()+\":\";\n\t     result+=Float.toString(this.m_distance)+\":\";\n\t     result+=Float.toString(this.m_direction);\n\t     return result;\n\t }\n",
    "4790": "        public String getAttrib(String attrib){\n\t    return \"\";\n\t}\n",
    "4793": "    public void addCase(Case ca){\n    \tif(ca == null){\n    \t\tthrow new IllegalArgumentException(\"Null Case added to CaseBase.\");\n    \t}\n\t\t\n    \tthis.m_casebase.add(ca);\n    }\n",
    "4794": "         public Spatial2DObject copyOfThis(){\n\t     Spatial2DObject copy=new Spatial2DObject(this.getFeatureName());\n\t     copy.setDistance(this.m_distance);\n\t     copy.setDirection(this.m_direction);\n\t     return copy;\n\t }\n",
    "4795": "        public String toString(){\n        \treturn m_name;\t\n        }\n",
    "4796": "    public void setCaseList(List<Case> cbList){\n    \t//check params\n    \tif(cbList == null){\n    \t\tthrow new IllegalArgumentException(\"Null paramater given to CaseBase constructor\");\n    \t}\n\t\t\n    \tthis.m_casebase = new ArrayList<Case>(cbList);\n    }\n",
    "4798": "\tpublic void setDistance(float dist){\n\t\tthis.m_distance = dist;\n\t}\n",
    "4800": "\tpublic void setValue(float value){\n\t\tthis.m_value = value;\n\t}\n",
    "4802": "\tpublic void setDirection(float dir){\n\t\tthis.m_direction = dir;\n\t}\n",
    "4803": "\tpublic float getValue(){\n\t\treturn this.m_value;\n\t}\n",
    "4806": "\tpublic AgentAction selectAction(List<Case> nearestNeighbours) {\n\t\t//check parameters\n\t\tif(nearestNeighbours == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to ClosestNeighbourSelection\");\n\t\t}\n\t\tif(nearestNeighbours.size() == 0){\n\t\t\tthrow new IllegalArgumentException(\"ClosestNeighbourSelection requires at least 1 Case to be given.\");\n\t\t}\n\t\t\n\t\t//get the first Case and its actions\n\t\tCase firstCase = nearestNeighbours.get(0);\n\t\tList<AgentAction> actions = firstCase.getActions();\n\t\t\n\t\treturn this.m_actionEst.estimateAction(actions);\n\t}\n",
    "4807": "\tpublic AgentAction estimateAction(List<AgentAction> possibilities) {\n\t\t//check parameters\n\t\tif(possibilities == null){\n\t\t\tthrow new IllegalArgumentException(\"Null list given to LastActionEstimate.\");\n\t\t}\n\t\t\n\t\t//if there are no associated actions, return null\n\t\tif(possibilities.size() == 0){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//return the last item\n\t\treturn possibilities.get(possibilities.size() -1);\n\t}\n",
    "4808": "\tpublic float getDistance(){\n\t\treturn this.m_distance;\n\t}\n",
    "4811": "\tpublic float calculatePenalty(SensoryItem feat) {\n\t\t//sanity check, even though we don't use it, we still don't want null\n\t\tif(feat == null){\n\t\t\tthrow new IllegalArgumentException(\"Null feature given to penalty function.\");\n\t\t}\n\t\t\n\t\treturn this.m_penalty;\n\t}\n",
    "4813": "\tpublic void setFilters(CaseFilter[] filters){\n\t\tfor(int ii=0;ii<filters.length;ii++){\n\t\t\tif(filters[ii] == null){\n\t\t\t\tthrow new IllegalArgumentException(\"Null CaseFilter given to agent.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.m_filters = filters;\n\t}\n",
    "4814": "\tpublic float getDirection(){\n\t\treturn this.m_direction;\n\t}\n",
    "4816": "\tpublic void setWeights(Weights newWeights){\n\t\tif(newWeights == null){\n\t\t\tthrow new IllegalArgumentException(\"Null weights given to GlobalDistanceMeasure\");\n\t\t}\n\t\tthis.m_featureWeights = newWeights;\n\t}\n",
    "4817": "\tpublic void setCaseBase(CaseBase cb){\n\t\tif(cb == null){\n\t\t\tthrow new IllegalArgumentException(\"Null CaseBase given to Agent.\");\n\t\t}\n\t\tif(cb.getCasebaseSize() == 0){\n\t\t\tthrow new IllegalArgumentException(\"Empty CaseBase given to Agent. At least one Case must be in CaseBase.\");\n\t\t}\n\t\t\n\t\tthis.m_caseBase = cb;\n\t\t\n\t}\n",
    "4819": "\tpublic Weights getWeights(){\n\t\treturn this.m_featureWeights;\n\t}\n",
    "4821": "\tprotected float weightedDistance(Map<String, Float> distances) {\n\t\tfloat totalDistance = 0.0f;\n\t\t\n\t\t//get a list of object types we have and go through each type\n\t\tList<String> objectTypes = new ArrayList<String>(distances.keySet());\n\t\tfor(String currentType : objectTypes){\n\t\t\tfloat rawDistance = distances.get(currentType);\n\t\t\t\t\n\t\t\t//apply the weight\n\t\t\tfloat currentWeight = this.m_featureWeights.getWeight(currentType);\n\t\t\ttotalDistance += rawDistance*currentWeight;\n\t\t}\n\t\t\n\t\treturn totalDistance;\n\t}\n",
    "4822": "\tpublic void setWeight(String itemName, float weight){\n\t\t//check parameters\n\t\tif(itemName == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given to Weights object.\");\n\t\t}\n\t\tif(weight < 0.0f || weight > 1.0f){\n\t\t\tthrow new IllegalArgumentException(\"The weights must be between 0.0 and 1.0 (inclusive)\");\n\t\t}\n\t\t\n\t\t//set the weight value\n\t\tthis.m_weights.put(itemName, new Float(weight));\n\t}\n",
    "4824": "\tpublic float getWeight(String itemName){\n\t\t//check parameters\n\t\tif(itemName == null){\n\t\t\tthrow new IllegalArgumentException(\"Null parameter given to Weights object.\");\n\t\t}\n\t\t\n\t\t//get the associated weight\n\t\tFloat weight = this.m_weights.get(itemName);\n\t\t\n\t\t//see if the weight has actually been set, otherwise use default\n\t\tif(weight == null){\n\t\t\treturn this.m_defaultWeight;\n\t\t}\n\t\treturn weight.floatValue();\n\t}\n",
    "4825": "    public void setSensoryItems(Hashtable<String,List<SensoryItem>> items){\n    \tthis.m_featuregroupTable=new Hashtable<String,List<SensoryItem>>(items);\n    }\n",
    "4826": "    public void setActions(List<AgentAction> actions){\n    \tthis.m_actions= new ArrayList<AgentAction>(actions);\n    }\n",
    "4831": "    public AgentInputs getInputs(){\n    \treturn this.m_inputs;\n    }\n",
    "4832": "\tpublic void setSampleSize(int sampleSize){\n\t\tif(sampleSize <= 0){\n\t\t\tthrow new IllegalArgumentException(\"Invalid sample size given to RandomUnderSample.setSampleSize(int)\");\n\t\t}\n\t\tthis.m_maxNum = sampleSize;\n\t}\n",
    "4834": "\tpublic int getSampleSize(){\n\t\treturn this.m_maxNum;\n\t}\n",
    "4836": "    public void setInputs(AgentInputs inputs){\n    \tthis.m_inputs=inputs;\n    }\n",
    "4837": "    public boolean doesContain(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list of that type of feature\n    \tList<SensoryItem> l = this.m_featuregroupTable.get(featureName);\n\t\t\n    \t//if there is no entry in the feature table the HashMap will\n    \t//have returned null\n    \tif(l == null || l.size() == 0){\n    \t\treturn false;\n    \t}\n    \treturn true;\n    }\n",
    "4842": "    public int getNumberSensoryItems(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list for that feature\n    \tList<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);\n    \t//if null then no features of that type exist\n    \tif(sensoryItemList == null){\n    \t\treturn 0;\n    \t}\n\t\treturn sensoryItemList.size();\n    }\n",
    "4844": "    public String toString(){\n    \tString output = \"Case : \";\n    \toutput += \"\\n\\tInputs : \";\n    \toutput += \"\\n\\t\\t\" + m_inputs.toString(m_inputs.getSensoryItemNames()); \n    \toutput += \"\\n\\tActions : \"; \n    \tfor(AgentAction a : m_actions){\n    \t\toutput += \"\\n\\t\\t\" + a.toString();\n    \t}  \t\n    \treturn output;\n    }\n",
    "4847": "    public int getNumberSensoryItems(){\n    \t//get the feature list for each type of feature\n    \tCollection<List<SensoryItem>> lists = this.m_featuregroupTable.values();\n\t\t\n    \tint featureCounter = 0;\n\t\t\n    \tfor(List<SensoryItem> currentList : lists){\n    \t\t//ignore null lists, these occur when we remove a feature list\n    \t\tif(currentList != null){\n    \t\t\tfeatureCounter += currentList.size();\n    \t\t}\n    \t}\n\t\t\n    \treturn featureCounter;\n    }\n",
    "4850": "\tprivate void resetLists(){\n\t\tthis.m_best = null;\n\t\tthis.m_evalBest = -1;\n\t\tthis.m_statsBest = null;\n\t\tthis.m_closed = new ArrayList<Weights>();\n\t\tthis.m_open = new ArrayList<Weights>();\n\t\tthis.m_evalOpen = new ArrayList<Float>();\n\t\tthis.m_statsOpen = new ArrayList<StatisticsBundle>();\n\t}\n",
    "4851": "    public void addMember(Case c) {\n\tif(c == null){\n\t    throw new IllegalArgumentException(\"Null Case given to Cluster.addMember(Case c)\");\n\t}\n\tthis.m_members.add(c);\n    }\n",
    "4853": "    public void removeSensoryItemType(String featureName){\n    \t//check parameters\n    \tif(featureName == null){\n    \t\tthrow new IllegalArgumentException(\"SensoryItem name was null.\");\n    \t}\n\t\t\n    \t//get the list for the specified feature\n    \tList<SensoryItem> sensoryItemList = this.m_featuregroupTable.get(featureName);\n\t\t\n    \t//if it is null then the feature doesn't exist in the AgentVision\n    \tif(sensoryItemList != null){\n    \t\t//clear the list\n    \t\tsensoryItemList.clear();\n    \t\t//change the table entry to null  (meaning empty)\n    \t\tthis.m_featuregroupTable.remove(featureName);\n    \t}\n    }\n",
    "4855": "\tpublic String getID(){\n\t\treturn this.m_id;\n\t}\n",
    "4856": "\tprivate double calculateError(List<List<VectorPoint>> clusters, VectorPoint[] newCentroids) {\n\t\tdouble total = 0;\n\t\t\n\t\t//go through each cluster\n\t\tfor(int ii=0; ii<clusters.size(); ii++){\n\t\t\tList<VectorPoint> nextCluster = clusters.get(ii);\n\t\t\tVectorPoint centroid = newCentroids[ii];\n\t\t\t//go through each cluster member\n\t\t\tfor(int jj=0; jj<nextCluster.size(); jj++){\n\t\t\t\tVectorPoint item = nextCluster.get(jj);\n\t\t\t\ttotal += item.euclideanDistance(centroid);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn total;\n\t}\n",
    "4857": "\tpublic CaseBase filter(CaseBase initialCB) {\n\t\t//check parameters\n\t\tif(initialCB == null){\n\t\t\tthrow new IllegalArgumentException(\"Null CaseBase given to NoActionsFilter.\");\n\t\t}\n\t\t\n\t\tCaseBase newCB = new CaseBase();\n\t\t\n\t\t//go through each Case in the initial CaseBase\n\t\tList<Case> allCases = initialCB.getCaseList();\n\t\tfor(Case currentCase : allCases){\n\t\t\t//only add ones that have AgentActions\n\t\t\tif(currentCase.getActions().size() != 0){\n\t\t\t\tnewCB.addCase(currentCase);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newCB;\n\t}\n",
    "4860": "\tpublic CaseBase filter(CaseBase initialCB) {\n\t\t//check parameters\n\t\tif(initialCB == null){\n\t\t\tthrow new IllegalArgumentException(\"Null case base given to FeatureDistancePresort.\");\n\t\t}\n\t\t\n\t\t//Create the Case filter\n\t\tFeatureDistanceCasePresort fdcp = new FeatureDistanceCasePresort();\n\t\t\n\t\t//create the new CaseBase\n\t\tCaseBase sorted = new CaseBase();\n\t\t\n\t\t//go through each Case in the CaseBase\n\t\tList<Case> allCases = initialCB.getCaseList();\n\t\tfor(Case currentCase : allCases){\n\t\t\tCase filteredCase = fdcp.filter(currentCase);\n\t\t\tsorted.addCase(filteredCase);\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n",
    "4861": "        public void add(AgentAction decClass){\n            elements+=1;\n            if(!Dclass.equals(decClass)){\n                consistent = false;\n            }\n        }\n",
    "4864": "\tpublic double euclideanDistance(VectorPoint otherPoint){\n\t\t//test the params\n\t\tif(otherPoint == null){\n\t\t\tthrow new IllegalArgumentException(\"Null point given.\");\n\t\t}\n\t\tfloat[] otherData = otherPoint.getPoint();\n\t\tif(otherData.length != this.m_point.length){\n\t\t\tthrow new IllegalArgumentException(\"Euclidean distance cannot be calculated because vectors are of different lengths.\");\n\t\t}\n\t\t\n\t\tdouble distance = 0;\n\t\tfor(int ii=0; ii<this.m_point.length; ii++){\n\t\t\tdistance += (this.m_point[ii] - otherData[ii])*(this.m_point[ii] - otherData[ii]);\n\t\t}\n\t\t\n\t\tdistance = Math.sqrt(distance);\n\t\treturn distance;\n\t}\n",
    "4865": "\tprivate void sortByDistance(List<SensoryItem> sensoryItemList){\n\t\t\n\t\t//define a comparator for sorting a List of Features by distance\n\t\tComparator<SensoryItem> comp = new Comparator<SensoryItem>(){\n\t\t\t public int compare(SensoryItem f1, SensoryItem f2){\n\t\t\t\t \n\t\t\t\t Spatial2DObject sf1 = (Spatial2DObject)f1;\n\t\t\t\t Spatial2DObject sf2 = (Spatial2DObject)f2;\n\t\t\t\t \n\t\t\t\t float dist1 = sf1.getDistance();\n\t\t\t\t float dist2 = sf2.getDistance();\n\t\t\t\t \n\t\t\t\t if (dist1 == dist2){\n\t\t\t\t\t return 0;\n\t\t\t\t }else if(dist1 > dist2){\n\t\t\t\t\t return 1;\n\t\t\t\t }else{\n\t\t\t\t\t return -1;\n\t\t\t\t }\n\t\t\t }\n\t\t};\n\t\t\n\t\t//sort the List based on our comparator we defined\n\t\tCollections.sort(sensoryItemList, comp);\n\t}\n",
    "4868": "        public int getCount(){\n            if(consistent == true)\n                return elements;\n            return 0;\n        }\n",
    "4871": "\tprivate CaseBaseProtocol saveCaseProtocolBufferHelpper(CaseBase casebase){\n\t\tCaseBaseProtocol.Builder builder = CaseBaseProtocol.newBuilder();\n\n\t\tfor(Case c : casebase.getCaseList()){\n\t\t\tbuilder.addMCasebase(saveCaseHelper(c));\n\t\t}\n\n\t\treturn builder.build();\n\t}\n",
    "4872": "\tprivate CaseProtocol saveCaseHelper(Case cases){\n\t\tCaseProtocol.Builder caseBuilder = CaseProtocol.newBuilder();\n\n\t\tcaseBuilder.setMInputs(saveAgentInputsHelper(cases.getInputs()));\n\t\tfor(AgentAction a : cases.getActions()){\n\t\t\tcaseBuilder.addMActions(saveAgentActionHelper(a));\n\t\t}\n\t\treturn caseBuilder.build();\n\t}\n",
    "4873": "        public AgentAction getDclass(){\n            if(consistent == true)\n                return Dclass;\n            return null;\n        }\n",
    "4875": "\tprivate AgentInputsProtocol saveAgentInputsHelper(AgentInputs i){\n\t\tAgentInputsProtocol.Builder inputsBuilder = AgentInputsProtocol.newBuilder();\n\n\t\tfor(String s : i.getSensoryItemNames()){\n\t\t\tAgentInputsProtocol.FeatureGroupTable.Builder featureBuilder = AgentInputsProtocol.FeatureGroupTable.newBuilder();\n\t\t\tfeatureBuilder.setFeature(s);\n\t\t\tfor(SensoryItem si : i.getSensoryItems(s)){\n\t\t\t\tfeatureBuilder.addItem(saveSensoryItemHelper(si));\n\t\t\t}\n\t\t\tinputsBuilder.addMFeaturegroupTable(featureBuilder.build());\n\t\t}\n\t\treturn inputsBuilder.build();\n\t}\n",
    "4876": "\tpublic int getMaximum(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger max = m_max.get(item);\n\t\tif(max == null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn max.intValue();\n\t}\n",
    "4877": "\tprivate SensoryItemProtocol saveSensoryItemHelper(SensoryItem s){\n\t\tSensoryItemProtocol.Builder sensoryBuilder = SensoryItemProtocol.newBuilder();\n\t\tsensoryBuilder.setMFeatureName(s.getFeatureName());\n\t\treturn sensoryBuilder.build();\n\t}\n",
    "4879": "\tpublic int getMinimum(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger min = m_min.get(item);\n\t\tif(min == null){\n\t\t\treturn 0;\n\t\t}\n\t\treturn min.intValue();\n\t}\n",
    "4880": "\tprivate AgentActionProtocol saveAgentActionHelper(AgentAction a){\n\t\tAgentActionProtocol.Builder actionBuilder = AgentActionProtocol.newBuilder();\n\n\t\tactionBuilder.setMName(a.getActionName());\n\t\treturn actionBuilder.build();\n\t}\n",
    "4881": "\tpublic float getMean(String item){\n\t\tif(item == null){\n\t\t\tthrow new IllegalArgumentException(\"Null value given to SensoryItemDistribution function.\");\n\t\t}\n\t\t\n\t\tInteger count = m_count.get(item);\n\t\tif(count == null || m_numCases == 0){\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (float)count/(float)m_numCases;\n\t}\n",
    "4882": "    public AgentInputs getAgentInputs(){\n\treturn aInputs;\n    }\n",
    "4885": "    public String getTeamName(){\n\treturn m_teamName;\n    }\n",
    "4886": "\tpublic String getFeatureName(){\n\t\treturn this.m_featureName;\n\t}\n",
    "4890": "        public SensoryItem copyOfThis(){\n\t    return new SensoryItem(this.getFeatureName());\n\t}\n",
    "4893": "       public String toString(){\n\t   return this.m_featureName;\n       }\n",
    "4894": "\tpublic float pairwiseDistance(SensoryItem f){\n\t\t//check the validity of parameters\n\t\tif(f == null){\n\t\t\tthrow new IllegalArgumentException(\"A null feature was given.\");\n\t\t}\n\t\t\n\t\t//make sure we have a distance calculation algorithm set\n\t\tif(SensoryItem.m_distanceCalculation == null){\n\t\t\tthrow new IllegalStateException(\"The distance calculation algorithm has not yet been set.\");\n\t\t}\n\t\t\n\t\t//if everything is fine, return the pairwise distance\n\t\treturn SensoryItem.m_distanceCalculation.pairwiseDistance(this, f);\n\t}\n",
    "4898": "\tpublic float penaltyDistance(){\n\t\n\t\t//make sure we have a penalty calculation algorithm set\n\t\tif(SensoryItem.m_penaltyCalculation == null){\n\t\t\tthrow new IllegalStateException(\"The penalty calculation algorithm has not yet been set.\");\n\t\t}\n\t\t\n\t\t//if everything is fine, return the pairwise distance\n\t\treturn SensoryItem.m_penaltyCalculation.calculatePenalty(this);\n\t}\n",
    "4899": "\tpublic String toXML(){\n\t\tString xml = \"\";\n\t\t\n\t\txml += \"<SensoryItem>\";\n\t\txml += \"<FeatureName>\";\n\t\txml += this.m_featureName;\n\t\txml += \"</FeatureName>\";\n\t\txml += \"</SensoryItem>\";\n\t\t\n\t\treturn xml;\n\t}\n",
    "5030": "\t@Test\n\tpublic void getClassificationAccuracy_manyTypesPerfect() throws Exception{\t\n\t\tMethod addPair = addPairHack();\n\t\t\n\t\t//simulate the pairings\n\t\taddPair.invoke(this.dummysw, \"oneAction\", \"oneAction\");\n\t\taddPair.invoke(this.dummysw, \"otherAction\", \"otherAction\");\n\t\taddPair.invoke(this.dummysw, \"otherAction\", \"otherAction\");\n\t\taddPair.invoke(this.dummysw, \"thirdAction\", \"thirdAction\");\n\t\taddPair.invoke(this.dummysw, \"thirdAction\", \"thirdAction\");\n\t\t\n\t\tassertEquals(this.dummysw.getClassificationAccuracy(), 1.0f);\n\t}\n",
    "5143": "    private void preFlushEntities() throws HibernateException {\n\n        List list = IdentityMap.concurrentEntries(entityEntries);\n        //safe from concurrent modification because of how entrySet() is implemented on IdentityMap\n        int size = list.size();\n        for ( int i=0; i<size; i++ ) {\n\n            Map.Entry me = (Map.Entry) list.get(i);\n            EntityEntry entry = (EntityEntry) me.getValue();\n            Status status = entry.status;\n\n            if ( status!=LOADING && status!=GONE && status!=DELETED ) {\n                Object object = me.getKey();\n                cascading++;\n                try {\n                    Cascades.cascade(this, entry.persister, object, Cascades.ACTION_SAVE_UPDATE, Cascades.CASCADE_ON_UPDATE);\n                }\n                finally {\n                    cascading--;\n                }\n            }\n        }\n\n    }\n",
    "5203": "\tprivate Method addPairHack() throws Exception{\n\t\t\n\t\tClass<StatisticsWrapper> c = StatisticsWrapper.class;\n\t\tMethod addPair = c.getDeclaredMethod(\"addPair\", new Class[]{String.class, String.class});\n\t\taddPair.setAccessible(true);\n\t\t\n\t\treturn addPair;\n\t}\n",
    "5380": "    public boolean contains(String paramName){\n\treturn line.contains(paramName);\n    }\n",
    "5419": "    private void parseOptions(String message, String params)\n    { //parse an initialization info\n\tparsed.setSensor(message);\n\tparsed.setParam(\"params\",params);\n\tparsed.setCycle(-1);\n\tParsingEvent pe=new ParsingEvent(this,parsed);\n\tfor(ParsingEventListener pel:PEListeners) pel.ServerParams(pe);\n    }\n",
    "5423": "    private void parseError(String message, String params)\n    { //parse an error\n\tparsed.setSensor(message);\n\tparsed.setParam(\"error\",params);\n\tparsed.setCycle(-2);\n\tParsingEvent pe=new ParsingEvent(this,parsed);\n\tfor(ParsingEventListener pel:PEListeners) pel.Error(pe);\n    }\n",
    "5521": "    private void preFlushCollections() throws HibernateException {\n\n        // Initialize dirty flags for arrays + collections with composite elements\n        // and reset reached, doupdate, etc.\n\n        List list = IdentityMap.entries(collectionEntries);\n        int size = list.size();\n        for ( int i=0; i<size; i++ ) {\n            Map.Entry e = (Map.Entry) list.get(i);\n           \t( (CollectionEntry) e.getValue() ).preFlush( (PersistentCollection) e.getKey() );\n        }\n    }\n",
    "5654": "    public void setPageSize(int pageSize){\n        this.pageSize = pageSize;\n        maxPage = rowCount / this.pageSize;\n        if (rowCount % pageSize > 0)\n            maxPage++;\n        currentPage = 0;\n            gotoPage(0);\n    }\n",
    "5658": "    public int getPageSize(){\n        return pageSize;\n    }\n",
    "5660": "    public void gotoPage(int pageNumber){\n        if ((pageNumber < 0)  || (pageNumber > maxPage))\n                throw new IndexOutOfBoundsException(\"Page number incorrect: got \"+pageNumber+ \"min 0, max \"+maxPage);\n        currentPage = pageNumber;\n        index = pageSize * currentPage;\n\n        length = ((rowCount - index) < pageSize) ? (rowCount - index): (pageSize);\n\n        fireTableStructureChanged();\n\n    }\n",
    "5665": "        public void setCheckValues(ArrayList<Map<K, V>> checkValues) {\n             this.checkValues.clear();\n             this.checkValues.addAll(checkValues);\n        }\n",
    "5666": "    public void gotoPrevPage(){\n        gotoPage(currentPage--);\n    }\n",
    "5668": "    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n        if (isSelected){\n            setForeground(table.getSelectionForeground());\n            setBackground(table.getSelectionBackground());\n        }\n        else{\n            setForeground(table.getForeground());\n            setBackground(table.getBackground());\n        }\n        boolean selected = (Boolean)value; //\u043f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a \u0442\u0438\u043f\u0443 Boolean\n        setSelected(selected); //\u0438\u0437\u043c\u0435\u043d\u044f\u0435\u043c \u0432\u0438\u0434 \u0447\u0435\u043a\u0431\u043e\u043a\u0441\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n        return this;\n    }\n",
    "5669": "    public int getPageCount(){\n        return maxPage;\n    }\n",
    "5672": "    public int getPageNumber(){\n        return currentPage;\n    }\n",
    "5677": "    public void setData(String[][] data, String[] columnNames, int pageSize){\n        this.data = data;\n        this.columnNames = columnNames;\n        this.isEnabled = new boolean[columnNames.length];\n        colCount = data.length;\n        if (colCount > 0)\n            rowCount = data[0].length;\n        setPageSize(pageSize);\n\n    }\n",
    "5679": "    public void warning(SAXParseException e) throws SAXException {\n        String location = \"Warning at [ \"+e.getColumnNumber()+\",\"+e.getLineNumber()+\"]:\";\n        System.out.println(e.getMessage());\n    }\n",
    "5683": "        public int getColumnCount() {\n            return colCount;\n        }\n",
    "5693": "        private void changeFilterState(int columnIndex, boolean  state){\n            if (state) {  // if check is enabled\n                manager.updateData(columnIndex,data[columnIndex]); //update validator\n                for (int i = 0; i < rowCount; i++) //corrects values for cells in columns\n                    data[columnIndex][i] = manager.getValidValue(columnIndex,data[columnIndex][i]);\n                fireTableDataChanged();\n            }\n\n        }\n",
    "5697": "        public Object getValueAt(int rowIndex, int columnIndex) {\n            if (rowIndex == 0)\n                return isEnabled[columnIndex];\n            else {\n                rowIndex+=index;\n                if (isEnabled[columnIndex])\n                    return manager.getValidValue(columnIndex,data[columnIndex][rowIndex-1]);\n                return data[columnIndex][rowIndex-1];\n            }\n\n            }\n",
    "5700": "        public boolean addValidator(int columnIndex, Validator validator){\n            if ((columnIndex >= 0 ) && (columnIndex <= columnNames.length -1)) {\n                manager.addValidator(columnIndex,validator);\n                return true;\n            }\n\n            else return false;\n        }\n",
    "5708": "    public boolean addEditor(String columnName, Editor editor){\n        return addEditor(findColumn(columnName),editor);\n    }\n",
    "5709": "    public void resizeNumberPanel( int maxNumber){\n        int digitCount = 3;\n        while ((maxNumber = maxNumber/10) > 0)\n            digitCount++;\n        this.setMinimumDisplayDigits(digitCount);\n    }\n",
    "5710": "    public Validator getValidator(int columnIndex){\n        return manager.getValidator(columnIndex);\n    }\n",
    "5766": "    private DefaultMutableTreeNode copy(DefaultMutableTreeNode node) {\n        return new DefaultMutableTreeNode(node.getUserObject());\n    }\n",
    "5776": "    private void refreshData(){\n        try {\n            countLines();\n            readData();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        JTableHeader header = owner.getTableHeader();\n        owner.setTableHeader(new JTableHeader());\n        fireTableStructureChanged();\n        fireTableDataChanged();\n        owner.setTableHeader(header);\n\n    }\n",
    "5779": "    private void countLines() throws IOException {\n        fileLineCount = 0;\n        steamReader = new InputStreamReader(new FileInputStream(this.inputFile),this.charset);\n        BufferedReader dataReader = new BufferedReader(steamReader);\n        while ( dataReader.readLine() !=null)\n            fileLineCount++;\n        steamReader.close();\n        dataReader.close();\n    }\n",
    "5782": "     public void setSplitRegexp(String splitRegexp) {\n         this.splitRegexp = splitRegexp;\n         refreshData();\n     }\n",
    "5784": "    public String getSplitRegexp() {\n        return splitRegexp;\n    }\n",
    "5785": "    public int getRowCount() {\n        return map.size();\n    }\n",
    "5786": "    public int getRowCount() {\n        return fileLineCount - startLine;\n    }\n",
    "5787": "    public int getColumnCount() {\n        return 2;\n    }\n",
    "5788": "    public int getColumnCount() {\n         return fileColumnCount;\n    }\n",
    "5789": "    public Object getValueAt(int row, int column) {\n        Object[] entries=map.entrySet().toArray();\n        Map.Entry entry=(Map.Entry)entries[row];\n        if (column==0) {\n            return entry.getKey();\n        } else if (column==1) { // column==1\n            return entry.getValue();\n        } else {\n            throw new IndexOutOfBoundsException(Integer.toString(column));\n        }\n    }\n",
    "5792": "    public String getColumnName(int column) {\n        return columnNames[column];\n    }\n",
    "5794": "    public void setColumnNames(String keyName, String valueName) {\n        columnNames= new String[]{keyName, valueName};\n    }\n",
    "5796": "    public Map getMap() {\n        return map;\n    }\n",
    "5797": "    public char getMinChar() {\n        return minChar;\n    }\n",
    "5798": "    public int getLength() {\n        return length;\n    }\n",
    "5799": "    public void setMap(Map map) {\n        this.map = map;\n    }\n",
    "5805": "    public WizardModel getWizardModel() {\n        return wizard.getModel();\n    }\n",
    "5812": "    public void aboutToDisplayPanel() {\n\n    }\n",
    "5813": "    public void displayingPanel() {\n\n    }\n",
    "5815": "    public void aboutToHidePanel() {\n\n    }    \n",
    "5851": "    public JDialog getDialog() {\n        return wizardDialog;\n    }\n",
    "5859": "    public Component getOwner() {\n        return wizardDialog.getOwner();\n    }\n",
    "5861": "    public void setFormat(SimpleDateFormat format) {\n        this.format = format;\n    }\n",
    "5864": "    public void tableChanged(TableModelEvent e) {\n\n        makeSample();\n    }\n",
    "5865": "    public void setTitle(String s) {\n        wizardDialog.setTitle(s);\n    }\n",
    "5867": "    private void makeSample(){\n        panel.getFileBrowser().setText(\"\");\n        Map<String, String> fieldMap;\n        fieldMap = model.getMap();\n        String[] fields = fieldMap.values().toArray(new String[fieldMap.values().size()]); \n        builder.mapAttributes(columns, fields);\n        builder.makeSample(data[0],sampleWriter);\n        panel.getFileBrowser().setCaretPosition(0);\n    }\n",
    "5871": "    public String getTitle() {\n        return wizardDialog.getTitle();\n    }\n",
    "5875": "    private void  fillArrayLoop(Object[] source, Object[] dest){\n\n        if  (source.length >= dest.length)\n        System.arraycopy(source,0,dest,0,dest.length);\n        else {\n            System.arraycopy(source,0,dest,0,source.length);\n            int length = source.length;\n            int counter = 0;\n            while (length < dest.length) {\n                dest[length] = source[counter];\n                counter++;\n                length++;\n                if (counter == source.length)\n                    counter = 0;\n            }\n        }\n\n\n    }\n",
    "5877": "    public void setModal(boolean b) {\n        wizardDialog.setModal(b);\n    }\n",
    "5881": "    public void showButtons(String fileName){\n        if (FileValidate.canWrite(fileName))  {\n            getWizard().setNextFinishButtonEnabled(true);\n            Core appCore = Core.getInstance();\n            appCore.setOutputFile(new File(fileName));\n            appCore.setOutputWriter(writer);\n\n        }\n\n        else\n            getWizard().setNextFinishButtonEnabled(false);\n    }\n",
    "5884": "    public boolean isModal() {\n        return wizardDialog.isModal();\n    }\n",
    "5890": "    public int showModalDialog() {\n        \n     //   wizardDialog.setModalityType(Dialog.ModalityType.TOOLKIT_MODAL);\n        wizardDialog.pack();\n        wizardDialog.setModal(true);\n        wizardDialog.setVisible(true);\n        return returnCode;\n    }\n",
    "5897": "    public WizardModel getModel() {\n        return wizardModel;\n    }\n",
    "5898": "    public JTextField getFileNameField(){\n        return content.getFileNameField();\n    }\n",
    "5900": "    public JTextArea getFileBrowser(){\n        return content.getContentBrowser();\n    }\n",
    "5901": "    public JTable getContentTable(){\n        return content.getMapTable();\n    }\n",
    "5902": "    public JTextField getFileNameField() {\n        return fileNameField;\n    }\n",
    "5903": "    public XMLWriterGUI getContent(){\n        return content;\n    }\n",
    "5904": "    public JTextArea getContentBrowser() {\n        return contentBrowser;\n    }\n",
    "5907": "    public void registerWizardPanel(Object id, WizardPanelDescriptor panel) {\n        \n        //  Add the incoming panel to our JPanel display that is managed by\n        //  the CardLayout layout manager.\n        \n        cardPanel.add(panel.getPanelComponent(), id);\n        \n        //  Set a callback to the current wizard.\n        \n        panel.setWizard(this);\n        \n        //  Place a reference to it in the model. \n        \n        wizardModel.registerPanel(id, panel);\n        \n    }  \n",
    "5909": "    public void mapAttributes(String[] columnNames, String[] attributes) {\n        indexesMap.clear();\n        for (int i = 0; i < attributes.length; i++ ){\n            String name = this.attributes[i];\n            indexesMap.put(name,findIndex(attributes[i],columnNames));\n        }\n    }\n",
    "5913": "    public void setCurrentPanel(Object id) {\n\n        //  Get the hashtable reference to the panel that should\n        //  be displayed. If the identifier passed in is null, then close\n        //  the dialog.\n        \n        if (id == null)\n            close(ERROR_RETURN_CODE);\n        \n        WizardPanelDescriptor oldPanelDescriptor = wizardModel.getCurrentPanelDescriptor();\n        if (oldPanelDescriptor != null)\n            oldPanelDescriptor.aboutToHidePanel();\n        \n        wizardModel.setCurrentPanel(id);\n        wizardModel.getCurrentPanelDescriptor().aboutToDisplayPanel();\n        \n        //  Show the panel in the dialog.\n        \n        cardLayout.show(cardPanel, (String)id);\n        wizardModel.getCurrentPanelDescriptor().displayingPanel();        \n        \n        \n    }\n",
    "5914": "    public void reset(){\n        users.clear();\n    }\n",
    "5918": "    public void makeSample(String[] fields, Writer out){\n        UserList sampleList = new UserList();\n        List<UserList.User> sample = sampleList.getUser();\n        sample.add(createUser(fields));\n        JAXBElement<UserList> sampleElement = new JAXBElement<UserList>(name,UserList.class,null,sampleList);\n        JAXB.marshal(sampleElement,out);\n\n\n\n\n    }\n",
    "5921": "    public void openFile(String fileName) throws IOException {\n        output = new FileOutputStream(fileName,false);\n\n\n    }\n",
    "5922": "    public void close() throws IOException {\n        output.close();\n    }\n",
    "5923": "    public void writeData(MappingResult result) throws IOException {\n        builder.reset();\n        for (String[] row : result.getData()){\n            builder.addUser(row);\n        }\n            builder.writeData(output);\n    }\n",
    "5926": "    public int getReturnCode() {\n        return returnCode;\n    }\n",
    "5933": "    public boolean getBackButtonEnabled() {\n        return wizardModel.getBackButtonEnabled();\n    }\n",
    "5935": "    public void insertUpdate(DocumentEvent e) {\n        showButtons(fileNameField.getText());\n\n    }\n",
    "5936": "    public void removeUpdate(DocumentEvent e) {\n        showButtons(fileNameField.getText());\n\n    }\n",
    "5939": "    public void setBackButtonEnabled(boolean newValue) {\n        wizardModel.setBackButtonEnabled(newValue);\n    }\n",
    "5945": "    public boolean getNextFinishButtonEnabled() {\n        return wizardModel.getNextFinishButtonEnabled();\n    }\n",
    "5951": "    public void setNextFinishButtonEnabled(boolean newValue) {\n        wizardModel.setNextFinishButtonEnabled(newValue);\n    }\n",
    "5958": "    public boolean getCancelButtonEnabled() {\n        return wizardModel.getCancelButtonEnabled();\n    }\n",
    "5963": "    public void setCancelButtonEnabled(boolean newValue) {\n        wizardModel.setCancelButtonEnabled(newValue);\n    }\n",
    "5972": "    public void initDialog(MappingResult result){\n        String[] columns = result.getColumns();\n        String data[][] = result.getData();\n        Set<String> ouNames = new HashSet<String>();\n            for (String[] row : data){\n              OUNode node = new OUNode(columns,row);\n              String name = node.toString();\n              if (!ouNames.contains(name))  {\n                  root.add(new DefaultMutableTreeNode(node));\n                  ouNames.add(name);\n              }\n            }\n            availableFields.setModel(new DefaultComboBoxModel<String>(columns));\n    }\n",
    "5974": "    public void clearTree(){\n        OUNode rootNode = new OUNode(new String[]{\"ou\"},new String[]{\"Domain Controllers\"});\n        root = new DefaultMutableTreeNode(rootNode);\n    }\n",
    "5975": "    public void openFile(String fileName) throws IOException {\n        writer = new BufferedWriter(new FileWriter(fileName, false));\n    }\n",
    "5978": "    public void close() throws IOException {\n        writer.close();\n    }\n",
    "5980": "    public String generateScript(MappingResult result){\n        UserFactory factory = new UserFactory(\"dc=edo ,dc=chsu, dc=ru\",\n                Arrays.asList(\"cn\",\"sn\",\"userPrincipalName\",\n                        \"userAccountControl\",\"unicodePwd\", \"givenName\"));\n        factory.initFactory(result);\n        StringBuilder script = new StringBuilder();\n        for( String[] row : result.getData()){\n            try {\n\n                script.append(documentBuilder.createAddStatement(factory.createClass(row)));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return script.toString();\n    }\n",
    "5983": "    public void writeData(MappingResult result) throws IOException {\n       writer.write(generateScript(result));\n    }\n",
    "5984": "    public void initFactory(MappingResult result) {\n        this.columns = result.getColumns();\n        for (int i = 0; i < columns.length; i++){ //searches for dn-attributes\n            int index =Arrays.binarySearch(dnAttributes,columns[i]); \n            if (index > -1)\n                dnIndexes[index] = i; // stores found indexes\n        }\n        \n    }\n",
    "5988": "    private StringBuilder makeAttributeDescription(LDIFClass object){\n        StringBuilder builder = new StringBuilder();\n        for (String key : object.keySet()) {\n            String[] values = object.get(key);\n            for (String value : values){\n                builder.append(key);\n                builder.append(\":\");\n                builder.append(generateSafeString(value));\n                builder.append(SEP);\n            }\n        }\n        return builder;\n    }\n",
    "5989": "    public LDIFClass createClass(String[] data) {\n        LDIFClass result = new LDIFClass();\n        result.setDN(makeDN(data)); //make and store DN\n        result.put(\"objectclass\",\"user\"); //store object class\n\n        for (int i = 0; i < columns.length; i++ )  //for all attributes in row\n            if (attributeNames.contains(columns[i])) // if this attribute is an user attributes\n              result.put(columns[i],data[i]); //store it\n        return result;\n    }\n",
    "5991": "    public StringBuilder createAddStatement(LDIFClass object) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"dn:\");\n        builder.append(generateSafeString(object.getDN()));\n        builder.append(SEP);\n        builder.append(\"changetype:add\");\n\n        builder.append(SEP);\n        builder.append(makeAttributeDescription(object));\n        builder.append(SEP);\n        return builder;\n    }\n",
    "5992": "    public void setSheetName(String sheetName) {\n        this.sheetName = sheetName;\n    }\n",
    "5993": "    public void setSelectedColumns(int[] selectedColumns,String[] columnNames){\n        this.selectedColumns = selectedColumns;\n        this.columnNames = columnNames;\n    }\n",
    "6000": "    public void close() throws IOException {\n        try {\n            workbook.write();\n            workbook.close();\n        } catch (WriteException e) {\n            throw new IOException(e);\n        }\n    }\n",
    "6003": "    private void writeRow(String[] data) throws IOException {\n        int colCounter = 0;\n        for (int index : selectedColumns){// for all indexes of selectedColumns\n            try {       // write values to sheet as text label\n                sheet.addCell(new Label(colCounter,activeRow,data[index]));\n                colCounter++; //increase column number\n            } catch (WriteException e) {\n                throw new IOException(e);\n            }\n        }\n\n    }\n",
    "6005": "    public void writeData(MappingResult result) throws IOException {\n\n        activeRow = 0;\n        int colCounter = 0;\n        String columnNames[] = result.getColumns(); // getting column names\n        for ( int index : selectedColumns)\n            try {  //writing selected column names\n                sheet.addCell(new Label(colCounter,activeRow,columnNames[index]));\n                colCounter++;\n            } catch (WriteException e) {\n                throw new IOException(e.getMessage(),e);\n            }\n        activeRow++;\n        for (String[] row : result.getData()){//for all selected rows of mapping output\n            writeRow(row); //write the row to worksheet\n            activeRow++;\n        }\n\n\n    }\n",
    "6008": "    public XLSWriterGUI getContent(){\n        return content;\n    }\n",
    "6013": "    public Charset getCharset() {\n        return charset;\n    }\n",
    "6015": "     public void setCharset(Charset charset) {\n        this.charset = charset;\n    }\n",
    "6020": "     public int getStartLine() {\n        return startLine;\n    }\n",
    "6022": "    public void setStartLine(int startLine) {\n        if (startLine < 0)   //line number must be non-negative\n            this.startLine = 0;\n        else\n          this.startLine = startLine;\n    }\n",
    "6024": "    public void stateChanged(ChangeEvent e) {\n        refreshFileContent();\n    }\n",
    "6027": "    public void actionPerformed(ActionEvent e) {\n        refreshFileContent();\n    }\n",
    "6029": "    public void setSplitRegexp(String splitRegexp) {\n        this.splitRegexp = splitRegexp;\n    }\n",
    "6032": "    public void setColumns(String[] columns) {\n        this.columns = columns;\n    }\n",
    "6040": "    public void actionPerformed(ActionEvent e) {\n        readerPanel.getContent().updateSeparators();\n    }\n",
    "6043": "    private void gotoStartLine() throws FileNotFoundException, NoSuchElementException {\n        inputScanner = new Scanner(getFile(),charset.name());\n                int lineCount = startLine;\n        while (lineCount-- > 0)\n                inputScanner.nextLine();\n    }\n",
    "6050": "    public FileReaderGUI getReaderGUI() {\n        return readerGUI;\n    }\n",
    "6051": "    public FileSeparator getContent() {\n        return GUI;\n    }\n",
    "6052": "    public JSpinner getImportStringSpinner() {\n        return importStringSpinner;\n    }\n",
    "6053": "   public JTable getFiletable(){\n       return GUI.getFileTable();\n   }\n",
    "6055": "    public Charset getCharset(){\n        return (Charset) charsetComboBox.getSelectedItem();\n    }\n",
    "6057": "    public JTable getFileTable() {\n        return fileTable;\n    }\n",
    "6059": "    public File getFile() {\n        return file;\n    }\n",
    "6060": "    public void setCheckboxesActionListener(ActionListener a){\n        for (Component component : separators.getComponents()) {\n            if (component instanceof JCheckBox)\n            {\n                ((JCheckBox)component).addActionListener(a);\n            }\n        }\n    }\n",
    "6061": "    public void setFile(File file) {\n        this.file = file;\n    }\n",
    "6063": "    public void setPreviewModel(TableModel fileViewModel) {\n        fileTable.setModel(fileViewModel);\n    }\n",
    "6064": "    public void setWorkSheet(int sheetIndex){\n        if (sheetIndex < sheetCount) {\n            this.sheetIndex = sheetIndex;\n            worksheet = workbook.getSheet(sheetIndex);\n        }\n    }\n",
    "6065": "    public int getSheetIndex() {\n        return sheetIndex;\n    }\n",
    "6066": "    public JPanel getContentPane() {\n        return contentPane;\n    }\n",
    "6067": "    public String getSheetName(){\n        return workbook.getSheet(sheetIndex).getName();\n    }\n",
    "6068": "    public void updateSeparators(){\n        String result =\"\";\n        for (Component component : separators.getComponents()) { // determine what checkboxes are checked\n            boolean isSelected = (component instanceof JCheckBox) && ((JCheckBox)component).isSelected();\n            if (isSelected)\n                result += ((JCheckBox)component).getActionCommand(); //add corresponding regexp to result\n        }\n        if (result.length() > 0) //if some regexp is selected\n            result =\"[\"+result+\"]\"; // quote it\n        else\n            result =  \"/.?/\"; // otherwise use default value\n        FileViewModel model = (FileViewModel) fileTable.getModel();\n        model.setSplitRegexp(result);      //update model\n        ColumnPacker.packColumns(fileTable, 3);  //pack table\n    }\n",
    "6070": "    public int getSheetCount(){\n        return sheetCount;\n    }\n",
    "6071": "    public void setSelectedColumns(int[] selectedColumns, String[] columnNames) throws IndexOutOfBoundsException{\n        this.selectedColumns = selectedColumns;\n        int maxColumns = worksheet.getColumns();\n        for (int selectedColumn : selectedColumns) {\n            if ((selectedColumn < 0 ) || (selectedColumn >= maxColumns))\n                throw new IndexOutOfBoundsException(\"\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \"+selectedColumn+ \" >= \"+maxColumns);\n        }\n        this.columnNames = columnNames;\n\n    }\n",
    "6076": "    public void setSelectedColumns() throws IndexOutOfBoundsException{\n        int maxColumns = worksheet.getColumns();\n        this.selectedColumns = new int[maxColumns];\n        this.columnNames = new String[selectedColumns.length];\n\n        for (int i = 0; i < selectedColumns.length; i++) {\n            selectedColumns[i] = i;\n            columnNames[i] = worksheet.getCell(i,0).getContents();\n        }\n    }\n",
    "6084": "    public JTable getContentTable() {\n        return contentTable;\n    }\n",
    "6086": "    public JLabel getSheetName() {\n        return sheetName;\n    }\n",
    "6088": "    public JSpinner getSheetSpinner() {\n        return sheetSpinner;\n    }\n",
    "6090": "    public XLSReaderGUI getContent(){\n        return content;\n    }\n",
    "6096": "    public void setSheet(int sheetNumber){\n        if (sheetNumber < sheetCount) { // check if number is valid\n            workSheet = workbook.getSheet(sheetNumber); // change actual worksheet\n            sheetIndex = sheetNumber;\n            fireTableStructureChanged(); // fire table change events\n            fireTableDataChanged();\n        }\n    }\n",
    "6099": "    public String getSheetName(){\n        return workSheet.getName();\n    }\n",
    "6106": "    public File getFile() {\n        return filename;\n    }\n",
    "6107": "    public void stateChanged(ChangeEvent e) {\n        JSpinner source = (JSpinner)e.getSource();\n        xlsModel.setSheet((Integer)source.getValue());  //update sheet\n        panel.getContent().getSheetName().setText(xlsModel.getSheetName()); //update name\n        JTableHeader header = new EditableTableHeader(contentTable.getColumnModel());\n        contentTable.setTableHeader(header); //set up the header\n        ColumnPacker.packColumns(contentTable, 3);\n    }\n",
    "6113": "    public int getRowCount() {\n        return workSheet.getRows()-1;\n    }\n",
    "6114": "    public void actionPerformed(ActionEvent e) {\n        refreshPageCounter();\n    }\n",
    "6115": "    public int getColumnCount() {\n        return workSheet.getColumns();\n    }\n",
    "6118": "    public Object getValueAt(int rowIndex, int columnIndex) {\n        return workSheet.getCell(columnIndex, rowIndex+1).getContents();//not displaying the header row\n    }\n",
    "6122": "    public void stateChanged(ChangeEvent e) {\n           int pageNumber = (Integer)recordSpinner.getValue() - 1; // get selected page number from event\n           model.gotoPage(pageNumber);// change model state\n    }\n",
    "6129": "    private void refreshPageCounter(){\n\n        int pageSize = panel.getContent().getRecordsPerPage();\n        model.setPageSize(pageSize);\n        int pageCount = model.getPageCount();\n        recordSpinner.setModel(new SpinnerNumberModel(1,1,pageCount,1));\n        panel.getContent().getAmount().setText(Integer.toString(pageCount));\n\n\n    }\n",
    "6135": "    private void reshapeData() {\n        String[][] newArray;\n        newArray = new String[linesCount][];\n        for (int i = 0; i < newArray.length; i++){\n            newArray[i] = new String[columns.length];\n            for (int j = 0; j < columns.length; j++)\n                newArray[i][j] = displayData[j][i];\n        }\n        displayData = newArray;\n    }\n",
    "6144": "    public MappingSettings getContent() {\n        return content;\n    }\n",
    "6154": "    private int findMapperIndex(Class mapperClass){\n        ListModel<MapperDecorator> model = pluginsList.getModel();\n        int length = model.getSize();\n        for (int i = 0;i < length; i++ ){\n            AttributeMapper current = model.getElementAt(i).getDelegate();\n            if (current.getClass().equals(mapperClass))\n                return i;\n\n        }\n        return -1;\n    }\n",
    "6158": "    public JLabel getAmount() {\n        return amount;\n    }\n",
    "6159": "    public Integer getRecordsPerPage() {\n        return Integer.parseInt((String)recordsPerPage.getSelectedItem());\n    }\n",
    "6161": "    public JComboBox getRecordsComboBox(){\n        return recordsPerPage;\n    }\n",
    "6163": "    public JSpinner getRecordSpinner() {\n        return recordSpinner;\n    }\n",
    "6165": "    public JTable getResultsTable() {\n        return resultsTable;\n    }\n",
    "6166": "            public void valueChanged(ListSelectionEvent e) {\n                //retrieve dialog window for selected plugin from manager\n                currentDialog = dialogManager.getDialog(pluginsList.getSelectedValue().getDelegate());\n                if (currentDialog==null) { //if dialog window is not found\n                    configPanel.removeAll();\n                    configPanel.add(defaultPanel); //display default panel\n                    configPanel.repaint();\n                }\n                else  {\n                     configPanel.removeAll();   //otherwise display dialog for mapper\n                     configPanel.add(currentDialog.getConfigPanel());\n                     configPanel.repaint();\n                }\n                pack();\n            }\n",
    "6168": "    private void createUIComponents() {\n\n        recordSpinner = new JSpinner();\n        resultsTable = new JTable();\n        resultsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n    }\n",
    "6170": "    public void setAvailableAttributes(Collection<AttributeBean>collection){\n        fieldList.removeAll();\n        DefaultListModel<String> model = (DefaultListModel<String>) fieldList.getModel();\n        for (AttributeBean bean : collection)\n            model.addElement(bean.getName());\n    }\n",
    "6173": "    private void showAddDialog(AttributeBean bean){\n        DefaultListModel<AttributeBean> model =\n                (DefaultListModel<AttributeBean>) availableAttributesList.getModel();\n       List<AttributeBean> list = Collections.list(model.elements());\n       model = (DefaultListModel<AttributeBean>) usedAttributesList.getModel();\n       list.addAll(Collections.list(model.elements()));\n\n         addDialog.setAvailableAttributes(list);\n         addDialog.setData(bean);\n\n         addDialog.pack();\n         addDialog.setVisible(true);\n         addDialog.getData(bean);\n\n    }\n",
    "6176": "    public AttributeMapper createPlugin(Class<? extends AttributeMapper> mapperClass) throws PluginConfigurationException {\n        boolean isFound = pluginsMap.values().contains(mapperClass);\n        if (!isFound)\n            throw new PluginConfigurationException(mapperClass) ;\n        AttributeMapper result;\n        try {\n            result = mapperClass.newInstance();//\u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\n        } catch (InstantiationException e) {\n            throw new PluginConfigurationException(mapperClass);\n        } catch (IllegalAccessException e) {\n             throw new PluginConfigurationException(mapperClass);\n        }\n        return result;\n    }\n",
    "6181": "    public boolean contains(String value){\n        return value.equals(data) || parent != null && parent.contains(value);\n    }\n",
    "6183": "    private void createUIComponents() {\n        // TODO: place custom component creation code here\n        availableAttributesList = new JList<AttributeBean>();\n        usedAttributesList = new JList<AttributeBean>();\n\n        availableAttributesList.setModel(new DefaultListModel<AttributeBean>());\n        usedAttributesList.setModel(new DefaultListModel<AttributeBean>());\n        addDialog = new AddMapper();\n        addDialog.setModal(true);\n        addDialog.setLocation(this.getX(),this.getY());\n    }\n",
    "6184": "    public void addChild(String value)throws DependencyException {\n        if (!contains(value)){\n            childs.add(new DependencyTree(this,value));\n        } else throw new DependencyException(\"\u0426\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043b\u044f \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u0430 \"+value);\n\n    }\n",
    "6186": "    public void addChilds(String[] values) throws DependencyException {\n        for (String value : values) {\n            addChild(value);\n        }\n\n    }\n",
    "6191": "    private void isCyclicDependent(String attributeName, ru.chsu.mapper.dependence.DependencyTree parent)throws ru.chsu.mapper.dependence.DependencyException {\n            ru.chsu.mapper.dependence.DependencyTree tree = new ru.chsu.mapper.dependence.DependencyTree(parent,attributeName);\n            AttributeBean attributeBean = config.get(attributeName);\n            AttributeMapper plugin = attributeBean.getMapper();\n            if (plugin != null){\n                String[] dependencies = attributeBean.getMapper().getDependencies();\n                tree.addChilds(dependencies);\n                for (ru.chsu.mapper.dependence.DependencyTree child : tree.getChilds()) {\n                    isCyclicDependent(child.getData(), tree);\n                }\n            }\n    }\n",
    "6196": "    public void checkDependencies(Collection<String> attributes) throws ru.chsu.mapper.dependence.DependencyException {\n        for (String attribute : attributes) {\n            isCyclicDependent(attribute,null);\n        }\n    }\n",
    "6201": "    public void setInputAttributes(Map<String, String> inputAttributes) {\n        this.inputAttributes = inputAttributes;\n    }\n",
    "6212": "    private void configureMappers(String configFileName) throws DependencyException, PluginConfigurationException{\n        ConfigParser parser;\n        try {\n            parser = new ConfigParser(configFileName);\n        } catch (IOException e) {\n            throw new PluginConfigurationException(\"Error: configuration file cannot be read\");\n        } catch (ParserConfigurationException e) {\n            throw new PluginConfigurationException(\"Error: configuration file structure is invalid\");\n        }\n        try {\n            config = parser.loadAttributes();\n        } catch (PluginConfigurationException e) {\n            e.printStackTrace();\n\n        }\n        checkDependencies(config.keySet());\n    }\n",
    "6229": "    public void setMapper(String field, AttributeBean mapperBean){\n        config.put(field, mapperBean);\n    }\n",
    "6540": "    private void convertNonSerializableParams(Object[] params) {\n        // Happens when the method is parameter-less\n        if (params == null) {\n            return;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            params[i] = Naming.getParameterStubIfNeeded(params[i]);\n        }\n    }\n",
    "6650": "    private void addUninitializedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {\n        CollectionEntry ce = new CollectionEntry(persister, id, flushing);\n        collection.setCollectionSnapshot(ce);\n        addCollection(collection, ce, id);\n    }\n",
    "6717": "    private void addUninitializedDetachedCollection(PersistentCollection collection, CollectionPersister persister, Serializable id) {\n        CollectionEntry ce = new CollectionEntry(persister, id);\n        collection.setCollectionSnapshot(ce);\n        addCollection(collection, ce, id);\n    }\n",
    "6852": "    public void addArrayHolder(ArrayHolder holder) {\n        //TODO:refactor + make this method private\n        arrayHolders.put( holder.getArray(), holder );\n    }\n",
    "6868": "\tpublic void dragDropEnd(DragSourceDropEvent e)\t{}\n",
    "7190": "\tpublic void keyReleased(KeyEvent e) {}\n",
    "7463": "    protected void finalize() throws Throwable {\n\n        log.debug(\"running Session.finalize()\");\n\n        if (isCurrentTransaction) log.warn(\"afterTransactionCompletion() was never called\");\n\n        if (connection!=null) { //ie it was never disconnected\n\n            //afterTransactionCompletion(false);\n\n            if ( connection.isClosed() ) {\n                log.warn(\"finalizing unclosed session with closed connection\");\n            }\n            else {\n                log.warn(\"unclosed connection, forgot to call close() on your session?\");\n                if (autoClose) connection.close();\n                //TODO: Should I also call closeStatements() from here?\n            }\n        }\n    }\n",
    "7571": "    private CollectionEntry getCollectionEntryOrNull(Object collection) {\n\n        PersistentCollection coll;\n        if (collection instanceof PersistentCollection) {\n            coll = (PersistentCollection) collection;\n            //if (collection==null) throw new TransientObjectException(\"Collection was not yet persistent\");\n        }\n        else {\n            coll = getArrayHolder(collection);\n            if (coll==null) {\n                //it might be an unwrapped collection reference!\n                //try to find a wrapper (slowish)\n                Iterator wrappers = IdentityMap.keyIterator(collectionEntries);\n                while ( wrappers.hasNext() ) {\n                    PersistentCollection pc = (PersistentCollection) wrappers.next();\n                    if ( pc.isWrapper(collection) ) {\n                        coll=pc;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return (coll==null) ? null : getCollectionEntry(coll);\n\n    }\n",
    "7828": "    public void evict(Object object) throws HibernateException {\n        if (object instanceof HibernateProxy) {\n            LazyInitializer li = HibernateProxyHelper.getLazyInitializer( (HibernateProxy) object );\n            Serializable id = li.getIdentifier();\n            ClassPersister persister = getClassPersister( li.getPersistentClass() );\n            Key key = new Key(id, persister);\n            proxiesByKey.remove(key);\n            if ( !li.isUninitialized() ) {\n                Object entity = removeEntity(key);\n                if (entity!=null) {\n                    EntityEntry e = removeEntry(entity);\n                    doEvict(e.persister, entity);\n                }\n            }\n        }\n        else {\n            EntityEntry e = removeEntry(object);\n            if (e!=null) {\n                removeEntity( new Key(e.id, e.persister) );\n                doEvict(e.persister, object);\n            }\n        }\n    }\n",
    "7938": "    private void evictCachedCollections(ClassPersister persister, Serializable id) throws HibernateException {\n        evictCachedCollections( persister.getPropertyTypes(), id );\n    }\n",
    "12961": "\tpublic void ejbCreate() throws CreateException {\n\t\t// TODO Auto-generated method stub\n\t}\n",
    "29877": "    public void setCodeset(String codeset) {\n        this.codeset = codeset;\n    }\n",
    "29883": "    public String getCodeset() {\n        return codeset;\n    }\n",
    "29887": "    public XMLDocument addStylesheet(String href, String type) {\n        PI pi = new PI();\n        pi.setTarget(\"xml-stylesheet\")\n          .addInstruction(\"href\", href)\n          .addInstruction(\"type\", type);\n        prolog.addElement(pi);\n        \n        return(this);\n    }\n",
    "29892": "    public XMLDocument addStylesheet(String href) {\n        return addStylesheet(href, \"text/xsl\");\n    }\n",
    "29897": "    public XMLDocument addToProlog(ConcreteElement element) {\n        prolog.addElement(element);\n        return(this);\n    }\n",
    "29900": "    public XMLDocument addElement(XML element) {\n        if (content == null)\n            content = element;\n        else\n            content.addElement(element);\n            \n        return(this);\n    }\n",
    "29906": "    public void output(OutputStream out)\n    {        \n        /** \n         * FIXME: The other part of the version hack!\n         *   Add the version declaration to the beginning of the document.\n         */\n        try {\n            out.write(versionDecl.getBytes());\n        } catch (Exception e) { }\n        \n        for (int i=0; i<prolog.size(); i++) {\n            ConcreteElement e = (ConcreteElement)prolog.elementAt(i);\n            e.output(out);\n        }\n         \n        if (content != null)\n            content.output(out);\n    }\n",
    "29909": "    public PI addInstruction(String name, String value) {\n        addAttribute(name, value);\n        return(this);\n    }\n",
    "29916": "    public Object clone() {\n        return content.clone();\n    }\n",
    "29941": "    public String process(String to_process)\n    {   System.out.println(\"\\nString to Process in StringFilter = \"+to_process);\n        String[] value = split(to_process);\n        StringBuffer new_value = new StringBuffer();\n        for(int x = 0; x < value.length; x++)\n        {\n            if(hasAttribute(value[x]))\n                new_value.append((String)get(value[x]));\n            else\n                new_value.append(value[x]);\n            if(x != value.length - 1)\n                new_value.append(\" \");\n        }\n        return(new_value.toString());\n    }\n",
    "30502": "\tpublic CToggleButton () {\n\t\tthis(null, null, false);\n\t}\n",
    "30504": "\tpublic CToggleButton (String text) {\n\t\tthis(text, null, false);\n\t}\n",
    "30508": "\tpublic CToggleButton (String text, boolean selected) {\n\t\tthis(text, null, selected);\n\t}\n",
    "42686": "\tpublic MQuery (int AD_Table_ID)\n\t{\t//\tUse Client Context as r/o\n\t\tm_TableName = M_Table.getTableName (Env.getCtx(), AD_Table_ID);\n\t}\t//\tMQuery\n",
    "63167": "\n\tprotected String checkOptions()\t{ return null; }\n",
    "64598": "    public void initialize() {\n    }\n",
    "64614": "    public int getInitialFirstRowHeight() {\n    \treturn -1;\n    }\n",
    "64625": "    public void setFirstRowHeight(int value) {\n        setRowHeight(0, value);\n    }\n",
    "64630": "    public Object getContentAt(int col, int row) {\n        return doGetContentAt(col, row);\n    }\n",
    "64634": "    public String getTooltipAt(int col, int row) {\n        return doGetTooltipAt(col, row);\n    }\n",
    "64639": "    public String doGetTooltipAt(int col, int row) {\n        return null;\n    }\n",
    "64645": "    public KTableCellEditor getCellEditor(int col, int row) {\n        return doGetCellEditor(col, row);\n    }\n",
    "64662": "    public void setContentAt(int col, int row, Object value) {\n        doSetContentAt(col, row, value);\n        for (int i = 0; i < modelChangeListeners.size(); i++) {\n        \tModelChangeListener listener = (ModelChangeListener)modelChangeListeners.get(i);\n        \tlistener.modelChanged(col, row, value);\n        }\n    }\n",
    "64674": "    public boolean isFixedCell(int col, int row) {\n        return col < getFixedColumnCount()\n        || row < getFixedRowCount();\n    }\n",
    "64698": "\tprotected void onTraverse(TraverseEvent e) {\n\t    if (e.keyCode == SWT.ARROW_LEFT) {\n\t        if (m_Text.getCaretPosition()==0 && m_Text.getSelectionCount()==0)\n\t            super.onTraverse(e);\n\t        // handel the event within the text widget!\n\t    } else if (e.keyCode == SWT.ARROW_RIGHT) {\n\t        if (m_Text.getCaretPosition()==m_Text.getText().length() && m_Text.getSelectionCount()==0)\n\t            super.onTraverse(e);\n\t        // handle the event within the text widget!\n\t    } else\n\t        super.onTraverse(e);\n\t}\n",
    "64712": "    private boolean isValidHAlignment(int align) {\n        if (align==SWTX.ALIGN_HORIZONTAL_CENTER || \n            align==SWTX.ALIGN_HORIZONTAL_LEFT  || \n            align==SWTX.ALIGN_HORIZONTAL_RIGHT)\n            return true;\n        return false;\n    }\n",
    "64715": "    private boolean isValidVAlignment(int align) {\n        if (align==SWTX.ALIGN_VERTICAL_TOP || \n            align==SWTX.ALIGN_VERTICAL_CENTER  || \n            align==SWTX.ALIGN_VERTICAL_BOTTOM)\n            return true;\n        return false;\n    }\n",
    "64719": "\tpublic void close(boolean save) {\n\t\tsuper.close(save);\n\t\tm_Dialog = null;\n\t}\n",
    "64722": "    public Point belongsToCell(int col, int row) {\n        return doBelongsToCell(col, row);\n    }\n",
    "64723": "\tpublic void setBounds(Rectangle rect) {\n\t    // ignored.\n\t}\n",
    "64727": "    protected Control createControl() {\n        return null;\n    }\n",
    "64733": "    public Point doBelongsToCell(int col, int row) {\n        return new Point(col, row);\n    }\n",
    "64735": "\tpublic void open(KTable table, int col, int row, Rectangle rect) {\n\t\tm_Table = table;\n\t\tm_Model = table.getModel();\n\t\tm_Rect = rect;\n\t\tm_Row = row;\n\t\tm_Col = col;\n\t\t\n\t\tclose(true);\n\t\t\n\t\tGC gc = new GC(m_Table);\n\t\tm_Table.updateCell(m_Col, m_Row);\n\t\tgc.dispose();\n\t}\n",
    "64737": "\tpublic void close(boolean save) {\n\t    if (save) {\n\t        Object o = m_Model.getContentAt(m_Col, m_Row);\n\t        if (!(o instanceof Boolean))\n\t            throw new ClassCastException(\"CheckboxCellEditor needs a Boolean content!\");\n\t        \n\t        boolean newVal = !((Boolean)o).booleanValue();\n\t        \n\t        m_Model.setContentAt(m_Col, m_Row, new Boolean(newVal));\n\t    }\n\t    super.close(save);\n\t}\n",
    "64743": "    public void setContent(Object content) {\n    }\n",
    "64744": "    public int mapRowIndexToModel(int shownRow) {\n        return shownRow;\n    }\n",
    "64749": "    public void setColumnToCompare(int column) {\n        //if (row>=m_Model.getFixedRowCount())\n        //    throw new IllegalArgumentException(\"An invalid column index was given!\");\n        \n        m_ColIndex=column;\n    }\n",
    "64752": "    public int mapRowIndexToTable(int modelRow) {\n    \treturn modelRow;\n    }\n",
    "64754": "\tpublic void cellDoubleClicked(int col, int row, int statemask) {\n\t}\n",
    "64757": "\tpublic void fixedCellDoubleClicked(int col, int row, int statemask) {\n\t}\n",
    "64759": "    public void setSortDirection(int direction) {\n    \t if (direction!=SORT_UP && direction!=SORT_DOWN && direction!=SORT_NONE)\n             throw new IllegalArgumentException(\"Undefined sorting direction: \"+direction);\n         \n    \t m_Direction = direction;\n    }\n",
    "64763": "\tpublic void dispose() {\n\t\tif (m_Control != null) {\n\t\t\tControl contr = m_Control;\n\t\t\tm_Control = null;\n\t\t\tcontr.dispose();\n\t\t}\n\t}\n",
    "64768": "    public void setModel(KTableSortedModel model) {\n    \tm_Model = model;\n    }\n",
    "64775": "\tpublic void close(boolean save) {\n\t\tm_Table.m_CellEditor = null;\n\t\t//m_Control.setVisible(false);\n\t\tGC gc = new GC(m_Table);\n\t\tm_Table.drawCell(gc, m_Col, m_Row);\n\t\tgc.dispose();\n\t\tthis.dispose();\n\t\tm_Table.setFocus();\n\t}\n",
    "64776": "    public void sort(KTableSortComparator comparator) {\n        Collections.sort(rowMapping, comparator);\n        \n        m_Ordered = comparator.getSortDirection();\n        \n        if (m_Ordered==KTableSortComparator.SORT_NONE)\n            setSortColumn(-1);\n        else\n            setSortColumn(comparator.getColumnToSortOn());\n    }\n",
    "64777": "\tpublic boolean isFocused() {\n\t\tif (m_Control == null)\n\t\t\treturn false;\n\t\treturn m_Control.isFocusControl();\n\t}\n",
    "64780": "\tpublic void setBounds(Rectangle rect) {\n\t\tif (m_Control != null)\n\t\t\tm_Control.setBounds(rect);\n\t}\n",
    "64784": "    public void setStyle(int style) {\n        m_Style = style;\n    }\n",
    "64786": "    public Object getContentAt(int col, int row) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        return doGetContentAt(valid.x, valid.y);\n    }\n",
    "64789": "    public String getTooltipAt(int col, int row) {\n        row = mapRowIndexToModel(row);\n        Point valid = getValidCell(col, row);\n        return doGetTooltipAt(valid.x, valid.y);\n    }\n",
    "64794": "    public KTableCellEditor getCellEditor(int col, int row) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        return doGetCellEditor(valid.x, valid.y);\n    }\n",
    "64796": "    public void setContentAt(int col, int row, Object value) {\n        row = mapRowIndexToModel(row);\n        // now have to check if the mapped cell is spanned, and if it is, take the\n        // cell that is responsible for the content of the big cell:\n        Point valid = getValidCell(col, row);\n        doSetContentAt(valid.x, valid.y, value);\n    }\n",
    "64800": "    public KTableCellRenderer getCellRenderer(int col, int row) {\n        row = mapRowIndexToModel(row);\n        Point valid = getValidCell(col, row);\n        return doGetCellRenderer(valid.x, valid.y);\n    }\n",
    "64803": "    public Point belongsToCell(int col, int row) {\n        if (getSortState() == KTableSortComparator.SORT_NONE)\n            return doBelongsToCell(col, row);\n        // if sorting is active, all cells get rendered seperately!\n        return new Point(col, row);\n    }\n",
    "64810": "    protected void drawCellButton(GC gc, Rectangle rect, String text, boolean pressed) {\n        rect.height += 1;\n        rect.width += 1;\n        gc.setForeground(Display.getCurrent().getSystemColor(\n                SWT.COLOR_LIST_FOREGROUND));\n        if (pressed) {\n            SWTX.drawButtonDown(gc, \n                    text, getAlignment(),\n                    null, getAlignment(), rect);\n        } else {\n            SWTX.drawButtonUp(gc, \n                    text, getAlignment(),\n                    null, getAlignment(), rect);\n        }\n    }\n",
    "64839": "    private Image mirrorImage(Image source) {\n        Rectangle bounds = source.getBounds();\n        \n        ImageData sourceData = source.getImageData();\n        ImageData resultData = new ImageData(\n                sourceData.height, sourceData.width, \n                sourceData.depth, sourceData.palette);\n        for (int x = 0; x<bounds.width; x++)\n            for (int y=0; y<bounds.height; y++)\n                resultData.setPixel(y, resultData.height-x-1, sourceData.getPixel(x, y));\n        source.dispose();\n        return new Image(Display.getCurrent(), resultData);        \n    }\n",
    "64840": "\tpublic void cellSelected(int col, int row, int statemask) {\n\t}\n",
    "64841": "\tpublic void fixedCellSelected(int col, int row, int statemask) {\n\t}\n",
    "64848": "    protected Rectangle drawDefaultSolidCellLine(GC gc, Rectangle rect, Color vBorderColor, Color hBorderColor) {\n        return BorderPainter.drawDefaultSolidCellLine(gc, rect, vBorderColor, hBorderColor);\n    }\n",
    "64860": "    public void setAlignment(int style) {\n        m_alignment = style;\n    }\n",
    "64885": "    public void setForeground(Color fgcolor) {\n        m_fgColor=fgcolor;\n    }\n",
    "64898": "    public void setDefaultForeground(Color fgcolor) {\n        COLOR_TEXT = fgcolor;\n    }\n",
    "64900": "    public Point doBelongsToCell(int col, int row) {\n        if ((col==2 || col==3)&& !isFixedCell(col, row)) {\n            int newRow = row;\n            if ((row-getFixedRowCount())%2==1)\n                newRow--;\n            return new Point(2, newRow);\n        }\n        return new Point(col,row);\n    }\n",
    "64907": "    public void setBackground(Color bgcolor) {\n        m_bgColor=bgcolor;\n    }\n",
    "64917": "    public void setDefaultBackground(Color bgcolor) {\n        COLOR_BACKGROUND = bgcolor;\n    }\n",
    "64943": "    public void setFont(Font font) {\n        m_font = font;\n    }\n",
    "64959": "    protected void applyFont(GC gc) {\n        m_GCfont = gc.getFont();\n        if (m_font == null)\n            m_font = Display.getCurrent().getSystemFont();\n        if ((m_Style & SWT.BOLD) != 0 || (m_Style & SWT.ITALIC)!=0) {\n            FontData[] fd = m_font.getFontData();\n            int style = SWT.NONE;\n            if ((m_Style & SWT.BOLD)!=0)\n                style |= SWT.BOLD;\n            if ((m_Style & SWT.ITALIC)!=0)\n                style |= SWT.ITALIC;\n            \n            for (int i=0; i<fd.length; i++)\n                fd[i].setStyle(style);\n            m_TMPfont = new Font(Display.getCurrent(), fd);\n            gc.setFont(m_TMPfont);\n        }  else\n            gc.setFont(m_font);\n    }\n",
    "64969": "    protected void resetFont(GC gc) {\n        if (m_TMPfont!=null) {\n            m_TMPfont.dispose();\n            m_TMPfont = null;\n        }\n            \n        gc.setFont(m_GCfont);\n    }\n",
    "64989": "\tpublic Vector getTasks() {\n\t\treturn tasks;\n\t}\n",
    "64991": "\tpublic void addTask() {\n\t\tExampleTask task = new ExampleTask(\"New task\");\n\t\ttasks.add(tasks.size(), task);\n\t\tIterator iterator = taskChangeListeners.iterator();\n\t\twhile (iterator.hasNext())\n\t\t\t((ITaskChangeListener) iterator.next()).taskAdded(task);\n\t}\n",
    "65013": "\tpublic void setCompleted(boolean b) {\n\t\tcompleted = b;\n\t}\n",
    "65014": "\tpublic void setDescription(String string) {\n\t\tdescription = string;\n\t}\n",
    "65017": "\tpublic void setOwner(String string) {\n\t\towner = string;\n\t}\n",
    "65018": "\tpublic void setPercentComplete(int i) {\n\t\tpercentComplete = i;\n\t}\n",
    "65052": "\tprivate void createSashForm() {\n\t\tGridData gridData = new org.eclipse.swt.layout.GridData();\n\t\tgridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData.grabExcessHorizontalSpace = true;\n\t\tgridData.grabExcessVerticalSpace = true;\n\t\tgridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tsashForm = new SashForm(top, SWT.NONE);\n\t\tsashForm.setOrientation(org.eclipse.swt.SWT.VERTICAL);\n\t\tsashForm.setLayoutData(gridData);\n\t\tcreateTopComposite();\n\t\tcreateBottomComposite();\n\t}\n",
    "65053": "\tprivate TrifonTextModelExample getTrifonTextModelExample() {\n\t\tif (trifonTextModelExample == null) {\n\t\t\ttrifonTextModelExample = new TrifonTextModelExample();\n\t\t}\n\t\treturn trifonTextModelExample;\n\t}\n",
    "65055": "\tprivate void createTopComposite() {\n\t\ttopComposite = new Composite(sashForm, SWT.NONE);\n\t\ttopComposite.setLayout(new GridLayout());\n\t\tcreateKTable();\n\t}\n",
    "65057": "\tprivate void createBottomComposite() {\n\t\tbottomComposite = new Composite(sashForm, SWT.NONE);\n\t}\n",
    "65059": "\tprivate void createComposite() {\n\t\tcomposite = new Composite(tabFolder, SWT.NONE);\n\t\tbuttonOne = new Button(composite, SWT.NONE);\n\t\tbuttonOne.setBounds(new org.eclipse.swt.graphics.Rectangle(5,5,12,23));\n\t\tbuttonOne.setText(\"Button One\");\n\t}\n",
    "65060": "\tprivate void createKTable() {\n\t\tGridData gridData1 = new org.eclipse.swt.layout.GridData();\n\t\tgridData1.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData1.grabExcessHorizontalSpace = true;\n\t\tgridData1.grabExcessVerticalSpace = true;\n\t\tgridData1.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tkTable = new KTable(topComposite, SWT.NONE);\n\t\tkTable.setLayoutData(gridData1);\n\t\t\n\t\tkTable.setModel(model);\n\t}\n",
    "65063": "\tprivate void createComposite1() {\n\t\tcompositeTwo = new Composite(tabFolder, SWT.NONE);\n\t\tcreateKTable();\n\t}\n",
    "65066": "\tprivate void createKTable() {\n\t\tkTable = new KTable(compositeTwo, SWT.V_SCROLL | SWT.H_SCROLL \n\t\t\t\t| SWTX.FILL_WITH_LASTCOL\n\t\t\t\t| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important\n\n\t\tkTable.setModel(getTrifonTextModelExample());\n\t\tkTable.setBounds(new org.eclipse.swt.graphics.Rectangle(115,15,77,23));\n\t\t\n\t}\n",
    "65070": "\tprivate void createBottomCTabFolder() {\n\t\tbottomTabFolder = new TabFolder(sashForm, SWT.NONE);\n\t\t\n\t\ttabItemOne = new TabItem(bottomTabFolder, SWT.NONE);\n\t\ttabItemOne.setText(\"Text Table\");\n\t\t\n\t\tComposite comp1 = new Composite(bottomTabFolder, SWT.NONE);\n\t\ttabItemOne.setControl(comp1);\n\t\tcomp1.setLayout(new FillLayout());\n\t\ttabOneKTable = new KTable(comp1, SWT.V_SCROLL | SWT.H_SCROLL \n\t\t\t\t| SWTX.FILL_WITH_LASTCOL\n\t\t\t\t| SWTX.EDIT_ON_KEY | SWT.MULTI | SWTX.MARK_FOCUS_HEADERS ); // @Trifon important\n\t\t\n\t}\n",
    "65108": "\tpublic boolean isSurveyant() {\n\t\treturn this.level == OutlawUser.LEVEL_NOBODY;\n\t}\n",
    "65110": "\tpublic Condition getPostCondition() {\n\t\treturn this.postCondition;\n\t}\n",
    "65112": "\tpublic void setContent(List<PersistentObject> list) {\n\t\tthis.content = list;\n\t}\n",
    "65113": "\tprivate void createTabFolder() {\n\t\tGridData gridData = new org.eclipse.swt.layout.GridData();\n\t\tgridData.horizontalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\tgridData.grabExcessHorizontalSpace = true;\n\t\tgridData.grabExcessVerticalSpace = true;\n\t\tgridData.verticalAlignment = org.eclipse.swt.layout.GridData.FILL;\n\t\ttabFolder = new TabFolder(top, SWT.NONE);\n\t\ttabFolder.setLayoutData(gridData);\n\t}\n",
    "65115": "\tpublic String getFilename() {\n\t\treturn this.filename;\n\t}\n",
    "65117": "\tpublic void setFilename(final String string) {\n\t\tthis.filename = string;\n\t}\n",
    "65118": "\tpublic void setImage(byte[] data) {\n\t\tthis.data = data;\n\t}\n",
    "65119": "\tpublic boolean isUser() {\n\t\treturn this.level == OutlawUser.LEVEL_USER;\n\t}\n",
    "65128": "\tpublic boolean isAdmin() {\n\t\treturn this.level == OutlawUser.LEVEL_ADMIN;\n\t}\n",
    "65132": "\tpublic String getText() {\n\t\treturn this.text;\n\t}\n",
    "65135": "\tpublic int getLayout() {\n\t\treturn this.layout;\n\t}\n",
    "65138": "\tpublic void setText(final String string) {\n\t\tthis.text = string;\n\t}\n",
    "65141": "\tpublic void setLayout(final int theLayout) {\n\t\tthis.layout = theLayout;\n\t}\n",
    "65144": "\tpublic String getTextPreview() {\n\t\tString retVal;\n\n\t\tif (this.text.length() > 120) {\n\t\t\tretVal = this.text.substring(0, 60);\n\t\t\tretVal += \"...\";\n\t\t\tretVal += this.text.substring(this.text.length() - 60 - 1, this.text.length() - 1);\n\t\t} else {\n\t\t\tretVal = this.text;\n\t\t}\n\n\t\treturn retVal;\n\t}\n",
    "65147": "\tpublic Date getCdate() {\n\t\treturn this.cdate;\n\t}\n",
    "65150": "\tpublic Date getEdate() {\n\t\treturn this.edate;\n\t}\n",
    "65151": "\tpublic Date getSdate() {\n\t\treturn this.sdate;\n\t}\n",
    "65155": "\tpublic int getState() {\n\t\treturn this.state;\n\t}\n",
    "65158": "\tpublic Survey getSurvey() {\n\t\treturn this.survey;\n\t}\n",
    "65162": "\tpublic void setCdate(final Date date) {\n\t\tthis.cdate = date;\n\t}\n",
    "65165": "\tpublic void setEdate(final Date date) {\n\t\tthis.edate = date;\n\t}\n",
    "65168": "\tpublic void setSdate(final Date date) {\n\t\tthis.sdate = date;\n\t}\n",
    "65171": "\tpublic void setState(final int theState) {\n\t\tthis.state = theState;\n\t}\n",
    "65175": "\tpublic void setSurvey(final Survey theSurvey) {\n\t\tthis.survey = theSurvey;\n\t}\n",
    "65212": "\tpublic int getQuestionLayout() {\n\t\treturn this.questionLayout;\n\t}\n",
    "65220": "\tpublic int getAnswerLayout() {\n\t\treturn this.answerLayout;\n\t}\n",
    "65353": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalGroupPrincipal))\n            return false;\n\n        InternalGroupPrincipal r = (InternalGroupPrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65370": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalRolePrincipal))\n            return false;\n\n        InternalRolePrincipal r = (InternalRolePrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65394": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalUserPrincipal))\n            return false;\n\n        InternalUserPrincipal r = (InternalUserPrincipal) object;\n        boolean isEqual = (r.getFullPath().equals(this.getFullPath()));\n        return isEqual;\n    }\n",
    "65424": "    public boolean equals(Object object)\n    {  \n        if (!(object instanceof InternalCredential))\n            return false;\n\n        InternalCredential c = (InternalCredential) object;\n        boolean isEqual = ((c.getValue().equals(this.getValue())) && (c.getType() == this.getType()) && ((null == c.getClassname()) || (c.getClassname().equals(this.getClassname()))));\n        return isEqual;\n    }\n",
    "65427": "    public String getSystemRoot()\n    {        \n        return \"/\";\n    }\n",
    "65555": "    public List retrieveOptions(Object command, Object context) {\n        if (getRefreshPropertyAsBoolean(command)) {\n            return chainedOption.retrieveOptions(command, context);\n        } else {\n            return new LinkedList();\n        }\n    }\n",
    "65556": "    protected LabelValueBean convertBean(Object object) {\n        String string = (String) object;\n        return new LabelValueBean(string, string);\n    }\n",
    "65558": "    public List adjustAndSort(List options, Object context) {\n        return options;\n    }\n",
    "65559": "    public void updateValue(Object command, List options, Object context) {\n        if (getRefreshPropertyAsBoolean(command)) {\n            chainedOption.updateValue(command, options, context);\n        }\n    }\n",
    "65561": "    public String getDefaultValue(List options, Object context) {\n        if (options.size() > 0) {\n            LabelValueBean bean = (LabelValueBean) options.get(0);\n            return bean.getValue();\n        } else {\n            return \"\";\n        }\n    }\n",
    "65569": "    public void setExtraItems(List extraItems) {\n        this.extraItems = extraItems;\n    }\n",
    "65570": "    public String getOptionsKey() {\n        return chainedOption.getOptionsKey();\n    }\n",
    "65574": "    public void setChainedOption(ChainedOption chainedOption) {\n        this.chainedOption = chainedOption;\n    }\n",
    "65581": "    public void setRefreshProperty(String refreshProperty) {\n        this.refreshProperty = refreshProperty;\n    }\n",
    "65582": "    public void setOptions(List options) {\n        this.options = options;\n    }\n",
    "65584": "    public List adjustAndSort(List options, Object context) {\n        LinkedList result = new LinkedList();\n        result.addAll(options);\n        Collections.sort(result);\n        return result;\n    }\n",
    "65588": "    public List convert(List beans) {\n        List retval = new ArrayList(beans.size());\n        for (Iterator iter = beans.iterator(); iter.hasNext();) {\n            LabelValueBean bean = convertBean(iter.next());\n            retval.add(bean);\n        }\n\n        return retval;\n    }\n",
    "65589": "    public void referenceData(Map model, Object command, Object context) {\n        for (Iterator iter = chainedOptions.iterator(); iter.hasNext();) {\n            ChainedOption chainedOption = (ChainedOption) iter.next();\n            List options = chainedOption.retrieveOptions(command, context);\n            model.put(chainedOption.getOptionsKey(), options);\n            chainedOption.updateValue(command, options, context);\n        }\n    }\n",
    "65590": "    public ChainedOptionStrategy getStrategy(Object command) {\n        return chainedOption.getStrategy(command);\n    }\n",
    "65600": "    public void updateValue(Object command, List options, Object context) {\n        String selectedValue = getProperty(command, getCommandProperty());\n\n        for (Iterator iter = options.iterator(); iter.hasNext();) {\n            if (matches((LabelValueBean) iter.next(), selectedValue)) {\n                return;\n            }\n        }\n\n        setProperty(command, getCommandProperty(), getStrategy(command)\n                .getDefaultValue(options, context));\n    }\n",
    "65607": "    protected boolean matches(LabelValueBean bean, String value) {\n        if (value == null) {\n            return false;\n        }\n        String beanValue = ((LabelValueBean) bean).getValue();\n        return StringUtils.equals(beanValue, value);\n    }\n",
    "65615": "    protected void initChainedOption() {\n    }\n",
    "65625": "    protected void setProperty(Object bean, String propertyName, Object value) {\n        BeanWrapper commandWrapper = new BeanWrapperImpl(bean);\n        commandWrapper.setPropertyValue(new PropertyValue(propertyName, value));\n    }\n",
    "65640": "    public void setCommandProperty(String commandProperty) {\n        this.commandProperty = commandProperty;\n    }\n",
    "65653": "    public void setOptionsKey(String optionsKey) {\n        this.optionsKey = optionsKey;\n    }\n",
    "65665": "    public void setConverter(BeanConverter converter) {\n        this.converter = converter;\n    }\n",
    "65667": "    public void testUpdateValue_valueExists() {\n        SomeCommand someCommand = new SomeCommand();\n        someCommand.setRegion(\"EU\");\n\n        final LabelValueBean expected = new LabelValueBean(\"a\", \"b\");\n        AbstractChainedOption tested = new AbstractChainedOption() {\n\n            public List retrieveOptions(Object command, Object context) {\n                return null;\n            }\n\n            protected boolean matches(LabelValueBean bean, String value) {\n                assertSame(expected, bean);\n                return true;\n            }\n\n            public ChainedOptionStrategy getStrategy(Object command) {\n                return strategyMock;\n            }\n        };\n\n        tested.setCommandProperty(\"region\");\n\n        tested.updateValue(someCommand, Collections.singletonList(expected),\n                null);\n\n        assertEquals(\"EU\", someCommand.getRegion());\n    }\n",
    "65674": "    public ChainedOptionStrategy getStrategy(Object command) {\n        return defaultStrategy;\n    }\n",
    "65683": "    public void setDefaultStrategy(ChainedOptionStrategy defaultStrategy) {\n        this.defaultStrategy = defaultStrategy;\n    }\n",
    "65802": "    @Override protected void startup() {\n        show(new VisualJBusinessView(this));\n    }\n",
    "65803": "    @Override protected void configureWindow(java.awt.Window root) {\n    }\n",
    "65809": "    public Database getDatabase() {\n        return this.database;\n    }\n",
    "65811": "    public void setDatabase(Database database) {\n        this.database = database;\n    }\n",
    "65812": "     public Table getChoosenTableByName(String name) {\n        Table table = null, target = null;\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(name)) {\n                return target;\n            }\n        }\n        return table;\n    }\n",
    "65813": "     public Table getChoosenTableHlsHead(Table table) {\n        Table target = null;\n        if (table.getHlsHead().equals(\"\")) {\n            // there is no head\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(table.getHlsHead())) {\n                // head found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65815": "    public Table getChoosenTableHlsLines(Table table) {\n        Table target = null;\n        if (table.getHlsLines().equals(\"\")) {\n            // there is no lines\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(table.getHlsLines())) {\n                // lines found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65817": "    public Table getColumnFkTable(Column column) {\n        Table target = null;\n        if (column.getFkTable().equals(\"\")) {\n            // there is no fkTable\n            return (Table) null;\n        }\n        Tables choosenTables = getDatabase().getChoosenTables();\n        for (int i = 0; i < choosenTables.getSize(); i++) {\n            target = (Table) choosenTables.getElementAt(i);\n            if (target.getName().equalsIgnoreCase(column.getFkTable())) {\n                // fkTable found\n                return target;\n            }\n        }\n        return (Table) null;\n    }\n",
    "65844": "    public String getSecurityPath() {\n        return securityPath;\n    }\n",
    "65845": "    public void setSecurityPath(String securityPath) {\n        securityPath = securityPath.toLowerCase().trim();\n        if(!securityPath.equals(\"\")) {\n            //securityPath.replaceAll(\"\\\\\", \"/\");\n            securityPath.replaceAll(\".\", \"/\");\n            securityPath.replaceAll(\" \", \"\");\n            if(securityPath.startsWith(\"/\")) {\n                securityPath = securityPath.substring(1);\n            }\n            if(!securityPath.endsWith(\"/\")) {\n                securityPath = securityPath + \"/\";\n            }\n        }\n        this.securityPath = securityPath;\n    }\n",
    "65874": "    protected Rectangle getCellRectIgnoreSpan(int col, int row) {\n        return getCellRectIgnoreSpan(col, row, getColumnLeft(col) + 1);\n    }\n",
    "65967": "    public String getTableName() {\n        return tableName;\n    }\n",
    "65968": "    public MenuVJB getMenuVJB() {\n        return menuVJB;\n    }\n",
    "65969": "    public void setTableName(String tableName) {\n        this.tableName = tableName;\n    }\n",
    "65970": "    public void setMenuVJB(MenuVJB menuVJB) {\n        this.menuVJB = menuVJB;\n    }\n",
    "65975": "    public String getTitleOfMenuOfItemsVJB() {\n        return titleOfMenuOfItemsVJB;\n    }\n",
    "65977": "    public void setTitleOfMenuOfItemsVJB(String titleOfMenuOfItemsVJB) {\n        this.titleOfMenuOfItemsVJB = titleOfMenuOfItemsVJB;\n    }\n",
    "65978": "    public boolean isMenuOfItemsSetted() {\n        return menuOfItemsSetted;\n    }\n",
    "65980": "    public void setMenuOfItemsSetted(boolean menuOfItemsSetted) {\n        this.menuOfItemsSetted = menuOfItemsSetted;\n    }\n",
    "65981": "    public MenuBarVJB getMenuBarVJB() {\n        return menuBarVJB;\n    }\n",
    "65983": "    public void setMenuBarVJB(MenuBarVJB menuBarVJB) {\n        this.menuBarVJB = menuBarVJB;\n    }\n",
    "65987": "    public boolean isAddNewMenuBar() {\n        return addNewMenuBar;\n    }\n",
    "65990": "    public void setAddNewMenuBar(boolean addNewMenuBar) {\n        this.addNewMenuBar = addNewMenuBar;\n    }\n",
    "66004": "    public Table getSelectedTable() {\n        return selectedTable;\n    }\n",
    "66005": "    public MenuOfBarVJB getMenuOfBarVJB() {\n        return menuOfBarVJB;\n    }\n",
    "66006": "    public void setSelectedTable(Table selectedTable) {\n        this.selectedTable = selectedTable;\n    }\n",
    "66007": "    public void setMenuOfBarVJB(MenuOfBarVJB menuOfBarVJB) {\n        this.menuOfBarVJB = menuOfBarVJB;\n    }\n",
    "66008": "    public boolean isTargetClassSelected() {\n        return targetClassSelected;\n    }\n",
    "66010": "    public void setTargetClassSelected(boolean targetClassSelected) {\n        this.targetClassSelected = targetClassSelected;\n    }\n",
    "66022": "    public String getMenuTitle() {\n        return menuTitle;\n    }\n",
    "66026": "    public void setMenuTitle(String menuTitle) {\n        this.menuTitle = menuTitle;\n    }\n",
    "66028": "    public int getMenuVJBType() {\n        return menuVJBType;\n    }\n",
    "66030": "    public void setMenuVJBType(int menuVJBType) {\n        this.menuVJBType = menuVJBType;\n    }\n",
    "66031": "    public boolean isCreateNewMenuBar() {\n        return createNewMenuBar;\n    }\n",
    "66032": "    public boolean isSelected() {\n        return selected;\n    }\n",
    "66033": "    public void setCreateNewMenuBar(boolean createNewMenuBar) {\n        this.createNewMenuBar = createNewMenuBar;\n    }\n",
    "66035": "    public void setSelected(boolean selected) {\n        this.selected = selected;\n    }\n",
    "66041": "    public String getMenuBarVJBName() {\n        return menuBarVJBName;\n    }\n",
    "66042": "    public void setMenuBarVJBName(String menuBarVJBName) {\n        this.menuBarVJBName = menuBarVJBName;\n    }\n",
    "66048": "    public void setMenuItemVJBList(ArrayList<MenuItemVJB> menuItemVJBList) {\n        this.menuItemVJBList = menuItemVJBList;\n    }\n",
    "66053": "    public void setMenuVJBList(ArrayList<MenuVJB> menuVJBList) {\n        this.menuVJBList = menuVJBList;\n    }\n",
    "66063": "    public void setMenusBarVJB(ArrayList<MenuBarVJB> menusBarVJB) {\n        this.menusBarVJB = menusBarVJB;\n    }\n",
    "66132": "    private String testDropTarget(TreePath destination, TreePath dropper) {\n        //Typical Tests for dropping\n\n        //Test 1.\n        boolean destinationPathIsNull = destination == null;\n        if (destinationPathIsNull) {\n            return \"Invalid drop location.\";\n        }\n\n        //Test 2.\n        MenuNode node = (MenuNode) destination.getLastPathComponent();\n        if (!node.getAllowsChildren()) {\n            return \"This node does not allow children\";\n        }\n\n        if (destination.equals(dropper)) {\n            return \"Destination cannot be same as source\";\n        }\n\n        //Test 3.\n        if (dropper.isDescendant(destination)) {\n            return \"Destination node cannot be a descendant.\";\n        }\n\n        //Test 4.\n        if (dropper.getParentPath().equals(destination)) {\n            return \"Destination node cannot be a parent.\";\n        }\n\n        return null;\n    }\n",
    "66171": "    public void redraw(Rectangle cellsToRedraw) {\n        checkWidget();\n        redraw(cellsToRedraw.x, cellsToRedraw.y, cellsToRedraw.width,\n                cellsToRedraw.height);\n    }\n",
    "66199": "    protected void drawCell(GC gc, int col, int row) {\n        \n        drawCell(gc, col, row, getCellRect(col, row));\n        \n        Rectangle oldClip = gc.getClipping();\n        gc.setClipping(getClientArea());\n        if ((getStyle() & SWTX.MARK_FOCUS_HEADERS)==SWTX.MARK_FOCUS_HEADERS) {\n            if (row>=m_TopRow) {\n                for (int i=0; i<m_Model.getFixedHeaderColumnCount(); i++)\n                    drawCell(gc, i, row, getCellRect(i, row));\n                for (int i=0; i<m_Model.getFixedHeaderRowCount(); i++)\n                    drawCell(gc, col, i, getCellRect(col, i));\n            }\n        }\n        gc.setClipping(oldClip);\n    }\n",
    "66227": "    public String getDateMask() {\n        return dateMask;\n    }\n",
    "66229": "    public void setDateMask(String dateMask) {\n        this.dateMask = dateMask;\n    }\n",
    "66231": "    public void updateCell(int col, int row) {\n        checkWidget();\n        if ((row < 0) || (row >= m_Model.getRowCount()) || \n            (col < 0) || (col >= m_Model.getColumnCount()))\n            return;\n\n        // be sure it is a valid cell if cells span \n        Point valid = getValidCell(col, row);\n        // update it:\n        GC gc = new GC(this);\n        drawCell(gc, valid.x, valid.y);\n        gc.dispose();\n    }\n",
    "66237": "    public JPanel getSelectedPanel() {\n        return selectedPanel;\n    }\n",
    "66238": "    public void setSelectedPanel(JPanel selectedPanel) {\n        this.selectedPanel = selectedPanel;\n    }\n",
    "66270": "    @Override protected void startup() {\n        show(new HotdogView(this));\n    }\n",
    "66273": "    public boolean isUfRecordSelected() {\n        return ufTable.getSelectedRow() != -1;\n    }\n",
    "66284": "    public boolean isSaveFired() {\n        return saveFired;\n    }\n",
    "66285": "    public void setSaveFired(boolean saveFired) {\n        this.saveFired = saveFired;\n    }\n",
    "66286": "    public Cliente getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66288": "    public void setCurrentRecord(Cliente currentRecord) {\n        Cliente oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66297": "    public boolean isCidadeRecordSelected() {\n        return cidadeTable.getSelectedRow() != -1;\n    }\n",
    "66300": "    public void setDefaultCursor(Cursor cursor, Point size_below_hotspot) {\n        checkWidget();\n        if (m_defaultCursor != null)\n            m_defaultCursor.dispose();\n        m_defaultCursor = cursor;\n        m_defaultCursorSize = size_below_hotspot;\n        setCursor(cursor);\n    }\n",
    "66305": "    public Animal getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66306": "    public void setCurrentRecord(Animal currentRecord) {\n        Animal oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66323": "    public Hospedagem getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66324": "    public void setCurrentRecord(Hospedagem currentRecord) {\n        Hospedagem oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n        if(this.currentRecord == null) {\n            Logger.getLogger(this.getClass().getName()).\n                warning(\"this.current record is null!\");\n        }\n        Logger.getLogger(this.getClass().getName()).\n                info(\"setCurrentRecord method, diaria value : \" + this.currentRecord.getDiaria());\n    }\n",
    "66330": "    public boolean isAnimalRecordSelected() {\n        return animalTable.getSelectedRow() != -1;\n    }\n",
    "66341": "    public Cidade getCurrentRecord() {\n        return currentRecord;\n    }\n",
    "66342": "    public void setCurrentRecord(Cidade currentRecord) {\n        Cidade oldRecord = this.currentRecord;\n        this.currentRecord = currentRecord;\n        propertyChangeSupport.firePropertyChange(\"currentRecord\",\n                oldRecord, currentRecord);\n    }\n",
    "66379": "    public boolean isClienteRecordSelected() {\n        return clienteTable.getSelectedRow() != -1;\n    }\n",
    "66438": "    public boolean isHospedagemRecordSelected() {\n        return hospedagemTable.getSelectedRow() != -1;\n    }\n",
    "66452": "    public Double getDesconto() {\n        return desconto;\n    }\n",
    "66453": "    public void setDesconto(Double desconto) {\n        this.desconto = desconto;\n    }\n",
    "66455": "    public Double getDiaria() {\n        return diaria;\n    }\n",
    "66456": "    public void setDiaria(Double diaria) {\n        this.diaria = diaria;\n    }\n",
    "66459": "    public Date getFim() {\n        return fim;\n    }\n",
    "66461": "    public void setFim(Date fim) {\n        this.fim = fim;\n    }\n",
    "66462": "    public Date getInicio() {\n        return inicio;\n    }\n",
    "66464": "    public void setInicio(Date inicio) {\n        this.inicio = inicio;\n    }\n",
    "66465": "    public Animal getAnimal() {\n        return animal;\n    }\n",
    "66467": "    public void setAnimal(Animal animal) {\n        this.animal = animal;\n    }\n",
    "66477": "    protected Point checkIfMatchesInColumns(int startRow, int endRow, int startCol, int endCol, Point toFind, boolean span) {\n        \n        for (int row = startRow; row < endRow; row++) {\n            for (int col = startCol; col < endCol; col++) {\n                \n                Rectangle rect = getCellRectIgnoreSpan(col, row);\n                // take into account the 1px right and bottom border\n                rect.width+=1;\n                rect.height+=1;\n                if (rect.contains(toFind))\n                    if (span)\n                    // take into account the spanning when reporting a match:\n                        return getValidCell(col, row);\n                    else\n                        return new Point(col, row);\n            }\n        }\n        return null;\n    }\n",
    "66478": "    public void setPlayers(ArrayList<PlayerThread> players) {\n        this.players = players;\n    }\n",
    "66535": "    public int getType() {\n        return type;\n    }\n",
    "66537": "    public void setType(int type) {\n        this.type = type;\n    }\n",
    "66570": "    public String getPlayerName() {\n        return playerName;\n    }\n",
    "66571": "    public void setPlayerName(String playerName) {\n        this.playerName = playerName;\n    }\n",
    "66572": "    public Integer getServerPort() {\n        return serverPort;\n    }\n",
    "66573": "    public void setServerPort(Integer serverPort) {\n        this.serverPort = serverPort;\n    }\n",
    "66575": "    public String getServerIP() {\n        return serverIP;\n    }\n",
    "66577": "    public void setServerIP(String serverIP) {\n        this.serverIP = serverIP;\n    }\n",
    "66585": "    public KeyframeController getKeyframeController() {\n        return keyframeController;\n    }\n",
    "66587": "    public void setKeyframeController(KeyframeController keyframeController) {\n        this.keyframeController = keyframeController;\n    }\n",
    "66588": "    public Node getNode() {\n        return node;\n    }\n",
    "66590": "    public void setNode(Node node) {\n        this.node = node;\n    }\n",
    "66607": "    public void setModelAnimationsList(List<ModelAnimation> modelAnimationsList) {\n        this.modelAnimationsList = modelAnimationsList;\n    }\n",
    "66609": "    public ModelAnimation getBaseAnimation() {\n        return baseAnimation;\n    }\n",
    "66611": "    public void setBaseAnimation(ModelAnimation baseAnimation) {\n        this.baseAnimation = baseAnimation;\n    }\n",
    "66612": "    public ModelAnimation getRunAnimation() {\n        return runAnimation;\n    }\n",
    "66614": "    public void setRunAnimation(ModelAnimation runAnimation) {\n        this.runAnimation = runAnimation;\n    }\n",
    "66632": "    private void buildInput() {\n        input = new ChaseDoomHandler(player.getNode(), properties.getRenderer());\n        mouse = new RelativeMouse(\"Mouse Input\");\n        mouse.registerWithInputHandler(input);\n\tmouse.setCullMode(Spatial.CULL_ALWAYS);\n        URL cursorFile = null;\n        try {\n            cursorFile = new File(\"model\", \"cursor1.png\").toURI().toURL();\n        } catch (MalformedURLException ex) {\n            Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        MouseInput.get().setHardwareCursor(cursorFile);\n    }\n",
    "66638": "    public int getBeginFrame() {\n        return beginFrame;\n    }\n",
    "66639": "    public void setBeginFrame(int beginFrame) {\n        this.beginFrame = beginFrame;\n    }\n",
    "66640": "    public int getEndFrame() {\n        return endFrame;\n    }\n",
    "66641": "    public void setEndFrame(int endFrame) {\n        this.endFrame = endFrame;\n    }\n",
    "66642": "    public boolean isAnimating() {\n        return animating;\n    }\n",
    "66643": "    public void setAnimating(boolean animating) {\n        this.animating = animating;\n    }\n",
    "66644": "    public void setKeys(List<Integer> keys) {\n        if (this.getKeys().size()>0) {\n            this.getKeys().clear();\n        }\n        this.getKeys().addAll(keys);\n    }\n",
    "66647": "    public boolean isEnabled() {\n\n        return enabled;\n    }\n",
    "66649": "    public void setEnabled(boolean enabled) {\n\n        this.enabled = enabled;\n\n        if (enabled) {\n            setCullMode(CULL_DYNAMIC);\n        } else {\n            setCullMode(CULL_ALWAYS);\n        }\n    }\n",
    "66650": "    public void setColor(ColorRGBA color) {\n\n        this.color = color;\n\n        text2D.setTextColor(color);\n    }\n",
    "66651": "    public void setOffset(Vector3f offset) {\n\n        this.offset = offset;\n    }\n",
    "66652": "    public void setText(String text) {\n\n        text2D.setText(text);\n    }\n",
    "66656": "    public void setHorizontalAlignment(int align) {\n\n        if (align == HA_LEFT) {\n            alignOffset = 0;\n        } else if (align == HA_CENTER) {\n            alignOffset = (text2D.getWidth() / 2) * -1;\n        } else if (align == HA_RIGHT) {\n            alignOffset = text2D.getWidth() * -1;\n        }\n\n        alignOffset = alignOffset * getLocalScale().x;\n    }\n",
    "66658": "    public void setVerticalAlignment(int valign) {\n\n        if (valign == VA_TOP) {\n            valignOffset = 0;\n        } else if (valign == VA_MIDDLE) {\n            valignOffset = (text2D.getHeight() / 2) * -1;\n        } else if (valign == VA_BOTTOM) {\n            valignOffset = text2D.getHeight() * -1;\n        }\n\n        valignOffset = valignOffset * getLocalScale().y;\n    }\n",
    "66661": "    public boolean isEditorOutcomeSave() {\n        return editorOutcomeSave;\n    }\n",
    "66663": "    public void setEditorOutcomeSave(boolean editorOutcomeSave) {\n        this.editorOutcomeSave = editorOutcomeSave;\n    }\n",
    "66720": "    public void setToolTipText(String tooltip) {\n        m_nativTooltip = tooltip;\n    }\n",
    "66734": "    public String getToolTipText() {\n        return m_nativTooltip;\n    }\n",
    "66811": "    public void openEditorInFocus(KTableCellEditor cellEditor) {\n        checkWidget();\n        //m_CellEditor = m_Model.getCellEditor(m_FocusCol, m_FocusRow);\n        m_CellEditor = cellEditor; //@Trifon\n        if (m_CellEditor != null) {\n            scrollToFocus();\n            Rectangle r = getCellRect(m_FocusCol, m_FocusRow);\n            m_CellEditor.open(this, m_FocusCol, m_FocusRow, r);\n        }\n    }\n",
    "66843": "    public void scroll(int col, int row) {\n        if (col<0 || col>=m_Model.getColumnCount() ||\n            row<0 || row>=m_Model.getRowCount())\n            return;\n        \n        m_TopRow = row;\n        m_LeftColumn=col;\n        redraw();\n    }\n",
    "66897": "    public void addCellSelectionListener(KTableCellSelectionListener listener) {\n        cellSelectionListeners.add(listener);\n    }\n",
    "66909": "    public void addCellResizeListener(KTableCellResizeListener listener) {\n        cellResizeListeners.add(listener);\n    }\n",
    "66949": "    public void addCellDoubleClickListener(KTableCellDoubleClickListener listener) {\n        cellDoubleClickListeners.add(listener);\n    }\n",
    "66967": "    public boolean removeCellSelectionListener(KTableCellSelectionListener listener) {\n        return cellSelectionListeners.remove(listener);\n    }\n",
    "66991": "    public boolean removeCellResizeListener(KTableCellResizeListener listener) {\n        return cellResizeListeners.remove(listener);\n    }\n",
    "67028": "    public boolean removeDoubleClickListener(KTableCellDoubleClickListener listener) {\n        return cellDoubleClickListeners.remove(listener);\n    }\n",
    "67038": "  public void gotoRecord(int pos) {\n    curRecordIndex = pos;\n    int rowNb = curRecordIndex-1+firstRowIndex;\n    getCaller().trace.trace(\"Moving to record #\"+pos+\" (row #\"+rowNb+\")\");\n    if(rowNb<firstRowIndex || rowNb>lastRowIndex)\n      curRow = null;\n    else\n      curRow = curSheet.getRow(rowNb);\n  }\n",
    "67043": "  public Value getColumn(int i) throws ExecuteException {\n    if(i<1 || i>sheetLabels.length)\n      throw new ExecuteException(\"Cell #\"+i+\" is out of range\");\n    if(curRow==null) return NullValue.NULL;\n    getCaller().trace.trace(\"Getting column #\"+i);\n    return getCellValue((short)(i-1));\n    // getCellType: CELL_TYPE_STRING, CELL_TYPE_NUMERIC, CELL_TYPE_FORMULA, CELL_TYPE_BOOLEAN, CELL_TYPE_ERROR\n    //    return cell.getNumericCellValue();\n  }\n",
    "67044": "    public boolean isRowSelectMode() {\n        return (getStyle() & SWT.FULL_SELECTION) == SWT.FULL_SELECTION;\n    }\n",
    "67056": "    public boolean isMultiSelectMode() {\n        return (getStyle() & SWT.MULTI) == SWT.MULTI;\n    }\n",
    "67066": "  protected boolean first100AreInteger(short col) {\n    int i = firstRowIndex;\n    HSSFRow row;\n    while((row=curSheet.getRow(i++))!=null && i<100) {\n      HSSFCell cell = row.getCell(col);\n      if(cell!=null) {\n\tif(cell.getCellType()==HSSFCell.CELL_TYPE_NUMERIC)\n        try {\n          float val = (float)cell.getNumericCellValue();\n          if(val!=(float)((int)val)) return false;\n\t} catch (NumberFormatException exc) {return false;}\n      }\n    }\n    return true;\n  }\n",
    "67081": "  public ASTXMLObject nextXML() throws ExecuteException {\n    currentChildIndex++;\n    if(currentChildIndex<(bufStart+buffer.size()))\n      return (ASTXMLObject) buffer.get(currentChildIndex+bufStart);\n    else \n      try{return parseXML();}\n      catch (XMLException exc) {\n        if(onerror==null) throw exc;\n        else {\n          onerror.executeWithExc(exc,\n              \"Caught XML exception while parsing \"+fileName);\n          return null;\n        }\n      }\n  }\n",
    "67085": "  public void initParser() throws ExecuteException {\n    bufStart = -1;\n    buffer.removeAllElements();\n    getCaller().trace.debug(\"*** Parsing \"+fileName+\" header...\");\n    FileReader fileReader;\n    // TBD: set encoding\n    try {fileReader = new FileReader(fileName);}\n    catch (FileNotFoundException exc) {\n      throw new ExecuteException(\"File not found: \"+fileName);}\n    parser = new Parser(fileReader);\n    // parse header\n    try {\n      boolean allowDSQL = allowDSQL();\n      root = parser.XMLHeader(allowDSQL,allowDSQL);\n      // TBD: detect empty document, i.e. <doc/>\n    } catch (ParseException exc) {\n      throw new XMLException(fileName,exc);\n    } catch (TokenMgrError exc) {\n      throw new XMLException(fileName,exc);\n    }\n  }\n",
    "67140": "  public String getString() throws ExecuteException {\n    if(getColumnCount()==0) return null;\n    if(currentRecord()>1) reset();\n    if(currentRecord()==0) \n      if(!nextRecord()) return null;\n    return getColumnString(1);\n  }\n",
    "67178": "  protected int findColumn(String label) throws ExecuteException {\n    Integer i = (Integer) columnLabels.get(label);\n    if(i!=null) return i.intValue();\n    else throw new ExecuteException(\"No column \"+label+\" in results\");\n  }\n",
    "67180": "    public void clearSelection() {\n        checkWidget();\n        clearSelectionWithoutRedraw();\n        m_FocusCol = -1;\n        m_FocusRow = -1;\n        if (isMultiSelectMode())\n            redraw();\n    }\n",
    "67193": "    protected boolean toggleSelection(int col, int row) {\n\n        if (isMultiSelectMode()) {\n            Object o;\n            if (isRowSelectMode()) {\n                o = new Integer(row);\n            } else {\n                o = new Point(col, row);\n            }\n            if (m_Selection.get(o) != null) {\n                m_Selection.remove(o);\n                return false;\n            } else {\n                m_Selection.put(o, o);\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "67203": "    protected void addToSelectionWithoutRedraw(int col, int row) {\n        if (isMultiSelectMode()) {\n            if (isRowSelectMode()) {\n                Integer o = new Integer(row);\n                m_Selection.put(o, o);\n            } else {\n                Point o = new Point(col, row);\n                m_Selection.put(o, o);\n            }\n        }\n    }\n",
    "67213": "    public void setSelection(int col, int row, boolean scroll) {\n        checkWidget();\n        if (col < m_Model.getColumnCount()\n                && col >= m_Model.getFixedHeaderColumnCount()\n                && row < m_Model.getRowCount()\n                && row >= m_Model.getFixedHeaderRowCount()) {\n            focusCell(col, row, 0);\n            if (scroll) {\n                scrollToFocus();\n            }\n        }\n    }\n",
    "67216": "  protected int findColumn(String label) throws ExecuteException {\n    if(cachedLabels!=null && cachedLabels.get(label)!=null)\n      return ((Integer)cachedLabels.get(label)).intValue();\n    else {\n      if(rs==null) // not sure this can ever happen \n        throw new ExecuteException(\"No SQL results\");\n      try {return rs.findColumn(label);}\n      catch (SQLException exc) {throw new ExecuteException(\n        \"Column \"+label+\" does not exist in results\");}\n    }\n  }\n",
    "67233": "    public boolean isCellSelected(int col, int row) {\n        checkWidget();\n        Point v = getValidCell(col, row);\n        col = v.x;\n        row = v.y;\n        if (!isMultiSelectMode()) {\n            if (isRowSelectMode())\n                return (row == m_FocusRow);\n            return (col == m_FocusCol && row == m_FocusRow);\n        }\n\n        if (isRowSelectMode())\n            return (m_Selection.get(new Integer(row)) != null);\n        else\n            return (m_Selection.get(new Point(col, row)) != null);\n    }\n",
    "67241": "    public boolean isRowSelected(int row) {\n        return (m_Selection.get(new Integer(row)) != null);\n    }\n",
    "67255": "  public Object getField(String name) throws ExecuteException {\n    if(name.equals(\"start\")) return new IntValue(start);\n    if(name.equals(\"end\")) return new IntValue(end);\n    return super.getField(name);\n  }\n",
    "67321": "    private boolean highlightSelectedRowCol(int col, int row) {\n        if (!isHighlightSelectionInHeader() || !isHeaderCell(col, row))\n            return false;\n        \n        Point[] sel = getCellSelection();\n        if (sel!=null) {\n            for (int i=0; i<sel.length; i++) {\n                if (sel[i].x == col || sel[i].y == row) \n                    return true;\n                Point valid = getValidCell(sel[i].x, row);\n                if (valid.x == col) return true;\n                valid = getValidCell(col, sel[i].y);\n                if (valid.y == row) return true;\n            }\n        }\n        return false;\n    }\n",
    "67364": "    public void setModel(KTableModel model) {\n        checkWidget();\n        m_Model = model;\n        m_FocusCol = -1;\n        m_FocusRow = -1;\n        clearSelectionWithoutRedraw();\n        \n        // implement autoscrolling if needed:\n        if ((getStyle() & SWTX.AUTO_SCROLL) == SWTX.AUTO_SCROLL)\n            updateScrollbarVisibility();\n        \n        redraw();\n        // TODO add KTable as listener to KModel...\n        if (m_Model != null) {\n        \tSystem.out.println(\"KTable added as listener to KTableModel...\");\n        \tm_Model.addModelChangeListener(this);\n        }\n    }\n",
    "67396": "    public KTableModel getModel() {\n        return m_Model;\n    }\n",
    "67402": "  public Object getType(Class cl) throws ExecuteException {\n    if(cl==String.class) return getString();\n    if(cl==Boolean.class) return new Boolean(getBoolean());\n    if(cl==Integer.class) return new Integer(getInt());\n    if(cl==Float.class) return new Float(getFloat());\n    if(cl==RecordHolder.class) return getRecordHolder();\n    if(cl==XmlElement.class) return getXmlElement();\n    if(cl==ASTXMLObject.class) return getASTXML();\n    throw new ExecuteException(\"Cannot convert \"+this.toString()+\n\t\t\t       \" to \"+cl);\n  }\n",
    "67404": "  public Class getObjectClass() {\n    return getClass();\n  }\n",
    "67405": "  public Object getField(String name) throws ExecuteException {\n    try {\n      return getValue(getClass().getField(name).get(this));\n    } catch (NoSuchFieldException exc) {\n      StringBuffer available = new StringBuffer(\"Valid fields are: \");\n      boolean first = true;\n      for (Enumeration e=getFieldsEnumeration(); e.hasMoreElements();) {\n        available.append((first?\"\":\",\")+e.nextElement());\n        first = false;\n      }\n      throw new ExecuteException(\"Field '\"+name+\"' does not exist. \"\n                               +(first?\"No fields defined.\":available.toString()));\n    } catch (IllegalAccessException exc) {\n      throw new ExecuteException(\"Field '\"+name+\"' cannot be accessed\",exc);\n    }\n  }\n",
    "67409": "  public Enumeration getFieldsEnumeration() {\n    Field[] fields = getClass().getFields();\n    Vector v = new Vector();\n    for(int i=0; i<fields.length; i++) v.add(fields[i].getName());\n    return Collections.enumeration(v);\n  }\n",
    "67432": "  public Object getField(String name) throws ExecuteException {\n    return getColumn(name);\n  }\n",
    "67441": "    protected int getFixedColumnCount() {\n        return m_Model.getFixedHeaderColumnCount()+m_Model.getFixedSelectableColumnCount();\n    }\n",
    "67494": "  public void reset() throws ExecuteException {\n      if(currentIndex==0) return;\n      else throw new ExecuteException(\"Unable to reset enumerator value\");\n  }\n",
    "67526": "    protected int getFixedRowCount() {\n        return m_Model.getFixedHeaderRowCount()+m_Model.getFixedSelectableRowCount();\n    }\n",
    "67554": "  public void highlight(String pattern) {\n    // First remove all old highlights\n    try {\n      Highlighter hilite = getHighlighter();\n      Document doc = getDocument();\n      String text = doc.getText(0, doc.getLength());\n      int pos = 0;\n      // Search for pattern\n      while ((pos = text.indexOf(pattern, pos)) >= 0) {\n\t// Create highlighter using private painter and apply around pattern\n\thilite.addHighlight(pos, pos+pattern.length(), findHighlightPainter);\n\tpos += pattern.length();\n      }\n    } catch (BadLocationException e) {\n    }\n  }\n",
    "67555": "  public void removeHighlights() {\n    Highlighter hilite = getHighlighter();\n    Highlighter.Highlight[] hilites = hilite.getHighlights();  \n    for (int i=0; i<hilites.length; i++) {\n      if (hilites[i].getPainter() == findHighlightPainter) {\n\thilite.removeHighlight(hilites[i]);\n      }\n    }\n  }\n",
    "67572": "  public boolean abortOpen() {\n    if(unsavedEdits()) {\n      // bring up save dialog\n      int i=gui.chooseYesNoCancel(\"Save changes to \"+\n\t\t\t      (fileName==null?\"buffer\":fileName)+\n\t\t\t      \"?\",\"Unsaved\");\n      if(i==JOptionPane.CANCEL_OPTION) return true;\n      if(i==JOptionPane.YES_OPTION) {\n\tif(fileName!=null) saveFile(fileName);\n\telse if(!saveDialog()) return true;\n      }\n    }\n    return false;\n  }\n",
    "67606": "  public void addStackValue(Value v) {\n    if(getGui()!=null) getGui().addReturnValue(v);\n  }\n",
    "67639": "  protected ConnectStmt openConnection() throws ExecuteException {\n    try {\n      if(driverClass!=null) Class.forName(driverClass);\n      getCaller().trace.sql(\"Connecting to \"+conurl);\n      Connection con = \n        DriverManager.getConnection(conurl,userName.getUserName(),\n        \t                    password.getPassword());\n      ConnectStmt conStmt = new ConnectStmt(con);\n      SQLconns.addElement(conStmt);\n      setMetadata();\n      return conStmt;\n    } catch (ClassNotFoundException exc) {\n      throw new ExecuteException(\"Unable to use driver \"+getDriverId()+\n        \": class \"+driverClass+\" could not be found.\");\n    } catch (SQLException exc) {\n      throw new ExecuteException(\"Unable to establish connection to '\"+\n        getId()+\"': \"+exc.getMessage(),exc);\n    }\n  }\n",
    "67646": "   public void stopMasking() {\n      this.stop = true;\n   }\n",
    "67647": "    public boolean hasMoreElements() {\n        if (hasMore)\n            hasChecked = hasMore = e1.hasMoreElements();\n        return hasMore ? true : e2.hasMoreElements();\n    }\n",
    "67648": "    public Object nextElement() {\n        if (hasMore && !hasChecked)\n            hasMore = e1.hasMoreElements();\n\thasChecked = false;\n        return hasMore ? e1.nextElement() : e2.nextElement();\n    }\n",
    "67669": "  protected int priority() {\n    return Integer.MAX_VALUE;\n  }\n",
    "67718": "  public void addVariable(Variable var) {\n    ((Hashtable)vars.elementAt(vars.size()-1)).put(var.getName(),var);\n    getCaller().trace.debug(\"Added \"+var+\" to the current variable context\");\n  }\n",
    "67719": "  public void setVariable(String name, Value value) throws ExecuteException {\n    Variable var;\n    try { var = getVariable(name); }\n    catch (VarNotSetException exc) { \n      var = new Variable(name);\n      addVariable(var); \n    }\n    var.setValue(value);\n  }\n",
    "67810": "  public String getXMLText() throws ExecuteException {\n    String r = \"\";\n    // TBD: should start from attributes?\n    for(int i=0; i<jjtGetNumChildren(); i++)\n      if(children[i] instanceof ASTXMLObject &&\n         !(children[i] instanceof ASTXMLAttribute))\n        r = r+((ASTXMLObject)children[i]).getXMLText();\n    return r;\n  }\n",
    "67862": "  public void updateCursorPos(int line, int col) {\n    caretPos.setText(\"\"+line+\":\"+col);\n  }\n",
    "67892": "  public Value executeWithCatch() throws ExecuteException {\n    if(getCaller().hasRequestToStop()) \n      throw new StopException();\n    try {return execute();}\n    catch (ExecuteException exc) {\n      if(exc.getNode()==null) exc.setNode(this); \n      throw exc;\n    }\n  }\n",
    "67954": "  public ASTXMLObject executeXML() {\n    return this;\n  }\n",
    "68115": "   public Food findIdenticalFood(Food f) {\n      Iterator iter = map.values().iterator();\n      while (iter.hasNext()) {\n         FoodProxy food = (FoodProxy)iter.next();\n         if (food.getDescription().equals(f.getDescription())) {\n            if (food.getFood().equals(f)) {\n               return food.getFood();\n            }\n         }\n      }\n      return null;\n   }\n",
    "68207": "   private String fixString(String str) {\n      //return \"<html><div align=\\\"center\\\">\" + str + \"</div></html>\";\n      if (str.length() > 53) {\n         return str.substring(0, 50)+\"...\";\n      } else {\n         return str;\n      }\n   }\n",
    "68213": "   private void createFile() {\n      for (Iterator iter = Biomarker.createPredefinedBiomarkers().iterator(); iter.hasNext();) {\n         Biomarker biomarker = (Biomarker) iter.next();\n         addBiomarker(biomarker);\n      }\n      save();\n   }\n",
    "68215": "   private void createDataset() {\n      actualData = new TimeSeries(metricName, Day.class);\n      dataset = new TimeSeriesCollection();\n      getData();\n      dataset.addSeries(actualData);\n   }\n",
    "68229": "   public int compareTo(Object object) {\n      return date.compareTo(((Metric)object).getDate());\n   }\n",
    "68297": "   public void addFood(NutrientTable toAdd, double weight) {\n      for (int i = 0; i < nutrients.length; i++) {\n         nutrients[i] += toAdd.getAmount(i) * weight;\n      }\n   }\n",
    "68319": "    public void update() {\n       UserManager.getCurrentUser().getFoodHistory().update(this);\n        //lds.changeServingAmount(this);\n    }\n",
    "68342": "   public void setMeasure(String measureName) {\n      if (food == null) return;\n      List measures = getFoodProxy().getFood().getMeasures();\n      for (int i=0; i<measures.size(); i++) {\n         Measure m = (Measure)measures.get(i);\n         if (m.getDescription().equals(measureName)) {\n            setMeasure(m);\n            return;\n         }\n      }\n      // if nothing found, default to GRAMS\n      setMeasure(Measure.GRAM);\n   }\n",
    "68372": "   public String getDescription() {\n      return description;\n   }\n",
    "68373": "   public void setFood(Food f) {\n      measures.setModel(new DefaultComboBoxModel(f.getMeasures().toArray()));\n      curMeasure = Measure.GRAM;\n      fireChangeEvent();\n   }\n",
    "68375": "   public void setDescription(String text) {\n      description = text;\n      setDirty(true);\n   }\n",
    "68376": "   public void setMeasure(Measure w, double mult) {\n     // measures.setSelectedItem(w);\n      for (int i=0; i<measures.getItemCount(); i++) {\n         Measure m = (Measure)measures.getItemAt(i);\n         if (m.equals(w)) {\n            measures.setSelectedIndex(i);\n            break;\n         }\n      }\n      multiplier.setValue(mult);\n      fireChangeEvent();\n   }\n",
    "68377": "   public List getMeasures() {\n      if (measures == null) {\n         measures = new ArrayList();\n         measures.add(Measure.GRAM);\n      }\n      return measures;\n   }\n",
    "68378": "   public void updateMeasure() {\n      Measure w = getSelectedMeasure();     \n      if (linked) {\n         double mult = w.getAmount();\n         if (curMeasure != null) {\n            double grams = curMeasure.getGrams() * multiplier.getValue();\n            mult = grams/w.getGrams();\n         }\n         multiplier.setValue(mult);\n      }\n      setFocus();\n      curMeasure = w;\n      fireChangeEvent();\n   }      \n",
    "68380": "   public double getMultiplier() {\n      return getGrams() / 100.0;\n   }\n",
    "68381": "   public void setMeasures(List measures) {\n      this.measures = measures;\n      setDirty(true);\n   }\n",
    "68382": "   public double getGrams() {\n      Measure w = getSelectedMeasure();\n      if (w != null) {\n         return multiplier.getValue() * w.getGrams();// * (1.0/w.getAmount()); \n      }\n      return 0;\n   }\n",
    "68383": "   public boolean hasDataFor(NutrientInfo ni) {\n        if (ni == null) return false;\n        return getNutrients().dataExists(ni.getIndex());         \n    }\n",
    "68386": "   public double getNutrientAmount(NutrientInfo ni) {\n        if (ni == null) return 0;\n        return getNutrients().getAmount(ni.getIndex());         \n    }\n",
    "68388": "   public void setNutrientAmount(NutrientInfo ni, double val) {\n      getNutrients().setAmount(ni.getIndex(), val);        \n      setDirty(true);\n   }\n",
    "68401": "   public void addServings(Serving[] list) {\n      addServingsToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());\n   }\n",
    "68402": "   public void itemStateChanged(ItemEvent e) {\n      updateMeasure();\n   }\n",
    "68403": "   public void actionPerformed(ActionEvent e) {\n      fireChangeEvent();\n      fireActionEvent();\n      //Toolkit.getDefaultToolkit().beep();\n   }\n",
    "68410": "   public String getSourceUID() {\n      return sourceUID;\n   }\n",
    "68411": "   public void keyReleased(KeyEvent e) {\n      //System.out.println(\"keyReleased: \" + e);\n      fireChangeEvent();\n   }\n",
    "68413": "   public void setSourceUID(String uid) {\n      sourceUID = uid;\n      setDirty(true);\n   }\n",
    "68415": "   public boolean isLinked() {\n      return linked;\n   }\n",
    "68416": "   public void setComment(String comment) {\n      this.comment = comment;\n      setDirty(true);\n   }\n",
    "68418": "   public void setLinked(boolean linked) {\n      this.linked = linked;\n   }\n",
    "68419": "   public String getComment() {\n      return comment;\n   }\n",
    "68433": "   public boolean equals(Food f) {\n      if (!f.getDescription().equals(getDescription())) return false;\n      List nutrients = NutrientInfo.getGlobalList();\n      for (int i=0; i<nutrients.size(); i++) {\n         NutrientInfo ni = (NutrientInfo)nutrients.get(i);\n         if (f.getNutrientAmount(ni) != getNutrientAmount(ni)) {\n            return false;\n         }\n      }\n      return true;\n   }\n",
    "68453": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      Serving s = getServing(row);\n      if (s != null) {\n         if (s.getFoodProxy().isDeprecated()) {\n            c.setForeground(Color.LIGHT_GRAY);               \n         } else if (col == 0) {\n            c.setForeground(s.getFoodProxy().getSource().getDisplayColor());               \n         } else {\n            c.setForeground(Color.BLACK);\n         }\n      }\n      return c;\n   }\n",
    "68457": "   private void setMeasureBox(Serving s) {\n      if (s != null) {\n         measureBox.removeAllItems();\n         List measures = s.getFood().getMeasures();\n         for (int i=0; i<measures.size(); i++) {\n            measureBox.addItem(measures.get(i));\n         }\n         measureBox.setSelectedItem(s.getMeasure());\n      }\n   }\n",
    "68461": "   public void updateOriginal() {\n      original.copy(food);\n      original.update();\n   }\n",
    "68472": "    public double getAmount() {\n        return amount;\n    }\n",
    "68474": "    public void setAmount(double amount) {\n        this.amount = amount;\n    }\n",
    "68477": "    public void setDescription(String description) {\n        this.description = description;\n    }\n",
    "68478": "    public double getGrams() {\n        return grams;\n    }\n",
    "68480": "    public void setGrams(double grams) {\n        this.grams = grams;\n    }\n",
    "68523": "   public void doPrint() {\n      try {         \n         MessageFormat headerFormat = new MessageFormat(getTitle());\n         MessageFormat footerFormat = new MessageFormat(\"- {0} -\");\n         getTable().print(JTable.PrintMode.FIT_WIDTH, headerFormat, footerFormat);          \n      } catch (PrinterException e) {\n         e.printStackTrace();\n         JOptionPane.showMessageDialog(this, e.getMessage());\n      }\n   }     \n",
    "68552": "   private void recomputeNutrients() {\n      double total = getTotalGrams();\n      \n      Iterator iter = NutrientInfo.getGlobalList().iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         setNutrientAmount(ni, getAmount(ni, total));\n      }\n      \n      recomputeFactors();\n      \n      boolean found = false;\n      List list = getMeasures();      \n      for (int i=0; i<list.size(); i++) {\n         Measure m = (Measure)list.get(i);\n         if (m.getDescription().equals(\"full recipe\")) {\n            m.setGrams(total);\n            found = true;\n         }\n      }\n      if (!found) {\n         getMeasures().add( new Measure(1.0, \"full recipe\", total) );\n      }\n      //update();\n   }\n",
    "68556": "   private double getAmount(NutrientInfo ni, double totalGrams) {\n      double total = 0;\n      for (Iterator iter = getServings().iterator(); iter.hasNext();) {\n         Serving serving = (Serving) iter.next();\n         if (serving.getFood() != null) {\n            double weight = (serving.getGrams()/totalGrams);\n            total += weight * serving.getFood().getNutrientAmount(ni);\n         }\n      }\n      return total;\n   }\n",
    "68563": "   public void updateOriginal() {\n      ((Recipe)original).copy(getRecipe());\n      original.update();\n   }\n",
    "68564": "   public boolean isSparseData() {\n      return sparse;\n   }\n",
    "68601": "   public User getLastUser() {\n      User user = getUser(getLastUsername());\n      if (user == null) {\n         user = getUserList().get(0);\n      }\n      return user;\n   }\n",
    "68615": "   public void addUser(JComponent parentWindow) {\n      User user = new User(new Settings(Settings.TAG_USER));\n      setCurrentUser(user);\n      addUser(user);\n      user.doFirstRun(parentWindow);\n      settings.save();\n   }\n",
    "68621": "   public void addUser(User user) {\n      userList.add(user);\n      settings.save();\n   }\n",
    "68626": "   public User getUser(String username) {\n      return getUser(getUserList(), username);\n   }\n",
    "68631": "   public void deleteUser(User user) {\n      userList.remove(user);\n      deleteFiles(user);\n      if (currentUser == user) {\n         // Make sure we select a new currentUser, find the first active user\n         setCurrentUser(getUserList().get(0));\n      }\n      settings.save();\n   }\n",
    "68635": "   public void deleteFiles(User user) {\n      File userDir = getUserDirectory(user);\n      if (userDir.exists()) {\n         int i;\n         for (i=0; i<userFileList.length; i++) {\n            File userFile = new File(userDir.getAbsolutePath(), userFileList[i]);\n            if (userFile.exists()) {\n               if (!userFile.delete()) {\n                  Logger.error(\"Unable to delete the file: \" + userFile.getAbsolutePath());\n               }\n            }\n         }\n         if (!userDir.delete()) {\n            Logger.error(\"Unable to delete the folder: \" + userDir.getAbsolutePath());\n         }\n      }\n   }\n",
    "68641": "   public boolean deleteUser(String username) {\n      User user = getUser(username);\n      if (userExists(username)) {\n         deleteUser(user);\n         return true;\n      }\n      return false;\n   }\n",
    "68649": "   public boolean setCurrentUser(String username) {\n      User user = getUser(username);\n      if (user != null) {\n         setCurrentUser(user);\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "68660": "   public int getAge() {\n      if (null != getBirthDate()) {\n         return getAge(getBirthDate());\n      }\n      return 0;\n   }\n",
    "68746": "   private void deleteSelectedUser(int row) {\n      String username = (String)userListModel.get(row);\n      \n      if ( ! isOkToDeleteUser()) {\n         return;\n      }\n      \n      if (userListModel.size() == 1) {\n         Logger.error(\"Not allowed to delete last user.\");\n         return;\n      }\n      if (!userMan.deleteUser(username)) {\n         Logger.error(\"Unable to delete user.\");\n         return;\n      }\n      userListModel.remove(row);\n      selectCurrentUser();\n      setDirty(true);\n   }\n",
    "68754": "   public void selectDefaultUser() {\n      userList.setSelectedValue(UserManager.selectOtherUser().getUsername(), true);   \n   }\n",
    "68759": "   public void selectCurrentUser() {\n      userList.setSelectedValue(UserManager.getCurrentUser().getUsername(), true);   \n      if (userListModel.getSize() == 1) {\n         delBtn.setEnabled(false);\n      }\n   }\n",
    "68774": "   public double getTargetCompletion(boolean average) {\n      double total = 0;\n      double value = 0;\n      double valueFull = 0; \n      \n      Iterator iter = getNutrientList().iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         Target target = UserManager.getCurrentUser().getTarget(ni);\n         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {\n            double amount = getNutrientTable().getAmount(ni);\n            valueFull += amount/target.getMin();\n            if (amount < target.getMin()) {\n               value += amount/target.getMin();\n            } else {\n               value++;\n            }\n            total++;\n         }\n      }\n      if (average) {\n         return valueFull/total;\n      } else {\n         return value / total;\n      }\n   }\n",
    "68851": "   public void initUserData() {\n      getFoodHistory();\n      getNotesHistory();\n      getBiometricsHistory();\n   }\n",
    "68906": "   public void saveUserData() {\n      getFoodHistory().save();\n      getBiometricsHistory().save();\n      getNotesHistory().save();\n      getExerciseHistory().save();\n   }\n",
    "68918": "   public double getTargetCompletion(List servings, List nutrients, int days, boolean average) {\n      double total = 0;\n      double value = 0;\n      double valueFull = 0; \n      \n      Iterator iter = nutrients.iterator();\n      while (iter.hasNext()) {\n         NutrientInfo ni = (NutrientInfo)iter.next();\n         Target target = UserManager.getCurrentUser().getTarget(ni);\n         if (target.getMin() > 0 && UserManager.getCurrentUser().isTracking(ni)) {\n            double amount = getAmount(servings, ni) / (double) days;\n            valueFull += amount/target.getMin();\n            if (amount < target.getMin()) {\n               value += amount/target.getMin();\n            } else {\n               value++;\n            }\n            total++;\n         }\n      }\n      if (average) {\n         return valueFull / total;\n      } else {\n         return value / total;\n      }\n   }\n",
    "69072": "   public void focusLost(FocusEvent e) {\n      if (curDate != null) {\n         saveCurrentNote(); \n      }\n   }\n",
    "69106": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      Exercise s = getExercise(row);\n      if (s != null) {\n         c.setForeground(Color.BLACK);\n      }\n      return c;\n   }\n",
    "69119": "   public void doDBSearch() {\n      Object sel = getSourceBox().getSelectedItem();\n      if (sel instanceof FoodDataSource) {\n         doDBSearch((FoodDataSource)sel);\n      } else {\n         doDBSearch(null);\n      }\n   }\n",
    "69156": "   public void restoreWindow() {\n      setVisible(true);\n      setExtendedState(Frame.NORMAL);\n      toFront();\n   }\n",
    "69168": "   public void goToToday() {\n      setDate(new Date(System.currentTimeMillis()), false);\n   }\n",
    "69174": "   private void copyPreviousDay() {\n//      if (isOkToAddServings(curDate)) {\n\t   Date previousDay = new Date(curDate.getTime() - ONE_DAY);\n      UserManager.getCurrentUser().getFoodHistory().copyConsumedOn(previousDay, curDate);\n\t   notifyObservers();\n//      }\n   }\n",
    "69192": "      public Component customRender(Component c, PrettyTable table, int row, int col) {\n         FoodProxy f = getSearchHit(row).getFoodProxy();\n         if (f != null) {\n            if (col == 0) {\n               c.setForeground(f.getSource().getDisplayColor());\n               if (f.isDeprecated()) {\n                  c.setForeground(Color.LIGHT_GRAY);\n               }\n            }\n         }\n         return c;\n      }\n",
    "69198": "   public void update() {\n      UserManager.getCurrentUser().getExerciseHistory().update(this);\n   }\n",
    "69207": "   public void addExercises(Exercise[] list) {\n      addExercisesToUser(list, UserManager.getCurrentUser(), CRONOMETER.getDailySummary().getDate());\n   }\n",
    "69234": "   public void setDate(Date d, boolean userChanged) {\n      curDate = d;      \n      // getDateTitle().setDate(curDate);\n      getDateTitle().setText(df.format(curDate));\n      validate();\n      getBioMarkersPanel().setDate(d);\n      getServingTable().setTitle(df.format(curDate));\n      if (!userChanged) {\n         getNotesEditor().saveCurrentNote(); \n      }\n      getNotesEditor().setDate(d);\n      asked = false;\n      refreshTime();\n      notifyObservers();\n   }\n",
    "69318": "   public void reload() {\n      load();\n   }\n",
    "69347": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      //Record entry = getUserEntry(row);\n      return c;\n   } \n",
    "69454": "   public void addEntries(Record[] list) {\n      for (int i=0; i<list.length; i++) {\n         add(list[i].copy());\n      }\n   }\n",
    "69485": "    public void removeLayoutComponent(Component comp) {\n        compTable.remove(comp);\n    }\n",
    "69504": "    public Dimension minimumLayoutSize(Container parent) {\n    \tint ncomponents = parent.getComponentCount();\n\t\tif (ncomponents == 0) return new Dimension(1,1);\n\t\tRectangle totalRect = new Rectangle(0,0,1,1);\n\t\tfor ( int i = 0; i < ncomponents; i++ ) {\n\t\t\tComponent c = parent.getComponent(i);\n\t\t\tSpazPosition lp = (SpazPosition)compTable.get(c);\n         Rectangle rect = lp.getMinRectangle();\n         if ( rect != null ) \n         \ttotalRect = totalRect.union(rect); \n\n\t\t}\n\t\treturn new Dimension(totalRect.width,totalRect.height);\n    }\n",
    "69515": "    public void addLayoutComponent(Component comp, Object constraints) {\n        if (constraints instanceof SpazPosition) {\n            SpazPosition cons = (SpazPosition)constraints;\n            setConstraints(comp, cons);\n        } else if (constraints != null) {\n            throw new IllegalArgumentException(\n                \"cannot add to layout: constraint must be a SpazPostion\");\n        }\n    }\n",
    "69519": "    public Dimension maximumLayoutSize(Container target) {\n        return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n    }\n",
    "69523": "    public float getLayoutAlignmentX(Container target) {\n        return 0.5f;\n    }\n",
    "69527": "    public float getLayoutAlignmentY(Container target) {\n        return 0.5f;\n    }\n",
    "69530": "    public void invalidateLayout(Container target) {\n        // Do nothing\n    }\n",
    "69551": "   public Component customRender(Component c, PrettyTable table, int row, int col) {\n      return c;\n   }\n",
    "69578": "   public void showWindow() {\n      setVisible(true); \n      toFront();\n   }\n",
    "69601": "   public void setExternal(boolean val) {\n      external = val;\n   }\n",
    "69606": "   public Object newInstance(String name) {\n      try {\n         Class c = this.loadClass(name, true);\n         return c.newInstance();\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n      return null;\n   }\n",
    "69631": "   public long getBytesRead() {\n      return bytesRetrieved;\n   }\n",
    "69634": "   public String getKey() {\n      return key;\n   }\n",
    "69636": "   public String getNewValue() {\n      return newValue;\n   }\n",
    "69659": "   public SQLColumnSet getColumns() {\n      return cols;\n   }\n",
    "69660": "    public void addWhere(String name, Object val) {\n        addWhere(name, EQ, val);\n    }\n",
    "69676": "    public void addWhereLike(String name, String val) {\n        where.add(\"upper(\" + name + \") like '\"\n                + escape(val.toString()).toUpperCase() + \"' \");\n    }\n",
    "69689": "    public void addSelection(String field) {\n        items.add(field);\n    }\n",
    "69692": "    protected ResultSet doExecuteQuery(Connection con) throws SQLException {\n        Statement stmt = con.createStatement();\n        String query = this.getQueryString();\n        if (Logger.isDebugEnabled()) {\n           Logger.debug(\"executeQuery() - Statement to be executed: \" + query);\n        }\n\n        results = stmt.executeQuery(query);\n        return results;\n    }\n",
    "69695": "   public void setPrintNewLines(boolean b) {\n      printNewLines  = b;\n      Iterator iter = children.iterator();\n      while (iter.hasNext()) {\n         ((XMLNode)iter.next()).setPrintNewLines(b);\n      }\n   }\n",
    "69701": "   protected String getQueryString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(\"UPDATE \");\n      sb.append(getTableName());\n      sb.append(\" SET \");\n      List names = cols.getNames();\n      List terms = cols.getValues();\n      for (int i=0; i<names.size(); i++) {         \n         Object name = names.get(i);\n         Object term = terms.get(i);\n         if (term == null) {\n            term = \"NULL\"; \n         }\n         sb.append(name.toString());\n         sb.append(\" = '\");\n         sb.append(escape(term.toString()));\n         sb.append(\"' \");\n         if (i < names.size() - 1) {\n            sb.append(\", \");\n         }\n      }\n      sb.append(getWhere());\n      return sb.toString();\n   }\n",
    "69706": "   protected String getQueryString() {\n      StringBuffer sb = new StringBuffer();\n      sb.append(\"DELETE FROM \");\n      sb.append(getTableName());\n      sb.append(getWhere());\n      return sb.toString();\n   }\n",
    "69730": "   public void setHgap(int hgap) {\n       this.hgap = hgap;\n   }\n",
    "69735": "   public int getVgap() {\n       return vgap;\n   }\n",
    "69757": "   public void setVgap(int vgap) {\n       this.vgap = vgap;\n   }\n",
    "69767": "   public void removeLayoutComponent(Component comp) {\n      constraints.remove(comp);\n   }\n",
    "69866": "    public DistributorMO setEndPoint(Location endPoint) {\n        this.endPoint = endPoint;\n        return this;\n    }\n",
    "70192": "    public void menuVJBTreeClear() {\n        menuSetDMT.removeAllChildren();\n        menuVJBTreeModel.reload();\n    }\n",
    "70311": "    public void menuVJBTreeRemoveCurrentNode() {\n        TreePath currentSelection = menuVJBTree.getSelectionPath();\n        if (currentSelection != null) {\n            DefaultMutableTreeNode currentNode = \n                    (DefaultMutableTreeNode)\n                    (currentSelection.getLastPathComponent());\n            MutableTreeNode parent = \n                    (MutableTreeNode)(currentNode.getParent());\n            if (parent != null) {\n                menuVJBTreeModel.removeNodeFromParent(currentNode);\n                return;\n            }\n        } \n        // Either there was no selection, or the root was selected.\n    }\n",
    "70455": "    public DefaultMutableTreeNode menuVJBTreeAddObject(Object child) {\n        DefaultMutableTreeNode parentNode = null;\n        TreePath parentPath = menuVJBTree.getSelectionPath();\n        if (parentPath == null) {\n            parentNode = menuSetDMT;\n        } else {\n            parentNode = (DefaultMutableTreeNode)\n                 (parentPath.getLastPathComponent());\n        }\n        return menuVJBTreeAddObject(parentNode, child, true);\n    }\n",
    "70493": "    public TimeLimit timeLimit(TickTock tickTock) {\n        return new TimeLimit(this, tickTock);\n    }\n",
    "70817": "    public TimeSpan approximate(TimeUnit unit) {\n        long nanos = nanoTime();\n        long tenths = (long)Math.floor(Math.log10(nanos));\n        for (int i = 0; ; i++) {\n            int exp = (i + 1) * 3;\n            if (tenths < exp || i == 3 || unit == UNITS[i]) {\n                long div = (long)Math.pow(10, exp - 3);\n                long time = nanos / div;\n                return new TimeSpan(time, UNITS[i]);\n            }\n        }\n    }\n",
    "70823": "    public TimeSpan approximate() {\n        return approximate(null);\n    }\n",
    "70872": "    public boolean isWrapped() {\n        return this.wrappedValue != null;\n    }\n",
    "70880": "    public Object getValueString() {\n        return this.valueString;\n    }\n",
    "70884": "    public Object getTypedValue() {\n        return this.typedValue;\n    }\n",
    "70888": "    public Class getType() {\n        return this.type;\n    }\n",
    "70892": "    public String getTypeName() {\n        return this.typeName;\n    }\n",
    "70898": "    public boolean isPrimitive() {\n        return this.primitive;\n    }\n",
    "70902": "    public Throwable getThrowable() {\n        return this.throwable;\n    }\n",
    "70909": "    protected void writeToBuffer(StringBuffer buffer, int x, boolean indent) {\n        buffer.append(this.getType().getLeft());\n        for (int i = 0; i < this.nodes.length; i++) {\n            this.nodes[i].writeToBuffer(buffer, x + 2, true);\n            if (i < (this.nodes.length - 1)) {\n                buffer.append(\" \");\n            }\n        }\n        buffer.append(this.getType().getRight());\n    }\n",
    "70916": "    public long getEvalTime() {\n        return this.evalTime;\n    }\n",
    "70922": "    public boolean isOK() {\n        return this.throwableType == null;\n    }\n",
    "71014": "    protected void writeToBuffer(StringBuffer buffer, int x, boolean i) {\n        String string = this.isContentString()\n            ? \"\\\"\" + this.getContent() + \"\\\"\"\n            : (this.isContentHolder()\n               ? ((Holder)this.getContent()).toValueString()\n               : String.valueOf(this.getContent()));\n        buffer.append(string);\n    }\n",
    "71023": "    public Object evaluate(Context context) {\n        if (this.isContentSymbol()) {\n            Object value = context.lookup(this.getSymbolContent());\n            if (value == null) {\n                value = Reflector.get().resolveLeafNode(context, this);\n                if (value == null) {\n                    throw new EvaluationException\n                        (\"Unknown symbol or type \" + this.getSymbolContent());\n                }\n            }\n            return value;\n        } else {\n            return this.getContent();\n        }\n    }\n",
    "71705": "    private void addClassNodes() {\n        if (getRealObject() != null) {\n            ClassNode actualClass = new ClassNode(this,\n                                                  getRealObject().getClass(),\n                                                  \"Actual class\");\n            addChild(actualClass);\n        }\n        if (getDeclaredClass() != null) {\n            ClassNode declaredClass = new ClassNode(this,\n                                                    getDeclaredClass(),\n                                                    \"Declared class\");\n            addChild(declaredClass);\n        }\n    }\n",
    "71708": "    private void addFieldListNodes() {\n        for (Class clazz = getActualClass();\n             clazz != null;\n             clazz = clazz.getSuperclass()) {\n            addFieldList(clazz);\n        }\n    }\n",
    "72000": "    public void testMod() {\n        assertEquals(\"Module failed\",\n                     DataHolderFactory.holder(5),\n                     DataHolderFactory.holder(20).mod(DataHolderFactory.holder(15)));\n    }\n",
    "72003": "    public void testMul() {\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Multiplicatio failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));\n        assertEquals(\"Multiplication failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(4.0).mul(DataHolderFactory.holder(5.0)));\n    }\n",
    "72005": "    public void testDiv() {\n        assertEquals(\"Division failed\",\n                     DataHolderFactory.holder(100),\n                     DataHolderFactory.holder(20).mul(DataHolderFactory.holder(5)));\n        assertEquals(\"Division failed\",\n                     DataHolderFactory.holder(100),\n                     DataHolderFactory.holder(20.0).mul(DataHolderFactory.holder(5.0)));\n    }\n",
    "72007": "    public void testSub() {\n        assertEquals(\"Subtraction failed\",\n                     DataHolderFactory.holder(4),\n                     DataHolderFactory.holder(20).sub(DataHolderFactory.holder(16)));\n        assertEquals(\"Subtraction failed\",\n                     DataHolderFactory.holder(4),\n                     DataHolderFactory.holder(20.0).sub(DataHolderFactory.holder(16.0)));\n    }\n",
    "72010": "    public void testAdd() {\n        assertEquals(\"Addition failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(12).add(DataHolderFactory.holder(8)));\n        assertEquals(\"Addition failed\",\n                     DataHolderFactory.holder(20),\n                     DataHolderFactory.holder(12.0).add(DataHolderFactory.holder(8.0)));\n    }\n",
    "72016": "    public void setUp() {\n    }\n",
    "72020": "    public void tearDown() {\n    }\n",
    "72294": "\tprivate void populateFields() {\n\t\tfields = editDVD.getFields();\n\t\t//We also need to add any extra fields that may have been added later\n\t\tfields = Field.addMissingFields(fields);\n\t\tupdateTabel();\n\t\tif(editDVD.getPoster() == null) {\n\t\t\tposter.setIcon(new ImageIcon(getClass().getResource(\"/org/dvdcatalog/dvdc/images/poster.png\")));\n\t\t}\n\t\telse {\n\t\t\tposter.setIcon(new ImageIcon(editDVD.getPoster()));\n\t\t}\n\t}\n",
    "72310": "\tprivate void saveFields() throws RuntimeException {\n\t\teditDVD.setFields(fields);\n\t}\n",
    "72311": "\tpublic Class getColumnClass(int c) {\n\t\ttry {\n            return super.getColumnClass (c);\n\t\t} catch (NullPointerException e) {\n\t\t\treturn String.class;\n\t\t}\n\t}\n",
    "72313": "\tpublic void setData(Vector v) {\n\t\tdata = v;\n\t\tfireTableDataChanged();\n\t}\n",
    "72323": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setLayout(new GridLayout(1, 3));\n\n\t\tpreviousButton.addActionListener(this);\n\t\tbuttonPane.add(previousButton);\n\n\t\tnextButton.addActionListener(this);\n\t\tbuttonPane.add(nextButton);\n\n\t\tsaveButton.addActionListener(this);\n\t\tsaveButton.setEnabled(false);\n\t\tbuttonPane.add(saveButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72324": "\tpublic BufferedImage getPoster() {\n\t\treturn poster;\n\t}\n",
    "72326": "\tpublic void run() {\n\t\tif(info != null) {\n\t\t\tinfo.setBar(bar);\n\t\t\tinfo.start();\n\t\t}\n\t\telse if(imdbSearch != null) {\n\t\t\timdbSearch.start();\n\t\t}\n\t}\n",
    "72330": "\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n",
    "72340": "\tprivate Component createInputComponents() {\n\t\tcards = new JPanel(new CardLayout());\n\t\tcards.add(createCard1(), \"INPUT\");\n\t\tcards.add(createCard2(), \"SEARCHING\");\n\t\tcards.add(createCard3(), \"LIST\");\n\t\tcards.add(createCard4(), \"RETRIEVING\");\n\t\tcards.add(createCard5(), \"INFO\");\n\t\treturn cards;\n\t}\n",
    "72341": "\tpublic String getDirector() {\n\t\treturn director;\n\t}\n",
    "72342": "\tprivate Component createCard1() {\n\t\tJPanel p = new JPanel();\n\t\tp.setAlignmentX(0.5f);\n\t\tp.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\t\tJLabel l = new JLabel(\"Movie Title: \");\n\t\timdbSearch = new JTextField(20);\n        imdbSearch.addActionListener (this);\n\n\t\tp.add(l);\n\t\tp.add(imdbSearch);\n\n\t\tJPanel toReturn = new JPanel();\n\t\ttoReturn.setLayout(new BoxLayout(toReturn, BoxLayout.PAGE_AXIS));\n\t\ttoReturn.add(createTopTitle(\"Enter a movietitle to search for\", \"Step 1 of 5\"));\n\t\ttoReturn.add(p);\n\n\t\treturn toReturn;\n\t}\n",
    "72345": "\tpublic String getGenre() {\n\t\treturn genre;\n\t}\n",
    "72350": "\tpublic String getTagline() {\n\t\treturn tagline;\n\t}\n",
    "72354": "\tpublic String getPlot() {\n\t\treturn plot;\n\t}\n",
    "72360": "\tpublic String getRating() {\n\t\treturn rating;\n\t}\n",
    "72365": "\tpublic Class getColumnClass(int c) {\n\t\ttry {\n\t\t\treturn getValueAt(0, c).getClass();\n\t\t} catch (NullPointerException e) {\n\t\t\treturn String.class;\n\t\t}\n\t}\n",
    "72366": "\tpublic String getPosterUrl() {\n\t\treturn posterUrl;\n\t}\n",
    "72367": "\tpublic void setData(Vector v) {\n        if (v instanceof SortedVector) data = v;\n        else {\n            data.clear ();\n\n            for (int i = 0; i < v.size (); i++)\n                data.add (v.get (i));\n        }\n\t\tfireTableDataChanged();\n\t}\n",
    "72369": "    public void addMouseListenerToTableHeader (final JTable table) {\n        final MouseAdapter adapter = new MouseAdapter () {\n            public void mouseClicked (final MouseEvent e) {\n                final TableColumnModel columnModel = table.getColumnModel ();\n                final int x = columnModel.getColumnIndexAtX (e.getX ());\n                final int col = table.convertColumnIndexToModel (x);\n\n                if(e.getClickCount () == 1 && col != -1) {\n                    ((SortedVector)data).sortBy (col);\n                    fireTableDataChanged ();\n                }\n            }\n        };\n        table.getTableHeader ().addMouseListener (adapter);\n    }\n",
    "72371": "\tpublic String getAddress() {\n\t\treturn address;\n\t}\n",
    "72385": "    public int compare (final Object o1, final Object o2) {\n        final Object[] a = (Object[])o1, b = (Object[])o2;\n\n        return ((String)a[col]).compareTo (b[col]);\n    }\n",
    "72387": "    public boolean equals (final Object o) {\n        return o instanceof ColumnComparator && ((ColumnComparator)o).col == col;\n    }\n",
    "72389": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\t\tbuttonPane.setLayout(new FlowLayout());\n\n\t\tbackButton.addActionListener(this);\n\t\tbackButton.setEnabled(false);\n\t\tbuttonPane.add(backButton);\n\n\t\tnextButton.addActionListener(this);\n\t\tbuttonPane.add(nextButton);\n\n\t\tskipButton.addActionListener(this);\n\t\tbuttonPane.add(skipButton);\n\n\t\tcancelButton.addActionListener(this);\n\t\tbuttonPane.add(cancelButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72390": "    public boolean add (final Object o) {\n        final ColumnComparator cc = new ColumnComparator (col);\n\n        for (int i = 0; i < size (); i++) {\n            final int res = cc.compare (get (i), o) * (ascending ? 1 : -1);\n            if (res > 0) {\n                add (i, o);\n                return true;\n            }\n        }\n        return super.add (o);\n    }\n",
    "72391": "    public void sortBy (final int col) {\n        if (this.col == col || isSorted (col)) reverse ();\n        else {\n            this.col = col;\n            ascending = true;\n            if (size () > 1) Collections.sort (this, new ColumnComparator (col));\n        }\n    }\n",
    "72393": "    public void reverse () {\n        ascending = !ascending;\n        final int lastIdx = size () - 1;\n\n        for (int i = 0; i < lastIdx; i++)\n            add (i, remove (lastIdx));\n    }\n",
    "72397": "\tprivate Component createButtons() {\n\t\tJPanel buttonPane = new JPanel();\n\t\tbuttonPane.setLayout(new FlowLayout());\n\n\t\tnewButton.setName(\"new\");\n\t\tbuttonPane.add(newButton);\n\t\teditButton.setName(\"edit\");\n\t\teditButton.setEnabled(false);\n\t\tbuttonPane.add(editButton);\n\t\tdeleteButton.setName(\"delete\");\n\t\tdeleteButton.setEnabled(false);\n\t\tbuttonPane.add(deleteButton);\n\n\t\treturn buttonPane;\n\t}\n",
    "72402": "\tprivate JTable createTable() {\n\t\tDVDTableModel dvdModel = new DVDTableModel();\n\t\t//dvdModel.setData(dvdCollection);\n\t\tJTable table = new JTable(dvdModel);\n\t\ttable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        dvdModel.addMouseListenerToTableHeader (table);\n\n\t\treturn table;\n\t}\n",
    "72404": "\tpublic void updateTableData(Vector v) {\n\t\tDVDTableModel model = (DVDTableModel) dvdTable.getModel();\n\t\tVector data = new Vector();\n\t\tIterator i = v.iterator();\n\n\t\twhile (i.hasNext()) {\n\t\t\tDVD dvd = (DVD) i.next();\n\t\t\tdata.add(dvd.toArray());\n\t\t}\n\n\t\tmodel.setData(data);\n\t}\n",
    "72407": "\tpublic void enableEditDeleteButtons() {\n\t\teditButton.setEnabled(true);\n\t\tdeleteButton.setEnabled(true);\n\t}\n",
    "72410": "\tpublic void valueChanged(ListSelectionEvent e) {\n        //Ignore extra messages.\n        if (e.getValueIsAdjusting()) return;\n\n        ListSelectionModel lsm = (ListSelectionModel)e.getSource();\n        if (lsm.isSelectionEmpty()) {\n            //no rows are selected\n        \tmainFrame.disableEditDeleteButtons();\n        \tselectedRow = -1;\n\n        } else {\n        \t// a row has been selected\n             selectedRow = lsm.getMinSelectionIndex();\n             mainFrame.enableEditDeleteButtons();\n        }\n\n\t}\n",
    "72413": "\tpublic void disableEditDeleteButtons() {\n\t\teditButton.setEnabled(false);\n\t\tdeleteButton.setEnabled(false);\n\t}\n",
    "72414": "\tpublic void setPermanentType() {\n\t\tpermanent = true;\n\t}\n",
    "72419": "\tprivate void collectTypes() {\n\t\tboolean foundNewType = true;\n\t\tIterator i = types.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tString t = (String) i.next();\n\t\t\tif(t.equalsIgnoreCase(type)) {\n\t\t\t\tfoundNewType = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(foundNewType) {\n\t\t\tLog.print(3, \"New type found, added to the list: \" + type);\n\t\t\ttypes.add(type);\n\t\t}\n\t}\n",
    "72420": "\tpublic void mouseClicked(MouseEvent e){\n\t\tif (e.getClickCount() == 2){\n\t\t\tDVD dvd = (DVD)dvdCollection.get(selectedRow);\n\t\t\topenEditWindow(dvd);\n\t\t}\n\t}\n",
    "72427": "\tpublic void nextPage(ImdbInfo[] imdbAddresses) {\n\t\tCardLayout cl = (CardLayout) (cards.getLayout());\n\t\tcl.next(cards);\n\t\tcardNr++;\n\n\t\tString[] moviesFound = new String[imdbAddresses.length];\n\t\tfor(int i = 0; i < imdbAddresses.length; i++) {\n\t\t\tmoviesFound[i] = imdbAddresses[i].getTitle();\n\t\t}\n\n        //Arrays.sort (moviesFound, new RelevanceComparator (imdbSearch.getText ()));\n\n\t\tlist.setListData(moviesFound);\n\n\t\tthis.imdbAddresses = imdbAddresses;\n\n\t\tbackButton.setEnabled(true);\n\t\tnextButton.setEnabled(true);\n\t}\n",
    "72436": "\tpublic int compareTo(Object o) {\n\t\tif (o instanceof DVD) {\n\t\t\tDVD d = (DVD) o;\n\t\t\tField f = (Field) fields.get(0);\n\t\t\tField f2 = (Field) d.getFields().get(0);\n\t\t\treturn f.getValue().compareTo(f2.getValue());\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "72442": "\tpublic void setFromWizard(boolean wiz) {\n\t\twizard = wiz;\n\t}\n",
    "72448": "\tpublic boolean isFromWizard() {\n\t\treturn wizard;\n\t}\n",
    "72463": "\tpublic void enableMainWindow() {\n\t\tmainFrame.setEnabled(true);\n\t\tmainFrame.setVisible(true);\n\t}\n",
    "72471": "\tpublic void dvdDataUpdated() {\n\t\tCollections.sort(dvdCollection);\n\t\tmainFrame.updateTableData(dvdCollection);\n\t}\n",
    "72479": "\tpublic void addDVD(DVD d) {\n\t\tdvdCollection.add(d);\n\t}\n",
    "72487": "\tpublic boolean hasNextDVD() {\n\t\treturn (selectedRow < dvdCollection.size()-1);\n\t}\n",
    "72498": "\tpublic boolean hasPreviousDVD() {\n\t\treturn (selectedRow > 0);\n\t}\n",
    "72555": "    public void next() {\n        Event e = new Event();\n        e.type = Event.NEXT;\n        e.time = System.currentTimeMillis() + delay;\n        queue.add(e);\n    }\n",
    "72562": "    public void poke(int channel) {\n        Event e = new Event();\n        e.type = Event.POKE;\n        e.channel = channel;\n        e.time = System.currentTimeMillis() + delay;\n        queue.add(e);\n    }\n",
    "72565": "    public char getChannel(int channel) {\n        synchronized (scopes) {\n            return levels[(int)scopes[channel]];\n        }\n    }\n",
    "72570": "    public String getAllChannels() {\n        StringBuffer sb = new StringBuffer();\n        for (int n = 0; n < scopes.length; n++) {\n            sb.append(getChannel(n));\n        }\n        return sb.toString();\n    }\n",
    "72667": "    public double getInitialVolume(int track) {\n    \treturn initialTrackVolume[track];\n    }\n",
    "72680": "    public int getTrackCount() {\n        return getPatternAtPos(0).getTrackCount();\n    }\n",
    "72830": "    private void loadList(LineNumberReader lnr) throws IOException {\n        position = -1;\n        list = new ArrayList<String>();\n        String line = null;\n        while ((line = lnr.readLine()) != null) {\n            line = line.trim();\n            File file = new File(line);\n            if (file.exists() && file.isFile())\n                list.add(line);\n        }\n    }\n",
    "72842": "    public void remove() {\n        list.remove(position);\n    }\n",
    "72849": "    private PlayerThread createPlayerThread(Module module) {\n        Player player = new Player();\n        try {\n            player.init(\n                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),\n                INTERPOLATE);\n            player.load(module);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n        PlayerThread playerthread = new PlayerThread(player);\n        playerthread.pause(true);\n        return playerthread;\n    }\n",
    "72852": "    private Module loadModule(int nextModule) {\n        int mc = fileList.size();\n        while (nextModule <= 0) nextModule += mc;\n        try {\n            theUrl = new URL(protocol, host, port, fileList.get((nextModule + mc) % mc));\n            return ModuleLoader.getModuleLoader(theUrl).getModule();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n",
    "72854": "    private ThreadedPlayer createPlayer(Module module) {\n        ThreadedPlayer player = new ThreadedPlayer();\n        try {\n            player.init(\n                new JavaSoundOutput(new SoundDataFormat(BITS, RATE, CHANNELS), BUFFERSIZE),\n                INTERPOLATE);\n            player.load(module);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        player.pause(true);\n        return player;\n    }\n",
    "72869": "        public void quit() {\n            run = false;\n        }\n",
    "72871": "    public void savePlayList() throws IOException {\n        savePlayList(new File(playListFile),playList);\n        Logger.debug(\"Saved playlist: \" + playListFile);\n    }\n",
    "72996": "    public void start() {\n        running = true;\n        t = new Thread(this);\n        t.start();\n    }\n",
    "72998": "    public void stop() {\n        running = false;\n    }\n",
    "73002": "    public boolean isRunning() {\n        return running;\n    }\n",
    "73003": "    public void pause(boolean pause) {\n        paused = pause;\n    }\n",
    "73007": "    public boolean isPaused() {\n        return paused;\n    }\n",
    "73009": "    public boolean hasFailed() {\n        return error;\n    }\n",
    "73012": "    public Throwable getFailiureCause() {\n        return errorCause;\n    }\n",
    "73085": "        public void setMute(boolean mute) {\n            this.mute = mute;\n        }\n",
    "73130": "    public boolean init(Output output, boolean interpolate) {\n        out = output;\n        lowLevelMixerClass = interpolate ? InterpolatingMixer.class : FastMixer.class;\n        return true;\n    }\n",
    "73132": "    public boolean load(String fileName) throws InvalidFormatException, IOException {\n        ModuleLoader ml = ModuleLoader.getModuleLoader(new File(fileName));\n        Module module = ml.getModule();\n        return load(module);\n    }\n",
    "73133": "    public boolean load(Module module) {\n        int tracks = module.getPatternAtPos(0).getTrackCount();\n\n        Mixer mixer = new DefaultMixer(out, lowLevelMixerClass, tracks);\n\n        ms = new ModuleState(module, mixer);\n\n        // do some mixer initialization...\n        mixer.setAmplification(getDefaultAmplification());\n\n        return out.open();\n    }\n",
    "73135": "    public boolean play() throws PlayerException {\n        return ms.play();\n    }\n",
    "73140": "    public ModuleState getModuleState() {\n        return ms;\n    }\n",
    "73141": "    public Module getModule() {\n        return getModuleState().getModule();\n    }\n",
    "73142": "    public double getDefaultAmplification() {\n        return getModuleState().getModule().getPatternAtPos(0).getTrackCount() / 4.0;\n    }\n",
    "73220": "    private void writeData(byte[] data, int ofs, int len) {\n        int count = 0;\n        int written = 0;\n        while (written < len) {\n            written += sdl.write(data, ofs + written, len - written);\n\n            // take a litle break if we couldn't write everything in 100\n            // tries...\n            count++;\n            if (count >= 100) {\n                try { Thread.sleep(10); } catch (InterruptedException e) { }\n                count = 0;\n            }\n        }\n    }\n",
    "74678": "\tprotected CatalogInquiry getCatalogService(){\n\t\treturn catalogService;\n\t}\n",
    "74681": "\tprotected AccountManagement getAccountService(){\n\t\treturn accountService;\n\t}\n",
    "74685": "\tprotected OrderEntry getOrderService(){\n\t\treturn orderService;\n\t}\n",
    "76469": "    public void shutdownServices() {\n\tif(services==null) return;\n\n        for(Iterator it = services.iterator();\n            it.hasNext();){\n               MPPlugin serv = (MPPlugin)it.next();\n\t       // Shutdown service\n\t       serv.shutdown();\n\t}\n\n\tservices = null;\n    }\n",
    "76483": "    private String getLocationString(SAXParseException ex) {\n\tStringBuffer str = new StringBuffer();\n\n\tString systemId = ex.getSystemId();\n\tif (systemId != null) {\n\t    int index = systemId.lastIndexOf('/');\n\t    if (index != -1) \n\t\tsystemId = systemId.substring(index + 1);\n\t    str.append(systemId);\n\t}\n\tstr.append(':');\n\tstr.append(ex.getLineNumber());\n\tstr.append(':');\n\tstr.append(ex.getColumnNumber());\n\n\treturn str.toString();\n\n    } // getLocationString(SAXParseException):String\n",
    "76485": "    public String getPassword() {\n        return password;\n    }\n",
    "76487": "  public void finished() {\n    workers.removeElement(this);\n    workersStart.remove(this);\n  }\n",
    "76489": "    public void setPassword(String newPassword) {\n        this.password = newPassword;\n    }\n",
    "76490": "  public void interrupt() {\n    Thread t = threadVar.get();\n    if (t != null) {\n      t.interrupt();\n    }\n    threadVar.clear();\n  }\n",
    "76492": "    public String getUserid() {\n        return userid;\n    }\n",
    "76493": "  public Object get() {\n    while (true) {  \n      Thread t = threadVar.get();\n      if (t == null) {\n\treturn getValue();\n      }\n      try {\n\tt.join();\n      }\n      catch (InterruptedException e) {\n\tThread.currentThread().interrupt(); // propagate\n\treturn null;\n      }\n    }\n  }\n",
    "76495": "    public void setUserid(String newUserid) {\n        this.userid = newUserid;\n    }\n",
    "76496": "  public void start(){\n    startThread.start();\n  }\n",
    "76498": "    public String getConnectUrl() {\n        return connectUrl;\n    }\n",
    "76501": "    public void setConnectUrl(String newConnectUrl) {\n        this.connectUrl = newConnectUrl;\n    }\n",
    "76505": "    public String getJdbcDriver() {\n        return jdbcDriver;\n    }\n",
    "76507": "    public void setJdbcDriver(String newJdbcDriver) {\n        this.jdbcDriver = newJdbcDriver;\n    }\n",
    "76525": "    public boolean isDoPopup() {\n        \n        return this.doPopup;\n    }\n",
    "76530": "    public void setDoPopup(boolean doPopup) {\n        this.doPopup = doPopup;\n    }\n",
    "76542": "    public File translateDocument(String inputDocument) throws Exception {\n\n        try {\n            documentTree = FileUtils.getInstance().stringToDocument(\n                    inputDocument);\n        } catch (Exception e) {\n            throw e;\n        }\n\n        result = new StringBuffer();\n        result.append(\"(deffacts patientSummary\");\n        result.append(\"\\n\");\n        buildResult(documentTree.getFirstChild(), \"\");\n        result.append(\"\\n\");\n        result.append(\")\");\n        File f = null;\n        try {\n            f = this.createFileFromStr(result.toString());\n        } catch (Exception e) {\n            throw e;\n        }\n        return f;\n\n    }\n",
    "76545": "    private File createFileFromStr(String str) throws Exception {\n        File file = new File(\"fileForIE.clp\");\n        FileWriter fileWriter;\n        try {\n            fileWriter = new FileWriter(file);\n            BufferedWriter out = new BufferedWriter(fileWriter);\n            out.write(str);\n            out.close();\n        } catch (IOException e) {\n            throw e;\n        }\n        return file;\n    }\n",
    "76607": "    private String getCurrentTime() {\n\n        Date now = new Date();\n        SimpleDateFormat df1 = new SimpleDateFormat(\"yyyyMMdd\");\n\n        return df1.format(now);\n    }\n",
    "76618": "    private String generateDocCode() {\n        // TO DO: come up with document code generation mechanism\n        return \"111\";\n    }\n",
    "76629": "    private String generateDocCodeSystem() {\n        // come up with document code generation mechanism\n        return \"111\";\n    }\n",
    "76670": "    private void registerIDocImport(IDocumentImport iDocumentImport) {\n        this.iDocumentImport = iDocumentImport;\n\n    }\n",
    "76672": "    private void registerIDocExport(IDocumentExport iDocumentExport) {\n        this.iDocumentExport = iDocumentExport;\n\n    }\n",
    "76675": "    private void registerIInference(IInference iInference) {\n        this.iInference = iInference;\n\n    }\n",
    "76679": "    private void registerIAuditLog(IAuditLog iAuditLog) {\n        this.iAuditLog = iAuditLog;\n\n    }\n",
    "76685": "    public boolean hasNext() {\n        return (position < length);\n    }\n",
    "76774": "    public PrimitiveType primitive(String name) {\n        return new PrimitiveType(this, name);\n    }\n",
    "76778": "    public PrimitiveType primitive(Token token) {\n        return primitive(token.getText());\n    }\n",
    "76780": "    public PrimitiveType primitive(Symbol symbol) {\n        return primitive(symbol.toString());\n    }\n",
    "76787": "    protected void visit(List nodes) {\n        Iterator iNodes = nodes.iterator();\n        while (iNodes.hasNext())\n            ((Node) iNodes.next()).apply(this);\n    }\n",
    "76790": "    protected void visit(Node node) {\n        node.apply(this);\n    }\n",
    "76794": "    protected void warning(String msg) {\n        logger.warning(msg);\n        // _errOut.println(msg);\n    }\n",
    "76795": "    public boolean hasErrors() {\n        return _errors;\n    }\n",
    "76804": "    public String getRecommendations(String patientSummary) {\n\n        helper = new SimpleWebServiceHelper();\n        String result = null;\n        try {\n            result = helper.getRecommendations(patientSummary);\n        } catch (EgadssException ex) {\n            logger.log(Level.SEVERE, ex.toString(), ex);\n        }\n        return result;\n\n    }\n",
    "76847": "    private void startSystem() throws Exception {\n        try {\n            this.createComponents();\n\n            this.initializeComponents();\n            log.info(\"EGADSS SYSTEM HAS BEEN STARTED\");\n\n        } catch (Exception e) {\n            throw e;\n        }\n\n    }\n",
    "76930": "    public String velocityClinicalGuideline()throws EgadssException {\n        if(!initialized)\n    throw new EgadssException(\"Configuration must be initialized before fields can be accessed\");\n        return this.velocityClinicalGuideline;\n    }\n",
    "76934": "    public void testValidateDocumentCase1() {\n        try {\n\n            if (documentValidator.validateDocument(FileUtils.getInstance()\n                    .filetoString(\n                            new File(Configuration.getInstance()\n                                    .testPatientXmlUri())), Configuration\n                    .getInstance().patientSummarySchemaUri())) {\n                assertTrue(true);\n            } else\n                assertTrue(false);\n        } catch (Exception e) {\n\n            logger.log(Level.WARNING, \"Case 1 Exception in DocumentValidator.validateDocument method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76946": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfig.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.fine(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76949": "    public void testInitialize() {\n        try {\n            iConfig.initialize(docImpExCompMap);\n            assertTrue(true);\n            logger.fine(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger\n                    .log(Level.WARNING,\n                            \"Exception in testing initialize method: \"\n                                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76952": "    public void testTerminate() {\n        // try{\n        // iConfig.terminate();\n        // logger.fine(\"Testing of terminate method was successful\");\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // logger.log(Level.WARNING, \"Exception in testing initialize method:\n        // \"+e.getMessage(), e);\n        // }\n    }\n",
    "76956": "    public void testImportDocument() {\n        try {\n\n            iDocumentImport.importDocument(xmlDocumentStr);\n            logger.fine(\"Testing of importDocument method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            assertTrue(false);\n            logger.log(Level.WARNING, \"Exception in testing importDocument: \"\n                    + e.getMessage(), e);\n        }\n\n    }\n",
    "76959": "    public void testExportDocument() {\n\n        try {\n            outputFromIeFile = new File(Configuration.getInstance()\n                    .patientResultInstancesClpUri());\n            iDocumentImport.importDocument(xmlDocumentStr);\n            iDocumentExport.exportDocument(outputFromIeFile);\n            logger.fine(\"Testing of exportDocument method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            assertTrue(false);\n            logger.log(Level.WARNING, \"Exception in testing exportDocument: \"\n                    + e.getMessage(), e);\n        }\n\n    }\n",
    "76964": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigTransController.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.fine(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76968": "    public void testInitialize() {\n        try {\n            iConfigTransController.initialize(transControllerCompMap);\n            assertTrue(true);\n            logger.fine(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger\n                    .log(Level.WARNING,\n                            \"Exception in testing initialize method: \"\n                                    + e.getMessage(), e);\n        }\n    }\n",
    "76973": "    public void testParseKnowledgeModuleForXPath() {\n        try {\n\n            preprocessor.parseKnowledgeModuleForXPath(knowledgeModuleFile);\n            logger.fine(\"Testing of parseKnowledgeModuleForXPath method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception in testing preprocessXPath: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n\n        }\n\n    }\n",
    "76975": "    public void testTerminate() {\n        // try{\n        // iConfigTransController.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // }\n    }\n",
    "76980": "    // public void testGetRecommendations() {\n    //\n    // this.testInitialize();\n    //\t\t\n    // //assert knowledge module into InferenceEngine\n    // try{\n    // ie.assertKnowledgeModule(testGuideline, \"Immunizations\");\n    // }catch(Exception e){\n    // assertTrue(false);\n    // }\n    //\t\t\n    // try{\n    //\t\t\t\n    //\t\t\t\n    // resultsDocument=iTrans.getRecommendations(inputDocument);\n    //\t\t\t\n    // assertTrue(true);\n    // }\n    // catch(Exception e){\n    // assertTrue(false);\n    // }\n    // }\n",
    "76987": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigDataStorage.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.info(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76990": "    public void testInitialize() {\n        try {\n            iConfigDataStorage.initialize(dataStorageComMap);\n            assertTrue(true);\n            logger.info(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing initialize method: \"\n                    + e.getMessage(), e);\n        }\n    }\n",
    "76991": "    public void testWriteLogEntry() {\n        try {\n            iAuditLog.writeLogEntry(logEntry);\n            logger.info(\"Testing of writeLogEntry method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing writeLogEntry method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "76992": "    public void testTerminate() {\n        // try{\n        // docImpEx.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // }\n    }\n",
    "76995": "    public void testGenerateAuditReport() {\n        try {\n            report = iAudit.generateAuditReport();\n            if (!(report == null)) {\n                logger.fine(\"Audit report string: \" + report);\n                logger\n                        .info(\"Testing of generateAuditReport method was successful\");\n                assertTrue(true);\n            } else {\n                assertTrue(false);\n            }\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing generateAuditReport method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n\n    }\n",
    "76997": "    public void testSetAndGetAuditingMode() {\n        try {\n            iAudit.setAuditingMode(\"privacy mode\");\n            if ((iAudit.getAuditingMode()).equals(\"privacy mode\")) {\n                logger\n                        .info(\"Testing of setAuditingMode and getAuditingMode methods was successful\");\n                assertTrue(true);\n            } else {\n                assertTrue(false);\n            }\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing setAuditingMode method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n\n    }\n",
    "77002": "    public void testShutSystemDown() {\n        // TO DO: figure out how to test methods that terminate the\n        // application...\n\n        \n\n    }\n",
    "77005": "    public void testViewSystemConfig() {\n        try {\n            config = iSysConfig.viewSystemConfig();\n            logger.fine(\"Config string: \" + config);\n            logger.info(\"Testing of viewSystemConfig method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO,\n                    \"Exception in testing viewSystemConfig method: \"\n                            + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77008": "    public void testGetInfo() {\n        try {\n            String componentInfo = iConfigConfigManager.getInfo();\n            logger.fine(\"Returned Component info: \" + componentInfo);\n            logger.info(\"Testing of getInfo method was successful\");\n            assertTrue(true);\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing getInfo method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77015": "    public void testInitialize() {\n        try {\n            iConfigConfigManager.initialize(configManagerCompMap);\n            assertTrue(true);\n            logger.info(\"Testing of initialize method was successful\");\n        } catch (Exception e) {\n            logger.log(Level.INFO, \"Exception in testing initialize method: \"\n                    + e.getMessage(), e);\n            assertTrue(false);\n        }\n    }\n",
    "77021": "    public void testTerminate() {\n        // try{\n        // iConfigConfigManager.terminate();\n        // assertTrue(true);\n        // }\n        // catch(Exception e){\n        // assertTrue(false);\n        // }\n    }\n",
    "81092": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t}\n",
    "81105": "    public void trace(boolean onoff) {\n      try {\n        serverControl.trace(onoff);\n      } catch (Exception e) {\n          e.printStackTrace();\n        }\n    }\n",
    "81107": "    public void shutdown() {\n        try {\n            serverControl.shutdown();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "81108": "    public void start() {\n        try {\n\t\t\tserverControl.start(pw);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n",
    "81112": "\t public Connection getConnection(String dbUrl, Properties properties) {\n\t\t Connection conn = null;\n\t\t try {\n\t\t\tpw.println(\"[NsSampleWork] Thread id - \"+thread_id + \"; requests database connection, dbUrl =\"+dbUrl);\n\t\t\tconn = DriverManager.getConnection(dbUrl, properties);\n\t\t  } catch (Exception e) {\n\t\t\t System.out.println(\"[NsSampleWork] Thread id - \"+ thread_id + \"; failed to get database connection. Exception thrown:\");\n\t\t\t e.printStackTrace();\n\t\t    }\n\t\t  return conn;\n\t }\n",
    "81114": "\t public void setIsolationLevel(Connection conn, int level) {\n\t\t try {\n\t\t\tconn.setTransactionIsolation(level);\n\t\t } catch (Exception e) {\n\t\t\t pw.println(\"[NsSampleWork] Thread id - \"+ thread_id +\"; setIsolationLevel failed. Exception thrown: \");\n\t\t\t e.printStackTrace();\n\t\t   }\n\t }\n",
    "81131": "\tpublic long length() throws SQLException {\n\t\treturn dataLength;\n\t\t\n\t}\n",
    "81443": "\tprotected byte getCurrChainState() {\n\n\t\tif (!dssIsChainedWithSameID && !dssIsChainedWithDiffID)\n\t\t\treturn DssConstants.DSS_NOCHAIN;\n\n\t\tif (dssIsChainedWithSameID)\n\t\t\treturn DssConstants.DSSCHAIN_SAME_ID;\n\n\t\treturn DssConstants.DSSCHAIN;\n\n\t}\n",
    "81557": "\tprotected void endDss() {\n\t\tendDss(true);\n\t}\n",
    "81745": "\tprivate int getCorrelationID() {\n\n\t\tint cId;\n\t\tif (previousCorrId != DssConstants.CORRELATION_ID_UNKNOWN) {\n\t\t\tif (previousChainByte == DssConstants.DSSCHAIN_SAME_ID)\n\t\t\t// then we have to use the last correlation id we sent.\n\t\t\t\tcId = previousCorrId;\n\t\t\telse\n\t\t\t// get correlation id as normal.\n\t\t\t\tcId = nextCorrelationID++;\n\t\t}\n\t\telse {\n\t\t// must be the case that this is the first DSS we're\n\t\t// writing for this connection (because we haven't\n\t\t// called \"endDss\" yet).  So, get the corr id as\n\t\t// normal.\n\t\t\tcId = nextCorrelationID++;\n\t\t}\n\n\t\treturn cId;\n\n\t}\n",
    "82376": "\tpublic String getHtmlLabelledMessageInstance(LocalizedResource localUtil, String key, String id) {\n\n\t\tif (id == null)\n\t\t\tid = \"\";\n\n\t\treturn (\"<label for='\" + id + \"'>\" + localUtil.getTextMessage(key) +\n\t\t\t\"</label>\");\n\n\t}\n",
    "82378": "\tprivate void printAsContentHeader(String str) {\n\n\t\tout.println(\"<a name=\\\"navskip\\\"></a><h2>\" + str + \"</h2>\");\n\t\treturn;\n\n\t}\n",
    "82382": "\tprivate String escapeSingleQuotes(String str) {\n\n\t\tif ((str == null) || (str.indexOf(\"'\") < 0))\n\t\t\treturn str;\n\n\t\tchar [] cA = str.toCharArray();\n\n\t\t// Worst (and extremely unlikely) case is every \n\t\t// character is a single quote, which means the\n\t\t// escaped string would need to be 4 times as long.\n\t\tchar [] result = new char[4*cA.length];\n\n\t\tint j = 0;\n\t\tfor (int i = 0; i < cA.length; i++) {\n\n\t\t\tif (cA[i] == '\\'') {\n\t\t\t\tresult[j++] = '&';\n\t\t\t\tresult[j++] = '#';\n\t\t\t\tresult[j++] = '3';\n\t\t\t\tresult[j++] = '9';\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult[j++] = cA[i];\n\n\t\t}\n\n\t\treturn new String(result, 0, j);\n\n\t}\n",
    "82653": "\tprivate String  buildPreformattedSqlerrmc(SQLException se) {\n\t\tif (se == null)\n\t\t\treturn \"\";\n\t\t\n\t\tStringBuffer sb = new StringBuffer(); \n\t\t // String buffer to build up message\n\t\tdo {\n\t\t\tsb.append(se.getLocalizedMessage());\n\t\t\tse = se.getNextException();\n\t\t\tif (se != null)\n\t\t\t\tsb.append(SQLERRMC_PREFORMATTED_MESSAGE_DELIMITER + \n\t\t\t\t\t\t\"SQLSTATE: \" + se.getSQLState());\n\t\t} while (se != null);\t\t\t\n\t\treturn sb.toString();\t\t\n\t}\n",
    "82659": "\tprivate String buildTokenizedSqlerrmc(EmbedSQLException se) {\n\t\t\n\t\tString sqlerrmc = \"\";\n\t\tdo {\n\t\t\tString messageId = se.getMessageId();\n\t\t\t// arguments are variable part of a message\n\t\t\tObject[] args = se.getArguments();\n\t\t\tfor (int i = 0; args != null &&  i < args.length; i++)\n\t\t\t\tsqlerrmc += args[i] + SQLERRMC_TOKEN_DELIMITER;\n\t\t\tsqlerrmc += messageId;\n\t\t\tse = (EmbedSQLException) se.getNextException();\n\t\t\tif (se != null)\n\t\t\t{\n\t\t\t\tsqlerrmc += SQLERRMC_MESSAGE_DELIMITER + se.getSQLState() + \":\";\t\t\t\t\n\t\t\t}\n\t\t} while (se != null);\n\t\treturn sqlerrmc;\n\t}\n",
    "83118": "\tprivate void finalizeChain() throws DRDAProtocolException {\n\n\t\twriter.finalizeChain(reader.getCurrChainState(), getOutputStream());\n\t\treturn;\n\n\t}\n",
    "83491": "    public int getTransactionTimeout() throws XAException {\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceEntry(this, \"getTransactionTimeout\");\n        }\n        exceptionsOnXA = null;\n        if (conn_.isPhysicalConnClosed()) {\n            connectionClosedFailure();\n        }\n\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceExit(this, \"getTransactionTimeout\", 0);\n        }\n        return 0; // we don't support transaction timeout\n    }\n",
    "83501": "    public boolean setTransactionTimeout(int seconds) throws XAException {\n        if (conn_.agent_.loggingEnabled()) {\n            conn_.agent_.logWriter_.traceExit(this, \"setTransactionTimeout\", false);\n        }\n        exceptionsOnXA = null;\n        return false; // we don't support transaction timeout in our layer.\n        /* int rc = xaSetTransTimeOut(seconds);\n           if (rc != XAResource.XA_OK)\n             throwXAException(rc); */\n    }\n",
    "84264": "    public String getCatalogName(int column) throws SqlException {\n        checkForClosedStatement();\n        checkForValidColumnIndex(column);\n        return \"\";\n    }\n",
    "84396": "    public void setPKGNAMCBytes(byte[] b, int resultSetHoldability) {\n        if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {\n            agent_.sectionManager_.holdPKGNAMCBytes = b;\n        } else if (resultSetHoldability == org.apache.derby.jdbc.ClientDataSource.CLOSE_CURSORS_AT_COMMIT) {\n            agent_.sectionManager_.noHoldPKGNAMCBytes = b;\n        }\n    }\n",
    "84636": "    public boolean isPhysicalConnClosed() {\n    return !open_ && !availableForReuse_; \n   }\n",
    "84681": "    public void setPKGNAMCBytes(byte[] b) {\n        if (isGenerated) {\n            PKGNAMCBytes = b;\n        } else {\n            agent_.sectionManager_.setPKGNAMCBytes(b, resultSetHoldability_);\n        }\n    }\n",
    "84794": "    public Object run() {\n        this.systemProperties_ = System.getProperties();\n        return this.systemProperties_;\n    }\n",
    "84802": "    public Connection getConnection() throws SQLException {\n        return getConnection(user, password);\n    }\n",
    "84803": "    public Connection getConnection(String user, String password) throws SQLException {\n        // Jdbc 2 connections will write driver trace info on a\n        // datasource-wide basis using the jdbc 2 data source log writer.\n        // This log writer may be narrowed to the connection-level\n        // This log writer will be passed to the agent constructor.\n\n        LogWriter dncLogWriter = super.computeDncLogWriterForNewConnection(\"_sds\");\n        updateDataSourceValues(tokenizeAttributes(connectionAttributes, null));\n        return new NetConnection((NetLogWriter) dncLogWriter, user, password, this, -1, false);\n    }\n",
    "84869": "\tprotected void runTestSet() throws T_Fail {\n\n\t\t// Set up the expected error handling\n\t\ttry {\n\t\t\t\n\t\t\tS001();\n\t\t\tS002();\n\t\t\tS003();\n\t\t\tS004();\n\t\t\tS005();\n\t\t\tS007();\n\t\t\tS008();\n\n\t\t\tM001();\n\t\t\tM002();\n\t\t\tM003();\n\t\t\tM004();\n\t\t\t\n\n\t\t} catch (StandardException se) {\n\n\t\t\tthrow T_Fail.exceptionFail(se);\n\n\t\t}\n\t}\n",
    "84901": "\tpublic void clearIdentity() {\n\t\tkeyValue = null;\n\t}\n",
    "84903": "\tpublic Object getIdentity() {\n\t\treturn keyValue;\n\t}\n",
    "84907": "\tpublic void lockEvent(Latch lockInfo) {\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(lockInfo.getQualifier() == null);\n\n\t\tlatch = lockInfo;\n\n\t\tcount++;\n\t}\n",
    "84913": "\tpublic void unlockEvent(Latch lockInfo) {\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(lockInfo.getQualifier() == null);\n\t\t\n\t\tcount--;\n        if (SanityManager.DEBUG)\n            SanityManager.ASSERT(count >= 0);\n\t\tlatch = null;\n\t}\n",
    "84927": "\tpublic boolean isDirty() {\n\t\tsynchronized (this) {\n\t\t\treturn isDirty;\n\t\t}\n\t}\n",
    "84948": "\tprotected String getModuleToTestProtocolName() {\n\t\treturn org.apache.derby.iapi.reference.Module.CacheFactory;\n\t}\n",
    "84958": "\tprotected void t_findCachedFail(CacheManager cm, Object key) throws StandardException, T_Fail {\n\t\tCacheable entry = cm.findCached(key);\n\t\tif (entry != null) {\n\t\t\tthrow T_Fail.testFailMsg(\"found cached item unexpectedly\");\n\t\t}\n\t}\n",
    "84959": "\tprotected Cacheable t_findCachedSucceed(CacheManager cm, Object key) throws StandardException, T_Fail {\n\t\tCacheable entry = cm.findCached(key);\n\t\tif (entry == null) {\n\t\t\tthrow T_Fail.testFailMsg(\"expected item to be in cache\");\n\t\t}\n\n\t\tif (!entry.getIdentity().equals(key))\n\t\t\tthrow T_Fail.testFailMsg(\"item returned does not match key\");\n\t\treturn entry;\n\t}\n",
    "84961": "\tprotected void t_findFail(CacheManager cm, Object key) throws T_Fail, StandardException {\n\t\tCacheable entry = cm.find(key);\n\t\tif (entry != null) {\n\t\t\tthrow T_Fail.testFailMsg(\"found item unexpectedly\");\n\t\t}\n\t}\n",
    "84963": "\tprotected Cacheable t_findSucceed(CacheManager cm, Object key) throws T_Fail, StandardException {\n\t\tCacheable entry = cm.find(key);\n\t\tif (entry == null) {\n\t\t\tthrow T_Fail.testFailMsg(\"expected item to be found\");\n\t\t}\n\t\tif (!entry.getIdentity().equals(key))\n\t\t\tthrow T_Fail.testFailMsg(\"item returned does not match key\");\n\n\t\treturn entry;\n\t}\n",
    "84995": "\tprotected boolean FAIL(String msg) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"] FAIL - \" + msg);\n\t\treturn false;\n\t}\n",
    "84996": "\tprotected boolean PASS(String testName) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"] Pass - \"+shortModuleToTestName +\" \" + testName);\n\t\treturn true;\n\t}\n",
    "84997": "\tpublic void REPORT(String msg) {\n\t\tout.println(\"[\" + Thread.currentThread().getName() + \"]     \" + msg);\n\t}\n",
    "85040": "\tprotected void joinSetupTest() throws T_Fail {\n\n\t\tT_Fail.T_ASSERT(factory != null, \"raw store factory not setup \");\n\t\tT_Fail.T_ASSERT(contextService != null, \"Context service not setup \");\n\t\tT_Fail.T_ASSERT(commonContainer != -1, \"common container not setup \");\n\n\t\tt_util = new T_Util(factory, lf, contextService);\n\n\t}\n",
    "85098": "\tpublic Page t_getLastPage(ContainerHandle c) throws T_Fail, StandardException {\n\n\t\tPage page = c.getFirstPage();\n\t\tif (page != null)\n\t\t{\n\t\t\tPage nextPage;\n\t\t\twhile((nextPage = c.getNextPage(page.getPageNumber())) != null)\n\t\t\t{\n\t\t\t\tpage.unlatch();\n\t\t\t\tpage = nextPage;\n\t\t\t}\n\t\t}\n\n\t\treturn page;\n\t}\n",
    "85100": "\tpublic Page t_getPage(ContainerHandle c, long pageNumber) throws T_Fail, StandardException {\n\n\t\tPage page = c.getPage(pageNumber);\n\t\tif (page == null)\n\t\t\tthrow T_Fail.testFailMsg(\"fail to get page \" + pageNumber + \" from container \" + c);\n\n\t\tif (page.getPageNumber() != pageNumber)\n\t\t\tthrow T_Fail.testFailMsg(\"page expected to have page number \" +\n\t\t\t\tpageNumber + \", has \" + page.getPageNumber() + \" Container \" + c);\n\n\t\treturn page;\n\t}\n",
    "85104": "\tpublic Page t_addPage(ContainerHandle c) throws T_Fail, StandardException {\n\n\t\tPage page = c.addPage();\n\n\t\tif (page == null)\n\t\t\tthrow T_Fail.testFailMsg(\"addPage() returned null\");\n\n\t\treturn page;\n\t}\n",
    "85120": "\tpublic void t_genRandomFile(String fileName, String mode, int size) throws T_Fail {\n\n\t\tRandomAccessFile iFile = null;\n\t\ttry {\n\t\t\tiFile = new RandomAccessFile(fileName, mode);\n\t\t\tfor (int i = 0; i < size; i++){\n\t\t\t\tbyte b = (byte) (i & 0xff);\n\t\t\t\tb = (byte) (((b >= ' ') && (b <= '~')) ? b : ' ');\n\t\t\t\tiFile.write(b);\n\t\t\t}\n\t\t\tiFile.close();\n\t\t} catch (FileNotFoundException fnfe) {\n\t\t\tthrow T_Fail.testFailMsg(\"cannot create new file\");\n\t\t} catch (IOException ioe) {\n\t\t\tthrow T_Fail.testFailMsg(\"io error, test failed\");\n\t\t}\n\n\t}\n",
    "85124": "\tpublic FormatableBitSet getValidColumns() {\n\t\treturn validColumns;\n\t} \n",
    "85127": "\tpublic boolean needsRowLocation() {\n\t\treturn false;\n\t}\n",
    "85129": "\tpublic void rowLocation(RowLocation rl) {\n\n\t\trl = null;\n\t}\n",
    "85366": "\tprotected void runTestSet() throws T_Fail {\n\n\t\t// get a utility helper\n\n\t\tContextManager cm1 = contextService.newContextManager();\n\t\tcontextService.setCurrentContextManager(cm1);\n\n\t\ttry {\n\n\t\t\trunCostEstimationTests();\n\t\t\trunAllocationTests();\n\n\t\t} catch (StandardException se) {\n\n\t\t\tcm1.cleanupOnError(se);\n\t\t\tthrow T_Fail.exceptionFail(se);\n\t\t}\n\t\tfinally {\n\n\t\t\tcontextService.resetCurrentContextManager(cm1);\n\t\t}\n\t}\n",
    "85374": "\tprotected void joinSetupTest() throws T_Fail {\n\n\t\tT_Fail.T_ASSERT(factory != null, \"raw store factory not setup \");\n\t\tT_Fail.T_ASSERT(lf != null, \"Lock factory not setup \");\n\t\tT_Fail.T_ASSERT(contextService != null, \"Context service not setup \");\n\n\t\ttestRollback = testRollbackProperty;\n\n\t}\n",
    "85419": "\tprotected void T000() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt1.close();\n\n\n\t\tt1 = t_util.t_startInternalTransaction();\n\n\t\tt1.close();\n\n\t\tt1 = t_util.t_startTransaction();\n\t\tTransaction ti = t_util.t_startInternalTransaction();\n\n\t\tti.close();\n\n\t\tt1.close();\n\n\t\tPASS(\"T000\");\n\t}\n",
    "85422": "\tprotected void T001() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_commit(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T001\");\n\t}\n",
    "85427": "\tprotected void T002() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T002\");\n\t}\n",
    "85432": "\tprotected void T003() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_commit(t1);\n\n\t\tt_util.t_commit(t1);\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T003\");\n\t}\n",
    "85438": "\tprotected void T004() throws T_Fail, StandardException {\n\n\t\tTransaction t1 = t_util.t_startTransaction();\n\n\t\tt_util.t_abort(t1);\n\n\t\tt_util.t_commit(t1);\n\n\t\tt_util.t_abort(t1);\n\n\t\tt1.close();\n\n\t\tPASS(\"T004\");\n\t}\n",
    "85480": "\tprotected void C010(int segment) throws T_Fail, StandardException {\n\n\t\tTransaction t = t_util.t_startTransaction();\n\n\t\tlong cid = t_util.t_addContainer(t, segment);\n\n\t\tt_util.t_commit(t);\n\t\n\t\tContainerHandle c1, c2;\n\n\t\tc1 = t_util.t_openContainer(t, segment, cid, true);\n\t\tc1 = t_util.t_openContainer(t, segment, cid, true);\n\t\tt_util.t_dropContainer(t, segment, cid);\t// cleanup\n\n\n\t\tt_util.t_commit(t);\n\t\tt.close();\n\n\t\tPASS(\"C010\");\n\n\t}\n",
    "85485": "\tprotected void C011() throws T_Fail, StandardException {\n\n\t\tTransaction t = t_util.t_startTransaction();\n\n\t\tlong cid = t_util.t_addContainer(t, 0);\n\n\t\tt_util.t_commit(t);\n\t\n\t\tContainerHandle c1, c2;\n\n\t\tc1 = t_util.t_openContainer(t, 0, cid, false);\n\t\tc1 = t_util.t_openContainer(t, 0, cid, true);\n\n\t\tt_util.t_dropContainer(t, 0, cid);\t// cleanup\n\n\t\tt_util.t_commit(t);\n\t\tt.close();\n\t\tPASS(\"C011\");\n\n\t}\n",
    "86122": "\tprotected Statement createFloatStatementForStateChecking(Connection conn) throws SQLException {\n\t\tStatement s = internalCreateFloatStatementForStateChecking(conn);\n\t\ts.setCursorName(\"StokeNewington\");\n\t\ts.setFetchDirection(ResultSet.FETCH_REVERSE);\n\t\ts.setFetchSize(444);\n\t\ts.setMaxFieldSize(713);\n\t\ts.setMaxRows(19);\n\n\t\tshowStatementState(\"Create \", s);\n\t\treturn s;\n\t}\n",
    "86148": "\tstatic private void expectedException (SQLException se, String expectedSQLState) {\n           if( se.getSQLState() != null && (se.getSQLState().equals(expectedSQLState))) { \n                System.out.println(\"PASS -- expected exception\");\n                while (se != null) {\n                    System.out.println(\"SQLSTATE(\"+se.getSQLState()+\"): \"+se.getMessage());\n                    se = se.getNextException();\n                }\n            } else {\n\t        System.out.println(\"FAIL--Unexpected SQLException: \" +\n\t\t\t\t\t\t\t   \"SQLSTATE(\" +se.getSQLState() + \")\" +\n\t\t\t\t\t\t\t   se.getMessage());\n\t        se.printStackTrace(System.out);\n\t    }\n\t}\n",
    "86149": "     static private void unexpectedSQLException(SQLException se) {\n\t System.out.println(\"FAIL -- Unexpected Exception: \"+ \n\t\t\t\t\t\t\"SQLSTATE(\" +se.getSQLState() +\")\" +\n\t\t\t\t\t\tse.getMessage());\n\t se.printStackTrace(System.out);\n     }\n",
    "86190": "\tprotected void dumpRS(ResultSet rs) throws SQLException {\n\t\tdumpRS(IGNORE_PROC_ID, rs);\n\t}\n",
    "86192": "\tprotected Connection createConnection(String[] args) throws Exception {\n\n\t\tConnection con;\n\n\t\t// use the ij utility to read the property file and\n\t\t// make the initial connection.\n\t\tij.getPropertyArg(args);\n\t\tcon = ij.startJBMS();\n\t\t//con.setAutoCommit(true); // make sure it is true\n\t\tcon.setAutoCommit(false);\n\n\t\treturn con;\n\n\t}\n",
    "86244": "\tpublic void unlatch(Latch heldLatch) {\n\t\tlockTable.unlock(heldLatch, 1);\n\t}\n",
    "86250": "\tprotected boolean setPotentiallyGranted() {\n\t\tif (!potentiallyGranted) {\n\t\t\tpotentiallyGranted = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "86252": "\tprotected void clearPotentiallyGranted() {\n\t\tpotentiallyGranted = false;\n\t}\n",
    "86261": "\tpublic Control shallowClone() {\n\t\treturn this;\n\t}\n",
    "86264": "\tpublic void unlockGroup(Object compatabilitySpace, Object group) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (SanityManager.DEBUG_ON(Constants.LOCK_TRACE)) {\n\t\t\t\tD_LockControl.debugLock(\"Lock Unlock Group: \", compatabilitySpace, group);\n\t\t\t}\n\t\t}\n\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn;\n\n\t\tls.unlockGroup(lockTable, group);\n\t}\n",
    "86275": "\tpublic boolean anyoneBlocked() {\n\t\treturn lockTable.anyoneBlocked();\n\t}\n",
    "86278": "\tpublic boolean areLocksHeld(Object compatabilitySpace, Object group) {\n\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn false;\n\n\t\t// there is a window where someone could remove the LockSpace from the \n        // spaces Hashtable, since we do not hold the spaces' monitor. This is \n        // Ok as the LockSpace will have no locks and this method will \n        // correctly return false.\n\n\t\treturn ls.areLocksHeld(group);\n\t}\n",
    "86280": "\tpublic boolean areLocksHeld(Object compatabilitySpace) {\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn false;\n\t\treturn !ls.isEmpty();\n\t}\n",
    "86286": "\tpublic void clearLimit(Object compatabilitySpace, Object group) {\n\t\tLockSpace ls = (LockSpace) get(compatabilitySpace);\n\t\tif (ls == null)\n\t\t\treturn;\n\n\t\tls.clearLimit(group);\n\t}\n",
    "86287": "\tpublic ActiveLock firstWaiter() {\n\t\tif ((waiting == null) || waiting.isEmpty())\n\t\t\treturn null;\n\t\treturn (ActiveLock) waiting.get(0);\n\t}\n",
    "86289": "\tpublic Lockable getLockable() {\n\t\treturn ref;\n\t}\n",
    "86301": "\tpublic void addWaiters(Dictionary waiters) {\n\t\t\n\t\tif ((waiting == null) || waiting.isEmpty())\n\t\t\treturn;\n\n\t\tObject previous = this;\n\t\tfor (ListIterator li = waiting.listIterator(); li.hasNext(); ) {\n\n\t\t\tActiveLock waitingLock = ((ActiveLock) li.next());\n\n\t\t\tObject waiter = waitingLock.getCompatabilitySpace();\n\n\t\t\twaiters.put(waiter, waitingLock);\n\t\t\twaiters.put(waitingLock, previous);\n\t\t\tprevious = waitingLock;\n\t\t}\n\t}\n",
    "86311": "\tprivate Object popFrontWaiter(List waiting, LockSet ls) {\n\t\t// Maintain count of waiters\n\t\tls.oneLessWaiter();\n\n\t\t// Remove and return the first lock request\n\t\treturn waiting.remove(0);\n\t}\n",
    "86329": "    private void cpArray( String toCp, int start, int end )\n    {   // build a field in the output string\n        int i = 0;\n        int totalAllowWrite = end - start;\n\n        if( toCp != null )\n        {\n            for( ; i < toCp.length() ; i++ )\n            {\n                if( (totalAllowWrite-i) == 0 )\n                    break;\n\n                outputRow[ i + start ] = toCp.charAt(i);\n            }\n        }\n        for( ; i + start != end; i++ )\n            outputRow[ i + start ] = ' ';\n\n        outputRow[ end ] = SEPARATOR;\n    }\n",
    "86343": "\tpublic void notifyModifyClasspath(String classpath) throws StandardException {\n\n\t\tif (applicationLoader != null) {\n\t\t\tapplicationLoader.modifyClasspath(classpath);\n\t\t}\n\t}\n",
    "86362": "\tprivate InputStream getRawStream(ZipFile zip, String name) {\n\n\t\ttry {\n\t\t\tZipEntry ze = zip.getEntry(name);\n\t\t\tif (ze == null)\n\t\t\t\treturn null;\n\n\t\t\treturn zip.getInputStream(ze);\n\t\t} catch (IOException ioe) {\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "86364": "\tprivate InputStream getRawStream(InputStream in, String name) { \n\n\t\tZipInputStream zipIn = null;\n\t\ttry {\n\t\t\tzipIn = new ZipInputStream(in);\n\n\t\t\tZipEntry ze;\n\t\t\twhile ((ze = jf.getNextEntry(zipIn)) != null) {\n\n\t\t\t\tif (ze.getName().equals(name)) {\n\t\t\t\t\tLimitInputStream lis = new LimitInputStream(zipIn);\n\t\t\t\t\tlis.setLimit((int) ze.getSize());\n\t\t\t\t\treturn lis;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzipIn.close();\n\n\t\t} catch (IOException ioe) {\n\t\t\tif (zipIn != null) {\n\t\t\t\ttry {\n\t\t\t\t\tzipIn.close();\n\t\t\t\t} catch (IOException ioe2) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "86371": "\tprivate HeaderPrintWriter makeStream() {\n\n\t\t// get the header\n\t\tPrintWriterGetHeader header = makeHeader();\n\t\tHeaderPrintWriter hpw = makeHPW(header);\n\n\t\t// If hpw == null then no properties were specified for the stream\n\t\t// so use/create the default stream.\n\t\tif (hpw == null)\n\t\t\thpw = createDefaultStream(header);\n\t\treturn hpw;\n\t}\n",
    "86372": "\tprivate PrintWriterGetHeader makeHeader() {\n\n\t\treturn new BasicGetLogHeader(true, true, (String) null);\n\t}\n",
    "86373": "\tprivate HeaderPrintWriter makeHPW(PrintWriterGetHeader header) {\n\n\t\t// the type of target is based on which property is used\n\t\t// to set it. choices are file, method, field, stream\n\n\t\tString target = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_FILE_PROPERTY);\n\t\tif (target!=null)\n\t\t\treturn makeFileHPW(target, header);\n\n\t\ttarget = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_METHOD_PROPERTY);\n\t\tif (target!=null) \n\t\t\treturn makeMethodHPW(target, header);\n\n\t\ttarget = PropertyUtil.\n                   getSystemProperty(Property.ERRORLOG_FIELD_PROPERTY);\n\t\tif (target!=null) \n\t\t\treturn makeFieldHPW(target, header);\n\n\t\treturn null;\n\t}\n",
    "86379": "\tprivate HeaderPrintWriter createDefaultStream(PrintWriterGetHeader header) {\n\t\treturn makeFileHPW(\"derby.log\", header);\n\t}\n",
    "86380": "\tprivate HeaderPrintWriter useDefaultStream(PrintWriterGetHeader header) {\n\n\t\treturn new BasicHeaderPrintWriter(System.err, header, false, \"System.err\");\n\t}\n",
    "86384": "\tpublic void keepAfterSearch() {\n\t\tkeepCount++;\n\t\tsetUsed(true);\n\t}\n",
    "86392": "\tpublic Cacheable getEntry() {\n\t\treturn entry;\n\t}\n",
    "86414": "\tpublic void cleanAll() throws StandardException {\n\t\tstat.cleanAll++;\n\t\tcleanCache((Matchable) null);\n\t}\n",
    "86417": "\tpublic void clean(Matchable partialKey) throws StandardException {\n\n\t\tcleanCache(partialKey);\n\t}\n",
    "86422": "\tpublic void shutdown() throws StandardException {\n\n\t\tif (cleaner != null) {\n\t\t\tcleaner.unsubscribe(myClientNumber);\n\t\t\tcleaner = null;\n\t\t}\n\n\t\tsynchronized (this) {\n\t\t\tactive = false;\n\t\t}\n\n\t\tageOut();\n\t\tcleanAll();\n\t\tageOut();\n\t}\n",
    "86461": "\tpublic Object put(Object key, Object value) {\n\t\tObject ref = defaults.put(key, value);\n\t\tif (!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX))\n\t\t\tupdate();\n\t\treturn ref;\n\t}\n",
    "86462": "\tpublic Object remove(Object key) {\n\t\tObject ref = defaults.remove(key);\n\t\tif ((ref != null) &&\n\t\t\t(!((String) key).startsWith(Property.PROPERTY_RUNTIME_PREFIX)))\n\t\t\tupdate();\n\t\treturn ref;\n\t}\n",
    "86474": "\tpublic void shutdown(Object serviceModule) {\n\t\tif (serviceModule == null)\n\t\t\treturn;\n\n\t\tTopService ts = findTopService(serviceModule);\n\t\tif (ts == null)\n\t\t\treturn;\n\n\t\t// shutdown() returns false if the service is already being shutdown\n\t\tboolean removeService = true;\n\t\ttry {\n\t\t\tremoveService = ts.shutdown();\n\t\t} finally {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (removeService) {\n\t\t\t\t\tboolean found = services.removeElement(ts);\n\t\t\t\t\tif (SanityManager.DEBUG) {\n\t\t\t\t\t\tSanityManager.ASSERT(found, \"service was not found \" + serviceModule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "86484": "\tpublic String getServiceName(Object serviceModule) {\n\n\t\tTopService ts = findTopService(serviceModule);\n\n\t\tif (ts == null)\n\t\t\treturn null;\n\n\t\treturn ts.getServiceType().getUserServiceName(ts.getKey().getIdentifier());\n\t}\n",
    "86488": "\tprotected long removeIdentity(CachedItem item) {\n\n        long shrink = 1;\n        \n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(!item.isKept(), \"item is kept\");\n\t\t\tSanityManager.ASSERT(item.isValid(), \"item is not valid\");\n\n\t\t}\n\n        if( useByteCount)\n            shrink = ((SizedCacheable) item.getEntry()).getSize();\n\t\tremove(item.getEntry().getIdentity());\t\t\t\t\n\t\titem.setValidState(false);\n        validItemCount--;\n\t\titem.getEntry().clearIdentity();\n        if( useByteCount)\n        {\n            shrink -= ((SizedCacheable) item.getEntry()).getSize();\n            currentByteCount -= shrink;\n        }\n        return shrink;\n\t}\n",
    "86493": "\tpublic PersistentService getServiceType(Object serviceModule) {\n\t\tTopService ts = findTopService(serviceModule);\n\n\t\tif (ts == null)\n\t\t\treturn null;\n\n\t\treturn ts.getServiceType();\n\t}\n",
    "86522": "\tprotected void report(String message)\t{\n\n\t\tPrintWriter tpw = getTempWriter();\n\n\t\tif (tpw != null)\n\t\t\ttpw.println(message);\n\n\t\tif (systemStreams != null)\n\t\t\tsystemStreams.stream().printlnWithHeader(message);\n\t}\n",
    "86570": "\tprotected void bootServiceProviders() {\n\n\t\tif (serviceProviders == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Enumeration e = serviceProviders.keys(); e.hasMoreElements(); ) {\n\n\t\t\tString serviceType = (String) e.nextElement();\n\t\t\tObject provider = serviceProviders.get(serviceType);\n\n\t\t\t// see if this provider can live in this environment\n\t\t\tif (!BaseMonitor.canSupport(provider, (Properties) null)) {\n\t\t\t\tserviceProviders.remove(serviceType);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n",
    "86574": "\tprotected void bootPersistentServices() {\n\t\tfor (Enumeration e = new ProviderEnumeration( applicationProperties); ; ) {\n\n\t\t\tPersistentService provider = (PersistentService) e.nextElement();\n\t\t\tbootProviderServices(provider);\n\t\t}\n\n\t}\n",
    "86575": "\tpublic int getRelativePC() {\n\t\treturn cout.size() - codeOffset;\n\t}\n",
    "86576": "\tpublic LocalField addField(String javaType, String name, int modifiers) {\n\n\t\tType type = factory.type(javaType);\n\t\t// put it into the class holder right away.\n\t\tClassMember field = classHold.addMember(name, type.vmName(), modifiers);\n\t\tint cpi = classHold.addFieldReference(field);\n\n\t\treturn new BCLocalField(type, cpi);\n\t}\n",
    "86595": "\tpublic String getName() {\n\t\treturn myName;\n\t}\n",
    "86600": "\tpublic void addThrownException(String exceptionClass) {\n\t\t\n\t\t// cannot add exceptions after code generation has started.\n\t\t// Allowing this would cause the method overflow/split to\n\t\t// break as the top-level method would not have the exception\n\t\t// added in the sub method.\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (myCode.getRelativePC() != 0)\n\t\t\t\tSanityManager.THROWASSERT(\"Adding exception after code generation \" + exceptionClass\n\t\t\t\t\t\t+ \" to method \" + getName());\n\t\t}\n\n\t\tif (thrownExceptions == null)\n\t\t\tthrownExceptions = new Vector();\n\t\tthrownExceptions.addElement(exceptionClass);\n\t}\n",
    "86601": "\tpublic void complete() {\n\t\t// write exceptions attribute info\n\t\twriteExceptions();\n\t\t\n\t\t// get the code attribute to put itself into the class\n\t\t// provide the final header information needed\n\t\tmyCode.complete(modClass, myEntry, maxStack, currentVarNum);\n\t}\n",
    "86635": "\tpublic UUIDFactory getUUIDFactory()\t{\n\n\t\treturn uuidFactory;\n\t}\n",
    "86648": "\tpublic ResourceBundle getBundle(String messageId) {\n\t\tContextManager cm;\n\t\ttry {\n\t\t\tcm = ContextService.getFactory().getCurrentContextManager();\n\t\t} catch (ShutdownException se) {\n\t\t\tcm = null;\n\t\t}\n\n\t\tif (cm != null) {\n\t\t\treturn MessageService.getBundleForLocale(cm.getMessageLocale(), messageId);\n\t\t}\n\t\treturn null;\n\t}\n",
    "86663": "\tpublic void getStaticField(String declaringClass, String fieldName, String fieldType) {\n\t\tgetField(VMOpcode.GETSTATIC, declaringClass, fieldName, fieldType);\n\t}\n",
    "86667": "\tpublic void setField(LocalField field) {\n\t\tBCLocalField lf = (BCLocalField) field;\n\t\tType lt = lf.type;\n\n\t\tputField(lf.type, lf.cpi, false);\n\n\t\tif (stackDepth == 0)\n\t\t\toverflowMethodCheck();\n\t}\n",
    "86669": "\tpublic void putField(LocalField field) {\n\t\tBCLocalField lf = (BCLocalField) field;\n\t\tType lt = lf.type;\n\n\t\tputField(lf.type, lf.cpi, true);\n\t}\n",
    "86675": "\tpublic void boot(boolean create, Properties properties) throws StandardException {\n\n\t\tCacheFactory cf =\n\t\t\t(CacheFactory) Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);\n\n\t\t/*\n\t\t** The initial and maximum cache sizes are based on experiments\n\t\t** that I did with some of the language tests.  I found that\n\t\t** the size quickly grew to about 40, then continued to grow\n\t\t** slowly after that.\n\t\t**\n\t\t**\t\t\t-\tJeff\n\t\t*/\n\t\tvmTypeIdCache =\n\t\t\tcf.newCacheManager(\n\t\t\t\tthis,\n\t\t\t\t\"VMTypeIdCache\",\n\t\t\t\t64,\n\t\t\t\t256);\n\t}\n",
    "86677": "\tpublic void stop() {\n\t}\n",
    "86700": "\tprotected void TC004all() throws StandardException, T_Fail {\n\t\tint[] modes = {\n\t\t\t0,\n\t\t\tContainerHandle.MODE_DROP_ON_COMMIT,\n\t\t\tContainerHandle.MODE_TRUNCATE_ON_COMMIT\n\t\t};\n\n\t\tfor (int m1 = 0; m1 < modes.length; m1++) {\n\t\t\tfor (int m2 = 0; m2 < modes.length; m2++) {\n\t\t\t\tfor (int m3 = 0; m3 < modes.length; m3++) {\n\n\t\t\t\t\tTC004(m1, m2, m3, false, false);\n\t\t\t\t\tTC004(m1, m2, m3, false, true);\n\t\t\t\t\tTC004(m1, m2, m3, true, false);\n\t\t\t\t\tTC004(m1, m2, m3, true, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n",
    "86718": "  public ResultSetMetaData getMetaData() {\n    return importResultSetMetaData;\n  }\n",
    "86719": "  public int getRow() throws SQLException {\n    return (importReadData.getCurrentRowNumber());\n  }\n",
    "86721": "  public void close() throws SQLException {\n    try {\n\t\tif(importReadData!=null)\n\t\t\timportReadData.closeStream();\n    } catch (Exception ex) {\n\t\tthrow LoadError.unexpectedError(ex);\n    }\n  }\n",
    "86736": "\tprotected ImportReadData getImportReadData() throws Exception {\n\t\treturn new ImportReadData(inputFileName, controlFileReader);\n\t}\n",
    "86758": "  protected void ignoreFirstRow() throws Exception {\n    readNextToken(recordSeparator, 0, recordSeparatorLength, true);\n  }\n",
    "86775": "  public void closeStream() throws Exception {\n    if (streamOpenForReading) {\n       bufferedReader.close();\n       streamOpenForReading = false;\n    }\n  }\n",
    "86834": "  public int getCurrentRowNumber() {\n    return lineNumber;\n  }\n",
    "86844": "\tpublic ResultColumnDescriptor getColumnDescriptor(int position) {\n\t\treturn columns[position-1];\n\t}\n",
    "86861": "\tpublic boolean isActive() {\n\t\treturn active;\n\t}\n",
    "86981": "\tpublic\tint\tgetTypeFormatId()\t{\n\t\treturn majorVersionNumber == DataDictionary.DD_VERSION_CS_5_1 ?\n\t\t\tStoredFormatIds.DD_ARWEN_VERSION_ID : StoredFormatIds.DD_DB2J72_VERSION_ID;\n\t}\n",
    "87063": "\tpublic void setDroppedInSavepointLevel(int droppededInSavepointLevel) {\n    this.droppededInSavepointLevel = droppededInSavepointLevel;\n  }\n",
    "87076": "\tpublic GenericPreparedStatement getPreparedStatement() {\n\t\treturn ps;\n\t}\n",
    "87090": "\tpublic void resetSavePoint() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (SanityManager.DEBUG_ON(\"traceSavepoints\"))\n\t\t\t{\n\t\t\t\tSanityManager.DEBUG_PRINT(\n\t\t\t\t\t\"GenericStatementContext.resetSavePoint()\",\n\t\t\t\t\tinternalSavePointName);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (inUse && setSavePoint)\n\t\t{\t\t\n\t\t\t// RESOLVE PLUGIN ???. For the plugin, there will be no transaction controller\n\t\t\tif ( tc != null ) { tc.setSavePoint(internalSavePointName, null); }\n\t\t\t// stage buffer management\n\t\t}\n\t}\n",
    "87117": "\tpublic void setParentRollback() {\n\t\trollbackParentContext = true;\n\t}\n",
    "87118": "\tpublic void setSystemCode() {\n\t\tisSystemCode = true;\n\t}\n",
    "87120": "\tpublic boolean getSystemCode() {\n\t\treturn isSystemCode;\n\t}\n",
    "87135": "\tpublic ExecutionFactory\tgetExecutionFactory() {\n\t\treturn ef;\n\t}\n",
    "87139": "\tpublic OptimizerFactory\tgetOptimizerFactory() {\n\t\treturn of;\n\t}\n",
    "87140": "\tpublic TypeCompilerFactory getTypeCompilerFactory() {\n\t\treturn tcf;\n\t}\n",
    "87141": "\tpublic DataValueFactory\t\tgetDataValueFactory() {\n\t\treturn dvf;\n\t}\n",
    "87144": "\tpublic boolean canSupport(Properties startParams) {\n\n\t\treturn Monitor.isDesiredType( startParams, EngineType.STANDALONE_DB);\n\t}\n",
    "87173": "\tpublic void boot(boolean create, Properties startParams) throws StandardException \n\t{\t\t\n\t\tLanguageConnectionFactory lcf = (LanguageConnectionFactory)  Monitor.findServiceModule(this, LanguageConnectionFactory.MODULE);\n\t\tPropertyFactory pf = lcf.getPropertyFactory();\n\t\tif (pf != null)\n\t\t\tpf.addPropertySetNotification(new LanguageDbPropertySetter());\n\n\t\temptySet = new GenericParameterValueSet(null, 0, false);\n\t}\n",
    "87202": "\tpublic void addActivation(Activation a) {\n\t\tacts.addElement(a);\n\n\t\tif (SanityManager.DEBUG) {\n\n\t\t\tif (SanityManager.DEBUG_ON(\"memoryLeakTrace\")) {\n\n\t\t\t\tif (acts.size() > 20)\n\t\t\t\t\tSystem.out.println(\"memoryLeakTrace:GenericLanguageContext:activations \" + acts.size());\n\t\t\t}\n\t\t}\n\t}\n",
    "87210": "\tprotected void clearProviderDependency(UUID p, Dependency d) {\n\t\tList deps = (List) providers.get(p);\n\n\t\tif (deps == null)\n\t\t\treturn;\n\n\t\tdeps.remove(d);\n\n\t\tif (deps.size() == 0)\n\t\t\tproviders.remove(p);\n\t}\n",
    "87237": "\tpublic UUID getProviderKey() {\n\t\treturn provider.getObjectID();\n\t}\n",
    "87238": "\tpublic Provider getProvider() {\n\t\treturn provider;\n\t}\n",
    "87239": "\tpublic Dependent getDependent() {\n\t\treturn dependent;\n\t}\n",
    "87264": "\tpublic boolean checkNoDeclaredOutputParameters() {\n\n\t\tboolean hasDeclaredOutputParameter = false;\n\t\tfor (int i=0; i<parms.length; i++) {\n\n\t\t\tGenericParameter gp = parms[i];\n\n\t\t\tswitch (gp.parameterMode) {\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_IN:\n\t\t\t\tbreak;\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_IN_OUT:\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_OUT:\n\t\t\t\thasDeclaredOutputParameter = true;\n\t\t\t\tbreak;\n\t\t\tcase JDBC30Translation.PARAMETER_MODE_UNKNOWN:\n\t\t\t\tgp.parameterMode = JDBC30Translation.PARAMETER_MODE_IN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn hasDeclaredOutputParameter;\n\t}\n",
    "87281": "\tpublic OrderByColumn getOrderByColumn(int position) {\n\t\tif (SanityManager.DEBUG)\n\t\tSanityManager.ASSERT(position >=0 && position < size());\n\t\treturn (OrderByColumn) elementAt(position);\n\t}\n",
    "87283": "\tpublic void printSubNodes(int depth) {\n\n\t\tif (SanityManager.DEBUG) \n\t\t{\n\t\t\tfor (int index = 0; index < size(); index++)\n\t\t\t{\n\t\t\t\t( (OrderByColumn) (elementAt(index)) ).treePrint(depth);\n\t\t\t}\n\t\t}\n\t}\n",
    "87297": "\tpublic int getActivationCount() {\n\t\treturn acts.size();\n\t}\n",
    "87307": "\tpublic CursorActivation lookupCursorActivation(String cursorName) {\n\n\t\tint size = acts.size();\n\t\tif (size > 0)\n\t\t{\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t Activation a = (Activation) acts.elementAt(i);\n\n\t\t\t\t if (!a.isInUse())\n\t\t\t\t {\n\t\t\t\t\tcontinue;\n\t\t\t\t }\n\n\n\n\t\t\t\tString executingCursorName = a.getCursorName();\n\n\t\t\t\t if (cursorName.equals(executingCursorName)) {\n\n\t\t\t\t\tResultSet rs = a.getResultSet();\n\t\t\t\t\tif (rs == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t // if the result set is closed, the the cursor doesn't exist\n\t\t\t\t\t if (rs.isClosed()) {\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t }\n\n\t\t\t\t \treturn (CursorActivation)a;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "87313": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.DataValueDescriptor;\n\t}\n",
    "87439": "\tpublic DataValueFactory getDataValueFactory() {\n\t\treturn dataFactory;\n\t}\n",
    "87443": "\tpublic LanguageFactory getLanguageFactory() {\n\t\treturn langFactory;\n\t}\n",
    "87448": "\tpublic LanguageConnectionFactory getLanguageConnectionFactory() {\n\t\treturn connFactory;\n\t}\n",
    "87479": "\tpublic void emptyCache() {\n\t\t/* We know prepared statements don't become dirty\n\t\t** statementCache.cleanAll(); \n\t\t*/\n\t\tif (statementCache != null)\n\t\t\tstatementCache.ageOut(); \n\t}\n",
    "87554": "\tpublic\tint\t\tgetStatementDepth()\n\t{ return statementDepth; }\n",
    "87621": "\tprivate void finishDDTransaction() throws StandardException {\n\n\t\t/* Was the data dictionary put into write mode? */\n\t\tif (ddWriteMode) {\n\t\t\tDataDictionary dd = getDataDictionary();\n\n\t\t\t/* Tell the data dictionary that the transaction is finished */\n\t\t\tdd.transactionFinished();\n\n\t\t\t/* The data dictionary isn't in write mode any more */\n\t\t\tddWriteMode = false;\n\t\t}\n\t}\n",
    "87664": "\tpublic String toString() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\treturn expression.toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n",
    "87665": "\tpublic void setDescending() {\n\t\tascending = false;\n\t}\n",
    "87666": "\tpublic boolean isAscending() {\n\t\treturn ascending;\n\t}\n",
    "87831": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.ConcatableDataValue;\n\t}\n",
    "87990": "\tpublic String getReceiverInterfaceName() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(receiver!=null,\"can't get receiver interface name until receiver is set\");\n\t\t}\n\n\t\treturn receiver.getTypeCompiler().interfaceName();\n\t}\n",
    "88021": "\tpublic void init(Object field, Object operand) {\n\t\textractField = ((Integer) field).intValue();\n\t\tsuper.init( operand,\n\t\t\t\t\t\"EXTRACT \"+fieldName[extractField],\n\t\t\t\t\tfieldMethod[extractField] );\n\t}\n",
    "88329": "    public\tString\tgetPackageName()\n\t{\treturn\tCodeGeneration.GENERATED_PACKAGE_PREFIX; }\n",
    "88330": "\tpublic String getBaseClassName() {\n\t    return ClassName.BaseActivation;\n\t}\n",
    "88994": "\tpublic String getReceiverInterfaceName() {\n\t    return ClassName.StringDataValue;\n\t}\n",
    "89015": "\t//public int\tgetLength() throws StandardException {\n\t//\treturn TypeDescriptor.MAXIMUM_WIDTH_UNKNOWN;\n\t//}\n",
    "89233": "\tpublic void printSubNodes(int depth) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tsuper.printSubNodes(depth);\n\n\t\t\tprintLabel(depth, \"cursor: \");\n\t\t}\n\t}\n",
    "89234": "\tpublic String toString() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\treturn \"preparedStatement: \" +\n\t\t    \t(preStmt == null? \"no prepared statement yet\\n\" :\n\t\t\t \tpreStmt.toString() + \"\\n\")+\n\t\t\t\tcursorName + \"\\n\" +\n\t\t\t\tsuper.toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n",
    "89467": "\tpublic boolean checkVersion(int requiredMajorVersion, String feature) throws StandardException {\n\n\t\tif (requiredMajorVersion == DataDictionary.DD_VERSION_CURRENT) {\n\t\t\trequiredMajorVersion = softwareVersion.majorVersionNumber;\n\t\t}\n\n\t\treturn dictionaryVersion.checkVersion(requiredMajorVersion, feature);\n\t}\n",
    "89612": "\tpublic String getReceiverInterfaceName() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(operand!=null,\n\t\t\t\t\t\t\t\t\"cannot get interface without operand\");\n\t\t}\n\n\t\tif (operatorType != -1)\n\t\t\treturn receiverInterfaceType;\n\t\t\n\t\treturn operand.getTypeCompiler().interfaceName();\n\t}\n",
    "89786": "\tpublic MethodBuilder getExecuteMethod() {\n\t\treturn executeMethod;\n\t}\n",
    "89795": "\tpublic MethodBuilder newGeneratedFun(String returnType, int modifiers) {\n\n\t\treturn newGeneratedFun(returnType, modifiers,\n\t\t\t\t\t\t\t   (String[]) null);\n\t}\n",
    "89803": "\tpublic void pushMethodReference(MethodBuilder mb, MethodBuilder exprMethod) {\n\n\t\tmb.pushThis(); // instance\n\t\tmb.push(exprMethod.getName()); // arg\n\t\tmb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.GeneratedByteCode,\n\t\t\t\t\"getMethod\",\n\t\t\t\tClassName.GeneratedMethod,\n\t\t\t\t1\n\t\t\t\t);\n\t}\n",
    "89804": "\tpublic MethodBuilder newUserExprFun() {\n\n\t\tMethodBuilder mb = newExprFun();\n\t\tmb.addThrownException(\"java.lang.Exception\");\n\t\treturn mb;\n\t}\n",
    "89806": "\tpublic void getCurrentDateExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentDate();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, \"getCurrentDate\", \"java.sql.Date\", 0);\n\t}\n",
    "89807": "\tpublic void getCurrentTimeExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentTime();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, \"getCurrentTime\", \"java.sql.Time\", 0);\n\t}\n",
    "89809": "\tpublic void getCurrentTimestampExpression(MethodBuilder mb) {\n\t\t// do any needed setup\n\t\tLocalField lf = getCurrentSetup();\n\n\t\t// generated Java:\n\t\t//\t  this.cdt.getCurrentTimestamp();\n\t\tmb.getField(lf);\n\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,\n\t\t\t\"getCurrentTimestamp\", \"java.sql.Timestamp\", 0);\n\t}\n",
    "89823": "\tpublic void pushResultSetClosedMethodFieldAccess(MethodBuilder mb) {\n\t\tif (resultSetClosedMethod != null)\n\t\t\tpushMethodReference(mb, resultSetClosedMethod);\n\t\telse\n\t\t\tmb.pushNull(ClassName.GeneratedMethod);\n\t}\n",
    "89827": "\t//private void pushRowArrayReference(MethodBuilder mb)\n\t//{ \t\t\n\t\t// PUSHCOMPILE - cache\n\t//\tmb.pushThis();\n\t//\tmb.getField(ClassName.BaseActivation, \"row\", ClassName.ExecRow + \"[]\");\n\t//}\n",
    "89836": "\tpublic GeneratedClass getGeneratedClass(ByteArray savedBytes) throws StandardException {\n\t\tif (gc != null) return gc;\n\n\t\tif (savedBytes != null)\n\t\t{\n\t\t\tByteArray classBytecode = cb.getClassBytecode();\n\n\t\t\t// note: be sure to set the length since\n\t\t\t// the class builder allocates the byte array\n\t\t\t// in big chunks\n\t\t\tsavedBytes.setBytes(classBytecode.getArray());\n\t\t\tsavedBytes.setLength(classBytecode.getLength());\n\t\t}\n\n\t    gc =  cb.getGeneratedClass();\n\n\t\treturn gc; // !! yippee !! here it is...\n\t}\n",
    "89838": "\tpublic void pushThisAsActivation(MethodBuilder mb) {\n\t\t// PUSHCOMPILER - WASCACHED\n\t\tmb.pushThis();\n\t\tmb.upCast(ClassName.Activation);\n\t}\n",
    "89839": "\tpublic void generateNull(MethodBuilder mb, TypeCompiler tc) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.pushNull(tc.interfaceName());\n\t\ttc.generateNull(mb);\n\t}\n",
    "89841": "\tpublic void generateNullWithExpress(MethodBuilder mb, TypeCompiler tc) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.swap(); // need the dvf as the instance\n\t\tmb.cast(tc.interfaceName());\n\t\ttc.generateNull(mb);\n\t}\n",
    "89842": "\tpublic void generateDataValue(MethodBuilder mb, TypeCompiler tc, LocalField field) {\n\t\tpushDataValueFactory(mb);\n\t\tmb.swap(); // need the dvf as the instance\n\t\ttc.generateDataValue(mb, field);\n\t}\n",
    "89962": "\tpublic\tString\t\tgetSQLtext()\n\t{\treturn\tSQLtext; }\n",
    "90128": "\tpublic\tNodeFactory\tgetNodeFactory()\n\t{\treturn lcf.getNodeFactory(); }\n",
    "90195": "\tpublic void addWarning(SQLWarning warning) {\n\t\tif (warnings == null)\n\t\t\twarnings = warning;\n\t\telse\n\t\t\twarnings.setNextWarning(warning);\n\t}\n",
    "90197": "\tpublic SQLWarning getWarnings() {\n\t\treturn warnings;\n\t}\n",
    "90348": "\tpublic void checkReliability(ValueNode sqlNode) throws StandardException {\n        sqlNode.checkReliability( \n                CompilerContext.FUNCTION_CALL_ILLEGAL,\n                SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF\n                );\n\t}\n",
    "90419": "\tpublic void setSingleExecution() {\n\t\tac.setSingleExecution();\n\t}\n",
    "90420": "\tpublic boolean isSingleExecution() {\n\t\treturn ac.isSingleExecution();\n\t}\n",
    "90422": "\tpublic int getNumSubqueries() {\n\t\treturn ac.getNumSubqueries();\n\t}\n",
    "90466": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(source instanceof CursorResultSet, \"source not instance of CursorResultSet\");\n\t\treturn ( (CursorResultSet)source ).getRowLocation();\n\t}\n",
    "90528": "\tpublic void\topenCore() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t    \tSanityManager.ASSERT( ! isOpen, \"CurrentOfResultSet already open\");\n\n\t\t// get the cursor\n\t\tgetCursor();\n\n\t\tnext = false;\n\t    isOpen = true;\n\t}\n",
    "90536": "\tpublic RowLocation getRowLocation()  {\n\t\treturn rowLocation;\n\t}\n",
    "90671": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(source instanceof CursorResultSet, \"source is not CursorResultSet\");\n\t\treturn ( (CursorResultSet)source ).getRowLocation();\n\t}\n",
    "90739": "\tpublic RowLocation getRowLocation() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Join used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90740": "\tpublic ExecRow getCurrentRow() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Join used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90770": "\tpublic boolean\tisClosed() {\n\t    return ( ! isOpen );\n\t}\n",
    "90774": "\tpublic ResultDescription getResultDescription() {\n\t    return resultDescription;\n\t}\n",
    "90797": "\tpublic\tboolean\tupToDate()\n\t{ return true; }\n",
    "90915": "\tpublic ResultDescription getResultDescription() {\n\t    return activation.getResultDescription();\n\t}\n",
    "90917": "\tpublic String getCursorName() {\n\n\t\tString cursorName = activation.getCursorName();\n\t\tif ((cursorName == null) && isForUpdate()) {\n\n\t\t\tactivation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());\n\n\t\t\tcursorName = activation.getCursorName();\n\t\t}\n\n\t\treturn cursorName;\n\t}\n",
    "90924": "\tpublic RowLocation getRowLocation() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"RowResultSet used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90928": "\tpublic ExecRow getCurrentRow() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"RowResultSet used in positioned update/delete\");\n\t\treturn null;\n\t}\n",
    "90977": "\tpublic void\treopenCore() throws StandardException {\n\t\tTransactionController\t\ttc;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(isOpen,\n\t\t\t\t\t\"HashScanResultSet already open\");\n\t\t}\n\n\t\tbeginTime = getCurrentTimeMillis();\n\n\t\tresetProbeVariables();\n\n\t\tnumOpens++;\n\t\topenTime += getElapsedMillis(beginTime);\n\t}\n",
    "90994": "\tpublic boolean isClosed() {\n\t\treturn isClosed;\n\t\t//return true;\n\t}\n",
    "91015": "\tpublic String getCursorName() {\n\t\treturn null;\n\t}\n",
    "91061": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ROW_RS);\n  }\n",
    "91066": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_PR);\n  }\n",
    "91071": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_UPDATE);\n  }\n",
    "91074": "  public Vector getChildren(){\n    return new Vector();\n  }\n",
    "91076": "  public long getTotalTime(){\n    //The method below is the original calculation.  However, the constructor\n    //time was found to be inaccurate, and was therefore removed from the calculation.\n\t  //return constructorTime + openTime + nextTime + closeTime;\n\t  return openTime + nextTime + closeTime;\n  }\n",
    "91077": "  public long getChildrenTime(){\n    long childrenTime = 0;\n    java.util.Enumeration e = getChildren().elements();\n    while (e.hasMoreElements()){\n      childrenTime = childrenTime + ((RealBasicNoPutResultSetStatistics)e.nextElement()).getTotalTime();\n    }\n    return childrenTime;\n  }\n",
    "91080": "  public long getNodeTime(){\n    return getTotalTime() - getChildrenTime();\n  }\n",
    "91088": "  public String getNodeName(){\n\treturn MessageService.getTextMessage(\n\t\t\t\tindexName == null ?\n\t\t\t\tSQLState.RTS_TABLE_SCAN :\n\t\t\t\tSQLState.RTS_INDEX_SCAN);\n  }\n",
    "91097": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_HASH_SCAN);\n  }\n",
    "91104": "  public Vector getChildren(){\n    Vector children = new Vector();\n    children.addElement(sourceResultSetStatistics);\n    return children;\n  }\n",
    "91112": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE_VTI);\n  }\n",
    "91121": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_IRTBR);\n  }\n",
    "91130": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SORT);\n  }\n",
    "91133": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_VTI);\n  }\n",
    "91141": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_INSERT_VTI);\n  }\n",
    "91142": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_MATERIALIZED_RS);\n  }\n",
    "91149": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DISTINCT_SCALAR_AGG);\n  }\n",
    "91150": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SCROLL_INSENSITIVE_RS);\n  }\n",
    "91157": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_NORMALIZE_RS);\n  }\n",
    "91158": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_GROUPED_AGG);\n  }\n",
    "91159": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_JOIN);\n  }\n",
    "91166": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_INSERT);\n  }\n",
    "91175": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ONCE_RS);\n  }\n",
    "91178": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_UNION);\n  }\n",
    "91182": "  public String getNodeName(){\n\t// NOTE: Not internationalizing because \"CURRENT OF\" are keywords.\n    return \"Current Of\";\n  }\n",
    "91187": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_ANY_RS);\n  }\n",
    "91188": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE_CASCADE);\n  }\n",
    "91193": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_DELETE);\n  }\n",
    "91202": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_HASH_TABLE);\n  }\n",
    "91208": "  public String getNodeName(){\n    return MessageService.getTextMessage(SQLState.RTS_SCALAR_AGG);\n  }\n",
    "91244": "  public Vector getChildren(){\n    Vector children = new Vector();\n    children.addElement(topResultSetStatistics);\n    return children;\n  }\n",
    "91279": "\tpublic ResultDescription getResultDescription() {\n\t    return source1.getResultDescription();\n\t}\n",
    "91286": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t    switch (whichSource) {\n\t        case 1 : \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.ASSERT(source1 instanceof CursorResultSet, \"source not CursorResultSet\");\n\t\t\t\treturn ((CursorResultSet)source1).getRowLocation();\n\t        case 2 : \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.ASSERT(source2 instanceof CursorResultSet, \"source2 not CursorResultSet\");\n\t\t\t\treturn ((CursorResultSet)source2).getRowLocation();\n\t        default: \n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t\tSanityManager.THROWASSERT( \"Bad source number in union\" );\n\t            return null;\n\t    }\n\t}\n",
    "91292": "\tpublic void forget() {\n\t\tcurrentDatetime = null;\n\t\tcurrentDate = null;\n\t\tcurrentTime = null;\n\t\tcurrentTimestamp = null;\n\t}\n",
    "91330": "\tpublic void markAsTopResultSet()\n\t{ }\n",
    "91411": "\tpublic ExecRow\tgetNextRowCore() throws StandardException {\n\n\t\tcurrentRow = null;\n\t\tbeginTime = getCurrentTimeMillis();\n\t\tif (isOpen) \n\t\t{\n\t\t\tif (!next) \n\t\t\t{\n\t            next = true;\n\t\t\t\tif (currentRow == null)\n\t\t\t\t{\n\t\t\t\t\tif (cachedRow != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentRow = cachedRow;\n\t\t\t\t\t}\n\t\t\t\t\telse if (row != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentRow = (ExecRow) row.invoke(activation);\n\t\t\t\t\t\tif (canCacheRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcachedRow = currentRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trowsReturned++;\n\t\t\t}\n\t\t\tsetCurrentRow(currentRow);\n\n\t\t\tnextTime += getElapsedMillis(beginTime);\n\t    }\n\t    return currentRow;\n\t}\n",
    "91490": "\tpublic String getReferencedTableName()\n\t{ return tableName; }\n",
    "91491": "\tpublic int getReferentialActionUpdateRule()\n\t{ return raUpdateRule; }\n",
    "91493": "\tpublic int getReferentialActionDeleteRule()\n\t{ return raDeleteRule; }\n",
    "91567": "\tprotected void closeActivationAction() throws Exception {\n\t\t// no code to be added here as generated code\n\t\t// will not call super.closeActivationAction()\n\t}\n",
    "91570": "\tpublic boolean isClosed() {\n\t\treturn closed;\n\t}\n",
    "91573": "\tpublic void setSingleExecution() {\n\t\tsingleExecution = true;\n\t}\n",
    "91576": "\tpublic boolean isSingleExecution() {\n\t\treturn singleExecution;\n\t}\n",
    "91579": "\tpublic int getNumSubqueries() {\n\t\treturn numSubqueries;\n\t}\n",
    "91621": "\tpublic String getCursorName() {\n\n\t\treturn isCursorActivation() ? cursorName : null;\n\t}\n",
    "91632": "\tpublic ResultSetFactory getResultSetFactory() {\n\t\treturn rsFactory;\n\t}\n",
    "91636": "\tpublic ExecutionFactory getExecutionFactory() {\n\t\treturn exFactory;\n\t}\n",
    "91638": "\tpublic CursorResultSet getTargetResultSet() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Must be overridden to be used.\");\n\t\treturn null;\n\t}\n",
    "91642": "\tpublic CursorResultSet getCursorResultSet() {\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.THROWASSERT(\"Must be overridden to be used.\");\n\t\treturn null;\n\t}\n",
    "91643": "\tpublic void throwIfClosed(String op) throws StandardException {\n\t\tif (closed)\n\t\t\tthrow StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);\n\t}\n",
    "91735": "\tpublic void\treopenCore() throws StandardException {\n\t\tTransactionController\t\ttc;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(isOpen,\n\t\t\t\t\t\"IndexRowToBaseRowResultSet already open\");\n\t\t}\n\n\t\tbeginTime = getCurrentTimeMillis();\n\n\t\tsource.reopenCore();\n\n\t\tnumOpens++;\n\t\topenTime += getElapsedMillis(beginTime);\n\t}\n",
    "91741": "\tpublic RowLocation getRowLocation() throws StandardException {\n\t\treturn baseRowLocation;\n\t}\n",
    "91760": "\tpublic Connection getCurrentConnection() throws SQLException {\n\n\t\tConnectionContext cc = \n\t\t\t(ConnectionContext) cm.getContext(ConnectionContext.CONTEXT_ID);\n\n\t\treturn cc.getNestedConnection(true);\n\t}\t\n",
    "91763": "\tpublic int getMaxDynamicResults() {\n\t\treturn 0;\n\t}\n",
    "91880": "\tpublic boolean isValid() {\n\t\treturn isValid;\n\t}\n",
    "91942": "\tpublic int\tgetUpdateMode() {\n\t\treturn updateMode;\n\t}\n",
    "91988": "    public String nativeSQL(String sql) {\n\t\t// we don't massage the strings at all, so this is easy:\n\t\treturn sql;\n\t}\n",
    "91992": "\tpublic void setAutoCommit(boolean autoCommit) throws SQLException {\n\n\t\t// Is this a nested connection\n\t\tif (rootConnection != this) {\n\t\t\tif (autoCommit)\n\t\t\t\tthrow newSQLException(SQLState.NO_AUTO_COMMIT_ON);\n\t\t}\n\n\t\tif (this.autoCommit != autoCommit)\n\t\t\tcommit();\n\n\t\tthis.autoCommit = autoCommit;\n\t}\n",
    "91995": "    public boolean getAutoCommit() {\n\t\treturn autoCommit;\n\t}\n",
    "91998": "    public void commit() throws SQLException {\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\t/*\n\t\t\t** Note that the context stack is\n\t\t\t** needed even for rollback & commit\n\t\t\t*/\n            setupContextStack();\n\n\t\t\ttry\n\t\t\t{\n\t\t    \tgetTR().commit();\n\t\t\t}\n            catch (Throwable t)\n\t\t\t{\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\n\t\t\tneedCommit = false;\n\t\t}\n\t}\n",
    "92002": "    public void rollback() throws SQLException {\n\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\t/*\n\t\t\t** Note that the context stack is\n\t\t\t** needed even for rollback & commit\n\t\t\t*/\n            setupContextStack();\n\t\t\ttry\n\t\t\t{\n\t\t    \tgetTR().rollback();\n\t\t\t} catch (Throwable t) {\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\t\t\tneedCommit = false;\n\t\t} \n\t}\n",
    "92005": "    public void close() throws SQLException {\n\t\t// JDK 1.4 javadoc indicates close on a closed connection is a no-op\n\t\tif (isClosed())\n\t\t   \treturn;\n\n\n\t\tif (rootConnection == this)\n\t\t{\n\t\t\t/* Throw error to match DB2/JDBC if a tran is pending in non-autocommit mode */\n\t\t\tif (!autoCommit && !transactionIsIdle()) {\n\t\t\t\tthrow newSQLException(SQLState.LANG_INVALID_TRANSACTION_STATE);\n\t\t\t}\n\n\t\t\tclose(exceptionClose);\n\t\t}\n\t\telse\n\t\t\tsetInactive(); // nested connection\n\t}\n",
    "92011": "    public DatabaseMetaData getMetaData() throws SQLException {\n\t\tif (isClosed())\n\t\t\tthrow Util.noCurrentConnection();\n\n\t\tif (dbMetadata == null) {\n\n \t\t\t// There is a case where dbname can be null.\n\t\t\t// Replication client of this method does not have a\n\t\t\t// JDBC connection; therefore dbname is null and this\n\t\t\t// is expected.\n\t\t\t//\n\t\t\tdbMetadata = factory.newEmbedDatabaseMetaData(this, getTR().getUrl());\n\t\t}\n\t\treturn dbMetadata;\n\t}\n",
    "92016": "    public void setCatalog(String catalog) throws SQLException {\n\t\t// silently ignoring this request like the javadoc said.\n\t\treturn;\n\t}\n",
    "92020": "\tpublic String getCatalog() throws SQLException {\n\t\t// we do not have support for Catalog, just return null as\n\t\t// the JDBC specs mentions then.\n\t\treturn null;\n\t}\n",
    "92035": "    protected void needCommit() {\n\t\tif (!needCommit) needCommit = true;\n\t}\n",
    "92070": "\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\n\t\t/*\n\t\t** We mark the activation as not being used and\n\t \t** that is it.  We rely on the connection to sweep\n\t\t** through the activations to find the ones that\n\t\t** aren't in use, and to close them.  We cannot\n\t \t** do a activation.close() here because there are\n\t\t** synchronized methods under close that cannot\n\t\t** be called during finalization.\n\t\t*/\n\t\tif (activation != null) \n\t\t{\n\t\t\tactivation.markUnused();\n\t\t}\n\t}\n",
    "92071": "\tprotected void closeActions() throws SQLException {\n\n\t\t//we release the resource for preparedStatement\n\t\tpreparedStatement = null;\n\n\t\ttry{\n\t\t\tsetupContextStack();\n\t\t} catch (SQLException se) {\n\t\t\t//we may have already committed the transaction in which case\n\t\t\t//setupContextStack will fail, the close should just return\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t    activation.close();\n\t\t\tactivation = null;\n\t\t} catch (Throwable t)\n\t\t{\n\t\t\tthrow handleException(t);\n\t\t} finally {\n\t\t    restoreContextStack();\n\t\t}\n\t}\n",
    "92073": "    public void setNull(int parameterIndex, int sqlType) throws SQLException {\n\n\t\tcheckStatus();\n\n\t\tint jdbcTypeId = getParameterJDBCType(parameterIndex);\n\t\t\n\t\tif (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {\n\n\t\t\tthrow dataTypeConversion(parameterIndex, Util.typeName(sqlType));\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setToNull();\n\t\t} catch (StandardException t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92074": "    public void setBoolean(int parameterIndex, boolean x) throws SQLException {\n\t\t\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (StandardException t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92077": "    public void setByte(int parameterIndex, byte x) throws SQLException {\n\n\t\tcheckStatus();\n\t\ttry {\n\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92079": "    public void setShort(int parameterIndex, short x) throws SQLException {\n\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92081": "    public void setInt(int parameterIndex, int x) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92082": "    public void setLong(int parameterIndex, long x) throws SQLException {\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92084": "    public void setFloat(int parameterIndex, float x) throws SQLException {\n\t\tcheckStatus();\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92085": "    public void setDouble(int parameterIndex, double x) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92089": "    public void setString(int parameterIndex, String x) throws SQLException {\n\t\tcheckStatus();\t\t\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\t}\n",
    "92091": "\tpublic void resetFromPool() throws SQLException {\n\t\tsynchronized (getConnectionSynchronization())\n\t\t{\n\t\t\tsetupContextStack();\n\t\t\ttry {\n\t\t\t\tgetLanguageConnection().resetFromPool();\n\t\t\t} catch (StandardException t) {\n\t\t\t\tthrow handleException(t);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\trestoreContextStack();\n\t\t\t}\n\t\t}\n\t}\n",
    "92092": "    public void setBytes(int parameterIndex, byte x[]) throws SQLException {\n\t\tcheckStatus();\n\n\t\ttry {\n\t\t\t/* JDBC is one-based, DBMS is zero-based */\n\t\t\tgetParms().getParameterForSet(parameterIndex - 1).setValue(x);\n\n\t\t} catch (Throwable t) {\n\t\t\tthrow EmbedResultSet.noStateChangeException(t);\n\t\t}\n\n\t}\n",
    "92093": "    public void setDate(int parameterIndex, Date x) throws SQLException {\n        setDate( parameterIndex, x, (Calendar) null);\n\t}\n",
    "92095": "    public void setTime(int parameterIndex, Time x) throws SQLException {\n        setTime( parameterIndex, x, (Calendar) null);\n\t}\n",
    "92110": "    public void clearParameters() throws SQLException {\n\t\tcheckStatus();\n\n\t\tParameterValueSet pvs = getParms();\n\t\tif (pvs != null)\n\t\t\tpvs.clearParameters();\n\t}\n",
    "92129": "\tpublic int getColumnCount()\t{\n\t\treturn columnInfo == null ? 0 : columnInfo.length;\n\t}\n",
    "92130": "\tpublic boolean isAutoIncrement(int column) throws SQLException\t{\n\n\t\tResultColumnDescriptor rcd = columnInfo[column - 1];\n\t\treturn rcd.isAutoincrement();\n\t}\n",
    "92132": "\tpublic boolean isCaseSensitive(int column) throws SQLException\t{\n\t  return DataTypeUtilities.isCaseSensitive(getColumnTypeDescriptor(column));\n\t}\n",
    "92133": "\tpublic boolean isSearchable(int column) throws SQLException\t{\n\t\tvalidColumnNumber(column);\n\n\t\t// we have no restrictions yet, so this is always true\n\t\t// might eventually be false for e.g. extra-long columns?\n\t\treturn true;\n\t}\n",
    "92134": "\tpublic boolean isCurrency(int column) throws SQLException\t{\n\n\t\treturn DataTypeUtilities.isCurrency(getColumnTypeDescriptor(column));\n\t}\n",
    "92135": "\tpublic int isNullable(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.isNullable(getColumnTypeDescriptor(column));\n\t}\n",
    "92136": "\tpublic boolean isSigned(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.isSigned(getColumnTypeDescriptor(column));\n\t}\n",
    "92138": "\tpublic int getColumnDisplaySize(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.getColumnDisplaySize(getColumnTypeDescriptor(column));\n\t}\n",
    "92139": "\tpublic String getColumnLabel(int column) throws SQLException {\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getName();\n\n\t\t// we could get fancier than this, but it's simple\n    \treturn (s==null? \"Column\"+Integer.toString(column) : s);\n\t}\n",
    "92140": "\tpublic String getColumnName(int column) throws SQLException\t{\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getName();\n\t\t// database returns null when no column name to differentiate from empty name\n    \treturn (s==null? \"\" : s);\n\n\t}\n",
    "92141": "\tpublic String getSchemaName(int column) throws SQLException\t{\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\n\t\tString s = cd.getSourceSchemaName();\n\t\t// database returns null when no schema name to differentiate from empty name\n\t\treturn (s==null? \"\" : s);\n\t}\n",
    "92142": "\tpublic int getPrecision(int column) throws SQLException\t{\n\t\treturn DataTypeUtilities.getDigitPrecision(getColumnTypeDescriptor(column));\n\t}\n",
    "92144": "\tpublic int getScale(int column) throws SQLException\t{\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\t// REMIND -- check it is valid to ask for scale\n\t\treturn dtd.getScale();\n\t}\n",
    "92145": "\tpublic String getTableName(int column) throws SQLException {\n\t\tResultColumnDescriptor cd = columnInfo[column - 1];\n\t\tString s = cd.getSourceTableName();\n\n\t\t// database returns null when no table name to differentiate from empty name\n\t\treturn (s==null? \"\" : s);\n\t}\n",
    "92146": "\tpublic String getCatalogName(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\t\treturn \"\";\n\t}\n",
    "92147": "\tpublic int getColumnType(int column) throws SQLException {\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\treturn dtd.getTypeId().getJDBCTypeId();\n\t}\n",
    "92149": "\tpublic String toString() {\n\t\treturn \"SQL Warning: \" + getMessage();\n\t}\n",
    "92150": "\tpublic String getColumnTypeName(int column) throws SQLException\t{\n\t\tDataTypeDescriptor dtd = getColumnTypeDescriptor(column);\n\t\treturn dtd.getTypeId().getSQLTypeName();\n\t}\n",
    "92153": "\tpublic boolean isReadOnly(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\n\t\t// we just don't know if it is a base table column or not\n\t\treturn false;\n\t}\n",
    "92157": "\tpublic boolean isWritable(int column) throws SQLException {\n\t\tvalidColumnNumber(column);\n\t\treturn columnInfo[column - 1].updatableByCursor();\n\t}\n",
    "92160": "\tpublic boolean isDefinitelyWritable(int column) throws SQLException\t{\n\t\tvalidColumnNumber(column);\n\n\t\t// we just don't know if it is a base table column or not\n\t\treturn false;\n\t}\n",
    "92175": "\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\n\t\tif (finalizeActivation != null) {\n\t\t\tfinalizeActivation.markUnused();\n\t\t}\t\t\n\t}\n",
    "92184": "\tpublic int getMaxFieldSize() throws SQLException {\n\t\tcheckStatus();\n\n        return MaxFieldSize;\n\t}\n",
    "92192": "\tpublic void setEscapeProcessing(boolean enable) throws SQLException\t{\n\t\tcheckStatus();\n        // Nothing to do in our server , just ignore it.\n\n\t}\n",
    "92193": "\tpublic int getQueryTimeout() throws SQLException {\n        // Currently Cloudscape does not support any sort of timeout, so always\n        // return 0, which means that timeout is unlimited.\n        return(0);\n\t}\n",
    "92195": "\tpublic void setQueryTimeout(int seconds) throws SQLException {\n\t\tif (seconds != 0)\n\t\t\tthrow Util.notImplemented(\"setQueryTimeout\");\n\t}\n",
    "92196": "\tpublic void cancel() throws SQLException {\n\t\tthrow Util.notImplemented(\"cancel\");\n\t}\n",
    "92198": "\tpublic SQLWarning getWarnings() throws SQLException\t{\n\t\tcheckStatus();\n\t\treturn warnings;\n\t}\n",
    "92199": "\tpublic void clearWarnings() throws SQLException\t{\n\t\tcheckStatus();\n\t\twarnings = null;\n\t}\n",
    "92202": "\tpublic void setCursorName(String name) throws SQLException {\n\t\tcheckStatus();\n\t\tcursorName = name;\n\t}\n",
    "92207": "    public ResultSetMetaData getMetaData() throws SQLException {\n\n\t  checkIfClosed(\"getMetaData\");\t// checking result set closure does not depend\n\t\t\t\t\t\t\t\t// on the underlying connection.  Do this\n\t\t\t\t\t\t\t\t// outside of the connection synchronization.\n\n\t  synchronized (getConnectionSynchronization()) {\n\n\n\t\tif (rMetaData == null) {\n\t\t\t// cache this object and keep returning it\n\t\t\trMetaData = newEmbedResultSetMetaData(resultDescription);\n\t\t}\n\t\treturn rMetaData;\n\t  }\n\t}\n",
    "92226": "\tprotected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {\n\t\treturn execute((String)batchElement, false, true, JDBC30Translation.NO_GENERATED_KEYS, null, null);\n\t}\n",
    "92241": "\tpublic void transferBatch(EmbedStatement other) throws SQLException {\n\t\t\n\t\tsynchronized (getConnectionSynchronization()) {\n\t\t\tother.batchStatements = batchStatements;\n\t\t\tbatchStatements = null;\n\t\t}\n\t}\n",
    "92266": "\tpublic void printStackTrace() {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace();\n\t\telse\n\t\t\tsuper.printStackTrace();\n\t}\n",
    "92267": "\tpublic void printStackTrace(PrintStream s) {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace(s);\n\t\telse\n\t\t\tsuper.printStackTrace(s);\n\t}\n",
    "92268": "\tpublic void printStackTrace(PrintWriter s) {\n\t\tThrowable je = getJavaException();\n\t\tif (je != null)\n\t\t\tje.printStackTrace(s);\n\t\telse\n\t\t\tsuper.printStackTrace(s);\n\t}\n",
    "92269": "\tpublic String toString() {\n\t\treturn \"SQL Exception: \" + getMessage();\n\t}\n",
    "92277": "\tpublic String getProperty(String key) {\n\n\t\tString propertyValue = null;\n\t\tTransactionController tc = null;\n\n\t\ttry {\n\n\t\t  if (store != null)\n          {\n            tc = store.getTransaction(\n                ContextService.getFactory().getCurrentContextManager());\n          }\n\n\t\t  propertyValue =\n\t\t\tPropertyUtil.getServiceProperty(tc,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\t(String) null);\n\t\t  if (tc != null) {\n\t\t\ttc.commit();\n\t\t\ttc = null;\n\t\t  }\n\n\t\t} catch (StandardException se) {\n\t\t\t// Do nothing and just return\n\t\t}\n\n\t\treturn propertyValue;\n\t}\n",
    "92286": "\tpublic boolean canSupport(Properties properties) {\n\n\t\tif (!requireAuthentication(properties))\n\t\t\treturn false;\n\n\t\t//\n\t\t// We check 2 System/Database properties:\n\t\t//\n\t\t//\n\t\t// - if derby.authentication.provider is set to 'BUILTIN'.\n\t\t//\n\t\t// and in that case we are the authentication service that should\n\t\t// be run.\n\t\t//\n\n\t\tString authenticationProvider = PropertyUtil.getPropertyFromSet(\n\t\t\t\t\tproperties,\n\t\t\t\t\torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);\n\n\t\tif ( (authenticationProvider != null) &&\n\t\t\t (authenticationProvider.length() != 0) &&\n\t\t\t (!(StringUtil.SQLEqualsIgnoreCase(authenticationProvider,\n\t\t\t\t  org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_BUILTIN))))\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\t// Yep, we're on!\n\t}\n",
    "92289": "\tpublic boolean canSupport(Properties properties) {\n\n\t\tif (!requireAuthentication(properties))\n\t\t\treturn false;\n\n\t\t//\n\t\t// we check 2 things:\n\t\t//\n\t\t// - if derby.connection.requireAuthentication system\n\t\t//   property is set to true.\n\t\t// - if derby.authentication.provider is set to one\n\t\t// of the JNDI scheme we support (i.e. LDAP).\n\t\t//\n\n\t\tauthenticationProvider = PropertyUtil.getPropertyFromSet(\n\t\t\t\t\tproperties,\n\t\t\t\t\t\torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);\n\n\t\t if ( (authenticationProvider != null) &&\n\t\t\t   (StringUtil.SQLEqualsIgnoreCase(authenticationProvider,\n\t\t\t\t  \torg.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n",
    "92299": "\tprivate void setInitDirContextEnv(Properties dbProps) {\n\n\t\t//\n\t\t// We retrieve JNDI properties set at the database level\t\n\t\t// if any.\n\t\t//\n\t\tinitDirContextEnv = new Properties();\n\n\t\tfor (Enumeration keys = dbProps.propertyNames(); keys.hasMoreElements(); ) {\n\n\t\t\tString key = (String) keys.nextElement();\n\n\t\t\tif (key.startsWith(\"java.naming.\")) {\n\t\t\t\tinitDirContextEnv.put(key, dbProps.getProperty(key));\n\t\t\t}\n\t\t}\n\t}\n",
    "92300": "\tpublic boolean canSupport(Properties properties) {\n\n\t\treturn !requireAuthentication(properties);\n\t}\n",
    "92303": "\tpublic int read() throws IOException {\n\n\t\tif (dummyBytes != 0) {\n\t\t\tdummyBytes--;\n\t\t\treturn 0;\n\t\t}\n\n\t\tint ret = super.read();\n\n\t\tif (ret < 0)\n\t\t\tcheckSufficientData();\n\n\t\treturn ret;\n\t}\n",
    "92305": "\tpublic int read(byte b[], int off, int len) throws IOException {\n\n\t\tint dlen = dummyBytes;\n\n\t\tif (dlen != 0) {\n\t\t\tif (len < dlen)\n\t\t\t\tdlen = len;\n\t\t\tfor (int i = 0; i < dlen; i++) {\n\t\t\t\tb[off+i] = 0;\n\t\t\t}\n\t\t\tdummyBytes -= dlen;\n\n\t\t\toff += dlen;\n\t\t\tlen -= dlen;\n\t\t}\n\n\t\tint realRead = super.read(b, off, len);\n\n\t\tif (realRead < 0)\n\t\t{\n\t\t\tif (dlen != 0)\n\t\t\t\treturn dlen;\n\n\t\t\tcheckSufficientData();\n\n\t\t\treturn realRead;\n\t\t}\n\n\t\treturn dlen + realRead;\n\t}\n",
    "92353": "\tpublic boolean allProceduresAreCallable() {\n\t\treturn true;\n\t}\n",
    "92356": "\tpublic boolean allTablesAreSelectable() {\n\t\treturn true;\n\t}\n",
    "92359": "\tpublic String getUserName() {\n\t\treturn (getEmbedConnection().getTR().getUserName());\n\t}\n",
    "92360": "\tpublic boolean isReadOnly() {\n\t\treturn getLanguageConnectionContext().getDatabase().isReadOnly();\n\t}\n",
    "92364": "\tpublic boolean nullsAreSortedHigh() {\n\t\treturn true;\n\t}\n",
    "92365": "\tpublic boolean nullsAreSortedLow() {\n\t\treturn false;\n\t}\n",
    "92367": "\tpublic boolean nullsAreSortedAtStart() {\n\t\treturn false;\n\t}\n",
    "92369": "\tpublic boolean nullsAreSortedAtEnd() {\n\t\treturn false;\n\t}\n",
    "92372": "\tpublic String getDatabaseProductName() {\n\t\treturn Monitor.getMonitor().getEngineVersion().getProductName();\n\t}\n",
    "92374": "\tpublic String getDatabaseProductVersion() {\n\t\tProductVersionHolder myPVH = Monitor.getMonitor().getEngineVersion();\n\n\t\treturn myPVH.getVersionBuildString(false);\n\t}\n",
    "92376": "\tpublic String getDriverName() {\n\t\treturn \"Apache Derby Embedded JDBC Driver\";\n\t}\n",
    "92380": "\tpublic String getDriverVersion()  {\n\t\treturn getDatabaseProductVersion();\n\t}\n",
    "92381": "\tpublic int getDriverMajorVersion() {\n\t\treturn getEmbedConnection().getLocalDriver().getMajorVersion();\n\t}\n",
    "92383": "\tpublic int getDriverMinorVersion() {\n\t\treturn getEmbedConnection().getLocalDriver().getMinorVersion();\n\t}\n",
    "92386": "\tpublic boolean usesLocalFiles() {\n\t\treturn true;\n\t}\n",
    "92388": "\tpublic boolean usesLocalFilePerTable() {\n\t\treturn true;\n\t}\n",
    "92390": "\tpublic boolean supportsMixedCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92392": "\tpublic boolean storesUpperCaseIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92395": "\tpublic boolean storesLowerCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92397": "\tpublic boolean storesMixedCaseIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92400": "\tpublic boolean supportsMixedCaseQuotedIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92402": "\tpublic boolean storesUpperCaseQuotedIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92404": "\tpublic boolean storesLowerCaseQuotedIdentifiers() {\n\t\treturn false;\n\t}\n",
    "92405": "\tpublic boolean storesMixedCaseQuotedIdentifiers() {\n\t\treturn true;\n\t}\n",
    "92409": "\tpublic String getIdentifierQuoteString() {\n\t\treturn \"\\\"\";\n\t}\n",
    "92411": "\tpublic String getSQLKeywords() {\n\t\treturn \"ALIAS,BIGINT,BOOLEAN,CALL,CLASS,COPY,DB2J_DEBUG,EXECUTE,EXPLAIN,FILE,FILTER,\"\n\t\t\t+  \"GETCURRENTCONNECTION,INDEX,INSTANCEOF,METHOD,NEW,OFF,PROPERTIES,PUBLICATION,RECOMPILE,\"\n\t\t\t+  \"REFRESH,RENAME,RUNTIMESTATISTICS,STATEMENT,STATISTICS,TIMING,WAIT\";\n\t}\n",
    "92412": "\tpublic String getNumericFunctions() {\n\t\treturn \"ABS,SQRT\";\n\t}\n",
    "92415": "\tpublic String getStringFunctions() {\n\t\treturn \"LENGTH,LOWER,LTRIM,RTRIM,SUBSTR,SUBSTRING,UPPER\";\n\t}\n",
    "92418": "\tpublic String getSystemFunctions()  {\n\t\treturn \"CURRENT_USER,getCurrentConnection,runTimeStatistics,SESSION_USER,USER,CURRENT SCHEMA\";\n\t}\n",
    "92420": "\tpublic String getTimeDateFunctions() {\n\t\treturn \"CURDATE,CURTIME,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,EXTRACT\";\n\t}\n",
    "92422": "\tpublic String getSearchStringEscape()  {\n\t\treturn \"\";\n\t}\n",
    "92425": "\tpublic String getExtraNameCharacters()  {\n\t\treturn \"\";\n\t}\n",
    "92427": "\tpublic boolean supportsAlterTableWithAddColumn() {\n\t\treturn true;\n\t}\n",
    "92429": "\tpublic boolean supportsAlterTableWithDropColumn() {\n\t\treturn true;\n\t}\n",
    "92432": "\tpublic boolean supportsColumnAliasing() {\n\t\treturn true;\n\t}\n",
    "92433": "\tpublic boolean nullPlusNonNullIsNull()  {\n\t\treturn true;\n\t}\n",
    "92437": "\tpublic boolean supportsConvert() {\n\t\treturn true;\n\t}\n",
    "92440": "\tpublic boolean supportsConvert(int fromType, int toType) {\n\t\t/*\n\t\t * at the moment we don't support CONVERT at all, so we take the easy\n\t\t * way out.  Eventually we need to figure out how to handle this\n\t\t * cleanly.\n\t\t */\n\t\treturn false;\n\t}\n",
    "92441": "\tpublic boolean supportsTableCorrelationNames()  {\n\t\treturn true;\n\t}\n",
    "92444": "\tpublic boolean supportsDifferentTableCorrelationNames() {\n\t\treturn true;\n\t}\n",
    "92446": "\tpublic boolean supportsExpressionsInOrderBy() {\n\t\treturn false;\n\t}\n",
    "92448": "\tpublic boolean supportsOrderByUnrelated() {\n\t\treturn false;\n\t}\n",
    "92450": "\tpublic boolean supportsGroupBy() {\n\t\treturn true;\n\t}\n",
    "92454": "\tpublic boolean supportsGroupByUnrelated()  {\n\t\treturn true;\n\t}\n",
    "92456": "\tpublic boolean supportsGroupByBeyondSelect() {\n\t\treturn true;\n\t}\n",
    "92458": "\tpublic boolean supportsLikeEscapeClause() {\n\t\treturn true;\n\t}\n",
    "92461": "\tpublic boolean supportsMultipleResultSets()  {\n\t\treturn true;\n\t}\n",
    "92462": "\tpublic boolean supportsMultipleTransactions() {\n\t\treturn true;\n\t}\n",
    "92465": "\tpublic boolean supportsNonNullableColumns()  {\n\t\treturn true;\n\t}\n",
    "92466": "\tpublic boolean supportsMinimumSQLGrammar() {\n\t\treturn true;\n\t}\n",
    "92469": "\tpublic boolean supportsCoreSQLGrammar() {\n\t\treturn false;\n\t}\n",
    "92473": "\tpublic boolean supportsExtendedSQLGrammar() {\n\t\treturn false;\n\t}\n",
    "92474": "\tpublic boolean supportsANSI92EntryLevelSQL() {\n\t\treturn false;\n\t}\n",
    "92477": "\tpublic boolean supportsANSI92IntermediateSQL() {\n\t\treturn false;\n\t}\n",
    "92479": "\tpublic boolean supportsANSI92FullSQL() {\n\t\treturn false;\n\t}\n",
    "92481": "\tpublic boolean supportsIntegrityEnhancementFacility() {\n\t\treturn false;\n\t}\n",
    "92483": "\tpublic boolean supportsOuterJoins() {\n\t\treturn true;\n\t}\n",
    "92486": "\tpublic boolean supportsFullOuterJoins()  {\n\t\treturn false;\n\t}\n",
    "92488": "\tpublic boolean supportsLimitedOuterJoins() {\n\t\treturn true;\n\t}\n",
    "92491": "\tpublic String getSchemaTerm() {\n\t\treturn \"SCHEMA\";\n\t}\n",
    "92494": "\tpublic String getProcedureTerm() {\n\t\treturn \"PROCEDURE\";\n\t}\n",
    "92495": "\tpublic String getCatalogTerm() {\n\t\treturn \"CATALOG\";\n\t}\n",
    "92498": "\tpublic boolean isCatalogAtStart() {\n\t\treturn false;\n\t}\n",
    "92500": "\tpublic String getCatalogSeparator() {\n\t\treturn \"\";\n\t}\n",
    "92502": "\tpublic boolean supportsSchemasInDataManipulation() {\n\t\treturn true;\n\t}\n",
    "92505": "\tpublic boolean supportsSchemasInProcedureCalls() {\n\t\treturn true;\n\t}\n",
    "92508": "\tpublic boolean supportsSchemasInTableDefinitions() {\n\t\treturn true;\n\t}\n",
    "92510": "\tpublic boolean supportsSchemasInIndexDefinitions() {\n\t\treturn true;\n\t}\n",
    "92512": "\tpublic boolean supportsSchemasInPrivilegeDefinitions() {\n\t\treturn true;\n\t}\n",
    "92515": "\tpublic boolean supportsCatalogsInDataManipulation() {\n\t\treturn false;\n\t}\n",
    "92517": "\tpublic boolean supportsCatalogsInProcedureCalls() {\n\t\treturn false;\n\t}\n",
    "92519": "\tpublic boolean supportsCatalogsInTableDefinitions() {\n\t\treturn false;\n\t}\n",
    "92522": "\tpublic boolean supportsCatalogsInIndexDefinitions() {\n\t\treturn false;\n\t}\n",
    "92523": "\tpublic boolean supportsCatalogsInPrivilegeDefinitions() {\n\t\treturn false;\n\t}\n",
    "92527": "\tpublic boolean supportsPositionedDelete() {\n\t\treturn true;\n\t}\n",
    "92529": "\tpublic boolean supportsPositionedUpdate() {\n\t\treturn true;\n\t}\n",
    "92532": "\tpublic boolean supportsSelectForUpdate() {\n\t\treturn true;\n\t}\n",
    "92534": "\tpublic boolean supportsStoredProcedures() {\n\t\treturn true;\n\t}\n",
    "92536": "\tpublic boolean supportsSubqueriesInComparisons() {\n\t\treturn true;\n\t}\n",
    "92539": "\tpublic boolean supportsSubqueriesInExists() {\n\t\treturn true;\n\t}\n",
    "92540": "\tpublic boolean supportsSubqueriesInIns() {\n\t\treturn true;\n\t}\n",
    "92547": "\tpublic boolean supportsCorrelatedSubqueries() {\n\t\treturn true;\n\t}\n",
    "92548": "\tpublic boolean supportsUnion() {\n\t\treturn true;\n\t}\n",
    "92551": "\tpublic boolean supportsUnionAll() {\n\t\treturn true;\n\t}\n",
    "92555": "\tpublic boolean supportsOpenCursorsAcrossRollback() {\n\t\treturn false;\n\t}\n",
    "92558": "\tpublic boolean supportsOpenStatementsAcrossCommit() {\n\t\treturn true;\n\t}\n",
    "92561": "\tpublic boolean supportsOpenStatementsAcrossRollback() {\n\t\treturn false;\n\t}\n",
    "92564": "\tpublic int getMaxBinaryLiteralLength() {\n\t\treturn 0;\n\t}\n",
    "92565": "\tpublic int getMaxCharLiteralLength() {\n\t\treturn 0;\n\t}\n",
    "92568": "\tpublic int getMaxColumnNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92570": "\tpublic int getMaxColumnsInGroupBy() {\n\t\treturn 0;\n\t}\n",
    "92572": "\tpublic int getMaxColumnsInIndex() {\n\t\treturn 0;\n\t}\n",
    "92575": "\tpublic int getMaxColumnsInOrderBy() {\n\t\treturn 0;\n\t}\n",
    "92577": "\tpublic int getMaxColumnsInSelect() {\n\t\treturn 0;\n\t}\n",
    "92580": "\tpublic int getMaxColumnsInTable()  {\n\t\treturn 0;\n\t}\n",
    "92582": "\tpublic int getMaxConnections() {\n\t\treturn 0;\n\t}\n",
    "92585": "\tpublic int getMaxCursorNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92587": "\tpublic int getMaxIndexLength() {\n\t\treturn 0;\n\t}\n",
    "92589": "\tpublic int getMaxSchemaNameLength()  {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92592": "\tpublic int getMaxProcedureNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92593": "\tpublic int getMaxCatalogNameLength()  {\n\t\treturn 0;\n\t}\n",
    "92597": "\tpublic int getMaxRowSize() {\n\t\treturn 0;\n\t}\n",
    "92600": "\tpublic boolean doesMaxRowSizeIncludeBlobs() {\n\t\treturn true;\n\t}\n",
    "92601": "\tpublic int getMaxStatementLength() {\n\t\treturn 0;\n\t}\n",
    "92604": "\tpublic int getMaxStatements() {\n\t\treturn 0;\n\t}\n",
    "92606": "\tpublic int getMaxTableNameLength() {\n\t\treturn Limits.MAX_IDENTIFIER_LENGTH;\n\t}\n",
    "92615": "\tpublic int getMaxTablesInSelect() {\n\t\treturn 0;\n\t}\n",
    "92622": "\tpublic int getMaxUserNameLength() {\n\t\treturn Limits.DB2_MAX_USERID_LENGTH;\n\t}\n",
    "92630": "\tpublic int getDefaultTransactionIsolation() {\n\t\treturn java.sql.Connection.TRANSACTION_READ_COMMITTED;\n\t}\n",
    "92639": "\tpublic boolean supportsTransactions()  {\n\t\treturn true;\n\t}\n",
    "92656": "\tpublic boolean supportsDataDefinitionAndDataManipulationTransactions() {\n\t\t\t return true;\n\t}\n",
    "92668": "\tpublic boolean dataDefinitionCausesTransactionCommit() {\n\t\treturn false;\n\t}\n",
    "92676": "\tpublic boolean dataDefinitionIgnoredInTransactions(){\n\t\treturn false;\n\t}\n",
    "92771": "\tpublic ResultSet getSchemas() throws SQLException {\n\t\treturn getSimpleQuery(\"getSchemas\");\n\t}\n",
    "92775": "\tpublic ResultSet getCatalogs() throws SQLException {\n\t\treturn getSimpleQuery(\"getCatalogs\");\n\t}\n",
    "92779": "\tpublic ResultSet getTableTypes() throws SQLException {\n\t\treturn getSimpleQuery(\"getTableTypes\");\n\t}\n",
    "92850": "\tpublic ResultSet getTypeInfo() throws SQLException {\n\t\treturn getSimpleQuery(\"getTypeInfo\");\n\t}\n",
    "92854": "\tpublic ResultSet getTypeInfoForODBC() throws SQLException {\n\t\treturn getSimpleQuery(\"odbc_getTypeInfo\");\n\t}\n",
    "92859": "\tpublic void resetCacheStats(String cacheName) {\n\t\tgetRawStoreXact().resetCacheStats(cacheName);\n\t}\n",
    "93292": "\tpublic void writeExternal_v36(ObjectOutput out) throws IOException {\n\t\tsuper.writeExternal(out);\n\t\tout.writeLong(baseConglomerateId);\n\t\tout.writeInt(rowLocationColumn);\n\t}\n",
    "93320": "\tpublic int getColumnId() {\n\t\treturn columnId;\n\t}\n",
    "93321": "\tpublic DataValueDescriptor getOrderable() {\n\t\treturn value;\n\t}\n",
    "93322": "\tpublic int getOperator() {\n\t\treturn DataValueDescriptor.ORDER_OP_EQUALS;\n\n\t}\n",
    "93324": "\tpublic boolean negateCompareResult() {\n\t\treturn false;\n\t}\n",
    "93326": "    public boolean getUnknownRV() {\n\t\treturn false;\n\t}\n",
    "93543": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;\n\t}\n",
    "93631": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHECKSUM;\n\t}\n",
    "93688": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHECKPOINT;\n\t}\n",
    "93711": "\tpublic long getValueAsLong() {\n\t\treturn makeLogInstantAsLong(fileNumber, filePosition);\n\t}\n",
    "93715": "\tpublic void readExternal(ObjectInput oi) throws IOException, ClassNotFoundException {\n\t\tfileNumber = CompressedNumber.readLong(oi);\n\t\tfilePosition = CompressedNumber.readLong(oi);\n\t}\n",
    "93716": "\tpublic void writeExternal(ObjectOutput oo) throws IOException {\n\t\tCompressedNumber.writeLong(oo,fileNumber);\n\t\tCompressedNumber.writeLong(oo,filePosition);\n\t}\n",
    "93733": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.FILE_STREAM_LOG_FILE;\n\t}\n",
    "93746": "\tpublic int\tgetId() {\n\t\treturn recordId;\n\t}\n",
    "93753": "\tpublic boolean lockerAlwaysCompatible() {\n\t\treturn true;\n\t}\n",
    "93757": "\tpublic boolean equals(Object ref) {\n\n\t\tif (!(ref instanceof RecordId))\n\t\t\treturn false;\n\n\t\tRecordId other = (RecordId) ref;\n\n\t\treturn ((recordId == other.recordId)\n\t\t\t&& pageId.equals(other.pageId));\n\t}\n",
    "93758": "\tpublic int hashCode() {\n\n\t\treturn (int) recordId ^ pageId.hashCode();\n\t}\n",
    "93764": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_INVALIDATE_PAGE;\n\t}\n",
    "93773": "\tpublic void removeContainer() throws StandardException {\n\t\tcontainer.removeContainer();\n\t}\n",
    "93774": "\tpublic Logger getLogger() {\n\n\t\tif (ReadOnlyDB)\n\t\t\treturn null;\n\t\telse\n\t\t\treturn new FileLogger(this);\n\t}\n",
    "93775": "\tpublic ContainerKey getId() {\n\t\treturn identity;\n\t}\n",
    "93777": "\tpublic boolean useContainer() throws StandardException {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(!active);\n\t\t\tSanityManager.ASSERT(container != null);\n\t\t}\n\n\t\t// always set forUpdate to false\n\t\tif (!container.use(this)) {\n\t\t\tcontainer = null;\n\t\t\treturn false;\n\t\t}\n\n\t\tactive = true;\n\n\t\t// watch transaction and close ourseleves just before it completes.\n        if (!hold)\n        {\n            xact.addObserver(this);\n            xact.addObserver(new DropOnCommit(identity, true));\n        }\n\n\t\treturn true;\n\t}\n",
    "93788": "\tpublic Page addPage(int flag) throws StandardException {\n\n\t\tif ((flag & ContainerHandle.ADD_PAGE_BULK) != 0 && active && forUpdate)\n\t\t{\n\t\t\t// start preallocating immediatelly, don't wait for the\n\t\t\t// preallocation threshold to be crossed.  Don't go wild and\n\t\t\t// preallocate a bunch of pages either, use preAllocate for that. \n\t\t\tcontainer.clearPreallocThreshold();\n\t\t}\n\n\t\treturn addPage();\n\t}\n",
    "93879": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_UPDATE;\n\t}\n",
    "93880": "\tpublic int getNextStartColumn() {\n\t\treturn nextColumn;\n\t}\n",
    "93931": "\tpublic Cacheable setIdentity(Object key) throws StandardException {\n\n\t\tContainerKey newIdentity = (ContainerKey) key;\n\n\t\t// if this is an open for a temp container then return an object of that type\n\t\tif (newIdentity.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT) {\n\n\t\t\tTempRAFContainer tmpContainer = new TempRAFContainer(dataFactory);\n\t\t\treturn tmpContainer.setIdent(newIdentity);\n\t\t}\n\n\t\treturn setIdent(newIdentity);\n\t}\n",
    "93950": "\tprotected void flushAll() throws StandardException {\n\n\t\tpageCache.clean(identity);\n\n\t\t// now clean myself which will sync all my pages.\n\t\tclean(false);\n\t}\n",
    "93980": "\tpublic boolean isDirty() {\n\n\t\tsynchronized (this) {\n\t\t\treturn isDirty || preDirty;\n\t\t}\n\t}\n",
    "93981": "\tpublic boolean isActuallyDirty() {\n\n\t\tsynchronized (this) {\n\t\t\treturn isDirty;\n\t\t}\n\t\t\n\t}\n",
    "93998": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_REMOVE_FILE;\n\t}\n",
    "94007": "\tprotected void createContainer(ContainerKey newIdentity) throws StandardException {\n\t\t// RESOLVE - probably should throw an error ...\n\t}\n",
    "94008": "\tprotected void readPositionedPage(long pageOffset, byte[] pageData) throws IOException {\n\n\n\t\tInputStream is = null;\n\t\ttry {\n\t\t\t// no need to synchronize as each caller gets a new stream\n\t\t\tis = getInputStream();\n\n\t\t\tInputStreamUtil.skipBytes(is, pageOffset);\n\n\t\t\tInputStreamUtil.readFully(is, pageData, 0, pageSize);\n\n\t\t\tis.close();\n\t\t\tis = null;\n\t\t} finally {\n\t\t\tif (is != null) {\n\t\t\t\ttry {is.close();} catch (IOException ioe) {}\n\t\t\t}\n\t\t}\n\t}\n",
    "94017": "\tpublic InputStream getReplayStream() throws IOException {\n\t\tbh.startReading();\n\t\trecording = false;\n\t\treturn new ByteHolderInputStream(bh);\n\t}\n",
    "94018": "\tpublic ByteHolder getByteHolder() throws IOException {\n\t\treturn bh;\n\t}\n",
    "94020": "\tpublic void clear() throws IOException {\n\t\tbh.clear();\n\t\trecording = true;\n\t}\n",
    "94021": "\tpublic void setInput(InputStream in) {\n\t\tthis.in = in;\n\t}\n",
    "94022": "\tpublic boolean recording() {\n\t\treturn recording;\n\t}\n",
    "94023": "\tpublic int available() throws IOException {\n\t\t// may not have set reading to be true, then,\n\t\t// we are getting available in negative numbers.\n\t\tint remainingBytes = bh.available();\n\t\tremainingBytes = remainingBytes > 0 ? remainingBytes : (-1) * remainingBytes;\n\t\treturn remainingBytes;\n\t}\n",
    "94025": "\tpublic int shiftToFront() throws IOException {\n\t\tint bytesShifted = bh.shiftToFront();\n\t\treturn bytesShifted;\n\t}\n",
    "94059": "\tpublic Object getIdentity() {\n\t\treturn identity;\n\t}\n",
    "94087": "\tpublic void unlatch() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(isLatched());\n\t\t}\n\n\t   releaseExclusive();\n\t}\n",
    "94104": "\tpublic boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "94108": "\tpublic boolean lockerAlwaysCompatible() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "94109": "\tpublic void unlockEvent(Latch lockInfo) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(owner != null, \"Should only be called when locked\");\n\t\t}\n\n\t\tsynchronized (this) {\n\n\t\t\tif (SanityManager.DEBUG) {\n\t\t\t\tif (nestedLatch != 0)\n\t\t\t\t\tSanityManager.THROWASSERT(\"nestedLatch is non-zero on unlockEvent - value = \" + nestedLatch);\n\t\t\t}\n\n\t\t\towner.deleteObserver(this);\n\t\t\towner = null;\n\t\t\tmyLatch = null;\n\t\t\tif (inClean)\n\t\t\t\tnotifyAll();\n\t\t}\n\t}\n",
    "94115": "\tpublic PageKey getPageId() {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(identity != null);\n\t\t}\n\n\t\treturn identity;\n\t}\n",
    "94118": "\tprotected void releaseExclusive() /* throws StandardException */ {\n\n\t\tif (SanityManager.DEBUG) {\n            if (!isLatched())\n            {\n                SanityManager.THROWASSERT(\n                    \"releaseExclusive failed, nestedLatch = \" + nestedLatch);\n            }\n\t\t}\n\n\t\tif (nestedLatch > 0) {\n\t\t\tnestedLatch--;\n\t\t\treturn;\n\t\t}\n\n\t\tRawTransaction t = owner.getTransaction();\n\t\tt.getLockFactory().unlatch(myLatch);\n\t}\n",
    "94122": "\tpublic int setDeleteStatus(int slot, boolean delete) throws StandardException, IOException {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\t// latch check performed in checkSlotOnPage\n\t\t\tcheckSlotOnPage(slot);;\n\t\t}\n\n\t\treturn (getHeaderAtSlot(slot).setDeleted(delete));\n\t}\n",
    "94129": "\tpublic int findRecordById(int recordId, int slotHint) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(isLatched());\n\t\t}\n\n\t\tif (slotHint == FIRST_SLOT_NUMBER)\n\t\t\tslotHint = recordId - RecordHandle.FIRST_RECORD_ID;\n\n\t\tint\tmaxSlot = recordCount();\n\n       if ((slotHint > FIRST_SLOT_NUMBER)        &&\n            (slotHint < maxSlot)                   && \n            (recordId == getHeaderAtSlot(slotHint).getId())) {\n            return(slotHint);\n        } else {\n            for (int slot = FIRST_SLOT_NUMBER; slot < maxSlot; slot++) {\n\t\t\t\tif (recordId == getHeaderAtSlot(slot).getId()) {\n                    return slot;\n\t\t\t\t}\n            }\n        }\n\n\t\treturn -1;\n\t}\n",
    "94292": "\tprotected void letGo(BaseContainerHandle handle) {\n\n\t\tRawTransaction t = handle.getTransaction();\n\n\t\thandle.getLockingPolicy().unlockContainer(t, handle);\n\t}\n",
    "94304": "\tprotected void setDroppedState(boolean isDropped) {\n\t\tthis.isDropped = isDropped;\n\t}\n",
    "94311": "\tpublic void update(Observable obj, Object arg) {\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (arg == null)\n\t\t\t\tSanityManager.THROWASSERT(\"still on observr list \" + this);\n\t\t}\n\n\t\tif (arg.equals(RawTransaction.COMMIT) || arg.equals(RawTransaction.ABORT)) {\n\n\t\t\tRawTransaction xact = (RawTransaction) obj;\n\n\t\t\ttry {\n\t\t\t\tif (this.isStreamContainer)\n\t\t\t\t\txact.dropStreamContainer(identity.getSegmentId(), identity.getContainerId());\n\t\t\t\telse\n\t\t\t\t\txact.dropContainer(identity);\n\t\t\t} catch (StandardException se) {\n\t\t\t\txact.setObserverException(se);\n\t\t\t}\n\n\t\t\tobj.deleteObserver(this);\n\t\t}\n\t}\n",
    "94332": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_SET_RESERVED_SPACE;\n\t}\n",
    "94378": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_CHAIN_ALLOC_PAGE;\n\t}\n",
    "94475": "\tpublic StandardException markCorrupt(StandardException originalError) {\n\t\tboolean firsttime = !isCorrupt;\n\n\t\tisCorrupt = true;\n\t\tif (getLogFactory() != null)\n\t\t\tgetLogFactory().markCorrupt(originalError);\n\n\t\t// if firsttime markCorrupt is called, release the JBMS lock so user\n\t\t// can move the database if so desired.\n\t\tif (firsttime)\n\t\t{\n\t\t\t// get rid of everything from the cache without first cleaning them\n\t\t\tif (pageCache != null)\n\t\t\t\tpageCache.discard(null);\n\n\t\t\tif (containerCache != null)\n\t\t\t\tcontainerCache.discard(null);\n\n\t\t\t// don't read in any more pages \n\t\t\tpageCache = null;\n\t\t\tcontainerCache = null;\n\n\t\t\treleaseJBMSLockOnDB();\n\t\t}\n\n\t\treturn originalError;\n\t}\n",
    "94490": "\tpublic String getRootDirectory() {\n\t\treturn dataDirectory;\n\t}\n",
    "94511": "\tprivate boolean handleServiceType( Properties startParams, String type) {\n        try\n        {\n            PersistentService ps = Monitor.getMonitor().getServiceProvider( startParams, type);\n            return ps != null && ps.hasStorageFactory();\n        }\n        catch( StandardException se){ return false;}\n\t}\n",
    "94538": "\tpublic void postRecovery() throws StandardException {\n\n\t\t// hook up the cache cleaner daemon after recovery is finished\n\t\tDaemonService daemon = rawStoreFactory.getDaemon();\n\n\t\tif (daemon == null)\n\t\t\treturn;\n\n\t\tcontainerCache.useDaemonService(daemon);\n\n\t\tpageCache.useDaemonService(daemon);\n\t\tif (postRecoveryRemovedFiles != null) {\n\n            synchronized( this)\n            {\n                actionCode = POST_RECOVERY_REMOVE_ACTION;\n                try\n                {\n                    AccessController.doPrivileged( this);\n                }\n                catch( PrivilegedActionException pae){} // POST_RECOVERY_REMOVE does not throw an exception\n            }\n\t\t\tpostRecoveryRemovedFiles = null;\n\t\t}\n\t}\n",
    "94554": "\tpublic boolean isReadOnly() {\n\t\t// return what the baseDataFileFactory thinks\n\t\treturn readOnly;\n\t}\n",
    "94561": "  final public void methodCallParameterList(Vector parameterList) throws ParseException, StandardException {\n    jj_consume_token(LEFT_PAREN);\n    if (jj_2_30(1)) {\n      methodParameter(parameterList);\n      label_17:\n      while (true) {\n        switch (jj_nt.kind) {\n        case COMMA:\n          ;\n          break;\n        default:\n          jj_la1[145] = jj_gen;\n          break label_17;\n        }\n        jj_consume_token(COMMA);\n        methodParameter(parameterList);\n      }\n    } else {\n      ;\n    }\n    jj_consume_token(RIGHT_PAREN);\n  }\n",
    "94576": "\tprotected void letGo(BaseContainerHandle handle) {\n\t\tsuper.letGo(handle);\n\n\t\tcontainerCache.release(this);\n\t}\n",
    "94584": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_COMPRESS_SPACE;\n\t}\n",
    "94614": "\tprotected void letGo(BaseContainerHandle handle) {\n\n\t\tinUseCount--;\n\t\tsuper.letGo(handle);\n\t}\n",
    "94616": "\tpublic boolean isSingleUser() {\n\t\treturn inUseCount == 1;\n\t}\n",
    "94638": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_UPDATE_FIELD;\n\t}\n",
    "94656": "\tpublic boolean equals(Object other) {\n\t\tif (other instanceof ContainerActionOnCommit) {\n\t\t\tif (!identity.equals(((ContainerActionOnCommit) other).identity))\n\t\t\t\treturn false;\n\n\t\t\t// the class of the types must match as well\n\t\t\treturn getClass().equals(other.getClass());\n\t\t}\n\t\treturn false;\n\t}\n",
    "94716": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_GLOBAL_XACT_ID_NEW;\n\t}\n",
    "94725": "\tpublic void resetCacheStats(String cacheName)  {\n\t\tgetDataFactory().resetCacheStats(cacheName);\n\t}\n",
    "94726": "\tpublic boolean anyoneBlocked() {\n\t\treturn getLockFactory().anyoneBlocked();\n\t}\n",
    "94746": "\tpublic void setTransactionId(GlobalTransactionId extid, TransactionId localid) {\n\n\t\tif (SanityManager.DEBUG) {\n\n\t\t\t//SanityManager.ASSERT(myGlobalId == null, \"my globalId is not null\");\n            if (!(state == IDLE || state == Xact.ACTIVE || \n                  (state== CLOSED && justCreated)))\n            {\n                SanityManager.THROWASSERT(\n                    \"my state is not idle nor active \" + state);\n            }\n\t\t}\n\n\t\tmyGlobalId = extid;\n\t\tmyId = localid;\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tif (SanityManager.DEBUG_ON(\"XATrace\") && extid != null)\n            {\n\t\t\t\tSanityManager.DEBUG(\n                    \"XATrace\",\"setting xid: \" + myId + \" \" + myGlobalId \n\t\t\t\t\t\t\t   + \" state \" + state + \" \" + this);\n\n                SanityManager.showTrace(new Throwable());\n                // Thread.dumpStack();\n            }\n\t\t}\n\n\t}\n",
    "94813": "\tprivate void getLogger() {\n\n\t\tlogger = logFactory.getLogger();\n\t}\n",
    "94898": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_BEGIN_XACT;\n\t}\n",
    "94908": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_TRANSACTION_TABLE_ENTRY;\n\t}\n",
    "94991": "\tpublic LockFactory getLockFactory() {\n\t\treturn lockFactory;\n\t}\n",
    "95011": "\tpublic StandardException markCorrupt(StandardException originalError) {\n\t\tlogFactory.markCorrupt(originalError);\n\t\treturn originalError;\n\t}\n",
    "95040": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.RAW_STORE_XACT_ID;\n\t}\n",
    "95048": "\tpublic boolean canSupport(Properties startParams) {\n\t\treturn true;\n\t}\n",
    "95052": "\tpublic boolean isReadOnly() {\n\t\treturn dataFactory.isReadOnly();\n\t}\n",
    "95131": "\tpublic String getString(int columnNumber)\n\t{\t\t\n\t\tString val = (String)currentRow.get(columnInfo[columnNumber-1].getName());\n\t\twasNull = (val == null);\n\n\t\treturn  val;\n\t}\n",
    "95455": "\tpublic boolean isAutoIncrement(int column) throws SQLException {\n\t\tthrow new SQLException(\"isAutoIncrement\");\n\t}\n",
    "95457": "\tpublic boolean isCaseSensitive(int column) throws SQLException {\n\t\tthrow new SQLException(\"isCaseSensitive\");\n\t}\n",
    "95458": "\tpublic boolean isSearchable(int column) throws SQLException{\n\t\tthrow new SQLException(\"isSearchable\");\n\t}\n",
    "95459": "\tpublic boolean isCurrency(int column) throws SQLException{\n\t\tthrow new SQLException(\"isCurrency\");\n\t}\n",
    "95460": "\tpublic int isNullable(int column) throws SQLException{\n\t\tthrow new SQLException(\"isNullable\");\n\t}\n",
    "95461": "\tpublic boolean isSigned(int column) throws SQLException {\n\t\tthrow new SQLException(\"isSigned\");\n\t}\n",
    "95463": "\tpublic  int getColumnDisplaySize(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnDisplaySize\");\n\t}\n",
    "95465": "\tpublic String getColumnLabel(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnLabel\");\n\t}\n",
    "95466": "\tpublic String getColumnName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnName\");\n\t}\n",
    "95467": "\tpublic  String getSchemaName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getSchemaName\");\n\t}\n",
    "95468": "\tpublic int getPrecision(int column) throws SQLException {\n\t\tthrow new SQLException(\"getPrecision\");\n\t}\n",
    "95469": "\tpublic  int getScale(int column) throws SQLException {\n\t\tthrow new SQLException(\"getScale\");\n\t}\n",
    "95471": "\tpublic  String getTableName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getTableName\");\n\t}\n",
    "95472": "\tpublic String getCatalogName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getCatalogName\");\n\t}\n",
    "95473": "\tpublic  String getColumnTypeName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnTypeName\");\n\t}\n",
    "95474": "\tpublic  boolean isReadOnly(int column) throws SQLException {\n\t\treturn true;\n\t}\n",
    "95475": "\tpublic  boolean isWritable(int column) throws SQLException {\n\t\treturn false;\n\t}\n",
    "95476": "\tpublic boolean isDefinitelyWritable(int column) throws SQLException {\n\t\treturn false;\n\t}\n",
    "95477": "\tpublic String getColumnClassName(int column) throws SQLException {\n\t\tthrow new SQLException(\"getColumnClassName\");\n\t}\n",
    "95612": "\tpublic void skipField(ObjectInput in) throws IOException {\n\n\n\t\tint fieldStatus = StoredFieldHeader.readStatus(in);\n\t\tint fieldDataLength = StoredFieldHeader.readFieldDataLength(in, fieldStatus, slotFieldSize);\n\n\t\tif (fieldDataLength != 0) {\n\t\t\tin.skipBytes(fieldDataLength);\n\t\t}\n\t}\n",
    "95656": "\tprotected void closeCurrentConnectionHandle() throws SQLException {\n\t\tif (currentConnectionHandle != null)\n\t\t{\n\t\t\tVector tmpEventListener = eventListener;\n\t\t\teventListener = null;\n\n\t\t\ttry {\n\t\t\t\tcurrentConnectionHandle.close();\n\t\t\t} finally {\n\t\t\t\teventListener = tmpEventListener;\n\t\t\t}\n\n\t\t\tcurrentConnectionHandle = null;\n\t\t}\n\t}\n",
    "95659": "\tpublic void notifyException(SQLException sqle) {\n\t\tthis.notifyError(sqle);\n\t}\n",
    "95662": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\t}\n",
    "95663": "\tpublic void checkSavepoint() throws SQLException {\n\t}\n",
    "95665": "\tpublic void checkRollback() throws SQLException {\n\t}\n",
    "95666": "\tpublic void checkCommit() throws SQLException {\n\t}\n",
    "95667": "\tpublic boolean closingConnection() throws SQLException {\n\t\tnotifyClose();\n\t\tcurrentConnectionHandle = null;\n\t\treturn false;\n\t}\n",
    "95669": "\tpublic Statement wrapStatement(Statement s) throws SQLException {\n\t\treturn s;\n\t}\n",
    "95670": "\tpublic PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {\n\t\treturn ps;\n\t}\n",
    "95671": "\tpublic CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {\n\t\treturn cs;\n\t}\n",
    "95695": "\tpublic int getLoginTimeout() throws SQLException {\n\t\treturn loginTimeout;\n\t}\n",
    "95696": "\tpublic void setLoginTimeout(int seconds) throws SQLException {\n\t\tloginTimeout = seconds;\n\t}\n",
    "95697": "\tpublic PrintWriter getLogWriter() throws SQLException {\n\t\treturn printer;\n\t}\n",
    "95698": "\tpublic void setLogWriter(PrintWriter out) throws SQLException {\n\t\tprinter = out;\n\t}\n",
    "95703": "\tpublic boolean acceptsURL(String url) throws SQLException {\n\t\treturn getRegisteredDriver().acceptsURL(url);\n\t}\n",
    "95705": "\tpublic int getMajorVersion() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().getMajorVersion());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "95706": "\tpublic int getMinorVersion() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().getMinorVersion());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn 0;\n\t\t}\n\t}\n",
    "95707": "\tpublic boolean jdbcCompliant() {\n\t\ttry {\n\t\t\treturn (getRegisteredDriver().jdbcCompliant());\n\t\t}\n\t\tcatch (SQLException se) {\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "95714": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\t\txaConnection.checkHoldCursors(holdability);\n\t}\n",
    "95718": "\tpublic void checkAutoCommit(boolean autoCommit) throws SQLException {\n\t\tif (autoCommit && (currentXid != null))\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_AUTOCOMMIT_XA);\n\n\t\tsuper.checkAutoCommit(autoCommit);\n\t}\n",
    "95720": "\tpublic void checkHoldCursors(int holdability) throws SQLException {\n\n\t\tif (holdability == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {\t\t\n\t\t\tif (currentXid != null)\n\t\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);\n\t\t}\n\n\t\tsuper.checkHoldCursors(holdability);\n\t}\n",
    "95723": "\tpublic void checkSavepoint() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);\n\n\t\tsuper.checkSavepoint();\n\t}\n",
    "95724": "\tpublic void checkRollback() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_ROLLBACK_XA);\n\n\t\tsuper.checkRollback();\n\t}\n",
    "95725": "\tpublic void checkCommit() throws SQLException {\n\n\t\tif (currentXid != null)\n\t\t\tthrow Util.generateCsSQLException(SQLState.CANNOT_COMMIT_XA);\n\n\t\tsuper.checkCommit();\n\t}\n",
    "95727": "\tpublic Statement wrapStatement(Statement s) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, s);\n\t\treturn sc.applicationStatement;\n\t}\n",
    "95728": "\tpublic PreparedStatement wrapStatement(PreparedStatement ps, String sql, Object generatedKeys) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, ps, sql, generatedKeys);\n\t\treturn (PreparedStatement) sc.applicationStatement;\n\t}\n",
    "95730": "\tpublic CallableStatement wrapStatement(CallableStatement cs, String sql) throws SQLException {\n\t\tXAStatementControl sc = new XAStatementControl(this, cs, sql);\n\t\treturn (CallableStatement) sc.applicationStatement;\n\t}\n",
    "95763": "\tpublic String getErrorProperty(String type) {\n\t\treturn getErrorProperty(getMessageId(), type);\n\t}\n",
    "95764": "\tpublic String toString() {\n\t\tString msg = getMessage();\n\n\t\treturn \"ERROR \" + getSQLState() + \": \" + msg;\n\t}\n",
    "95796": "\tpublic ByteArray getFileFormat() throws IOException {\n\n\t\tint classFileSize = 4 + (10 * 2);\n\t\tclassFileSize += cptEstimatedSize;\n\n\t\tif (interfaces != null)\n\t\t\tclassFileSize += (interfaces.length * 2);\n\n\t\tif (field_info != null)\n\t\t\tclassFileSize += field_info.classFileSize();\n\n\t\tif (method_info != null)\n\t\t\tclassFileSize += method_info.classFileSize();\n\n\t\tif (attribute_info != null)\n\t\t\tclassFileSize += attribute_info.classFileSize();\n\n\t\n\t\tClassFormatOutput cfo = new ClassFormatOutput(classFileSize + 200);\n\n\t\tput(cfo);\n\n\t\treturn new ByteArray(cfo.getData(), 0, cfo.size());\n\n\t}\n",
    "95824": "\tprotected int addEntry(Object key, ConstantPoolEntry item) {\n\n\t\titem.setIndex(cptEntries.size());\n\t\tif (key != null)\n\t\t\tcptHashTable.put(key, item);\n\t\tcptEntries.addElement(item);\n\n\t\tcptEstimatedSize += item.classFileSize();\n\n\t\tif (item.doubleSlot()) {\n\t\t\tcptEntries.addElement(null);\n\t\t\treturn 2;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n",
    "95825": "\tprivate int addDirectEntry(ConstantPoolEntry item) {\n\t\tConstantPoolEntry existingItem = findMatchingEntry(item);\n\t\tif (existingItem != null) {\n\t\t\titem = existingItem;\n\t\t\t//foundCount++;\n\t\t}\n\t\telse {\n\t\t\taddEntry(item.getKey(), item);\n\t\t}\n\t\treturn item.getIndex();\n\t}\n",
    "95826": "\tprivate int addIndexReference(int tag, int i1, int i2) {\n\n\t\t// search for the item using the pre-allocated object \n\t\tsearchIndex.set(tag, i1, i2);\n\n\t\tConstantPoolEntry item = findMatchingEntry(searchIndex);\n\n\t\tif (item == null) {\n\t\t\titem = new CONSTANT_Index_info(tag, i1, i2);\n\t\t\taddEntry(item.getKey(), item);\n\t\t}\n\n\t\treturn item.getIndex();\n\t}\n",
    "95827": "\tpublic int addClassReference(String fullyQualifiedName) {\n\t\tif (ClassHolder.isExternalClassName(fullyQualifiedName)) {\n\t\t\tfullyQualifiedName = ClassHolder.convertToInternalClassName(fullyQualifiedName);\n\t\t\t// System.out.println(\"addClassReference \" + fullyQualifiedName);\n\t\t}\n\n\t\tint name_index = addUtf8Entry(fullyQualifiedName).getIndex();\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_Class, name_index, 0);\n\t}\n",
    "95828": "\tprivate int addNameAndType(String name, String descriptor) {\n\t\tint nameIndex = addUtf8Entry(name).getIndex();\n\n\t\tint descriptorIndex = addUtf8Entry(descriptor).getIndex();\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_NameAndType, nameIndex, descriptorIndex);\n\t}\n",
    "95831": "\tprivate CONSTANT_Utf8_info addUtf8Entry(String value) {\n\n\t\tCONSTANT_Utf8_info item = (CONSTANT_Utf8_info) findMatchingEntry(value);\n\n\t\tif (item == null) {\n\n\t\t\titem = new CONSTANT_Utf8_info(value);\n\t\t\taddEntry(value, item);\n\t\t}\n\t\treturn item;\n\t}\n",
    "95833": "\tprivate CONSTANT_Utf8_info addExtraUtf8(String value) {\n\n\t\tCONSTANT_Utf8_info item = new CONSTANT_Utf8_info(value);\n\t\taddEntry(null, item);\n\n\t\treturn item;\n\t}\n",
    "95834": "\tprivate int addString(String value) {\n\t\tCONSTANT_Utf8_info sutf = addUtf8Entry(value);\n\t\tint valueIndex = sutf.setAsString();\n\t\tif (valueIndex == 0) {\n\t\t\t// string is already being used as code\n\t\t\tvalueIndex = addExtraUtf8(value).getIndex();\n\t\t\tsutf.setAlternative(valueIndex);\n\t\t}\n\n\t\treturn addIndexReference(VMDescriptor.CONSTANT_String, valueIndex, 0);\n\t}\n",
    "95835": "\tprivate int addCodeUtf8(String value) {\n\t\tCONSTANT_Utf8_info sutf = addUtf8Entry(value);\n\t\tint index = sutf.setAsCode();\n\t\tif (index == 0) {\n\t\t\t// code string is already being used as string\n\t\t\tCONSTANT_Utf8_info eutf = addExtraUtf8(value);\n\t\t\teutf.setAsCode(); // ensure the replace will happen\n\t\t\tindex = eutf.getIndex();\n\t\t\tsutf.setAlternative(index);\n\t\t}\n\n\t\treturn index;\n\t}\n",
    "95838": "\tpublic int findClass(String fullyQualifiedName) {\n\t\tString internalName = ClassHolder.convertToInternalClassName(fullyQualifiedName);\n\t\tint utf_index = findUtf8(internalName);\n\t\tif (utf_index < 0)\n\t\t\treturn -1;\n\n\t\treturn findIndexIndex(VMDescriptor.CONSTANT_Class,\n\t\t\tutf_index, 0);\n\t}\n",
    "95839": "\tpublic int findNameAndType(String name, String descriptor) {\n\n\t\tint name_index = findUtf8(name);\n\t\tif (name_index < 0)\n\t\t\treturn -1;\n\t\tint descriptor_index = findUtf8(descriptor);\n\t\tif (descriptor_index < 0)\n\t\t\treturn -1;\n\n\t\treturn findIndexIndex(VMDescriptor.CONSTANT_NameAndType,\n\t\t\tname_index, descriptor_index);\n\t}\n",
    "95850": "\tstatic private String makeDesc (String className, int arity, boolean descriptor) {\n\n\t\tif (!descriptor && (arity == 0)) {\n\t\t\treturn className.replace('.','/');\n\t\t}\n\n\t\tStringBuffer desc = new StringBuffer(arity+2+className.length());\n\n\t\tfor (int i=0;i<arity;i++)\n\t\t\tdesc.append(VMDescriptor.C_ARRAY);\n\n\t\tdesc.append(VMDescriptor.C_CLASS);\n\n\t\tdesc.append(className.replace('.','/'));\n\n\t\tdesc.append(VMDescriptor.C_ENDCLASS);\n\n\t\treturn desc.toString();\n\t}\n",
    "95892": "\tprivate void checkInterrupt() {\n\t\tif (shutdown) {\n\t\t\t// system must have changed underneath us\n\t\t\tthrow new ShutdownException();\n\t\t}\n\t}\n",
    "95893": "\tpublic void setLocaleFinder(LocaleFinder finder) {\n\t\tthis.finder = finder;\n\t}\n",
    "95906": "\tpublic ContextManager getCurrentContextManager() {\n\n\t\tThread me = Thread.currentThread();\n\n\t\tObject list = threadContextList.get();\n\n\t\tif (list instanceof ContextManager) {\n\t\t\t\n\t\t\tContextManager cm = (ContextManager) list;\n\t\t\tif (cm.activeThread == me)\n\t\t\t\treturn cm;\n\t\t\treturn null;\n\t\t}\n\n\t\tif (list == null)\n\t\t\treturn null;\n\n\t\tjava.util.Stack stack = (java.util.Stack) list;\n\t\treturn (ContextManager) (stack.peek());\n\n\n\t//\tif (list == null)\n\t//\t\treturn null;\n\n\t\t/*\t\tThread me = Thread.currentThread();\n\t\t\n\t\tsynchronized (this) {\n\t\t\tfor (Iterator i = allContexts.iterator(); i.hasNext(); ) {\n\n\t\t\t\tContextManager cm = (ContextManager) i.next();\n\t\t\t\tif (cm.activeThread == me)\n\t\t\t\t\treturn cm;\n\t\t\t}\n\t\t}\n\t\t//OLDreturn (ContextManager) get(me);\n\t\treturn null;\n*/\t}\n",
    "95924": "\tstatic public void DEBUG_PRINT(String flag, String message) {\n\t\tjava.io.PrintWriter debugStream = GET_DEBUG_STREAM();\n\n\t\tdebugStream.println(\"DEBUG \"+flag+\" OUTPUT: \" + message);\n\t\tdebugStream.flush();\n\t}\n",
    "95931": "\tpublic int getCount() {\n\t\treturn count;\n\t}\n",
    "95933": "\tpublic void setLimit(int limit) {\n\n\t\tcount = 0;\n\n\t\tthis.limit = limit;\n\n\t\treturn;\n\t}\n",
    "95935": "\tpublic  void write(int b) throws IOException {\n\t\t\n\t\tif ((limit >= 0) && ((count + 1) > limit)) {\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tout.write(b);\n\t\tcount++;\n\t}\n",
    "95937": "\tpublic void write(byte b[], int off, int len) throws IOException {\n\n\t\tif ((limit >= 0) && ((count + len) > limit)) {\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tout.write(b, off, len);\n\t\tcount += len;\n\t}\n",
    "95967": "\tpublic void setData(byte[] data) {\n\t\tpageData = data;\n\t\tclearLimit();\n\t}\n",
    "95977": "\tpublic int setLimit(int offset, int length) throws IOException {\n\n\t\tif ((offset < 0) || (length < 0)) {\n\t\t\tstart = end = position = 0;\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tstart = offset;\n\t\tend = offset + length;\n\n\t\tif (end > pageData.length) {\n\t\t\tstart = end = position = 0;\n\t\t\tthrow new EOFException();\n\t\t}\n\n\t\tposition = start;\n\n\t\treturn length;\n\t}\n",
    "95982": "\tpublic  void write(int b)  {\n\t}\n",
    "95983": "\tpublic void write(byte b[]) {\n\t}\n",
    "95984": "\tpublic void write(byte b[], int off, int len)  {\n\t}\n",
    "96002": "\tpublic void discardLeft(int amountToShrinkBy) {\n\n\t\tSystem.arraycopy(buf, amountToShrinkBy, buf, 0,\n\t\t\tused - amountToShrinkBy);\n\n\t\tposition -= amountToShrinkBy;\n\t\tused -= amountToShrinkBy;\n\t}\n",
    "96022": "\tpublic void setLimit(int length) {\n\t\tremainingBytes = length;\n\t\tlimitInPlace = true;\n\t\treturn;\n\t}\n",
    "96023": "\tpublic int clearLimit() {\n\t\tint leftOver = remainingBytes;\n\t\tlimitInPlace = false;\n\t\tremainingBytes = -1;\n\t\treturn leftOver;\n\t}\n",
    "96038": "\tpublic void clearDefaults() {\n\t\tdefaults = null;\n\t}\n",
    "96055": "\tpublic int getLength() {\n\t\treturn lengthAsBits;\n\t}\n",
    "96104": "\tprivate boolean isLong(int fieldSize, int overflowThreshold) {\n\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (overflowThreshold == 0) \n\t\t\t\tSanityManager.THROWASSERT(\"overflowThreshold cannot be 0\");\n\t\t}\n\n\t\t// if a field size is over the threshold, then it becomes a long column\n\t\tint maxThresholdSize = maxFieldSize * overflowThreshold / 100;\n\t\treturn (fieldSize > maxThresholdSize);\n\t}\n",
    "96106": "\tprivate boolean isMethodMoreSpecificOrEqual(Member T, Member U, boolean[] isParam) {\n\n\t\tClass[] TC;\n\t\tClass[] UC;\n\n\t\tif (T instanceof Method) {\n\t\t\tif (!classConvertableFromTo(T.getDeclaringClass(), U.getDeclaringClass(), true))\n\t\t\t\treturn false;\n\n\t\t\tTC = ((Method) T).getParameterTypes();\n\t\t\tUC = ((Method) U).getParameterTypes();\n\t\t} else {\n\t\t\tTC = ((Constructor) T).getParameterTypes();\n\t\t\tUC = ((Constructor) U).getParameterTypes();\n\t\t}\n\n\t\treturn signatureConvertableFromTo(TC, null, UC, isParam, true);\n\t}\n",
    "96124": "\tpublic boolean isAlpha() {\n\t\treturn\t   (majorVersion >= 5)\n\t\t\t\t&& (minorVersion > 2)\n\t\t\t\t&& ((maintVersion / MAINT_ENCODING) == 0);\n\t}\n",
    "96127": "    public int getBuildNumberAsInt(){\n    \tif (buildNumber == null)\n    \t    return -1;\n    \tboolean dubiousCode = false;\n    \tint offset = buildNumber.indexOf('M');\n    \tif (offset == -1)\n    \t    offset = buildNumber.indexOf(':');\n    \telse\n    \t    dubiousCode = true;\n    \tif (offset == -1)\n    \t\toffset = buildNumber.length();\n        else\n            dubiousCode = true;\n    \t\n    \ttry {\n    \t\tint bnai = Integer.parseInt(buildNumber.substring(0, offset));\n    \t\tif (dubiousCode)\n    \t\t    bnai = -bnai;\n    \t\treturn bnai;\n    \t} catch (NumberFormatException nfe) \n     \t{\n     \t\treturn -1;\n    \t}\n    }\n",
    "96130": "\tpublic String getSimpleVersionString() {\n\n\t\treturn ProductVersionHolder.simpleVersionString(majorVersion, minorVersion, isBeta());\n\t}\n",
    "96156": "\tpublic boolean equals(Object other) {\n\t\tif (other instanceof ByteArray) {\n\t\t\tByteArray ob = (ByteArray) other;\n\t\t\treturn ByteArray.equals(array, offset, length, ob.array, ob.offset, ob.length);\n\t\t}\n\t\treturn false;\n\t}\n",
    "96216": "\tpublic boolean isAutoincAlways(){\n\t\treturn (columnDefaultInfo == null) && isAutoincrement();\n\t}\n",
    "96617": "\tpublic void syncState() throws SQLException {\n\t\tConnection conn = getRealConnection();\n\n\t\tstateIsolationLevel = conn.getTransactionIsolation();\n\t\tstateReadOnly = conn.isReadOnly();\n\t\tstateAutoCommit = conn.getAutoCommit();\n\t\t// jdk13 does not have Connection.getHoldability method and hence using\n\t\t// reflection to cover both jdk13 and higher jdks\n\t\ttry {\n\t\t\tMethod sh = conn.getClass().getMethod(\"getHoldability\", null);\n\t\t\tstateHoldability = ((Integer)sh.invoke(conn, null)).intValue();\n\t\t} catch( Exception e)\n\t\t{\n\t\t\tthrow PublicAPI.wrapStandardException( StandardException.plainWrapException( e));\n\t\t}       \n\t}\n",
    "96664": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_DATE_ID;\n\t}\n",
    "96713": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_LONGINT_ID;\n\t}\n",
    "96791": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_TIMESTAMP_ID;\n\t}\n",
    "96825": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_CHAR_ID;\n\t}\n",
    "96878": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_REF_ID;\n\t}  \n",
    "96913": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_BOOLEAN_ID;\n\t}\n",
    "96983": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_LONGVARCHAR_ID;\n\t}\n",
    "97030": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_INTEGER_ID;\n\t}\n",
    "97229": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_VARCHAR_ID;\n\t}\n",
    "97237": "\tpublic void setInto(ResultSet rs, int position) throws SQLException, StandardException {\n\t\trs.updateObject(position, getObject());\n\t}\n",
    "97249": "\tpublic int\t\t\t\t\ttypePrecedence() {\n\t\treturn -1;\n\t}\n",
    "97253": "        public int getTypeFormatId() {\n                return StoredFormatIds.SQL_NCLOB_ID;\n        }\n",
    "97371": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_REAL_ID;\n\t}\n",
    "97456": "\tpublic DataValueDescriptor getNull() {\n\t\treturn typeId.getNull();\n\t}\n",
    "97504": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_SMALLINT_ID;\n\t}\n",
    "97558": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_CHAR_ID;\n\t}\n",
    "97638": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_DOUBLE_ID;\n\t}\n",
    "97685": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_CLOB_ID;\n\t}\n",
    "97749": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_TIME_ID;\n\t}\n",
    "97807": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_VARCHAR_ID;\n\t}\n",
    "97821": "\tprotected int typeCompare(DataValueDescriptor arg) throws StandardException {\n\t\t\n\t\tBigIntegerDecimal obid = getBID(arg);\n\t\t\n\t\t// need to align scales to perform comparisions\n\t\tint tscale = getDecimalValueScale();\n\t\tint oscale = obid.getDecimalValueScale();\n\t\n\t\tBigInteger tbi = new BigInteger(data2c);\n\t\tBigInteger obi = new BigInteger(obid.data2c);\n\t\t\n\t\tif (tscale < oscale)\n\t\t\ttbi = BigIntegerDecimal.rescale(tbi, oscale - tscale);\n\t\telse if (oscale < tscale)\n\t\t\tobi = BigIntegerDecimal.rescale(obi, tscale - oscale);\n\t\n\t\treturn tbi.compareTo(obi);\n\t}\n",
    "97824": "\tpublic NumberDataValue minus(NumberDataValue result) throws StandardException {\n\t\t\n\t\tif (result == null)\n\t\t\tresult = (NumberDataValue) getNewNull();\n\n\t\tif (isNull())\n\t\t\tresult.setToNull();\n\t\telse\n\t\t{\n\t\t\tBinaryDecimal rbd = (BinaryDecimal) result;\n\t\t\t\n\t\t\tBigInteger bi = new BigInteger(data2c);\n\t\t\t// scale remains unchanged.\n\t\t\trbd.data2c = bi.negate().toByteArray();\n\t\t\trbd.sqlScale = sqlScale;\n\t\t\n\t\t}\n\t\t\t\n\t\treturn result;\n\t}\n",
    "97838": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_NATIONAL_LONGVARCHAR_ID;\n\t}\n",
    "97873": "\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_USERTYPE_ID_V3;\n\t}\n",
    "97957": "\tpublic long getContainerId() {\n\t\treturn containerId;\n\t}\n",
    "97982": "        public boolean  streamStorable() {\n                return isStringTypeId() || isBitTypeId();\n        }\n",
    "97991": "\tpublic void checkLogicalOperationOk() throws StandardException {\n\t}\n",
    "97992": "\tpublic boolean recoveryRollbackFirst() {\n\t\treturn false;\n\t}\n",
    "97994": "\tpublic void setObserverException(StandardException se) {\n\t\tif (observerException == null)\n\t\t\tobserverException = se;\n\t}\n",
    "97995": "\tpublic void notifyObservers(Object arg) {\n\t\tif (countObservers() != 0) {\n\t\t\tsetChanged();\n\t\t\tsuper.notifyObservers(arg);\n\t\t}\n\t}\n",
    "98034": "    public boolean inField() {\n        return false;\n    }\n",
    "98036": "    public boolean inConstructor() {\n        return false;\n    }\n",
    "98037": "    public boolean inMethod() {\n        return false;\n    }\n",
    "98038": "    public boolean inOverview() {\n        return true;\n    }\n",
    "98039": "    public boolean inPackage() {\n        return true;\n    }\n",
    "98040": "    public boolean inType() {\n        return true;\n    }\n",
    "98041": "    public boolean isInlineTag() {\n        return false;\n    }\n",
    "98042": "    public String toString(Tag tag) {\n        return \"\\n<dt><table cellpadding=2 cellspacing=2><tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr>\\n\";\n    }\n",
    "98043": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<table cellpadding=2 cellspacing=2><tr><td>\" + ROWNAME + \"</td><td>\" ;\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"\\n\";\n    }\n",
    "98053": "    public String toString(Tag tag) {\n        return \"<tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr>\\n\";\n    }\n",
    "98054": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<tr><td>\" + ROWNAME + \"</td><td>\";\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"\\n\";\n    }\n",
    "98086": "    public String toString(Tag tag) {\n        return \"<tr><td>\" + ROWNAME + \"</td>\"\n               + \"<td>\" + tag.text() + \"</td></tr></table>\\n\";\n    }\n",
    "98088": "    public String toString(Tag[] tags) {\n        if (tags.length == 0) {\n            return null;\n        }\n        String result = \"<tr><td>\" + ROWNAME + \"</td><td>\" ;\n        for (int i = 0; i < tags.length; i++) {\n            if (i > 0) {\n                result += \"\";\n            }\n            result += tags[i].text() + \"</td></tr>\";\n        }\n        return result + \"</table></dt>\\n\";\n    }\n",
    "98104": "\tprivate void doTrace(Throwable t) {\n\t\tif (util.getSystemProperty(\"ij.exceptionTrace\") != null) {\n\t\t\tt.printStackTrace(out);\n\t\t}\n\t\tout.flush();\n\t}\n",
    "98193": "\tpublic void ReInit(Reader s) { \n\t    try {\n\t\t\tsource.close();\n\t\t} catch (IOException ioe) {\n\t\t\t// just be quiet if it is already gone\n\t\t}\n\t\tsource = s;\n\t\tstate = IN_STATEMENT;\n\t\tatEOF = false;\n\t\tpeekEOF = false;\n\t\tpeeked = false;\n\t}\n",
    "98202": "\tprivate boolean whiteSpace(char c) {\n\t\treturn (c == SPACE ||\n\t\t    \tc == TAB ||\n\t\t    \tc == RETURN ||\n\t\t    \tc == NEWLINE ||\n\t\t    \tc == FORMFEED);\n\t}\n",
    "98208": "\tprivate void readString(char stringDelimiter) {\n\t\tstate = IN_STRING;\n\t\tdo {\n\t\t\tchar nextChar = readChar();\n\n\t\t\tif (atEOF()) {\n\t\t\t\tstate = END_OF_INPUT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nextChar == stringDelimiter) {\n\t\t\t\t// we've reached the end of the string\n\t\t\t\tstate = IN_STATEMENT;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// still in string\n\t\t} while (state == IN_STRING); // could be while true...\n\t}\n",
    "98217": "\tprivate char readChar() {\n\t\tif (!peeked) peekChar();\n\n\t\tpeeked = false;\n\t\tatEOF = peekEOF;\n\n\t\tif (!atEOF) statement.append(peekChar);\n\n\t\treturn peekChar;\n\t}\n",
    "98218": "\tprivate char peekChar() {\n\t\tpeeked = true;\n\t\tchar c = '\\00';\n\n\t\ttry {\n\t\t    int cInt;\n\n\t\t\t// REMIND: this is assuming a flat ascii source file.\n\t\t\t// will need to beef it up at some future point to\n\t\t\t// understand whether the stream is ascii or something else.\n\t\t\tcInt = source.read();\n\t\t\tpeekEOF = (cInt == -1);\n\t\t\tif (!peekEOF) c = (char)cInt;\n\t\t} catch (IOException ie) {\n\t\t\tthrow ijException.iOException(ie);\n\t\t}\n\n\t\tpeekChar = c;\n\t\treturn c;\n\t}\n",
    "98352": "\tstatic public boolean getPropertyArg(String[] args) throws IOException {\n\t\tString n;\n\t\tInputStream in1;\n\t\tProperties p;\n\n\t\tif ((n = getArg(\"-p\", args))!= null){\n\t\t\tin1 = new FileInputStream(n);\n\t\t\tin1 = new BufferedInputStream(in1);\n\t\t}\n\t\telse if ((n = getArg(\"-pr\", args)) != null) {\n\t\t\tin1 = getResourceAsStream(n);\n\t\t\tif (in1 == null) throw ijException.resourceNotFound();\n\t\t}\n\t\telse\n\t\t\treturn false;\n\n\t\tp = System.getProperties();\n\n\t\t// Trim off excess whitespace in property file, if any, and\n\t\t// then load those properties into 'p'.\n\t\tutil.loadWithTrimmedValues(in1, p);\n\n\t\treturn true;\n\t}\n",
    "98357": "\tstatic public String getFileArg(String[] args) throws IOException {\n\t\tString fileName;\n\t\tint fLocn;\n\t\tboolean foundP = false;\n\n\t\tif (args == null) return null;\n\t\tif ((fileName=getArg(\"-f\",args))!=null) return fileName;\n\t\t//\n\t\t//The first unknown arg is the file\n\t\tfor (int ix=0; ix < args.length; ix++)\n\t\t\tif(args[ix].equals(\"-f\")  ||\n\t\t\t   args[ix].equals(\"-fr\") ||\n\t\t\t   args[ix].equals(\"-ca\")  ||\n\t\t\t   args[ix].equals(\"-car\")  ||\n\t\t\t   args[ix].equals(\"-p\")  ||\n\t\t\t   args[ix].equals(\"-pr\"))\n\t\t\t\tix++; //skip the parameter to these args\n\t\t\telse\n\t\t\t\treturn args[ix];\n\t\treturn null;\n\t}\n",
    "98359": " \tstatic public String getInputResourceNameArg(String[] args) {\n\t\treturn getArg(\"-fr\", args);\n\t}\n",
    "98363": "    static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n\t\treturn startJBMS(null,null);\n\t}\n",
    "98410": "  final public ijResult ProtocolStatement() throws ParseException, SQLException {\n        Token t;\n        String n = null;\n    jj_consume_token(PROTOCOL);\n    t = jj_consume_token(STRING);\n    if (jj_2_56(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                installProtocol(n, stringValue(t.image));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98431": "\tstatic public boolean init() {\n\t\treturn (LocalizedResource.getInstance() != null);\n\t}\n",
    "98433": "\tstatic public void ShowException(PrintWriter out, Throwable e) {\n\t\tif (e == null) return;\n\n\t\tif (e instanceof SQLException)\n\t\t\tShowSQLException(out, (SQLException)e);\n\t\telse\n\t\t\te.printStackTrace(out);\n\t}\n",
    "98434": "\tstatic public void ShowSQLException(PrintWriter out, SQLException e) {\n\t\tString errorCode;\n\n\t\tif (Boolean.getBoolean(\"ij.showErrorCode\")) {\n\t\t\terrorCode = LocalizedResource.getMessage(\"UT_Error0\", LocalizedResource.getNumber(e.getErrorCode()));\n\t\t}\n\t\telse {\n\t\t\terrorCode = \"\";\n\t\t}\n\n\t\twhile (e!=null) {\n\t\t\tString p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage(\"UT_NoSqlst\"));\n\t\t\tString p2 = mapNull(e.getMessage(),LocalizedResource.getMessage(\"UT_NoMessa\"));\n\t\t\tout.println(LocalizedResource.getMessage(\"UT_Error012\", p1, p2,errorCode));\n\t\t\tdoTrace(out, e);\n\t\t\te=e.getNextException();\n\t\t}\n\t}\n",
    "98435": "\tstatic public void ShowWarnings(PrintWriter out, Connection theConnection) {\n\t    try {\n\t\t// GET CONNECTION WARNINGS\n\t\tSQLWarning warning = null;\n\n\t\tif (theConnection != null) {\n\t\t\tShowWarnings(out, theConnection.getWarnings());\n\t\t}\n\n\t\tif (theConnection != null) {\n\t\t\ttheConnection.clearWarnings();\n\t\t}\n\t    } catch (SQLException e) {\n\t\t\tShowSQLException(out, e);\n\t    }\n\t} // ShowWarnings\n",
    "98437": "\tstatic public void ShowWarnings(PrintWriter out, ResultSet rs) {\n\t    try {\n\t\t// GET RESULTSET WARNINGS\n\t\tSQLWarning warning = null;\n\n\t\tif (rs != null) {\n\t\t\tShowWarnings(out, rs.getWarnings());\n\t\t}\n\n\t\tif (rs != null) {\n\t\t\trs.clearWarnings();\n\t\t}\n\t    } catch (SQLException e) {\n\t\t\tShowSQLException(out, e);\n\t    }\n\t} // ShowResultSetWarnings\n",
    "98454": "  final public ijResult SetConnectionStatement() throws ParseException, SQLException {\n        String t;\n    jj_consume_token(SET);\n    jj_consume_token(CONNECTION);\n    t = identifier();\n                if (!currentConnEnv.haveSession(t)) {\n                        {if (true) throw ijException.noSuchConnection(t);}\n                }\n                currentConnEnv.setCurrentSession(t);\n                theConnection = currentConnEnv.getConnection();\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98459": "  final public ijResult ShowConnectionsStatement() throws ParseException, SQLException {\n    jj_consume_token(SHOW);\n    jj_consume_token(CONNECTIONS);\n                {if (true) return showConnectionsMethod(false);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98460": "\tstatic public String mapNull(String s, String nullValue) {\n\t\tif (s==null) return nullValue;\n\t\treturn s;\n\t}\n",
    "98463": "\tstatic public void doTrace(PrintWriter out, Exception e) {\n\t\tif (Boolean.getBoolean(\"ij.exceptionTrace\")) {\n\t\t\te.printStackTrace(out);\n\t\t    out.flush();\n\t\t}\n\t}\n",
    "98466": "  final public ijResult CommitStatement() throws ParseException, SQLException {\n    jj_consume_token(COMMIT);\n    if (jj_2_67(2)) {\n      jj_consume_token(WORK);\n    } else {\n      ;\n    }\n                haveConnection();\n                theConnection.commit();\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98474": "  final public ijResult RollbackStatement() throws ParseException, SQLException {\n    jj_consume_token(ROLLBACK);\n    if (jj_2_68(2)) {\n      jj_consume_token(WORK);\n    } else {\n      ;\n    }\n                haveConnection();\n                theConnection.rollback();\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98587": "    public void shutdown() {\n\ttry{\n\t    for(int i=0;i<sockets.size();i++) {\n\t\t(datain.get(i)).close();\n\t\t(dataout.get(i)).close();\n\t\t(sockets.get(i)).close();\n\t\tSystem.out.println(\"Socket closed\");\n\t    } // end for\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem shutting down\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end shutdown\n",
    "98588": "    public boolean addServer(String IP) {\n\ttry {\n\t    sockets.add(new Socket(IP,port));\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Unable to connect to \"+IP+\":\"+port);\n\t    System.out.println(e);\n\t    return false;\n\t}// end catch\n\treturn true;\n    } // end addServer(String)\n",
    "98589": "    public void addDataStreams(int index) {\n\ttry {\n\t    dataout.add(new DataOutputStream((sockets.get(index)).getOutputStream()));\n\t    datain.add(new DataInputStream((sockets.get(index)).getInputStream()));\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem creating data streams\");\n\t    System.out.println(\"**** ADD CODE TO PROPERLY CLOSE STUFF HERE ****\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end addDataStreams(int)\n",
    "98592": "    public void badCommand(String rcv, String exp) {\n\tSystem.out.println(\"Received \\\"\" + rcv + \"\\\"\");\n\tSystem.out.println(\"Expected \\\"\" + exp + \"\\\"\");\n    } // end badCommand(String,String)\n",
    "98593": "    public int checkOS() {\n\tif(System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")) {\n\t    return 0;\n\t} // end if linux\n\tif(System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n\t    return 1;\n\t}\n\treturn 2;\n    } // end checkOS()\n",
    "98596": "    public boolean lookForConnection() {\n\t/* Wait for client to connect */\n\tCSocket = null;\n\ttry {\n\t    CSocket = SSocket.accept();\n\t    System.out.println(\"CONNECTION ACCEPTED\");\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Unable to accept connection\");\n\t    System.out.println(e);\n\t    return false;\n\t} // end catch\n\n\t/* Add the data streams */\n\ttry {\n\t    din = new DataInputStream(CSocket.getInputStream());\n\t    dout = new DataOutputStream(CSocket.getOutputStream());\n\t    return true;\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem with Data Streams\");\n\t    System.out.println(e);\n\t    return false;\n\t} // end catch\n    } // end lookForConnection()\n",
    "98598": "    public void closeConnection() {\n\ttry {\n\t    din.close();\n\t    dout.close();\n\t    CSocket.close();\n\t    System.out.println(\"CSocket Closed\");\n\t} // end try\n\tcatch(IOException e) {\n\t    System.out.println(\"Problem closing connection\");\n\t    System.out.println(e);\n\t} // end catch\n    } // end shutdown\n",
    "98599": "    public PointType getPoint() {\n        return point;\n    }\n",
    "98600": "    public void setPoint(PointType value) {\n        this.point = value;\n    }\n",
    "98611": "    public Pos getPos() {\n        return pos;\n    }\n",
    "98612": "    public void setPos(Pos value) {\n        this.pos = value;\n    }\n",
    "98626": "    public void setPointMembers(List<PointMember> pointMembers) {\n        this.pointMembers = pointMembers;\n    }\n",
    "98639": "    public String getSrsName() {\n        return srsName;\n    }\n",
    "98640": "    public void setSrsName(String value) {\n        this.srsName = value;\n    }\n",
    "98650": "    public void set_Geometry(JAXBElement<? extends AbstractGeometryType> value) {\n        this.geometry = ((JAXBElement<? extends AbstractGeometryType> ) value);\n    }\n",
    "98662": "    public MultiCurveType getMultiCurve() {\n        return multiCurve;\n    }\n",
    "98663": "    public void setMultiCurve(MultiCurveType value) {\n        this.multiCurve = value;\n    }\n",
    "98675": "    public AbstractRingPropertyType getExterior() {\n        return exterior;\n    }\n",
    "98677": "    public void setExterior(AbstractRingPropertyType value) {\n        this.exterior = value;\n    }\n",
    "98681": "    public SurfaceInterpolationType getInterpolation() {\n        if (interpolation == null) {\n            return SurfaceInterpolationType.PLANAR;\n        } else {\n            return interpolation;\n        }\n    }\n",
    "98682": "    public void setInterpolation(SurfaceInterpolationType value) {\n        this.interpolation = value;\n    }\n",
    "98684": "    public void setInteriors(List<AbstractRingPropertyType> interiors) {\n        this.interiors = interiors;\n    }\n",
    "98698": "    public String getValue() {\n        return value;\n    }\n",
    "98699": "    public void setValue(String value) {\n        this.value = value;\n    }\n",
    "98701": "    public String getCodeSpace() {\n        return codeSpace;\n    }\n",
    "98702": "    public void setCodeSpace(String value) {\n        this.codeSpace = value;\n    }\n",
    "98732": "    public BoundedBy createBoundedBy() {\n        return new BoundedBy();\n    }\n",
    "98733": "    public LineStringSegmentType createLineStringSegmentType() {\n        return new LineStringSegmentType();\n    }\n",
    "98734": "    public MultiPointType createMultiPointType() {\n        return new MultiPointType();\n    }\n",
    "98735": "    public Segments createSegments() {\n        return new Segments();\n    }\n",
    "98737": "    public MultiSurfacePropertyType createMultiSurfacePropertyType() {\n        return new MultiSurfacePropertyType();\n    }\n",
    "98738": "    public PolygonPatchType createPolygonPatchType() {\n        return new PolygonPatchType();\n    }\n",
    "98739": "    public GeometryPropertyType createGeometryPropertyType() {\n        return new GeometryPropertyType();\n    }\n",
    "98740": "    public MeasureType createMeasureType() {\n        return new MeasureType();\n    }\n",
    "98741": "    public PointType createPointType() {\n        return new PointType();\n    }\n",
    "98742": "    public PolygonType createPolygonType() {\n        return new PolygonType();\n    }\n",
    "98743": "    public CurveType createCurveType() {\n        return new CurveType();\n    }\n",
    "98745": "    public PosList createPosList() {\n        return new PosList();\n    }\n",
    "98747": "    public AbstractRingPropertyType createAbstractRingPropertyType() {\n        return new AbstractRingPropertyType();\n    }\n",
    "98748": "    public PointMember createPointMember() {\n        return new PointMember();\n    }\n",
    "98750": "    public LineStringType createLineStringType() {\n        return new LineStringType();\n    }\n",
    "98751": "    public MultiCurvePropertyType createMultiCurvePropertyType() {\n        return new MultiCurvePropertyType();\n    }\n",
    "98752": "    public MultiSurfaceType createMultiSurfaceType() {\n        return new MultiSurfaceType();\n    }\n",
    "98753": "    public ReferenceType createReferenceType() {\n        return new ReferenceType();\n    }\n",
    "98754": "    public Patches createPatches() {\n        return new Patches();\n    }\n",
    "98755": "    public MultiPointPropertyType createMultiPointPropertyType() {\n        return new MultiPointPropertyType();\n    }\n",
    "98756": "    public MultiGeometryPropertyType createMultiGeometryPropertyType() {\n        return new MultiGeometryPropertyType();\n    }\n",
    "98757": "    public MultiCurveType createMultiCurveType() {\n        return new MultiCurveType();\n    }\n",
    "98759": "    public Pos createPos() {\n        return new Pos();\n    }\n",
    "98761": "    public SurfaceMember createSurfaceMember() {\n        return new SurfaceMember();\n    }\n",
    "98762": "    public SurfaceType createSurfaceType() {\n        return new SurfaceType();\n    }\n",
    "98765": "    public LinearRingType createLinearRingType() {\n        return new LinearRingType();\n    }\n",
    "98766": "    public AbstractFeatureBaseType createAbstractFeatureBaseType() {\n        return new AbstractFeatureBaseType();\n    }\n",
    "98767": "    public AbstractSurfaceType createAbstractSurfaceType() {\n        return new AbstractSurfaceType();\n    }\n",
    "98768": "    public Envelope createEnvelope() {\n        return new Envelope();\n    }\n",
    "98769": "    public Name createName() {\n        return new Name();\n    }\n",
    "98770": "    public CurveMember createCurveMember() {\n        return new CurveMember();\n    }\n",
    "98776": "  final public ijResult JBMSPreparedStatementExec() throws ParseException, SQLException {\n        Token s = null;\n    jj_consume_token(EXECUTE);\n    jj_consume_token(STATEMENT);\n    s = jj_consume_token(STRING);\n                {if (true) return executeImmediate(stringValue(s.image));}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98780": "    public String getType() {\n        if (type == null) {\n            return \"simple\";\n        } else {\n            return type;\n        }\n    }\n",
    "98781": "    public void setType(String value) {\n        this.type = value;\n    }\n",
    "98783": "    public String getHref() {\n        return href;\n    }\n",
    "98784": "    public void setHref(String value) {\n        this.href = value;\n    }\n",
    "98787": "    public String getRole() {\n        return role;\n    }\n",
    "98788": "    public void setRole(String value) {\n        this.role = value;\n    }\n",
    "98791": "    public String getArcrole() {\n        return arcrole;\n    }\n",
    "98792": "    public void setArcrole(String value) {\n        this.arcrole = value;\n    }\n",
    "98795": "    public void setTitle(String value) {\n        this.title = value;\n    }\n",
    "98796": "  final public ijResult F2KExecuteProcedure() throws ParseException, SQLException {\n        Token s = null;\n    jj_consume_token(EXECUTE);\n    jj_consume_token(PROCEDURE);\n    s = jj_consume_token(STRING);\n                haveConnection();\n\n                Statement       aStatement = theConnection.createStatement();\n                String          text = \"execute procedure \" + s;\n\n                aStatement.execute( text );\n\n                {if (true) return new ijStatementResult( aStatement,true );}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98798": "    public String getShow() {\n        return show;\n    }\n",
    "98799": "    public void setShow(String value) {\n        this.show = value;\n    }\n",
    "98801": "    public String getActuate() {\n        return actuate;\n    }\n",
    "98802": "    public void setActuate(String value) {\n        this.actuate = value;\n    }\n",
    "98816": "    public MultiSurfaceType getMultiSurface() {\n        return multiSurface;\n    }\n",
    "98817": "    public void setMultiSurface(MultiSurfaceType value) {\n        this.multiSurface = value;\n    }\n",
    "98842": "    public void setDescription(String value) {\n        this.description = value;\n    }\n",
    "98844": "  final public ijResult AsyncStatement() throws ParseException, SQLException {\n        Token s = null;\n        String n = null;\n    jj_consume_token(ASYNC);\n    n = identifier();\n    s = jj_consume_token(STRING);\n            {if (true) return executeAsync(stringValue(s.image), n);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98847": "    public String getId() {\n        return id;\n    }\n",
    "98848": "    public void setId(String value) {\n        this.id = value;\n    }\n",
    "98861": "    public void set_GeometricAggregate(JAXBElement<? extends AbstractGeometricAggregateType> value) {\n        this.geometricAggregate = ((JAXBElement<? extends AbstractGeometricAggregateType> ) value);\n    }\n",
    "98869": "  final public ijResult WaitForStatement() throws ParseException, SQLException {\n        Token s = null;\n        String n = null;\n    jj_consume_token(WAIT);\n    jj_consume_token(FOR);\n    n = identifier();\n                AsyncStatement as = currentConnEnv.getSession().getAsyncStatement(n);\n                if (as == null) {if (true) throw ijException.noSuchAsyncStatement(n);}\n                try {\n                    as.join(); // we wait for it to finish.\n                } catch (InterruptedException ie) {\n                        {if (true) throw ijException.waitInterrupted(ie);}\n                }\n                {if (true) return as.getResult();}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98893": "    public MultiPointType getMultiPoint() {\n        return multiPoint;\n    }\n",
    "98894": "  final public ijResult RemoveStatement() throws ParseException, SQLException {\n        String i;\n        PreparedStatement ps;\n    jj_consume_token(REMOVE);\n    i = identifier();\n                haveConnection();\n                Session s = currentConnEnv.getSession();\n                ps = (PreparedStatement) s.getPreparedStatement(i);\n                JDBCDisplayUtil.checkNotNull(ps,\"prepared statement \"+i);\n                ps.close();\n                s.removePreparedStatement(i);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98895": "    public void setMultiPoint(MultiPointType value) {\n        this.multiPoint = value;\n    }\n",
    "98907": "    public void setSegments(Segments value) {\n        this.segments = value;\n    }\n",
    "98937": "    public void set_Surface(JAXBElement<? extends AbstractSurfaceType> value) {\n        this.surface = ((JAXBElement<? extends AbstractSurfaceType> ) value);\n    }\n",
    "98949": "    public Envelope getEnvelope() {\n        return envelope;\n    }\n",
    "98950": "    public void setEnvelope(Envelope value) {\n        this.envelope = value;\n    }\n",
    "98964": "    public void set_SurfacePatches(List<JAXBElement<? extends AbstractSurfacePatchType>> surfacePatches) {\n        this.surfacePatches = surfacePatches;\n    }\n",
    "98970": "  final public ijResult AutocommitStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(AUTOCOMMIT);\n    if (jj_2_87(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_88(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                haveConnection();\n                // REMIND: want to warn if unchanged?\n                theConnection.setAutoCommit((on==null?false:true));\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "98975": "    public BoundedBy getBoundedBy() {\n        return boundedBy;\n    }\n",
    "98976": "    public void setBoundedBy(BoundedBy value) {\n        this.boundedBy = value;\n    }\n",
    "98988": "    public void setPatches(Patches value) {\n        this.patches = value;\n    }\n",
    "99000": "    public void set_Curve(JAXBElement<? extends AbstractCurveType> value) {\n        this.curve = ((JAXBElement<? extends AbstractCurveType> ) value);\n    }\n",
    "99004": "  final public ijResult NoHoldForConnectionStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(NOHOLDFORCONNECTION);\n                haveConnection();\n                theConnection = utilInstance.setHoldability(theConnection, JDBC30Translation.CLOSE_CURSORS_AT_COMMIT);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99013": "    public PosList getPosList() {\n        return posList;\n    }\n",
    "99014": "    public void setPosList(PosList value) {\n        this.posList = value;\n    }\n",
    "99016": "    public CurveInterpolationType getInterpolation() {\n        if (interpolation == null) {\n            return CurveInterpolationType.LINEAR;\n        } else {\n            return interpolation;\n        }\n    }\n",
    "99017": "    public void setInterpolation(CurveInterpolationType value) {\n        this.interpolation = value;\n    }\n",
    "99037": "  final public ijResult LocalizedDisplay() throws ParseException {\n        Token on=null;\n    jj_consume_token(LOCALIZEDDISPLAY);\n    if (jj_2_89(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_90(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                LocalizedResource.enableLocalization((on==null?false:true));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99057": "    public void setSurfaceMembers(List<SurfaceMember> surfaceMembers) {\n        this.surfaceMembers = surfaceMembers;\n    }\n",
    "99067": "  final public ijResult ReadOnlyStatement() throws ParseException, SQLException {\n        Token on=null;\n    jj_consume_token(READONLY);\n    if (jj_2_91(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_92(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                haveConnection();\n                theConnection.setReadOnly((on==null?false:true));\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99085": "    public void setCurveMembers(List<CurveMember> curveMembers) {\n        this.curveMembers = curveMembers;\n    }\n",
    "99095": "    public double getValue() {\n        return value;\n    }\n",
    "99096": "    public void setValue(double value) {\n        this.value = value;\n    }\n",
    "99098": "    public String getUom() {\n        return uom;\n    }\n",
    "99099": "    public void setUom(String value) {\n        this.uom = value;\n    }\n",
    "99101": "  final public ijResult ElapsedTimeStatement() throws ParseException {\n        Token on=null;\n    jj_consume_token(ELAPSEDTIME);\n    if (jj_2_93(2)) {\n      on = jj_consume_token(ON);\n    } else if (jj_2_94(2)) {\n      jj_consume_token(OFF);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                elapsedTime = (on != null);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99137": "    public Pos getLowerCorner() {\n        return lowerCorner;\n    }\n",
    "99138": "    public void setLowerCorner(Pos value) {\n        this.lowerCorner = value;\n    }\n",
    "99139": "  final public ijResult MaximumDisplayWidthStatement() throws ParseException {\n        int       maxWidth;\n    jj_consume_token(MAXIMUMDISPLAYWIDTH);\n    maxWidth = intValue();\n                JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99141": "    public Pos getUpperCorner() {\n        return upperCorner;\n    }\n",
    "99142": "    public void setUpperCorner(Pos value) {\n        this.upperCorner = value;\n    }\n",
    "99156": "    public LinearRingType getLinearRing() {\n        return linearRing;\n    }\n",
    "99157": "    public void setLinearRing(LinearRingType value) {\n        this.linearRing = value;\n    }\n",
    "99172": "    public void set_CurveSegments(List<JAXBElement<? extends AbstractCurveSegmentType>> curveSegments) {\n        this.curveSegments = curveSegments;\n    }\n",
    "99190": "\tpublic void applyRemark(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\n\t\t// first, remove any remarks\n\t\tremoveRemarkFromValue(remark, value);\n\t\t\n\t\t// add the remark\n\t\tvalue.getRemarks().add(remark);\n\t}\n",
    "99191": "\tpublic boolean isRemarkSet(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\t\t\n\t\tfor(TridasRemark aRemark : value.getRemarks()) {\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark)) {\n\t\t\t\t// must test for special 'disabled override'\n\t\t\t\tif(aRemark.isSetInheritedCount() && aRemark.getInheritedCount() < 0)\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n",
    "99192": "\tpublic boolean isRemarkInherited(TridasValue value) {\n\t\tTridasRemark remark = asTridasRemark();\n\t\t\n\t\tfor(TridasRemark aRemark : value.getRemarks()) {\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark)) {\n\t\t\t\t// get the inherited count from the remark associated with the value\n\t\t\t\treturn (aRemark.isSetInheritedCount() && aRemark.getInheritedCount() > 0) ? true : false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n",
    "99193": "\tpublic void overrideRemark(TridasValue value) {\n\t\tTridasRemark source = asTridasRemark();\n\t\t\n\t\t// create a copy of the remark, as we're going to be modifying it\n\t\tTridasRemark remark = (TridasRemark) source.createCopy();\n\t\tsource.copyTo(remark);\n\n\t\t// first, remove any remarks\n\t\tremoveRemarkFromValue(remark, value);\n\t\t\n\t\t// flag the new remark as disabled\n\t\tremark.setInheritedCount(-1);\n\t\t\n\t\t// add the remark\n\t\tvalue.getRemarks().add(remark);\n\t}\n",
    "99194": "\tpublic void removeRemark(TridasValue value) {\n\t\tremoveRemarkFromValue(asTridasRemark(), value);\n\t}\n",
    "99195": "\tprotected void removeRemarkFromValue(TridasRemark remark, TridasValue value) {\n\t\tListIterator<TridasRemark> remarkIterator = value.getRemarks().listIterator();\n\t\t\n\t\twhile(remarkIterator.hasNext()) {\n\t\t\tTridasRemark aRemark = remarkIterator.next();\n\t\t\t\n\t\t\tif(RemarkEquals.remarksEqual(remark, aRemark))\n\t\t\t\tremarkIterator.remove();\n\t\t}\n\t}\n",
    "99207": "    public void setName(String value) {\n        this.name = value;\n    }\n",
    "99213": "    public boolean isIsActive() {\n        return isActive;\n    }\n",
    "99214": "    public void setIsActive(boolean value) {\n        this.isActive = value;\n    }\n",
    "99230": "    public void setMeasurementVariables(List<ControlledVoc> measurementVariables) {\n        this.measurementVariables = measurementVariables;\n    }\n",
    "99242": "    public void setElementShapes(List<ControlledVoc> elementShapes) {\n        this.elementShapes = elementShapes;\n    }\n",
    "99254": "    public String getType() {\n        return type;\n    }\n",
    "99259": "    public String getObject() {\n        return object;\n    }\n",
    "99260": "    public void setObject(String value) {\n        this.object = value;\n    }\n",
    "99281": "    public void setDatingTypes(List<ControlledVoc> datingTypes) {\n        this.datingTypes = datingTypes;\n    }\n",
    "99295": "    public void setCoverageTemporals(List<ControlledVoc> coverageTemporals) {\n        this.coverageTemporals = coverageTemporals;\n    }\n",
    "99306": "    public WSISapwoodDictionary createWSISapwoodDictionary() {\n        return new WSISapwoodDictionary();\n    }\n",
    "99307": "    public WSIParam createWSIParam() {\n        return new WSIParam();\n    }\n",
    "99308": "    public WSIBox createWSIBox() {\n        return new WSIBox();\n    }\n",
    "99310": "    public WSIRequest createWSIRequest() {\n        return new WSIRequest();\n    }\n",
    "99311": "    public WSISearchParams createWSISearchParams() {\n        return new WSISearchParams();\n    }\n",
    "99312": "    public WSIRegionDictionary createWSIRegionDictionary() {\n        return new WSIRegionDictionary();\n    }\n",
    "99313": "    public WSISecurityUserDictionary createWSISecurityUserDictionary() {\n        return new WSISecurityUserDictionary();\n    }\n",
    "99314": "  final public ijResult HelpStatement() throws ParseException {\n    jj_consume_token(HELP);\n                Vector v = new Vector();\n\n                StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage(\"IJ_HelpText\"), \"\\n\");\n                while (st.hasMoreTokens()) {\n                    v.addElement(st.nextToken());\n                }\n\n                {if (true) return new ijVectorResult(v,null);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99315": "    public WSIHeartwoodDictionary createWSIHeartwoodDictionary() {\n        return new WSIHeartwoodDictionary();\n    }\n",
    "99316": "    public WSIRootElement createWSIRootElement() {\n        return new WSIRootElement();\n    }\n",
    "99317": "    public WSINonce createWSINonce() {\n        return new WSINonce();\n    }\n",
    "99318": "    public WSIMessage createWSIMessage() {\n        return new WSIMessage();\n    }\n",
    "99319": "    public WSIBoxDictionary createWSIBoxDictionary() {\n        return new WSIBoxDictionary();\n    }\n",
    "99320": "    public WSIElementAuthenticityDictionary createWSIElementAuthenticityDictionary() {\n        return new WSIElementAuthenticityDictionary();\n    }\n",
    "99321": "    public WSIEntity createWSIEntity() {\n        return new WSIEntity();\n    }\n",
    "99322": "    public WSIHelp createWSIHelp() {\n        return new WSIHelp();\n    }\n",
    "99323": "    public WSIHeader createWSIHeader() {\n        return new WSIHeader();\n    }\n",
    "99324": "    public WSILocationTypeDictionary createWSILocationTypeDictionary() {\n        return new WSILocationTypeDictionary();\n    }\n",
    "99325": "    public WSIAuthenticate createWSIAuthenticate() {\n        return new WSIAuthenticate();\n    }\n",
    "99326": "    public WSIElementTypeDictionary createWSIElementTypeDictionary() {\n        return new WSIElementTypeDictionary();\n    }\n",
    "99327": "    public WSILink createWSILink() {\n        return new WSILink();\n    }\n",
    "99328": "    public WSISampleTypeDictionary createWSISampleTypeDictionary() {\n        return new WSISampleTypeDictionary();\n    }\n",
    "99329": "    public WSIElementShapeDictionary createWSIElementShapeDictionary() {\n        return new WSIElementShapeDictionary();\n    }\n",
    "99330": "    public WSIReadingNoteDictionary createWSIReadingNoteDictionary() {\n        return new WSIReadingNoteDictionary();\n    }\n",
    "99331": "    public WSIDatingTypeDictionary createWSIDatingTypeDictionary() {\n        return new WSIDatingTypeDictionary();\n    }\n",
    "99332": "    public WSICoverageTemporalFoundationDictionary createWSICoverageTemporalFoundationDictionary() {\n        return new WSICoverageTemporalFoundationDictionary();\n    }\n",
    "99333": "    public WSITaxonDictionary createWSITaxonDictionary() {\n        return new WSITaxonDictionary();\n    }\n",
    "99335": "    public WSIContent createWSIContent() {\n        return new WSIContent();\n    }\n",
    "99336": "    public WSIMeasurementVariableDictionary createWSIMeasurementVariableDictionary() {\n        return new WSIMeasurementVariableDictionary();\n    }\n",
    "99337": "    public WSIObjectTypeDictionary createWSIObjectTypeDictionary() {\n        return new WSIObjectTypeDictionary();\n    }\n",
    "99338": "    public SecurityGroup createSecurityGroup() {\n        return new SecurityGroup();\n    }\n",
    "99339": "    public WSICoverageTemporalDictionary createWSICoverageTemporalDictionary() {\n        return new WSICoverageTemporalDictionary();\n    }\n",
    "99340": "    public SecurityUser createSecurityUser() {\n        return new SecurityUser();\n    }\n",
    "99342": "    public EntityType getType() {\n        return type;\n    }\n",
    "99343": "    public void setType(EntityType value) {\n        this.type = value;\n    }\n",
    "99360": "    public void setSqlsAndObjectsAndElements(List<Object> sqlsAndObjectsAndElements) {\n        this.sqlsAndObjectsAndElements = sqlsAndObjectsAndElements;\n    }\n",
    "99377": "    public TridasIdentifier getIdentifier() {\n        return identifier;\n    }\n",
    "99378": "    public void setIdentifier(TridasIdentifier value) {\n        this.identifier = value;\n    }\n",
    "99380": "    public DateTime getCreatedTimestamp() {\n        return createdTimestamp;\n    }\n",
    "99382": "    public void setCreatedTimestamp(DateTime value) {\n        this.createdTimestamp = value;\n    }\n",
    "99384": "    public DateTime getLastModifiedTimestamp() {\n        return lastModifiedTimestamp;\n    }\n",
    "99385": "    public void setLastModifiedTimestamp(DateTime value) {\n        this.lastModifiedTimestamp = value;\n    }\n",
    "99388": "    public String getComments() {\n        return comments;\n    }\n",
    "99389": "    public void setComments(String value) {\n        this.comments = value;\n    }\n",
    "99391": "    public String getTrackingLocation() {\n        return trackingLocation;\n    }\n",
    "99393": "    public void setTrackingLocation(String value) {\n        this.trackingLocation = value;\n    }\n",
    "99396": "    public String getCurationLocation() {\n        return curationLocation;\n    }\n",
    "99397": "    public void setCurationLocation(String value) {\n        this.curationLocation = value;\n    }\n",
    "99399": "    public Integer getSampleCount() {\n        return sampleCount;\n    }\n",
    "99400": "    public void setSampleCount(Integer value) {\n        this.sampleCount = value;\n    }\n",
    "99405": "    public void setSamples(List<TridasSample> samples) {\n        this.samples = samples;\n    }\n",
    "99422": "    public void setElementTypes(List<ControlledVoc> elementTypes) {\n        this.elementTypes = elementTypes;\n    }\n",
    "99434": "    public void setRegions(List<ControlledVoc> regions) {\n        this.regions = regions;\n    }\n",
    "99445": "    public void setDictionaries(WSIRequest.Dictionaries value) {\n        this.dictionaries = value;\n    }\n",
    "99446": "  final public ijResult XA_DataSourceStatement() throws ParseException, SQLException {\n        Token dbname = null;\n        Token shut = null;\n        String create = null;\n    jj_consume_token(XA_DATASOURCE);\n    dbname = jj_consume_token(STRING);\n    if (jj_2_105(2)) {\n      if (jj_2_103(2)) {\n        shut = jj_consume_token(SHUTDOWN);\n      } else if (jj_2_104(2)) {\n        create = identifier();\n      } else {\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    } else {\n      ;\n    }\n                xahelper.XADataSourceStatement(this, dbname, shut, create);\n\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99454": "  final public ijResult XA_ConnectStatement() throws ParseException, SQLException {\n        Token userT = null;\n        Token passwordT = null;\n        String n = null;\n    jj_consume_token(XA_CONNECT);\n    if (jj_2_106(2)) {\n      jj_consume_token(USER);\n      userT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_107(2)) {\n      jj_consume_token(PASSWORD);\n      passwordT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_108(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.XAConnectStatement(this, userT, passwordT, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99460": "  final public ijResult XA_DisconnectStatement() throws ParseException, SQLException {\n        String n = null;\n    jj_consume_token(XA_DISCONNECT);\n    if (jj_2_109(2)) {\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.XADisconnectStatement(this, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99468": "  final public ijResult XA_CommitStatement() throws ParseException, SQLException {\n        Token onePhase=null;\n        Token twoPhase=null;\n        int xid = 0;\n    jj_consume_token(XA_COMMIT);\n    if (jj_2_110(2)) {\n      onePhase = jj_consume_token(XA_1PHASE);\n    } else if (jj_2_111(2)) {\n      twoPhase = jj_consume_token(XA_2PHASE);\n    } else {\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    xid = intValue();\n                xahelper.CommitStatement(this, onePhase, twoPhase, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99475": "  final public ijResult XA_EndStatement() throws ParseException, SQLException {\n        int flag = 0;\n        int xid = 0;\n    jj_consume_token(XA_END);\n    flag = xatmflag();\n    xid = intValue();\n                xahelper.EndStatement(this, flag, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99480": "    public WSIAuthenticate getAuthenticate() {\n        return authenticate;\n    }\n",
    "99481": "  final public ijResult XA_ForgetStatement() throws ParseException, SQLException {\n        int xid = 0;\n    jj_consume_token(XA_FORGET);\n    xid = intValue();\n                xahelper.ForgetStatement(this, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99482": "    public void setAuthenticate(WSIAuthenticate value) {\n        this.authenticate = value;\n    }\n",
    "99485": "    public WSISearchParams getSearchParams() {\n        return searchParams;\n    }\n",
    "99487": "    public void setSearchParams(WSISearchParams value) {\n        this.searchParams = value;\n    }\n",
    "99488": "  final public ijResult XA_GetConnectionStatement() throws ParseException, SQLException {\n        String n = \"XA\";\n    jj_consume_token(XA_GETCONNECTION);\n    if (jj_2_112(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                theConnection = xahelper.XAGetConnectionStatement(this, n);\n                currentConnEnv.addSession(theConnection, n);\n\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99491": "    public CorinaRequestType getType() {\n        return type;\n    }\n",
    "99493": "    public void setType(CorinaRequestType value) {\n        this.type = value;\n    }\n",
    "99495": "    public CorinaRequestFormat getFormat() {\n        return format;\n    }\n",
    "99498": "    public void setFormat(CorinaRequestFormat value) {\n        this.format = value;\n    }\n",
    "99500": "    public String getParentEntityID() {\n        return parentEntityID;\n    }\n",
    "99502": "    public void setParentEntityID(String value) {\n        this.parentEntityID = value;\n    }\n",
    "99503": "  final public ijResult XA_RecoverStatement() throws ParseException, SQLException {\n        int flag = 0;\n    jj_consume_token(XA_RECOVER);\n    flag = xatmflag();\n                {if (true) return xahelper.RecoverStatement(this, flag);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99505": "    public void setProjects(List<TridasProject> projects) {\n        this.projects = projects;\n    }\n",
    "99507": "    public void setObjects(List<TridasObject> objects) {\n        this.objects = objects;\n    }\n",
    "99508": "    public void setElements(List<TridasElement> elements) {\n        this.elements = elements;\n    }\n",
    "99509": "  final public ijResult XA_RollbackStatement() throws ParseException, SQLException {\n        int xid = 0;\n    jj_consume_token(XA_ROLLBACK);\n    xid = intValue();\n                xahelper.RollbackStatement(this, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99512": "    public void setRadiuses(List<TridasRadius> radiuses) {\n        this.radiuses = radiuses;\n    }\n",
    "99513": "    public void setMeasurementSeries(List<TridasMeasurementSeries> measurementSeries) {\n        this.measurementSeries = measurementSeries;\n    }\n",
    "99516": "  final public ijResult XA_StartStatement() throws ParseException, SQLException {\n        int flag = 0;\n        int xid = 0;\n    jj_consume_token(XA_START);\n    flag = xatmflag();\n    xid = intValue();\n                xahelper.StartStatement(this, flag, xid);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99517": "    public void setDerivedSeries(List<TridasDerivedSeries> derivedSeries) {\n        this.derivedSeries = derivedSeries;\n    }\n",
    "99518": "    public void setUsers(List<SecurityUser> users) {\n        this.users = users;\n    }\n",
    "99519": "    public void setBoxes(List<WSIBox> boxes) {\n        this.boxes = boxes;\n    }\n",
    "99521": "    public void setEntities(List<WSIEntity> entities) {\n        this.entities = entities;\n    }\n",
    "99535": "  final public ijResult CP_DataSourceStatement() throws ParseException, SQLException {\n        Token dbname = null;\n        Token protocol = null;\n    jj_consume_token(CP_DATASOURCE);\n    dbname = jj_consume_token(STRING);\n    if (jj_2_125(2)) {\n      jj_consume_token(PROTOCOL);\n      protocol = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n                xahelper.CPDataSourceStatement(this, dbname, protocol);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99543": "  final public ijResult CP_ConnectStatement() throws ParseException, SQLException {\n        Token userT = null;\n        Token passwordT = null;\n        String n = null;\n    jj_consume_token(CP_CONNECT);\n    if (jj_2_126(2)) {\n      jj_consume_token(USER);\n      userT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_127(2)) {\n      jj_consume_token(PASSWORD);\n      passwordT = jj_consume_token(STRING);\n    } else {\n      ;\n    }\n    if (jj_2_128(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.CPConnectStatement(this, userT, passwordT, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99549": "  final public ijResult CP_GetConnectionStatement() throws ParseException, SQLException {\n        String n = \"Pooled\";\n    jj_consume_token(CP_GETCONNECTION);\n    if (jj_2_129(2)) {\n      jj_consume_token(AS);\n      n = identifier();\n    } else {\n      ;\n    }\n                theConnection = xahelper.CPGetConnectionStatement(this, n);\n                currentConnEnv.addSession(theConnection, n);\n                {if (true) return new ijConnectionResult(theConnection);}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99557": "    public void setTaxons(List<ControlledVoc> taxons) {\n        this.taxons = taxons;\n    }\n",
    "99562": "  final public ijResult CP_DisconnectStatement() throws ParseException, SQLException {\n        String n = null;\n    jj_consume_token(CP_DISCONNECT);\n    if (jj_2_130(2)) {\n      n = identifier();\n    } else {\n      ;\n    }\n                xahelper.CPDisconnectStatement(this, n);\n                {if (true) return null;}\n    throw new Error(\"Missing return statement in function\");\n  }\n",
    "99572": "    public void setObjectTypes(List<ControlledVoc> objectTypes) {\n        this.objectTypes = objectTypes;\n    }\n",
    "99601": "    public void setRemarks(List<TridasRemark> remarks) {\n        this.remarks = remarks;\n    }\n",
    "99613": "    public void setLocationTypes(List<ControlledVoc> locationTypes) {\n        this.locationTypes = locationTypes;\n    }\n",
    "99625": "    public void setSapwoods(List<ControlledVoc> sapwoods) {\n        this.sapwoods = sapwoods;\n    }\n",
    "99639": "    public Integer getCode() {\n        return code;\n    }\n",
    "99640": "    public void setCode(Integer value) {\n        this.code = value;\n    }\n",
    "99642": "    public void setContent(List<Object> content) {\n        this.content = content;\n    }\n",
    "99668": "    public void setHeartwoods(List<ControlledVoc> heartwoods) {\n        this.heartwoods = heartwoods;\n    }\n",
    "99679": "    public void setMemberOf(SecurityUser.MemberOf value) {\n        this.memberOf = value;\n    }\n",
    "99686": "    public String getUsername() {\n        return username;\n    }\n",
    "99687": "    public void setUsername(String value) {\n        this.username = value;\n    }\n",
    "99690": "    public String getFirstName() {\n        return firstName;\n    }\n",
    "99691": "    public void setFirstName(String value) {\n        this.firstName = value;\n    }\n",
    "99693": "    public String getLastName() {\n        return lastName;\n    }\n",
    "99694": "    public void setLastName(String value) {\n        this.lastName = value;\n    }\n",
    "99704": "    public void setPassword(String value) {\n        this.password = value;\n    }\n",
    "99720": "        public void setSecurityGroups(List<SecurityGroup> securityGroups) {\n            this.securityGroups = securityGroups;\n        }\n",
    "99734": "    public void setUser(WSIHeader.User value) {\n        this.user = value;\n    }\n",
    "99737": "    public String getWsVersion() {\n        return wsVersion;\n    }\n",
    "99739": "    public void setWsVersion(String value) {\n        this.wsVersion = value;\n    }\n",
    "99743": "    public String getClientVersion() {\n        return clientVersion;\n    }\n",
    "99744": "    public void setClientVersion(String value) {\n        this.clientVersion = value;\n    }\n",
    "99746": "    public XMLGregorianCalendar getRequestDate() {\n        return requestDate;\n    }\n",
    "99748": "    public void setRequestDate(XMLGregorianCalendar value) {\n        this.requestDate = value;\n    }\n",
    "99752": "    public void setQueryTime(WSIHeader.QueryTime value) {\n        this.queryTime = value;\n    }\n",
    "99755": "    public String getRequestUrl() {\n        return requestUrl;\n    }\n",
    "99756": "    public void setRequestUrl(String value) {\n        this.requestUrl = value;\n    }\n",
    "99760": "    public CorinaRequestType getRequestType() {\n        return requestType;\n    }\n",
    "99762": "    public void setRequestType(CorinaRequestType value) {\n        this.requestType = value;\n    }\n",
    "99764": "    public CorinaRequestStatus getStatus() {\n        return status;\n    }\n",
    "99765": "    public void setStatus(CorinaRequestStatus value) {\n        this.status = value;\n    }\n",
    "99774": "    public WSINonce getNonce() {\n        return nonce;\n    }\n",
    "99775": "    public void setNonce(WSINonce value) {\n        this.nonce = value;\n    }\n",
    "99779": "    public void setMessages(List<WSIMessage> messages) {\n        this.messages = messages;\n    }\n",
    "99780": "    public void setTimings(List<WSIHeader.Timing> timings) {\n        this.timings = timings;\n    }\n",
    "99802": "        public String getUnit() {\n            return unit;\n        }\n",
    "99804": "        public void setUnit(String value) {\n            this.unit = value;\n        }\n",
    "99827": "        public String getLabel() {\n            return label;\n        }\n",
    "99829": "        public void setLabel(String value) {\n            this.label = value;\n        }\n",
    "99860": "        public String getFirstname() {\n            return firstname;\n        }\n",
    "99862": "        public void setFirstname(String value) {\n            this.firstname = value;\n        }\n",
    "99866": "        public String getLastname() {\n            return lastname;\n        }\n",
    "99867": "        public void setLastname(String value) {\n            this.lastname = value;\n        }\n",
    "99888": "    public void setCoverageTemporalFoundations(List<ControlledVoc> coverageTemporalFoundations) {\n        this.coverageTemporalFoundations = coverageTemporalFoundations;\n    }\n",
    "99902": "    public void setElementAuthenticities(List<ControlledVoc> elementAuthenticities) {\n        this.elementAuthenticities = elementAuthenticities;\n    }\n",
    "99917": "    public String getSeq() {\n        return seq;\n    }\n",
    "99918": "    public void setSeq(String value) {\n        this.seq = value;\n    }\n",
    "99931": "    public SearchParameterName getName() {\n        return name;\n    }\n",
    "99932": "    public void setName(SearchParameterName value) {\n        this.name = value;\n    }\n",
    "99934": "    public SearchOperator getOperator() {\n        return operator;\n    }\n",
    "99935": "    public void setOperator(SearchOperator value) {\n        this.operator = value;\n    }\n",
    "99951": "    public WSIHeader getHeader() {\n        return header;\n    }\n",
    "99952": "    public void setHeader(WSIHeader value) {\n        this.header = value;\n    }\n",
    "99954": "    public WSIHelp getHelp() {\n        return help;\n    }\n",
    "99956": "    public void setHelp(WSIHelp value) {\n        this.help = value;\n    }\n",
    "99959": "    public WSIContent getContent() {\n        return content;\n    }\n",
    "99960": "    public void setContent(WSIContent value) {\n        this.content = value;\n    }\n",
    "99962": "    public WSIRequest getRequest() {\n        return request;\n    }\n",
    "99963": "    public void setRequest(WSIRequest value) {\n        this.request = value;\n    }\n",
    "99974": "    public Object getAny() {\n        return any;\n    }\n",
    "99975": "    public void setAny(Object value) {\n        this.any = value;\n    }\n",
    "99989": "    public void setAll(WSISearchParams.All value) {\n        this.all = value;\n    }\n",
    "99993": "    public SearchReturnObject getReturnObject() {\n        return returnObject;\n    }\n",
    "99994": "    public void setReturnObject(SearchReturnObject value) {\n        this.returnObject = value;\n    }\n",
    "99996": "    public Integer getLimit() {\n        return limit;\n    }\n",
    "99997": "    public void setLimit(Integer value) {\n        this.limit = value;\n    }\n",
    "99999": "    public Integer getSkip() {\n        return skip;\n    }\n",
    "100000": "    public void setSkip(Integer value) {\n        this.skip = value;\n    }\n",
    "100002": "    public boolean isIncludeChildren() {\n        return includeChildren;\n    }\n",
    "100003": "    public void setIncludeChildren(boolean value) {\n        this.includeChildren = value;\n    }\n",
    "100009": "    public void setParams(List<WSIParam> params) {\n        this.params = params;\n    }\n",
    "100038": "    public void setSampleTypes(List<ControlledVoc> sampleTypes) {\n        this.sampleTypes = sampleTypes;\n    }\n",
    "100054": "    public String getCnonce() {\n        return cnonce;\n    }\n",
    "100055": "    public void setCnonce(String value) {\n        this.cnonce = value;\n    }\n",
    "100058": "    public String getSnonce() {\n        return snonce;\n    }\n",
    "100059": "    public void setSnonce(String value) {\n        this.snonce = value;\n    }\n",
    "100062": "    public String getHash() {\n        return hash;\n    }\n",
    "100064": "    public void setHash(String value) {\n        this.hash = value;\n    }\n",
    "100109": "    public String getPref() {\n\treturn pref;\n    }\n",
    "100364": "\tpublic void clear() {\n\t\tset(null);\n\t}\n",
    "100365": "\tpublic void set(T value) {\n\t\t\n\t\t// special case for nulls (unset)\n\t\tif(value == null) {\n\t\t\tApp.prefs.setPref(prefName, null);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tswitch(underlyingType) {\n\t\tcase STRING:\n\t\t\tApp.prefs.setPref(prefName, (String) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase COLOR:\n\t\t\tApp.prefs.setColorPref(prefName, (Color) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase DIMENSION:\n\t\t\tApp.prefs.setDimensionPref(prefName, (Dimension) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase BOOLEAN:\n\t\t\tApp.prefs.setBooleanPref(prefName, (Boolean) value);\n\t\t\tbreak;\n\n\t\tcase INTEGER:\n\t\t\tApp.prefs.setIntPref(prefName, (Integer) value);\n\t\t\tbreak;\n\t\t\t\n\t\tcase FONT:\n\t\t\tApp.prefs.setFontPref(prefName, (Font) value);\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "100367": "\tpublic T get() {\n\t\treturn get(defaultValue);\n\t}\n",
    "100398": "\tpublic void setValue(OBJTYPE value) {\n\t\t// same value? ignore it\n\t\tif(prefValue == value)\n\t\t\treturn;\n\t\t\n\t\t// they equal the same thing? ignore it\n\t\tif(prefValue != null && prefValue.equals(value))\n\t\t\treturn;\n\t\t\n\t\tvalueModified = true;\n\t\tprefValue = value;\n\t\t\n\t\tif(autocommit)\n\t\t\tcommit();\n\t}\n",
    "100399": "\tpublic OBJTYPE getValue() {\n\t\treturn (OBJTYPE) prefValue;\n\t}\n",
    "100405": "    public int intValue() {\n        // i pity th' fool who tries to use intvalue!\n        throw new UnsupportedOperationException();\n    }\n",
    "100406": "    public boolean isYearOne() {\n        return (y == 1);\n    }\n",
    "100407": "    public Year add(int dy) {\n        // copy, and convert to zys\n        int r = y;\n        if (r < 0)\n            r++;\n\n        // add dy\n        r += dy;\n\n        // convert back, and return\n        if (r <= 0)\n            r--;\n        return Years.valueOf(r);\n    }\n",
    "100408": "    public int diff(Year y2) {\n        // copy, and convert to zys\n        int i1 = y;\n        if (i1 < 0)\n            i1++;\n\n        int i2 = y2.y;\n        if (i2 < 0)\n            i2++;\n\n        // subtract, and return\n        return i1 - i2;\n    }\n",
    "100409": "    public int mod(int m) {\n        int r = y % m;\n        if (r < 0)\n            r += m;\n        return r;\n    }\n",
    "100410": "    public int row() {\n        int z = y / 10;\n        if (y<0 && y%10!=0)\n            z--;\n        return z;\n    }\n",
    "100411": "    public int column() {\n        return mod(10);\n    }\n",
    "100412": "    public int compareTo(Year o2) {\n        return this.y - o2.y;\n    }\n",
    "100420": "    public String getDefaultExtension() {\n\treturn \".out\";\n    }\n",
    "100496": "\tprivate void quickVerify(BufferedReader r) throws IOException {\n\t\tr.mark(4096);\n\n\t\tString firstLine = r.readLine();\n\t\tif(firstLine == null || !firstLine.startsWith(\"<?xml\"))\n\t\t\tthrow new WrongFiletypeException();\n\t\t\n\t\tr.reset();\n\t}\n",
    "100500": "    public Sample load(BufferedReader r) throws IOException {\n        throw new WrongFiletypeException();\n    }\n",
    "100503": "    public String getDefaultExtension() {\n\treturn \".txt\";\n    }\n",
    "100639": "\tprivate void checkRemeasurable() {\n\t\t// enable if it's a valid index into both datasets!\n\t\tYear y = dv1.getSelectedYear();\n\t\tint col = dv1.myTable.getSelectedColumn();\n\t\tint idx = y.diff(s1.getStart());\n\t\tbtnRemeasure.setEnabled(col > 0 && col < 11 && idx >= 0 && idx < s1.getData().size() && idx < s2.getData().size());\t\t\n\t}\n",
    "100671": "\tprivate void performRedateInPlace(TridasDating dating) {\n\t\tsample.postEdit(Redate.redate(sample, range, dating));\n\t}\n",
    "100728": "        public void setSelection(int row, int col) {\n            if(row == -1)\n            \trow = lastRow;\n            if(col == -1)\n            \tcol = lastCol;\n\n            if(row < 0 || row >= table.getRowCount())\n            \treturn;\n            \n            if(col < 0 || col > table.getColumnCount())\n            \treturn;\n            \n            lastRow = row;\n        \ttable.setRowSelectionInterval(row, row);\n        \t\n        \tlastCol = col;\n        \ttable.setColumnSelectionInterval(col, col);\n        \t\n        \tdoReconciliation();\n        \tscrollToVisible(table, row, col);\n        }\n",
    "100752": "\tprivate void initButtons() {\n\t\t// cancel == close\n\t\tcancel = Builder.makeButton(\"general.cancel\");\n\t\tcancel.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent ae) {\n\t\t\t\tdispose();\n\t\t\t}\n\t\t});\n\n\t\t// ok == apply\n\t\tok = Builder.makeButton(\"general.ok\");\n\t\tok.addActionListener(new ActionListener() {\n\t\t\tpublic void actionPerformed(ActionEvent ae) {\n\t\t\t\t// nothing to do?\n\t\t\t\tif (r.equals(s.getRange())) {\n\t\t\t\t\tdispose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(applyTruncation())\n\t\t\t\t\tdispose();\n\t\t\t}\n\t\t});\n\t}\n",
    "100773": "\tprivate void updateResult() {\n\t\tString rangeAndSpan;\n\t\tif (r == null) {\n\t\t\trangeAndSpan = I18n.getText(\"error\");\n\t\t\tcellModifier.updateRange(s.getRange());\n\t\t}\n\t\telse {\n\t\t\trangeAndSpan = r + \" (n=\" + r.span() + \")\";\n\t\t\tcellModifier.updateRange(r);\n\t\t}\n\n\t\tresult.setText(I18n.getText(\"truncate.afterTruncating\") + \": \" + rangeAndSpan);\n\t}\n",
    "100776": "    public int height(Graphics g) {\n        return height;\n    }\n",
    "100779": "    public float getLatitudeAsDegrees() {\n        return latitude / 3600f;\n    }\n",
    "100780": "\tpublic void setFont(Font f) {\n\t\tthis.font = f;\n\t}\n",
    "100781": "    public float getLongitudeAsDegrees() {\n        return longitude / 3600f;\n    }\n",
    "100784": "    public void setLatitudeAsDegrees(float degrees) {\n        int seconds = Math.round(degrees * 3600);\n        if (seconds < MIN_LATITUDE)\n            seconds = MIN_LATITUDE;\n        else if (seconds > MAX_LATITUDE)\n            seconds = MAX_LATITUDE;\n        this.latitude = seconds;\n    }\n",
    "100786": "    public void setLongitudeAsDegrees(float degrees) {\n        int seconds = Math.round(degrees * 3600);\n\n        // need to make sure the longitude is between -180 and 179 degrees.\n        // 180 degrees, for example, gets sent back down to -180.\n        // if i were doing degrees, i'd add 180, mod 360, sub 180.\n        // so just do that in seconds.\n        seconds += 180 * 3600;\n        seconds %= 360 * 3600;\n        if (seconds <= 0)\n            seconds += 180 * 3600;\n        else\n            seconds -= 180 * 3600;\n        \n        this.longitude = seconds;\n    }\n",
    "100788": "    public int getLatitudeAsSeconds() {\n        return latitude;\n    }\n",
    "100789": "    public int getLongitudeAsSeconds() {\n        return longitude;\n    }\n",
    "100791": "    public void setLatitudeAsSeconds(int seconds) {\n        if (seconds < MIN_LATITUDE)\n            seconds = MIN_LATITUDE;\n        else if (seconds > MAX_LATITUDE)\n            seconds = MAX_LATITUDE;\n        this.latitude = seconds;\n    }\n",
    "100793": "    public void setLongitudeAsSeconds(int seconds) {\n        // make sure longitude is between -180 and 179 degrees.\n        // see setLongitudeAsDegrees().\n        seconds += 180 * 3600;\n        seconds %= 360 * 3600;\n        if (seconds <= 0)\n            seconds += 180 * 3600;\n        else\n            seconds -= 180 * 3600;\n\n        // PERF: make sure these are computed at compile-time, not run-time.\n\n        // FIXME: extract method normalizeLongitude() (lat, too, while you're at it)\n\n        this.longitude = seconds;\n    }\n",
    "100804": "    public boolean containsOnlyNumbers(String str) {\n        \n        //It can't contain only numbers if it's null or empty...\n        if (str == null || str.length() == 0)\n            return false;\n        \n        for (int i = 0; i < str.length(); i++) {\n\n            //If we find a non-digit character we return false.\n            if (!Character.isDigit(str.charAt(i)))\n                return false;\n        }\n        \n        return true;\n    }\n",
    "100851": "\tprotected void repaintParent() {\n\t\tif(listener != null)\n\t\t\tlistener.cellModifierChanged(this);\n\t}\n",
    "100862": "\tpublic int getRowCount() {\n\t\t// these need to be updated when the user inserts/deletes\n\t\tcountRows();\n\n\t\t// compute num rows\n\t\tint n = row_max - row_min + 1;\n\n\t\t// always give a blank space for more data entry; if the last year\n\t\t// is the last year of this decade, we'll need another decade\n\t\tif (s.getRange().getEnd().column() == 9)\n\t\t\tn++;\n\n\t\treturn n;\n\t}\n",
    "100863": "\tpublic int getColumnCount() {\n\t\treturn 12;\n\t}\n",
    "100878": "\tprivate Icon lazyLoadIcon(String iconName) {\n\t\tif(iconName == null)\n\t\t\treturn null;\n\t\t\n\t\tIcon icon = lazyIconMap.get(iconName);\n\t\tif(icon == null) {\n\t\t\t// lazy-load the icon\n\t\t\ticon = Builder.getIcon(iconName, 16);\n\t\t\tlazyIconMap.put(iconName, icon);\n\t\t}\n\t\t\n\t\treturn icon;\t\t\n\t}\n",
    "100879": "\tprivate Icon getTridasIcon(NormalTridasRemark remark) {\n\t\treturn lazyLoadIcon(Remarks.getTridasRemarkIcons().get(remark));\n\t}\n",
    "100880": "\tprivate Icon getCorinaIcon(String remark) {\n\t\treturn lazyLoadIcon(Remarks.getCorinaRemarkIcons().get(remark));\n\t}\n",
    "100898": "\t\tprivate void populateFromObject(TridasObject obj) {\n\t\t\tList<TridasObject> flatObjects = new ArrayList<TridasObject>();\n\n\t\t\t// start out with the toplevel object\n\t\t\tflatObjects.add(obj);\n\t\t\t\n\t\t\t// if it has children, keep traversing\n\t\t\twhile(obj.isSetObjects()) {\n\t\t\t\tobj = obj.getObjects().get(0);\n\t\t\t\tflatObjects.add(obj);\n\t\t\t}\n\t\t\n\t\t\tobject = obj;\n\t\t\tobjectArray = flatObjects.toArray(new TridasObject[0]);\n\t\t\t\n\t\t\tif(!object.isSetElements())\n\t\t\t\treturn;\n\t\t\t\n\t\t\telement = object.getElements().get(0);\n\t\t\t\n\t\t\tif(!element.isSetSamples())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tsample = element.getSamples().get(0);\n\t\t\t\n\t\t\tbox = loadBoxFromSample(sample);\n\t\t}\n",
    "100934": "\tpublic Year getSelectedYear() {\n\t\treturn ((DecadalModel) myModel).getYear(myTable.getSelectedRow(),\n\t\t\t\tmyTable.getSelectedColumn());\n\t}\n",
    "100935": "\tprivate Image lazyLoadIcon(String iconName) {\n\t\tif(iconName == null)\n\t\t\treturn null;\n\t\t\n\t\tImage icon = lazyIconMap.get(iconName);\n\t\tif(icon == null) {\n\t\t\t// lazy-load the icon\n\t\t\ticon = Builder.getITextImageIcon(iconName);\n\n\t\t\tlazyIconMap.put(iconName, icon);\n\t\t}\n\t\t\n\t\treturn icon;\t\t\n\t}\n",
    "100940": "\tprivate Image getTridasIcon(NormalTridasRemark remark) {\n\t\treturn lazyLoadIcon(Remarks.getTridasRemarkIcons().get(remark));\n\t}\n",
    "100943": "\tprivate Image getCorinaIcon(String remark) {\n\t\t\n\t\tString iconName = Remarks.getCorinaRemarkIcons().get(remark);\n\t\t\n\t\treturn lazyLoadIcon(iconName);\n\t}\n",
    "100980": "\tpublic void addCellModifier(TableCellModifier modifier) {\n\t\tmyCellRenderer.addModifier(modifier);\n\t\t\n\t\t// repaint the table on notification\n\t\tmodifier.setListener(new TableCellModifierListener() {\n\t\t\tpublic void cellModifierChanged(TableCellModifier modifier) {\n\t\t\t\tmyTable.repaint();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// repaint now, to be safe\n\t\tmyTable.repaint();\n\t}\n",
    "100987": "\tpublic void removeCellModifier(TableCellModifier modifier) {\n\t\tmyCellRenderer.removeModifier(modifier);\n\t\tmodifier.setListener(null);\n\t\tmyTable.repaint();\n\t}\n",
    "101142": "\tprivate void makeMenusHeavyweight() {\n\t\tJMenuBar menus = getJMenuBar();\n\t\t\n\t\tfor(int i = 0; i < menus.getMenuCount(); i++)\n\t\t\tmenus.getMenu(i).getPopupMenu().setLightWeightPopupEnabled(false);\n\t}\n",
    "101178": "\tpublic void setLoadProperty(String propertyName, Object value) {\n\t\tif(loadProperties == null)\n\t\t\tloadProperties = new HashMap<String, Object>();\n\t\t\n\t\tloadProperties.put(propertyName, value);\n\t}\n",
    "101179": "\tpublic void setSaveProperty(String propertyName, Object value) {\n\t\tif(saveProperties == null)\n\t\t\tsaveProperties = new HashMap<String, Object>();\n\t\t\n\t\tsaveProperties.put(propertyName, value);\n\t}\n",
    "101195": "\tpublic SampleDataView getSampleDataView() {\n\t\treturn dataView;\n\t}\n",
    "101202": "\tpublic String getMetaString(String key) {\n\t\tObject o = meta.get(key);\n\t\t\n\t\treturn (o == null) ? null : o.toString();\n\t}\n",
    "101204": "\tprivate TridasValues createEmptyRingWidths() {\n\t\tTridasValues values = new TridasValues();\n\t\t\n\t\t// set default units\n\t\tTridasUnit units = new TridasUnit();\t\t\n\t\tunits.setNormalTridas(NormalTridasUnit.HUNDREDTH_MM);\n\t\tvalues.setUnit(units);\n\t\t\n\t\t// set as ring widths\n\t\tTridasVariable variable = new TridasVariable();\n\t\tvariable.setNormalTridas(NormalTridasVariable.RING_WIDTH);\n\t\tvalues.setVariable(variable);\n\n\t\t// populate the list of values (empty)\n\t\tvalues.getValues();\n\t\t\n\t\treturn values;\n\t}\t\n",
    "101208": "\tprivate TridasValues createEmptyWeiserjahre() {\n\t\tTridasValues values = new TridasValues();\n\t\t\n\t\tvalues.setUnitless(new TridasUnitless());\n\t\t\n\t\t// set as Weiserjahre\n\t\tvalues.setVariable(WEISERJAHRE_VARIABLE);\n\n\t\t// populate the list of values (empty)\n\t\tvalues.getValues();\n\t\t\n\t\treturn values;\n\t}\t\n",
    "101214": "\tpublic SampleType getSampleType() {\n\t\treturn sampleType;\n\t}\n",
    "101215": "\tpublic void setSampleType(SampleType sampleType) {\n\t\tthis.sampleType = sampleType;\n\t}\n",
    "101216": "\tpublic ITridasSeries getSeries() {\n\t\treturn series;\n\t}\n",
    "101217": "\tpublic void setSeries(ITridasSeries series) {\n\t\tthis.series = series;\n\n\t\t// update our sample type to reflect what's going on\n\t\tif(series instanceof ITridasDerivedSeries) {\n\t\t\tif(!sampleType.isDerived())\n\t\t\t\tsampleType = SampleType.UNKNOWN_DERIVED;\n\t\t}\n\t\telse if(sampleType.isDerived())\n\t\t\tsampleType = SampleType.UNKNOWN;\n\t}\n",
    "101218": "\tpublic TridasValue getValueForYear(Year y) {\n\t\treturn getValueForYear(tridasValuesMap.get(NormalTridasVariable.RING_WIDTH), y);\n\t}\n",
    "101219": "\tpublic CorinaMetadata meta() {\n\t\tif(metadata == null)\n\t\t\tmetadata = new BaseSampleMetadata(this);\n\t\t\n\t\treturn metadata;\n\t}\n",
    "101220": "\tpublic String getDisplayTitle() {\n\t\treturn getMeta(\"title\", String.class);\n\t}\t\n",
    "101223": "\tpublic TridasValue getValueForYear(TridasValues values, Year y) {\n\t\tRange range = getRange();\n\n\t\tif(!range.contains(y))\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\n\t\tint idx = y.diff(range.getStart());\n\t\treturn values.getValues().get(idx);\t\t\n\t}\n",
    "101224": "\tpublic TridasIdentifier getIdentifier() {\n\t\treturn (series != null) ? series.getIdentifier() : null;\n\t}\n",
    "101231": "\tpublic void clearModified() {\n\t\tmodified = false;\n\t}\n",
    "101239": "\tpublic String getName() {\n\t\treturn loader.getName();\n\t}\n",
    "101240": "\tpublic String getShortName() {\n\t\treturn loader.getShortName();\n\t}\n",
    "101242": "\tpublic int compareTo(Element o) {\n\t\tif(o == this)\n\t\t\treturn 0;\n\t\t\n\t\treturn o.getName().compareTo(getName());\n\t}\n",
    "101249": "\tpublic Sample load() throws IOException {\n\t\tSample s = Files.load(filename);\n\n\t\tif(s==null) return null;\n\t\t\n\t\ts.setLoader(this);\n\t\t\n\t\t// lazily-load this...?\n\t\ttype = s.getSampleType();\n\t\t\n\t\t// we loaded it, so tell our open menu...\n\t\t// Don't do this here, it affects imports!\n\t\t//OpenRecent.sampleOpened(this);\n\t\t\n\t\treturn s;\n\t}\n",
    "101252": "\tpublic int countRings() {\n\t\t// it's not a sum, so the number of rings is just the length\n\t\t// (if (null count) (length data) ...\n\t\tList<Number> data = getData();\n\t\t\n\t\tif (!hasCount())\n\t\t\treturn data.size();\n\n\t\tList<Integer> count = getCount();\n\n\t\t// it's a sum, so the number of rings is the sum of the number\n\t\t// of measurements for each year\n\t\t// ... (apply '+ count))\n\t\tint n = 0, size = count.size();\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tn += count.get(i);\n\t\treturn n;\n\t}\n",
    "101256": "\tpublic String getRelativeFilename() {\n\t\t// no basename or folder? return relative path...\n\t\tif(basename == null || folder == null)\n\t\t\treturn filename;\n\t\t\n\t\treturn \"?\" + folder + \":\" + basename;\n\t}\n",
    "101265": "\tpublic SampleType getSampleType() {\n\t\treturn type;\n\t}\n",
    "101267": "\tpublic void addAll(ElementList src) {\n\t\tfor(Element e : src) {\n\t\t\tadd(e);\n\t\t\tif(src.activeMap.containsKey(e))\n\t\t\t\tactiveMap.put(e, src.activeMap.get(e));\n\t\t}\n\t}\n",
    "101271": "\tpublic ElementList toActiveList() {\n\t\tElementList activeList = new ElementList();\n\t\t\n\t\tfor(Element e : this)\n\t\t\tif(isActive(e))\n\t\t\t\tactiveList.add(e);\n\t\t\n\t\treturn activeList;\n\t}\n",
    "101284": "\tpublic float getScale() {\n\t\treturn (isIndexed() ? 0.1f : 1.0f);\n\t}\n",
    "101287": "\tpublic Year getStart() {\n\t\treturn getRange().getStart();\n\t}\n",
    "101296": "\tpublic boolean isAbsolutelyDated() {\n\t\tITridasSeries series = getSeries();\n\t\t\n\t\t// no interpretation or no dating -> Relative dating\n\t\tif(!series.isSetInterpretation() || !series.getInterpretation().isSetDating())\n\t\t\treturn false;\n\t\t\n\t\tswitch(series.getInterpretation().getDating().getType()) {\n\t\tcase ABSOLUTE:\n\t\tcase DATED___WITH___UNCERTAINTY:\n\t\tcase RADIOCARBON:\n\t\t\treturn true;\n\t\t\t\n\t\tcase RELATIVE:\n\t\t\treturn false;\n\t\t\t\n\t\tdefault:\n\t\t\tnew Bug(new IllegalArgumentException(\"Dating type \" + \n\t\t\t\t\tseries.getInterpretation().getDating() + \" not supported\"));\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "101300": "\tpublic boolean isIndexed() {\n\t\tswitch(super.getSampleType()) {\n\t\tcase INDEX:\n\t\t\treturn true; // nice and easy\n\n\t\t// we don't know? guess. and save our guess.\n\t\tcase UNKNOWN:\n\t\t\tString type = (String) getMeta(\"format\");\n\t\t\tif (type != null && Character.toUpperCase(type.charAt(0)) == 'I') {\n\t\t\t\tsetSampleType(SampleType.INDEX);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\t\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "101302": "\tpublic boolean isModified() {\n\t\treturn modified;\n\t}\n",
    "101306": "\tpublic boolean isSummed() {\n\t\tswitch(super.getSampleType()) {\n\t\tcase SUM:\n\t\t\treturn true; // nice and easy\n\n\t\t// we don't know? guess.\n\t\t// why is this \"or?\"\n\t\tcase UNKNOWN: {\n\t\t\tif (elements != null || hasCount()) {\n\t\t\t\tsetSampleType(SampleType.SUM);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "101312": "\tpublic boolean hasCount() {\n\t\treturn ringwidths.hasCount();\n\t}\n",
    "101320": "\tpublic void setModified() {\n\t\tmodified = true;\n\t}\n",
    "101330": "\tpublic String toSimpleString() {\n\t\tString name = getDisplayTitle();\n\t\tif (isModified()) // not aqua-ish, but how to do it the real way?\n\t\t\tname = \"* \" + name;\n\t\treturn name;\n\t}\n",
    "101352": "  public void setProgress(int value) {\n    v = value;\n    if (value >= max) {\n      close();\n    } else if (value >= lastDisp + reportDelta) {\n      lastDisp = value;\n      if (popped) {\n        notifyStateChanged();\n      } else {\n        long T = System.currentTimeMillis();\n        long dT = (int)(T-T0);\n        if (dT >= millisToDecideToPopup) {\n          int predictedCompletionTime;\n          if (value > min) {\n            predictedCompletionTime = (int)(dT *\n                                            (max - min) /\n                                            (value - min));\n          } else {\n            predictedCompletionTime = millisToPopup;\n          }\n          if (predictedCompletionTime >= millisToPopup) {\n            popped = true;\n            notifyDisplay();\n          }\n        }\n      }\n    }\n  }\n",
    "101353": "  public void close() {\n    if (!popped) return;\n    popped = false;\n    notifyClosed();\n  }\n",
    "101355": "  public int getMinimum() {\n    return min;\n  }\n",
    "101356": "  public void setMinimum(int m) {\n    min = m;\n  }\n",
    "101357": "  public int getMaximum() {\n    return max;\n  }\n",
    "101358": "  public void setMaximum(int m) {\n    max = m;\n  }\n",
    "101361": "  public void setMillisToDecideToPopup(int millisToDecideToPopup) {\n    this.millisToDecideToPopup = millisToDecideToPopup;\n  }\n",
    "101362": "  public int getMillisToDecideToPopup() {\n    return millisToDecideToPopup;\n  }\n",
    "101363": "  public void setMillisToPopup(int millisToPopup) {\n    this.millisToPopup = millisToPopup;\n  }\n",
    "101365": "  public int getMillisToPopup() {\n    return millisToPopup;\n  }\n",
    "101367": "  public void setNote(String note) {\n    this.note = note;\n    if (popped) {\n      notifyStateChanged();\n    }\n  }\n",
    "101368": "  public String getNote() {\n    return note;\n  }\n",
    "101369": "\tpublic void setSortColumn(Integer sortColumn) {\n\t\tif (sortColumn != null)\n\t\t\tthis.sortColumn = sortColumn;\n\t\telse\n\t\t\tthis.sortColumn = -1;\n\t}\n",
    "101371": "\tpublic void setReversed(boolean reversed) {\n\t\tthis.reversed = reversed;\n\t}\n",
    "101372": "\tpublic boolean isReversed() {\n\t\treturn reversed;\n\t}\n",
    "101550": "    protected void addLabelMenu() {\n    \t\n    \tJMenu labelmenu = Builder.makeMenu(\"menus.admin.labels\", \"label.png\");\n\n    \t\n    \tJMenuItem boxlabel = Builder.makeMenuItem(\"menus.admin.boxlabels\",\n                \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.boxLabelDialog()\", \"box.png\");\n        labelmenu.add(boxlabel);\n    \t\n        JMenuItem samplelabel = Builder.makeMenuItem(\"menus.admin.samplelabels\",\n                \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.sampleLabelDialog()\", \"sample.png\");\n        labelmenu.add(samplelabel);   \n        add(labelmenu);\n    }\n",
    "101551": "\t protected void addReportsMenu() {\n\t \t\n\t \tJMenu reportmenu = Builder.makeMenu(\"menus.admin.reports\", \"prosheet.png\");\n\t \t\n\t \t\n\t    JMenuItem prosheet = Builder.makeMenuItem(\"menus.admin.prosheet\",\n\t            \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.proSheetPrintingDialog()\", \"prosheet.png\");\n\t    reportmenu.add(prosheet); \n\t \tadd(reportmenu);\n\t }\n",
    "101553": "\tprotected void addUserGroupMenu() {\n\t\t\n\t  \tJMenuItem usergroup = Builder.makeMenuItem(\"menus.admin.usersandgroups\",\n\t            \"edu.cornell.dendro.corina.admin.UserGroupAdmin.main()\", \"edit_group.png\");\n\t\n\t\tusergroup.setEnabled(true);\n\t\tadd(usergroup);\n\t}\n",
    "101555": "\tprotected void addCurationMenu() {\n\t\t\n\t \tJMenu curationmenu = Builder.makeMenu(\"menus.admin.curation\", \"curation.png\");\n\t \t\n\t \t\n\t    JMenuItem findsample = Builder.makeMenuItem(\"menus.admin.findsample\",\n\t            \"edu.cornell.dendro.corina.admin.SampleCuration.showDialog()\", \"findsample.png\");\n\t    curationmenu.add(findsample); \n\t    \n\t    \n\t    JMenuItem inventory = Builder.makeMenuItem(\"menus.admin.inventory\",\n\t            \"edu.cornell.dendro.corina.util.labels.ui.PrintingDialog.proSheetPrintingDialog()\");\n\t    inventory.setEnabled(false);\n\t    curationmenu.add(inventory); \n\t    \n\t \tadd(curationmenu);\n\t}\n",
    "101557": "    protected void addHelpMenu() {\n    \t\n\t// See if we have access to mozilla libs\n\ttry {\n\t\t// this loads the DLL...\n\t\tClass.forName(\"org.mozilla.browser\");\n\t}\n\tcatch (Exception e) {\n\t\t// driver not installed...\n\t\tSystem.out.println(\"No mozilla - no help\");\n\t\tSystem.out.println(e.toString());\n\t\treturn;\n\t}\n\tcatch (Error e) {\n\t\t// native interface not installed...\n\t\tSystem.out.println(\"No mozilla - no help\");\n\t\tSystem.out.println(e.toString());\n\t\treturn;\n\t}\n\t\n\t// Mozilla present so add help menu\n\tadd(Builder.makeMenuItem(\"menus.help.corina_help\",\n\t\t\t\t \"edu.cornell.dendro.corina.gui.HelpWiki.showHelp()\", \"help.png\"));\n    }\n",
    "101558": "    protected void addSystemInfoMenu() {\n        add(Builder.makeMenuItem(\"menus.help.system_info\",\n                                 \"edu.cornell.dendro.corina.util.PropertiesWindow.showPropertiesWindow()\", \"system.png\"));\n    }\n",
    "101561": "    protected void addAboutMenu() {\n      JMenuItem menuitem = Builder.makeMenuItem(\"menus.about\");\n      menuitem.setAction(ABOUT_ACTION);\n      add(menuitem);\n    }\n",
    "101565": "    public int getUpperValue() {\n        return getValue() + getExtent();\n    }\n",
    "101567": "    public void setUpperValue(int value) {\n        // Compute new extent.\n        int lowerValue = getValue();\n        int newExtent = Math.min(Math.max(0, value - lowerValue), getMaximum() - lowerValue);\n        \n        // Set extent to set upper value.\n        setExtent(newExtent);\n    }\n",
    "101603": "    private void paintLowerThumb(Graphics g) {\n        Rectangle knobBounds = thumbRect;\n        int w = knobBounds.width;\n        int h = knobBounds.height;      \n        \n        // Create graphics copy.\n        Graphics2D g2d = (Graphics2D) g.create();\n\n        // Create default thumb shape.\n        Shape thumbShape = createThumbShape(w - 1, h - 1);\n\n        // Draw thumb.\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n            RenderingHints.VALUE_ANTIALIAS_ON);\n        g2d.translate(knobBounds.x, knobBounds.y);\n\n        g2d.setColor(Color.GRAY);\n        g2d.fill(thumbShape);\n\n        g2d.setColor(Color.GRAY);\n        g2d.draw(thumbShape);\n        \n        // Dispose graphics.\n        g2d.dispose();\n    }\n",
    "101605": "    private void paintUpperThumb(Graphics g) {\n        Rectangle knobBounds = upperThumbRect;\n        int w = knobBounds.width;\n        int h = knobBounds.height;      \n        \n        // Create graphics copy.\n        Graphics2D g2d = (Graphics2D) g.create();\n\n        // Create default thumb shape.\n        Shape thumbShape = createThumbShape(w - 1, h - 1);\n\n        // Draw thumb.\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n            RenderingHints.VALUE_ANTIALIAS_ON);\n        g2d.translate(knobBounds.x, knobBounds.y);\n\n        g2d.setColor(Color.GRAY);\n        g2d.fill(thumbShape);\n\n        g2d.setColor(Color.GRAY);\n        g2d.draw(thumbShape);\n\n        // Dispose graphics.\n        g2d.dispose();\n    }\n",
    "101607": "    private Shape createThumbShape(int width, int height) {\n        // Use circular shape.\n        Ellipse2D shape = new Ellipse2D.Double(0, 0, width, height);\n        return shape;\n    }\n",
    "101609": "    private void setUpperThumbLocation(int x, int y) {\n        Rectangle upperUnionRect = new Rectangle();\n        upperUnionRect.setBounds(upperThumbRect);\n\n        upperThumbRect.setLocation(x, y);\n\n        SwingUtilities.computeUnion(upperThumbRect.x, upperThumbRect.y, upperThumbRect.width, upperThumbRect.height, upperUnionRect);\n        slider.repaint(upperUnionRect.x, upperUnionRect.y, upperUnionRect.width, upperUnionRect.height);\n    }\n",
    "101653": "\tprivate void checkValid() {\n\t\tboolean isValid = isDataValid();\n\t\t\n\t\tif(valid == isValid)\n\t\t\treturn;\n\t\t\n\t\tboolean oldValid = valid;\n\t\tvalid = isValid;\n\t\t\n\t\t// change background color and repaint accordingly\n\t\tsetBackground(valid ? validColor : invalidColor);\n\t\trepaint();\n\n\t\tproperties.firePropertyChange(PARAMETER_VALID_PROPERTY, oldValid, valid);\t\t\n\t}\n",
    "101655": "\tpublic SearchParameterName getParameterName() {\n\t\tObject o = cboSearchField.getSelectedItem();\n\t\t\n\t\tif(o instanceof SearchParameterName)\n\t\t\treturn (SearchParameterName) o;\n\t\t\n\t\treturn null;\n\t}\n",
    "101656": "\tpublic SearchOperator getOperator() {\n\t\treturn (SearchOperator) cboSearchOperator.getSelectedItem();\n\t}\n",
    "101658": "\tpublic String getValue() {\n\t\tString value = txtSearchText.getText();\n\t\t\n\t\treturn (value.length() > 0) ? value : null;\n\t}\n",
    "101663": "\tpublic void addSearchParameterPropertyChangeListener(PropertyChangeListener listener) {\n\t\tproperties.addPropertyChangeListener(listener);\n\t}\n",
    "101664": "\tpublic void removeSearchParameterPropertyChangeListener(PropertyChangeListener listener) {\n\t\tproperties.removePropertyChangeListener(listener);\n\t}\n",
    "101683": "\tpublic void setNonce(String nonce, String seq) {\n\t\tserverNonce = nonce;\n\t\tserverNonceSeq = seq;\n\t}\n",
    "101713": "    protected void doInitComponents(){\n    \t// Dynamic components\n\t    btnAdd = new javax.swing.JButton();\n\t    btnRemove = new javax.swing.JButton();\n\t    tblAvailMeas = new javax.swing.JTable();\n\t    tblChosenMeas = new javax.swing.JTable();\n\t    // Standard components\n    \tinitComponents();\n    \t\n    \t// Hide ribbon \n\t    panelRibbon.setVisible(false);\n\t    \n\t    // Hide preview button\n\t    btnPreview.setVisible(false);\n\n\t    // Make sure components are using I18n\n        internationalizeComponents();\n         \n    }\n",
    "101719": "    public void playBarcodeBeep(){\n\t\tAudioClip beep;\n\t\ttry {\t\n\t\t\t// play this to indicate measuring is on...\n\t\t\tbeep = Applet.newAudioClip(getClass().getClassLoader().getResource(\"edu/cornell/dendro/corina_resources/Sounds/checkout.wav\"));\n\t\t\tif(beep != null)\n\t\t\t\tbeep.play();\n\t\t} catch (Exception ae) { \n\t\t\tSystem.out.println(\"Failed to play sound\");\n\t\t\tSystem.out.println(ae.getMessage());\n\t\t\t}\n\t\t\n    }\n",
    "101731": "    private void setupSearch() {\n    \tsearchPanel = new SearchPanel(new SearchSupport());\n    \tthis.browseSearchPane.setComponentAt(1, searchPanel);\n    }\n",
    "101732": "\tprivate void rebuild() {\n\t\t// delete the layout\n\t\tpanel.removeAll();\n\n\t\tGridBagConstraints c = new GridBagConstraints();\n\t\t\n\t\tc.gridx = 0;\n\t\tc.gridy = 0;\n\t\tc.ipady = 4;\n\t\t\n\t\t// now, add everything to our layout\n\t\tfor(SearchParameterPanel searchPanel : parameters) {\n\t\t\tpanel.add(searchPanel, c);\n\t\t\tc.gridy++;\n\t\t}\n\t\t\n\t\tc.anchor = GridBagConstraints.LINE_START;\n\t\tpanel.add(addButton, c);\n\t\t\n\t\t// revalidate our panel, we changed the layout\n\t\tpanel.revalidate();\t\t\n\t}\n",
    "101733": "\tprivate void rebuildQuery() {\n\t\tSearchParameters search = new SearchParameters(SearchReturnObject.MEASUREMENT_SERIES);\n\n\t\t// don't include children\n\t\tsearch.setIncludeChildren(false);\n\t\t\n\t\tfor(SearchParameterPanel searchPanel : parameters) {\n\t\t\tif(!searchPanel.isDataValid())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tsearch.addSearchConstraint(searchPanel.getParameterName(), searchPanel.getOperator(), \n\t\t\t\t\tsearchPanel.getValue());\n\t\t}\n\t\t\n\t\t// empty search? don't change anything...\n\t\tif(!search.isSetParams())\n\t\t\treturn;\n\t\t\n\t\tstartSearch(search);\n\t}\n",
    "101744": "\tpublic void reSort() {\n\t\t// nothing to sort by :(\n\t\tif(lastSortedCol < 0)\n\t\t\treturn;\n\t\t\n\t\tint col = lastSortedCol;\n\t\tboolean reverse = headerRenderer.isReversed();\n\t\t\n\t\tlastSortedCol = -1;\n\t\tsortOnColumn(col, reverse);\n\t}\n",
    "101745": "\tpublic void sortOnColumn(int col, boolean reverse) {\n\t\tif(col == lastSortedCol) {\n\t\t\tCollections.reverse(model.getElements());\n\t\t\theaderRenderer.setReversed(!headerRenderer.isReversed());\n\t\t}\n\t\telse {\n\t\t\tCollections.sort(model.getElements(), new ElementListTableColumnComparator(model, col));\n\t\t\t\n\t\t\theaderRenderer.setSortColumn(col);\n\t\t\theaderRenderer.setReversed(false);\n\t\t\t\n\t\t\tlastSortedCol = col;\n\t\t\t\n\t\t\tif(reverse)\n\t\t\t\tCollections.reverse(model.getElements());\n\t\t}\n\t\n\t\t\n\t\t// notify the model and repaint the header\n\t\tmodel.fireTableDataChanged();\n\t\ttable.getTableHeader().repaint();\n\t\t\n\t}\n",
    "101755": "    public Dimension minimumLayoutSize(Container parent) {\n        return getLayoutSize(parent, false);\n    }\n",
    "101756": "    public Dimension preferredLayoutSize(Container parent) {\n        return getLayoutSize(parent, true);\n    }\n",
    "101757": "    public void addLayoutComponent(String name, Component comp) {\n        // do nothing\n    }\n",
    "101758": "    public void removeLayoutComponent(Component comp) {\n        // do nothing\n    }\n",
    "101821": "\tprotected void setCapsNoWhitespace(JTextField field) {\n\t\tfield.addKeyListener(new KeyAdapter() {\n\t\t\tpublic void keyTyped(KeyEvent ke) {\n\t\t\t\tchar k = ke.getKeyChar();\n\t\t\t\t\n\t\t\t\t// don't allow any whitespace\n\t\t\t\tif(Character.isWhitespace(k)) {\n\t\t\t\t\tke.consume(); // om nom nom nom!\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// force uppercase\n\t\t\t\tke.setKeyChar(Character.toUpperCase(k));\n\t\t\t}\n\t\t});\n\t}\n",
    "101828": "\tprotected void setSelectAllOnFocus(JTextField field) {\n\t\tfinal JTextField glue = field;\n\t\t\n\t\tfield.addFocusListener(new FocusAdapter() {\n\t\t\tpublic void focusGained(FocusEvent fe) {\n\t\t\t\tglue.selectAll();\n\t\t\t}\n\t\t});\n\t}\n",
    "101831": "\tprivate void setMaxHeight(Component comp) {\n\t\tDimension d = comp.getPreferredSize();\n\t\tcomp.setMaximumSize(new Dimension(Short.MAX_VALUE, d.height));\n\t}\n",
    "101832": "\tprotected void colorField(JComponent field, boolean isValid) {\n\t\tif(isValid) {\n\t\t\tfield.setBackground(UIManager.getLookAndFeelDefaults().getColor(\"TextField.background\"));\n\t\t} else {\n\t\t\tfield.setBackground(new Color(255, 255, 200));\n\t\t}\n\t}\n",
    "101846": "    public void preVisibleNotify() {\n\t\t// finally, if we have any defaults, apply them to our editor panel\n\t\tObject o;\n\t\tif((o = wizardParent.getDefaultsForClass(contentClass)) != null) {\n\t\t\tsetDefaultSelectionFrom((OBJT) o); // apply them to our combobox, perhaps?\n\t\t\tmyPanel.setDefaultsFrom((OBJT) o); // and fill in our editor pane\n\t\t}\n    }\n",
    "101851": "    public OBJT getPanelObject() {\n    \tObject selection = cboExistingList.getSelectedItem();\n    \t\n    \tif(selection == null)\n    \t\tthrow new IllegalStateException(\"GetPanelObject() has no object?\");\n    \t\n    \tif(!selection.getClass().equals(contentClass)) {\n    \t\tthrow new IllegalStateException(\"GetPanelObject() not content class, instead it's \" + selection.getClass().toString());\n    \t}\n    \t\n    \treturn (OBJT) selection;\n    }\n",
    "101854": "    public void preVisibleNotify() {\n\t\t// if we have any defaults, apply them\n\t\tObject o;\n\t\tif((o = parent.getDefaultsForClass(contentClass)) != null) \n\t\t\tsetDefaultsFrom((Sample) o);\n    }\n",
    "101855": "    private void checkEverythingValid() {\n    \tif(btnExisting.isSelected()) {\n    \t\tcheckComboValid();\n    \t\t\n    \t\tif(ourFormValidated)\n    \t\t\tsetPanelValid(true);\n    \t\telse\n    \t\t\tsetPanelValid(false);\n    \t}\n    \telse if(btnNew.isSelected()) {    \t\t\n    \t\tif(childFormValidated)\n    \t\t\tsetPanelValid(true);\n    \t\telse\n    \t\t\tsetPanelValid(false);\n    \t}\n    }\n",
    "101856": "    private void checkComboValid() {\n\t\t// do we have a valid selection in the combo box?\n\t\tObject obj = cboExistingList.getSelectedItem();\n\t\tif(obj != null && obj.getClass().equals(contentClass))\n\t\t\tourFormValidated = true;\n\t\telse\n\t\t\tourFormValidated = false;\n    }\n",
    "101862": "    public boolean isPanelValid() {\n    \treturn panelValid;\n    }\n",
    "101873": "\tpublic void notifyChildFormStateChanged() {\n\t\tchildFormValidated = myPanel.isFormValidated();\n\t\t\n\t\tcheckEverythingValid();\n\t}\n",
    "101889": "    public void addElement(Element e) {\n\t\tif(!selectedElements.contains(e))\n\t\t\tselectedElements.add(e);\n\t\telse\n\t\t\treturn;\n\t\n\t\tchosenSorter.reSort();\n\t\t\n\t\t// tell the table it's changed!\n\t\t((ElementListTableModel)tblChosenMeas.getModel()).fireTableDataChanged();\n\n\t\t// verify a selected element\n\t\tif(selectedElements.size() > minimumSelectedElements)\n\t\t\tbtnOk.setEnabled(true);\n\t\telse\n\t\t\tbtnOk.setEnabled(false);    \t\n    }\n",
    "101891": "\tprotected void setNewObject(OBJT obj) {\n\t\tthis.newObject = obj;\n\t}\n",
    "101893": "    public TridasEntityBase getPanelObject() {\n    \treturn null;\n    }\n",
    "101896": "\tpublic void populate() {\n\t\t\n\t}\n",
    "101897": "    public void deleteElement(Element e) {\n   \t\tdeleteElementFromModel(e, ((ElementListTableModel)tblChosenMeas.getModel()));\n   \t\tdeleteElementFromModel(e, ((ElementListTableModel)tblAvailMeas.getModel()));    \t\n    }\n",
    "101898": "\tpublic void populate(String parentPrefix) {\n\t\t\n\t}\n",
    "101899": "\tprotected boolean createOrUpdateObject(IntermediateResource resource) {\n\t\tPrototypeLoadDialog dlg = new PrototypeLoadDialog(resource);\n\t\t\n\t\t// start our query (remotely)\n\t\tresource.query();\t\t\n\t\t\n\t\tdlg.setVisible(true);\n\t\t\n\t\tif(!dlg.isSuccessful()) {\n\t\t\tJOptionPane.showMessageDialog(this, \"Could not create: \" + dlg.getFailException(), \n\t\t\t\t\t\"Failed to create\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t\telse\t\t\t\t\n\t\t\tsucceeded = true;\n\n\t\treturn succeeded;\n\t}\n",
    "101901": "\tpublic boolean didSucceed() {\n\t\treturn succeeded;\n\t}\n",
    "101902": "\tprotected void setFieldValidateButtons(JTextField field) {\n\t\tfield.getDocument().addDocumentListener(new DocumentListener() {\n\t\t\tpublic void changedUpdate(DocumentEvent e) {\n\t\t\t\t// hello stupid bug.. this isn't used on JTextFields for some awful reason\n\t\t\t}\n\n\t\t\tpublic void removeUpdate(DocumentEvent e) {\n\t\t\t\tvalidateForm();\n\t\t\t}\n\n\t\t\tpublic void insertUpdate(DocumentEvent e) {\n\t\t\t\tvalidateForm();\n\t\t\t}\n\t\t});\n\t}\n",
    "101908": "\tpublic String getLocalName() {\n\t\treturn null;\n\t}\n",
    "101909": "\tpublic void commit() {\n\t\tSystem.out.println(\"Commit not yet implemented :(\");\n\t}\n",
    "101913": "\tprotected void notifyWizard() {\n\t\tif(wizardToNotify != null)\n\t\t\twizardToNotify.notifyChildFormStateChanged();\n\t}\n",
    "101918": "    public boolean isSelectedElement(Element e) {\n    \treturn selectedElements.contains(e);\n    }\n",
    "101922": "\tpublic void setUpdateObject(OBJT obj) {\n\t\tif(obj instanceof TridasEntityBase) {\n\t\t\tif(((TridasEntityBase) obj).isNew())\n\t\t\t\tthrow new IllegalArgumentException(\"Trying to create an update dialog for a new resource!\");\n\t\t}\n\t\t\n\t\tupdatingObject = obj;\n\t}\n",
    "101924": "\tprotected void assimilateUpdateObject(OBJT obj) {\n\t\tif(updatingObject == null)\n\t\t\treturn;\n\t\t\n\t\t((TridasEntityBase) obj).assimilateIntermediateObject((TridasEntityBase) updatingObject);\n\t}\n",
    "101926": "\tprotected void validateForm() {\n\t\t\n\t}\n",
    "101929": "    public void setMinimumSelectedElements(int value) {\n    \tminimumSelectedElements = value;\n    }\n",
    "101935": "    public void selectSiteByCode(String code) {\n    \tTridasObjectEx site = App.tridasObjects.findObjectBySiteCode(code);\n    \t\n    \tif(site != null)\n    \t\tlstSites.setSelectedValue(site, true);\n    }\n",
    "101945": "    public JPanel getExtraButtonPanel() {\n    \treturn extraButtonPanel;\n    }\n",
    "101960": "    public Object getDefaultsForClass(Class<?> clazz) {\n    \treturn defaultsMap.get(clazz);\n    }\n",
    "101975": "\t\tprivate void showSearchLabel(boolean shouldShow) {\n\t\t\tif (shouldShow == false) {\n\t\t\t\tsearchInfoLabel.setVisible(false);\n\t\t\t\tgetLayeredPane().remove(searchInfoLabel);\n\t\t\t\tgetLayeredPane().validate();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPoint workPt = workArea.getLocation();\n\t\t\tworkPt = SwingUtilities.convertPoint(workArea, workPt, null);\n\t\t\tsearchInfoLabel.setBounds(workPt.x, workPt.y, workArea.getWidth(), 100);\n\t\t\tsearchInfoLabel.setVisible(true);\n\n\t\t\tgetLayeredPane().add(searchInfoLabel,\n\t\t\t\t\tnew Integer(JLayeredPane.POPUP_LAYER - 1), 0);\n\t\t\tgetLayeredPane().validate();\n\t\t}\n",
    "102153": "\tpublic String getSeriesName() {\n\t\treturn seriesName.getText();\n\t}\n",
    "102160": "\tpublic boolean testAndComplainRequired(EnumSet<Fields> valuesRequired) {\n\t\tif(valuesRequired.contains(Fields.NAME) && !hasSeriesName()) {\n\t\t\tcomplain(I18n.getText(\"general.seriesCode\"));\n\t\t\tseriesName.requestFocusInWindow();\n\t\t\treturn false;\n\t\t}\n\n\t\tif(valuesRequired.contains(Fields.VERSION) && !hasVersion()) {\n\t\t\tcomplain(I18n.getText(\"general.version\"));\n\t\t\tversionName.requestFocusInWindow();\n\t\t\treturn false;\n\t\t}\n\n\t\tif(valuesRequired.contains(Fields.JUSTIFICATION) && !hasJustification()) {\n\t\t\tcomplain(I18n.getText(\"general.justification\"));\n\t\t\tjustification.requestFocusInWindow();\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "102238": "\tpublic void perform(Object source) {\n\t\tActionEvent ae = new ActionEvent(source == null ? this : source,\n\t\t\t\tActionEvent.ACTION_PERFORMED,\n\t\t\t\t(String) getValue(Action.ACTION_COMMAND_KEY));\n\t\tactionPerformed(ae);\n\t}\n",
    "102239": "\tprotected void selectionStateChanged(boolean newSelectedState) {\n\t\t// by default, we don't care :)\n\t}\n",
    "102240": "\tpublic void connectToggleableButton(AbstractButton button, Boolean defaultValue) {\n\t\tif(buttonAdapters == null)\n\t\t\tbuttonAdapters = new ArrayList<ButtonSelectionActionAdapter>();\n\t\t\n\t\tbuttonAdapters.add(new ButtonSelectionActionAdapter(button, defaultValue));\n\t}\n",
    "102242": "\tpublic void connectToggleableButton(AbstractButton button) {\n\t\tconnectToggleableButton(button, null);\n\t}\n",
    "102262": "\tpublic void setScoreClass(Class<?> clazz) {\n\t\tshownCrossdateClass = clazz;\n\n\t\t// update the cross\n\t\tif(pairing != null)  {\t\t\t\n\t\t\tcross = pairing.getCrossForClass(clazz);\n\t\t\tif(cross != null)\n\t\t\t\tupdateTable();\n\t\t}\n\t\t\n\t\tfireTableDataChanged();\n\t}\n",
    "102264": "    private ElementList showOpenDialog(Frame parent, boolean modal, ElementList preexistingElements) {\n    \tDBBrowser dbb = new DBBrowser(parent, modal, true) {\n\t\t\t@Override\n\t\t\tprotected boolean finish() {\n\t\t\t\treturn (loadAllElements() && super.finish());\n\t\t\t}\n\t\t};\n\t\t\n\t\treturn doOpenDialog(dbb, preexistingElements);\n    }\n",
    "102271": "\tpublic int getFullestBucket() {\n\t\t// computed lazily; -1 means \"not computed\"\n\t\t// (because no bucket can contain -1 things, of course)\n\t\tif (fullest == -1) {\n\t\t\tfor (int i = 0; i < buckets.length; i++)\n\t\t\t\tfullest = Math.max(fullest, buckets[i]);\n\t\t}\n\t\treturn fullest;\n\t}\n",
    "102273": "\tpublic int getNumberOfBuckets() {\n\t\treturn buckets.length;\n\t}\n",
    "102274": "\tpublic String getBucketRange(int bucket) {\n\t\t// build memo, if necessary\n\t\tif (memo == null)\n\t\t\tmemo = new String[buckets.length];\n\n\t\t// compute result for cache, if necessary\n\t\tif (memo[bucket] == null) {\n\t\t\tboolean isInfty = (hasInfty && bucket == buckets.length - 1);\n\t\t\tfloat a = low + step * bucket;\n\t\t\tfloat b = (isInfty ? Float.POSITIVE_INFINITY : low + step\n\t\t\t\t\t* (bucket + 1));\n\t\t\tmemo[bucket] = format.format(a) + \" - \" + format.format(b);\n\t\t\t// \"-\" should really be \"\\u2014\",\n\t\t\t// but my printer can't handle that yet,\n\t\t\t// so yours likely can't, either. :-(\n\t\t}\n\n\t\t// return it\n\t\treturn memo[bucket];\n\t}\n",
    "102275": "\tpublic float getBucketMin(int bucket) {\n\t\treturn low + step * bucket;\n\t}\n",
    "102276": "\tpublic int getBucketItems(int bucket) {\n\t\treturn buckets[bucket];\n\t}\n",
    "102278": "\tpublic String getName() {\n\t\treturn I18n.getText(\"statistics.tscore\");\n\t}\n",
    "102279": "\tpublic String getFormat() {\n\t\treturn App.prefs.getPref(\"corina.cross.tscore.format\", \"0.00\");\n\t}\n",
    "102291": "\tpublic Pairing getPairing(int row, int col) throws NoSuchPairingException {\n\t\tPairing pairing = pairings.get(keyForRowCol(row, col));\n\t\t\n\t\tif(pairing == null)\n\t\t\tthrow new NoSuchPairingException(row, col);\n\t\t\n\t\treturn pairing;\n\t}\n",
    "102297": "\tprivate Pairing findPairing(Pairing pairing) {\n\t\tfor(Pairing p : pairings.values())\n\t\t\tif(p.equals(pairing))\n\t\t\t\treturn p;\n\t\t\n\t\treturn null;\n\t}\n",
    "102301": "\tpublic ElementList getAllFixed() {\n\t\treturn fixed; // FIXME: exposes internal representation!\n\t}\n",
    "102302": "\tpublic ElementList getAllMoving() {\n\t\treturn moving; // FIXME: exposes internal representation!\n\t}\n",
    "102310": "\tpublic Cross makeCross() throws IOException, IllegalArgumentException {\n\t\treturn Cross.makeCross(algorithms[crossNr], getFixed(), getMoving());\n\t\t// (PERF: this is inefficient for the d-score, but not\n\t\t// horrible.  the i/o problem is much worse than the extra\n\t\t// computation time.)\n\t}\n",
    "102311": "\tpublic void setAlgorithms(String algorithms[]) {\n\t\t// make copy\n\t\tint n = algorithms.length;\n\t\tthis.algorithms = new String[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tthis.algorithms[i] = algorithms[i];\n\t}\n",
    "102312": "\tpublic void nextPairing() {\n\t\tif (crossNr < algorithms.length - 1) {\n\t\t\tcrossNr++;\n\t\t} else if (pairingNr < pairings.size() - 1) {\n\t\t\tpairingNr++;\n\t\t\tcrossNr = 0;\n\t\t}\n\t}\n",
    "102314": "\tpublic void prevPairing() {\n\t\tif (crossNr > 0) {\n\t\t\tcrossNr--;\n\t\t} else if (pairingNr > 0) {\n\t\t\tpairingNr--;\n\t\t\tcrossNr = algorithms.length - 1;\n\t\t}\n\t}\n",
    "102315": "\tpublic boolean isFirst() {\n\t\treturn (pairingNr == 0 && crossNr == 0);\n\t}\n",
    "102318": "\tpublic boolean isLast() {\n\t\treturn (pairingNr == pairings.size() - 1 && crossNr == algorithms.length - 1);\n\t}\n",
    "102353": "\tpublic Pageable print(PageFormat pageFormat) {\n\t\treturn grid.makeHardcopy(pageFormat);\n\t}\n",
    "102376": "\tpublic void graphChanged(GrapherEvent evt) {\n\t\tif(evt.getEventType() == GrapherEvent.Type.XOFFSET_CHANGED) {\n\t\t\tif(graphSamples.size() == 2)\n\t\t\t\tstatus.setMovingRange(graphSamples.get(1).getRange());\n\t\t}\n\t}\n",
    "102412": "\tpublic Printable print() {\n\t\treturn table.print();\n\t}\n",
    "102436": "    public void setCrossdate(Cross crossdate) {\n\tthis.crossdate = crossdate;\n\n\tupdateTable();\n    }\n",
    "102445": "\tpublic int size() {\n\t\treturn num;\n\t}\n",
    "102447": "\tpublic Cell getCell(int row, int column) {\n\t\t// (cells are immutable, so this is safe.)\n\t\treturn cell[row][column];\n\t}\n",
    "102454": "\tpublic Exception getError() {\n\t\treturn error;\n\t}\n",
    "102457": "\tpublic Preview getPreview() {\n\t\treturn new GridPreview(this);\n\t}\n",
    "102549": "  public void graphSelectedCrossdate() {\n    // get the row\n    int row = table.getSelectedRow();\n\n    // get the year (== end-date of moving sample)\n    HighScore score = (HighScore) crossdate.getHighScores().getScores().get(row);\n    Year y = score.movingRange.getEnd();\n\n    // new cross at this offset\n    new GraphWindow(crossdate, y);\n  }\n",
    "102598": "    public void graphSelectedCrossdate() {\n\t// get the (row,col) of the click\n\tint row = table.getSelectedRow();\n\tint col = table.getSelectedColumn();\n\n\t// get the year (== end-date of moving sample)\n\tYear y = ((ScoresTableModel) table.getModel()).getYear(row, col);\n\n\t// blank spot (TODO: better to just look for empty cell?)\n\tif (!crossdate.getRange().contains(y))\n\t    return;\n\tif (col == 0)\n\t    return;\n\tif ((row + crossdate.getRange().getStart().row() == 0) && (col == 1))\n\t    return;\n\n\t// new graph at this place\n\tnew GraphWindow(crossdate, y);\n    }\n",
    "102611": "\tpublic Float getScoreAt(int row, int col) {\n\t\t// for the year column\n\t\tif (col == 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// check for year zero\n\t\t\tif ((row + row_min == 0) && (col == 1))\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tYear year = getYear(row, col);\n\n\t\t\tif (cross.getRange().contains(year))\n\t\t\t\treturn cross.getScore(year);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t}\n",
    "102613": "\tpublic Range getSecondaryRangeForCell(int row, int col) {\n\t\tif(col == 0)\n\t\t\treturn null; // nothing in this column\n\t\t\n\t\t// check for year zero\n\t\tif ((row + row_min == 0) && (col == 1))\n\t\t\treturn null;\n\n\t\t// I think the logic behind this makes sense... but it makes my head hurt\n\t\tYear year = getYear(row, col);\n\t\t// essentially, redate the moving's end to the year in this row,col\n\t\treturn cross.getMoving().getRange().redateEndTo(year);\n\t}\n",
    "102615": "\tpublic Sample getSecondaryForCell(int row, int col) {\n\t\tRange newRange = getSecondaryRangeForCell(row, col);\n\t\t\n\t\tif(newRange == null)\n\t\t\treturn null;\n\t\t\n\t\tSample redate = new Sample();\n\t\t\n\t\tSample.copy(pairing.getSecondary(), redate);\n\t\tredate.setRange(newRange);\n\t\t\n\t\treturn redate;\n\t}\n",
    "102620": "\tpublic Integer getOverlapAt(Range newRange) {\n\t\treturn (newRange == null) ? null : newRange.overlap(cross.getFixed().getRange());\t\t\n\t}\n",
    "102637": "\tpublic String getName() {\n\t\treturn I18n.getText(\"statistics.rvalue\");\n\t}\n",
    "102639": "\tpublic String getFormat() {\n\t\treturn App.prefs.getPref(\"corina.cross.rvalue.format\", \"0.00\");\n\t}\n",
    "102645": "\tprivate float mean(float array[]) {\n\t\t// (/ (reduce '+ array) (length array))\n\t\tfloat s = 0.0f;\n\t\tfor (int i = 0; i < array.length; i++)\n\t\t\ts += array[i];\n\t\treturn s / array.length;\n\n\t\t// what if array.length==0? -- only happens if one sample has no data (possible?)\n\t}\n",
    "102658": "\tprotected float getScore(int index) {\n\t\treturn data[index];\n\t}\n",
    "102662": "\tpublic float getScore(Year year) {\n\t\tint index = year.diff(range.getStart());\n\t\treturn data[index];\n\t}\n",
    "102665": "\tpublic int getScoreSignifigance(Year year) {\n\t\tint index = year.diff(range.getStart());\n\t\treturn signifigance[index];\n\t}\n",
    "102671": "\tpublic Sample getFixed() {\n\t\treturn fixed;\n\t}\n",
    "102674": "\tpublic Sample getMoving() {\n\t\treturn moving;\n\t}\n",
    "102677": "\tpublic boolean isFinished() {\n\t\treturn finished;\n\t}\n",
    "102692": "\tprotected void preamble() {\n\t\t// nothing need be done by default\n\n\t\t// DELETE ME!\n\t}\n",
    "102701": "\tpublic Sample getSecondaryForRow(int row) {\n\t\tif(row < 0 || row > getRowCount())\n\t\t\treturn null;\n\n\t\tSample redate = new Sample();\n\n\t\tSample.copy(pairing.getSecondary(), redate);\n\t\tredate.setRange(scores.get(row).range);\n\t\t\n\t\treturn redate;\n\t}\n",
    "102703": "\tpublic Range getSecondaryRangeForRow(int row) {\n\t\tif(row < 0 || row > getRowCount())\n\t\t\treturn null;\n\n\t\treturn new Range(scores.get(row).range.getStart(), scores.get(row).range.getEnd());\n\t}\t\n",
    "102769": "    public void save(Sample sample) throws SQLException {\n\tconnection.setAutoCommit(false);\n\n\tsaveSample(sample);\n\n\tconnection.commit();\n\tconnection.setAutoCommit(true);\n    }\n",
    "102773": "    public void dump(String folder) throws SQLException {\n\t// connection.setAutoCommit(false);\n\n\tFile f = new File(folder);\n\n\tif (f.isDirectory()) {\n\t    importFolder(f);\n\t} else {\n\t    importFile(f);\n\t}\n\n\t// connection.commit();\n\t// connection.setAutoCommit(true);\n    }\n",
    "102828": "    public XMLBody setPretty(boolean pretty) {\n    \tthis.pretty = pretty;\n    \t\n    \treturn this;\n    }\n",
    "102907": "\tpublic PageFormat getPageFormat() {\n\t\treturn pageFormat;\n\t}\n",
    "102909": "\tpublic void setPageFormat(PageFormat pageFormat) {\n\t\tthis.pageFormat = pageFormat;\n\t}\n",
    "102910": "\tpublic void setPageOrientation(int orientation) {\n\t\tpageFormat.setOrientation(orientation);\n\t}\n",
    "102913": "\tpublic void print(boolean showDialog) throws PrinterException {\n\t\tif(!showDialog || printJob.printDialog()) {\n\t\t\t// set the minimum margins for this paper (java defaults to 1\"... wtf?)\n\t\t\tpageFormat = minimumMarginsFormat(pageFormat);\n\t\t\t\n\t\t\tprintJob.print();\n\t\t}\n\t}\n",
    "102966": "    @Override\n\tpublic void mousePressed(MouseEvent e) { // mac\n\tmaybeShowPopup(e);\n    }\n",
    "102967": "    @Override\n\tpublic void mouseReleased(MouseEvent e) { // win32\n\tmaybeShowPopup(e);\n    }\n",
    "102971": "    public void showPopup(MouseEvent e) {\n\t// if table, and this row not selected, select this row\n\tif (e.getSource() instanceof JTable) {\n\t    JTable table = (JTable) e.getSource();\n\t    int row = table.rowAtPoint(e.getPoint());\n\t    if (row!=-1 && !table.isRowSelected(row))\n\t\ttable.setRowSelectionInterval(row, row);\n\t}\n\n\t// show popup\n\tif (popup != null)\n\t    popup.show(e.getComponent(), e.getX(), e.getY());\n    }\n",
    "102997": "    public void changedUpdate(DocumentEvent e) {\n\tupdate(e);\n    }\n",
    "102999": "    public void insertUpdate(DocumentEvent e) {\n\tupdate(e);\n    }\n",
    "103001": "    public void removeUpdate(DocumentEvent e) {\n\tupdate(e);\n    }\n",
    "103011": "\tpublic void replaceContents(Collection<? extends E> c) {\n\t\tif(!isEmpty())\n\t\t\tclear();\n\t\taddAll(c);\n\t}\n",
    "103018": "\tpublic String getFilename() {\n\t\tString fn = (String) s.getMeta(\"filename\");\n\t\tArrayList<String> segments = new ArrayList<String>();\n\t\tFile f = new File(fn);\n\t\tint depth = 0;\n\t\t\n\t\tfn = f.getName();\n\t\tdo {\n\t\t\tsegments.add(fn);\n\t\t\t\n\t\t\tf = f.getParentFile();\n\t\t\tfn = f.getName();\n\t\t\tdepth++;\n\t\t} while((fn.length() == 3 || fn.equalsIgnoreCase(\"forest\") || depth == 1) && fn.toLowerCase().indexOf(\"data\") == -1);\n\t\t\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i = segments.size() - 1; i >= 0; i--) {\n\t\t\tif(sb.length() != 0)\n\t\t\t\tsb.append(File.separator);\n\t\t\tsb.append(segments.get(i));\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n",
    "103029": "\tpublic String toString() {\n\t\ttry {\n\t\t\tTransformer xformer = TransformerFactory.newInstance().newTransformer();\n\t\t\tDOMSource source = new DOMSource(domElement);\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tStreamResult result = new StreamResult(sw);\n\t\t\t\n\t\t\txformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, showXmlDeclaration ? \"no\" : \"yes\");\n\t\t\txformer.setOutputProperty(OutputKeys.INDENT, pretty ? \"yes\" : \"no\");\n\t\t\t\n\t\t\txformer.transform(source, result);\n\t\t\t\n\t\t\treturn sw.toString();\n\t\t} catch (Exception e) {\n\t\t\treturn \"<error: \" + e.getMessage() + \" >\";\n\t\t}\n\t}\n",
    "103033": "\tpublic Object getElementAt(int index) {\n\t\treturn this.get(index);\n\t}\n",
    "103035": "\tpublic int getSize() {\n\t\treturn this.size();\n\t}\n",
    "103038": "\tpublic void addListDataListener(ListDataListener listener) {\n\t\tif (listDataListeners == null) {\n\t\t\tlistDataListeners = new ArrayList<ListDataListener>();\n\t\t}\n\t\tif (!listDataListeners.contains(listener)) {\n\t\t\tlistDataListeners.add(listener);\n\t\t}\n\t}\n",
    "103041": "\tpublic void removeListDataListener(ListDataListener listener) {\n\t\tif (listDataListeners != null) {\n\t\t\tlistDataListeners.remove(listener);\n\t\t}\n\t}\n",
    "103043": "\tpublic String toString() {\n\t\treturn bug.toString();\n\t}\n",
    "103054": "    public int compare(Object o1, Object o2) {\n\treturn compare((String) o1, (String) o2);\n    }\n",
    "103093": "    @Override\n\tpublic void write(char[] cbuf, int off, int len) {        \n        for (int i=off; i<off+len; i++) {\n            char c = cbuf[i];\n            if (c != '\\r')\n                super.write(c);\n        }\n    }\n",
    "103096": "    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n",
    "103101": "    public void debug(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_DEBUG)) {\n            log(SimpleLog.LOG_LEVEL_DEBUG, message, null);\n        }\n    }\n",
    "103108": "    public void debug(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_DEBUG)) {\n            log(SimpleLog.LOG_LEVEL_DEBUG, message, t);\n        }\n    }\n",
    "103109": "\tpublic Year getStart() {\n\t\treturn start;\n\t}\n",
    "103110": "\tpublic Year getEnd() {\n\t\treturn end;\n\t}\n",
    "103111": "    public void trace(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_TRACE)) {\n            log(SimpleLog.LOG_LEVEL_TRACE, message, null);\n        }\n    }\n",
    "103112": "\tpublic Range redateStartTo(Year y) {\n\t\treturn redateBy(y.diff(start));\n\t}\n",
    "103113": "\tpublic Range redateBy(int dy) {\n\t\treturn new Range(start.add(dy), end.add(dy));\n\t}\n",
    "103114": "    public void trace(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_TRACE)) {\n            log(SimpleLog.LOG_LEVEL_TRACE, message, t);\n        }\n    }\n",
    "103116": "\tpublic int span() {\n\t\treturn end.diff(start) + 1;\n\t}\n",
    "103118": "    public void info(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {\n            log(SimpleLog.LOG_LEVEL_INFO,message,null);\n        }\n    }\n",
    "103119": "\tpublic int rows() {\n\t\treturn getEnd().row() - getStart().row() + 1;\n\t}\n",
    "103121": "    public void info(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_INFO)) {\n            log(SimpleLog.LOG_LEVEL_INFO, message, t);\n        }\n    }\n",
    "103122": "\tpublic String toStringWithSpan() {\n\t\treturn \"(\" + start + \" - \" + end + \", n=\" + span() + \")\";\n\t\t// use \\u2014 EM DASH?\n\t}\n",
    "103123": "    public void warn(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_WARN)) {\n            log(SimpleLog.LOG_LEVEL_WARN, message, null);\n        }\n    }\n",
    "103124": "\tpublic boolean contains(Year y) {\n\t\treturn (start.compareTo(y) <= 0) && (y.compareTo(end) <= 0);\n\t}\n",
    "103125": "\tpublic boolean contains(Range r) {\n\t\treturn contains(r.start) && contains(r.end);\n\t}\n",
    "103126": "    public void warn(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_WARN)) {\n            log(SimpleLog.LOG_LEVEL_WARN, message, t);\n        }\n    }\n",
    "103127": "\tpublic boolean startOfRow(Year y) {\n\t\treturn y.equals(start) || y.column() == 0 || y.isYearOne();\n\t}\n",
    "103129": "\tpublic boolean endOfRow(Year y) {\n\t\treturn y.equals(end) || y.column() == 9;\n\t}\n",
    "103130": "    public void error(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_ERROR)) {\n            log(SimpleLog.LOG_LEVEL_ERROR, message, null);\n        }\n    }\n",
    "103131": "\tpublic int overlap(Range r) {\n\t\treturn intersection(r).span();\n\t}\n",
    "103133": "\tpublic Range intersection(Range r) {\n\t\treturn new Range(Year.max(start, r.start), Year.min(end, r.end));\n\t}\n",
    "103134": "\tpublic Range union(Range r) {\n\t\treturn new Range(Year.min(start, r.start), Year.max(end, r.end));\n\t}\n",
    "103135": "    public void error(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_ERROR)) {\n            log(SimpleLog.LOG_LEVEL_ERROR, message, t);\n        }\n    }\n",
    "103138": "    public void fatal(Object message) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_FATAL)) {\n            log(SimpleLog.LOG_LEVEL_FATAL, message, null);\n        }\n    }\n",
    "103139": "\tpublic int compareTo(Range r2) {\n\n\t\tint c1 = end.compareTo(r2.end);\n\t\tif (c1 != 0)\n\t\t\treturn c1;\n\n\t\t// negative, because fallback puts longest samples first\n\t\tint c2 = -start.compareTo(r2.start);\n\t\treturn c2;\n\t}\n",
    "103141": "    public void fatal(Object message, Throwable t) {\n\n        if (isLevelEnabled(SimpleLog.LOG_LEVEL_FATAL)) {\n            log(SimpleLog.LOG_LEVEL_FATAL, message, t);\n        }\n    }\n",
    "103156": "        public void flushBase64() throws java.io.IOException  {\n            if( position > 0 ) {\n                if( encode ) {\n                    out.write( encode3to4( b4, buffer, position, options ) );\n                    position = 0;\n                }   // end if: encoding\n                else {\n                    throw new java.io.IOException( \"Base64 input not properly padded.\" );\n                }   // end else: decoding\n            }   // end if: buffer partially full\n\n        }   // end flush\n",
    "103183": "        public void suspendEncoding() throws java.io.IOException  {\n            flushBase64();\n            this.suspendEncoding = true;\n        }   // end suspendEncoding\n",
    "103194": "        public void resumeEncoding() {\n            this.suspendEncoding = false;\n        }   // end resumeEncoding\n",
    "103213": "\tpublic String saveSingleSample(Sample exportee, String format) {\n\t\t\n\t\t// use the default title...\t\t\n\t\tString title = I18n.getText(\"export\") + \" \" + exportee.getDisplayTitle();\n\t\t\n\t\treturn saveSingleSample(exportee, format, title);\n\t}\n",
    "103221": "\tpublic String savePackedSample(List slist, String format) {\n\t\treturn savePackedSample(slist, format, I18n.getText(\"export\"));\n\t}\n",
    "103232": "\tpublic List saveMultiSample(List slist, String format) {\n\t\treturn saveMultiSample(slist, format, \"Choose an Export Folder\");\n\t}\n",
    "103334": "\tpublic void scaleToFitHeight() {\n\t\tscaleToFitHeight(1);\n\t}\n",
    "103346": "\tpublic void setDefault() {\n\t\tGraphPrefs.PLOT_AGENT.set(this);\n\t}\n",
    "103347": "\tpublic String getI18nTag() \n\t{\t\t\n\t\tif(this.toString().equals(PlotAgent.SEMILOG.toString())) return \"graph.agent_semilog\";\n\t\telse if (this.toString().equals(PlotAgent.STANDARD.toString()))\treturn \"graph.agent_standard\";\n\t\telse if (this.toString().equals(PlotAgent.TOOTHED.toString())) return \"graph.agent_toothed\";\n\t\telse return null;\n\t\t\n\t}\n",
    "103425": "    public void setAgent(PlotAgent agent) { \n    \tif(canChangeAgent)\n    \t\tgraphAgent = agent; \n    }\n",
    "103430": "    public void setHighlighted(boolean highlighted) {\n    \tthis.highlighted = highlighted;\n    }\n",
    "103432": "    public boolean isHighlighted() {\n    \treturn highlighted;\n    }\n",
    "103433": "    public CorinaGraphPlotter getPlotter() {\n    \treturn graphAgent.getPlotter();\n    }\n",
    "103445": "\tpublic GraphInfo getPrinter() {\n\t\treturn new GraphInfo(this, true);\n\t}\n",
    "103448": "\tpublic void resetColors() {\n\t\tif (!printing) {\n\t\t\tbackgroundColor = GraphPrefs.BACKGROUND.get();\n\t\t\tforeColor = GraphPrefs.FOREGROUND.get();\n\t\t\tmajorLineColor = GraphPrefs.MAJOR_LINE.get();\n\t\t\tminorLineColor = ColorUtils.blend(majorLineColor, backgroundColor);\n\t\t\tmidLineColor = ColorUtils.blend(majorLineColor, minorLineColor);\n\t\t} else {\n\t\t\tbackgroundColor = GraphPrefs.BACKGROUND_PRINT.get();\n\t\t\tforeColor = GraphPrefs.FOREGROUND_PRINT.get();\n\t\t\tmajorLineColor = GraphPrefs.MAJOR_LINE_PRINT.get();\n\t\t\tminorLineColor = ColorUtils.blend(majorLineColor, backgroundColor);\n\t\t\tmidLineColor = ColorUtils.blend(majorLineColor, minorLineColor);\t\t\t\n\t\t}\n\t}\n",
    "103498": "\tpublic Graph getGraph() {\n\t\treturn graph;\n\t}\n",
    "103500": "\tpublic Type getEventType() {\n\t\treturn eventType;\n\t}\n",
    "103552": "\tpublic int getGraphHeight(JPanel panel) {\n\t\treturn printing ? this.printHeight : panel.getHeight();\n\t}\n",
    "103668": "    private void compute() {\n        // i put this in run(), so it could be threaded, but is it worth it?\n        // -- for 100yr sample x 10 indexes, 900mhz athlon: 30-40ms.\n        // so no, it's probably not worth it.\n        // TODO: put this in the constructor.\n        for (int i=0; i<indexes.size(); i++)\n            (indexes.get(i)).run();\n    }\n",
    "103691": "\tprivate void legacyApplyIndex(Index index) {\n\t\tindex.apply();\n\n\t\t// undo (index implements undoable)\n\t\tsample.postEdit(index);\n\n\t\t// also: clear filename, set modified\n\t\tsample.setModified();\n\t\tsample.removeMeta(\"filename\"); // BUG: this should be in\n\t\t\t\t\t\t\t\t\t\t// Index.apply()\n\t\t// (otherwise undo doesn't put the filename back)\n\n\t\t// tell editor, and close\n\t\tsample.fireSampleDataChanged();\n\t\tsample.fireSampleMetadataChanged();\t\t\n\t}\n",
    "103716": "\tpublic String getName() {\n\t\tString tag = ixFunction.getI18nTag();\n\t\tString trailer = ixFunction.getI18nTagTrailer();\n\t\t\n\t\tif(trailer == null)\n\t\t\treturn I18n.getText(tag);\n\t\t\n\t\treturn MessageFormat.format(I18n.getText(tag),\n\t\t\t\tnew Object[] { trailer });\n\t\t/*\n\t\tString fqdn = getClass().getName();\n\t\tint dotIndex = fqdn.lastIndexOf(\".\");\n\t\treturn fqdn.substring(dotIndex + 1);\n\t\t*/\n\t}\n",
    "103779": "\tpublic boolean isList() {\n\t\treturn hasSetValues;\n\t}\n",
    "103833": "\tpublic void setMasterList(List<? extends Number> masterList) {\n\t\tif(masterList == null)\n\t\t\tthrow new NullPointerException();\n\t\t\n\t\tthis.masterList = masterList;\n\t}\n",
    "103835": "\tpublic void setData(List<Number> in) {\n\t\tdata = (in != null) ? new HookableNumericArrayList<Number>(this, in)\n\t\t\t\t: new HookableNumericArrayList<Number>(this);\n\t\tvalues.clear();\n\n\t\tfor (int i = 0, len = values.size(); i < len; i++) {\n\t\t\tTridasValue value = new TridasValue();\n\n\t\t\tvalue.setValue(data.get(i).toString());\n\t\t\t//value.setIndex(Integer.toString(i));\n\n\t\t\tvalues.add(value);\n\t\t}\n\n\t\tif (usesCounts) {\n\t\t\tcount.setMasterList(data);\n\t\t\tcheckCountsValid();\n\n\t\t\tif (countsValid)\n\t\t\t\tcopyOverCounts();\n\t\t}\n\t}\n",
    "103838": "\tpublic void setCount(List<Integer> in) {\n\t\tif(!usesCounts) {\n\t\t\tif(in == null || in.isEmpty())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tfor(int i = 0, len = in.size(); i < len; i++) {\n\t\t\t\tInteger v = in.get(i);\n\t\t\t\t\n\t\t\t\tif(v != null && v != 1) \n\t\t\t\t\tthrow new IllegalArgumentException(\"Counts contains a non-trival count\");\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tcount = (in != null) ? new HookableCountArrayList(this, in, data)\n\t\t\t\t: new HookableCountArrayList(this, data);\n\t\tcheckCountsValid();\n\t\t\n\t\tif(countsValid)\n\t\t\tcopyOverCounts();\n\t\telse\n\t\t\tclearCounts();\n\t}\n",
    "103839": "\tprotected int actualSize() {\n\t\treturn super.size();\n\t}\n",
    "103840": "\tprotected boolean actualIsEmpty() {\n\t\treturn super.isEmpty();\n\t}\n",
    "103857": "\tprivate String wjForIndex(int index) {\n\t\treturn incr.get(index) + \"/\" + decr.get(index);\n\t}\n",
    "103863": "\tprivate void recursiveAdd(TridasObjectEx obj, ListViews view) {\n\t\tview.allObjects.add(obj);\n\t\tview.bySiteCode.put(obj.getLabCode(), obj);\n\t\t\n\t\tif(obj.hasChildren()) {\n\t\t\tfor(TridasObjectEx child : ListUtil.subListOfType(obj.getObjects(), TridasObjectEx.class))\n\t\t\t\trecursiveAdd(child, view);\n\t\t}\n\t}\n",
    "103868": "\tpublic TridasObjectEx findObjectBySiteCode(String siteCode) {\n\t\tsynchronized(data) {\n\t\t\treturn data.bySiteCode.get(siteCode);\n\t\t}\n\t}\n",
    "103884": "\tprivate String getKey(ITridas parentObject) {\n\t\tXmlRootElement root = parentObject.getClass().getAnnotation(XmlRootElement.class);\n\t\tTridasIdentifier identifier = parentObject.getIdentifier();\n\t\t\t\n\t\tif(root != null)\n\t\t\treturn root.name() + \":\" + identifier.toString();\n\t\telse\n\t\t\treturn parentObject.getClass().getName() + \":\" + identifier.toString();\n\t}\n",
    "103891": "\tpublic void replaceChildProperty(TridasEntityProperty oldProp, TridasEntityProperty newProp) {\n\t\tint nProps = childProperties.size();\n\t\tfor(int i = 0; i < nProps; i++) {\n\t\t\tif(childProperties.get(i) == oldProp)\n\t\t\t\tchildProperties.set(i, newProp);\n\t\t}\n\t}\n",
    "103897": "\tprivate void selectNull() {\n\t\tTridasLocationGeometry oldGeometry = geometry;\n\t\tlabel.setValue(null);\n\t\tgeometry = null;\n\t\t\n\t\tfirePropertyChange(oldGeometry, geometry);\n\t}\n",
    "103899": "\tprivate void selectGeometry() {\n\t\tTridasLocationGeometry oldGeometry = geometry;\n\t\tLocationGeometry dialog = new LocationGeometry();\n\t\t\n\t\t// show the dialog...\n\t\tdialog.showDialog(SwingUtilities.getWindowAncestor(editor), geometry);\n\t\t\n\t\t// cancelled...\n\t\tif(!dialog.hasResults())\n\t\t\treturn;\n\t\t\n\t\tgeometry = dialog.getGeometry();\n\t\tlabel.setValue(geometry);\n\t\tfirePropertyChange(oldGeometry, geometry);\n\t}\n",
    "103918": "\tpublic boolean representsEnumType() {\n\t\treturn clazz.isEnum();\n\t}\n",
    "103948": "\tpublic void setType(Class<?> clazz, Field field) {\n\t\tthis.clazz = clazz;\t\t\n\t}\n",
    "103956": "\tpublic void writeToObject(Object object) {\n\t\ttry {\n\t\t\tMethod method = BeanUtils.getWriteMethod(object.getClass(),\n\t\t\t\t\tgetName(), getType());\n\t\t\tif (method != null) {\n\t\t\t\tmethod.invoke(object, new Object[] { getExternalTranslatedValue(getValue()) });\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n",
    "103964": "\tprotected Object getExternalTranslatedValue(Object value) {\n\t\treturn value;\n\t}\n",
    "103966": "\tprivate void cleanupPopup(boolean resetFilter) {\n\t\tif(isPopupShowing) {\n\t\t\tsearchPanel.setVisible(false);\n\t\t\tisPopupShowing = false;\n\t\t}\n\t\t\n\t\tif(resetFilter) {\n\t\t\tfilter.setFilterText(\"\");\n\t\t\tmodel.setFilter(filter);\n\t\t}\n\t}\n",
    "103967": "\tprotected Object getInternalTranslatedValue(Object value) {\n\t\treturn value;\n\t}\n",
    "103979": "\tpublic TridasLocationGeometry getGeometry() {\n\t\tif(!hasResults)\n\t\t\tthrow new IllegalStateException();\n\t\t\n\t\tTridasLocationGeometry geometry = new TridasLocationGeometry();\n\t\tPointType point = new PointType();\n\t\tgeometry.setPoint(point);\n\t\t\n\t\t// TODO: Actually implement detecting this and putting in the right standards\n\t\tpoint.setSrsName(\"EPSG:4326\");\n\t\t\n\t\tPos pos = new Pos();\n\t\tpoint.setPos(pos);\n\t\t\n\t\tpos.getValues().add(Double.valueOf(spnDDLong.getValue().toString()));\n\t\tpos.getValues().add(Double.valueOf(spnDDLat.getValue().toString()));\n\t\t\n\t\treturn geometry;\n\t}\n",
    "103981": "\tprivate void searchFieldChanged() {\n\t\tfilter.setFilterText(searchField.getText());\n\t\tmodel.setFilter(filter);\n\t}\n",
    "104003": "\tpublic void setEmptyGraphText(String emptyGraphText) {\n\t\tthis.emptyGraphText = emptyGraphText;\n\t}\n",
    "104014": "\tprivate void paintNoGraphs(Graphics g) {\n\t\tGraphics2D g2 = (Graphics2D) g;\n\n\t\tComposite oldComposite = g2.getComposite();\n\t\tFont oldFont = g2.getFont();\n\t\t\n\t\tg2.setColor(Color.blue.darker());\n\t\tg2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.4f));\n\t\tg2.setFont(g2.getFont().deriveFont(72.0f));\n\t\t\n\t\tint width = g2.getFontMetrics().stringWidth(emptyGraphText);\n\t\t\n\t\tfloat x = (float)((getWidth() / 2) - (width / 2)); \n\t\tfloat y = (float)(getHeight() / 2);\n\n\t\tg2.drawString(emptyGraphText, x, y);\n\t\t\n\t\tg2.setComposite(oldComposite);\n\t\tg2.setFont(oldFont);\n\t}\n",
    "104052": "\tpublic void clearSites() {\n\t\tthis.siteCodes.clear();\n\t\tthis.siteTitles.clear();\n\t}\n",
    "104054": "\tprivate ImageIcon scaleIcon20x20(ImageIcon icon) {\n\t\treturn new ImageIcon(icon.getImage().getScaledInstance(20, 20, Image.SCALE_SMOOTH));\n\t}\n",
    "104066": "\tprivate int compare(String o1, String o2) {\n\t\t// nicely handle nulls\n\t\tif (o1 == null && o2 == null)\n\t\t\treturn 0;\n\n\t\t// nulls go last\n\t\tif (o1 == null)\n\t\t\treturn 1;\n\t\tif (o2 == null)\n\t\t\treturn -1;\n\n\t\tInteger i1 = null, i2 = null;\n\t\ttry {\n\t\t\ti1 = Integer.valueOf(o1);\n\t\t} catch (NumberFormatException nfe) {\n\t\t}\n\t\t\n\t\ttry {\n\t\t\ti2 = Integer.valueOf(o2);\n\t\t} catch (NumberFormatException nfe) {\n\t\t}\n\n\t\t// both strings, string compare!\n\t\tif (i1 == null && i2 == null)\n\t\t\treturn o1.compareToIgnoreCase(o2);\n\n\t\t// strings go last\n\t\tif (i1 == null)\n\t\t\treturn 1;\n\t\tif (i2 == null)\n\t\t\treturn -1;\n\n\t\t// flat out integers!\n\t\treturn i1.compareTo(i2);\n\t}\n",
    "104073": "\tpublic boolean isTopLevelObject() {\n\t\treturn (parentObject == null);\n\t}\n",
    "104075": "\tpublic TridasObjectEx getParent() {\n\t\treturn parentObject;\n\t}\n",
    "104076": "\tpublic boolean hasChildren() {\n\t\treturn isSetObjects();\n\t}\n",
    "104077": "\tpublic boolean hasLabCode() {\n\t\treturn (labCode != null);\n\t}\n",
    "104081": "\tpublic void setPlotAgent(PlotAgent agent) {\n\t\tthis.plotAgent = agent;\n\t}\n",
    "104083": "\tpublic String toTitleString() {\n\t\tif(labCode == null || labCode.equals(title))\n\t\t\treturn title;\n\t\t\n\t\treturn \"[\" + labCode + \"] \" + title;\n\t}\n",
    "104101": "\tprotected PreprocessResult preprocessQuery(INTYPE object) throws ResourceException, UserCancelledException {\n\t\treturn PreprocessResult.SUCCESS;\n\t}\n",
    "104102": "\tprivate void doQuerySucceeded(INTYPE object) {\n\t\ttry {\n\t\t\t// Call our (potentially overridden) querySucceeded method\n\t\t\tquerySucceeded(object);\n\t\t} finally {\n\t\t\t// Notify listeners that everything went well\n\t\t\t// no matter what!\n\t\t\tfireResourceEvent(new ResourceEvent(this, ResourceEvent.RESOURCE_QUERY_COMPLETE, object));\n\t\t}\n\t}\n",
    "104103": "\tprivate void chooseOrCancelUIUpdate() {\n\t\t// disable/enable editing\n\t\teditEntity.setEnabled(!changingTop);\n\t\ttopChooser.setEnabled(changingTop);\n\t\tchangeButton.setText(changingTop ? OK_STATE : CHANGE_STATE);\n\t\tcancelChangeButton.setVisible(changingTop);\t\t\n\t}\n",
    "104104": "\tprivate void doQueryFailed(Exception e) {\n\t\ttry {\n\t\t\t// Call our (potentially overridden) queryFailed method\n\t\t\tqueryFailed(e);\n\t\t} finally {\t\n\t\t\t// Notify listeners that our query failed\n\t\t\t// No matter what!\n\t\t\tfireResourceEvent(new ResourceEvent(this, ResourceEvent.RESOURCE_QUERY_FAILED, e));\n\t\t}\n\t}\n",
    "104106": "\tprotected void querySucceeded(INTYPE object) {\n\t}\n",
    "104107": "\tprivate void changeButtonPressed() {\n\t\t\n\t\t// Make sure we populate our combobox with everything from the server\n\t\tpopulateComboAndSelect(true);\n\t\t\n\t\tif(topChooser.getSelectedItem() == EntityListComboBox.NEW_ITEM)\n\t\t\tpropertiesTable.setPreviewText(I18n.getText(\"general.choose\").toUpperCase());\n\t\telse\n\t\t\tpropertiesTable.setPreviewText(I18n.getText(\"general.preview\").toUpperCase());\n\t\tpropertiesTable.setPreviewing(true);\n\t\t\n\t\t// we're starting to change...\n\t\tchangingTop = true;\n\n\t\tchooseOrCancelUIUpdate();\n\t}\n",
    "104108": "\tprotected void queryFailed(Exception e) {\n\t\tSystem.err.println(\"Failed to query resource \" + resourceName);\n\t\te.printStackTrace();\n\t\t\n\t\tif(e instanceof ResourceException && e.getCause() != null) {\n\t\t\tSystem.err.println(\"Caused by:\");\n\t\t\te.getCause().printStackTrace();\n\t\t}\n\t}\n",
    "104109": "\tpublic void query() {\n\t\tqueryThread = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tqueryWait();\n\t\t\t\t\n\t\t\t\tqueryThread = null;\n\t\t\t}\n\t\t};\n\t\t\n\t\tqueryThread.start();\n\t}\n",
    "104115": "\tprotected void populateNewEntity(EditType type, ITridas entity) {\n\t\tentity.setTitle(\"New \" + type.displayTitle);\n\t}\n",
    "104117": "\tpublic void setOwnerWindow(Window window) {\n\t\tthis.ownerWindow = window;\n\t}\n",
    "104119": "\tpublic Window getOwnerWindow() {\n\t\treturn this.ownerWindow;\n\t}\n",
    "104121": "\tpublic void setUseVerticalScrollbar(boolean useVerticalScrollbar) {\n\t\tthis.useVerticalScrollbar = useVerticalScrollbar;\n\t}\n",
    "104128": "\tpublic void setProperty(String propertyName, Object value) {\n\t\t// lazy-create properties\n\t\tif(properties == null) \n\t\t\tproperties = new HashMap<String, Object>();\n\t\t\n\t\tproperties.put(propertyName, value);\n\t}\n",
    "104130": "\tpublic void setProperties(Map<String, ? extends Object> newProperties) {\n\t\t// lazy-create properties\n\t\tif(properties == null) \n\t\t\tproperties = new HashMap<String, Object>();\n\t\t\n\t\tproperties.putAll(newProperties);\n\t}\n",
    "104132": "\tpublic boolean hasProperty(String propertyName) {\n\t\tif(properties == null)\n\t\t\treturn false;\n\t\t\n\t\treturn properties.containsKey(propertyName);\n\t}\n",
    "104133": "\tpublic void setValidateSchema(Schema schema) {\n\t\tthis.validateSchema = schema;\n\t}\n",
    "104141": "\tprotected void setAssociatedResult(T associatedResult) {\n\t\tthis.associatedResult = associatedResult;\n\t}\n",
    "104144": "\tpublic T getAssociatedResult() {\n\t\tif(associatedResult == null)\n\t\t\tthrow new IllegalStateException(\"getAssociatedResult() has a null result\");\n\t\t\n\t\treturn associatedResult;\n\t}\n",
    "104146": "\tprivate void sortList(List<? extends ITridas> list) {\n\t\t// Sort list intelligently\n\t\tTridasComparator numSorter = new TridasComparator(TridasComparator.Type.TITLES, \n\t\t\t\tTridasComparator.NullBehavior.NULLS_LAST, \n\t\t\t\tTridasComparator.CompareBehavior.AS_NUMBERS_THEN_STRINGS);\n\t\t\n\t\tCollections.sort(list, numSorter);\t\t\n\t}\n",
    "104160": "\tpublic int getNumericCode() {\n\t\treturn numericCode;\n\t}\n",
    "104162": "\tprotected ITridas getCreateOrUpdateEntity() {\n\t\treturn createOrUpdateEntity;\n\t}\n",
    "104164": "\tprivate ITridas entityInList(ITridas entity, List<?> list) {\n\t\tfor(Object o : list) {\n\t\t\tif(o instanceof ITridas) {\n\t\t\t\tITridas otherEntity = (ITridas) o;\n\t\t\t\t\n\t\t\t\tif(matchEntities(entity, otherEntity))\n\t\t\t\t\treturn otherEntity;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "104167": "\tpublic String getServerNonce() {\n\t\treturn srvNonce;\n\t}\n",
    "104168": "\tpublic String getServerNonceSeq() {\n\t\treturn seq;\n\t}\n",
    "104169": "\tprivate String md5(String in) {\n\t\ttry {\n\t\t\tMessageDigest digest = MessageDigest.getInstance(\"MD5\");\n\t\t\t\n\t\t\tdigest.update(in.getBytes());\n\t\t\t\n\t\t\treturn StringUtils.bytesToHex(digest.digest());\n\t\t} catch (Exception e) {\n\t\t\tnew Bug(e);\n\t\t\treturn \"<error>\";\n\t\t}\t\n\t}\n",
    "104175": "\tpublic Sample getSample(TridasIdentifier identifier) {\n\t\tfor(BaseSample bs : getAssociatedResult()) {\n\t\t\tif(bs.getSeries().getIdentifier().equals(identifier)) {\n\t\t\t\tif(!(bs instanceof Sample))\n\t\t\t\t\tthrow new IllegalStateException(\"Found identifier but no sample??\");\n\t\t\t\t\n\t\t\t\treturn (Sample) bs;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "104189": "\tprotected void setQueryType(CorinaRequestType queryType) {\n\t\tthis.queryType = queryType;\n\t}\n",
    "104192": "\tprivate void populateComboAndSelect(boolean goRemote) {\n\t\t// get the list of stuff that goes in the box\n\t\tList<? extends ITridas> entityList = getEntityList(goRemote);\n\t\t\n\t\ttopChooser.setList(entityList);\n\n\t\t// select what we already have, if it exists\n\t\tITridas selectedEntity = currentMode.getEntity(s);\n\t\t\n\t\t// otherwise, try to choose something nicely\n\t\tif(selectedEntity == null)\n\t\t\tselectedEntity = suggestSelectedEntity(currentMode, entityList);\n\t\t\n\t\tselectInCombo(selectedEntity);\t\t\n\t}\n",
    "104193": "\tprivate String WSIMessageAsString(WSIMessage msg) {\n\t\tStringBuffer sb = new StringBuffer();\n\n\t\tfor (Object o : msg.getContent()) {\n\t\t\tif (o instanceof String)\n\t\t\t\tsb.append((String) o);\n\t\t\telse if (o instanceof org.w3c.dom.Element) {\n\t\t\t\tsb.append(new DomToString((org.w3c.dom.Element) o, false));\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n",
    "104194": "\tpublic void addSearchForAll() {\n\t\tif(hasConstraints || hasAllConstraint)\n\t\t\tthrow new IllegalArgumentException(\"Cannot have both search constraints and all constraint/multiple all constraints\");\n\t\tthis.setAll(new All());\n\t\tasText += \"[all]\";\n\t\thasAllConstraint = true;\n\t}\n",
    "104205": "\tprivate void save(Object obj) {\n\t\tif(myResource == null)\n\t\t\treturn;\n\t\t\n\t\ttry {\n\t\t\tMarshaller marshaller = getJAXBContext().createMarshaller();\n\t\t\tNamespacePrefixMapper nspm = getNamespacePrefixMapper();\n\n\t\t\tmarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n\t\t\tif (nspm != null)\n\t\t\t\tmarshaller.setProperty(\"com.sun.xml.bind.namespacePrefixMapper\", nspm);\n\t\t\t\n\t\t\tmarshaller.marshal(obj, getCacheFile());\n\t\t} catch (JAXBException e) {\n\t\t\tSystem.err.println(\"Couldn't save cache for \"\n\t\t\t\t\t+ myResource.getResourceName() + \": \" + e.getMessage());\n\t\t}\n\t}\n",
    "104207": "\tpublic void fromCookieStore(CookieStore cs) {\n\t\tboolean storeChanged = false;\n\t\t\n\t\tfor(Cookie c : cs.getCookies()) {\n\t\t\tString hv = hashCookie(c);\n\t\t\tWSCookieWrapper cw = cookies.get(hv);\n\t\t\t\n\t\t\t// cookie already exists and is unchanged\n\t\t\tif(cw != null && cw.equals(c))\n\t\t\t\tcontinue;\n\n\t\t\t// (re-)wrap a cookie\n\t\t\tcookies.put(hv, new WSCookieWrapper(c));\n\t\t\tstoreChanged = true;\n\t\t\t\n\t\t\tSystem.out.println(\"New Cookie: \" + hv);\n\t\t}\n\t\t\n\t\tif(storeChanged) {\n\t\t\tWSCookieStoreHandler.save(this);\n\t\t}\n\t}\t\n",
    "104209": "\tprotected ITridas suggestSelectedEntity(EditType mode, List<? extends ITridas> list) {\n\t\tif(list.size() == 1)\n\t\t\treturn list.get(0);\n\t\t\n\t\treturn null;\n\t}\n",
    "104221": "\tpublic INTYPE query() throws IOException {\n\t\treturn doRequest();\n\t}\n",
    "104223": "\tprivate String getStackTrace() {\n\t\tPureStringWriter sw = new PureStringWriter();\n\t\tPrintWriter pw = new PrintWriter(sw);\n\t\tnew Throwable().printStackTrace(pw);\n\t\treturn sw.toString();\n\t}\n",
    "104224": "\tprotected Schema getValidationSchema() {\n\t\treturn null;\n\t}\n",
    "104225": "\tprotected JAXBContext getJAXBContext() throws JAXBException {\n\t\treturn JAXBContext.newInstance();\n\t}\n",
    "104226": "\tprivate void disableBelowEnableAbove(EditType type) {\n\t\tboolean enabled = true;\n\t\t\n\t\tfor(EditType t : EditType.values()) {\n\t\t\tt.enableAssociatedButton(enabled);\n\t\t\t\n\t\t\tif(t == type)\n\t\t\t\tenabled = false;\n\t\t}\n\t}\n",
    "104228": "\tprotected NamespacePrefixMapper getNamespacePrefixMapper() {\n\t\treturn null;\n\t}\n",
    "104229": "\tpublic void setRequestObject(OUTTYPE reqObj) {\n\t\tthis.sendingObject = reqObj;\n\t}\n",
    "104232": "\tprivate AbstractButton addButton(final EditType type) {\n \t\tAction action = new AbstractAction(type.getTitle(), type.getIcon()) {\n\t\t\tpublic void actionPerformed(ActionEvent e) {\t\t\t\t\n\t\t\t\tbuttonAction(type);\n\t\t\t}\n\t\t};\n\t\t\n\t\tJToggleButton button = new JToggleButton(action);\n\t\ttype.associateButton(button);\n\t\t\n\t\treturn button;\n\t}\n",
    "104235": "\tpublic Dimension getPreferredSize(Dimension parentPreferredDimensions, Dimension scrollExtentDimensions) {\n\t\tparentPreferredDimensions.height = scrollExtentDimensions.height;\n\t\t\n\t\treturn parentPreferredDimensions;\t\t\n\t}\n",
    "104238": "\tpublic String getFolder() {\n\t\treturn folder;\n\t}\n",
    "104248": "\t\tpublic ITridas getEntity(Sample s) {\n\t\t\tif(this == DERIVED_SERIES || this == MEASUREMENT_SERIES)\n\t\t\t\treturn s.getSeries();\n\t\t\t\n\t\t\treturn s.getMeta(metadataTag, ITridas.class);\n\t\t}\n",
    "104253": "\t\tpublic void horizontalScrollbarStatusChanged() {\n\t\t\tensureScrollerExists();\n\t\t\t\n\t\t\tif (!gInfo.isShowBaselines())\n\t\t\t\tscroller.getHorizontalScrollBar().removeAdjustmentListener(this);\n\t\t\telse\n\t\t\t\tscroller.getHorizontalScrollBar().addAdjustmentListener(this);\t\t\t\n\t\t}\n",
    "104255": "\t\tpublic void associateButton(AbstractButton button) {\n\t\t\tassociatedButton = button;\n\t\t}\n",
    "104256": "\t\tpublic AbstractButton getButton() {\n\t\t\treturn associatedButton;\n\t\t}\n",
    "104258": "\t\tpublic void verticalAxisStatusChanged() {\n\t\t\tensureScrollerExists();\n\n\t\t\tif (gInfo.isShowVertAxis()) {\n\t\t\t\tvertaxis = new Axis(gInfo, PlotAgent.getDefault().getAxisType(), GrapherPanel.this);\n\t\t\t\tscroller.setRowHeaderView(vertaxis);\n\t\t\t} else {\n\t\t\t\tscroller.setRowHeaderView(null);\n\t\t\t}\t\t\t\n\t\t}\n",
    "104259": "\t\tpublic void enableAssociatedButton(boolean enabled) {\n\t\t\tif(this == DERIVED_SERIES || this == MEASUREMENT_SERIES || this == BOX)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif(associatedButton != null) {\n\t\t\t\tassociatedButton.setEnabled(enabled);\n\t\t\t}\n\t\t}\n",
    "104262": "\t\tpublic void propertyChanged() {\n\t\t\thasChanged = true;\n\t\t}\n",
    "104265": "\tpublic void addGrapherListener(GrapherListener listener) {\n\t\tgrapherListeners.add(GrapherListener.class, listener);\n\t}\n",
    "104268": "\tpublic void removeGrapherListner(GrapherListener listener) {\n\t\tgrapherListeners.remove(GrapherListener.class, listener);\n\t}\n",
    "104274": "    public File getFolder() {\n        // note: it's immutable, so this is safe.\n        return folder;\n    }\n",
    "104275": "    public File getTopLevel() {\n        // note: it's immutable, so this is safe.\n        return toplevel;\n    }\n",
    "104282": "    public void addChangeListener(ChangeListener listener) {\n        if (!listeners.contains(listener))\n            listeners.add(listener);\n    }\n",
    "104284": "    public void removeChangeListener(ChangeListener listener) {\n        listeners.remove(listener);\n    }\n",
    "104286": "\t\tpublic EditType previous() {\n\t\t\tswitch(this) {\n\t\t\tcase ELEMENT:\n\t\t\t\treturn OBJECT;\n\t\t\tcase SAMPLE:\n\t\t\t\treturn ELEMENT;\n\t\t\tcase RADIUS:\n\t\t\t\treturn SAMPLE;\n\t\t\tcase MEASUREMENT_SERIES:\n\t\t\t\treturn RADIUS;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n",
    "104290": "\t\tpublic EditType next() {\n\t\t\tswitch(this) {\n\t\t\tcase OBJECT:\n\t\t\t\treturn ELEMENT;\n\t\t\tcase ELEMENT:\n\t\t\t\treturn SAMPLE;\n\t\t\tcase SAMPLE:\n\t\t\t\treturn RADIUS;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n",
    "104305": "\tpublic void propertyChange(PropertyChangeEvent evt) {\n\t\tObject n;\n\t\tif(evt.getOldValue() == null && (n = evt.getNewValue()) != null && n.toString().equals(\"\"))\n\t\t\treturn;\n\t\t\n\t\tif(currentMode == null)\n\t\t\tthrow new IllegalStateException(\"Property changed with null mode??\");\n\n\t\tcurrentMode.propertyChanged();\n\t}\n",
    "104319": "    public void setSortColumn(String sortColumn) {\n        if (sortColumn == null)\n            throw new NullPointerException();\n    \n        this.sortColumn = sortColumn;\n    }\n",
    "104381": "    protected void addNewFolderMenuItem() {\n        JMenuItem newFolder = Builder.makeMenuItem(\"new_folder\", /*WRITEME:*/false);\n         // TODO: create new folder\n         // TODO: select it, and start editing its name inline (need renaming first!)\n         // -- what if i'm not displaying folders in the browser?  dialog?  no, edit on top ... what if it's a popup?\n         // TODO: undoable, as long as nothing has been created/moved inside it\n        // -- in which case moving/creating something inside it is undoable, and then this is undoable.\n        add(newFolder);\n    }\n",
    "104411": "    protected void addPageSetupMenuItem() {\n        JMenuItem setup = Builder.makeMenuItem(\"page_setup...\");\n        setup.addActionListener(new AbstractAction() { // REFACTOR: this taken verbatim from XMenubar\n            public void actionPerformed(ActionEvent ae) {\n                // make printer job, if none exists yet\n                if (printJob == null)\n                    printJob = PrinterJob.getPrinterJob();\n\n                // get page format\n                pageFormat = printJob.pageDialog(pageFormat);\n            }\n        });\n        add(setup);\n    }\n",
    "104430": "\tpublic void batchAddStatements(Statement s, String newVMeasurementResultID) throws SQLException {\n\t\tString header = \"INSERT into tblVMeasurementReadingResult (VMeasurementResultID,RelYear,Reading) VALUES ('\";\n\t\tint truncateLength = header.length();\n\t\tStringBuffer b = new StringBuffer(header);\t\t\n\t\t\n\t\tint len = output.size();\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tb.setLength(truncateLength);\n\t\t\t\n\t\t\tb.append(newVMeasurementResultID);\n\t\t\tb.append(\"',\");\n\t\t\tb.append(relYear.get(i));\n\t\t\tb.append(',');\n\t\t\tb.append(output.get(i).intValue());\n\t\t\tb.append(\")\");\n\t\t\ts.addBatch(b.toString());\n\t\t}\n\t}\n",
    "104433": "\tpublic void cleanup() throws SQLException {\n\t\tIterator<String> i = queries.keySet().iterator();\n\t\t\n\t\twhile(i.hasNext()) {\n\t\t\tStatementQueryHolder sq = queries.get(i.next());\n\t\t\tif(sq != null)\n\t\t\t\tsq.cleanup();\n\t\t}\n\t}\n",
    "104437": "\tpublic Row getSelectedRow() throws NoSuchElementException {\n\t\tint selection = table.getSelectedRow();\n\t\tif (selection != -1)\n\t\t\treturn (Row) visibleFiles.get(selection);\n\t\telse\n\t\t\tthrow new NoSuchElementException();\n\t}\n",
    "104438": "\tprivate void acquireVMeasurementResult(UUID VMeasurementID, boolean safe) throws SQLException {\n\t\tif(safe) {\n\t\t\t// If we have an error, clean up any mess we made, but pass along the exception.\n\t\t\tSavepoint beforeCreation = dbq.getConnection().setSavepoint();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tresult = recursiveGetVMeasurementResult(VMeasurementID, null, null, 0);\n\t\t\t} catch (SQLException sql) {\n\t\t\t\tdbq.getConnection().rollback(beforeCreation);\n\t\t\t\tthrow sql;\n\t\t\t} finally {\n\t\t\t\tdbq.getConnection().releaseSavepoint(beforeCreation);\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\telse\n\t\t\tresult = recursiveGetVMeasurementResult(VMeasurementID, null, null, 0);\n\t}\n",
    "104454": "\tpublic Iterator getSelectedRows() {\n\t\treturn new Iterator() {\n\t\t\tint rows[] = table.getSelectedRows();\n\n\t\t\tint i = 0;\n\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn (i < rows.length);\n\t\t\t}\n\n\t\t\tpublic Object next() throws NoSuchElementException {\n\t\t\t\tif (i < rows.length)\n\t\t\t\t\treturn visibleFiles.get(i++);\n\t\t\t\telse\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t};\n\t}\n",
    "104482": "\tpublic void doIndex() {\n\t\tSystem.out.println(\"Starting index function \" + getI18nTag());\n\t\tif(input == null)\n\t\t\tthrow new IllegalArgumentException(\"Index function has not been properly initilaized\");\n\t\tif(alreadyIndexed)\n\t\t\tthrow new IllegalArgumentException(\"Index function has already been run\");\n\t\telse\n\t\t\talreadyIndexed = true;\n\t\t\n\t\tindex();\n\t}\n",
    "104509": "    public String getAddressLine1() {\n        return addressLine1;\n    }\n",
    "104513": "    public void setAddressLine1(String value) {\n        this.addressLine1 = value;\n    }\n",
    "104519": "    public String getAddressLine2() {\n        return addressLine2;\n    }\n",
    "104520": "    public void setAddressLine2(String value) {\n        this.addressLine2 = value;\n    }\n",
    "104521": "    public ControlledVoc getType() {\n        return type;\n    }\n",
    "104523": "    public String getCityOrTown() {\n        return cityOrTown;\n    }\n",
    "104524": "    public void setType(ControlledVoc value) {\n        this.type = value;\n    }\n",
    "104525": "    public void setCityOrTown(String value) {\n        this.cityOrTown = value;\n    }\n",
    "104529": "    public String getStateProvinceRegion() {\n        return stateProvinceRegion;\n    }\n",
    "104530": "    public void setStateProvinceRegion(String value) {\n        this.stateProvinceRegion = value;\n    }\n",
    "104533": "    public String getPostalCode() {\n        return postalCode;\n    }\n",
    "104534": "    public void setPostalCode(String value) {\n        this.postalCode = value;\n    }\n",
    "104538": "    public String getCountry() {\n        return country;\n    }\n",
    "104540": "    public void setCountry(String value) {\n        this.country = value;\n    }\n",
    "104542": "    public SeriesLinksWithPreferred getLinkSeries() {\n        return linkSeries;\n    }\n",
    "104545": "    public void setLinkSeries(SeriesLinksWithPreferred value) {\n        this.linkSeries = value;\n    }\n",
    "104559": "    public XMLGregorianCalendar getValue() {\n        return value;\n    }\n",
    "104560": "    public void setValue(XMLGregorianCalendar value) {\n        this.value = value;\n    }\n",
    "104561": "    public ControlledVoc getTaxon() {\n        return taxon;\n    }\n",
    "104563": "    public Certainty getCertainty() {\n        return certainty;\n    }\n",
    "104564": "    public void setCertainty(Certainty value) {\n        this.certainty = value;\n    }\n",
    "104566": "    public void setTaxon(ControlledVoc value) {\n        this.taxon = value;\n    }\n",
    "104575": "    public TridasShape getShape() {\n        return shape;\n    }\n",
    "104578": "    public void setShape(TridasShape value) {\n        this.shape = value;\n    }\n",
    "104580": "    public NormalTridasRemark getNormalTridas() {\n        return normalTridas;\n    }\n",
    "104583": "    public void setNormalTridas(NormalTridasRemark value) {\n        this.normalTridas = value;\n    }\n",
    "104585": "    public Integer getInheritedCount() {\n        return inheritedCount;\n    }\n",
    "104586": "    public TridasDimensions getDimensions() {\n        return dimensions;\n    }\n",
    "104587": "    public void setInheritedCount(Integer value) {\n        this.inheritedCount = value;\n    }\n",
    "104589": "    public void setDimensions(TridasDimensions value) {\n        this.dimensions = value;\n    }\n",
    "104597": "    public String getAuthenticity() {\n        return authenticity;\n    }\n",
    "104600": "    public void setAuthenticity(String value) {\n        this.authenticity = value;\n    }\n",
    "104604": "    public NormalTridasDatingType getType() {\n        return type;\n    }\n",
    "104606": "    public void setType(NormalTridasDatingType value) {\n        this.type = value;\n    }\n",
    "104611": "    public TridasLocation getLocation() {\n        return location;\n    }\n",
    "104617": "    public void setLocation(TridasLocation value) {\n        this.location = value;\n    }\n",
    "104624": "    public String getProcessing() {\n        return processing;\n    }\n",
    "104627": "    public void setProcessing(String value) {\n        this.processing = value;\n    }\n",
    "104634": "    public String getMarks() {\n        return marks;\n    }\n",
    "104637": "    public void setMarks(String value) {\n        this.marks = value;\n    }\n",
    "104642": "    public Double getAltitude() {\n        return altitude;\n    }\n",
    "104645": "    public void setAltitude(Double value) {\n        this.altitude = value;\n    }\n",
    "104654": "    public TridasSlope getSlope() {\n        return slope;\n    }\n",
    "104658": "    public void setSlope(TridasSlope value) {\n        this.slope = value;\n    }\n",
    "104664": "    public NormalTridasVariable getNormalTridas() {\n        return normalTridas;\n    }\n",
    "104665": "    public void setNormalTridas(NormalTridasVariable value) {\n        this.normalTridas = value;\n    }\n",
    "104666": "    public TridasSoil getSoil() {\n        return soil;\n    }\n",
    "104673": "    public void setSoil(TridasSoil value) {\n        this.soil = value;\n    }\n",
    "104680": "    public BigInteger getValue() {\n        return value;\n    }\n",
    "104681": "    public void setValue(BigInteger value) {\n        this.value = value;\n    }\n",
    "104683": "    public TridasBedrock getBedrock() {\n        return bedrock;\n    }\n",
    "104688": "    public DatingSuffix getSuffix() {\n        return suffix;\n    }\n",
    "104689": "    public void setBedrock(TridasBedrock value) {\n        this.bedrock = value;\n    }\n",
    "104690": "    public void setSuffix(DatingSuffix value) {\n        this.suffix = value;\n    }\n",
    "104705": "    public TridasDating getDating() {\n        return dating;\n    }\n",
    "104707": "    public void setDating(TridasDating value) {\n        this.dating = value;\n    }\n",
    "104710": "    public Year getFirstYear() {\n        return firstYear;\n    }\n",
    "104712": "    public void setFirstYear(Year value) {\n        this.firstYear = value;\n    }\n",
    "104715": "    public Year getLastYear() {\n        return lastYear;\n    }\n",
    "104716": "    public void setLastYear(Year value) {\n        this.lastYear = value;\n    }\n",
    "104718": "    public void setFiles(List<TridasFile> files) {\n        this.files = files;\n    }\n",
    "104720": "    public TridasDatingReference getDatingReference() {\n        return datingReference;\n    }\n",
    "104721": "    public void setDatingReference(TridasDatingReference value) {\n        this.datingReference = value;\n    }\n",
    "104722": "    public void setGenericFields(List<TridasGenericField> genericFields) {\n        this.genericFields = genericFields;\n    }\n",
    "104730": "    public Year getPithYear() {\n        return pithYear;\n    }\n",
    "104731": "    public void setPithYear(Year value) {\n        this.pithYear = value;\n    }\n",
    "104734": "    public Year getDeathYear() {\n        return deathYear;\n    }\n",
    "104736": "    public void setDeathYear(Year value) {\n        this.deathYear = value;\n    }\n",
    "104739": "    public String getProvenance() {\n        return provenance;\n    }\n",
    "104741": "    public void setProvenance(String value) {\n        this.provenance = value;\n    }\n",
    "104744": "    public void setStatFoundations(List<TridasStatFoundation> statFoundations) {\n        this.statFoundations = statFoundations;\n    }\n",
    "104764": "    public BigDecimal getStatValue() {\n        return statValue;\n    }\n",
    "104766": "    public void setStatValue(BigDecimal value) {\n        this.statValue = value;\n    }\n",
    "104772": "    public BigDecimal getSignificanceLevel() {\n        return significanceLevel;\n    }\n",
    "104774": "    public void setSignificanceLevel(BigDecimal value) {\n        this.significanceLevel = value;\n    }\n",
    "104777": "    public String getUsedSoftware() {\n        return usedSoftware;\n    }\n",
    "104779": "    public void setUsedSoftware(String value) {\n        this.usedSoftware = value;\n    }\n",
    "104797": "    public TridasCategory getCategory() {\n        return category;\n    }\n",
    "104798": "    public Date getMeasuringDate() {\n        return measuringDate;\n    }\n",
    "104800": "    public void setMeasuringDate(Date value) {\n        this.measuringDate = value;\n    }\n",
    "104801": "    public void setCategory(TridasCategory value) {\n        this.category = value;\n    }\n",
    "104805": "    public Date getDerivationDate() {\n        return derivationDate;\n    }\n",
    "104806": "    public String getInvestigator() {\n        return investigator;\n    }\n",
    "104807": "    public void setDerivationDate(Date value) {\n        this.derivationDate = value;\n    }\n",
    "104808": "    public void setInvestigator(String value) {\n        this.investigator = value;\n    }\n",
    "104813": "    public TridasWoodCompleteness getWoodCompleteness() {\n        return woodCompleteness;\n    }\n",
    "104814": "    public String getPeriod() {\n        return period;\n    }\n",
    "104816": "    public void setWoodCompleteness(TridasWoodCompleteness value) {\n        this.woodCompleteness = value;\n    }\n",
    "104817": "    public void setPeriod(String value) {\n        this.period = value;\n    }\n",
    "104821": "    public String getAnalyst() {\n        return analyst;\n    }\n",
    "104822": "    public Date getRequestDate() {\n        return requestDate;\n    }\n",
    "104823": "    public void setAnalyst(String value) {\n        this.analyst = value;\n    }\n",
    "104824": "    public void setRequestDate(Date value) {\n        this.requestDate = value;\n    }\n",
    "104828": "    public String getDendrochronologist() {\n        return dendrochronologist;\n    }\n",
    "104829": "    public String getCommissioner() {\n        return commissioner;\n    }\n",
    "104830": "    public void setDendrochronologist(String value) {\n        this.dendrochronologist = value;\n    }\n",
    "104831": "    public void setCommissioner(String value) {\n        this.commissioner = value;\n    }\n",
    "104836": "    public TridasMeasuringMethod getMeasuringMethod() {\n        return measuringMethod;\n    }\n",
    "104838": "    public void setMeasuringMethod(TridasMeasuringMethod value) {\n        this.measuringMethod = value;\n    }\n",
    "104849": "    public SeriesLinks getLinkSeries() {\n        return linkSeries;\n    }\n",
    "104851": "    public void setLinkSeries(SeriesLinks value) {\n        this.linkSeries = value;\n    }\n",
    "104857": "    public String getObjective() {\n        return objective;\n    }\n",
    "104860": "    public void setObjective(String value) {\n        this.objective = value;\n    }\n",
    "104863": "    public void setTypes(List<ControlledVoc> types) {\n        this.types = types;\n    }\n",
    "104864": "    public String getStandardizingMethod() {\n        return standardizingMethod;\n    }\n",
    "104867": "    public void setStandardizingMethod(String value) {\n        this.standardizingMethod = value;\n    }\n",
    "104868": "    public void setLaboratories(List<TridasLaboratory> laboratories) {\n        this.laboratories = laboratories;\n    }\n",
    "104870": "    public void setReferences(List<String> references) {\n        this.references = references;\n    }\n",
    "104873": "    public String getAuthor() {\n        return author;\n    }\n",
    "104874": "    public void setResearches(List<TridasResearch> researches) {\n        this.researches = researches;\n    }\n",
    "104875": "    public void setAuthor(String value) {\n        this.author = value;\n    }\n",
    "104880": "    public String getVersion() {\n        return version;\n    }\n",
    "104882": "    public void setVersion(String value) {\n        this.version = value;\n    }\n",
    "104887": "    public TridasInterpretationUnsolved getInterpretationUnsolved() {\n        return interpretationUnsolved;\n    }\n",
    "104889": "    public void setInterpretationUnsolved(TridasInterpretationUnsolved value) {\n        this.interpretationUnsolved = value;\n    }\n",
    "104895": "    public TridasInterpretation getInterpretation() {\n        return interpretation;\n    }\n",
    "104898": "    public void setInterpretation(TridasInterpretation value) {\n        this.interpretation = value;\n    }\n",
    "104901": "    public TridasIdentifier createTridasIdentifier() {\n        return new TridasIdentifier();\n    }\n",
    "104904": "    public TridasFile createTridasFile() {\n        return new TridasFile();\n    }\n",
    "104907": "    public SeriesLink createSeriesLink() {\n        return new SeriesLink();\n    }\n",
    "104911": "    public Integer getMissingHeartwoodRingsToPith() {\n        return missingHeartwoodRingsToPith;\n    }\n",
    "104912": "    public TridasCoverage createTridasCoverage() {\n        return new TridasCoverage();\n    }\n",
    "104913": "    public void setMissingHeartwoodRingsToPith(Integer value) {\n        this.missingHeartwoodRingsToPith = value;\n    }\n",
    "104916": "    public String getMissingHeartwoodRingsToPithFoundation() {\n        return missingHeartwoodRingsToPithFoundation;\n    }\n",
    "104917": "    public void setMissingHeartwoodRingsToPithFoundation(String value) {\n        this.missingHeartwoodRingsToPithFoundation = value;\n    }\n",
    "104920": "    public TridasSlope createTridasSlope() {\n        return new TridasSlope();\n    }\n",
    "104921": "    public ComplexPresenceAbsence getPresence() {\n        return presence;\n    }\n",
    "104922": "    public void setPresence(ComplexPresenceAbsence value) {\n        this.presence = value;\n    }\n",
    "104926": "    public TridasPith createTridasPith() {\n        return new TridasPith();\n    }\n",
    "104932": "    public ControlledVoc createControlledVoc() {\n        return new ControlledVoc();\n    }\n",
    "104939": "    public TridasVocabulary createTridasVocabulary() {\n        return new TridasVocabulary();\n    }\n",
    "104940": "    public String getContent() {\n        return content;\n    }\n",
    "104941": "    public void setContent(String value) {\n        this.content = value;\n    }\n",
    "104944": "    public PresenceAbsence getPresence() {\n        return presence;\n    }\n",
    "104945": "    public void setPresence(PresenceAbsence value) {\n        this.presence = value;\n    }\n",
    "104948": "    public TridasElement createTridasElement() {\n        return new TridasElement();\n    }\n",
    "104957": "    public TridasBedrock createTridasBedrock() {\n        return new TridasBedrock();\n    }\n",
    "104967": "    public TridasLaboratory createTridasLaboratory() {\n        return new TridasLaboratory();\n    }\n",
    "104969": "    public void setValues(List<TridasValues> values) {\n        this.values = values;\n    }\n",
    "104975": "    public TridasProject createTridasProject() {\n        return new TridasProject();\n    }\n",
    "104979": "    public TridasSoil createTridasSoil() {\n        return new TridasSoil();\n    }\n",
    "104984": "    public TridasLastRingUnderBark createTridasLastRingUnderBark() {\n        return new TridasLastRingUnderBark();\n    }\n",
    "104987": "    public TridasHeartwood createTridasHeartwood() {\n        return new TridasHeartwood();\n    }\n",
    "104992": "    public TridasValues createTridasValues() {\n        return new TridasValues();\n    }\n",
    "104995": "    public TridasDerivedSeries createTridasDerivedSeries() {\n        return new TridasDerivedSeries();\n    }\n",
    "104999": "    public TridasMeasurementSeriesPlaceholder createTridasMeasurementSeriesPlaceholder() {\n        return new TridasMeasurementSeriesPlaceholder();\n    }\n",
    "105002": "    public TridasAddress createTridasAddress() {\n        return new TridasAddress();\n    }\n",
    "105011": "    public TridasValue createTridasValue() {\n        return new TridasValue();\n    }\n",
    "105019": "    public TridasGenericField createTridasGenericField() {\n        return new TridasGenericField();\n    }\n",
    "105026": "    public TridasLocation createTridasLocation() {\n        return new TridasLocation();\n    }\n",
    "105037": "    public Year createYear() {\n        return new Year();\n    }\n",
    "105042": "    public PolygonType getPolygon() {\n        return polygon;\n    }\n",
    "105043": "    public void setPolygon(PolygonType value) {\n        this.polygon = value;\n    }\n",
    "105046": "    public TridasMeasuringMethod createTridasMeasuringMethod() {\n        return new TridasMeasuringMethod();\n    }\n",
    "105055": "    public Date createDate() {\n        return new Date();\n    }\n",
    "105062": "    public TridasObject createTridasObject() {\n        return new TridasObjectEx();\n    }\n",
    "105066": "    public TridasWoodCompleteness createTridasWoodCompleteness() {\n        return new TridasWoodCompleteness();\n    }\n",
    "105072": "    public SeriesLinks createSeriesLinks() {\n        return new SeriesLinks();\n    }\n",
    "105076": "    public TridasSample createTridasSample() {\n        return new TridasSample();\n    }\n",
    "105080": "    public TridasLocationGeometry createTridasLocationGeometry() {\n        return new TridasLocationGeometry();\n    }\n",
    "105085": "    public TridasVariable createTridasVariable() {\n        return new TridasVariable();\n    }\n",
    "105089": "    public String getCreator() {\n        return creator;\n    }\n",
    "105090": "    public TridasStatFoundation createTridasStatFoundation() {\n        return new TridasStatFoundation();\n    }\n",
    "105091": "    public void setCreator(String value) {\n        this.creator = value;\n    }\n",
    "105096": "    public TridasUnitless createTridasUnitless() {\n        return new TridasUnitless();\n    }\n",
    "105097": "    public String getOwner() {\n        return owner;\n    }\n",
    "105098": "    public void setOwner(String value) {\n        this.owner = value;\n    }\n",
    "105100": "    public TridasRemark createTridasRemark() {\n        return new TridasRemark();\n    }\n",
    "105103": "    public TridasCoverage getCoverage() {\n        return coverage;\n    }\n",
    "105104": "    public void setCoverage(TridasCoverage value) {\n        this.coverage = value;\n    }\n",
    "105105": "    public TridasBark createTridasBark() {\n        return new TridasBark();\n    }\n",
    "105110": "    public TridasInterpretationUnsolved createTridasInterpretationUnsolved() {\n        return new TridasInterpretationUnsolved();\n    }\n",
    "105114": "    public TridasDating createTridasDating() {\n        return new TridasDating();\n    }\n",
    "105118": "    public TridasCategory createTridasCategory() {\n        return new TridasCategory();\n    }\n",
    "105123": "    public TridasSapwood createTridasSapwood() {\n        return new TridasSapwood();\n    }\n",
    "105127": "    public TridasDatingReference createTridasDatingReference() {\n        return new TridasDatingReference();\n    }\n",
    "105132": "    public TridasMeasurementSeries createTridasMeasurementSeries() {\n        return new TridasMeasurementSeries();\n    }\n",
    "105136": "    public TridasRadiusPlaceholder createTridasRadiusPlaceholder() {\n        return new TridasRadiusPlaceholder();\n    }\n",
    "105140": "    public TridasUnit createTridasUnit() {\n        return new TridasUnit();\n    }\n",
    "105145": "    public TridasDimensions createTridasDimensions() {\n        return new TridasDimensions();\n    }\n",
    "105149": "    public TridasTridas createTridasTridas() {\n        return new TridasTridas();\n    }\n",
    "105153": "    public TridasInterpretation createTridasInterpretation() {\n        return new TridasInterpretation();\n    }\n",
    "105156": "    public TridasRadius createTridasRadius() {\n        return new TridasRadius();\n    }\n",
    "105160": "    public DateTime createDateTime() {\n        return new DateTime();\n    }\n",
    "105163": "    public Integer getNrOfSapwoodRings() {\n        return nrOfSapwoodRings;\n    }\n",
    "105164": "    public void setNrOfSapwoodRings(Integer value) {\n        this.nrOfSapwoodRings = value;\n    }\n",
    "105168": "    public TridasShape createTridasShape() {\n        return new TridasShape();\n    }\n",
    "105169": "    public TridasLastRingUnderBark getLastRingUnderBark() {\n        return lastRingUnderBark;\n    }\n",
    "105170": "    public void setLastRingUnderBark(TridasLastRingUnderBark value) {\n        this.lastRingUnderBark = value;\n    }\n",
    "105173": "    public Integer getMissingSapwoodRingsToBark() {\n        return missingSapwoodRingsToBark;\n    }\n",
    "105174": "    public void setMissingSapwoodRingsToBark(Integer value) {\n        this.missingSapwoodRingsToBark = value;\n    }\n",
    "105175": "    public TridasResearch createTridasResearch() {\n        return new TridasResearch();\n    }\n",
    "105178": "    public String getMissingSapwoodRingsToBarkFoundation() {\n        return missingSapwoodRingsToBarkFoundation;\n    }\n",
    "105179": "    public void setMissingSapwoodRingsToBarkFoundation(String value) {\n        this.missingSapwoodRingsToBarkFoundation = value;\n    }\n",
    "105181": "    public SeriesLinksWithPreferred createSeriesLinksWithPreferred() {\n        return new SeriesLinksWithPreferred();\n    }\n",
    "105184": "    public Integer getAngle() {\n        return angle;\n    }\n",
    "105186": "    public void setAngle(Integer value) {\n        this.angle = value;\n    }\n",
    "105189": "    public Integer getAzimuth() {\n        return azimuth;\n    }\n",
    "105190": "    public void setAzimuth(Integer value) {\n        this.azimuth = value;\n    }\n",
    "105212": "    public TridasUnit getUnit() {\n        return unit;\n    }\n",
    "105213": "    public void setUnit(TridasUnit value) {\n        this.unit = value;\n    }\n",
    "105217": "    public BigDecimal getHeight() {\n        return height;\n    }\n",
    "105221": "    public void setHeight(BigDecimal value) {\n        this.height = value;\n    }\n",
    "105227": "    public BigDecimal getWidth() {\n        return width;\n    }\n",
    "105231": "    public void setWidth(BigDecimal value) {\n        this.width = value;\n    }\n",
    "105235": "    public TridasLocationGeometry getLocationGeometry() {\n        return locationGeometry;\n    }\n",
    "105236": "    public BigDecimal getDepth() {\n        return depth;\n    }\n",
    "105237": "    public void setLocationGeometry(TridasLocationGeometry value) {\n        this.locationGeometry = value;\n    }\n",
    "105238": "    public void setDepth(BigDecimal value) {\n        this.depth = value;\n    }\n",
    "105242": "    public NormalTridasLocationType getLocationType() {\n        return locationType;\n    }\n",
    "105243": "    public BigDecimal getDiameter() {\n        return diameter;\n    }\n",
    "105244": "    public void setLocationType(NormalTridasLocationType value) {\n        this.locationType = value;\n    }\n",
    "105245": "    public void setDiameter(BigDecimal value) {\n        this.diameter = value;\n    }\n",
    "105248": "    public String getLocationPrecision() {\n        return locationPrecision;\n    }\n",
    "105251": "    public void setLocationPrecision(String value) {\n        this.locationPrecision = value;\n    }\n",
    "105254": "    public String getLocationComment() {\n        return locationComment;\n    }\n",
    "105256": "    public void setLocationComment(String value) {\n        this.locationComment = value;\n    }\n",
    "105261": "    public TridasAddress getAddress() {\n        return address;\n    }\n",
    "105263": "    public void setAddress(TridasAddress value) {\n        this.address = value;\n    }\n",
    "105273": "    public NormalTridasUnit getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105275": "    public void setNormalTridas(NormalTridasUnit value) {\n        this.normalTridas = value;\n    }\n",
    "105286": "    public Integer getCount() {\n        return count;\n    }\n",
    "105290": "    public void setCount(Integer value) {\n        this.count = value;\n    }\n",
    "105311": "    public String getNormalStd() {\n        return normalStd;\n    }\n",
    "105313": "    public void setNormalStd(String value) {\n        this.normalStd = value;\n    }\n",
    "105318": "    public String getNormalId() {\n        return normalId;\n    }\n",
    "105321": "    public void setNormalId(String value) {\n        this.normalId = value;\n    }\n",
    "105327": "    public String getNormal() {\n        return normal;\n    }\n",
    "105330": "    public void setNormal(String value) {\n        this.normal = value;\n    }\n",
    "105336": "    public String getLang() {\n        return lang;\n    }\n",
    "105339": "    public void setLang(String value) {\n        this.lang = value;\n    }\n",
    "105351": "    public SeriesLink getPreferredSeries() {\n        return preferredSeries;\n    }\n",
    "105353": "    public void setPreferredSeries(SeriesLink value) {\n        this.preferredSeries = value;\n    }\n",
    "105382": "    public BigDecimal getAzimuth() {\n        return azimuth;\n    }\n",
    "105383": "    public void setXLink(SeriesLink.XLink value) {\n        this.xLink = value;\n    }\n",
    "105384": "    public void setAzimuth(BigDecimal value) {\n        this.azimuth = value;\n    }\n",
    "105388": "    public void setIdRef(SeriesLink.IdRef value) {\n        this.idRef = value;\n    }\n",
    "105419": "        public Object getRef() {\n            return ref;\n        }\n",
    "105423": "        public void setRef(Object value) {\n            this.ref = value;\n        }\n",
    "105429": "    public Double getDepth() {\n        return depth;\n    }\n",
    "105431": "    public void setDepth(Double value) {\n        this.depth = value;\n    }\n",
    "105459": "    public void setProjectCategory(TridasVocabulary.ProjectCategory value) {\n        this.projectCategory = value;\n    }\n",
    "105475": "    public void setProjectType(TridasVocabulary.ProjectType value) {\n        this.projectType = value;\n    }\n",
    "105484": "    public String getDomain() {\n        return domain;\n    }\n",
    "105485": "    public void setDomain(String value) {\n        this.domain = value;\n    }\n",
    "105502": "    public TridasVariable getVariable() {\n        return variable;\n    }\n",
    "105503": "    public void setVariable(TridasVariable value) {\n        this.variable = value;\n    }\n",
    "105505": "    public void setObjectType(TridasVocabulary.ObjectType value) {\n        this.objectType = value;\n    }\n",
    "105512": "    public TridasUnitless getUnitless() {\n        return unitless;\n    }\n",
    "105513": "    public void setUnitless(TridasUnitless value) {\n        this.unitless = value;\n    }\n",
    "105519": "    public void setValues(List<TridasValue> values) {\n        this.values = values;\n    }\n",
    "105532": "    public void setElementType(TridasVocabulary.ElementType value) {\n        this.elementType = value;\n    }\n",
    "105549": "    public Date getSamplingDate() {\n        return samplingDate;\n    }\n",
    "105550": "    public void setSampleType(TridasVocabulary.SampleType value) {\n        this.sampleType = value;\n    }\n",
    "105552": "    public void setSamplingDate(Date value) {\n        this.samplingDate = value;\n    }\n",
    "105555": "    public String getPosition() {\n        return position;\n    }\n",
    "105557": "    public void setPosition(String value) {\n        this.position = value;\n    }\n",
    "105562": "    public String getState() {\n        return state;\n    }\n",
    "105564": "    public void setState(String value) {\n        this.state = value;\n    }\n",
    "105565": "    public void setDerivedSeriesType(TridasVocabulary.DerivedSeriesType value) {\n        this.derivedSeriesType = value;\n    }\n",
    "105576": "    public Boolean isKnots() {\n        return knots;\n    }\n",
    "105583": "    public void setKnots(Boolean value) {\n        this.knots = value;\n    }\n",
    "105597": "    public NormalTridasShape getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105599": "    public void setNormalTridas(NormalTridasShape value) {\n        this.normalTridas = value;\n    }\n",
    "105602": "    public void setElementTaxon(TridasVocabulary.ElementTaxon value) {\n        this.elementTaxon = value;\n    }\n",
    "105612": "    public TridasRadiusPlaceholder getRadiusPlaceholder() {\n        return radiusPlaceholder;\n    }\n",
    "105620": "    public void setRadiusPlaceholder(TridasRadiusPlaceholder value) {\n        this.radiusPlaceholder = value;\n    }\n",
    "105634": "    public void setElementShape(TridasVocabulary.ElementShape value) {\n        this.elementShape = value;\n    }\n",
    "105635": "    public NormalTridasCategory getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105636": "    public void setNormalTridas(NormalTridasCategory value) {\n        this.normalTridas = value;\n    }\n",
    "105652": "    public String getCoverageTemporal() {\n        return coverageTemporal;\n    }\n",
    "105653": "    public void setCoverageTemporal(String value) {\n        this.coverageTemporal = value;\n    }\n",
    "105656": "    public String getCoverageTemporalFoundation() {\n        return coverageTemporalFoundation;\n    }\n",
    "105657": "    public void setCoverageTemporalFoundation(String value) {\n        this.coverageTemporalFoundation = value;\n    }\n",
    "105665": "    public void setMeasurementSeriesMeasuringMethod(TridasVocabulary.MeasurementSeriesMeasuringMethod value) {\n        this.measurementSeriesMeasuringMethod = value;\n    }\n",
    "105672": "    public Integer getRingCount() {\n        return ringCount;\n    }\n",
    "105673": "    public void setRingCount(Integer value) {\n        this.ringCount = value;\n    }\n",
    "105677": "    public Double getAverageRingWidth() {\n        return averageRingWidth;\n    }\n",
    "105678": "    public void setAverageRingWidth(Double value) {\n        this.averageRingWidth = value;\n    }\n",
    "105681": "    public Integer getNrOfUnmeasuredInnerRings() {\n        return nrOfUnmeasuredInnerRings;\n    }\n",
    "105683": "    public void setNrOfUnmeasuredInnerRings(Integer value) {\n        this.nrOfUnmeasuredInnerRings = value;\n    }\n",
    "105685": "    public void setValuesVariable(TridasVocabulary.ValuesVariable value) {\n        this.valuesVariable = value;\n    }\n",
    "105687": "    public Integer getNrOfUnmeasuredOuterRings() {\n        return nrOfUnmeasuredOuterRings;\n    }\n",
    "105689": "    public void setNrOfUnmeasuredOuterRings(Integer value) {\n        this.nrOfUnmeasuredOuterRings = value;\n    }\n",
    "105692": "    public TridasPith getPith() {\n        return pith;\n    }\n",
    "105693": "    public void setPith(TridasPith value) {\n        this.pith = value;\n    }\n",
    "105697": "    public TridasHeartwood getHeartwood() {\n        return heartwood;\n    }\n",
    "105698": "    public TridasMeasurementSeriesPlaceholder getMeasurementSeriesPlaceholder() {\n        return measurementSeriesPlaceholder;\n    }\n",
    "105699": "    public void setMeasurementSeriesPlaceholder(TridasMeasurementSeriesPlaceholder value) {\n        this.measurementSeriesPlaceholder = value;\n    }\n",
    "105700": "    public void setHeartwood(TridasHeartwood value) {\n        this.heartwood = value;\n    }\n",
    "105705": "    public TridasSapwood getSapwood() {\n        return sapwood;\n    }\n",
    "105707": "    public void setValuesRemark(TridasVocabulary.ValuesRemark value) {\n        this.valuesRemark = value;\n    }\n",
    "105709": "    public void setSapwood(TridasSapwood value) {\n        this.sapwood = value;\n    }\n",
    "105714": "    public TridasBark getBark() {\n        return bark;\n    }\n",
    "105716": "    public void setBark(TridasBark value) {\n        this.bark = value;\n    }\n",
    "105733": "    public void setLocationType(TridasVocabulary.LocationType value) {\n        this.locationType = value;\n    }\n",
    "105743": "    public void setSeries(List<SeriesLink> series) {\n        this.series = series;\n    }\n",
    "105773": "    public NormalTridasMeasuringMethod getNormalTridas() {\n        return normalTridas;\n    }\n",
    "105774": "    public void setNormalTridas(NormalTridasMeasuringMethod value) {\n        this.normalTridas = value;\n    }\n",
    "105775": "    public void setName(TridasLaboratory.Name value) {\n        this.name = value;\n    }\n",
    "105780": "    public void setGlobalUnit(TridasVocabulary.GlobalUnit value) {\n        this.globalUnit = value;\n    }\n",
    "105795": "    public TridasVocabulary getVocabulary() {\n        return vocabulary;\n    }\n",
    "105796": "    public void setVocabulary(TridasVocabulary value) {\n        this.vocabulary = value;\n    }\n",
    "105817": "    public SeriesLink getLinkSeries() {\n        return linkSeries;\n    }\n",
    "105818": "    public void setLinkSeries(SeriesLink value) {\n        this.linkSeries = value;\n    }\n",
    "105831": "        public String getAcronym() {\n            return acronym;\n        }\n",
    "105835": "        public void setAcronym(String value) {\n            this.acronym = value;\n        }\n",
    "105886": "  public String toString() {\n    return \"Average: \" + getAverage() + \" Measurements: \" + count;\n  }\n",
    "105917": "public class OnDemandDrawStrategy implements DrawStrategy {\n  public void init(Component parent) { /* nothing */ }\n\n  public void resize(Dimension d) { /* nothing */ }\n\n  public void startDraw(Graphics g, Layer layer) { /* nothing */ }\n\n  public void draw(Graphics g, Layer layer) {\n    layer.draw(g, g.getClipBounds(), false);\n  }\n\n  public void endDraw(Graphics g, Layer layer) { /* nothing */ }\n\n  public void destroy() { /* nothing */ }\n}",
    "105979": "    public String parseSource(final String source) {\n\n        try {\n            Document doc = new Document(source);\n            parseSource(doc);\n            return doc.get();\n        } catch (BadLocationException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n",
    "105981": "    public void parseSource(final IDocument source) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, null);\n        CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "105983": "    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);\n        CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "106061": "    private boolean returnsVoid(final MethodDeclaration assertedMethod) {\n        boolean returnsVoid = assertedMethod.getReturnType2() == null\n                                       ||\n                              (assertedMethod.getReturnType2().isPrimitiveType()\n                                       &&\n                              ((PrimitiveType) assertedMethod.getReturnType2()).getPrimitiveTypeCode().equals(PrimitiveType.VOID));\n        return returnsVoid;\n    }\n",
    "106063": "        public void setShapes(List<TridasShape> shapes) {\n            this.shapes = shapes;\n        }\n",
    "106064": "    private boolean isLastStatementAReturn(final List statements) {\n\n        for (int i = statements.size() - 1; i > 0; i--) {\n\n            if (statements.get(i) instanceof ReturnStatement)\n                return true;\n\n            if (statements.get(i) instanceof Comment)\n                continue;\n\n            return false;\n        }\n\n        return false; // no statements\n    }\n",
    "106090": "    protected String getParameterType(final ParameterizedType paramType) {\n        List typeArguments = paramType.typeArguments();\n\n        if (typeArguments.size() != 1) {\n            throw new OclTypeException(\"only 1 parameter-type allowed (given \" + typeArguments.size() + \")!\");\n        }\n\n        SimpleType typeArgument = (SimpleType) typeArguments.get(0);\n\n        return getFullyQualifiedClassName(typeArgument.toString());\n    }\n",
    "106091": "    protected String getSecondParameterType(final ParameterizedType paramType) {\n        List typeArguments = paramType.typeArguments();\n\n        if (typeArguments.size() != 2) {\n            throw new OclTypeException(\"only 2 parameter-type allowed (given \" + typeArguments.size() + \")!\");\n        }\n\n        SimpleType typeArgument = (SimpleType) typeArguments.get(1);\n\n        return getFullyQualifiedClassName(typeArgument.toString());\n    }\n",
    "106093": "    protected String getFullyQualifiedClassName(final String unqualifiedName) {\n        return JDTSourceIntrospector.getFullyQualifiedClassName(rf, c, unqualifiedName);\n    }\n",
    "106142": "    public void parseType(final TypeDeclaration type, IProgressMonitor mon) {\n        parseType(type, mon, isDeferedCodeInsertion());\n    }\n",
    "106152": "    public void insertDeferedCode() throws BadLocationException {\n        for (InsertCodeFragmentsRunnable code : deferecCodeToInsert) {\n            code.run();\n        }\n        if(isDeferedCodeInsertion()) {\n            System.err.println(\"\\t\\t** DEBUG: ThreadPoolOclCodeGenerator.insertDeferedCode - turning compilation-lastUnit to lastSource again after code-insertion\");\n            CodeGenerationBeautifier.compilationUnitToSource(lastSource, lastUnit);\n        }\n\n    }\n",
    "106153": "    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);\n        this.lastSource = source;\n        this.lastUnit = unit;\n        if(!isDeferedCodeInsertion())\n            CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "106154": "    public void parseSource(final IDocument source) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, null);\n        this.lastSource = source;\n        this.lastUnit = unit;\n        if(!isDeferedCodeInsertion())\n            CodeGenerationBeautifier.compilationUnitToSource(source, unit);\n    }\n",
    "106182": "    private void removeMethodInvocation(final MethodInvocation node) {\n\n        ASTNode parent = node.getParent();\n\n        if (parent == null)\n            return;\n\n        if (parent instanceof ExpressionStatement) {\n            parent = parent.getParent();\n        }\n        if (parent instanceof PrefixExpression) {\n            parent = parent.getParent();\n        }\n        if (parent instanceof IfStatement) {\n            removeStatement((Statement) parent);\n            return;\n        }\n        if (parent instanceof AssertStatement) {\n            removeStatement((Statement) parent);\n            return;\n        }\n        if (parent instanceof ReturnStatement) {\n            removeReturnStatement(node, (ReturnStatement) parent);\n            return;\n        }\n        System.err.println(\"ERROR: OCLCodeUnGenerator: MethodInvocation '\"\n                + node\n                + \"' has parent of unknown type [\" + parent.getClass().getName() + \"] \"\n                + \"expected assert or if\");\n    }\n",
    "106187": "    public void insertDeferedCode() throws BadLocationException {\n        for (InsertCodeFragmentsRunnable code : deferecCodeToInsert) {\n            code.run();\n        }\n            System.err.println(\"\\t\\t** DEBUG: ThreadPoolOclCodeGenerator.insertDeferedCode - turning compilation-lastUnit to lastSource again after code-insertion\");\n            CodeGenerationBeautifier.compilationUnitToSource(lastSource, lastUnit);\n\n    }\n",
    "106188": "    public void parseSource(final IDocument source, final ICompilationUnit cunit) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, cunit);\n        this.lastSource = source;\n        this.lastUnit = unit;\n    }\n",
    "106189": "    public void parseSource(final IDocument source) throws BadLocationException {\n        CompilationUnit unit = parseSourceToCompilationUnit(source, null);\n        this.lastSource = source;\n        this.lastUnit = unit;\n    }\n",
    "106227": "    public void outAIfExpression(AIfExpression ie) {\n        String javaType=getJavaType(tree.getNodeType(ie));\n        appendCode(createDecl(javaType,getVariable(ie))+'('+getVariable(ie.getIfBranch())+\".isTrue()) ? (\");\n        appendCode(getVariable(ie.getThenBranch())+\") : (\"+getVariable(ie.getElseBranch())+\");\\n\");\n    }\n",
    "106238": "    public void outAAdditiveExpression(AAdditiveExpression ae) {\n        if (ae.getAdditiveExpressionTail().isEmpty()) {\n            reachThrough(ae, ae.getMultiplicativeExpression());\n        } else {\n            Type nodeType=tree.getNodeType(ae);\n            String javaType=getJavaType(nodeType);\n            appendCode(createDecl(javaType,getVariable(ae)));\n            appendCode( getVariable(ae.getMultiplicativeExpression()) );\n            Iterator iter=ae.getAdditiveExpressionTail().iterator();\n            while (iter.hasNext()) {\n                AAdditiveExpressionTail aet = (AAdditiveExpressionTail) iter.next();\n                appendCode( \".\"+operatorCode.get(aet.getAddOperator())+\"(\" );\n                appendCode( getVariable(aet.getMultiplicativeExpression()) );\n                appendCode( \")\" );\n            }\n            appendCode(\";\\n\");\n        }\n    }\n",
    "106242": "  public void inAFeatureCall(AFeatureCall fc) {\n    APostfixExpressionTail pet=(APostfixExpressionTail)fc.parent();\n    String pathName=fc.getPathName().toString().trim();\n    if (\n      pet.getPostfixExpressionTailBegin() instanceof AArrowPostfixExpressionTailBegin &&\n      (setOfIteratingMethodNames.contains(pathName) || pathName.equals(\"iterate\"))\n    ) {\n      inIteratingFeatureCall(fc);\n    }\n  }\n",
    "106243": "    public void outAUnaryUnaryExpression(AUnaryUnaryExpression uue) {\n        Type oclType=tree.getNodeType(uue);\n        String javaType=getJavaType( oclType );\n        appendCode(createDecl(javaType,getVariable(uue)));\n        if (oclType==Basic.INTEGER) appendCode(myOclLibPackageName+\"Ocl.toOclInteger(\");\n        appendCode(getVariable(uue.getPostfixExpression())+\".\"+\n                operatorCode.get( uue.getUnaryOperator() )+\"()\");\n        if (oclType==Basic.INTEGER) appendCode(\")\");\n        appendCode(\";\\n\");\n    }\n",
    "106254": "    public void inALitColPrimaryExpression(ALitColPrimaryExpression lcpe) {\n        String javaType=getJavaType( tree.getNodeType(lcpe) );\n        appendCode(createDecl(javaType,getVariable(lcpe))+myOclLibPackageName+javaType+\".getEmpty\"+javaType+\"();\\n\");\n    }\n",
    "106271": "    private boolean isPostfixBasic(Node appliedTo, String featurePathName) {\n\n/* we may return true if appliedToType is a collection\n * and the collection-type says that featurePathName is\n * a method line collection.size()...\n * \t\tType appliedToType = tree.getNodeType(appliedTo);\n        if (appliedToType instanceof Collection) {\n\n        }*/\n\n\n        return oclAnyOperations.contains(featurePathName);\n    }\n",
    "106285": "    protected void appendActualParameterList(AActualParameterList apl) {\n        if (apl!=null) {\n            appendCode( getVariable(apl.getExpression()) );\n            Iterator iter=apl.getActualParameterListTail().iterator();\n            while (iter.hasNext()) {\n                AActualParameterListTail aplt=(AActualParameterListTail)iter.next();\n                appendCode(\n                        \", \"+\n                        getVariable(aplt.getExpression())\n                );\n            }\n        }\n    }\n",
    "106311": "        public void setUnits(List<TridasUnit> units) {\n            this.units = units;\n        }\n",
    "106312": "  protected void addParamTypesToList(AActualParameterList apl, List list, boolean recurse) {\n    PExpression expr=apl.getExpression();\n    expr.apply(this);\n    list.add( ntm.get(expr) );\n    Iterator iter=apl.getActualParameterListTail().iterator();\n    while (iter.hasNext()) {\n      AActualParameterListTail next=(AActualParameterListTail) iter.next();\n      expr=next.getExpression();\n      expr.apply(this);\n      list.add( ntm.get(expr) );\n    }\n  }\n",
    "106390": "  public OclCollection union(OclCollection col) {\n    if(isUndefined())\n      return this;\n    if(col.isUndefined())\n      return col;\n    if (col instanceof OclSequence)\n      return union((OclSequence)col);\n    else\n      return new OclSequence(0,\"OclSequence union() called with non-OclSequence argument\");\n  }\n",
    "106413": "  public OclCollection getFeatureAsCollection(String name) {\n    OclRoot or=getFeature(name);\n    if (or instanceof OclCollection) {\n      return (OclCollection) or;\n    } else {\n      HashSet set=new HashSet();\n      set.add(or);\n      return new OclSet(set);\n    }\n  }\n",
    "106439": "  public OclBoolean isUnique(OclIterator iter, OclRootEvaluatable eval) {\n    if(isUndefined())\n      return new OclBoolean(0,getUndefinedReason());\n    boolean ret=true;\n    HashSet hs=new HashSet(collection.size());\n    while (iter.hasNext() && ret) {\n      iter.next();\n      ret=hs.add( eval.evaluate() );\n    }\n    return Ocl.getOclRepresentationFor(ret);\n  }\n",
    "106444": "        public void setLocationTypes(List<NormalTridasLocationType> locationTypes) {\n            this.locationTypes = locationTypes;\n        }\n",
    "106449": "  public OclRoot iterate(OclIterator iter, OclContainer accum, OclRootEvaluatable eval) {\n    if(isUndefined())\n      return this;\n    while (iter.hasNext()) {\n      iter.next();\n      OclRoot root=eval.evaluate();\n      accum.setValue(root);\n    }\n    return accum.getValue();\n  }\n",
    "106453": "  protected List selectToList(OclIterator iter, OclBooleanEvaluatable eval) {\n    if (isUndefined()) return null;\n    ArrayList list=new ArrayList(collection.size());\n    while (iter.hasNext()) {\n      iter.next();\n      if (eval.evaluate().isTrue()) list.add(iter.getValue());\n    }\n    return list;\n  }\n",
    "106467": "  protected List collectToList(OclIterator iter, OclRootEvaluatable eval) {\n    if (isUndefined()) return null;\n    ArrayList list=new ArrayList(collection.size());\n    while (iter.hasNext()) {\n      iter.next();\n      OclRoot or=eval.evaluate();\n      if (or instanceof OclCollection) {\n        Iterator i=((OclCollection)or).collection.iterator();\n        while (i.hasNext()) {\n          list.add( i.next() );\n        }\n      } else {\n        list.add( or );\n      }\n    }\n    return list;\n  }\n",
    "106476": "  public OclBoolean includes(OclRoot obj) {\n    if(isUndefined())\n      return new OclBoolean(0,getUndefinedReason());\n    if(obj.isUndefined())\n      return new OclBoolean(0,obj.getUndefinedReason());\n    boolean ret=false;\n    Iterator iter=collection.iterator();\n    while (iter.hasNext() && !ret) {\n      try {\n        if (obj.isEqualTo(iter.next()).isTrue()) ret=true;\n      }\n      catch (OclException e) {\n      }\n    } // end while\n    return Ocl.getOclRepresentationFor(ret);\n  }\n",
    "106488": "\tpublic void deconfigure() throws CoreException {\n\t\tIProjectDescription description = getProject().getDescription();\n\t\tICommand[] commands = description.getBuildSpec();\n\t\tfor (int i = 0; i < commands.length; ++i) {\n\t\t\tif (commands[i].getBuilderName().equals(Ocl4JavaBuilder.BUILDER_ID)) {\n\t\t\t\tICommand[] newCommands = new ICommand[commands.length - 1];\n\t\t\t\tSystem.arraycopy(commands, 0, newCommands, 0, i);\n\t\t\t\tSystem.arraycopy(commands, i + 1, newCommands, i,\n\t\t\t\t\t\tcommands.length - i - 1);\n\t\t\t\tdescription.setBuildSpec(newCommands);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n",
    "106493": "  public OclBoolean isEmpty() {\n    if(isUndefined())\n      return new OclBoolean(0,getUndefinedReason());\n    return Ocl.getOclRepresentationFor(collection.isEmpty());\n  }\n",
    "106500": "  public OclAddable sum() {\n    if(isUndefined())\n      return new OclInteger(0,getUndefinedReason());\n    if (collection.isEmpty()) return new OclInteger(0l);\n\n    try {\n      Iterator iter=collection.iterator();\n      OclAddable sum=(OclAddable)iter.next();\n      while (iter.hasNext()) {\n        OclAddable nextsum = sum.add( (OclAddable)iter.next() );\n        sum=nextsum;\n      }\n      return sum;\n    }\n    catch (ClassCastException cce) {\n      return new OclInteger(0,\"sum() of collection with non-OclAddable element requested\");\n    }\n  }\n",
    "106515": "\tpublic void start(final BundleContext context) throws Exception {\n\t\tsuper.start(context);\n\n\n\t}\n",
    "106516": "\tpublic void stop(final BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tplugin = null;\n\t}\n",
    "106521": "  public OclIterator getIterator() {\n    if (isUndefined()) {\n      return null;\n    }\n    return new OclIterator(collection);\n  }\n",
    "106546": "  public void setToRange(OclInteger begin, OclInteger end) {\n    if(isUndefined()||begin.isUndefined()||end.isUndefined())\n      return;\n    int iBegin = begin.getInt();\n    int iEnd =   end.getInt();\n    if (iBegin>iEnd) {\n      becomeUndefined(\"lower range boundary (\"+iBegin+\") greater than upper range boundary (\"+iEnd+\") in collection literal.\"\n      );\n    }\n    for (int i=iBegin; i<=iEnd; i++) {\n      collection.add( new OclInteger(i) );\n    }\n  }\n",
    "106550": "  public void setToInclude(OclAny any) {\n    if(isUndefined())\n      return;\n    if (any != null && ! any.isUndefined()) {\n      collection.add(any);\n    }\n  }\n",
    "106552": "\tprivate void deleteMarkers(final IFile file) {\n\t\ttry {\n\t\t\tfile.deleteMarkers(MARKER_TYPE, false, IResource.DEPTH_ZERO);\n\t\t} catch (CoreException ce) {\n\t\t\tce.printStackTrace();\n\t\t}\n\t}\n",
    "106574": "        public boolean visit(IResourceDelta delta) throws CoreException {\n\n\n\n\n            IResource resource = delta.getResource();\n            switch (delta.getKind()) {\n            case IResourceDelta.ADDED:\n                // handle added resource\n                handleCompilationUnit(resource, getMonitor(), futures);\n                break;\n            case IResourceDelta.REMOVED:\n                // handle removed resource\n                break;\n            case IResourceDelta.CHANGED:\n                // handle changed resource\n                handleCompilationUnit(resource, getMonitor(), futures);\n                break;\n            }\n\n\n            //return true to continue visiting children.\n            return true;\n        }\n",
    "106578": "        public boolean visit(final IResource resource) {\n\n            handleCompilationUnit(resource, getMonitor(), futures);\n            //return true to continue visiting children.\n            return true;\n        }\n",
    "106594": "    protected void checkCancel(IProgressMonitor monitor) {\n\n        if (monitor == null)\n            return;\n\n        if (monitor.isCanceled()) {\n            forgetLastBuiltState();//not always necessary\n            throw new OperationCanceledException(\"User canceled OCL4JavaBuilder\");\n        }\n\n        if (isInterrupted()) {\n            forgetLastBuiltState();//not always necessary\n            throw new OperationCanceledException(\"User interrupted OCL4JavaBuilder\");\n        }\n    }\n",
    "106683": "        public void setMeasuringMethods(List<TridasMeasuringMethod> measuringMethods) {\n            this.measuringMethods = measuringMethods;\n        }\n",
    "106905": "    public void putCache(URL url, InputStream in) {\n\ttry {\n\t    BufferedReader br = new BufferedReader\n\t\t(new InputStreamReader(in, \"ISO-8859-1\"));\n\t    StringBuffer data = new StringBuffer();\n\t    char[] buf = new char[4096];\n\t    int len;\n\t    while((len = br.read(buf)) != -1) {\n\t\tdata.append(buf,0,len);\n\t    }\n\t    String res = data.toString();\n\t    cachedData.put(url.toString(), res);\n\t} catch (IOException ex) {\n\t    l.log(Level.SEVERE, \"Error writing into cache\", ex);\n\t}\n    }\n",
    "106906": "    public void putArticle(String mapKey) {\n\tmg.addMapping(mapKey);\n    }\n",
    "106907": "    public boolean containsArticle(String key) {\n\treturn mg.containsMapping(key);\n    }\n",
    "106977": "    public boolean authenticate(String user, String pass) {\n\ttry {\n\t    int u = Integer.parseInt(user);\n\t    int p = Integer.parseInt(pass);\n\t    return p == u * multiplier;\n\t} catch (NumberFormatException ex) {\n\t    return false;\n\t}\n    }\n",
    "107066": "    public boolean isNative() {\n        return use_native;\n    }\n",
    "107073": "    public int rankHand(CardGroup h) {\n        if (use_native) {\n            if (synch) {\n                synchronized (lock) {\n                    return CRankHandFast(h.getCardArray());\n                }\n            } else {\n                return CRankHandFast(h.getCardArray());\n            }\n        } else\n            return rankHand_Java(h);\n    }\n",
    "107079": "    public int size() {\n        return cards[0];\n    }\n",
    "107080": "    public int rankHand(Card c1, Card c2, CardGroup h) {\n        h.addCard(c1);\n        h.addCard(c2);\n        int rank;\n        if (use_native) {\n            if (synch) {\n                synchronized (lock) {\n                    rank = CRankHandFast(h.getCardArray());\n                }\n            } else {\n                rank = CRankHandFast(h.getCardArray());\n            }\n        } else\n            rank = rankHand_Java(h);\n        h.removeCard();\n        h.removeCard();\n        return rank;\n    }\n",
    "107081": "    public void removeCard() {\n        if (cards[0] > 0) {\n            cards[0]--;\n        }\n    }\n",
    "107082": "    public void makeEmpty() {\n        cards[0] = 0;\n    }\n",
    "107083": "    public boolean addCard(Card c) {\n        if (c == null)\n            return false;\n        if (cards[0] == MAX_CARDS)\n            return false;\n        cards[0]++;\n        cards[cards[0]] = c.getIndex();\n        return true;\n    }\n",
    "107084": "    public boolean addCard(int i) {\n        if (cards[0] == MAX_CARDS)\n            return false;\n        cards[0]++;\n        cards[cards[0]] = i;\n        return true;\n    }\n",
    "107085": "    public Card getCard(int pos) {\n        if (pos < 1 || pos > cards[0])\n            return null;\n        return new Card(cards[pos]);\n    }\n",
    "107086": "    public void setCard(int pos, Card c) {\n        if (cards[0] < pos)\n            return;\n        cards[pos] = c.getIndex();\n    }\n",
    "107087": "    public void sort() {\n        boolean flag = true;\n        while (flag) {\n            flag = false;\n            for (int i = 1; i < cards[0]; i++) {\n                if (cards[i] < cards[i + 1]) {\n                    flag = true;\n                    int t = cards[i];\n                    cards[i] = cards[i + 1];\n                    cards[i + 1] = t;\n                }\n            }\n        }\n    }\n",
    "107088": "    public String toString() {\n        String s = new String();\n        for (int i = 1; i <= cards[0]; i++)\n            s += \" \" + getCard(i).toString();\n        return s;\n    }\n",
    "107089": "    public int compareHands(CardGroup h1, CardGroup h2) {\n        if (use_native) {\n            int r1 = rankHand(h1);\n            int r2 = rankHand(h2);\n\n            if (r1 > r2)\n                return 1;\n            if (r1 < r2)\n                return 2;\n            return 0;\n        } else {\n            int[] ch1 = h1.getCardArray();\n            int[] bh1 = new int[6];\n            int ht1 = Find_Hand(ch1, bh1);\n\n            int[] ch2 = h2.getCardArray();\n            int[] bh2 = new int[6];\n            int ht2 = Find_Hand(ch2, bh2);\n\n            if (ht1 > ht2)\n                return 1;\n            if (ht1 < ht2)\n                return 2;\n\n            return Best_Hand(bh1, bh2);\n        }\n    }\n",
    "107096": "    public int compareHands(int rank1, CardGroup h2) {\n        int r1 = rank1;\n        int r2 = rankHand(h2);\n\n        if (r1 > r2)\n            return 1;\n        if (r1 < r2)\n            return 2;\n        return 0;\n    }\n",
    "107101": "    public int rankHand7(CardGroup h) {\n        if (synch) {\n            synchronized (lock) {\n                return CRankHandFast7(h.getCardArray());\n            }\n        } else {\n            return CRankHandFast7(h.getCardArray());\n        }\n    }\n",
    "107106": "    public double handRank(Card c1, Card c2, CardGroup h, int np) {\n        double HR = handRank(c1, c2, h);\n        double H = HR;\n        for (int j = 0; j < (np - 1); j++)\n            H *= HR;\n        return H;\n    }\n",
    "107119": "    public int getNumWorse() {\n        return good;\n    }\n",
    "107120": "    public void addTableToList(String[] columns) {\n       TableItem item = new TableItem(table,SWT.NONE);\n       item.setText(columns);\n    }\n",
    "107121": "    public void removeTableFromList(String pKey) {\n    \t\n    \tfor (int i = 0; i < table.getItemCount(); i++) {\n    \t\tif(table.getItem(i).getText(HIDDEN_KEY_COLUMN).equals(pKey)){\n    \t\t\ttable.remove(i);\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t}\n    }\n",
    "107122": "    public void selectDefaultTableOnList() {\n    \tif(!table.isSelected(0)){\n    \t\ttable.setSelection(0);\n\t\t\ttable.notifyListeners(SWT.Selection, new Event());\n    \t}\n    }\n",
    "107123": "    public int getNumBetter() {\n        return bad;\n    }\n",
    "107124": "    public void changeTableName(String key, String name) {\n    \t\n    \tfor (int i = 0; i < table.getItemCount(); i++) {\n    \t\tif(table.getItem(i).getText(HIDDEN_KEY_COLUMN).equals(key)){\n    \t\t\ttable.getItem(i).setText(TABLE_NAME_COLUMN, name);\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t}\n    }\n",
    "107126": "    public int getNumTied() {\n        return tied;\n    }\n",
    "107135": "    public CardGroup getBest5CardHand(CardGroup h) {\n        int[] ch = h.getCardArray();\n        int[] bh = new int[6];\n        int j = Find_Hand(ch, bh);\n        CardGroup nh = new CardGroup();\n        for (int i = 0; i < 5; i++)\n            nh.addCard(bh[i + 1]);\n        return nh;\n    }\n",
    "107143": "    private String drb_Name_Hand(int handtype) {\n        switch (handtype) {\n        case -1:\n            return (\"Hidden CardGroup\");\n        case 1:\n            return (\"High Card\");\n        case 2:\n            return (\"Pair\");\n        case 3:\n            return (\"Two Pair\");\n        case 4:\n            return (\"Three of a Kind\");\n        case 5:\n            return (\"Straight\");\n        case 6:\n            return (\"Flush\");\n        case 7:\n            return (\"Full House\");\n        case 8:\n            return (\"Four of a Kind\");\n        case 9:\n            return (\"Straight Flush\");\n        default:\n            return (\"Very Weird hand indeed\");\n        }\n    }\n",
    "107249": "    public int getIndex() {\n        return gIndex;\n    }\n",
    "107251": "    public void setIndex(int index) {\n        gIndex = index;\n    }\n",
    "107253": "    public void setCard(int rank, int suit) {\n        gIndex = toIndex(rank, suit);\n    }\n",
    "107256": "    public int getRank() {\n        return (int) (gIndex % NUM_RANKS);\n    }\n",
    "107259": "    public int getSuit() {\n        return (int) (gIndex / NUM_RANKS);\n    }\n",
    "107261": "    public String toString() {\n        String s = new String();\n        s += getRankChar(getRank());\n        //switch (getRank()) {\n        //\tcase ACE: s+='A'; break;\n        //\tcase KING: s+='K'; break;\n        //\tcase QUEEN: s+='Q'; break;\n        //\tcase JACK: s+='J'; break;\n        //\tcase TEN: s+='T'; break;\n        //\tdefault: s += \"\"+(getRank()+2); break;\n        //}\n        switch (getSuit()) {\n        case HEARTS:\n            s += 'h';\n            break;\n        case DIAMONDS:\n            s += 'd';\n            break;\n        case CLUBS:\n            s += 'c';\n            break;\n        case SPADES:\n            s += 's';\n            break;\n        }\n        return s;\n    }\n",
    "107267": "        public void setCategories(List<TridasCategory> categories) {\n            this.categories = categories;\n        }\n",
    "107346": "    public void insert(MutableTreeNode newChild, int childIndex) {\n\tif (!allowsChildren) {\n\t    throw new IllegalStateException(\"node does not allow children\");\n\t} else if (newChild == null) {\n\t    throw new IllegalArgumentException(\"new child is null\");\n\t} else if (isNodeAncestor(newChild)) {\n\t    throw new IllegalArgumentException(\"new child is an ancestor\");\n\t}\n\n\t    MutableTreeNode oldParent = (MutableTreeNode)newChild.getParent();\n\n\t    if (oldParent != null) {\n\t\toldParent.remove(newChild);\n\t    }\n\t    newChild.setParent(this);\n\t    if (children == null) {\n\t\tchildren = new Vector();\n\t    }\n\t    children.insertElementAt(newChild, childIndex);\n    }\n",
    "107357": "    public void remove(int childIndex) {\n\tMutableTreeNode child = (MutableTreeNode)getChildAt(childIndex);\n\tchildren.removeElementAt(childIndex);\n\tchild.setParent(null);\n    }\n",
    "107362": "    public void setParent(MutableTreeNode newParent) {\n\tparent = newParent;\n    }\n",
    "107368": "    public TreeNode getParent() {\n\treturn parent;\n    }\n",
    "107373": "    public TreeNode getChildAt(int index) {\n\tif (children == null) {\n\t    throw new ArrayIndexOutOfBoundsException(\"node has no children\");\n\t}\n\treturn (TreeNode)children.elementAt(index);\n    }\n",
    "107378": "    public int getChildCount() {\n\tif (children == null) {\n\t    return 0;\n\t} else {\n\t    return children.size();\n\t}\n    }\n",
    "107383": "    public int getIndex(TreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tif (!isNodeChild(aChild)) {\n\t    return -1;\n\t}\n\treturn children.indexOf(aChild);\t// linear search\n    }\n",
    "107393": "    public Enumeration children() {\n\tif (children == null) {\n\t    return EMPTY_ENUMERATION;\n\t} else {\n\t    return children.elements();\n\t}\n    }\n",
    "107402": "    public void setAllowsChildren(boolean allows) {\n\tif (allows != allowsChildren) {\n\t    allowsChildren = allows;\n\t    if (!allowsChildren) {\n\t\tremoveAllChildren();\n\t    }\n\t}\n    }\n",
    "107413": "    public boolean getAllowsChildren() {\n\treturn allowsChildren;\n    }\n",
    "107421": "    public void setUserObject(Object userObject) {\n\tthis.userObject = userObject;\n    }\n",
    "107429": "    public Object getUserObject() {\n\treturn userObject;\n    }\n",
    "107430": "\tprivate JToggleButton getJToggleButton() {\n\t\tif (jToggleButton == null) {\n\t\t\tjToggleButton = new JToggleButton();\n\t\t\tjToggleButton.setBounds(157, 114, 101, 30);\n\t\t\tjToggleButton.setText(\"OK\");\n\t\t\tjToggleButton.addActionListener(new java.awt.event.ActionListener() { \n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {    \n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn jToggleButton;\n\t}\n",
    "107435": "\tprivate JTextArea getJTextArea1() {\n\t\tif (jTextArea1 == null) {\n\t\t\tjTextArea1 = new JTextArea();\n\t\t\tjTextArea1.setBounds(9, 163, 363, 89);\n\t\t\tjTextArea1.setWrapStyleWord(false);\n\t\t\tjTextArea1.setText(\"\");\n\t\t\tjTextArea1.setAutoscrolls(true);\n\t\t\tjTextArea1.setLineWrap(true);\n\t\t\tjTextArea1.setEnabled(false) ; \n\t\t}\n\t\treturn jTextArea1;\n\t}\n",
    "107438": "    public void removeFromParent() {\n\tMutableTreeNode parent = (MutableTreeNode)getParent();\n\tif (parent != null) {\n\t    parent.remove(this);\n\t}\n    }\n",
    "107445": "    public void remove(MutableTreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tif (!isNodeChild(aChild)) {\n\t    throw new IllegalArgumentException(\"argument is not a child\");\n\t}\n\tremove(getIndex(aChild));\t// linear search\n    }\n",
    "107453": "    public void removeAllChildren() {\n\tfor (int i = getChildCount()-1; i >= 0; i--) {\n\t    remove(i);\n\t}\n    }\n",
    "107473": "    public boolean isNodeAncestor(TreeNode anotherNode) {\n\tif (anotherNode == null) {\n\t    return false;\n\t}\n\n\tTreeNode ancestor = this;\n\n\tdo {\n\t    if (ancestor == anotherNode) {\n\t\treturn true;\n\t    }\n\t} while((ancestor = ancestor.getParent()) != null);\n\n\treturn false;\n    }\n",
    "107482": "    public boolean isNodeDescendant(DefaultMutableTreeNode anotherNode) {\n\tif (anotherNode == null)\n\t    return false;\n\n\treturn anotherNode.isNodeAncestor(this);\n    }\n",
    "107505": "    public int getDepth() {\n\tObject\tlast = null;\n\tEnumeration\t_enum = breadthFirstEnumeration();\n\t\n\twhile (_enum.hasMoreElements()) {\n\t    last = _enum.nextElement();\n\t}\n\t\n\tif (last == null) {\n\t    throw new Error (\"nodes should be null\");\n\t}\n\t\n\treturn ((DefaultMutableTreeNode)last).getLevel() - getLevel();\n    }\n",
    "107513": "    public int getLevel() {\n\tTreeNode ancestor;\n\tint levels = 0;\n\n\tancestor = this;\n\twhile((ancestor = ancestor.getParent()) != null){\n\t    levels++;\n\t}\n\n\treturn levels;\n    }\n",
    "107521": "    public TreeNode getRoot() {\n\tTreeNode ancestor = this;\n\tTreeNode previous;\n\n\tdo {\n\t    previous = ancestor;\n\t    ancestor = ancestor.getParent();\n\t} while (ancestor != null);\n\n\treturn previous;\n    }\n",
    "107530": "    public boolean isRoot() {\n\treturn getParent() == null;\n    }\n",
    "107542": "    public DefaultMutableTreeNode getNextNode() {\n\tif (getChildCount() == 0) {\n\t    // No children, so look for nextSibling\n\t    DefaultMutableTreeNode nextSibling = getNextSibling();\n\n\t    if (nextSibling == null) {\n\t\tDefaultMutableTreeNode aNode = (DefaultMutableTreeNode)getParent();\n\n\t\tdo {\n\t\t    if (aNode == null) {\n\t\t\treturn null;\n\t\t    }\n\n\t\t    nextSibling = aNode.getNextSibling();\n\t\t    if (nextSibling != null) {\n\t\t\treturn nextSibling;\n\t\t    }\n\n\t\t    aNode = (DefaultMutableTreeNode)aNode.getParent();\n\t\t} while(true);\n\t    } else {\n\t\treturn nextSibling;\n\t    }\n\t} else {\n\t    return (DefaultMutableTreeNode)getChildAt(0);\n\t}\n    }\n",
    "107555": "    public DefaultMutableTreeNode getPreviousNode() {\n\tDefaultMutableTreeNode previousSibling;\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null) {\n\t    return null;\n\t}\n\n\tpreviousSibling = getPreviousSibling();\n\n\tif (previousSibling != null) {\n\t    if (previousSibling.getChildCount() == 0)\n\t\treturn previousSibling;\n\t    else\n\t\treturn previousSibling.getLastLeaf();\n\t} else {\n\t    return myParent;\n\t}\n    }\n",
    "107560": "    public Enumeration preorderEnumeration() {\n\treturn new PreorderEnumeration(this);\n    }\n",
    "107567": "    public Enumeration postorderEnumeration() {\n\treturn new PostorderEnumeration(this);\n    }\n",
    "107575": "    public Enumeration breadthFirstEnumeration() {\n\treturn new BreadthFirstEnumeration(this);\n    }\n",
    "107579": "  public void splash(){\n    initImageAndTracker();\n    setSize(fImage.getWidth(null), fImage.getHeight(null));\n    center();\n    \n    fMediaTracker.addImage(fImage, 0);\n    try {\n      fMediaTracker.waitForID(0);\n    }\n    catch(InterruptedException ie){\n      System.out.println(\"Cannot track image load.\");\n    }\n\n    SplashWindow splashWindow = new SplashWindow(this,fImage);\n  }\n",
    "107581": "  private void center(){\n    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();\n    Rectangle frame = getBounds();\n    setLocation((screen.width - frame.width)/2, (screen.height - frame.height)/2);\n  }\n",
    "107582": "    public Enumeration depthFirstEnumeration() {\n\treturn postorderEnumeration();\n    }\n",
    "107599": "    public Enumeration pathFromAncestorEnumeration(TreeNode ancestor){\n\treturn new PathBetweenNodesEnumeration(ancestor, this);\n    }\n",
    "107611": "    public boolean isNodeChild(TreeNode aNode) {\n\tboolean retval;\n\n\tif (aNode == null) {\n\t    retval = false;\n\t} else {\n\t    if (getChildCount() == 0) {\n\t\tretval = false;\n\t    } else {\n\t\tretval = (aNode.getParent() == this);\n\t    }\n\t}\n\n\treturn retval;\n    }\n",
    "107626": "    public TreeNode getFirstChild() {\n\tif (getChildCount() == 0) {\n\t    throw new NoSuchElementException(\"node has no children\");\n\t}\n\treturn getChildAt(0);\n    }\n",
    "107640": "    public TreeNode getLastChild() {\n\tif (getChildCount() == 0) {\n\t    throw new NoSuchElementException(\"node has no children\");\n\t}\n\treturn getChildAt(getChildCount()-1);\n    }\n",
    "107648": "    public TreeNode getChildAfter(TreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tint index = getIndex(aChild);\t\t// linear search\n\n\tif (index == -1) {\n\t    throw new IllegalArgumentException(\"node is not a child\");\n\t}\n\n\tif (index < getChildCount() - 1) {\n\t    return getChildAt(index + 1);\n\t} else {\n\t    return null;\n\t}\n    }\n",
    "107658": "    public TreeNode getChildBefore(TreeNode aChild) {\n\tif (aChild == null) {\n\t    throw new IllegalArgumentException(\"argument is null\");\n\t}\n\n\tint index = getIndex(aChild);\t\t// linear search\n\n\tif (index == -1) {\n\t    throw new IllegalArgumentException(\"argument is not a child\");\n\t}\n\n\tif (index > 0) {\n\t    return getChildAt(index - 1);\n\t} else {\n\t    return null;\n\t}\n    }\n",
    "107668": "    public boolean isNodeSibling(TreeNode anotherNode) {\n\tboolean retval;\n\n\tif (anotherNode == null) {\n\t    retval = false;\n\t} else if (anotherNode == this) {\n\t    retval = true;\n\t} else {\n\t    TreeNode  myParent = getParent();\n\t    retval = (myParent != null && myParent == anotherNode.getParent());\n\n\t    if (retval && !((DefaultMutableTreeNode)getParent())\n\t\t           .isNodeChild(anotherNode)) {\n\t\tthrow new Error(\"sibling has different parent\");\n\t    }\n\t}\n\n\treturn retval;\n    }\n",
    "107693": "    public int getSiblingCount() {\n\tTreeNode myParent = getParent();\n\n\tif (myParent == null) {\n\t    return 1;\n\t} else {\n\t    return myParent.getChildCount();\n\t}\n    }\n",
    "107709": "    public DefaultMutableTreeNode getNextSibling() {\n\tDefaultMutableTreeNode retval;\n\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null) {\n\t    retval = null;\n\t} else {\n\t    retval = (DefaultMutableTreeNode)myParent.getChildAfter(this);\t// linear search\n\t}\n\n\tif (retval != null && !isNodeSibling(retval)) {\n\t    throw new Error(\"child of parent is not a sibling\");\n\t}\n\n\treturn retval;\n    }\n",
    "107721": "    public DefaultMutableTreeNode getPreviousSibling() {\n\tDefaultMutableTreeNode retval;\n\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null) {\n\t    retval = null;\n\t} else {\n\t    retval = (DefaultMutableTreeNode)myParent.getChildBefore(this);\t// linear search\n\t}\n\n\tif (retval != null && !isNodeSibling(retval)) {\n\t    throw new Error(\"child of parent is not a sibling\");\n\t}\n\n\treturn retval;\n    }\n",
    "107732": "    public boolean isLeaf() {\n\treturn (getChildCount() == 0);\n    }\n",
    "107744": "    public AdapterPanelTreeNodeImpl getFirstLeaf() {\n    \tAdapterPanelTreeNodeImpl node = this;\n\n\twhile (!node.isLeaf()) {\n\t    node = (AdapterPanelTreeNodeImpl)node.getFirstChild();\n\t}\n\n\treturn node;\n    }\n",
    "107757": "    public AdapterPanelTreeNodeImpl getLastLeaf() {\n    \tAdapterPanelTreeNodeImpl node = this;\n\n\twhile (!node.isLeaf()) {\n\t    node = (AdapterPanelTreeNodeImpl)node.getLastChild();\n\t}\n\n\treturn node;\n    }\n",
    "107773": "    public DefaultMutableTreeNode getNextLeaf() {\n\tDefaultMutableTreeNode nextSibling;\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null)\n\t    return null;\n\n\tnextSibling = getNextSibling();\t// linear search\n\n\tif (nextSibling != null)\n\t    return nextSibling.getFirstLeaf();\n\n\treturn myParent.getNextLeaf();\t// tail recursion\n    }\n",
    "107783": "    public DefaultMutableTreeNode getPreviousLeaf() {\n\tDefaultMutableTreeNode previousSibling;\n\tDefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();\n\n\tif (myParent == null)\n\t    return null;\n\n\tpreviousSibling = getPreviousSibling();\t// linear search\n\n\tif (previousSibling != null)\n\t    return previousSibling.getLastLeaf();\n\n\treturn myParent.getPreviousLeaf();\t\t// tail recursion\n    }\n",
    "107787": "    public int getLeafCount() {\n\tint count = 0;\n\n\tTreeNode node;\n\tEnumeration _enum = breadthFirstEnumeration(); // order matters not\n\n\twhile (_enum.hasMoreElements()) {\n\t    node = (TreeNode)_enum.nextElement();\n\t    if (node.isLeaf()) {\n\t\tcount++;\n\t    }\n\t}\n\n\tif (count < 1) {\n\t    throw new Error(\"tree has zero leaves\");\n\t}\n\n\treturn count;\n    }\n",
    "107791": "    public String toString() {\n\tif (userObject == null) {\n\t    return null;\n\t} else {\n\t    return userObject.toString();\n\t}\n    }\n",
    "107795": "    public Object clone() {\n    \tAdapterPanelTreeNodeImpl newNode = null;\n\n\ttry {\n\t    newNode = (AdapterPanelTreeNodeImpl)super.clone();\n\n\t    // shallow copy -- the new node has no parent or children\n\t    newNode.children = null;\n\t    newNode.parent = null;\n\n\t} catch (CloneNotSupportedException e) {\n\t    // Won't happen because we implement Cloneable\n\t    throw new Error(e.toString());\n\t}\n\n\treturn newNode;\n    }\n",
    "108139": "    public RowSpec getLineGapSpec() {\n        return lineGapSpec;\n    }\n",
    "108143": "    public void setLineGapSize(ConstantSize lineGapSize) {\n        RowSpec rowSpec = FormFactory.createGapRowSpec(lineGapSize);\n        this.lineGapSpec = rowSpec;\n    }\n",
    "108145": "    public void setParagraphGapSize(ConstantSize paragraphGapSize) {\n        RowSpec rowSpec = FormFactory.createGapRowSpec(paragraphGapSize);\n        this.paragraphGapSpec = rowSpec;\n    }\n",
    "108149": "    public int getLeadingColumnOffset() {\n        return leadingColumnOffset;\n    }\n",
    "108152": "    public void setLeadingColumnOffset(int columnOffset) {\n        this.leadingColumnOffset = columnOffset;\n    }\n",
    "108155": "    public boolean isRowGroupingEnabled() {\n        return rowGroupingEnabled;\n    }\n",
    "108156": "    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {\n        JLabel label = append(textWithMnemonic);\n        label.setLabelFor(c);\n        iniPersitentLabel (label, c);\n        append(c, columnSpan);\n        return label;\n    }\n",
    "108158": "    public void setRowGroupingEnabled(boolean enabled) {\n        rowGroupingEnabled = enabled;\n    }\n",
    "108161": "    public void append(Component component) {\n        append(component, 1);\n    }\n",
    "108165": "    public void append(Component component, int columnSpan) {\n        ensureCursorColumnInGrid();\n        ensureHasGapRow(lineGapSpec);\n        ensureHasComponentLine();\n        \n        add(component, createLeftAdjustedConstraints(columnSpan));\n        nextColumn(columnSpan + 1);\n    }\n",
    "108168": "    public void append(Component c1, Component c2) {\n        append(c1);\n        append(c2);\n    }\n",
    "108171": "    public void append(Component c1, Component c2, Component c3) {\n        append(c1);\n        append(c2);\n        append(c3);\n    }\n",
    "108173": "    public JLabel append(String textWithMnemonic) {\n        JLabel label = getComponentFactory().createLabel(textWithMnemonic);\n        append(label);\n        return label;\n    }\n",
    "108176": "    public JLabel append(String textWithMnemonic, Component component) {\n        return append(textWithMnemonic, component, 1);\n    }\n",
    "108178": "    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {\n        JLabel label = append(textWithMnemonic);\n        label.setLabelFor(c);\n        append(c, columnSpan);\n        return label;\n    }\n",
    "108181": "    public JLabel append(String textWithMnemonic, Component c1, Component c2) {\n        JLabel label = append(textWithMnemonic, c1);\n        append(c2);\n        return label;\n    }\n",
    "108184": "    public void append(String textWithMnemonic, Component c1, Component c2, int colSpan) {\n        append(textWithMnemonic, c1);\n        append(c2, colSpan);\n    }\n",
    "108186": "    public JLabel append(String textWithMnemonic, Component c1, Component c2, Component c3) {\n        JLabel label = append(textWithMnemonic, c1, c2);\n        append(c3);\n        return label;\n    }\n",
    "108190": "    public JLabel append(String textWithMnemonic, Component c1, Component c2, Component c3, Component c4) {\n        JLabel label = append(textWithMnemonic, c1, c2, c3);\n        append(c4);\n        return label;\n    }\n",
    "108194": "    public JLabel appendI15d(String resourceKey) {\n        return append(getI15dString(resourceKey));\n    }\n",
    "108207": "    public JLabel appendI15d(String resourceKey, Component component) {\n        return appendI15d(resourceKey, component, 1);\n    }\n",
    "108212": "    public JLabel appendI15d(String resourceKey, Component component, boolean nextLine) {\n        JLabel label = appendI15d(resourceKey, component, 1);\n        if (nextLine) {\n            nextLine();\n        }\n        return label;\n    }\n",
    "108221": "    public JLabel appendI15d(String resourceKey, Component c1, Component c2, Component c3, Component c4) {\n        JLabel label = appendI15d(resourceKey, c1, c2, c3);\n        append(c4);\n        return label;\n    }\n",
    "108223": "    public JLabel appendTitle(String textWithMnemonic) {\n        JLabel titleLabel = getComponentFactory().createTitle(textWithMnemonic);\n        append(titleLabel);\n        return titleLabel;\n    }\n",
    "108225": "    public JLabel appendI15dTitle(String resourceKey) {\n        return appendTitle(getI15dString(resourceKey));\n    }\n",
    "108227": "    public JComponent appendSeparator() {\n        return appendSeparator(\"\");\n    }\n",
    "108231": "    public JComponent appendSeparator(String text) {\n        ensureCursorColumnInGrid();\n        ensureHasGapRow(paragraphGapSpec);\n        ensureHasComponentLine();\n        \n        setColumn(super.getLeadingColumn());\n        int columnSpan = getColumnCount();\n        setColumnSpan(getColumnCount());\n        JComponent titledSeparator = addSeparator(text);\n        setColumnSpan(1);\n        nextColumn(columnSpan);\n        return titledSeparator;\n    }\n",
    "108233": "    public void appendI15dSeparator(String resourceKey) {\n        appendSeparator(getI15dString(resourceKey));\n    }\n",
    "108235": "    protected int getLeadingColumn() {\n        int column = super.getLeadingColumn();\n        return column + getLeadingColumnOffset() * getColumnIncrementSign();\n    }\n",
    "108237": "    private void ensureCursorColumnInGrid() {\n        if (   ( isLeftToRight() && (getColumn() > getColumnCount()))\n            || (!isLeftToRight() && (getColumn() < 1))) {\n            nextLine();\n        }\n    }\n",
    "108239": "    private void ensureHasGapRow(RowSpec gapRowSpec) {\n        if ((getRow() == 1) || (getRow() <= getRowCount()))\n            return;\n        \n        if (getRow() <= getRowCount()) {\n            RowSpec rowSpec = getCursorRowSpec();\n            if ((rowSpec == gapRowSpec))\n                return;\n        }\n        appendRow(gapRowSpec);\n        nextLine();\n    }\n",
    "108242": "    private void ensureHasComponentLine() {\n        if (getRow() <= getRowCount()) return;\n        appendRow(FormFactory.PREF_ROWSPEC);  \n        if (isRowGroupingEnabled()) {\n            getLayout().addGroupedRow(getRow());\n        }      \n    }\n",
    "108244": "    private RowSpec getCursorRowSpec() {\n        return getLayout().getRowSpec(getRow());\n    }\n",
    "108246": "\tpublic JComponent appendGradientLabel(String text) {\n\t\treturn appendSeparator(text);\n\t\t\n\t}\n",
    "108294": "        public void setVariables(List<TridasVariable> variables) {\n            this.variables = variables;\n        }\n",
    "108525": "    public static boolean supportsBoundProperties(Class clazz) {\n        return  (getPCLAdder(clazz)   != null) \n             && (getPCLRemover(clazz) != null);\n    }\n",
    "109107": "    public JLabel append(String textWithMnemonic, Component c, int columnSpan) {\n    \tthis.lastAdapter = FactoryWidget.getFactory().getLastAdapter();\n        JLabel label = append(textWithMnemonic);\n        label.setLabelFor(c);\n        iniPersitentLabel (label, c);\n        append(c, columnSpan);\n        return label;\n    }\n",
    "109201": "\tpublic JComponent appendGradientLabel(String text) {\n\t\tJComponent result = appendSeparator(text);\n\t\tif (result instanceof Container) {\n\t\t\tContainer c = (Container) result;\n\t\t\tfor (int i = 0; i < c.getComponentCount(); i++) {\n\t\t\t\tif (c.getComponent(i) instanceof JLabel) {\n\t\t\t\t\tJLabel label = (JLabel) c.getComponent(i);\n\t\t\t\t\tlabel.setForeground(new java.awt.Color(10, 96, 43));\n\t\t\t\t\tlabel.setFont(label.getFont().deriveFont(16.0f));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "110585": "\tpublic ResourceBundle getResourceBundle() {\n\t\treturn resourceBundle;\n\t}\n",
    "110970": "    public void applyEditorValue() {\n        setVisible(true);\n        redraw();\n//        StructuredSelection sel = (StructuredSelection) tableViewer.getSelection();\n        //        setSelection(tableViewerExample\n        //                .getRowIndex((HashMap) sel.getFirstElement()),\n        // getColumn());\n        TreeItem currentRow = getRow();\n        if (currentRow != null && !currentRow.isDisposed()) {\n            tableViewer.setSelection(new StructuredSelection(getRowAsElement()), true);\n        }\n        currentRow = getRow();\n        if (currentRow != null && !currentRow.isDisposed()) {\n            // set selection of table separatly; viewer does incorrectly.\n            ((Tree) getParent()).setSelection(new TreeItem[] { currentRow });\n        }\n    }\n",
    "110974": "    public void cancelEditor() {\n        setVisible(true);\n    }\n",
    "110983": "    protected void handleDoubleClick() {\n        activateEditor();\n    }\n",
    "111034": "    public void addSelectionListener(SelectionListener listener) {\n        checkWidget();\n        if (listener == null)\n            SWT.error(SWT.ERROR_NULL_ARGUMENT);\n        TypedListener typedListener = new TypedListener(listener);\n        addListener(SWT.Selection, typedListener);\n        addListener(SWT.DefaultSelection, typedListener);\n    }\n",
    "111068": "    public void add(IFigure figure) {\n        if (figure instanceof Connection) {\n            connections.add((Connection) figure);\n        } else {\n            children.add(figure);\n        }\n    }\n",
    "111090": "\tprotected int endOfLineOf(int offset) throws BadLocationException {\n\n\t\tIRegion info = fDocument.getLineInformationOfOffset(offset);\n\t\tif (offset <= info.getOffset() + info.getLength())\n\t\t\treturn info.getOffset() + info.getLength();\n\n\t\tint line = fDocument.getLineOfOffset(offset);\n\t\ttry {\n\t\t\tinfo = fDocument.getLineInformation(line + 1);\n\t\t\treturn info.getOffset() + info.getLength();\n\t\t} catch (BadLocationException x) {\n\t\t\treturn fDocument.getLength();\n\t\t}\n\t}\n",
    "111140": "    public void removeSelectionListener(SelectionListener listener) {\n        checkWidget();\n        if (listener == null) {\n            SWT.error(SWT.ERROR_NULL_ARGUMENT);\n        }\n        removeListener(SWT.Selection, listener);\n        removeListener(SWT.DefaultSelection, listener);\n    }\n",
    "111158": "    public int getColumn() {\n        checkWidget();\n        return column == null ? 0 : table.indexOf(column);\n    }\n",
    "111164": "    public TreeItem getRow() {\n        checkWidget();\n        return row;\n    }\n",
    "111307": "\tpublic void addModuleData(String iModuleName, CheckoutModuleData iCheckoutModuleData) {\n\t\tcheckoutModuleDataMap.put(iModuleName, iCheckoutModuleData);\n\t}\n",
    "111311": "\tpublic void removeModuleData(String iModuleName) {\n\t\tcheckoutModuleDataMap.remove(iModuleName);\n\t}\n",
    "111347": "\tpublic boolean isCorrect() {\n\n\t\tIterator moduleDataIterator = checkoutModuleDataMap.values().iterator();\n\t\twhile (moduleDataIterator.hasNext()) {\n\t\t\tCheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();\n\t\t\tif (!lCheckoutModuleData.isCorrect()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "111351": "\tpublic void setFieldstoUnverified() {\n\t\tIterator moduleDataIterator = checkoutModuleDataMap.values().iterator();\n\t\twhile (moduleDataIterator.hasNext()) {\n\t\t\tCheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();\n\t\t\tlCheckoutModuleData.setFieldstoUnverified();\n\t\t}\n\t}\n",
    "111355": "\tpublic int getMaxStep() {\n\t\tint currentMaxStep;\n\t\tint res = 0;\n\t\tIterator moduleDataIterator = checkoutModuleDataMap.values().iterator();\n\t\twhile (moduleDataIterator.hasNext()) {\n\t\t\tCheckoutModuleData lCheckoutModuleData = (CheckoutModuleData) moduleDataIterator.next();\n\t\t\tcurrentMaxStep = lCheckoutModuleData.getMaxStep();\n\t\t\tif (currentMaxStep >= res) {\n\t\t\t\tres = currentMaxStep;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n",
    "111357": "\tpublic CheckoutModuleData getModuleData(String iKey) {\n\t\treturn (CheckoutModuleData) checkoutModuleDataMap.get(iKey);\n\t}\n",
    "111361": "\tpublic Iterator getModulesIterator() {\n\t\tif (checkoutModuleMap != null) {\n\t\t\treturn checkoutModuleMap.values().iterator();\n\t\t} else {\n\t\t\treturn (Iterator) null;\n\t\t}\n\t}\n",
    "111367": "\tpublic void addInitError(Map iMap) {\n\t\tinitErrors.add(iMap);\n\t}\n",
    "111371": "\tpublic void clearInitErrors() {\n\t\tinitErrors.clear();\n\t}\n",
    "111373": "\tpublic void setLabel(Locale iLocale, String iString) {\n\t\tthis.labelMap.remove(iLocale);\n\t\tthis.labelMap.put(iLocale, iString);\n\t}\n",
    "111376": "\tpublic boolean isInitialized() {\n\t\treturn ((initErrors == null) || (initErrors.size() == 0));\n\t}\n",
    "111378": "\tpublic String getLabel(Locale iLocale) {\n\t\tif (this.labelMap != null) return (String) this.labelMap.get(iLocale.getLanguage());\n\t\telse return null;\n\t}\n",
    "111385": "\tpublic void setAskedStep(int iStep) {\n\t\tthis.askedStep = iStep;\n\t}\n",
    "111386": "\tpublic void setMessage(Map iMap) {\n\t\tmessageMap = iMap;\n\t}\n",
    "111387": "\tpublic int getAskedStep() {\n\t\treturn this.askedStep;\n\t}\n",
    "111389": "\tpublic String getMessage(Locale iLocale) {\n\t\treturn (String) this.messageMap.get(iLocale);\n\t}\n",
    "111390": "\tpublic void setExternalPayment(String iExternalPayment) {\n\t\texternalPayment = iExternalPayment;\n\t}\n",
    "111392": "\tpublic String getExternalPayment() {\n\t\treturn externalPayment;\n\t}\n",
    "111395": "\tpublic void setOrderLogStatus(String iLog) {\n\t\torderLogStatus = iLog;\n\t}\n",
    "111396": "\tpublic void setStatus(Integer iStatus) {\n\t\tstatus = iStatus;\n\t}\n",
    "111398": "\tpublic void unsetOrderLogStatus() {\n\t\torderLogStatus = null;\n\t}\n",
    "111399": "\tpublic Integer getStatus() {\n\t\treturn status;\n\t}\n",
    "111400": "\tpublic String getOrderLogStatus() {\n\t\treturn orderLogStatus;\n\t}\n",
    "111402": "\tpublic void setType(String iType) {\n\t\tif (\"group\".equals(this.type)){\n\t\t\tfor (int i = 0; i < group.size(); i++) {\n\t\t\t\tCheckoutModuleDataField lCheckoutDataField = (CheckoutModuleDataField) group.get(i);\n\t\t\t\tlCheckoutDataField.setType(iType);\n\t\t\t}\n\t\t} else {\n\t\t\ttype = iType;\n\t\t}\n\n\t}\n",
    "111403": "\tpublic void setOrderNumber(Integer iOrderNumber) {\n\t\torderNumber = iOrderNumber;\n\t}\n",
    "111406": "\tpublic Integer getOrderNumber() {\n\t\treturn orderNumber;\n\t}\n",
    "111431": "\tpublic String toString(StringBuffer uStringBuffer) {\n\t\tuStringBuffer.setLength(0);\n\t\tuStringBuffer.append(humanReadableKey);\n\t\tuStringBuffer.append('.');\n\t\tuStringBuffer.append(representationSecurityLevel);\n\t\tuStringBuffer.append('.');\n\t\tuStringBuffer.append(getData());\n\t\tuStringBuffer.append('.');\n\t\tuStringBuffer.append(comesFromSession);\n\t\treturn uStringBuffer.toString();\n\t}\n",
    "111456": "\tpublic Viewer getDocumentViewer(DocumentData ioDocumentData) {\n\t\tThingDocumentData lThingDocumentData = (ThingDocumentData) ioDocumentData;\n\t\tViewer lViewer = null;\n\t\tif (lThingDocumentData.isEditable()) {\n\t\t\tlViewer = new ThingDocumentViewer(lThingDocumentData, this, this);\n\t\t}\n\t\treturn lViewer;\n\t}\n",
    "111462": "\tpublic String getOntologyName() {\n\t\treturn \"thing\";\n\t}\n",
    "111468": "\tpublic Object getData(Viewer iViewer, Connection ioConnection, StringBuffer uStringBuffer) throws SQLException {\n\t\treturn null;\n\t}\n",
    "111500": "\tpublic void init() throws ServletException {\n\t\tServletConfig lServletConfig = getServletConfig();\n\t\tfor (Enumeration lEnum = lServletConfig.getInitParameterNames();lEnum.hasMoreElements();) {\n\t\t\t//System.out.println(lEnum);\n\t\t\tString ltmpStringjs = (String) lEnum.nextElement();\n\t\t\t//test if ltmpStringjs begins with javascript.xxx\n\t\t\tif (ltmpStringjs.startsWith(\"javascript.\")){\n\t\t\t\tString ltmpStringjsvalue = lServletConfig.getInitParameter(ltmpStringjs);\n\t\t\t\t//convert ltmpStringjs javascript.value in value\n\t\t\t\tltmpStringjs = ltmpStringjs.replaceAll(\"javascript.\",\"\");\n\t\t\t\t//add to jsMap\n\t\t\t\tjsMap.put(ltmpStringjs,ltmpStringjsvalue);\n\t\t\t}\n\t\t}\n\t}\n",
    "111537": "\tpublic String setInvoiceHeader() {\n\n\t\tString invoiceHeader = \t\"Distribution Fusion 3 inc.\\n\" +\n\t\t\t\t\t\t\t\t\"Electronic Trading System\\n\\n\" +\n\t\t\t\t\t\t\t\t\"Invoice no.: \\n\" +\n\t\t\t\t\t\t\t\t\"Date : \" + today +\n\t\t\t\t\t\t\t\t\"\\n\\nTrading partner : \" + \"HMV North America\" +\n\t\t\t\t\t\t\t\t\"reference : \" +\n\t\t\t\t\t\t\t\t\"Content type :   EDI\\n\\n\";\n\n\t\treturn invoiceHeader;\n\t}\n",
    "111728": "\tpublic Collection getPurchaseOrderItemRelations()  {\n\t\treturn purchaseOrderItemRelations;\n\t}\n",
    "111967": "    static public Object convert(String dataislandPrimitiveName, Object value) {\n        return convert(dataislandPrimitiveName, value, null);\n    }\n",
    "112013": "    static public void localize(Collection localizableObjectCollection, org.dataisland.primitives.bean.LocalizationContext localizationContext) throws LocalizationException {\n        for (Iterator i = localizableObjectCollection.iterator(); i.hasNext();) {\n            Object lCurrentObject = i.next();\n\n            if (lCurrentObject instanceof Collection) {\n                localize((Collection) lCurrentObject, localizationContext);\n            } else if (lCurrentObject instanceof org.dataisland.primitives.bean.Localizable) {\n                localize((org.dataisland.primitives.bean.Localizable) lCurrentObject, localizationContext);\n            }\n        }\n    }\n",
    "112042": "    public int compareTo(Object o) {\n        if (!(o instanceof Datatype)) {\n            throw new IllegalArgumentException(\"The object to be compared must be a Datatype object\");\n        }\n        return -1;\n    }\n",
    "112048": "    public int compareTo(Object o) {\n    \t\tif (!(o instanceof Money)) {\n            throw new IllegalArgumentException(\"The object to be compared must be a Money object\");\n        }\n        \n        Money obj = (Money) o;\n        \n        if (amount != null) {\n            return amount.compareTo(obj.getAmount());\n        }\n\n        return -1;\n            \n    }\n",
    "112082": "\tpublic DataIsland getDataIsland() {\n\t\treturn dataIsland;\n\t}\n",
    "112083": "\tpublic Object getData() {\n\t\treturn data;\n\t}\n",
    "112084": "\tpublic void setDocumentType(DocumentType iDocumentType) {\n\t\tthis.documentType = iDocumentType;\n\t\tstring = null;\n\t}\n",
    "112085": "\tpublic Date getLastModified() {\n\t\treturn lastModified;\n\t}\n",
    "112088": "\tpublic DocumentType getDocumentType() {\n\t\treturn documentType;\n\t}\n",
    "112089": "\tpublic View getView() {\n\t\treturn view;\n\t}\n",
    "112091": "\tpublic Locale getLocale() {\n\t\tView view = getView();\n\t\tif(view == null) return null;\n\t\treturn view.getLocale();\n\t}\n",
    "112093": "\tpublic void setLocale(Locale iLocale) {\n\t\tthis.locale = iLocale;\n\t\tstring = null;\n\t}\n",
    "112094": "\tpublic DocumentType getDocumentType() {\n\t\tView view = getView();\n\t\tif(view == null) return null;\n\t\treturn view.getDocumentType();\n\t}\n",
    "112095": "\tpublic void setDataIsland(DataIsland iDataIsland) {\n\t\tdataIsland = iDataIsland;\n\t}\n",
    "112097": "\tpublic void setData(Object iData) {\n\t\tdata = iData;\n\t}\n",
    "112098": "\tpublic Locale getLocale() {\n\t\treturn locale;\n\t}\n",
    "112099": "\tpublic void setLastModified(Date iLastModified) {\n\t\tif(iLastModified == null) throw new IllegalArgumentException(\"The last changed date object cannot be null\");\n\t\tlastModified = iLastModified;\n\t}\n",
    "112100": "\tpublic void setKey(String iKey) {\n\t\tkey = iKey;\n\t}\n",
    "112101": "\tpublic void setMode(String iMode) {\n\t\tthis.mode = iMode;\n\t\tstring = null;\n\t}\n",
    "112103": "\tpublic void setView(View iView) {\n\t\tif(iView == null) throw new IllegalArgumentException(\"The view object cannot be null\");\n\t\t//else if(iView.getLocale() == null) throw new IllegalArgumentException(\"The view's locale cannot be null\");\n\t\telse if(iView.getDocumentType() == null) throw new IllegalArgumentException(\"The view's document type cannot be null\");\n\t\tview = iView;\n\t}\n",
    "112105": "\tpublic String getMode() {\n\t\treturn mode;\n\t}\n",
    "112112": "\tpublic String toString() {\n\t\tif(string == null) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tif(locale != null) sb.append(locale).append('.');\n\t\t\tsb.append(documentType);\n\t\t\tstring = sb.toString();\n\t\t}\n\t\treturn string;\n\t}\n",
    "112119": "\tpublic boolean equals(Object obj) {\n\t\tif(obj instanceof View)  {\n\t\t\tView view = (View) obj;\n\t\t\tif(Misc.match(view.documentType, this.documentType) && Misc.match(view.locale, this.locale))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "112125": "\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n",
    "112148": "\tstatic public View getXMLView(Locale locale) {\n\t\treturn new View(DocumentType.XML, locale);\n\t}\n",
    "112161": "\tstatic public List getLocales(List iViews) {\n\t\tif(iViews == null) return null;\n\t\tVector locales = new Vector();\n\t\tIterator viewIterator = iViews.iterator();\n\t\twhile(viewIterator.hasNext()) {\n\t\t\tView view = (View) viewIterator.next();\n\t\t\tif(!locales.contains(view.getLocale())) locales.add(view.getLocale());\n\t\t}\n\t\tif(locales.size() == 0) locales = null;\n\t\treturn locales;\n\t}\n",
    "112222": "\tprivate void init(Writer oWriter) {\n\t\tif(oWriter == null) throw new IllegalArgumentException(\"The writer cannot be null\");\n\t\tsetOutput(oWriter);\n\t}\n",
    "112223": "\tstatic public boolean match(Object o1, Object o2) {\n\t\tif(o1 == null) {\n\t\t\tif(o2 == null) return true;\n\t\t} else if(o2 != null) {\n\t\t\tif(o1.equals(o2)) return true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "112224": "\tprivate void reset() {\n\t\toutput = null;\n\t\tprefixTable.clear();\n\t\tforcedDeclTable.clear();\n\t\tdoneDeclTable.clear();\n\t\telementLevel = 0;\n\t\tnsSupport.reset();\n\t\tprefixCounter = 0;\n\t}\n",
    "112227": "    public String getQuery() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tString result = getQuery(sb);\n\t\tsb.setLength(0);\n\t\treturn result;\n    }\n",
    "112228": "\tpublic void setOutput(Writer oWriter) {\n\t\toutput = oWriter;\n\t}\n",
    "112236": "\tpublic void init(Map iParameters) {\n\t}\n",
    "112249": "\tpublic IncluderContext getIncluderContext(ServletContext ioServletContext) {\n\t\tIncluderContext lIncluderContext = null;\n\t\tsynchronized(INCLUDER_CONTEXT_KEY) {\n\t\t\tlIncluderContext = (IncluderContext) ioServletContext.getAttribute(INCLUDER_CONTEXT_KEY);\n\t\t\tif(lIncluderContext == null) {\n\t\t\t\tlIncluderContext = new IncluderContext();\n\t\t\t\tlIncluderContext.init(ioServletContext.getRealPath(\"/WEB-INF/includes\"));\n\t\t\t\tioServletContext.setAttribute(INCLUDER_CONTEXT_KEY, lIncluderContext);\n\t\t\t}\n\t\t}\n\t\treturn lIncluderContext;\n\t}\n",
    "112269": "\tpublic ContentHandler getContentHandler() {\n\t\tif(this.ch == null && this.os != null) {\n\t\t\tString lMIMEType = getMIMEDocumentType();\n\t\t\tif(lMIMEType != null) setContentHandler(ApacheSerializer.getContentHandler(lMIMEType, this.os));\n\t\t}\n\t\treturn this.ch;\n\t}\n",
    "112277": "\tpublic View getBestView(Vector iViews) {\n\t\treturn View.getBestView(getPreferredDocumentTypes(), getPreferredLocales(), iViews);\n\t}\n",
    "112278": "\tpublic Locale getBestLocale(List iLocales) {\n\t\treturn Misc.getBestLocale(getPreferredLocales(), iLocales);\n\t}\n",
    "112282": "\tpublic ContentHandler getContentHandler() {\n\t\treturn this.ch;\n\t}\n",
    "112299": "\tstatic public void removeReservedParameter(String iParameterName) {\n\t\treservedParameter.remove(iParameterName);\n\t}\n",
    "112304": "\tpublic void setName(String iName) {\n\t\tthis.name = iName;\n\t}\n",
    "112308": "\tpublic boolean equals(Object iO) {\n\t\t if (iO != null) {\n\t\t \tDocumentType documentType = (DocumentType) iO;\n\t\t \tif(documentType.name == null) {\n\t\t \t\tif(name == null) return true;\n\t\t \t} else if(name == null) {\n\t\t \t\tif(documentType.name == null) return true;\n\t\t \t} else if(name.equals(documentType.name)) return true;\n\t\t }\n\t\t return false;\n\t}\n",
    "112309": "\tpublic String toString() {\n\t\treturn getName();\n\t}\n",
    "112330": "\tpublic File getRepositoryDirectory() {\n\t\treturn repositoryDirectory;\n\t}\n",
    "112336": "\tpublic void setRepositoryDirectory(File iRepositoryDirectory) {\n\t\tif(iRepositoryDirectory != null && iRepositoryDirectory.isDirectory() && iRepositoryDirectory.canRead()) {\n\t\t\tthis.repositoryDirectory = iRepositoryDirectory;\n\t\t\tthis.stylesheets = null;\n\t\t} else this.repositoryDirectory = null;\n\t\trefreshStylesheets();\n\t}\n",
    "112338": "\tpublic File getResolverRepositoryDirectory() {\n\t\treturn resolverRepositoryDirectory;\n\t}\n",
    "112339": "\tpublic void setRepositoryDirectory(File repositoryDirectory) {\n\t\tif(repositoryDirectory != null && (repositoryDirectory.isDirectory() || repositoryDirectory.mkdirs()) && repositoryDirectory.canRead()) {\n\t\t\ttry {\n\t\t\t\tthis.repositoryDirectory = repositoryDirectory.getCanonicalFile();\n\t\t\t\tclear();\n\t\t\t} catch(IOException ioe) {\n\t\t\t\tclear();\n\t\t\t\tthis.repositoryDirectory = null;\n\t\t\t}\n\t\t} else {\n\t\t\tclear();\n\t\t\tthis.repositoryDirectory = null;\n\t\t}\n\t}\n",
    "112342": "\tpublic void setResolverRepositoryDirectory(File iResolverRepositoryDirectory) {\n\t\tif(iResolverRepositoryDirectory != null && iResolverRepositoryDirectory.isDirectory() && iResolverRepositoryDirectory.canRead()) {\n\t\t\tthis.resolverRepositoryDirectory = iResolverRepositoryDirectory;\n\t\t\tif(transformerURIResolver == null) transformerURIResolver = new TransformerURIResolver();\n\t\t\ttry {\n\t\t\t\ttransformerURIResolver.setRootDirectory(resolverRepositoryDirectory);\n\t\t\t} catch (IOException lIOException) {\n\t\t\t\tRuntimeException lRuntimeException = new RuntimeException(\"Bad transformer resolver repository directory :\\n\" + this.resolverRepositoryDirectory.getAbsolutePath() + \"\\n\" + lIOException.getMessage(), lIOException);\n\t\t\t\tthrow lRuntimeException;\n\t\t\t}\n\t\t} else this.resolverRepositoryDirectory = null;\n\t\trefreshStylesheets();\n\t}\n",
    "112492": "    static public void parseQueryParameters(String query, Map parameters) {\n\t\tStringTokenizer st = new StringTokenizer(query, \"&\");\n\t\tString key, value, pair;\n\t\twhile(st.hasMoreTokens()) {\n\t\t    pair = (String)st.nextToken();\n\t\t    int pos = pair.indexOf('=');\n\t\t    if (pos != -1) {\n\t\t\t\tkey = pair.substring(0, pos);\n\t\t\t\tvalue = pair.substring(pos+1, pair.length());\n\t\t\t\tparameters.put(key, value);\n\t\t    } else parameters.put(pair, null);\n\t\t}\n    }\n",
    "113156": "    public Group saveGroup(Group group) throws DataIslandCMSException {\n        if (\"\".equals(group.getId())) group.setId(null);\n\n        try {\n\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Process persistance (create : if no persisted object previously existed, update otherwise)\n                // Schedule the value object for persistence\n                session.saveOrUpdate(group);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n\n\n        return group;\n    }\n",
    "113160": "    public List fetchGroupList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {\n        List groups = null;\n        // Initialize the hibernate session\n        Session session = currentSession();\n\n        try {\n            // Fetch session from hibernate\n            groups = session.createCriteria(Group.class).list();\n            LocalizationUtils.localize(groups, localizationContext);\n        } catch (Exception e) {\n            throw new DataIslandCMSException(e);\n        } finally {\n            // Close the hibernate session\n            closeSession();\n        }\n        return groups;\n    }\n",
    "113162": "    public void deleteGroup(Group group) throws DataIslandCMSException {\n        try {\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Schedule for deletion\n                session.delete(group);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n    }\n",
    "113171": "    public Role saveRole(Role role) throws DataIslandCMSException {\n        if (\"\".equals(role.getId())) role.setId(null);\n\n        try {\n\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n\n                // Schedule the value object for persistence\n                session.saveOrUpdate(role);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n\n\n        return role;\n    }\n",
    "113174": "    public List fetchRoleList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {\n        List roles = null;\n        // Initialize the hibernate session\n        Session session = currentSession();\n\n        try {\n            // Fetch session from hibernate\n            roles = session.createCriteria(Role.class).list();\n            LocalizationUtils.localize(roles, localizationContext);\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        } finally {\n            // Close the hibernate session\n            closeSession();\n        }\n        return roles;\n    }\n",
    "113176": "    public void deleteRole(Role role) throws DataIslandCMSException {\n        try {\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Schedule for deletion\n                session.delete(role);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n    }\n",
    "113185": "    public List fetchUserList(LocalizationContext localizationContext) throws DataIslandCMSException, LocalizationException {\n        List users = null;\n        // Initialize the hibernate session\n        Session session = currentSession();\n\n        try {\n            // Fetch session from hibernate\n            users = session.createCriteria(User.class).list();\n            LocalizationUtils.localize(users, localizationContext);\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        } finally {\n            // Close the hibernate session\n            closeSession();\n        }\n        return users;\n    }\n",
    "113188": "    public void deleteUser(org.dataisland.cms.bean.User user) throws DataIslandCMSException {\n        try {\n            // Initialize the hibernate session\n            Session session = currentSession();\n            // Start an hibernate transaction\n            Transaction tx = session.beginTransaction();\n\n            try {\n                // Schedule for deletion\n                session.delete(user);\n\n                // Commit hibernate transaction\n                tx.commit();\n            } catch (HibernateException he) {\n                tx.rollback();\n                throw new DataIslandCMSException(he);\n            } finally {\n                // Close the hibernate session\n                closeSession();\n            }\n\n        } catch (HibernateException he) {\n            throw new DataIslandCMSException(he);\n        }\n    }\n",
    "113197": "    public Object unmarshal(Object obj, IUnmarshallingContext uctx) throws JiBXException {\n\n        // make sure we're at the appropriate start tag\n        UnmarshallingContext ctx = (UnmarshallingContext)uctx;\n        \n        if (!ctx.isAt(m_uri, m_name)) {\n            ctx.throwStartTagNameError(m_uri, m_name);\n        }\n\n        String refid = ctx.attributeText(m_uri, REFID_ATTRIBUTE_NAME);\n\n        ctx.parsePastEndTag(m_uri, m_name);\n\n        return ctx.findDefinedID(refid, m_index);\n    }\n",
    "113217": "    static public Role loadFormIntoRole(ActionForm actionForm, HttpServletRequest httpServletRequest) throws LocalizationException {\n        Role role = new Role();\n        LocalizationUtils.localize(role, StrutsLocalizationUtils.getCompositeLocalizationContext(httpServletRequest, WEB_CONTEXT_LOCALIZATION_CONTEXT_KEY));\n        DynaValidatorForm roleForm = (DynaValidatorForm) actionForm;\n        role.setId((String) roleForm.get(\"id\"));\n        role.setHumanReadableKey((String) roleForm.get(\"humanReadableKey\"));\n        role.setName((String) roleForm.get(\"name\"));\n        role.setDescriptions(LocalizationUtils.getLocaleKeyedMap((SortedMap) roleForm.get(\"description\")));\n        return role;\n    }\n",
    "113226": "    static public void populate(ActionForm actionForm, org.dataisland.cms.bean.Group group) {\n        DynaValidatorForm groupDeleteForm = (DynaValidatorForm) actionForm;\n        groupDeleteForm.set(\"id\", group.getId());\n        groupDeleteForm.set(\"name\", group.getName());\n    }\n",
    "113229": "    static public void populate(ActionForm actionForm, Role role) throws LocalizationException {\n        DynaValidatorForm roleDeleteForm = (DynaValidatorForm) actionForm;\n        roleDeleteForm.set(\"id\", role.getId());\n        roleDeleteForm.set(\"name\", role.getName());\n    }\n",
    "113262": "    static public void populate(ActionForm actionForm, org.dataisland.cms.bean.User user) {\n        DynaValidatorForm userDeleteForm = (DynaValidatorForm) actionForm;\n        userDeleteForm.set(\"id\", user.getId());\n        userDeleteForm.set(\"name\", user.getName());\n    }\n",
    "113265": "    static public Set getRolesFromIdArray(String[] roleIds, HttpServletRequest httpServletRequest) throws DataIslandCMSException, LocalizationException {\n        Set roles = new HashSet();\n\n        for (int i = 0; i < roleIds.length; i++) {\n            try {\n                roles.add(RolePersistenceFacade.getInstance().fetchRole(roleIds[i], StrutsLocalizationUtils.getCompositeLocalizationContext(httpServletRequest, WEB_CONTEXT_LOCALIZATION_CONTEXT_KEY)));\n            } catch (org.dataisland.cms.exception.RoleNotFoundException rnfe) {\n                throw new DataIslandCMSException(\"The role to be linked to the group does not exist.\", rnfe);\n            }\n        }\n        return roles;\n    }\n",
    "113292": "    public void setId(String id) {\n        this.id = id;\n    }\n",
    "113294": "    public void setPassword(String password) {\n        this.password = password;\n    }\n",
    "113296": "    public String getLogin() {\n        return login;\n    }\n",
    "113297": "    public void setLogin(String login) {\n        this.login = login;\n    }\n",
    "113301": "    public Group getGroup() {\n        return group;\n    }\n",
    "113303": "    public void setGroup(Group group) {\n        this.group = group;\n    }\n",
    "113305": "    public String getEmail() {\n        return email;\n    }\n",
    "113307": "    public void setEmail(String email) {\n        this.email = email;\n    }\n",
    "113308": "    public boolean isSystem() {\n        return system;\n    }\n",
    "113309": "    public void setSystem(boolean system) {\n        this.system = system;\n    }\n",
    "113310": "    static public ContextStack getContextStack(String contextStackKey, HttpServletRequest httpServletRequest) {\n        //Get Context Stack\n        String contextStackIdString = httpServletRequest.getParameter(contextStackKey);\n        String contextStackId = (String) ConvertUtils.convert(contextStackIdString, String.class);\n        return (ContextStack) httpServletRequest.getSession().getAttribute(contextStackId);\n    }\n",
    "113330": "    public void setContextStackIDInRequest(String contextStackKey, HttpServletRequest httpServletRequest) {\n        // Get Stack\n        String contextStackId = (String) httpServletRequest.getAttribute(contextStackKey);\n\n        if (contextStackId == null) {\n            String contextStackIdString = httpServletRequest.getParameter(contextStackKey);\n            contextStackId = (String) ConvertUtils.convert(contextStackIdString, String.class);\n            // Set context stack key in request\n            if(contextStackId != null) {\n                httpServletRequest.setAttribute(contextStackKey, contextStackId);\n            }\n        }\n    }\n",
    "113347": "    public Set getRoles() {\n        return roles;\n    }\n",
    "113348": "    public String getHumanReadableKey() {\n        return humanReadableKey;\n    }\n",
    "113349": "    public void setRoles(Set roles) {\n        if (roles == null)\n            this.roles.clear();\n        else\n            this.roles = roles;\n    }\n",
    "113464": "   public void addRequestServiceContext(ServiceContext serviceContext) {\n      addServiceContext(serviceContext);\n   }\n",
    "113470": "   public InvocationResponse exec(String interfaceName, String methodName, Object[] arguments, String[] argumentTypes, ServiceContext[] contextList) {\n      return interceptorCtrl.exec(interfaceName, methodName, arguments, argumentTypes, contextList);\n   }\n",
    "113473": "   public Throwable sendingException() {\n      return this.sendingException;\n   }\n",
    "113474": "   public Object server() {\n      return this.server;\n   }\n",
    "113475": "   public void addReplyServiceContext(ServiceContext serviceContext) {\n      addServiceContext(serviceContext);\n   }\n",
    "113478": "   public Remote remoteLookup(String name) throws RMINamingException {\n\n      // no caching - only a single Remote here\n      DemoServerInterface serverStubProxy = (DemoServerInterface)\n         RMIReplicationManager.getInstance().newInterceptor(demoServerObj, name);\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         return serverStubProxy;\n      } else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "113480": "   public Remote stubLookup(String name) {\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         try {\n            return (Remote) UnicastRemoteObject.toStub(demoServerObj);  // **** preserve the stub semantics\n         }\n         catch (NoSuchObjectException ex) {\n            ex.printStackTrace();\n         }\n      }\n\n      return null;\n   }\n",
    "113481": "   public Remote serverObjectLookup(String name) {\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         return demoServerObj;\n      }\n\n      return null;\n   }\n",
    "113488": "   public Remote remoteLookup(String name) throws RMINamingException, RemoteException {\n\n      if (name.equals(\"JRMPDemoServer\")) {\n         return serverStubProxy;\n      } else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "113495": "   public Remote lookup(String name) throws RMINamingException {\n\n      Remote remote;\n      try {\n         remote = Naming.lookup(name);\n      } catch (Exception ex) {\n         throw new RMINamingException(\"JRMP naming lookup error\", ex);  // a simple conversion\n      }\n\n      return remote;\n   }\n",
    "113496": "   public Throwable getCause() {\n      return causeException;\n   }\n",
    "113499": "   public RMINamingInterface getNamingInterfaceDelegate() {\n\n      return this.delegate;\n   }\n",
    "113513": "   public boolean isContextId(int id) {\n\n      if (contextId == id) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "113514": "   public int xid() {\n\n      return xid;\n   }\n",
    "113515": "   public int getContextId() {\n\n      return contextId;\n   }\n",
    "113517": "   public Object getContextData() {\n\n      return contextData;\n   }\n",
    "113520": "   protected Object initialValue() {\n\n      return null;\n   }\n",
    "113521": "   public String toObjectId() {\n\n      return \"ServiceContext: <\" + Integer.toString(contextId) + \"> \" + super.toString();\n   }\n",
    "113523": "   protected void preDispatch() throws ChannelException {\n\n   }\n",
    "113525": "   protected void processSetStateEvent(SetStateEvent event) {\n   }\n",
    "113526": "   protected void processGetStateEvent(GetStateEvent event) {\n   }\n",
    "113528": "   private void startDispatchThread() {\n      dispatchThread = \n         new MessageDispatchThread(\"RMI Multicast Dispatch Thread: \" + groupName);\n      dispatchThread.setDaemon(true);\n      dispatchThread.start();\n   }\n",
    "113537": "   protected void stateSync() {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if (channel.getLocalAddress().equals(coordinator)) {   // double validation\n         try {\n            if (log.isTraceEnabled()) log.trace(\"sending state sync\");\n\n            ServerObjectStates stateMap = getServerStates();\n\n            synchronized (requestIdLock) {\n               stateMap.setRequestId(requestId);\n            }\n\n            channel.send(null, null, stateMap);  // as a normal message\n         }\n         catch (Exception ex) {\n            if (log.isErrorEnabled())  log.error(\"stateSync failed\", ex);\n         }\n      }\n   }\n",
    "113545": "   public void viewAccepted(View new_view) {\n\n      super.viewAccepted(new_view);\n\n      if (grpCoordinatorListener != null) {     // re-entry is not a concern here\n         if (channel.getLocalAddress().equals(new_view.getMembers().get(0))) {\n            grpCoordinatorListener.becomeGroupCoordinator();\n         }\n      }\n   }\n",
    "113546": "   public void viewAccepted(View new_view) {\n\n      if (log.isDebugEnabled())  log.debug(\"** View=\" + new_view + \" (size=\" + new_view.size() + \")\");\n\n      if (vsync) {\n         synchronized (outboundMsgQueueLock) {\n            if (outboundMsgQueue != null) {\n               Serializable msg;\n               for (Iterator i = outboundMsgQueue.iterator(); i.hasNext(); ) {\n                  try {\n                     msg = (Serializable) i.next();\n                     if (msg instanceof Message)\n                        channel.send((Message) msg);   //  maybe a unicast\n                     else\n                        channel.send(null, null, msg);\n\n                     if (log.isTraceEnabled()) log.trace(\"send queue msg\");\n                  }\n                  catch (ChannelException ex) {\n                     if (log.isErrorEnabled())  log.error(\"exception\", ex);\n                  }\n               }\n               outboundMsgQueue = null;  // reset\n            }\n         }\n      }\n   }\n",
    "113547": "   protected ServerObjectStates getServerStates() throws Exception {\n\n      ServerObjectStates stateMap = new ServerObjectStates();\n\n      String[] servers = localNaming.serverObjects();\n      String name;\n      Remote server;\n      byte[] serverState;\n\n      // non atomic for server object state fetching !?? (FIFO + server determinism)\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         server = localNaming.serverObjectLookup(name);\n         if (server != null) {   // do whatever available\n            if (server instanceof Checkpointable) {\n               serverState = ((Checkpointable) server).getState();\n               stateMap.setServerObjectState(name, serverState);\n            }\n         }\n      }\n\n      return stateMap;\n   }\n",
    "113549": "   public void suspect(Address suspected_mbr) {\n\n   }\n",
    "113550": "   protected void setServerStates(ServerObjectStates stateMap) throws Exception {\n\n      String[] servers = stateMap.serverObjectNames();\n      String name;\n      Remote server;\n      byte[] serverState;\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         serverState = stateMap.getServerObjectState(name);\n         if (serverState != null) {   // do whatever available\n            server = localNaming.serverObjectLookup(name);\n            if (server != null) {\n               if (server instanceof Checkpointable) {\n                  ((Checkpointable) server).setState(serverState);\n               }\n            }\n         }\n      }\n   }\n",
    "113551": "   public void block() {\n      if (vsync) {\n         if (log.isDebugEnabled())  log.debug(\"** VSYNC block ...\");\n\n         synchronized (outboundMsgQueueLock) {\n\n            outboundMsgQueue = new ArrayList();  // also server as a flag\n\n            // jgroups: this will eat unicast too !!\n            channel.blockOk();\n         }\n      }\n   }\n",
    "113552": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"receiveRequestServiceContexts: \" + requestInfo);\n\n   }\n",
    "113553": "   public void receiveRequest(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"receiveRequest: \" + requestInfo);\n\n   }\n",
    "113555": "   public void sendReply(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"sendReply: \" + requestInfo);\n\n   }\n",
    "113557": "   public void sendException(ServerRequestInfo requestInfo) {\n      if (log.isTraceEnabled()) log.trace(\"sendException: \" + requestInfo);\n\n   }\n",
    "113561": "   public void setRequestId(FTRequestServiceContext requestId) {\n      this.requestId = requestId;\n   }\n",
    "113563": "      private long assignId() {\n\n         int id = nextId++;\n\n         if (nextId == Integer.MAX_VALUE) {   // wrap around\n\n            nextId = 1;\n         }\n\n         return id;\n      }\n",
    "113566": "   protected void processMsg(Message msg) throws Throwable {\n\n      synchronized (syncedLock) {\n         if (! stateSynced) {\n            if (log.isDebugEnabled())  log.debug(\"ignore message, wait for join state sync\");\n            return;\n         }\n      }\n\n      super.processMsg(msg);\n   }\n",
    "113570": "   protected void processGetStateEvent(GetStateEvent event) {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if ( channel.getLocalAddress().equals(coordinator)) {\n\n         try {\n            ServerObjectStates stateMap = getServerStates();\n\n            channel.returnState(Util.objectToByteBuffer(stateMap));\n\n            if (log.isDebugEnabled())  log.debug(\"sent state sync\");\n         }\n         catch (Exception ex) {    // let the new member hang\n            if (log.isErrorEnabled())  log.error(\"GetStateEvent failed\", ex);\n         }\n      }\n      else {\n         if (log.isDebugEnabled())  log.debug(\"ignore unexpected GetStateEvent: \" + event);\n      }\n   }\n",
    "113571": "   public void receiveReply(ClientRequestInfo requestInfo) {\n\n      // ignore\n   }\n",
    "113572": "   protected void preDispatch() throws ChannelException {\n      channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);\n   }\n",
    "113573": "   public void receiveException(ClientRequestInfo requestInfo) {\n\n      // ignore\n   }\n",
    "113577": "   public void receiveReply(ClientRequestInfo requestInfo) {\n      return;\n   }\n",
    "113579": "   public void receiveException(ClientRequestInfo requestInfo) {\n      return;\n   }\n",
    "113580": "   public void receiveReply(ClientRequestInfo requestInfo) {\n      trace(\"client: receiveReply: \" + requestInfo.toString());\n   }\n",
    "113581": "   public void receiveException(ClientRequestInfo requestInfo) {\n      trace(\"client: receiveException: \" + requestInfo.toString());\n   }\n",
    "113582": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      ServiceContext[] contexts = requestInfo.operationContexts();\n      ServiceContext cxt;\n      if (contexts != null) {\n         for (int i = 0; i < contexts.length; i ++) {\n            cxt = contexts[i];\n            if (cxt.isContextId(ServiceContext.TRANSACTION_CONTEXT_ID)) {\n               Current.setServiceContext(cxt);\n            }\n         }\n      }\n   }\n",
    "113583": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      trace(\"server: receiveRequestServiceContexts: \" + requestInfo.toString());\n   }\n",
    "113584": "   public void receiveRequest(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113585": "   public void receiveRequest(ServerRequestInfo requestInfo) {\n      trace(\"server: receiveRequest: \" + requestInfo.toString());\n   }\n",
    "113586": "   public void sendReply(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113587": "   public void sendReply(ServerRequestInfo requestInfo) {\n      trace(\"server: sendReply: \" + requestInfo.toString());\n   }\n",
    "113588": "   public void sendException(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113589": "   public void sendException(ServerRequestInfo requestInfo) {\n      trace(\"server: sendException: \" + requestInfo.toString());\n   }\n",
    "113591": "   public void writeExternal(ObjectOutput out) throws IOException {\n      out.writeObject(remoteStub);\n\n      out.writeObject(serverInterceptorRemote);\n\n      // for now, we make this a copy. It helps runtime exception mgt\n      // some optimization is possible\n   }\n",
    "113594": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      this.remoteStub = (Remote) in.readObject();\n      this.serverInterceptorRemote = (ServerInterceptorRemoteInterface) in.readObject();\n   }\n",
    "113599": "   public ServiceContext checkRequestServiceContext(int contextId) {\n\n      ServiceContext result = null;\n\n      if (operationContexts != null) {\n\n         int num = operationContexts.length;\n         ServiceContext c;\n         for (int i = 0; i < num; i ++ ) {\n            c = operationContexts[i];\n            if (c.contextId == contextId) {\n               result = c;\n               ServiceContext[] newContexts = new ServiceContext[num - 1];\n               System.arraycopy(operationContexts, 0, newContexts, 0, i);\n               if (i < num -1)\n                  System.arraycopy(operationContexts, i+1, newContexts, i , num-i-1);\n               operationContexts = newContexts;\n               break;        // no duplication checking\n            }\n         }\n      }\n\n      return result;\n   }\n",
    "113602": "   protected ServiceContext getServiceContext(int contextId) {\n\n      return ContextUtil.getServiceContext(operationContexts, contextId);\n   }\n",
    "113603": "   protected void addServiceContext(ServiceContext serviceContext) {\n\n      operationContexts = ContextUtil.addServiceContext(operationContexts, serviceContext);\n   }\n",
    "113614": "   public void removeClientRequestInterceptor(String name) {\n\n      synchronized (clientInterceptorList) {\n         clientInterceptorList.remove(name);\n      }\n   }\n",
    "113615": "   public void writeExternal(ObjectOutput out) throws IOException {\n      super.writeExternal(out);\n      out.writeObject(remoteKey);\n      out.writeObject(props);\n   }\n",
    "113616": "   public ClientRMIInterceptor getClientRequestInterceptor(String name) {\n\n      synchronized (clientInterceptorList) {\n         return (ClientRMIInterceptor) clientInterceptorList.get(name);\n      }\n   }\n",
    "113617": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      super.readExternal(in);\n      this.remoteKey = (String) in.readObject();\n      this.props = (Properties) in.readObject();\n   }\n",
    "113618": "   public String getPropert(String name) {\n      return props.getProperty(name);\n   }\n",
    "113620": "   public void setPropert(String name, String value) {\n      props.setProperty(name, value);\n   }\n",
    "113621": "   public void removeServerRequestInterceptor(String name) {\n\n      synchronized (serverInterceptorList) {\n         serverInterceptorList.remove(name);\n      }\n   }\n",
    "113622": "   public String getRemoteKey() {\n      return remoteKey;\n   }\n",
    "113623": "   public ServerRMIInterceptor getServerRequestInterceptor(String name) {\n\n      synchronized (serverInterceptorList) {\n         return (ServerRMIInterceptor) serverInterceptorList.get(name);\n      }\n   }\n",
    "113626": "   public void addClientMessageInterceptor(ClientRMIMessageInterceptor interceptor) {\n\n      synchronized (this) {\n         clientMsgInterceptor = interceptor;\n      }\n   }\n",
    "113628": "   private void processExecReflectionException(Exception ex) throws InvocationTargetException {\n\n      // the cause exception has to be a runtime exception\n      throw new InvocationTargetException(new IllegalArgumentException(\"Interceptor Service.exec() failed: \" + ex));\n   }\n",
    "113629": "   public void removeClientMessageInterceptor(String name) {\n\n      synchronized (this) {\n         clientMsgInterceptor = null;\n      }\n   }\n",
    "113630": "   public ClientRMIMessageInterceptor getClientMessageInterceptor(String name) {\n\n      synchronized (this) {\n         return this.clientMsgInterceptor;\n      }\n   }\n",
    "113633": "   public ClientRMIMessageInterceptor getClientMessageInterceptor() {\n\n      synchronized (this) {\n         return this.clientMsgInterceptor;\n      }\n   }\n",
    "113636": "   public void addServerMessageInterceptor(ServerRMIMessageInterceptor interceptor) {\n\n      synchronized (this) {\n         serverMsgInterceptor = interceptor;\n      }\n   }\n",
    "113639": "   public void removeServerMessageInterceptor(String name) {\n\n      synchronized (this) {\n         serverMsgInterceptor = null;\n      }\n   }\n",
    "113642": "   public ServerRMIMessageInterceptor getServerMessageInterceptor(String name) {\n\n      synchronized (this) {\n         return this.serverMsgInterceptor;\n      }\n   }\n",
    "113646": "   public ServerRMIMessageInterceptor getServerMessageInterceptor() {\n\n      synchronized (this) {\n         return this.serverMsgInterceptor;\n      }\n   }\n",
    "113676": "   public Remote lookup(String name) throws RMINamingException, RemoteException {\n\n      if (name.equals(\"JRMPDemoServer\")) {\n         return serverStubProxy;\n      }\n      else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "113696": "   public boolean isServiceId(int id) {\n\n      if (serviceId == id) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n",
    "113697": "   public int getServiceId() {\n\n      return serviceId;\n   }\n",
    "113702": "   public String toObjectId() {\n\n      return \"ServiceContext: <\" + Integer.toString(serviceId) + \"> \" + super.toString();\n   }\n",
    "113717": "   protected void processMsg(Message msg) throws Throwable {\n\n      Object msgObj;\n      msgObj = msg.getObject();\n\n      if (msgObj instanceof InvocationResponse) {\n\n         synchronized (rspLock) {\n            rsp = (InvocationResponse) msgObj;   // todo: concurrent access\n            rspLock.notify();\n         }\n      }\n\n      // possible issues ??\n      if (msgObj != null)\n         System.out.println(\"***  obj is \" + msgObj.getClass() +\n            \", hdrs are\" + msg.printObjectHeaders());\n      else\n         System.out.println(\"***  hdrs are \" + msg.printObjectHeaders());\n   }\n",
    "113719": "   public InvocationResponse invoke(ClientRequestInfo requestInfo) throws ChannelException {\n\n      channel.send(null, null, (Serializable) requestInfo);\n\n      InvocationResponse result = null;\n\n      synchronized (rspLock) {\n         while (rsp == null) {\n            try {\n               rspLock.wait();\n            }\n            catch (InterruptedException ex) {\n               // shadow any interrupt\n               // rspLock.notify();\n            }\n         }\n         result = rsp;\n         rsp = null; // no further request-response correlation here - single-thread client ?!\n      }\n\n      return result;\n   }\n",
    "113725": "   public void receiveException(ClientRequestInfo requestInfo) {\n\n      // never invoked in this case\n   }\n",
    "113729": "   public void sendRequest(ClientRequestInfo requestInfo) {\n      trace(\"client: sendRequest: \" + requestInfo.toString());\n   }\n",
    "113733": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      ServiceContext[] contexts = requestInfo.operationContexts();\n      ServiceContext cxt;\n      if (contexts != null) {\n         for (int i = 0; i < contexts.length; i ++) {\n            cxt = contexts[i];\n            if (cxt.isServiceId(ServiceContext.TRANSACTION_CONTEXT_ID)) {\n               Current.setServiceContext(cxt);\n            }\n         }\n      }\n   }\n",
    "113749": "   public ServiceContext checkRequestServiceContext(int serviceId) {\n\n      ServiceContext result = null;\n\n      if (operationContexts != null) {\n\n         int num = operationContexts.length;\n         ServiceContext c;\n         for (int i = 0; i < num; i ++ ) {\n            c = operationContexts[i];\n            if (c.serviceId == serviceId) {\n               result = c;\n               ServiceContext[] newContexts = new ServiceContext[num - 1];\n               System.arraycopy(operationContexts, 0, newContexts, 0, i);\n               if (i < num -1)\n                  System.arraycopy(operationContexts, i+1, newContexts, i , num-i-1);\n               operationContexts = newContexts;\n               break;        // no duplication checking\n            }\n         }\n      }\n\n      return result;\n   }\n",
    "113751": "   protected ServiceContext getServiceContext(int serviceId) {\n\n      return ContextUtil.getServiceContext(operationContexts, serviceId);\n   }\n",
    "113766": "   public void writeExternal(ObjectOutput out) throws IOException {\n      super.writeExternal(out);\n      out.writeObject(props);\n   }\n",
    "113768": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      super.readExternal(in);\n      this.props = (Properties) in.readObject();\n   }\n",
    "113811": "   protected ServiceContext getServiceContext(int serviceId) {\n\n      if (operationContexts == null) {\n         return null;\n      }\n      else {\n         ServiceContext c;\n         for (int i = 0; i < operationContexts.length; i ++ ) {\n            c = operationContexts[i];\n            if (c.serviceId == serviceId) {\n               return (ServiceContext) c.clone();\n            }\n         }\n         return null; // otherwise\n      }\n   }\n",
    "113812": "   public void removeClientRequestInterceptor(String name) {\n\n      synchronized (interceptorList) {\n         interceptorList.remove(name);\n      }\n   }\n",
    "113813": "   protected void addServiceContext(ServiceContext serviceContext) {\n\n      if (operationContexts != null) {\n\n         int num = operationContexts.length;\n         ServiceContext c;\n\n         for (int i = 0; i < num; i ++ ) {\n            c = operationContexts[i];\n            if (c.serviceId == serviceContext.serviceId) {\n               operationContexts[i] = serviceContext;\n               return; // replace\n            }\n         }\n\n         // append\n         ServiceContext[] result = new ServiceContext[num + 1];\n         System.arraycopy(operationContexts, 0, new ServiceContext[num + 1], 0, num);\n         result[num] = serviceContext;  // last one\n         operationContexts = result;\n      }\n      else {\n         operationContexts = new ServiceContext[1];\n         operationContexts[0] = serviceContext;\n      }\n   }\n",
    "113817": "   public void sendRequest(ClientRequestInfo requestInfo) {\n\n      // update the clientRequestInfo\n      requestInfo.addRequestServiceContext(Current.getServiceContext(ServiceContext.TRANSACTION_CONTEXT_ID));\n   }\n",
    "113906": "   public void receiveRequestServiceContexts(ServerRequestInfo requestInfo) {\n      return;\n   }\n",
    "113922": "   public void sendRequest(ClientRequestInfo requestInfo) {\n      // ignore\n   }\n",
    "113937": "   public void viewAccepted(View new_view) {\n\n      if (log.isDebugEnabled())  log.debug(\"** View=\" + new_view + \" (size=\" + new_view.size() + \")\");\n\n      if (vsync) {\n         synchronized (outboundMsgQueueLock) {\n            if (outboundMsgQueue != null) {\n               for (Iterator i = outboundMsgQueue.iterator(); i.hasNext(); ) {\n                  try {\n                     channel.send(null, null, (Serializable) i.next());\n                  }\n                  catch (ChannelException ex) {\n                     if (log.isErrorEnabled())  log.error(\"exception\", ex);\n                  }\n               }\n               outboundMsgQueue = null;  // reset\n            }\n         }\n      }\n   }\n",
    "113945": "   public void block() {\n      if (vsync) {\n         if (log.isDebugEnabled())  log.debug(\"** VSYNC block ...\");\n         synchronized (outboundMsgQueueLock) {\n            outboundMsgQueue = new ArrayList();  // also server as a flag\n            channel.blockOk();   // jgroups: this will eat unicast too !!\n         }\n      }\n   }\n",
    "114218": "   protected void processStateSync(ServerObjectStateMap stateMap) {\n      try {\n         setServerStates(stateMap);\n\n         synchronized(msgBuffer) {\n            msgBuffer.clear();   // no partial state-sync\n         }\n      }\n      catch (Exception ex) {     // keep the buffer\n         if (log.isErrorEnabled())  log.error(\"SetStateEvent failed\", ex);\n      }\n   }\n",
    "114219": "   protected void stateSync() {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if (channel.getLocalAddress().equals(coordinator)) {   // double validation\n         try {\n            if (log.isTraceEnabled()) log.trace(\"sending state sync\");\n            ServerObjectStateMap stateMap = getServerStates();\n            channel.send(null, null, stateMap);  // as a normal message\n         }\n         catch (Exception ex) {\n            if (log.isErrorEnabled())  log.error(\"stateSync failed\", ex);\n         }\n      }\n   }\n",
    "114233": "   protected ServerObjectStateMap getServerStates() throws Exception {\n\n      ServerObjectStateMap stateMap = new ServerObjectStateMap();\n\n      String[] servers = localNaming.serverObjects();\n      String name;\n      Remote server;\n      byte[] serverState;\n\n      // non atomic for server object state fetching !?? (FIFO + server determinism)\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         server = localNaming.serverObjectLookup(name);\n         if (server != null) {   // do whatever available\n            if (server instanceof Checkpointable) {\n               serverState = ((Checkpointable) server).getState();\n               stateMap.setServerObjectState(name, serverState);\n            }\n         }\n      }\n\n      return stateMap;\n   }\n",
    "114237": "   protected void setServerStates(ServerObjectStateMap stateMap) throws Exception {\n\n      String[] servers = stateMap.serverObjectNames();\n      String name;\n      Remote server;\n      byte[] serverState;\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         serverState = stateMap.getServerObjectState(name);\n         if (serverState != null) {   // do whatever available\n            server = localNaming.serverObjectLookup(name);\n            if (server != null) {\n               if (server instanceof Checkpointable) {\n                  ((Checkpointable) server).setState(serverState);\n               }\n            }\n         }\n      }\n   }\n",
    "114250": "   protected void processGetStateEvent(GetStateEvent event) {\n\n      Address coordinator = (Address) channel.getView().getMembers().get(0);\n\n      if ( channel.getLocalAddress().equals(coordinator)) {\n\n         try {\n            ServerObjectStateMap stateMap = getServerStates();\n\n            channel.returnState(Util.objectToByteBuffer(stateMap));\n         }\n         catch (Exception ex) {    // let the new member hang\n            if (log.isErrorEnabled())  log.error(\"GetStateEvent failed\", ex);\n         }\n      }\n      else {\n         if (log.isDebugEnabled())  log.debug(\"unexpected GetStateEvent: \" + event);\n      }\n   }\n",
    "114339": "   public void writeExternal(ObjectOutput out) throws IOException {\n      out.writeObject(serviceStub);\n\n      out.writeObject(interceptorRemote);\n      // for now, we make this a copy. It helps runtime exception mgt\n      // some optimization is possible\n   }\n",
    "114343": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      this.serviceStub = (Remote) in.readObject();\n      this.interceptorRemote = (ServerInterceptorRemoteInterface) in.readObject();\n   }\n",
    "114411": "   public void writeExternal(ObjectOutput out) throws IOException {\n      super.writeExternal(out);\n   }\n",
    "114415": "   public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n      super.readExternal(in);\n   }\n",
    "114539": "   public Remote remoteLookup(String name) throws RMINamingException {\n      return remoteLookup(name, null);\n   }\n",
    "114544": "   public Remote remoteLookup(String name) throws RMINamingException {\n\n      // no caching - only a single Remote here\n      DemoServerInterface serverStubProxy = (DemoServerInterface)\n         RMIReplicationManager.getInstance().newInterceptor(demoServerObj, name);  // not really a remoteStub here - same effect\n\n      if (name.equals(\"ReplicateDemoServerObject\")) {\n         return serverStubProxy;\n      } else {\n         throw new RMINamingException(\"Name not found\", null);\n      }\n   }\n",
    "114549": "   public String objectGroupId(String name) {\n      return null;  // default\n   }\n",
    "114557": "   public void comesNewGroupCoordinator() {\n      \n   }\n",
    "114560": "   public void comesNewGroupCoordinator() {\n\n      try {\n         OpenGroupManagerRemoteInterface coordinatorOpenGrpMgr =\n            (OpenGroupManagerRemoteInterface) Naming.lookup(\"//\" + namingHost + \"/OpenGroupManager\");\n\n         OpenGroupManager.getInstance().registerWithCoordinator(coordinatorOpenGrpMgr, serverId, openGrpMgrStub);\n      }\n      catch (Exception e) {\n         System.out.println(\"Register OpenGroupMgr proxy with coordinator err: \" + e.getMessage());\n         e.printStackTrace();\n      }\n\n      // todo: add re-try\n   }\n",
    "114576": "    public Exception getNextException() {\n        return nextException;\n    }\n",
    "114578": "    public void setLogTarget(PrintStream target) {\n        logTarget = target;\n    }\n",
    "114579": "    public PrintStream getLogTarget() {\n        return logTarget;\n    }\n",
    "114583": "    public void printStackTrace(Throwable e) {\n\n        // Yes, we print the stack trace for an originating\n        // exception, but nothing else.\n        // If e is not a remote exception\n        // or if e.detail is null\n        // or if e.detail is not an EJBException\n        // Print the stack\n        // Otherwise the stack has already been printed, don't print.\n        if (!(e instanceof RemoteException)\n                || ((RemoteException) e).detail == null) {\n//                ||!(((RemoteException) e).detail instanceof EJBException)) {\n            e.printStackTrace(logTarget);\n        }\n    }\n",
    "114593": "    public void printStackTrace(Throwable e) {\n\n        if (debugLevel > 3) {\n            e.printStackTrace(logTarget);\n        } else {\n            super.printStackTrace(e);\n        }\n    }\n",
    "114632": "   public ServerObjectNamingInterface getLocalServerObjectNaming() {\n      return this.localNaming;\n   }\n",
    "114648": "   public boolean checkObjectGroup(String grpId) {\n      if (grpId == null) {\n         return true;   // default\n      }\n\n      synchronized (queueMap) {\n         return queueMap.containsKey(grpId);\n      }\n   }\n",
    "114649": "   public Queue checkObjectGroupQueue(String grpId) {\n      if (grpId == null) {\n         return DEFAULT_QUEUE;\n      }\n\n      synchronized (queueMap) {\n         if (queueMap.containsKey(grpId)) {\n            return (Queue) queueMap.get(grpId);\n         }\n         else {\n            Queue q = new Queue();\n            queueMap.put(grpId, q);\n            return q;\n         }\n      }\n   }\n",
    "114652": "   public boolean clearObjectGroupQueue(String grpId) {\n      if (grpId == null) {\n         return false;   // ignore\n      }\n\n      synchronized (queueMap) {\n         if (queueMap.containsKey(grpId)) {\n            Queue q = (Queue) queueMap.get(grpId);\n            //q.purge();             // triggered from delivery thread now\n            if (q.isEmpty()) {\n               queueMap.remove(grpId);\n               return true;\n            }\n            else {\n               return false;   // let the delivery thread run\n            }\n         }\n         else {\n            return false;   //ignore\n         }\n      }\n   }\n",
    "114657": "   public void viewAccepted(View new_view) {\n\n      super.viewAccepted(new_view);\n\n      if (grpCoordinatorListener != null) {     // re-entry is not a concern here\n         if (channel.getLocalAddress().equals(new_view.getMembers().get(0))) {\n            grpCoordinatorListener.becomesGroupCoordinator();\n         }\n         else {\n            // todo: only fire when there's actually a coordinator change - same above !!\n            grpCoordinatorListener.comesNewGroupCoordinator();\n         }\n      }\n   }\n",
    "114665": "   protected void setServerStates(ServerObjectStates stateMap) throws Exception {\n\n      String[] servers = stateMap.serverObjectNames();\n      String name;\n      Remote server;\n      byte[] serverState;\n      for (int i = 0; i < servers.length; i ++) {\n         name = servers[i];\n         serverState = stateMap.getServerObjectState(name);\n         if (serverState != null) {   // do whatever available\n            server = localNaming.serverObjectLookup(name);\n            if (server != null) {     // equivalently a registration - no object-group for now\n               if (server instanceof Checkpointable) {\n                  ((Checkpointable) server).setState(serverState);\n               }\n            }\n         }\n      }\n   }\n",
    "114671": "      public void quit() {\n         stopped = true;       // todo: clean it up\n      }\n",
    "114682": "   protected void preDispatch() throws ChannelException {\n      // channel.setOpt(Channel.GET_STATE_EVENTS, Boolean.TRUE);  - deprecated since 2.3\n   }\n",
    "114702": "   public void registerProxyStub(String serverId, Remote mgrProxyStub) throws RemoteException {\n\n      stubMap.put(serverId, mgrProxyStub);\n   }\n",
    "114832": "\tpublic int read(byte[] _buffer) throws IOException {\n\t\tint pos = 0;\n\t\twhile (pos < _buffer.length) {\n\t\t\tpos += read(_buffer, pos, _buffer.length - pos);\n\t\t}\n\t\treturn pos;\n\t}\n",
    "114855": "\tpublic void copyInto(double[] anArray) {\n\t\tSystem.arraycopy(elementData, 0, anArray, 0, elementCount);\n\t}\n",
    "114860": "\tpublic void trimToSize() {\n\t\tint oldCapacity = elementData.length;\n\t\tif (elementCount < oldCapacity) {\n\t\t\tdouble[] oldData = elementData;\n\t\t\telementData = new double[elementCount];\n\t\t\tSystem.arraycopy(oldData, 0, elementData, 0, elementCount);\n\t\t}\n\t}\n",
    "114869": "\tpublic void ensureCapacity(int minCapacity) {\n\t\tensureCapacityHelper(minCapacity);\n\t}\n",
    "114873": "\tprotected boolean lessThan(float a, float b) {\n\t\treturn a < b;\n\t}\n",
    "114874": "\tprivate void ensureCapacityHelper(int minCapacity) {\n\t\tint oldCapacity = elementData.length;\n\t\tif (minCapacity > oldCapacity) {\n\t\t\tdouble[] oldData = elementData;\n\t\t\tint newCapacity = (capacityIncrement > 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2);\n\t\t\tif (newCapacity < minCapacity) {\n\t\t\t\tnewCapacity = minCapacity;\n\t\t\t}\n\t\t\telementData = new double[newCapacity];\n\t\t\tSystem.arraycopy(oldData, 0, elementData, 0, elementCount);\n\t\t}\n\t}\n",
    "114882": "\tpublic String toString() {\n\t\treturn new String(buf, 0, count);\n\t}\n",
    "114883": "\tpublic void setSize(int newSize) {\n\t\tif (newSize > elementCount) {\n\t\t\tensureCapacityHelper(newSize);\n\t\t}\n\t\telse {\n\t\t\tfor (int i = newSize; i < elementCount; i++) {\n\t\t\t\telementData[i] = 0;\n\t\t\t}\n\t\t}\n\t\telementCount = newSize;\n\t}\n",
    "114886": "\tpublic String toString(String enc) throws UnsupportedEncodingException {\n\t\treturn new String(buf, 0, count, enc);\n\t}\n",
    "114889": "\tpublic String toString(int hibyte) {\n\t\treturn new String(buf, hibyte, 0, count);\n\t}\n",
    "114890": "\tpublic int capacity() {\n\t\treturn elementData.length;\n\t}\n",
    "114892": "\tpublic void close() throws IOException {\n\t}\n",
    "114900": "\tpublic int size() {\n\t\treturn elementCount;\n\t}\n",
    "114902": "    public void setBody(AbstractMP3FragmentBody body) {\n        this.body = body;\n    }\n",
    "114903": "    public AbstractMP3FragmentBody getBody() {\n        return this.body;\n    }\n",
    "114905": "    public boolean equals(Object obj) {\n        if ((obj instanceof AbstractMP3Fragment) == false) {\n            return false;\n        }\n\n        AbstractMP3Fragment object = (AbstractMP3Fragment) obj;\n\n        if (this.getIdentifier().equals(object.getIdentifier()) == false) {\n            return false;\n        }\n\n        if (this.body.equals(object.body) == false) {\n            return false;\n        }\n\n        return super.equals(obj);\n    }\n",
    "114906": "\tpublic boolean isEmpty() {\n\t\treturn elementCount == 0;\n\t}\n",
    "114908": "\tpublic boolean contains(double elem) {\n\t\treturn indexOf(elem, 0) >= 0;\n\t}\n",
    "114910": "\tpublic int indexOf(double elem) {\n\t\treturn indexOf(elem, 0);\n\t}\n",
    "114913": "\tpublic int indexOf(double elem, int index) {\n\t\tfor (int i = index; i < elementCount; i++)\n\t\t\tif (elem == elementData[i])\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}\n",
    "114916": "\tpublic int lastIndexOf(double elem) {\n\t\treturn lastIndexOf(elem, elementCount - 1);\n\t}\n",
    "114917": "\tpublic int lastIndexOf(double elem, int index) {\n\t\tif (index >= elementCount)\n\t\t\tthrow new IndexOutOfBoundsException(index + \" >= \" + elementCount);\n\n\t\tfor (int i = index; i >= 0; i--)\n\t\t\tif (elem == elementData[i])\n\t\t\t\treturn i;\n\t\treturn -1;\n\t}\n",
    "114920": "\tpublic double elementAt(int index) {\n\t\tif (index >= elementCount) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n\t\t}\n\t\t/* Since try/catch is free, except when the exception is thrown,\n\t\t   put in this extra try/catch to catch negative indexes and\n\t\t   display a more informative error message.  This might not\n\t\t   be appropriate, especially if we have a decent debugging\n\t\t   environment - JP. */\n\t\ttry {\n\t\t\treturn elementData[index];\n\t\t}\n\t\tcatch (ArrayIndexOutOfBoundsException e) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" < 0\");\n\t\t}\n\t}\n",
    "114922": "    public void setFilenameTag(FilenameTag filenameTag) {\n        this.filenameTag = filenameTag;\n    }\n",
    "114923": "\tpublic double firstElement() {\n\t\tif (elementCount == 0) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn elementData[0];\n\t}\n",
    "114924": "\tpublic double lastElement() {\n\t\tif (elementCount == 0) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn elementData[elementCount - 1];\n\t}\n",
    "114926": "    public FilenameTag getFilenameTag() {\n        return this.filenameTag;\n    }\n",
    "114927": "\tpublic void setElementAt(double obj, int index) {\n\t\tif (index >= elementCount) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n\t\t}\n\t\telementData[index] = obj;\n\t}\n",
    "114929": "\tpublic void removeElementAt(int index) {\n\t\tif (index >= elementCount) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);\n\t\t}\n\t\telse if (index < 0) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index);\n\t\t}\n\t\tint j = elementCount - index - 1;\n\t\tif (j > 0) {\n\t\t\tSystem.arraycopy(elementData, index + 1, elementData, index, j);\n\t\t}\n\t\telementCount--;\n\t\telementData[elementCount] = 0; /* to let gc do its work */\n\t}\n",
    "114930": "    public void setFrameAcrossTags(AbstractID3v2Frame frame) {\n        ID3v2_4 id3v1 = null;\n        ID3v2_4 lyrics3 = null;\n\n        if (this.id3v1tag != null) {\n            id3v1 = new ID3v2_4(this.id3v1tag);\n            id3v1.setFrame(frame);\n            this.id3v1tag.overwrite(id3v1);\n        }\n\n        if (this.id3v2tag != null) {\n            id3v2tag.setFrame(frame);\n        }\n\n        if (this.lyrics3tag != null) {\n            lyrics3 = new ID3v2_4(this.lyrics3tag);\n            lyrics3.setFrame(frame);\n            this.lyrics3tag = new Lyrics3v2(lyrics3);\n        }\n\n        if (this.filenameTag != null) {\n            filenameTag.setFrame(frame);\n        }\n    }\n",
    "114934": "\tpublic void insertElementAt(double obj, int index) {\n\t\tif (index >= elementCount + 1) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index + \" > \" + elementCount);\n\t\t}\n\t\tensureCapacityHelper(elementCount + 1);\n\t\tSystem.arraycopy(elementData, index, elementData, index + 1, elementCount - index);\n\t\telementData[index] = obj;\n\t\telementCount++;\n\t}\n",
    "114936": "\tpublic void addElement(double obj) {\n\t\tensureCapacityHelper(elementCount + 1);\n\t\telementData[elementCount++] = obj;\n\t}\n",
    "114940": "\tpublic boolean removeElement(double obj) {\n\t\tint i = indexOf(obj);\n\t\tif (i >= 0) {\n\t\t\tremoveElementAt(i);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "114942": "\tpublic void removeAllElements() {\n\t\t// Let gc do its work\n\t\tfor (int i = 0; i < elementCount; i++)\n\t\t\telementData[i] = 0;\n\n\t\telementCount = 0;\n\t}\n",
    "114944": "\tpublic Object clone() {\n\t\ttry {\n\t\t\tDoubleVector v = (DoubleVector) super.clone();\n\t\t\tv.elementData = new double[elementCount];\n\t\t\tSystem.arraycopy(elementData, 0, v.elementData, 0, elementCount);\n\t\t\treturn v;\n\t\t}\n\t\tcatch (CloneNotSupportedException e) {\n\t\t\t// this shouldn't happen, since we are Cloneable\n\t\t\tthrow new InternalError();\n\t\t}\n\t}\n",
    "114945": "    public void setID3v1Tag(AbstractMP3Tag mp3tag) {\n        id3v1tag = new ID3v1_1(mp3tag);\n    }\n",
    "114947": "\tpublic double get(int index) {\n\t\tif (index >= elementCount)\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index);\n\n\t\treturn elementData[index];\n\t}\n",
    "114950": "\tpublic double set(int index, double element) {\n\t\tif (index >= elementCount)\n\t\t\tthrow new ArrayIndexOutOfBoundsException(index);\n\n\t\tdouble oldValue = elementData[index];\n\t\telementData[index] = element;\n\t\treturn oldValue;\n\t}\n",
    "114952": "\tpublic boolean add(double o) {\n\t\tensureCapacityHelper(elementCount + 1);\n\t\telementData[elementCount++] = o;\n\t\treturn true;\n\t}\n",
    "114953": "    public ID3v1 getID3v1Tag() {\n        return id3v1tag;\n    }\n",
    "114954": "\tpublic boolean remove(double o) {\n\t\treturn removeElement(o);\n\t}\n",
    "114956": "    public void setID3v2Tag(AbstractMP3Tag mp3tag) {\n        id3v2tag = new ID3v2_4(mp3tag);\n    }\n",
    "114957": "\tpublic void add(int index, double element) {\n\t\tinsertElementAt(element, index);\n\t}\n",
    "114962": "\tpublic void clear() {\n\t\tremoveAllElements();\n\t}\n",
    "114964": "\tpublic boolean equals(Object o) {\n\t\treturn super.equals(o);\n\t}\n",
    "114965": "    public AbstractID3v2 getID3v2Tag() {\n        return id3v2tag;\n    }\n",
    "114966": "\tprotected void removeRange(int fromIndex, int toIndex) {\n\t\tint numMoved = elementCount - toIndex;\n\t\tSystem.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved);\n\n\t\t// Let gc do its work\n\t\tint newElementCount = elementCount - (toIndex - fromIndex);\n\t\twhile (elementCount != newElementCount)\n\t\t\telementData[--elementCount] = 0;\n\t}\n",
    "114978": "    public void setLyrics3Tag(AbstractMP3Tag mp3tag) {\n        lyrics3tag = new Lyrics3v2(mp3tag);\n    }\n",
    "115001": "    public AbstractLyrics3 getLyrics3Tag() {\n        return lyrics3tag;\n    }\n",
    "115062": "    public Lyrics3v2Field getField(String identifier) {\n        return (Lyrics3v2Field) fieldMap.get(identifier);\n    }\n",
    "115072": "    public void setId3v2PaddingMultiplier(float mult) {\n        if (mult > 1) {\n            id3v2PaddingMultiplier = mult;\n        }\n    }\n",
    "115077": "    public float getId3v2PaddingMultiplier() {\n        return id3v2PaddingMultiplier;\n    }\n",
    "115081": "    public boolean isUnsynchronized() {\n        return getUnsynchronizedFragments().size() > 0;\n    }\n",
    "115082": "    public void setId3v2PaddingSize(int size) {\n        if (size >= 0) {\n            id3v2PaddingSize = size;\n        }\n    }\n",
    "115087": "    public int getId3v2PaddingSize() {\n        return id3v2PaddingSize;\n    }\n",
    "115125": "    public String getBriefDescription() {\n        String            str = \"\";\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n\n            if ((object.toString() != null) && (object.toString().length() > 0)) {\n                str += (object.getIdentifier() + \"=\\\"\" + object.toString() + \"\\\"; \");\n            }\n        }\n\n        return str;\n    }\n",
    "115126": "    public String getDescription() {\n        String            str = \"\";\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n            str += (object.getIdentifier() + \" = \" + object.toString() + \"\\n\");\n        }\n\n        return str.trim();\n    }\n",
    "115127": "    public void setObject(String identifier, Object obj) {\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n\n            if (object.getIdentifier().equals(identifier)) {\n                object.setValue(obj);\n            }\n        }\n    }\n",
    "115128": "    public Object getObject(String identifier) {\n        AbstractMP3Object object;\n        Object            obj = null;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n\n            if (object.getIdentifier().equals(identifier)) {\n                obj = object.getValue();\n            }\n        }\n\n        return obj;\n    }\n",
    "115132": "    public boolean isSubsetOf(Object obj) {\n        if ((obj instanceof AbstractMP3FragmentBody) == false) {\n            return false;\n        }\n\n        ArrayList superset = ((AbstractMP3FragmentBody) obj).objectList;\n\n        for (int i = 0; i < objectList.size(); i++) {\n            if (((AbstractMP3Object) objectList.get(i)).getValue() != null) {\n                if (superset.contains(objectList.get(i)) == false) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n",
    "115133": "    public boolean equals(Object obj) {\n        if ((obj instanceof AbstractMP3FragmentBody) == false) {\n            return false;\n        }\n\n        AbstractMP3FragmentBody object = (AbstractMP3FragmentBody) obj;\n\n        if (this.objectList.equals(object.objectList) == false) {\n            return false;\n        }\n\n        return super.equals(obj);\n    }\n",
    "115134": "    public Iterator iterator() {\n        return objectList.iterator();\n    }\n",
    "115138": "    public String toString() {\n        String            str = getIdentifier() + \"\\n\";\n        AbstractMP3Object object;\n        Iterator          iterator = objectList.listIterator();\n\n        while (iterator.hasNext()) {\n            object = (AbstractMP3Object) iterator.next();\n            str += (object.getIdentifier() + \" = \" + object.toString() + \"\\n\");\n        }\n\n        return str;\n    }\n",
    "115143": "    public boolean hasFilenameTag() {\n        return (filenameTag != null);\n    }\n",
    "115147": "    public void equals() {\n        /**\n         * @todo Implement this java.lang.Object method\n         */\n        throw new java.lang.UnsupportedOperationException(\"Method equals() not yet implemented.\");\n    }\n",
    "115149": "    public boolean hasID3v1Tag() {\n        return (id3v1tag != null);\n    }\n",
    "115153": "    public void setLanguage(String lang) {\n        if (TagConstant.languageIdToString.containsKey(lang)) {\n            language = lang;\n        }\n    }\n",
    "115161": "    public boolean hasID3v2Tag() {\n        return (id3v2tag != null);\n    }\n",
    "115166": "    public String getLanguage() {\n        return language;\n    }\n",
    "115177": "    public boolean hasLyrics3Tag() {\n        return (lyrics3tag != null);\n    }\n",
    "115225": "    public void setLyrics3SaveField(String id, boolean save) {\n        this.lyrics3SaveFieldMap.put(id, new Boolean(save));\n    }\n",
    "115240": "    public boolean getLyrics3SaveField(String id) {\n        return ((Boolean) lyrics3SaveFieldMap.get(id)).booleanValue();\n    }\n",
    "115281": "    private int getFrameSize() {\n        if (this.frequency == 0) {\n            return 0;\n        }\n\n        int size = 0;\n        int paddingByte;\n\n        if (padding) {\n            paddingByte = 1;\n        } else {\n            paddingByte = 0;\n        }\n\n        if (this.layer == 3) { // Layer I\n            size = (int) ((((12 * this.bitRate) / this.frequency) + paddingByte) * 4);\n        } else {\n            size = (int) (((144 * this.bitRate) / this.frequency) + paddingByte);\n        }\n\n        //if (protection) size += 2;\n        return size;\n    }\n",
    "115338": "    public void setPlayCounterSize(byte size) {\n        if (size > 0) {\n            playCounterSize = size;\n        }\n    }\n",
    "115356": "    public byte getPlayCounterSize() {\n        return playCounterSize;\n    }\n",
    "115377": "    public void setTextEncoding(byte enc) {\n        if ((enc >= 0) && (enc <= 3)) {\n            textEncoding = enc;\n        }\n    }\n",
    "115386": "    public byte getTextEncoding() {\n        return textEncoding;\n    }\n",
    "115399": "    public void setTimeStampFormat(byte tsf) {\n        if ((tsf == 1) || (tsf == 2)) {\n            timeStampFormat = tsf;\n        }\n    }\n",
    "115416": "    public byte getTimeStampFormat() {\n        return timeStampFormat;\n    }\n",
    "115660": "    public void setTimeStamp(long timeStamp, byte timeStampFormat) {\n        /**\n         * @todo convert both types of formats\n         */\n        timeStamp = timeStamp / 1000;\n        minute    = timeStamp / 60;\n        second    = timeStamp % 60;\n    }\n",
    "115693": "    static public boolean isMatchingParenthesis(String str) {\n        if (str != null) {\n            TagOptionSingleton option = TagOptionSingleton.getInstance();\n            int                length = str.length();\n            char               ch;\n\n            for (int i = 0; i < length; i++) {\n                ch = str.charAt(i);\n\n                if (option.isCloseParenthesis(\"\" + ch)) {\n                    return false;\n                }\n\n                if (option.isOpenParenthesis(\"\" + ch)) {\n                    i = findMatchingParenthesis(str, i);\n\n                    if (i < 0) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n",
    "115696": "    public String composeFilename() {\n        String filename = \"\";\n\n        if (beforeComposite != null) {\n            filename += (beforeComposite.composeFilename() + \" \");\n        }\n\n        if (afterComposite != null) {\n            filename += afterComposite.composeFilename();\n        }\n\n        return filename.trim();\n    }\n",
    "115699": "    public void setComposite(AbstractFilenameComposite composite) {\n        this.composite = composite;\n    }\n",
    "115701": "    static public long getWholeNumber(Object value) {\n        long number;\n\n        if (value instanceof String) {\n            number = Long.parseLong((String) value);\n        } else if (value instanceof Byte) {\n            number = ((Byte) value).byteValue();\n        } else if (value instanceof Short) {\n            number = ((Short) value).shortValue();\n        } else if (value instanceof Integer) {\n            number = ((Integer) value).intValue();\n        } else if (value instanceof Long) {\n            number = ((Long) value).longValue();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported value class: \" + value.getClass().getName());\n        }\n\n        return number;\n    }\n",
    "115703": "    public AbstractFilenameComposite getComposite() {\n        return composite;\n    }\n",
    "115709": "    public void setId3v2FrameBodyClass(Class id3v2FrameBodyClass) {\n        this.id3v2FrameBodyClass = id3v2FrameBodyClass;\n    }\n",
    "115710": "    public void setFrame(AbstractID3v2Frame frame) {\n        if (frame != null) {\n            if (id3tag == null) {\n                id3tag = new ID3v2_4();\n            }\n\n            id3tag.setFrame(frame);\n\n            if (composite != null) {\n                composite.setFrame(frame);\n            }\n        }\n    }\n",
    "115711": "    public Class getId3v2FrameBodyClass() {\n        return id3v2FrameBodyClass;\n    }\n",
    "115712": "    public AbstractID3v2Frame getFrame(String identifier) {\n        if (id3tag != null) {\n            return id3tag.getFrame(identifier);\n        }\n\n        return null;\n    }\n",
    "115713": "    public void setToken(String token) {\n        this.token = token.trim();\n    }\n",
    "115716": "    public String getToken() {\n        return token;\n    }\n",
    "115717": "    public void setId3tag(ID3v2_4 id3tag) {\n        this.id3tag = id3tag;\n\n        if (id3tag != null) {\n            Iterator iterator = id3tag.iterator();\n\n            while (iterator.hasNext()) {\n                composite.setFrame((AbstractID3v2Frame) iterator.next());\n            }\n\n            if (composite != null) {\n                composite.matchAgainstTag(id3tag);\n            }\n        }\n    }\n",
    "115718": "    public String composeFilename() {\n        return token;\n    }\n",
    "115720": "    public ID3v2_4 getId3tag() {\n        return id3tag;\n    }\n",
    "115721": "    public Iterator iterator() {\n        return new FilenameTokenIterator(this);\n    }\n",
    "115728": "    public String toString() {\n        return id3v2FrameBodyClass + \": \" + token;\n    }\n",
    "115731": "    public boolean hasNext() {\n        boolean nextFlag = false;\n\n        if (beforeIterator != null) {\n            nextFlag = nextFlag || beforeIterator.hasNext();\n        }\n\n        if (afterIterator != null) {\n            nextFlag = nextFlag || afterIterator.hasNext();\n        }\n\n        return nextFlag;\n    }\n",
    "115732": "    public Object next() {\n        if ((beforeIterator != null) && beforeIterator.hasNext()) {\n            return beforeIterator.next();\n        } else if ((afterIterator != null) && afterIterator.hasNext()) {\n            return afterIterator.next();\n        } else {\n            throw new NoSuchElementException(\"Iteration has no more elements.\");\n        }\n    }\n",
    "115734": "    public void remove() {\n        /**\n         * @todo Implement this java.util.Iterator method\n         */\n        throw new java.lang.UnsupportedOperationException(\"Method remove() not yet implemented.\");\n    }\n",
    "115737": "    public boolean hasNext() {\n        boolean nextFlag = false;\n\n        if (beforeIterator != null) {\n            nextFlag = nextFlag || beforeIterator.hasNext();\n        }\n\n        if (middleIterator != null) {\n            nextFlag = nextFlag || middleIterator.hasNext();\n        }\n\n        if (afterIterator != null) {\n            nextFlag = nextFlag || afterIterator.hasNext();\n        }\n\n        return nextFlag;\n    }\n",
    "115739": "    public Object next() {\n        if ((beforeIterator != null) && beforeIterator.hasNext()) {\n            return beforeIterator.next();\n        } else if ((middleIterator != null) && middleIterator.hasNext()) {\n            return middleIterator.next();\n        } else if ((afterIterator != null) && afterIterator.hasNext()) {\n            return afterIterator.next();\n        }\n\n        throw new NoSuchElementException(\"Iteration has no more elements.\");\n    }\n",
    "115742": "    public void setOriginalToken(String originalToken) {\n        this.originalToken = originalToken;\n    }\n",
    "115743": "    public String getOriginalToken() {\n        return originalToken;\n    }\n",
    "115744": "    public boolean hasNext() {\n        return returnedToken == false;\n    }\n",
    "115746": "    public Object next() {\n        if (returnedToken == false) {\n            returnedToken = true;\n\n            return filenameToken;\n        }\n\n        throw new NoSuchElementException(\"Iteration has no more elements.\");\n    }\n",
    "115748": "    static public String replaceEOLNwithCRLF(String text) {\n        String newText = null;\n\n        if (text != null) {\n            newText = \"\";\n\n            int oldPos = 0;\n            int newPos = text.indexOf('\\n');\n\n            while (newPos >= 0) {\n                newText += (text.substring(oldPos, newPos) + TagConstant.CRLF);\n                oldPos = ++newPos;\n                newPos = text.indexOf('\\n', oldPos);\n            }\n\n            newText += text.substring(oldPos);\n        }\n\n        return newText;\n    }\n",
    "115751": "    public void setMiddleComposite(AbstractFilenameComposite middleComposite) {\n        this.middleComposite = middleComposite;\n    }\n",
    "115753": "    public AbstractFilenameComposite getMiddleComposite() {\n        return middleComposite;\n    }\n",
    "115754": "    public void setOpenDelimiter(String openDelimiter) {\n        this.openDelimiter = openDelimiter;\n    }\n",
    "115756": "    public String getOpenDelimiter() {\n        return openDelimiter;\n    }\n",
    "115757": "    public String composeFilename() {\n        String filename = \"\";\n\n        if (beforeComposite != null) {\n            filename += beforeComposite.composeFilename();\n        }\n\n        filename += (\" \" + openDelimiter);\n\n        if (middleComposite != null) {\n            filename += middleComposite.composeFilename();\n        }\n\n        filename += (TagOptionSingleton.getInstance().getCloseParenthesis(openDelimiter) + \" \");\n\n        if (afterComposite != null) {\n            filename += afterComposite.composeFilename();\n        }\n\n        return filename;\n    }\n",
    "115761": "    public Iterator iterator() {\n        return new FilenameParenthesisIterator(this);\n    }\n",
    "115763": "    public void matchAgainstKeyword(Class id3v2FrameBodyClass) {\n        if (AbstractID3v2FrameBody.class.isAssignableFrom(id3v2FrameBodyClass)) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n\n            if (middleComposite != null) {\n                middleComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n        }\n    }\n",
    "115765": "    public void matchAgainstTag(AbstractMP3Tag matchTag) {\n        if (matchTag != null) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstTag(matchTag);\n            }\n\n            if (middleComposite != null) {\n                middleComposite.matchAgainstTag(matchTag);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstTag(matchTag);\n            }\n        }\n    }\n",
    "115771": "    static public String stripChar(String str, char ch) {\n        if (str != null) {\n            char[] buffer = new char[str.length()];\n            int    next = 0;\n\n            for (int i = 0; i < str.length(); i++) {\n                if (str.charAt(i) != ch) {\n                    buffer[next++] = str.charAt(i);\n                }\n            }\n\n            return new String(buffer, 0, next);\n        } else {\n            return null;\n        }\n    }\n",
    "115775": "    public void setAfterComposite(AbstractFilenameComposite afterComposite) {\n        this.afterComposite = afterComposite;\n    }\n",
    "115776": "    public AbstractFilenameComposite getAfterComposite() {\n        return afterComposite;\n    }\n",
    "115777": "    public void setBeforeComposite(AbstractFilenameComposite beforeComposite) {\n        this.beforeComposite = beforeComposite;\n    }\n",
    "115778": "    static public void updateCompositeFromAllOption(AbstractFilenameComposite composite) {\n        Iterator iterator = TagOptionSingleton.getInstance().getKeywordIterator();\n\n        while (iterator.hasNext()) {\n            composite.matchAgainstKeyword((Class) iterator.next());\n        }\n    }\n",
    "115779": "    public AbstractFilenameComposite getBeforeComposite() {\n        return beforeComposite;\n    }\n",
    "115780": "    public void setDelimiter(String delimiter) {\n        this.delimiter = delimiter;\n    }\n",
    "115781": "    static public void updateCompositeFromAllTag(AbstractFilenameComposite composite, MP3File mp3File) {\n        composite.matchAgainstTag(mp3File.getID3v1Tag());\n        composite.matchAgainstTag(mp3File.getID3v2Tag());\n        composite.matchAgainstTag(mp3File.getLyrics3Tag());\n    }\n",
    "115782": "    public String getDelimiter() {\n        return delimiter;\n    }\n",
    "115786": "    public String composeFilename() {\n        String filename = \"\";\n\n        if (beforeComposite != null) {\n            filename += beforeComposite.composeFilename();\n        }\n\n        filename += (delimiter + \" \");\n\n        if (afterComposite != null) {\n            filename += afterComposite.composeFilename();\n        }\n\n        return filename;\n    }\n",
    "115791": "    public Iterator iterator() {\n        return new FilenameDelimiterIterator(this);\n    }\n",
    "115794": "    public void matchAgainstKeyword(Class id3v2FrameBodyClass) {\n        if (AbstractID3v2FrameBody.class.isAssignableFrom(id3v2FrameBodyClass)) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstKeyword(id3v2FrameBodyClass);\n            }\n        }\n    }\n",
    "115797": "    public void matchAgainstTag(AbstractMP3Tag matchTag) {\n        if (matchTag != null) {\n            if (beforeComposite != null) {\n                beforeComposite.matchAgainstTag(matchTag);\n            }\n\n            if (afterComposite != null) {\n                afterComposite.matchAgainstTag(matchTag);\n            }\n        }\n    }\n",
    "115820": "    static private StringBuffer capitalizeWord(String word, boolean keepUppercase) {\n        if (word == null) {\n            return null;\n        }\n\n        StringBuffer wordBuffer = new StringBuffer();\n        int          index = 0;\n\n        if (keepUppercase && word.toUpperCase().equals(word)) {\n            wordBuffer.append(word);\n        } else {\n            word = word.toLowerCase();\n\n            int  len = word.length();\n            char ch;\n            ch = word.charAt(index);\n\n            while (((ch < 'a') || (ch > 'z')) && (index < (len - 1))) {\n                ch = word.charAt(++index);\n            }\n\n            if (index < len) {\n                wordBuffer.append(word.substring(0, index));\n                wordBuffer.append((char) (ch + uppercase));\n                wordBuffer.append(word.substring(index + 1));\n            } else {\n                wordBuffer.append(word);\n            }\n        }\n\n        return wordBuffer;\n    }\n",
    "116237": "    public DocPosition adjustPosition(int adjustment){\n        position += adjustment;\n        return this;\n    }\n",
    "116238": "    public boolean equals(Object obj){\n        if (obj instanceof DocPosition){\n            DocPosition d = (DocPosition)(obj);\n            if (this.position == d.position){\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n",
    "116241": "    public String toString(){\n        return \"\" + position;\n    }\n",
    "116242": "    public boolean equals(Object obj){\n    \treturn this == obj;\n    }\n",
    "116243": "    public int compare(Object o1, Object o2){\n        if (o1 instanceof DocPosition && o2 instanceof DocPosition){\n            DocPosition d1 = (DocPosition)(o1);\n            DocPosition d2 = (DocPosition)(o2);\n            return (d1.getPosition() - d2.getPosition());\n        } else if (o1 instanceof DocPosition){\n            return -1;\n        } else if (o2 instanceof DocPosition){\n            return 1;\n        } else if (o1.hashCode() < o2.hashCode()){\n            return -1;\n        } else if (o2.hashCode() > o1.hashCode()){\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n",
    "116248": "\tpublic void run() {\n\t\twhile(document.get() != null) {\n\t\t\ttry {\n\t\t\t\tRecolorEvent re;\n\t\t\t\tsynchronized (eventsLock) {\n\t\t\t\t\t// get the next event to process - stalling until the\n\t\t\t\t\t// event becomes available\n\t\t\t\t\twhile(events.isEmpty() && document.get() != null) {\n\t\t\t\t\t\t// stop waiting after a second in case document\n\t\t\t\t\t\t// has been cleared.\n\t\t\t\t\t\teventsLock.wait(1000);\n\t\t\t\t\t}\n\t\t\t\t\tre = (RecolorEvent) events.removeFirst();\n\t\t\t\t}\n\t\t\t\tprocessEvent(re.position, re.adjustment);\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch(Exception ex) { }\n\t\t}\n\t}\n",
    "116263": "\tpublic void colorAll() {\n\t\tcolor(0, getLength());\n\t}\n",
    "116264": "\tpublic void color(int position, int adjustment) {\n\t\tcolorer.color(position, adjustment);\n\t}\n",
    "116268": "    public void update(int position, int adjustment){\n        if (position < this.position){\n            if (this.position < position - adjustment){\n                this.position = position;\n            } else {\n                this.position += adjustment;\n            }\n        }\n    }\n",
    "116269": "    public void close() {\n    }\n",
    "116271": "    public void mark(int readAheadLimit){\n        mark = position;\n    }\n",
    "116272": "    public boolean markSupported(){\n        return true;\n    }\n",
    "116273": "    public int read(){\n        if (position < document.getLength()){\n            try {\n                char c = document.getText((int)position, 1).charAt(0);\n                position++;\n                return c;\n            } catch (BadLocationException x){\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n    }\n",
    "116275": "    public int read(char[] cbuf){\n        return read(cbuf, 0, cbuf.length);\n    }\n",
    "116276": "    public int read(char[] cbuf, int off, int len){\n        if (position < document.getLength()){\n            int length = len;\n            if (position + length >= document.getLength()){\n                length = document.getLength() - (int)position;\n            }\n            if (off + length >= cbuf.length){\n                length = cbuf.length - off;\n            }\n            try {\n                String s = document.getText((int)position, length);\n                position += length;\n                for (int i=0; i<length; i++){\n                    cbuf[off+i] = s.charAt(i);\n                }\n                return length;\n            } catch (BadLocationException x){\n                return -1;\n            }\n        } else {\n            return -1;\n        }\n    }\n",
    "116281": "    public long skip(long n){\n        if (position + n <= document.getLength()){\n            position += n;\n            return n;\n        } else {\n            long oldPos = position;\n            position = document.getLength();\n            return (document.getLength() - oldPos);\n        }\n    }\n",
    "116283": "    public void seek(long n){\n        if (n <= document.getLength()){\n            position = n;\n        } else {\n            position = document.getLength();\n        }\n    }\n",
    "116287": "    public boolean isReservedWord(){\n        return((id >> 8) == 0x1);\n    }\n",
    "116291": "    public boolean isIdentifier(){\n        return((id >> 8) == 0x2);\n    }\n",
    "116294": "    public boolean isLiteral(){\n        return((id >> 8) == 0x3);\n    }\n",
    "116299": "    public boolean isSeparator(){\n        return((id >> 8) == 0x4);\n    }\n",
    "116302": "    public boolean isOperator(){\n        return((id >> 8) == 0x5);\n    }\n",
    "116309": "    public boolean isComment(){\n        return((id >> 8) == 0xD);\n    }\n",
    "116315": "    public boolean isWhiteSpace(){\n        return((id >> 8) == 0xE);\n    }\n",
    "116320": "    public boolean isError(){\n        return((id >> 8) == 0xF);\n    }\n",
    "116325": "    public String getDescription(){\n        if (isReservedWord()){\n            return(\"reservedWord\");\n        } else if (id == METHOD){\n            return(\"method\");\n        } else if (isIdentifier()){\n            return(\"identifier\");\n        } else if (isLiteral()){\n            return(\"literal\");\n        } else if (isSeparator()){\n            return(\"separator\");\n        } else if (isOperator()){\n            return(\"operator\");\n        } else if (isComment()){\n            return(\"comment\");\n        } else if (isWhiteSpace()){\n            return(\"whitespace\");\n        } else if (isError()){\n            return(\"error\");\n        } else {\n            return(\"unknown\");\n        }\n    }\n",
    "116711": "    public void close() {\n\ttry {\n            file.close();\n            file = null;\n        }\n        catch (Exception e) { }\n    }\n",
    "116716": "    public Country getCountry(String ipAddress) {\n\tInetAddress addr;\n\ttry {\n\t    addr = InetAddress.getByName(ipAddress);\n\t}\n\tcatch (UnknownHostException e) {\n            return UNKNOWN_COUNTRY;\n\t}\n\treturn getCountry(bytesToLong(addr.getAddress()));\n    }\n",
    "116721": "    public boolean isPremium() {\n        return info.indexOf(\"FREE\") < 0;\n    }\n",
    "116722": "    public Date getDate() {\n        for (int i=0; i<info.length()-9; i++) {\n            if (Character.isWhitespace(info.charAt(i))) {\n                String dateString = info.substring(i+1, i+9);\n                try {\n                    synchronized (formatter) {\n                        return formatter.parse(dateString);\n                    }\n                }\n                catch (ParseException pe) {  }\n                break;\n            }\n        }\n        return null;\n    }\n",
    "116724": "    public Country getCountry(InetAddress ipAddress) {\n        return getCountry(bytesToLong(ipAddress.getAddress()));\n    }\n",
    "116727": "    public String getCode() {\n        return code;\n    }\n",
    "116733": "    public Country getCountry(long ipAddress) {\n        if (file == null) {\n            throw new IllegalStateException(\"Database has been closed.\");\n        }\n        int ret = seekCountry(ipAddress) - COUNTRY_BEGIN;\n        if (ret == 0) {\n            return UNKNOWN_COUNTRY;\n        }\n        else {\n            return new Country(countryCode[ret], countryName[ret]);\n        }\n    }\n",
    "116854": "\tpublic void init(IStructuredSelection selection) {\n\t\tIJavaElement jelem= getInitialJavaElement(selection);\n\t\tinitContainerPage(jelem);\n\t\tinitTypePage(jelem);\n\t\tdoStatusUpdate();\n\t}\n",
    "117158": "\tpublic void start(BundleContext context) throws Exception {\n\t    System.out.println(\"Starting JMX Console UI\");\n\t\tsuper.start(context);\n\t\tbundleContext = context;\n\t}\n",
    "117161": "\tpublic void stop(BundleContext context) throws Exception {\n\t\tsuper.stop(context);\n\t\tgetPreferences().flush();\n\t}\n",
    "117164": "\tpublic Preferences getPreferences() {\n\t\tIPreferencesService service = Platform.getPreferencesService();\n\t\tIEclipsePreferences root = service.getRootNode();\n\t\treturn root.node(InstanceScope.SCOPE).node(getBundle().getSymbolicName());\n\t}\n",
    "117170": "\tpublic void addChild(NodeAbstract child) {\n\t\tchildren.add(child);\t\n\t\tchild.setParent(this);\n\t}\n",
    "117172": "\tpublic void removeChild(NodeAbstract child) {\n\t\tchildren.remove(child);\n\t\tchild.setParent(null);\n\t}\n",
    "117175": "\tpublic boolean hasChildren() {\n\t\treturn children.size() > 0;\n\t}\n",
    "117177": "\tpublic void removeAllChildren () {\n\t\tchildren.clear();\n\t}\n",
    "117186": "\tpublic void setParent(NodeAbstract parent) {\n\t\tthis.parent = parent;\n\t}\n",
    "117188": "\tpublic NodeAbstract getParent() {\n\t\treturn parent;\n\t}\n",
    "117194": "\tpublic Object getAdapter(Class key) {\n\t    if (key.equals(NodeAbstract.class))\n\t        return this;\n\t\treturn null;\n\t}\n",
    "117197": "\tpublic void addServer(NodeServer server) {\n\t    modelChangedEventDisabled = true;\n\t\taddChild(server);\n\t\tpersistServer(server);\n\t\tmodelChangedEventDisabled = false;\n\t\temitModelChangeEvent(this);\t\t\n\t}\n",
    "117204": "\tpublic void removeServer(NodeServer server) {\n\t\t\n\t\tmodelChangedEventDisabled = true;\n\n\t\ttry { \n\t    //    server.disconnect();\n\t    } catch (Exception e) {}\n\t\tremoveChild(server);\n\t\ttry {\n\t\t    Preferences modelPrefs = getModelPrefNode();\n\t\t\tmodelPrefs.node(server.getName()).removeNode();\n        } catch (BackingStoreException e) {\n            System.out.println(\"Unable to save the model to disk: \" + e.getMessage());\n        }\n\n\t\tmodelChangedEventDisabled = false;\n\t\temitModelChangeEvent(this);\t\n\t}\n",
    "117208": "\tpublic void refresh() throws Exception {\n\t\tmodelChangedEventDisabled = true;\n\t\tObject[] servers = getChildren();\n\t\tfor (int i = 0; i < servers.length;  i++) {\n//\t\t\t((ChatAppsServer) servers[i]).refresh();\n\t\t}\n\t\tmodelChangedEventDisabled = false;\n\t\temitModelChangeEvent(this);\n\t}\n",
    "117220": "\tpublic void createPartControl(Composite parent) {\n\t\t// Create the tree viewer\n\t\tviewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);\n\t\tcontent = new ViewContentProvider(getViewSite(), model);\n\t\tviewer.setContentProvider(content);\n\t\tviewer.setLabelProvider(new ViewLabelProvider());\n//\t\tviewer.setSorter(new NameSorter());\n\t\tviewer.setInput(getViewSite());\n\t\t\n\t\t// Register with the model change listener\n\t\tmodel.addModelChangeListener(this);\n\t\t\n\t\t// Build the GUI\n\t\tmakeActions();\n\t\thookContextMenu();\n\t\thookSelectionChangedAction();\n\t\tcontributeToActionBars();\n\t}\n",
    "117229": "\tprivate void hookContextMenu() {\n\t\tMenuManager menuMgr = new MenuManager(\"#PopupMenu\");\n\t\tmenuMgr.setRemoveAllWhenShown(true);\n\t\tmenuMgr.addMenuListener(new IMenuListener() {\n\t\t\tpublic void menuAboutToShow(IMenuManager manager) {\n\t\t\t\tServerView.this.fillContextMenu(manager);\n\t\t\t}\n\t\t});\n\t\tMenu menu = menuMgr.createContextMenu(viewer.getControl());\n\t\tviewer.getControl().setMenu(menu);\n\t\tgetSite().registerContextMenu(menuMgr, viewer);\n\t}\n",
    "117242": "\tprivate void contributeToActionBars() {\n\t\tIActionBars bars = getViewSite().getActionBars();\n\t\tfillLocalPullDown(bars.getMenuManager());\n\t\tfillLocalToolBar(bars.getToolBarManager());\n\t}\n",
    "117247": "\tprotected Control createContents(Composite parent) {\n\t\tIProject project = (IProject) (this.getElement().getAdapter(IProject.class));\n\t\tchatappsProject = ChatAppsPlugin.getChatAppsProject(project);  \n\t\t\t\t\n\t\tComposite composite = new Composite(parent, SWT.NULL);\n\t\tcomposite.setLayout(new GridLayout(3, false));\n\t\tcomposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n\n\t\tcreateDomainName(composite);\n\t\tcreateFacadeClass(composite);\n\t\treturn composite;\n\t}\n",
    "117250": "\tprivate void fillLocalPullDown(IMenuManager manager) {\n\t\tmanager.add((Action) actionMap.get(AddServerAction.ID));\n//\t\tmanager.add((Action) actionMap.get(RemoveAction.ID));\n//\t\tmanager.add((Action) actionMap.get(RefreshAction.ID));\n\t\tmanager.add(new Separator());\n\t}\n",
    "117252": "\tpublic boolean performOk() {\n\t\ttry {\n\t\t\tchatappsProject.setDomainName(txtDomainName.getText());\n\t\t\tchatappsProject.setFacadeClass(txtFacadeClass.getText());\n\t\t\tchatappsProject.saveProperties();\n\t\t} catch (Exception ex) {\n\t\t\tChatAppsPlugin.log(ex.getMessage());\n\t\t}\n\n\t\treturn true;\n\t}\n",
    "117262": "\tprivate void fillLocalToolBar(IToolBarManager manager) {\n\t\tmanager.add((Action) actionMap.get(AddServerAction.ID));\n\t\tmanager.add(new Separator());\n\t}\n",
    "117271": "\tprivate void hookSelectionChangedAction() {\n\t\tfinal IWorkbenchPart workbenchPart = this;\n\t\tviewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\t\t\tpublic void selectionChanged(SelectionChangedEvent sce) {\n\t\t\t    Iterator iter = actionMap.values().iterator();\n\t\t\t    while (iter.hasNext()) \n\t\t\t        ((BaseAction) iter.next()).checkState();\n\t\t\t}\n\t\t});\n\t}\n",
    "117280": "\tprivate void showMessage(String message) {\n\t\tMessageDialog.openInformation(viewer.getControl().getShell(),\n\t\t\t\t\"JMX Server View\", message);\n\t}\n",
    "117282": "\tpublic void setCompletionProposalAutoActivationCharacters(char[] activationSet) {\n\t\tfProposalAutoActivationSet= activationSet;\n\t}\n",
    "117284": "\tpublic void addServer (NodeServer server) {\n\t\tmodel.addServer(server);\n\t}\n",
    "117285": "\tpublic void restrictProposalsToVisibility(boolean restrict) {\n\t\tHashtable options= JavaCore.getOptions();\n\t\tObject value= options.get(VISIBILITY);\n\t\tif (value instanceof String) {\n\t\t\tString newValue= restrict ? ENABLED : DISABLED;\n\t\t\tif ( !newValue.equals(value)) {\n\t\t\t\toptions.put(VISIBILITY, newValue);\n\t\t\t\tJavaCore.setOptions(options);\n\t\t\t}\n\t\t}\n\t}\n",
    "117288": "\tpublic void orderProposalsAlphabetically(boolean order) {\n\t\tfComparator.setOrderAlphabetically(order);\n\t}\n",
    "117289": "\tpublic void dispose() {\n//\t\tmodel.removeModelChangeListener(this);\n\t\tsuper.dispose();\n\t}\n",
    "117290": "\tpublic void restrictProposalsToMatchingCases(boolean restrict) {\n\t\t// not yet supported\n\t}\n",
    "117293": "\tpublic void setFocus() {\n\t\tviewer.getControl().setFocus();\n\t}\n",
    "117448": "    public  void checkState () {}\n",
    "117574": "    public void createInitialLayout(IPageLayout layout) {\n        defineActions(layout);\n        defineLayout(layout);\n    }\n",
    "117883": "\tpublic void actionPerformed(ActionEvent e) {\n\n\t\ttry {\t\t\n\t\t\tBrowserLauncher.openURL(\"http://www.jgpd.com/\");\t\t\n\t\t} catch (Exception ex){\n\t\t\tJOptionPane.showMessageDialog(graphpad, ex.toString(), Translator.getString(\"Error\"), JOptionPane.ERROR_MESSAGE );\n\t\t}\n\t\t\n\t}\n",
    "117886": "\tpublic void actionPerformed(ActionEvent e) {\n\n\t\ttry {\t\t\n\t\t\tBrowserLauncher.openURL(\"http://sourceforge.net/tracker/?func=add&group_id=90011&atid=592210\");\t\t\n\t\t} catch (Exception ex){\n\t\t\tJOptionPane.showMessageDialog(graphpad, ex.toString(), Translator.getString(\"Error\"), JOptionPane.ERROR_MESSAGE );\n\t\t}\n\t\t\n\t}\n",
    "117898": "\tpublic void clear() {\n\t\trootNode.removeAllChildren();\n\t\ttreeModel.reload();\n\t}\n",
    "117901": "\tpublic void removeCurrentNode() {\n\t\tTreePath currentSelection = tree.getSelectionPath();\n\t\tif (currentSelection != null) {\n\t\t\tDefaultMutableTreeNode currentNode = (DefaultMutableTreeNode)\n\t\t\t\t\t\t (currentSelection.getLastPathComponent());\n\t\t\tMutableTreeNode parent = (MutableTreeNode)(currentNode.getParent());\n\t\t\tif (parent != null) {\n\t\t\t\ttreeModel.removeNodeFromParent(currentNode);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} \n\n\t\t// Either there was no selection, or the root was selected.\n\t\t// FIXME\n\t}\n",
    "117904": "\tpublic DefaultMutableTreeNode addObject(Object child) {\n\t\tDefaultMutableTreeNode parentNode = null;\n\t\tTreePath parentPath = tree.getSelectionPath();\n\n\t\tif (parentPath == null) {\n\t\t\tparentNode = rootNode;\n\t\t} else {\n\t\t\tparentNode = (DefaultMutableTreeNode)\n\t\t\t\t\t\t (parentPath.getLastPathComponent());\n\t\t}\n\n\t\treturn addObject(parentNode, child, true);\n\t}\n",
    "117949": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tif (EDIT.equals(e.getActionCommand())) {\n\t\t\t//The user has clicked the cell, so\n\t\t\t//bring up the dialog.\n//\t\t\tbutton.setBackground(currentColor);\n//\t\t\tcolorChooser.setColor(currentColor);\n\t\t\t//Set up the dialog that the button brings up.\n\t\t\tdialog = new File_PackageWizard(frame, // owner frame\n\t\t\t\t\t\t\t\t\t\t\tnew String(\"File Selection Wizard\"),\n\t\t\t\t\t\t\t\t\t\t\t600,  // width\n\t\t\t\t\t\t\t\t\t\t\t350,  // height\n\t\t\t\t\t\t\t\t\t\t\t5,   // number of wizard screens\n\t\t\t\t\t\t\t\t\t\t\tthis);\n\t\t\tdialog.setModal(true);\n\t\t\tdialog.setVisible(true);\n\n\t\t\t//Make the renderer reappear.\n\t\t\tfireEditingStopped();\n\n\t\t}\n\t}\n",
    "118318": "\tpublic Object clone() {\n\t\tJGpdGraphCell c = (JGpdGraphCell) super.clone();\n\t\treturn c;\n\t}\n",
    "118322": "\tprotected Object cloneUserObject() {\n\t\tif (userObject instanceof ValueChangeHandler)\n\t\t\treturn ((ValueChangeHandler) userObject).clone();\n\t\treturn userObject;\n\t}\n",
    "118327": "    public String toString() {\n        return \"Spring Embedded\";\n    }\n",
    "118332": "    public LayoutAlgorithm getLayoutAlgorithm() {\n        return new SpringEmbeddedLayoutAlgorithm();\n    }\n",
    "118338": "    protected boolean isTrue(String boolValue){\n        if( boolValue != null ){\n            if( \"TRUE\".equals(boolValue.toUpperCase()) ){\n                return true;\n            }\n            else if( \"FALSE\".equals(boolValue.toUpperCase()) ){\n                return false;\n            }\n        }\n        return false;\n    }\n",
    "118341": "    private void action_cancel() {\n        setVisible(false);\n        dispose();\n        canceled = true;\n    }\n",
    "118352": "    public boolean isCanceled() {\n        return canceled;\n    }\n",
    "118354": "    private boolean initialize(){\n        \n        dlgProgress.setVisible(true);\n        dlgProgress.setMessage(phaseName[PHASE_INITIALISATION]);\n        \n        int length = cellList.size();\n        \n        for( int i = 0; i < length; i++ ){\n            \n            CellView view = (CellView) cellList.get(i);\n            \n            initializeVertice(view);\n            \n            if( updateProgressDialog(PHASE_INITIALISATION,\n                                     i,\n                                     length) )\n                                     \n                return true; // canceled        \n        }\n        \n        for( int i = 0; i < applyCellList.size(); i++ )\n            computeLastImpulse( (CellView) applyCellList.get(i) );\n            \n        return false;    //not canceled\n    }\n",
    "118360": "    private void initializeVertice(CellView view){\n            Map attributes = view.getAttributes();\n            if( attributes == null )\n                attributes = new Hashtable();\n                \n            attributes.put(KEY_CAPTION,KEY_CAPTION);\n            \n            initPosition(view);                       \n\n            if( isCluster(view) ){\n                attributes.put(KEY_TEMPERATURE,\n                               new Double(clusterInitTemperature));\n            }\n            else attributes.put(KEY_TEMPERATURE,\n                                new Double(initTemperature));\n            \n            attributes.put(KEY_SKEWGAUGE,  new Double(0.0));\n            attributes.put(KEY_CURRENT_IMPULSE,new Point2D.Double());\n            attributes.put(KEY_LAST_IMPULSE   ,new Point2D.Double());\n    }\n",
    "118368": "    private boolean updateProgressDialog(int phase, int round, int maxRound){\n        \n        int lowValue = 0;\n        if( phase != 0 ) \n            lowValue = phaseLength[phase-1];\n        \n        int maxValue = phaseLength[phase];\n        \n        int width = maxValue - lowValue;\n        \n        int value = lowValue+(int)(width*((double)round/(double)maxRound));\n        \n        dlgProgress.setValue(value);\n        \n        return dlgProgress.isCanceled();\n    }\n",
    "118372": "    private void computeCurrentImpulse(CellView view){\n        \n        //gets the impulse for view\n        Point2D.Double impulse = computeImpulse(view);\n        \n        //set result into node\n        view.getAttributes().put(KEY_CURRENT_IMPULSE,impulse);\n    }\n",
    "118377": "    private void computeLastImpulse(CellView view){\n        \n        //gets the impulse for view\n        Point2D.Double impulse = computeImpulse(view);\n        \n        //set result into node\n        view.getAttributes().put(KEY_LAST_IMPULSE,impulse);\n    }\n",
    "118393": "    private void closeDialog() {\n        action_cancel();\n    }\n",
    "118400": "    private void removeTemporaryLayoutDataFromCells(){\n        \n        for( int i = 0; i < cellList.size(); i++ )\n            ((CellView)cellList.get(i)).getAttributes().clear();\n    }\n",
    "118410": "    private void correctCoordinates(){\n        Rectangle boundingBox = getBoundingBox();\n        if( boundingBox != null ){\n            for( int i = 0; i < cellList.size(); i++ ){\n                CellView view = (CellView) cellList.get(i);\n                Point2D.Double pos = getPosition(view);\n                Point2D.Double newPos = new Point2D.Double(\n                                                      pos.x-boundingBox.getX(),\n                                                      pos.y-boundingBox.getY());\n                view.getAttributes().put(KEY_POSITION,newPos);\n            }\n        }\n    }\n",
    "118414": "    private Rectangle getBoundingBox(){\n        return getBoundingBox(cellList);\n    }\n",
    "118421": "    private double getTemperature(int index, ArrayList list){\n        \n        Double temperature = (Double) getAttribute(index,KEY_TEMPERATURE,list);\n        return temperature.doubleValue();\n    }\n",
    "118438": "    protected ArrayList getAdditionalForces(VertexView view){\n        return new ArrayList();\n    }\n",
    "118453": "    protected void computeClusterPosition(VertexView cluster){\n        ArrayList clusteredVertices = (ArrayList)cluster.getAttributes().get(KEY_CLUSTERED_VERTICES);\n        Point2D.Double clusterPos = computeBarycenter(clusteredVertices);\n        cluster.getAttributes().put(KEY_POSITION,clusterPos);\n    }\n",
    "118459": "    protected boolean isCluster(CellView cell){\n        if( cell.getAttributes().containsKey(KEY_IS_CLUSTER)){\n            if( isTrue((String)cell.getAttributes().get(KEY_IS_CLUSTER))){\n                return true;\n            }\n            else {\n                System.err.println(\"FATAL ERROR: CELL CANNOT CLEARLY BE IDENTIFIED AS A CLUSTER!!!\");\n                return false;\n            }        \n        }\n        else return false;        \n    }\n",
    "118473": "\tprotected double fa(double x, double k) {\n\t\tdouble force = (x * x / k);\n\t\treturn force;\n\t}\n",
    "118475": "\tprotected double fr(double x, double k) {\n\t\tdouble force = (k * k) / x;\n\t\treturn force;\n\t}\n",
    "118476": "\tprotected double norm(Rectangle p) {\n\t\tdouble x = p.x;\n\t\tdouble y = p.y;\n\t\tdouble norm = Math.sqrt(x * x + y * y);\n\t\treturn norm;\n\t}\n",
    "118485": "    private void action_ok() {\n        try {\n            Integer.parseInt(horizontalSpacingTextField.getText());\n            Integer.parseInt(verticalSpacingTextField.getText());\n        } catch (Exception e) {\n\t\t\tString message = Translator.getString(\"Error.SpacingMustBeNumbers\"/*#Finished:Original=\"Spacing must be numbers\"*/);\n            JOptionPane.showMessageDialog(this, message, Translator.getString(\"Error\"), JOptionPane.INFORMATION_MESSAGE);\n            return;\n        }\n        setVisible(false);\n        dispose();\n        canceled = false;\n    }\n",
    "118486": "    public boolean canceled() {\n        return canceled;\n    }\n",
    "118487": "    public String getIndention() {\n        return horizontalSpacingTextField.getText().trim();\n    }\n",
    "118488": "    public String getVerticalSpacing() {\n        return verticalSpacingTextField.getText().trim();\n    }\n",
    "118489": "    public void setIndention(String text) {\n        horizontalSpacingTextField.setText(text);\n    }\n",
    "118490": "    public void setVerticalSpacing(String text) {\n        verticalSpacingTextField.setText(text);\n    }\n",
    "118506": "    public boolean performOptimization(ArrayList applyList, ArrayList allCellList, ArrayList allEdgeList, Properties config, ProgressDialog dialog){\n        cellList  = allCellList;\n        applyCellList = applyList;\n        edgeList = allEdgeList;\n        \n        presetConfig = config;\n        \n        dlgProgress = dialog;\n        initProgressValue = dialog.getValue();\n\n        loadConfiguration(CONFIG_KEY_RUN);\n        \n        init(false);\n        boolean isCancled = run();\n        \n        return isCancled;\n    }\n",
    "118512": "    protected void loadAdditionalConfiguration(int configSwitch){\n    }\n",
    "118524": "    private void removeTemporaryData(){\n        for( int i = 0; i < applyCellList.size(); i++ )\n            ((CellView)applyCellList.get(i)).getAttributes().clear();        \n    }\n",
    "118530": "    private boolean run(){\n        boolean isCancled = false;\n        while( round <= maxRounds && !isCancled)\n            isCancled = performRound();\n        return isCancled;\n    }\n",
    "118539": "    protected double getAdditionalCosts(int cfConfig, double[] lambda){\n        return 0.0;\n    }\n",
    "118542": "    private boolean getBolzmanBreak(double oldEnergy, double newEnergy){\n        return Math.random() < Math.pow(Math.E,(oldEnergy-newEnergy)/temperature);\n    }\n",
    "118544": "    private int getMaxRoundsByTemperature(double actualTemperature){\n        return (int)Math.ceil( Math.log(minTemperature/actualTemperature) /\n                                Math.log(tempScaleFactor));\n    }\n",
    "118568": "    private ArrayList getRelevantEdges(CellView except){\n        ArrayList relevantEdgeList = new ArrayList();\n        for( int i = 0; i < edgeList.size(); i++ ){\n            CellView view = ((EdgeView)edgeList.get(i)).getSource().getParentView();\n            if( view != except &&\n                applyCellList.contains(view) ){\n                relevantEdgeList.add(edgeList.get(i));\n            }\n            else {\n                view = ((EdgeView)edgeList.get(i)).getTarget().getParentView();\n                if( view != except &&\n                    applyCellList.contains(view) ){\n                    relevantEdgeList.add(edgeList.get(i));\n                }\n            }\n        }\n        return relevantEdgeList;\n    }\n",
    "118570": "    private void setPosition(CellView view, Point2D.Double pos){\n        setAttribute(view,KEY_POSITION,pos);\n    }\n",
    "118574": "    private void setPosition(int index, double x, double y){\n        setPosition((CellView)applyCellList.get(index),x,y);\n    }\n",
    "118579": "    private void setPosition(CellView view, double x, double y){\n        setPosition(view,new Point2D.Double(x,y));\n    }\n",
    "118582": "    private void setAttribute(CellView view,String key, Object obj){\n        if( view.getAttributes() == null )\n            view.setAttributes(new Hashtable());\n        Map attributes = view.getAttributes();\n        attributes.put(key,obj);\n    }\n",
    "118584": "    private Object getAttribute(CellView view, String key){\n        return view.getAttributes().get(key);\n    }\n",
    "118591": "    protected ArrayList getRelativesFrom(ArrayList list, CellView view){\n        ArrayList relatives = getRelatives(view);\n        ArrayList result    = new ArrayList();\n        for( int i = 0; i < relatives.size(); i++ )\n            if( list.contains(relatives.get(i)) )\n                result.add(relatives.get(i));\n        return result;\n    }\n",
    "118684": "        protected void init() {\n                // netbeans\n                initComponents();\n\n                // fill the list\n                fillList();\n\n                // select the first one\n                try {\n                        lstLayoutControllers.setSelectedIndex(0);\n                } catch (Exception e) {\n                }\n        }\n",
    "118685": "        protected void fillList() {\n                try {\n                        DefaultListModel model = new DefaultListModel();\n                        Iterator all = LayoutRegistry.registeredLayoutControllers();\n\n                        while (all.hasNext()) {\n                                LayoutController controller = (LayoutController) all.next();\n                                model.addElement(controller);\n                        }\n                        \n                        \n                        lstLayoutControllers.setModel(model);\n                } catch (Exception e) {\n                        e.printStackTrace();\n                }\n        }\n",
    "118686": "        protected void cancel() {\n                canceled = true;\n                setVisible(false);\n                dispose();\n        }\n",
    "118687": "        protected void finish() {\n                canceled = false;\n                setVisible(false);\n                dispose();\n        }\n",
    "118689": "        protected void configure() {\n                try {\n                        LayoutController controller =\n                                (LayoutController) lstLayoutControllers.getSelectedValue();\n                        if (!controller.isConfigurable()) {\n                                String message = Translator.getString(\"Error.ThisLayoutCannotBeConfigured\"); /*#Finished: \"This Layout cannot be configured.\"*/\n                                JOptionPane.showMessageDialog(\n                                        this,\n                                        message,\n                                        null,\n                                        JOptionPane.INFORMATION_MESSAGE);\n                                return;\n                        }\n                        controller.configure();\n                } catch (Exception e) {\n                        e.printStackTrace();\n                }\n        }\n",
    "118692": "        public LayoutController getSelectedLayoutController() {\n                try {\n                        return (LayoutController) lstLayoutControllers.getSelectedValue();\n                } catch (Exception e) {\n                        return null;\n                }\n        }\n",
    "118703": "        protected void closeDialog(\n                java.awt.event.WindowEvent evt) { //GEN-FIRST:event_closeDialog\n                cancel();\n        } //GEN-LAST:event_closeDialog\n",
    "118722": "\tprotected void displayEdgeCrossesValues(Vector levels) {\n\t\tSystem.out.println(\"----------------Edge Crosses Indicator Values\"\n\t\t/*#Frozen*/\n\t\t);\n\n\t\tfor (int i = 0; i < levels.size() - 1; i++) {\n\t\t\t// Get the current level\n\t\t\tVector currentLevel = (Vector) levels.get(i);\n\t\t\tSystem.out.print(\"Level (\" + i + \"):\" /*#Frozen*/\n\t\t\t);\n\t\t\tfor (int j = 0; j < currentLevel.size(); j++) {\n\t\t\t\tCellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);\n\n\t\t\t\tSystem\n\t\t\t\t\t.out\n\t\t\t\t\t.print(\n\t\t\t\t\t\tNumberFormat.getNumberInstance().format(\n\t\t\t\t\t\t\tsourceWrapper.getEdgeCrossesIndicator())\n\t\t\t\t\t\t+ \" - \" /*#Frozen*/\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n",
    "118724": "\tprotected void displayGridPositions(Vector levels) {\n\n\t\tSystem.out.println(\"----------------GridPositions\" /*#Frozen*/\n\t\t);\n\n\t\tfor (int i = 0; i < levels.size() - 1; i++) {\n\t\t\t// Get the current level\n\t\t\tVector currentLevel = (Vector) levels.get(i);\n\t\t\tSystem.out.print(\"Level (\" + i + \"):\" /*#Frozen*/\n\t\t\t);\n\t\t\tfor (int j = 0; j < currentLevel.size(); j++) {\n\t\t\t\tCellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);\n\t\t\t\tSystem\n\t\t\t\t\t.out\n\t\t\t\t\t.print(\n\t\t\t\t\t\tNumberFormat.getNumberInstance().format(\n\t\t\t\t\t\t\tsourceWrapper.getGridPosition())\n\t\t\t\t\t\t+ \" - \" /*#Frozen*/\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n",
    "118725": "\tprotected void displayPriorities(Vector levels) {\n\n\t\tSystem.out.println(\"----------------down Priorities\" /*#Frozen*/\n\t\t);\n\n\t\tfor (int i = 0; i < levels.size() - 1; i++) {\n\t\t\t// Get the current level\n\t\t\tVector currentLevel = (Vector) levels.get(i);\n\t\t\tSystem.out.print(\"Level (\" + i + \"):\" /*#Frozen*/\n\t\t\t);\n\t\t\tfor (int j = 0; j < currentLevel.size(); j++) {\n\t\t\t\tCellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);\n\t\t\t\tSystem.out.print(sourceWrapper.getPriority() +\n\t\t\t\t/*\" (\" +\n\t\t\t\t                   sourceWrapper.nearestDownNeighborLevel + \") \" +*/\n\t\t\t\t\" - \" /*#Frozen*/\n\t\t\t\t);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n",
    "118735": "\tprotected void updateProgress4Movements() {\n\t\t// adds the current loop count\n\t\tmovements.add(new Integer(movementsCurrentLoop));\n\t\titeration++;\n\n\t\t// if the current loop count is higher than the max movements count\n\t\t// memorize the new max\n\t\tif (movementsCurrentLoop > movementsMax) {\n\t\t\tmovementsMax = movementsCurrentLoop;\n\t\t}\n\n\t\t// Calculate the new progress\n\t\tif (movements.size() > 1) {\n\t\t\tdlgProgress.setValue(movements.size() - 1);\n\t\t}\n\t}\n",
    "118773": "\tpublic void setMinimum(int min) {\n\t\tpbProgressSum.setMinimum(min);\n\t}\n",
    "118774": "\tpublic void setMaximum(int max) {\n\t\tpbProgressSum.setMaximum(max);\n\t}\n",
    "118775": "\tpublic void setToMaximum() {\n\t\tsetValue(pbProgressSum.getMaximum());\n\t}\n",
    "118776": "\tpublic boolean isDataFlavorSupported(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = getTransferDataFlavors();\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118777": "\tpublic void setValue(int value) {\n\t\tpbProgressSum.setValue(value);\n\n\t\tlblProgressSumVal.setText(\n\t\t\tjava.text.NumberFormat.getInstance().format(\n\t\t\t\tMath.round(pbProgressSum.getPercentComplete() * 100))\n\t\t\t\t+ \"%\");\n\t}\n",
    "118780": "\tpublic int getValue() {\n\t\treturn pbProgressSum.getValue();\n\t}\n",
    "118782": "\tpublic void setMessage(String message) {\n\t\tlblMessage.setText(message);\n\t}\n",
    "118784": "\tpublic boolean isCanceled() {\n\t\treturn isCanceled;\n\t}\n",
    "118785": "\tprotected boolean isHTMLFlavor(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = htmlFlavors;\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118786": "\tpublic void setCancelVisible(boolean visible) {\n\t\tcmdCancel.setVisible(visible);\n\t}\n",
    "118787": "\tprotected boolean isHTMLSupported() {\n\t\treturn false;\n\t}\n",
    "118788": "\tpublic void setCancelEnabled(boolean enabled) {\n\t\tcmdCancel.setEnabled(enabled);\n\t}\n",
    "118789": "\tpublic JButton getCancelButton() {\n\t\treturn cmdCancel;\n\t}\n",
    "118790": "\tprotected String getHTMLData() {\n\t\treturn null;\n\t}\n",
    "118791": "\tprotected void saveComponentState(JComponent c) {\n\t}\n",
    "118792": "\tprotected boolean isPlainFlavor(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = plainFlavors;\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118794": "\tprotected void restoreComponentState(JComponent c) {\n\t}\n",
    "118795": "\tprotected boolean isPlainSupported() {\n\t\treturn false;\n\t}\n",
    "118796": "\tprotected void restoreComponentStateForDrop(JComponent c) {\n\t}\n",
    "118797": "\tprotected void updateInsertionLocation(JComponent c, Point p) {\n\t}\n",
    "118798": "\tprotected String getPlainData() {\n\t\treturn null;\n\t}\n",
    "118799": "\tprivate void initPropertiesIfNecessary() {\n\t\tif (timer == null) {\n\t\t\tToolkit t = Toolkit.getDefaultToolkit();\n\t\t\tInteger initial = new Integer(100);\n\t\t\tInteger interval = new Integer(100);\n\n\t\t\ttry {\n\t\t\t\tinitial =\n\t\t\t\t\t(Integer) t.getDesktopProperty(\n\t\t\t\t\t\t\"DnD.Autoscroll.initialDelay\");\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tinterval =\n\t\t\t\t\t(Integer) t.getDesktopProperty(\"DnD.Autoscroll.interval\");\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\ttimer = new Timer(interval.intValue(), this);\n\n\t\t\ttimer.setCoalesce(true);\n\t\t\ttimer.setInitialDelay(initial.intValue());\n\n\t\t\ttry {\n\t\t\t\thysteresis =\n\t\t\t\t\t((Integer) t\n\t\t\t\t\t\t.getDesktopProperty(\"DnD.Autoscroll.cursorHysteresis\"))\n\t\t\t\t\t\t.intValue();\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t}\n",
    "118800": "\tprotected boolean isStringFlavor(DataFlavor flavor) {\n\t\tDataFlavor[] flavors = stringFlavors;\n\t\tfor (int i = 0; i < flavors.length; i++) {\n\t\t\tif (flavors[i].equals(flavor)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "118806": "\tprivate void cleanup() {\n\t\tif (timer != null) {\n\t\t\ttimer.stop();\n\t\t}\n\t\tcomponent = null;\n\t\tlastPosition = null;\n\t}\n",
    "118807": "\tprotected void setModel(GraphModel model) {\n\t\tcancelEditing(graph);\n\t\tif (graphModel != null && graphModelListener != null)\n\t\t\tgraphModel.removeGraphModelListener(graphModelListener);\n\t\tgraphModel = model;\n\t\tif (graphModel != null && graphModelListener != null)\n\t\t\tgraphModel.addGraphModelListener(graphModelListener);\n\t\tif (graphModel != null) // jmv : to avoid NullPointerException \n\t\t\tupdateSize();\n\t}\n",
    "118808": "\tprotected JFrame createFrame() {\n\t\t/*\n\t\tJFrame frame = new JFrameP() {\n\t\t\tpublic String getInstanceID() {\n\t\t\t\treturn this.getClass().getName();\n\t\t\t}\n\t\t\tpublic String getNameSpace() {\n\t\t\t\treturn \"JGraphPad\";\n\t\t\t}\n\t\t};\n\t\t*/\n\t\tGPFrame gpframe = new GPFrame();\n\t\tgpframe.setName(\"MainGraphpad\");\n\n\t\treturn gpframe;\n\t}\n",
    "118812": "\tprotected void setGraphLayoutCache(GraphLayoutCache view) {\n\t\tcancelEditing(graph);\n\t\tif (graphLayoutCache != null && graphViewObserver != null)\n\t\t\tgraphLayoutCache.deleteObserver(graphViewObserver);\n\t\tgraphLayoutCache = view;\n\t\tif (graphLayoutCache != null && graphViewObserver != null)\n\t\t\tgraphLayoutCache.addObserver(graphViewObserver);\n\t\tupdateSize();\n\t}\n",
    "118816": "\tprotected void setMarquee(BasicMarqueeHandler marqueeHandler) {\n\t\tmarquee = marqueeHandler;\n\t}\n",
    "118817": "\tpublic ActionMap getCurrentActionMap() {\n\t\treturn currentActionMap;\n\t}\n",
    "118820": "\tpublic Frame getFrame() {\n\t\tfor (Container p = getParent(); p != null; p = p.getParent()) {\n\t\t\tif (p instanceof Frame) {\n\t\t\t\treturn (Frame) p;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "118821": "\tprotected void setSelectionModel(GraphSelectionModel newLSM) {\n\t\tcancelEditing(graph);\n\t\tif (graphSelectionListener != null && graphSelectionModel != null)\n\t\t\tgraphSelectionModel.removeGraphSelectionListener(\n\t\t\t\tgraphSelectionListener);\n\t\tgraphSelectionModel = newLSM;\n\t\tif (graphSelectionModel != null && graphSelectionListener != null)\n\t\t\tgraphSelectionModel.addGraphSelectionListener(\n\t\t\t\tgraphSelectionListener);\n\t\tif (graph != null)\n\t\t\tgraph.repaint();\n\t}\n",
    "118825": "\tpublic CellHandle getHandle(JGraph graph) {\n\t\treturn handle;\n\t}\n",
    "118827": "\tpublic void error(String message) {\n\t\tJOptionPane.showMessageDialog(\n\t\t\tthis,\n\t\t\tmessage,\n\t\t\tappTitle,\n\t\t\tJOptionPane.ERROR_MESSAGE);\n\t}\n",
    "118828": "\tpublic GPGraph getCurrentGraph() {\n\t\tGPDocument doc = getCurrentDocument();\n\t\tif (doc == null)\n\t\t\treturn null;\n\t\treturn doc.getGraph();\n\t}\n",
    "118829": "\tprotected Object getFocusedCell() {\n\t\tif (focus != null)\n\t\t\treturn focus.getCell();\n\t\treturn null;\n\t}\n",
    "118833": "\tpublic ModelExportImpl getExportModel() {\n\t\tGPDocument doc = getCurrentDocument();\n\t\tif (doc == null)\n\t\t\treturn null;\n\t\treturn doc.getExportModel();\n\t}\n",
    "118836": "\tpublic JInternalFrame getCurrentInternalFrame() {\n\t\tGPInternalFrame internalFrame =\n\t\t\t(GPInternalFrame) desktop.getSelectedFrame();\n\t\tif (internalFrame == null) {\n\t\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\t\tif (frames.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tframes[0].setSelected(true);\n\t\t\t\t\tinternalFrame = (GPInternalFrame) frames[0];\n\t\t\t\t} catch (PropertyVetoException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internalFrame == null)\n\t\t\treturn null;\n\t\treturn internalFrame;\n\t}\n",
    "118837": "\tpublic Point getInsertionLocation() {\n\t\treturn insertionLocation;\n\t}\n",
    "118839": "\tpublic GPDocument getCurrentDocument() {\n\t\tGPInternalFrame internalFrame =\n\t\t\t(GPInternalFrame) desktop.getSelectedFrame();\n\t\tif (internalFrame == null) {\n\t\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\t\tif (frames.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tframes[0].setSelected(true);\n\t\t\t\t\tinternalFrame = (GPInternalFrame) frames[0];\n\t\t\t\t} catch (PropertyVetoException e) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (internalFrame == null)\n\t\t\treturn null;\n\t\treturn internalFrame.getDocument();\n\t}\n",
    "118841": "\tpublic AbstractActionDefault getEditUndoAction() {\n\t\treturn (AbstractActionDefault) currentActionMap.get(\n\t\t\tUtilities.getClassNameWithoutPackage(EditUndo.class));\n\t}\n",
    "118842": "\tpublic void setInsertionLocation(Point p) {\n\t\tinsertionLocation = p;\n\t}\n",
    "118843": "\tpublic AbstractActionDefault getEditRedoAction() {\n\t\treturn (AbstractActionDefault) currentActionMap.get(\n\t\t\tUtilities.getClassNameWithoutPackage(EditRedo.class));\n\t}\n",
    "118856": "\tpublic void addGPInternalFrame(GPInternalFrame f) {\n\t\tdesktop.add(f);\n\t\ttry {\n\t\t\tf.setSelected(true);\n\t\t} catch (Exception ex) {\n\t\t}\n\t\tdoc2InternalFrame.put(f.getDocument(), f);\n\t}\n",
    "118862": "\tpublic void removeGPInternalFrame(GPInternalFrame f) {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf.setVisible(false);\n\t\tdesktop.remove(f);\n\t\tdoc2InternalFrame.remove(f.getDocument());\n\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\tif (frames.length > 0) {\n\t\t\ttry {\n\t\t\t\tframes[0].setSelected(true);\n\t\t\t} catch (PropertyVetoException e) {\n\t\t\t}\n\t\t}\n\t}\n",
    "118867": "\tpublic void exit() {\n\n\t\tif (!isApplet()) {\n\t\t\tSystem.exit(0);\n\t\t} else {\n\t\t\tgetApplet().exit(this);\n\t\t}\n\t}\n",
    "118868": "\tpublic void selectCellForEvent(Object cell, MouseEvent event) {\n\t\t// Toggle selection\n\t\tif (isToggleSelectionEvent(event))\n\t\t\ttoggleSelectionCellForEvent(cell, event);\n\n\t\t// Select cell\n\t\telse if (isAddToSelectionEvent(event))\n\t\t\tgraph.addSelectionCell(cell);\n\t\telse\n\t\t\tgraph.setSelectionCell(cell);\n\t}\n",
    "118871": "\tpublic void setApplet(JGraphpad applet) {\n\t\tthis.applet = applet;\n\t}\n",
    "118874": "\tpublic JGraphpad getApplet() {\n\t\treturn applet;\n\t}\n",
    "118876": "\tprotected void toggleSelectionCellForEvent(Object cell, MouseEvent event) {\n\t\tif (graph.isCellSelected(cell))\n\t\t\tgraph.removeSelectionCell(cell);\n\t\telse\n\t\t\tgraph.addSelectionCell(cell);\n\t}\n",
    "118878": "\tpublic boolean isApplet() {\n\t\treturn (applet != null);\n\t}\n",
    "118881": "\tpublic void addDocument(GraphModelProvider graphModelProvider) {\n\t\taddDocument(null, graphModelProvider, null, null, null);\n\t}\n",
    "118884": "\tpublic boolean isAddToSelectionEvent(MouseEvent e) {\n\t\treturn e.isShiftDown();\n\t}\n",
    "118891": "\tpublic boolean isToggleSelectionEvent(MouseEvent event) {\n\t\treturn (event.isControlDown());\n\t}\n",
    "118899": "\tpublic Object getCell() {\n\t\treturn cells[0];\n\t}\n",
    "118901": "\tpublic boolean isAddedCell() {\n\t\treturn areNew[0];\n\t}\n",
    "118902": "\tpublic boolean isAddedCell(Object cell) {\n\t\tfor (int counter = cells.length - 1; counter >= 0; counter--)\n\t\t\tif (cells[counter].equals(cell))\n\t\t\t\treturn areNew[counter];\n\t\tthrow new IllegalArgumentException(\"cell is not a cell identified by the GraphSelectionEvent\");\n\t}\n",
    "118903": "\tpublic boolean isAddedCell(int index) {\n\t\tif (cells == null || index < 0 || index >= cells.length) {\n\t\t\tthrow new IllegalArgumentException(\"index is beyond range of added cells identified by GraphSelectionEvent\");\n\t\t}\n\t\treturn areNew[index];\n\t}\n",
    "118904": "\tpublic Object cloneWithSource(Object newSource) {\n\t\t// Fix for IE bug - crashing\n\t\treturn new GraphSelectionEvent(newSource, cells, areNew);\n\t}\n",
    "118905": "\tpublic GraphModelChange getChange() {\n\t\treturn change;\n\t}\n",
    "118907": "\tpublic GPBarFactory getBarFactory() {\n\t\treturn barFactory;\n\t}\n",
    "118909": "\tpublic boolean isForceMarqueeEvent(MouseEvent event) {\n\t\tif (marquee != null)\n\t\t\treturn marquee.isForceMarqueeEvent(event);\n\t\treturn false;\n\t}\n",
    "118910": "\tpublic void setBarFactory(GPBarFactory barFactory) {\n\t\tthis.barFactory = barFactory;\n\t}\n",
    "118912": "\tpublic boolean isConstrainedMoveEvent(MouseEvent event) {\n\t\tif (event != null)\n\t\t\treturn event.isShiftDown();\n\t\treturn false;\n\t}\n",
    "118913": "\tpublic GraphUI getUI() {\n\t\treturn (GraphUI) ui;\n\t}\n",
    "118914": "\tpublic JGpdMarqueeHandler getMarqueeHandler() {\n\t\treturn marqueeHandler;\n\t}\n",
    "118916": "\tpublic void setUI(GraphUI ui) {\n\t\tif ((GraphUI) this.ui != ui) {\n\t\t\tsettingUI = true;\n\t\t\ttry {\n\t\t\t\tsuper.setUI(ui);\n\t\t\t} finally {\n\t\t\t\tsettingUI = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "118917": "\tpublic boolean isEditing(JGraph graph) {\n\t\treturn (editingComponent != null);\n\t}\n",
    "118920": "\tpublic void updateUI() {\n\t\tsetUI(new org.jgraph.plaf.basic.BasicGraphUI());\n\t\tinvalidate();\n\t}\n",
    "118922": "\tpublic boolean stopEditing(JGraph graph) {\n\t\tif (editingComponent != null && cellEditor.stopCellEditing()) {\n\t\t\tcompleteEditing(false, false, true);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "118924": "\tpublic boolean intersects(Graphics g, CellView value, Rectangle r) {\n\t\tif (value instanceof EdgeView && g != null && value != null) {\n            setView(value);\n            Graphics2D g2 = (Graphics2D) g;\n            boolean hit = g2.hit(r, view.getShape(), true);\n\t\t\tif (hit)\n\t\t\t\treturn true;\n\t\t\tRectangle rect = view.getLabelBounds();\n\t\t\tif (rect != null)\n\t\t\t\treturn rect.intersects(r);\n\t\t}\n\t\treturn false;\n\t}\n",
    "118925": "\tpublic Rectangle getBounds(CellView value) {\n\t\tif (value instanceof EdgeView && value != null) {\n            setView(value);\n\t\t\tRectangle r = getPaintBounds(view);\n\t\t\tRectangle label = getLabelBounds(view);\n\t\t\tif (label != null)\n\t\t\t\tr = r.union(label);\n\t\t\tint b = (int) Math.ceil(lineWidth);\n\t\t\tr.x = r.x - b;\n\t\t\tr.y = r.y - b;\n\t\t\tr.width = r.width + 2 * b;\n\t\t\tr.height = r.height + 2 * b;\n\t\t\treturn r;\n\t\t}\n\t\treturn null;\n\t}\n",
    "118926": "\tpublic String getUIClassID() {\n\t\treturn uiClassID;\n\t}\n",
    "118927": "\tpublic Rectangle getLabelBounds(EdgeView view) {\n        setView(view);\n\t\tPoint p = getLabelPosition(this.view);\n\t\tDimension d = getLabelSize(this.view);\n\t\tif (p != null && d != null) {\n\t\t\tp.translate(-d.width / 2, -d.height / 2);\n\t\t\treturn new Rectangle(p.x, p.y, d.width + 1, d.height + 1);\n\t\t}\n\t\treturn null;\n\t}\n",
    "118929": "\tpublic void cancelEditing(JGraph graph) {\n\t\tif (editingComponent != null)\n\t\t\tcompleteEditing(false, true, false);\n\t\t// Escape key is handled by the KeyHandler.keyPressed inner class method\n\t}\n",
    "118930": "\tpublic Dimension getLabelSize(EdgeView view) {\n        setView(view);\n\t\tObject label = view.getGraph().convertValueToString(view);\n\t\tif (label != null && label.toString().length() > 0) {\n\t\t\tfontGraphics.setFont(\n\t\t\t\tGraphConstants.getFont(view.getAllAttributes()));\n\t\t\tmetrics = fontGraphics.getFontMetrics();\n\t\t\tint sw = metrics.stringWidth(label.toString());\n\t\t\tint sh = metrics.getHeight();\n\t\t\treturn new Dimension(sw, sh);\n\t\t}\n\t\treturn null;\n\t}\n",
    "118932": "\tpublic Map cloneCells(Object[] cells) {\n\t\treturn graphModel.cloneCells(cells);\n\t}\n",
    "118934": "\tpublic Rectangle getPaintBounds(EdgeView view) {\n        setView(view);\n\t\treturn view.getShape().getBounds();\n\t}\n",
    "118935": "\tpublic void startEditingAtCell(JGraph graph, Object cell) {\n\t\tgraph.scrollCellToVisible(cell);\n\t\tif (cell != null)\n\t\t\tstartEditing(cell, null);\n\t}\n",
    "118938": "\tpublic Object getFirstCellForLocation(int x, int y) {\n\t\treturn getNextCellForLocation(null, x, y);\n\t}\n",
    "118941": "\tpublic Object getEditingCell(JGraph graph) {\n\t\treturn editingCell;\n\t}\n",
    "118943": "\tpublic Object getNextCellForLocation(Object current, int x, int y) {\n\t\tx /= scale;\n\t\ty /= scale; // FIX: Consistency with other methods?\n\t\tCellView cur = graphLayoutCache.getMapping(current, false);\n\t\tCellView cell = getNextViewAt(cur, x, y);\n\t\tif (cell != null)\n\t\t\treturn cell.getCell();\n\t\treturn null;\n\t}\n",
    "118945": "\tpublic void validate() {\n\t}\n",
    "118947": "\tpublic Rectangle getCellBounds(Object cell) {\n\t\tCellView view = graphLayoutCache.getMapping(cell, false);\n\t\tif (view != null)\n\t\t\treturn view.getBounds();\n\t\treturn null;\n\t}\n",
    "118948": "\tpublic void revalidate() {\n\t}\n",
    "118949": "\tpublic void repaint(long tm, int x, int y, int width, int height) {\n\t}\n",
    "118950": "\tpublic void repaint(Rectangle r) {\n\t}\n",
    "118951": "\tpublic Rectangle getCellBounds(Object[] cells) {\n\t\tif (cells != null && cells.length > 0) {\n\t\t\tRectangle ret = getCellBounds(cells[0]);\n\t\t\tif (ret != null) {\n\t\t\t\tret = new Rectangle(ret);\n\t\t\t\tfor (int i = 1; i < cells.length; i++) {\n\t\t\t\t\tRectangle r = getCellBounds(cells[i]);\n\t\t\t\t\tif (r != null)\n\t\t\t\t\t    SwingUtilities.computeUnion(\n\t\t\t\t\t\tr.x,\n\t\t\t\t\t\tr.y,\n\t\t\t\t\t\tr.width,\n\t\t\t\t\t\tr.height,\n\t\t\t\t\t\tret);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "118953": "\tprotected void prepareForUIInstall() {\n\t\t// Data member initializations\n\t\tstopEditingInCompleteEditing = true;\n\t\tpreferredSize = new Dimension();\n\t\tsetGraphLayoutCache(graph.getGraphLayoutCache());\n\t\tsetModel(graph.getModel());\n\t}\n",
    "118957": "\tpublic CellView getNextViewAt(CellView current, int x, int y) {\n\t\tObject[] sel =\n\t\t\tgraphLayoutCache.order(getSelectionModel().getSelectables());\n\t\tCellView[] cells = graphLayoutCache.getMapping(sel);\n\t\tCellView cell = getNextViewAt(cells, current, x, y);\n\t\treturn cell;\n\t}\n",
    "118959": "\tprotected void completeUIInstall() {\n\t\t// Custom install code\n\t\tsetSelectionModel(graph.getSelectionModel());\n\t\tupdateSize();\n\t}\n",
    "118964": "\tprotected void installDefaults() {\n\t\tif (graph.getBackground() == null\n\t\t\t|| graph.getBackground() instanceof UIResource) {\n\t\t\tgraph.setBackground(UIManager.getColor(\"Tree.background\"));\n\t\t}\n\t\tif (graph.getFont() == null || graph.getFont() instanceof UIResource)\n\t\t\tgraph.setFont(UIManager.getFont(\"Tree.font\"));\n\t\t// Set JGraph's laf-specific colors\n\t\tgraph.setMarqueeColor(UIManager.getColor(\"Table.gridColor\"));\n\t\tgraph.setHandleColor(\n\t\t\tUIManager.getColor(\"MenuItem.selectionBackground\"));\n\t\tgraph.setLockedHandleColor(UIManager.getColor(\"MenuItem.background\"));\n\t\tgraph.setGridColor(UIManager.getColor(\"Tree.selectionBackground\"));\n\t\tgraph.setOpaque(true);\n\t}\n",
    "118966": "\tpublic Object getPortForLocation(int x, int y) {\n\t\tPortView view = getPortViewAt(x, y);\n\t\tif (view != null)\n\t\t\treturn view.getCell();\n\t\treturn null;\n\t}\n",
    "118970": "\tpublic void mouseDragged(MouseEvent e) {\n\t\tif (!e.isConsumed() && startPoint != null) {\n\t\t\tif (!(e.getSource() instanceof JGraph))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"MarqueeHandler cannot handle event from unknown source: \"\n\t\t\t\t\t\t+ e);\n\t\t\tJGraph graph = (JGraph) e.getSource();\n\t\t\tGraphics g = graph.getGraphics();\n\t\t\tColor bg = graph.getBackground();\n\t\t\tColor fg = graph.getMarqueeColor();\n\t\t\tg.setColor(fg);\n\t\t\tg.setXORMode(bg);\n\t\t\toverlay(g);\n\t\t\tcurrentPoint = e.getPoint();\n\t\t\tmarqueeBounds = new Rectangle(startPoint);\n\t\t\tmarqueeBounds.add(currentPoint);\n\t\t\tg.setColor(bg);\n\t\t\tg.setXORMode(fg);\n\t\t\toverlay(g);\n\t\t\te.consume();\n\t\t}\n\t}\n",
    "118972": "\tpublic void paint(Graphics g) {\n\t\toverlay(g);\n\t}\n",
    "118974": "\tpublic void mousePressed(MouseEvent e) {\n\t\tif (!e.isConsumed()) {\n\t\t\tif (!(e.getSource() instanceof JGraph))\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"MarqueeHandler cannot handle event from unknown source: \"\n\t\t\t\t\t\t+ e);\n\t\t\tJGraph graph = (JGraph) e.getSource();\n\t\t\tstartPoint = e.getPoint();\n\t\t\tmarqueeBounds = new Rectangle(startPoint);\n\t\t\tpreviousCursor = graph.getCursor();\n\t\t\tgraph.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n\t\t\te.consume();\n\t\t}\n\t}\n",
    "118976": "\tpublic Point getCurrentPoint() {\n\t\treturn currentPoint;\n\t}\n",
    "118977": "\tpublic Rectangle getMarqueeBounds() {\n\t\treturn marqueeBounds;\n\t}\n",
    "118978": "\tpublic PortView getPortViewAt(int x, int y) {\n\t\tRectangle r =\n\t\t\tnew Rectangle(\n\t\t\t\tx - tolerance,\n\t\t\t\ty - tolerance,\n\t\t\t\t2 * tolerance,\n\t\t\t\t2 * tolerance);\n\t\tPortView[] ports = graphLayoutCache.getPorts();\n\t\tfor (int i = ports.length - 1; i >= 0; i--)\n\t\t\tif (ports[i] != null && ports[i].intersects(getGraphics(), r))\n\t\t\t\treturn ports[i];\n\t\treturn null;\n\t}\n",
    "118979": "\tpublic Cursor getPreviousCursor() {\n\t\treturn previousCursor;\n\t}\n",
    "118980": "\tpublic Point getStartPoint() {\n\t\treturn startPoint;\n\t}\n",
    "118981": "\tpublic void setCurrentPoint(Point currentPoint) {\n\t\tthis.currentPoint = currentPoint;\n\t}\n",
    "118982": "\tpublic void setMarqueeBounds(Rectangle marqueeBounds) {\n\t\tthis.marqueeBounds = marqueeBounds;\n\t}\n",
    "118983": "\tprotected void installKeyboardActions() {\n\t\tInputMap km =\n\t\t\tgetInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\t\tSwingUtilities.replaceUIInputMap(\n\t\t\tgraph,\n\t\t\tJComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,\n\t\t\tkm);\n\t\tkm = getInputMap(JComponent.WHEN_FOCUSED);\n\t\tSwingUtilities.replaceUIInputMap(graph, JComponent.WHEN_FOCUSED, km);\n\t\tSwingUtilities.replaceUIActionMap(graph, createActionMap());\n\t}\n",
    "118984": "\tpublic void setPreviousCursor(Cursor previousCursor) {\n\t\tthis.previousCursor = previousCursor;\n\t}\n",
    "118985": "\tpublic void setStartPoint(Point startPoint) {\n\t\tthis.startPoint = startPoint;\n\t}\n",
    "118987": "\tpublic void refresh(boolean createDependentViews) {\n\t\tsuper.refresh(createDependentViews);\n\t\t// Sync Source- and Targetport\n\t\tif (points != null) {\n\t\t\tObject modelSource = getModel().getSource(cell);\n\t\t\tObject modelTarget = getModel().getTarget(cell);\n\t\t\tsetSource(mapper.getMapping(modelSource, createDependentViews));\n\t\t\tsetTarget(mapper.getMapping(modelTarget, createDependentViews));\n\t\t\t// Re-Route\n\t\t\tEdge.Routing routing = GraphConstants.getRouting(allAttributes);\n\t\t\tif (routing != null)\n\t\t\t\trouting.route(this, points);\n\t\t}\n\t}\n",
    "118988": "\tpublic String convertValueToString(Object value) {\n\t\tCellView view =\n\t\t\t(value instanceof CellView)\n\t\t\t\t? (CellView) value\n\t\t\t\t: getGraphLayoutCache().getMapping(value, false);\n\t\tif (view != null) {\n\t\t\tObject newValue = GraphConstants.getValue(view.getAllAttributes());\n\t\t\tif (newValue != null)\n\t\t\t\tvalue = newValue;\n\t\t\telse\n\t\t\t\tvalue = view.getCell();\n\t\t}\n\t\tif (value instanceof DefaultMutableTreeNode\n\t\t\t&& ((DefaultMutableTreeNode) value).getUserObject() != null)\n\t\t\treturn ((DefaultMutableTreeNode) value).getUserObject().toString();\n\t\telse if (value != null)\n\t\t\treturn value.toString();\n\t\treturn null;\n\t}\n",
    "118989": "\tpublic void update() {\n\t\tsuper.update();\n\t\tpoints = GraphConstants.getPoints(allAttributes);\n\t\tlabelPosition = GraphConstants.getLabelPosition(allAttributes);\n\t\tEdge.Routing routing = GraphConstants.getRouting(allAttributes);\n\t\tif (routing != null)\n\t\t\trouting.route(this, points);\n\t\t// Synchronize Points and PortViews\n\t\tif (getModel().getSource(cell) != null)\n\t\t\tsetSource(getSource());\n\t\tif (getModel().getTarget(cell) != null)\n\t\t\tsetTarget(getTarget());\n\t\t// Clear cached shapes\n\t\tbeginShape = null;\n\t\tendShape = null;\n\t\tlineShape = null;\n\t\tsharedPath = null;\n\t\tcachedBounds = null;\n\t\tcachedLabelBounds = null;\n\t}\n",
    "118990": "\tpublic boolean intersects(Graphics g, Rectangle rect) {\n\t\treturn getEdgeRenderer().intersects(g, this, rect);\n\t}\n",
    "118991": "\tprotected void installComponents() {\n\t\tif ((rendererPane = createCellRendererPane()) != null)\n\t\t\tgraph.add(rendererPane);\n\t}\n",
    "118992": "\tpublic Rectangle getBounds() {\n\t\tif (cachedBounds != null) {\n\t\t\treturn cachedBounds;\n\t\t} else {\n\t\t\treturn cachedBounds = getEdgeRenderer().getBounds(this);\n\t\t}\n\t}\n",
    "118994": "\tpublic EdgeRenderer getEdgeRenderer() {\n\t\treturn (EdgeRenderer) getRenderer();\n\t}\n",
    "118995": "\tpublic Point snap(Point p) {\n\n\t\tif (gridEnabled && p != null) {\n\n\t\t\tdouble sgs = (double) gridSize * getScale();\n\n\t\t\tp.x = (int) Math.round(Math.round(p.x / sgs) * sgs);\n\t\t\tp.y = (int) Math.round(Math.round(p.y / sgs) * sgs);\n\n\t\t}\n\n\t\treturn p;\n\n\t}\n",
    "118996": "\tpublic CellViewRenderer getRenderer() {\n\t\treturn renderer;\n\t}\n",
    "118997": "\tpublic CellHandle getHandle(GraphContext context) {\n\t\treturn new EdgeHandle(this, context);\n\t}\n",
    "118998": "\tprotected TransferHandler createTransferHandler() {\n\t\treturn new GraphTransferHandler();\n\t}\n",
    "118999": "\tpublic CellView getSource() {\n\t\treturn source;\n\t}\n",
    "119000": "\tpublic Dimension snap(Dimension d) {\n\n\t\tif (gridEnabled && d != null) {\n\n\t\t\tdouble sgs = (double) gridSize * getScale();\n\n\t\t\td.width = 1 + (int) Math.round(Math.round(d.width / sgs) * sgs);\n\t\t\td.height = 1 + (int) Math.round(Math.round(d.height / sgs) * sgs);\n\n\t\t}\n\n\t\treturn d;\n\n\t}\n",
    "119001": "\tpublic void setSource(CellView sourceView) {\n\t\tsource = sourceView;\n\t\tif (source != null)\n\t\t\tpoints.set(0, source);\n\t\telse\n\t\t\tpoints.set(0, getPoint(0));\n\t\tinvalidate();\n\t}\n",
    "119002": "\tpublic CellView getTarget() {\n\t\treturn target;\n\t}\n",
    "119003": "\tpublic void setTarget(CellView targetView) {\n\t\ttarget = targetView;\n\t\tint n = points.size() - 1;\n\t\tif (target != null)\n\t\t\tpoints.set(n, target);\n\t\telse\n\t\t\tpoints.set(n, getPoint(n));\n\t\tinvalidate();\n\t}\n",
    "119004": "\tprotected PropertyChangeListener createPropertyChangeListener() {\n\t\treturn new PropertyChangeHandler();\n\t}\n",
    "119005": "\tpublic Point getLabelPosition() {\n\t\treturn labelPosition;\n\t}\n",
    "119006": "\tpublic Point toScreen(Point p) {\n\t\tif (p == null)\n\t\t\treturn null;\n\n\t\tp.x = (int) Math.round(p.x * scale);\n\t\tp.y = (int) Math.round(p.y * scale);\n\t\treturn p;\n\t}\n",
    "119007": "\tpublic void setLabelPosition(Point pos) {\n\t\tlabelPosition.setLocation(pos);\n\t\tinvalidate();\n\t}\n",
    "119008": "\tpublic int getPointCount() {\n\t\treturn points.size();\n\t}\n",
    "119010": "\tpublic Point getPoint(int index) {\n\t\tObject obj = points.get(index);\n\t\tif (obj instanceof PortView)\n\t\t\t// Port Location Seen From This Edge\n\t\t\treturn ((PortView) obj).getLocation(this);\n\t\telse if (obj instanceof CellView)\n\t\t\treturn ((CellView) obj).getBounds().getLocation();\n\t\telse if (obj instanceof Point)\n\t\t\t// Regular Point\n\t\t\treturn (Point) obj;\n\t\treturn null;\n\t}\n",
    "119011": "\tprotected MouseListener createMouseListener() {\n\t\treturn new MouseHandler();\n\t}\n",
    "119012": "\tpublic void setPoint(int index, Point p) {\n\t\tpoints.set(index, p);\n\t\tinvalidate();\n\t}\n",
    "119013": "\tpublic Point fromScreen(Point p) {\n\t\tif (p == null)\n\t\t\treturn null;\n\n\t\tp.x = (int) Math.round(p.x / scale);\n\t\tp.y = (int) Math.round(p.y / scale);\n\t\treturn p;\n\t}\n",
    "119015": "\tpublic void removePoint(int index) {\n\t\tpoints.remove(index);\n\t\tinvalidate();\n\t}\n",
    "119016": "\tpublic boolean isAddPointEvent(MouseEvent event) {\n\t\treturn SwingUtilities.isRightMouseButton(event);\n\t}\n",
    "119017": "\tpublic Rectangle toScreen(Rectangle rect) {\n\t\tif (rect == null)\n\t\t\treturn null;\n\n\t\trect.x *= scale;\n\t\trect.y *= scale;\n\t\trect.width *= scale;\n\t\trect.height *= scale;\n\t\treturn rect;\n\t}\n",
    "119018": "\tprotected KeyListener createKeyListener() {\n\t\treturn new KeyHandler();\n\t}\n",
    "119023": "\tpublic Rectangle fromScreen(Rectangle rect) {\n\t\tif (rect == null)\n\t\t\treturn null;\n\n\t\trect.x /= scale;\n\t\trect.y /= scale;\n\t\trect.width /= scale;\n\t\trect.height /= scale;\n\t\treturn rect;\n\t}\n",
    "119024": "\tprotected GraphSelectionListener createGraphSelectionListener() {\n\t\treturn new GraphSelectionHandler();\n\t}\n",
    "119028": "\tpublic CellView createView(Object cell, CellMapper map) {\n\t\tCellView view = null;\n\t\tif (graphModel.isPort(cell))\n\t\t\tview = createPortView(cell, map);\n\t\telse if (graphModel.isEdge(cell))\n\t\t\tview = createEdgeView(cell, map);\n\t\telse\n\t\t\tview = createVertexView(cell, map);\n\t\tmap.putMapping(cell, view);\n\t\tview.refresh(true); // Create Dependent Views\n\t\tview.update();\n\t\treturn view;\n\t}\n",
    "119030": "\tprotected CellEditorListener createCellEditorListener() {\n\t\treturn new CellEditorHandler();\n\t}\n",
    "119034": "\tpublic void updateAutoSize(CellView view) {\n\t\tif (view != null && !isEditing()\n\t\t\t&& GraphConstants.isAutoSize(view.getAllAttributes())) {\n\t\t\tRectangle bounds = view.getBounds();\n\t\t\tif (bounds != null) {\n\t\t\t\tDimension d = getUI().getPreferredSize(this, view);\n\t\t\t\tbounds.setSize(d);\n\t\t\t}\n\t\t}\n\t}\n",
    "119035": "\t\tpublic void mouseMoved(MouseEvent event) {\n\t\t\tfor (int i = 0; i < r.length; i++)\n\t\t\t\tif (r[i].contains(event.getPoint())) {\n\t\t\t\t\tgraph.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));\n\t\t\t\t\tevent.consume();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif (loc.contains(event.getPoint())\n\t\t\t\t&& graph.isMoveable()\n\t\t\t\t&& GraphConstants.isMoveable(edge.getAllAttributes())) {\n\t\t\t\tgraph.setCursor(new Cursor(Cursor.HAND_CURSOR));\n\t\t\t\tevent.consume();\n\t\t\t}\n\t\t}\n",
    "119036": "\tprotected ComponentListener createComponentListener() {\n\t\treturn new ComponentHandler();\n\t}\n",
    "119039": "\tprotected EdgeView createEdgeView(Object e, CellMapper cm) {\n\t\tif (e instanceof Edge)\n\t\t\treturn createEdgeView((Edge) e, cm);\n\t\telse\n\t\t\treturn new EdgeView(e, this, cm);\n\t}\n",
    "119041": "\tprotected CellRendererPane createCellRendererPane() {\n\t\treturn new CellRendererPane();\n\t}\n",
    "119043": "\tprotected PortView createPortView(Object p, CellMapper cm) {\n\t\tif (p instanceof Port)\n\t\t\treturn createPortView((Port) p, cm);\n\t\telse\n\t\t\treturn new PortView(p, this, cm);\n\t}\n",
    "119045": "\tpublic JGraph getGraph() {\n\t\treturn graph;\n\t}\n",
    "119046": "\tpublic GraphModel getModel() {\n\t\treturn graph.getModel();\n\t}\n",
    "119047": "\tprotected Observer createGraphViewObserver() {\n\t\treturn new GraphViewObserver();\n\t}\n",
    "119048": "\tpublic CellMapper getMapper() {\n\t\treturn mapper;\n\t}\n",
    "119049": "\tpublic Object getCell() {\n\t\treturn cell;\n\t}\n",
    "119051": "\tprotected EdgeView createEdgeView(Edge e, CellMapper cm) {\n\t\treturn new EdgeView(e, this, cm);\n\t}\n",
    "119053": "\tpublic void update() {\n\t\tupdateAllAttributes();\n\t\t// Notify Parent\n\t\tchildUpdated();\n\t}\n",
    "119054": "\tprotected void updateAllAttributes() {\n\t\tallAttributes = getModel().getAttributes(cell);\n\t\tif (allAttributes != null) {\n\t\t\tallAttributes = GraphConstants.cloneMap(allAttributes);\n\t\t} else\n\t\t\tallAttributes = GraphConstants.createMap();\n\t\tallAttributes.putAll(attributes);\n\t}\n",
    "119056": "\tpublic CellView getParentView() {\n\t\treturn parent;\n\t}\n",
    "119057": "\tprotected GraphModelListener createGraphModelListener() {\n\t\treturn new GraphModelHandler();\n\t}\n",
    "119058": "\tpublic void removeFromParent() {\n\t\tif (parent instanceof AbstractCellView) {\n\t\t\tjava.util.List list = ((AbstractCellView) parent).childViews;\n\t\t\tlist.remove(this);\n\t\t}\n\t}\n",
    "119060": "\tpublic boolean isLeaf() {\n\t\treturn childViews.isEmpty();\n\t}\n",
    "119061": "\tprotected PortView createPortView(Port p, CellMapper cm) {\n\t\treturn new PortView(p, this, cm);\n\t}\n",
    "119062": "\tpublic Map getAttributes() {\n\t\treturn attributes;\n\t}\n",
    "119063": "\tpublic Map getAllAttributes() {\n\t\treturn allAttributes;\n\t}\n",
    "119064": "\tpublic Map setAttributes(Map change) {\n\t\tMap undo = GraphConstants.applyMap(change, attributes);\n\t\tupdate();\n\t\treturn undo;\n\t}\n",
    "119069": "\tprotected VertexView createVertexView(Object v, CellMapper cm) {\n\t\treturn new VertexView(v, this, cm);\n\t}\n",
    "119070": "\tpublic boolean intersects(Graphics g, Rectangle rect) {\n\t\tif (isLeaf()) {\n\t\t\tRectangle bounds = getBounds();\n\t\t\tif (bounds != null)\n\t\t\t\treturn bounds.intersects(rect);\n\t\t} else { // Check If Children Intersect\n\t\t\tIterator it = childViews.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t\tif (((CellView) it.next()).intersects(g, rect))\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "119072": "\tpublic GraphCellEditor getEditor() {\n\t\treturn cellEditor;\n\t}\n",
    "119073": "\tpublic Iterator edges() {\n\t\treturn edges.iterator();\n\t}\n",
    "119074": "\tpublic boolean addEdge(Object edge) {\n\t\treturn edges.add(edge);\n\t}\n",
    "119075": "\tpublic boolean removeEdge(Object edge) {\n\t\treturn edges.remove(edge);\n\t}\n",
    "119076": "\tpublic Set getEdges() {\n\t\treturn new HashSet(edges);\n\t}\n",
    "119077": "\tpublic void setEdges(Set edges) {\n\t\tthis.edges = new HashSet(edges);\n\t}\n",
    "119078": "\tpublic Port getAnchor() {\n\t\treturn anchor;\n\t}\n",
    "119079": "\tpublic void setAnchor(Port port) {\n\t\tanchor = port;\n\t}\n",
    "119080": "\tpublic int getEditClickCount() {\n\t\treturn editClickCount;\n\t}\n",
    "119081": "\tpublic Object clone() {\n\t\tDefaultPort c = (DefaultPort) super.clone();\n\t\tc.edges = new HashSet();\n\t\treturn c;\n\t}\n",
    "119092": "\tpublic void setEditClickCount(int count) {\n\t\teditClickCount = count;\n\t}\n",
    "119101": "\tpublic boolean isDropEnabled() {\n\t\treturn dropEnabled;\n\t}\n",
    "119102": "\tpublic int getRootCount() {\n\t\treturn roots.size();\n\t}\n",
    "119104": "\tpublic Object getRootAt(int index) {\n\t\treturn roots.get(index);\n\t}\n",
    "119105": "\tpublic int getIndexOfRoot(Object root) {\n\t\treturn roots.indexOf(root);\n\t}\n",
    "119106": "\tpublic void setDropEnabled(boolean flag) {\n\t\tdropEnabled = flag;\n\t}\n",
    "119107": "\tpublic boolean contains(Object node) {\n\t\tObject parentNode = null;\n\t\twhile ((parentNode = getParent(node))\n\t\t\t!= null)\n\t\t\tnode = parentNode;\n\t\treturn roots.contains(node);\n\t}\n",
    "119108": "\tprotected void uninstallComponents() {\n\t\tif (rendererPane != null)\n\t\t\tgraph.remove(rendererPane);\n\t}\n",
    "119109": "\tpublic Map getAttributes(Object node) {\n\t\tif (node instanceof GraphCell)\n\t\t\treturn ((GraphCell) node).getAttributes();\n\t\treturn null;\n\t}\n",
    "119110": "\tpublic boolean isDragEnabled() {\n\t\treturn dragEnabled;\n\t}\n",
    "119111": "\tpublic Object getSource(Object edge) {\n\t\tif (edge instanceof Edge)\n\t\t\treturn ((Edge) edge).getSource();\n\t\treturn null;\n\t}\n",
    "119113": "\tpublic Object getTarget(Object edge) {\n\t\tif (edge instanceof Edge)\n\t\t\treturn ((Edge) edge).getTarget();\n\t\treturn null;\n\t}\n",
    "119115": "\tpublic void setDragEnabled(boolean flag) {\n\t\tdragEnabled = flag;\n\t}\n",
    "119116": "\tpublic boolean acceptsSource(Object edge, Object port) {\n\t\treturn true;\n\t}\n",
    "119117": "\tpublic boolean acceptsTarget(Object edge, Object port) {\n\t\treturn true;\n\t}\n",
    "119120": "\tpublic Iterator edges(Object port) {\n\t\tif (port instanceof Port)\n\t\t\treturn ((Port) port).edges();\n\t\treturn emptyIterator;\n\t}\n",
    "119123": "\tpublic void setMoveable(boolean flag) {\n\t\tmoveable = flag;\n\t}\n",
    "119124": "\tprotected void paintBackground(Graphics g) {\n\t\tif (graph.isGridVisible())\n\t\t\tpaintGrid(graph.getGridSize(), g, g.getClipBounds());\n\t}\n",
    "119126": "\tpublic boolean isBendable() {\n\t\treturn bendable;\n\t}\n",
    "119127": "\tpublic Object getParent(Object child) {\n\t\tif (child != null && child instanceof TreeNode)\n\t\t\treturn ((TreeNode) child).getParent();\n\t\treturn null;\n\t}\n",
    "119130": "\tpublic int getIndexOfChild(Object parent, Object child) {\n\t\tif (parent == null || child == null)\n\t\t\treturn -1;\n\t\treturn ((TreeNode) parent).getIndex((TreeNode) child);\n\t}\n",
    "119133": "\tpublic void setBendable(boolean flag) {\n\t\tbendable = flag;\n\t}\n",
    "119134": "\tprotected void paintForeground(Graphics g) {\n\t\tif (graph.isPortsVisible())\n\t\t\tpaintPorts(g, graphLayoutCache.getPorts());\n\t}\n",
    "119135": "\tpublic int getChildCount(Object parent) {\n\t\tif (parent instanceof TreeNode)\n\t\t\treturn ((TreeNode) parent).getChildCount();\n\t\treturn 0;\n\t}\n",
    "119136": "\tpublic boolean isLeaf(Object node) {\n\t\tif (asksAllowsChildren && node instanceof TreeNode)\n\t\t\treturn !((TreeNode) node).getAllowsChildren();\n\t\treturn ((TreeNode) node).isLeaf();\n\t}\n",
    "119137": "\tpublic boolean isConnectable() {\n\t\treturn connectable;\n\t}\n",
    "119140": "\tpublic void setConnectable(boolean flag) {\n\t\tconnectable = flag;\n\t}\n",
    "119141": "\tpublic void remove(Object[] roots) {\n\t\tGraphModelEdit edit = createRemoveEdit(roots);\n\t\tif (edit != null) {\n\t\t\tedit.execute();\n\t\t\tpostEdit(edit);\n\t\t}\n\t}\n",
    "119144": "\tprotected void updateHandle() {\n\t\tif (graphLayoutCache != null) {\n\t\t\tObject[] cells = graphLayoutCache.order(graph.getSelectionCells());\n\t\t\tif (cells != null && cells.length > 0)\n\t\t\t\thandle = createHandle(createContext(graph, cells));\n\t\t\telse\n\t\t\t\thandle = null;\n\t\t}\n\t}\n",
    "119145": "\tpublic boolean isDisconnectable() {\n\t\treturn disconnectable;\n\t}\n",
    "119146": "\tpublic void toBack(Object[] cells) {\n\t\tGraphModelLayerEdit edit =\n\t\t\tcreateLayerEdit(cells, GraphModelLayerEdit.BACK);\n\t\tif (edit != null) {\n\t\t\tedit.execute();\n\t\t\tpostEdit(edit);\n\t\t}\n\t}\n",
    "119147": "\tpublic void toFront(Object[] cells) {\n\t\tGraphModelLayerEdit edit =\n\t\t\tcreateLayerEdit(cells, GraphModelLayerEdit.FRONT);\n\t\tif (edit != null) {\n\t\t\tedit.execute();\n\t\t\tpostEdit(edit);\n\t\t}\n\t}\n",
    "119149": "\tpublic void setDisconnectable(boolean flag) {\n\t\tdisconnectable = flag;\n\t}\n",
    "119152": "\tpublic boolean isCloneable() {\n\t\treturn cloneable;\n\t}\n",
    "119153": "\tpublic CellHandle createHandle(GraphContext context) {\n\t\tif (context != null && !context.isEmpty() && graph.isEnabled())\n\t\t\treturn new RootHandle(context);\n\t\treturn null;\n\t}\n",
    "119154": "\tprotected GraphModelEdit createRemoveEdit(Object[] cells) {\n\t\t// Remove from GraphStructure\n\t\tConnectionSet cs = ConnectionSet.create(this, cells, true);\n\t\t// Remove from Group Structure\n\t\tParentMap pm = ParentMap.create(this, cells, true, false);\n\t\t// Construct Edit\n\t\t//GraphModelEdit edit = new GraphModelEdit(cells, cs, pm);\n\t\tGraphModelEdit edit = createEdit(null, cells, null, cs, pm);\n\t\tif (edit != null)\n\t\t\tedit.end();\n\t\treturn edit;\n\t}\n",
    "119156": "\tpublic void setCloneable(boolean flag) {\n\t\tcloneable = flag;\n\t}\n",
    "119157": "\tpublic void updateSize() {\n\t\tvalidCachedPreferredSize = false;\n\t\tgraph.graphDidChange();\n\t\tupdateHandle();\n\t}\n",
    "119161": "\tpublic boolean isSizeable() {\n\t\treturn sizeable;\n\t}\n",
    "119164": "\tpublic void setSizeable(boolean flag) {\n\t\tsizeable = flag;\n\t}\n",
    "119165": "\tprotected ConnectionSet handleConnectionSet(ConnectionSet cs) {\n\t\tif (cs != null) {\n\t\t\tConnectionSet csundo = new ConnectionSet();\n\t\t\tIterator it = cs.connections();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tConnectionSet.Connection c =\n\t\t\t\t\t(ConnectionSet.Connection) it.next();\n\t\t\t\tObject edge = c.getEdge();\n\t\t\t\tif (c.isSource())\n\t\t\t\t\tcsundo.connect(edge, getSource(edge), true);\n\t\t\t\telse\n\t\t\t\t\tcsundo.connect(edge, getTarget(edge), false);\n\t\t\t\thandleConnection(c);\n\t\t\t}\n\t\t\treturn csundo;\n\t\t}\n\t\treturn null;\n\t}\n",
    "119166": "\tpublic void setPreferredMinSize(Dimension newSize) {\n\t\tpreferredMinSize = newSize;\n\t}\n",
    "119167": "\tprotected void handleConnection(ConnectionSet.Connection c) {\n\t\tObject edge = c.getEdge();\n\t\tObject old = (c.isSource()) ? getSource(edge) : getTarget(edge);\n\t\tObject port = c.getPort();\n\t\tif (port != old) {\n\t\t\tconnect(edge, old, c.isSource(), true);\n\t\t\tif (contains(port) && contains(edge))\n\t\t\t\tconnect(edge, port, c.isSource(), false);\n\t\t}\n\t}\n",
    "119168": "\tpublic boolean isDisconnectOnMove() {\n\t\treturn disconnectOnMove && disconnectable;\n\t}\n",
    "119170": "\tpublic Dimension getPreferredMinSize() {\n\t\tif (preferredMinSize == null)\n\t\t\treturn null;\n\t\treturn new Dimension(preferredMinSize);\n\t}\n",
    "119172": "\tpublic void addGraphModelListener(GraphModelListener l) {\n\t\tlistenerList.add(GraphModelListener.class, l);\n\t}\n",
    "119173": "\tpublic void setSelectNewCells(boolean flag) {\n\t\tselectNewCells = flag;\n\t}\n",
    "119175": "\tpublic void removeGraphModelListener(GraphModelListener l) {\n\t\tlistenerList.remove(GraphModelListener.class, l);\n\t}\n",
    "119176": "\tpublic boolean isSelectNewCells() {\n\t\treturn selectNewCells;\n\t}\n",
    "119177": "\tpublic Dimension getPreferredSize(JComponent c) {\n\t\tDimension pSize = this.getPreferredMinSize();\n\n\t\tif (!validCachedPreferredSize)\n\t\t\tupdateCachedPreferredSize();\n\t\tif (graph != null) {\n\t\t\tif (pSize != null)\n\t\t\t\treturn new Dimension(\n\t\t\t\t\tMath.max(pSize.width, preferredSize.width),\n\t\t\t\t\tMath.max(pSize.height, preferredSize.height));\n\t\t\treturn new Dimension(preferredSize.width, preferredSize.height);\n\t\t} else if (pSize != null)\n\t\t\treturn pSize;\n\t\telse\n\t\t\treturn new Dimension(0, 0);\n\t}\n",
    "119180": "\tpublic void setDisconnectOnMove(boolean flag) {\n\t\tdisconnectOnMove = flag;\n\t}\n",
    "119181": "\tpublic Dimension getMinimumSize(JComponent c) {\n\t\tif (this.getPreferredMinSize() != null)\n\t\t\treturn this.getPreferredMinSize();\n\t\treturn new Dimension(0, 0);\n\t}\n",
    "119182": "\t\tprotected void handleEmptyGroups(Object[] groups) {\n\t\t\tif (groups != null && groups.length > 0) {\n\t\t\t\tif (remove == null)\n\t\t\t\t\tremove = new Object[] {\n\t\t\t\t};\n\t\t\t\tObject[] tmp = new Object[remove.length + groups.length];\n\t\t\t\tSystem.arraycopy(remove, 0, tmp, 0, remove.length);\n\t\t\t\tSystem.arraycopy(groups, 0, tmp, remove.length, groups.length);\n\t\t\t\tremove = tmp;\n\t\t\t}\n\t\t}\n",
    "119184": "\tpublic boolean isGridEnabled() {\n\t\treturn gridEnabled;\n\t}\n",
    "119185": "\tpublic Dimension getMaximumSize(JComponent c) {\n\t\tif (graph != null)\n\t\t\treturn getPreferredSize(graph);\n\t\tif (this.getPreferredMinSize() != null)\n\t\t\treturn this.getPreferredMinSize();\n\t\treturn new Dimension(0, 0);\n\t}\n",
    "119187": "\t\tpublic Object getSource() {\n\t\t\treturn DefaultGraphModel.this;\n\t\t}\n",
    "119188": "\tpublic void setGridEnabled(boolean flag) {\n\t\tgridEnabled = flag;\n\t}\n",
    "119189": "\t\tpublic Map getPreviousAttributes() {\n\t\t\treturn previousAttributes;\n\t\t}\n",
    "119190": "\tprotected void completeEditing() {\n\t\t/* If should invoke stopCellEditing, try that */\n\t\tif (graph.getInvokesStopCellEditing()\n\t\t\t&& stopEditingInCompleteEditing\n\t\t\t&& editingComponent != null) {\n\t\t\tcellEditor.stopCellEditing();\n\t\t}\n\t\t/* Invoke cancelCellEditing, this will do nothing if stopCellEditing\n\t\t   was succesful. */\n\t\tcompleteEditing(false, true, false);\n\t}\n",
    "119192": "\tpublic int getTolerance() {\n\t\treturn tolerance;\n\t}\n",
    "119193": "\t\tpublic ConnectionSet getConnectionSet() {\n\t\t\treturn connectionSet;\n\t\t}\n",
    "119195": "\tpublic void setTolerance(int size) {\n\t\ttolerance = size;\n\t}\n",
    "119197": "\t\tpublic ParentMap getParentMap() {\n\t\t\treturn parentMap;\n\t\t}\n",
    "119199": "\tpublic int getHandleSize() {\n\t\treturn handleSize;\n\t}\n",
    "119202": "\tpublic void setHandleSize(int size) {\n\t\thandleSize = size;\n\t}\n",
    "119203": "\t\tpublic void redo() throws CannotRedoException {\n\t\t\tsuper.redo();\n\t\t\texecute();\n\t\t}\n",
    "119205": "\t\tpublic void undo() throws CannotUndoException {\n\t\t\tsuper.undo();\n\t\t\texecute();\n\t\t}\n",
    "119206": "\tpublic int getMinimumMove() {\n\t\treturn minimumMove;\n\t}\n",
    "119208": "\t\tprotected void startTimer() {\n\t\t\tif (timer == null) {\n\t\t\t\ttimer = new Timer(200, this);\n\t\t\t\ttimer.setRepeats(true);\n\t\t\t}\n\t\t\ttimer.start();\n\t\t}\n",
    "119210": "\tpublic void setMinimumMove(int pixels) {\n\t\tminimumMove = pixels;\n\t}\n",
    "119212": "\t\tprotected JScrollPane getScrollPane() {\n\t\t\tComponent c = graph.getParent();\n\n\t\t\twhile (c != null && !(c instanceof JScrollPane))\n\t\t\t\tc = c.getParent();\n\t\t\tif (c instanceof JScrollPane)\n\t\t\t\treturn (JScrollPane) c;\n\t\t\treturn null;\n\t\t}\n",
    "119215": "\tpublic Color getGridColor() {\n\t\treturn gridColor;\n\t}\n",
    "119217": "\t\tpublic void actionPerformed(ActionEvent ae) {\n\t\t\tif (scrollBar == null || !scrollBar.getValueIsAdjusting()) {\n\t\t\t\tif (timer != null)\n\t\t\t\t\ttimer.stop();\n\t\t\t\tupdateSize();\n\t\t\t\ttimer = null;\n\t\t\t\tscrollBar = null;\n\t\t\t}\n\t\t}\n",
    "119219": "\tpublic void setGridColor(Color newColor) {\n\t\tgridColor = newColor;\n\t}\n",
    "119222": "\tpublic Color getHandleColor() {\n\t\treturn handleColor;\n\t}\n",
    "119224": "\t\tpublic void addImplicitEdit(UndoableEdit edit) {\n\t\t\t// ignore\t\n\t\t}\n",
    "119225": "\tpublic void setHandleColor(Color newColor) {\n\t\thandleColor = newColor;\n\t}\n",
    "119228": "\t\tpublic void putViews(GraphLayoutCache view, CellView[] cellViews) {\n\t\t\t// ignore\n\t\t}\n",
    "119229": "\tpublic Color getLockedHandleColor() {\n\t\treturn lockedHandleColor;\n\t}\n",
    "119231": "\t\tpublic void valueChanged(GraphSelectionEvent event) {\n\t\t\t//cancelEditing(graph);\n\t\t\tupdateHandle();\n\t\t\tObject[] cells = event.getCells();\n\t\t\tif (cells != null && cells.length <= MAXCLIPCELLS) {\n\t\t\t\tRectangle r = graph.toScreen(graph.getCellBounds(cells));\n\t\t\t\tif (r != null) {\n\t\t\t\t\tint hsize = graph.getHandleSize();\n\t\t\t\t\tr.grow(hsize, hsize); //padding to paint handles\n\t\t\t\t\tupdateHandle();\n\t\t\t\t\tgraph.repaint(r);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tgraph.repaint();\n\t\t}\n",
    "119232": "\t\tprotected List getParentList(Object cell) {\n\t\t\tList list = null;\n\t\t\tif (cell instanceof DefaultMutableTreeNode) {\n\t\t\t\tObject parent = ((DefaultMutableTreeNode) cell).getParent();\n\t\t\t\tif (parent instanceof DefaultGraphCell)\n\t\t\t\t\tlist = ((DefaultGraphCell) parent).getChildren();\n\t\t\t\telse\n\t\t\t\t\tlist = roots;\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n",
    "119233": "\tpublic void setLockedHandleColor(Color newColor) {\n\t\tlockedHandleColor = newColor;\n\t}\n",
    "119235": "\t\tpublic void editingStopped(ChangeEvent e) {\n\t\t\tcompleteEditing(false, false, true);\n\t\t}\n",
    "119237": "\tpublic Color getMarqueeColor() {\n\t\treturn marqueeColor;\n\t}\n",
    "119240": "\t\tpublic void editingCanceled(ChangeEvent e) {\n\t\t\tcompleteEditing(false, false, false);\n\t\t}\n",
    "119241": "\tpublic void setMarqueeColor(Color newColor) {\n\t\tmarqueeColor = newColor;\n\t}\n",
    "119243": "\tpublic void setBorderSelectionColor(Color newColor) {\n\t\tborderSelectionColor = newColor;\n\t}\n",
    "119244": "\tpublic Color getBorderSelectionColor() {\n\t\treturn borderSelectionColor;\n\t}\n",
    "119246": "\tpublic void setFont(Font font) {\n\t\tthis.font = font;\n\t}\n",
    "119247": "\tpublic Color getHighlightColor() {\n\t\treturn highlightColor;\n\t}\n",
    "119248": "\tpublic Font getFont() {\n\t\treturn font;\n\t}\n",
    "119250": "\tpublic Object getCellEditorValue() {\n\t\treturn realEditor.getCellEditorValue();\n\t}\n",
    "119251": "\tpublic boolean isCellEditable(EventObject event) {\n\t\tboolean retValue = false;\n\n\t\tif (!realEditor.isCellEditable(event))\n\t\t\treturn false;\n\t\tif (canEditImmediately(event))\n\t\t\tretValue = true;\n\t\tif (retValue)\n\t\t\tprepareForEditing();\n\t\treturn retValue;\n\t}\n",
    "119252": "\tpublic boolean shouldSelectCell(EventObject event) {\n\t\treturn realEditor.shouldSelectCell(event);\n\t}\n",
    "119253": "\tpublic void setHighlightColor(Color newColor) {\n\t\thighlightColor = newColor;\n\t}\n",
    "119254": "\tpublic boolean stopCellEditing() {\n\t\tif (realEditor.stopCellEditing()) {\n\t\t\tif (editingComponent != null)\n\t\t\t\teditingContainer.remove(editingComponent);\n\t\t\teditingComponent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "119256": "\tpublic void cancelCellEditing() {\n\t\trealEditor.cancelCellEditing();\n\t\tif (editingComponent != null)\n\t\t\teditingContainer.remove(editingComponent);\n\t\teditingComponent = null;\n\t}\n",
    "119257": "\tpublic void addCellEditorListener(CellEditorListener l) {\n\t\trealEditor.addCellEditorListener(l);\n\t}\n",
    "119259": "\tpublic void removeCellEditorListener(CellEditorListener l) {\n\t\trealEditor.removeCellEditorListener(l);\n\t}\n",
    "119260": "\tpublic void valueChanged(GraphSelectionEvent e) {\n\t\tif (graph != null) {\n\t\t\tif (graph.getSelectionCount() == 1)\n\t\t\t\tlastCell = graph.getSelectionCell();\n\t\t\telse\n\t\t\t\tlastCell = null;\n\t\t}\n\t}\n",
    "119261": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tif (graph != null)\n\t\t\tgraph.startEditingAtCell(lastCell);\n\t}\n",
    "119263": "\tpublic double getScale() {\n\t\treturn scale;\n\t}\n",
    "119264": "\tprotected void setGraph(JGraph newGraph) {\n\t\tif (graph != newGraph) {\n\t\t\tif (graph != null)\n\t\t\t\tgraph.removeGraphSelectionListener(this);\n\t\t\tgraph = newGraph;\n\t\t\tif (graph != null)\n\t\t\t\tgraph.addGraphSelectionListener(this);\n\t\t}\n\t}\n",
    "119266": "\tprotected boolean shouldStartEditingTimer(EventObject event) {\n\t\tif ((event instanceof MouseEvent)\n\t\t\t&& SwingUtilities.isLeftMouseButton((MouseEvent) event)) {\n\t\t\tMouseEvent me = (MouseEvent) event;\n\n\t\t\treturn (\n\t\t\t\tme.getClickCount() == 1 && inHitRegion(me.getX(), me.getY()));\n\t\t}\n\t\treturn false;\n\t}\n",
    "119268": "\tprotected boolean inHitRegion(int x, int y) {\n\t\tif (lastCell != null && graph != null) {\n\t\t\tRectangle bounds = graph.getCellBounds(lastCell);\n\n\t\t\tif (bounds != null\n\t\t\t\t&& x <= (bounds.x + offsetX)\n\t\t\t\t&& y <= (bounds.y + offsetY)\n\t\t\t\t&& offsetX < (bounds.width - 5)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "119270": "\tpublic void setScale(double newValue) {\n\t\tif (newValue > 0) {\n\t\t\tdouble oldValue = this.scale;\n\t\t\tscale = newValue;\n\t\t\tfirePropertyChange(SCALE_PROPERTY, oldValue, newValue);\n\t\t}\n\t}\n",
    "119271": "\tprotected void prepareForEditing() {\n\t\teditingContainer.add(editingComponent);\n\t}\n",
    "119272": "\tprotected Container createContainer() {\n\t\treturn new EditorContainer();\n\t}\n",
    "119276": "\tpublic int getGridSize() {\n\t\treturn gridSize;\n\t}\n",
    "119279": "\t\tpublic Border getBorder() {\n\t\t\treturn border;\n\t\t}\n",
    "119283": "\tpublic int getGridMode() {\n\t\treturn gridMode;\n\t}\n",
    "119284": "\t\tpublic void paint(Graphics g) {\n\t\t\tDimension size = getSize();\n\n\t\t\t// Then the icon.\n\t\t\tif (editingIcon != null) {\n\t\t\t\tint yLoc = 0;\n\t\t\t\tint xLoc = 0;\n\t\t\t\teditingIcon.paintIcon(this, g, xLoc, yLoc);\n\t\t\t}\n\n\t\t\t// Border selection color\n\t\t\tColor background = getBorderSelectionColor();\n\t\t\tif (background != null) {\n\t\t\t\tg.setColor(background);\n\t\t\t\tg.drawRect(0, 0, size.width - 1, size.height - 1);\n\t\t\t}\n\t\t\tsuper.paint(g);\n\t\t}\n",
    "119285": "\t\tpublic void doLayout() {\n\t\t\tif (editingComponent != null) {\n\t\t\t\tDimension cSize = getSize();\n\t\t\t\tint h = (int) editingComponent.getPreferredSize().getHeight();\n\t\t\t\teditingComponent.setBounds(\n\t\t\t\t\toffsetX,\n\t\t\t\t\toffsetY,\n\t\t\t\t\tcSize.width - offsetX,\n\t\t\t\t\th);\n\t\t\t}\n\t\t}\n",
    "119287": "\t\tpublic Dimension getPreferredSize() {\n\t\t\tif (editingComponent != null) {\n\t\t\t\tDimension pSize = editingComponent.getPreferredSize();\n\n\t\t\t\tpSize.width += offsetX + 2;\n\t\t\t\tpSize.height += offsetY + 2;\n\n\t\t\t\t// Make sure width is at least 50.\n\t\t\t\t// and height at least 20\n\t\t\t\tint iwidth = 50;\n\t\t\t\tif (editingIcon != null) {\n\t\t\t\t\tiwidth = Math.max(editingIcon.getIconWidth(), iwidth);\n\t\t\t\t}\n\t\t\t\tpSize.height = Math.max(pSize.height, 24); // Offset 4\n\t\t\t\tpSize.width = Math.max(pSize.width, iwidth);\n\t\t\t\treturn pSize;\n\t\t\t}\n\t\t\treturn new Dimension(0, 0);\n\t\t}\n",
    "119288": "\t\tpublic void mouseMoved(MouseEvent e) {\n\t\t\tif (previousCursor == null)\n\t\t\t\tpreviousCursor = graph.getCursor();\n\t\t\tif (graph != null && graph.isEnabled()) {\n\t\t\t\tif (marquee != null)\n\t\t\t\t\tmarquee.mouseMoved(e);\n\t\t\t\tif (handle != null)\n\t\t\t\t\thandle.mouseMoved(e);\n\t\t\t\tif (!e.isConsumed() && previousCursor != null) {\n\t\t\t\t\tgraph.setCursor(previousCursor);\n\t\t\t\t\tpreviousCursor = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "119289": "\tpublic void update() {\n\t\tsuper.update();\n\t\tbounds = GraphConstants.getBounds(allAttributes);\n\t\tgroupBounds = null;\n\t}\n",
    "119291": "\tpublic void setGridSize(int newSize) {\n\t\tint oldValue = this.gridSize;\n\n\t\tthis.gridSize = newSize;\n\t\tfirePropertyChange(GRID_SIZE_PROPERTY, oldValue, newSize);\n\t}\n",
    "119292": "\tpublic Rectangle getBounds() {\n\t\tif (!isLeaf()) {\n\t\t\tif (groupBounds == null)\n\t\t\t\tupdateGroupBounds();\n\t\t\treturn groupBounds;\n\t\t}\n\t\treturn bounds;\n\t}\n",
    "119298": "\tpublic void setGridMode(int mode) {\n\t\tif (mode == DOT_GRID_MODE\n\t\t\t|| mode == CROSS_GRID_MODE\n\t\t\t|| mode == LINE_GRID_MODE) {\n\t\t\tgridMode = mode;\n\t\t\trepaint();\n\t\t}\n\t}\n",
    "119300": "\tpublic CellHandle getHandle(GraphContext context) {\n\t\tif (GraphConstants.isSizeable(getAllAttributes())\n\t\t\t&& context.getGraph().isSizeable())\n\t\t\treturn new SizeHandle(this, context);\n\t\treturn null;\n\t}\n",
    "119301": "\tpublic Point getCenterPoint() {\n\t\tRectangle r = getBounds();\n\t\treturn new Point((int) r.getCenterX(), (int) r.getCenterY());\n\t}\n",
    "119302": "\tpublic Point getPerimeterPoint(Point source, Point p) {\n\t\treturn renderer.getPerimeterPoint(this, source, p);\n\t}\n",
    "119305": "\tpublic boolean isGridVisible() {\n\t\treturn gridVisible;\n\t}\n",
    "119309": "\t\tpublic void mouseMoved(MouseEvent event) {\n\t\t\tif (vertex != null) {\n\t\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\t\tif (r[i].contains(event.getPoint())) {\n\t\t\t\t\t\tgraph.setCursor(new Cursor(cursors[i]));\n\t\t\t\t\t\tevent.consume();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "119310": "\t\tpublic void mousePressed(MouseEvent event) {\n\t\t\tif (!graph.isSizeable())\n\t\t\t\treturn;\n\t\t\tfor (int i = 0; i < r.length; i++) {\n\t\t\t\tif (r[i].contains(event.getPoint())) {\n\t\t\t\t\tSet set = new HashSet();\n\t\t\t\t\tset.add(vertex.getCell());\n\t\t\t\t\tcontextViews = context.createTemporaryContextViews(set);\n\t\t\t\t\tObject[] all =\n\t\t\t\t\t\tAbstractCellView.getDescendantViews(\n\t\t\t\t\t\t\tnew CellView[] { vertex });\n\t\t\t\t\tif (all.length\n\t\t\t\t\t\t>= org.jgraph.plaf.basic.BasicGraphUI.MAXHANDLES)\n\t\t\t\t\t\tcachedBounds = new Rectangle(initialBounds);\n\t\t\t\t\tevent.consume();\n\t\t\t\t\tindex = i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "119312": "\tpublic void setGridVisible(boolean flag) {\n\t\tboolean oldValue = gridVisible;\n\n\t\tgridVisible = flag;\n\t\tfirePropertyChange(GRID_VISIBLE_PROPERTY, oldValue, flag);\n\t}\n",
    "119318": "\tpublic void addConnections(CellView[] views) {\n\t\tfor (int i = 0; i < views.length; i++) {\n\t\t\tif (views[i] instanceof EdgeView) {\n\t\t\t\tEdgeView edgeView = (EdgeView) views[i];\n\t\t\t\tObject edge = edgeView.getCell();\n\t\t\t\tCellView sourceView = edgeView.getSource();\n\t\t\t\tCellView targetView = edgeView.getTarget();\n\t\t\t\tObject source = null;\n\t\t\t\tif (sourceView != null)\n\t\t\t\t\tsource = sourceView.getCell();\n\t\t\t\tObject target = null;\n\t\t\t\tif (targetView != null)\n\t\t\t\t\ttarget = targetView.getCell();\n\t\t\t\tconnect(edge, source, target);\n\t\t\t}\n\t\t}\n\t}\n",
    "119319": "\tpublic boolean isPortsVisible() {\n\t\treturn portsVisible;\n\t}\n",
    "119320": "\tpublic void connect(Object edge, Object source, Object target) {\n\t\tconnect(edge, source, true);\n\t\tconnect(edge, target, false);\n\t}\n",
    "119321": "\tpublic void connect(Object edge, Object port, boolean source) {\n\t\tConnection c = new Connection(edge, port, source);\n\t\tconnections.remove(c);\n\t\tconnections.add(c);\n\t\tedges.add(edge);\n\t}\n",
    "119322": "\tpublic void disconnect(Object edge) {\n\t\tdisconnect(edge, true);\n\t\tdisconnect(edge, false);\n\t}\n",
    "119323": "\tpublic void disconnect(Object edge, boolean source) {\n\t\tconnections.add(new Connection(edge, null, source));\n\t\tedges.add(edge);\n\t}\n",
    "119324": "\tpublic boolean isEmpty() {\n\t\treturn connections.isEmpty();\n\t}\n",
    "119325": "\tpublic int size() {\n\t\treturn connections.size();\n\t}\n",
    "119327": "\tpublic Iterator connections() {\n\t\treturn connections.iterator();\n\t}\n",
    "119328": "\tpublic Set getChangedEdges() {\n\t\treturn edges;\n\t}\n",
    "119329": "\tpublic void setPortsVisible(boolean flag) {\n\t\tboolean oldValue = portsVisible;\n\n\t\tportsVisible = flag;\n\t\tfirePropertyChange(PORTS_VISIBLE_PROPERTY, oldValue, flag);\n\t}\n",
    "119330": "\tpublic ConnectionSet clone(Map map) {\n\t\tConnectionSet cs = new ConnectionSet();\n\t\tIterator it = connections();\n\t\twhile (it.hasNext()) {\n\t\t\t// Shortcut Vars\n\t\t\tConnection c = (Connection) it.next();\n\t\t\tObject edge = map.get(c.getEdge());\n\t\t\tObject port = c.getPort();\n\t\t\tif (port != null)\n\t\t\t\tport = map.get(port);\n\t\t\t// New Port\n\t\t\tif (edge != null && port != null)\n\t\t\t\tcs.connect(edge, port, c.isSource());\n\t\t\t// Old Port\n\t\t\telse if (edge != null)\n\t\t\t\tcs.connect(edge, c.getPort(), c.isSource());\n\t\t}\n\t\treturn cs;\n\t}\n",
    "119331": "\t\tpublic Object getEdge() {\n\t\t\treturn edge;\n\t\t}\n",
    "119332": "\t\tpublic Object getPort() {\n\t\t\treturn port;\n\t\t}\n",
    "119333": "\t\tpublic boolean isSource() {\n\t\t\treturn isSource;\n\t\t}\n",
    "119334": "\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj instanceof Connection) {\n\t\t\t\tConnection other = (Connection) obj;\n\t\t\t\treturn (\n\t\t\t\t\tother.getEdge().equals(edge)\n\t\t\t\t\t\t&& other.isSource() == isSource);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "119335": "\t\tpublic int hashCode() {\n\t\t\treturn edge.hashCode();\n\t\t}\n",
    "119336": "\tpublic boolean isAntiAliased() {\n\t\treturn antiAliased;\n\t}\n",
    "119347": "\tpublic void setAntiAliased(boolean newValue) {\n\t\tboolean oldValue = this.antiAliased;\n\n\t\tthis.antiAliased = newValue;\n\t\tfirePropertyChange(ANTIALIASED_PROPERTY, oldValue, newValue);\n\t}\n",
    "119348": "\tpublic void setSelectionMode(int mode) {\n\t\tint oldMode = selectionMode;\n\n\t\tselectionMode = mode;\n\t\tif (selectionMode != GraphSelectionModel.MULTIPLE_GRAPH_SELECTION\n\t\t\t&& selectionMode != GraphSelectionModel.SINGLE_GRAPH_SELECTION)\n\t\t\tselectionMode = GraphSelectionModel.MULTIPLE_GRAPH_SELECTION;\n\t\tif (oldMode != selectionMode && changeSupport != null)\n\t\t\tchangeSupport.firePropertyChange(\n\t\t\t\tSELECTION_MODE_PROPERTY,\n\t\t\t\tnew Integer(oldMode),\n\t\t\t\tnew Integer(selectionMode));\n\t}\n",
    "119350": "\tpublic int getSelectionMode() {\n\t\treturn selectionMode;\n\t}\n",
    "119351": "\tpublic void setChildrenSelectable(boolean flag) {\n\t\tchildrenSelectable = flag;\n\t}\n",
    "119352": "\tpublic boolean isChildrenSelectable() {\n\t\treturn childrenSelectable;\n\t}\n",
    "119353": "\tpublic boolean isEditable() {\n\t\treturn editable;\n\t}\n",
    "119354": "\tprotected boolean isChildrenSelectable(Object cell) {\n\t\treturn childrenSelectable;\n\t}\n",
    "119355": "\tpublic void setSelectionCell(Object cell) {\n\t\tif (cell == null)\n\t\t\tsetSelectionCells(null);\n\t\telse\n\t\t\tsetSelectionCells(new Object[] { cell });\n\t}\n",
    "119357": "\t\tpublic void mouseMoved(MouseEvent event) {\n\t\t\tif (!event.isConsumed() && handles != null)\n\t\t\t\tfor (int i = handles.length - 1;\n\t\t\t\t\ti >= 0 && !event.isConsumed();\n\t\t\t\t\ti--)\n\t\t\t\t\tif (handles[i] != null)\n\t\t\t\t\t\thandles[i].mouseMoved(event);\n\t\t}\n",
    "119358": "\tpublic void addSelectionCell(Object cell) {\n\t\tif (cell != null)\n\t\t\taddSelectionCells(new Object[] { cell });\n\t}\n",
    "119359": "\tpublic void addSelectionCells(Object[] cells) {\n\t\tif (cells != null) {\n\t\t\tif (selectionMode == GraphSelectionModel.SINGLE_GRAPH_SELECTION)\n\t\t\t\tsetSelectionCells(cells);\n\t\t\telse {\n\t\t\t\tVector change = new Vector();\n\t\t\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\t\t\tif (cells[i] != null) {\n\t\t\t\t\t\tboolean newness = select(selection, cells[i]);\n\t\t\t\t\t\tif (newness) {\n\t\t\t\t\t\t\tchange.addElement(\n\t\t\t\t\t\t\t\tnew CellPlaceHolder(cells[i], true));\n\t\t\t\t\t\t\tObject parent =\n\t\t\t\t\t\t\t\tgraph.getModel().getParent(cells[i]);\n\t\t\t\t\t\t\tif (parent != null)\n\t\t\t\t\t\t\t\tchange.addElement(\n\t\t\t\t\t\t\t\t\tnew CellPlaceHolder(parent, false));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (change.size() > 0)\n\t\t\t\t\tnotifyCellChange(change);\n\t\t\t}\n\t\t}\n\t}\n",
    "119360": "\tpublic void setEditable(boolean flag) {\n\t\tboolean oldValue = this.editable;\n\n\t\tthis.editable = flag;\n\t\tfirePropertyChange(EDITABLE_PROPERTY, oldValue, flag);\n\t}\n",
    "119361": "\tpublic void removeSelectionCell(Object cell) {\n\t\tif (cell != null)\n\t\t\tremoveSelectionCells(new Object[] { cell });\n\t}\n",
    "119362": "\tpublic void removeSelectionCells(Object[] cells) {\n\t\tif (cells != null) {\n\t\t\tVector change = new Vector();\n\t\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\t\tif (cells[i] != null) {\n\t\t\t\t\tboolean removed = deselect(cells[i]);\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tchange.addElement(new CellPlaceHolder(cells[i], false));\n\t\t\t\t\t\tObject parent = graph.getModel().getParent(cells[i]);\n\t\t\t\t\t\tif (parent != null)\n\t\t\t\t\t\t\tchange.addElement(\n\t\t\t\t\t\t\t\tnew CellPlaceHolder(parent, false));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (change.size() > 0)\n\t\t\t\tnotifyCellChange(change);\n\t\t}\n\t}\n",
    "119363": "\tpublic Object getSelectionCell() {\n\t\tif (selection != null && selection.size() > 0)\n\t\t\treturn selection.toArray()[0];\n\t\treturn null;\n\t}\n",
    "119365": "\tpublic int getSelectionCount() {\n\t\treturn (selection == null) ? 0 : selection.size();\n\t}\n",
    "119366": "\tpublic GraphModel getModel() {\n\t\treturn graphModel;\n\t}\n",
    "119367": "\tpublic boolean isCellSelected(Object cell) {\n\t\tint count = getSelectedChildCount(cell);\n\t\treturn (count == SELECTED);\n\t}\n",
    "119369": "\tpublic boolean isChildrenSelected(Object cell) {\n\t\tint count = getSelectedChildCount(cell);\n\t\treturn (count > 0);\n\t}\n",
    "119370": "\tpublic boolean isSelectionEmpty() {\n\t\treturn (selection.isEmpty());\n\t}\n",
    "119371": "\t\tprotected CellView findViewForPoint(Point pt) {\n\t\t\tint snap = graph.getTolerance();\n\t\t\tRectangle r =\n\t\t\t\tnew Rectangle(pt.x - snap, pt.y - snap, 2 * snap, 2 * snap);\n\t\t\tfor (int i = 0; i < views.length; i++)\n\t\t\t\tif (views[i].intersects(graph.getGraphics(), r))\n\t\t\t\t\treturn views[i];\n\t\t\treturn null;\n\t\t}\n",
    "119372": "\tpublic void setModel(GraphModel newModel) {\n\t\tGraphModel oldModel = graphModel;\n\n\t\tgraphModel = newModel;\n\t\tfirePropertyChange(GRAPH_MODEL_PROPERTY, oldModel, graphModel);\n\t\t// FIX: Use Listener\n\t\tif (graphLayoutCache != null\n\t\t\t&& graphLayoutCache.getModel() != graphModel)\n\t\t\tgraphLayoutCache.setModel(graphModel);\n\t\tinvalidate();\n\t}\n",
    "119373": "\tpublic void clearSelection() {\n\t\tif (selection != null) {\n\t\t\tVector change = new Vector();\n\t\t\tIterator it = cellStates.entrySet().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\tchange.addElement(new CellPlaceHolder(entry.getKey(), false));\n\t\t\t}\n\t\t\tselection.clear();\n\t\t\tcellStates.clear();\n\t\t\tif (change.size() > 0)\n\t\t\t\tnotifyCellChange(change);\n\t\t}\n\t}\n",
    "119374": "\tprotected int getSelectedChildCount(Object cell) {\n\t\tif (cell != null) {\n\t\t\tInteger state = (Integer) cellStates.get(cell);\n\t\t\tif (state == null) {\n\t\t\t\tstate = UNSELECTED;\n\t\t\t\tcellStates.put(cell, state);\n\t\t\t}\n\t\t\treturn state.intValue();\n\t\t}\n\t\treturn 0;\n\t}\n",
    "119375": "\tprotected void setSelectedChildCount(Object cell, int count) {\n\t\tInteger i = new Integer(count);\n\t\tcellStates.put(cell, i);\n\t}\n",
    "119377": "\tpublic GraphLayoutCache getGraphLayoutCache() {\n\t\treturn graphLayoutCache;\n\t}\n",
    "119379": "\tpublic void addGraphSelectionListener(GraphSelectionListener x) {\n\t\tlistenerList.add(GraphSelectionListener.class, x);\n\t}\n",
    "119380": "\tpublic void removeGraphSelectionListener(GraphSelectionListener x) {\n\t\tlistenerList.remove(GraphSelectionListener.class, x);\n\t}\n",
    "119381": "\tpublic void setGraphLayoutCache(GraphLayoutCache newLayoutCache) {\n\t\tGraphLayoutCache oldLayoutCache = graphLayoutCache;\n\n\t\tgraphLayoutCache = newLayoutCache;\n\t\tfirePropertyChange(\n\t\t\tGRAPH_LAYOUT_CACHE_PROPERTY,\n\t\t\toldLayoutCache,\n\t\t\tgraphLayoutCache);\n\t\t// FIX: Use Listener\n\t\tif (graphLayoutCache != null\n\t\t\t&& graphLayoutCache.getModel() != getModel())\n\t\t\tgraphLayoutCache.setModel(getModel());\n\t\tinvalidate();\n\t}\n",
    "119383": "\tprotected void fireValueChanged(GraphSelectionEvent e) {\n\t\t// Guaranteed to return a non-null array\n\t\tObject[] listeners = listenerList.getListenerList();\n\t\t// TreeSelectionEvent e = null;\n\t\t// Process the listeners last to first, notifying\n\t\t// those that are interested in this event\n\t\tfor (int i = listeners.length - 2; i >= 0; i -= 2) {\n\t\t\tif (listeners[i] == GraphSelectionListener.class) {\n\t\t\t\t// Lazily create the event:\n\t\t\t\t// if (e == null)\n\t\t\t\t// e = new ListSelectionEvent(this, firstIndex, lastIndex);\n\t\t\t\t ((GraphSelectionListener) listeners[i + 1]).valueChanged(e);\n\t\t\t}\n\t\t}\n\t}\n",
    "119384": "\tprotected void notifyCellChange(Vector changedCells) {\n\t\tint cCellCount = changedCells.size();\n\t\tboolean[] newness = new boolean[cCellCount];\n\t\tObject[] cells = new Object[cCellCount];\n\t\tCellPlaceHolder placeholder;\n\n\t\tfor (int counter = 0; counter < cCellCount; counter++) {\n\t\t\tplaceholder = (CellPlaceHolder) changedCells.elementAt(counter);\n\t\t\tnewness[counter] = placeholder.isNew;\n\t\t\tcells[counter] = placeholder.cell;\n\t\t}\n\n\t\tGraphSelectionEvent event =\n\t\t\tnew GraphSelectionEvent(this, cells, newness);\n\n\t\tfireValueChanged(event);\n\t}\n",
    "119385": "\tpublic Object clone() throws CloneNotSupportedException {\n\t\tDefaultGraphSelectionModel clone =\n\t\t\t(DefaultGraphSelectionModel) super.clone();\n\t\tclone.changeSupport = null;\n\t\tif (selection != null)\n\t\t\tclone.selection = new ArrayList(selection);\n\t\tclone.listenerList = new EventListenerList();\n\t\treturn clone;\n\t}\n",
    "119386": "\tpublic BasicMarqueeHandler getMarqueeHandler() {\n\t\treturn marquee;\n\t}\n",
    "119389": "\t\tpublic boolean isNew() {\n\t\t\treturn isNew;\n\t\t}\n",
    "119390": "\t\tpublic void setCell(Object cell) {\n\t\t\tthis.cell = cell;\n\t\t}\n",
    "119391": "\tpublic void setMarqueeHandler(BasicMarqueeHandler newMarquee) {\n\t\tBasicMarqueeHandler oldMarquee = marquee;\n\n\t\tmarquee = newMarquee;\n\t\tfirePropertyChange(MARQUEE_HANDLER_PROPERTY, oldMarquee, newMarquee);\n\t\tinvalidate();\n\t}\n",
    "119393": "\t\tpublic void setNew(boolean isNew) {\n\t\t\tthis.isNew = isNew;\n\t\t}\n",
    "119395": "\tpublic int getDescendantCount() {\n\t\treturn cellCount;\n\t}\n",
    "119397": "\tpublic boolean contains(Object node) {\n\t\treturn cellSet.contains(node);\n\t}\n",
    "119398": "\tpublic CellView getMapping(Object cell, boolean create) {\n\t\tif (cell != null) {\n\t\t\tCellView view = (CellView) views.get(cell);\n\t\t\tif (view != null)\n\t\t\t\treturn view;\n\t\t\telse if (contains(cell))\n\t\t\t\treturn createMapping(cell);\n\t\t\telse\n\t\t\t\treturn graphLayoutCache.getMapping(cell, false);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119399": "\tpublic void setInvokesStopCellEditing(boolean newValue) {\n\t\tboolean oldValue = invokesStopCellEditing;\n\n\t\tinvokesStopCellEditing = newValue;\n\t\tfirePropertyChange(\n\t\t\tINVOKES_STOP_CELL_EDITING_PROPERTY,\n\t\t\toldValue,\n\t\t\tnewValue);\n\t}\n",
    "119402": "\tpublic void putMapping(Object cell, CellView view) {\n\t\tviews.put(cell, view);\n\t}\n",
    "119403": "\tpublic void setFactory(CellViewFactory factory) {\n\t\tthis.factory = factory;\n\t}\n",
    "119405": "\tpublic boolean getInvokesStopCellEditing() {\n\t\treturn invokesStopCellEditing;\n\t}\n",
    "119407": "\tpublic CellViewFactory getFactory() {\n\t\treturn factory;\n\t}\n",
    "119408": "\tpublic void setModel(GraphModel model) {\n\t\troots.clear();\n\t\tmapping.clear();\n\t\thiddenSet.clear();\n\t\tvisibleSet.clear();\n\t\tgraphModel = model;\n\t\tObject[] cells = DefaultGraphModel.getRoots(model);\n\t\tif (!isPartial())\n\t\t\tinsertRoots(getMapping(cells, true));\n\t\t// AutoSize for Existing Cells\n\t\tif (cells != null)\n\t\t\tfor (int i = 0; i < cells.length; i++)\n\t\t\t\tfactory.updateAutoSize(getMapping(cells[i], false));\n\t\t// Update PortView Cache\n\t\tupdatePorts();\n\t}\n",
    "119410": "\tpublic boolean isCellEditable(Object cell) {\n\t\tif (cell != null) {\n\t\t\tCellView view = graphLayoutCache.getMapping(cell, false);\n\t\t\tif (view != null) {\n\t\t\t\treturn isEditable()\n\t\t\t\t&& GraphConstants.isEditable(view.getAllAttributes());\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "119413": "\tprotected void updatePorts() {\n\t\tObject[] roots = DefaultGraphModel.getRoots(graphModel);\n\t\tSet set = DefaultGraphModel.getDescendants(graphModel, roots);\n\t\tif (set != null) {\n\t\t\tObject[] all = set.toArray(); //order(set.toArray());\n\t\t\tArrayList result = new ArrayList();\n\t\t\tfor (int i = 0; i < all.length; i++) {\n\t\t\t\tif (graphModel.isPort(all[i])) {\n\t\t\t\t\tCellView portView = getMapping(all[i], false);\n\t\t\t\t\tif (portView != null) {\n\t\t\t\t\t\tresult.add(portView);\n\t\t\t\t\t\tportView.refresh(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tports = new PortView[result.size()];\n\t\t\tresult.toArray(ports);\n\t\t}\n\t}\n",
    "119414": "\tpublic String getToolTipText(MouseEvent event) {\n\t\tif (event != null) {\n\t\t\tObject cell = getFirstCellForLocation(event.getX(), event.getY());\n\t\t\tString s = convertValueToString(cell);\n\t\t\treturn (s != null && s.length() > 0) ? s : null;\n\t\t}\n\t\treturn null;\n\t}\n",
    "119418": "\tpublic void setSelectionModel(GraphSelectionModel selectionModel) {\n\t\tif (selectionModel == null)\n\t\t\tselectionModel = EmptySelectionModel.sharedInstance();\n\n\t\tGraphSelectionModel oldValue = this.selectionModel;\n\n\t\t// Remove Redirector From Old Selection Model\n\t\tif (this.selectionModel != null && selectionRedirector != null)\n\t\t\tthis.selectionModel.removeGraphSelectionListener(\n\t\t\t\tselectionRedirector);\n\n\t\tthis.selectionModel = selectionModel;\n\n\t\t// Add Redirector To New Selection Model\n\t\tif (selectionRedirector != null)\n\t\t\tthis.selectionModel.addGraphSelectionListener(selectionRedirector);\n\n\t\tfirePropertyChange(\n\t\t\tSELECTION_MODEL_PROPERTY,\n\t\t\toldValue,\n\t\t\tthis.selectionModel);\n\t}\n",
    "119423": "\tpublic GraphSelectionModel getSelectionModel() {\n\t\treturn selectionModel;\n\t}\n",
    "119426": "\tpublic void clearSelection() {\n\t\tgetSelectionModel().clearSelection();\n\t}\n",
    "119429": "\tpublic void insertRoots(CellView[] views) {\n\t\tif (views != null) {\n\t\t\trefresh(views, true);\n\t\t\tfor (int i = 0; i < views.length; i++) {\n\t\t\t\tif (views[i] != null\n\t\t\t\t\t&& getMapping(views[i].getCell(), false) != null) {\n\t\t\t\t\tCellView parentView = views[i].getParentView();\n\t\t\t\t\tObject parent =\n\t\t\t\t\t\t(parentView != null) ? parentView.getCell() : null;\n\t\t\t\t\tif (!(views[i] instanceof PortView)\n\t\t\t\t\t\t&& !roots.contains(views[i])\n\t\t\t\t\t\t&& parent == null) {\n\t\t\t\t\t\troots.add(views[i]);\n\t\t\t\t\t\t// Remove children for non-partial views?\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "119430": "\tpublic boolean isSelectionEmpty() {\n\t\treturn getSelectionModel().isSelectionEmpty();\n\t}\n",
    "119431": "\tpublic CellView getMapping(Object cell, boolean create) {\n\t\tif (cell == null)\n\t\t\treturn null;\n\t\tCellView view = (CellView) mapping.get(cell);\n\t\tif (view == null && create) {\n\t\t\tview = (CellView) hiddenSet.get(cell);\n\t\t\tif (view != null && isVisible(cell)) {\n\t\t\t\tputMapping(cell, view);\n\t\t\t\thiddenSet.remove(cell);\n\t\t\t} else\n\t\t\t\tview = factory.createView(cell, this);\n\t\t}\n\t\treturn view;\n\t}\n",
    "119433": "\tpublic void putMapping(Object cell, CellView view) {\n\t\t// Remove isVisible-condition?\n\t\tif (cell != null && view != null && isVisible(cell))\n\t\t\tmapping.put(cell, view);\n\t}\n",
    "119434": "\tpublic void addGraphSelectionListener(GraphSelectionListener tsl) {\n\t\tlistenerList.add(GraphSelectionListener.class, tsl);\n\t\tif (listenerList.getListenerCount(GraphSelectionListener.class) != 0\n\t\t\t&& selectionRedirector == null) {\n\t\t\tselectionRedirector = new GraphSelectionRedirector();\n\t\t\tselectionModel.addGraphSelectionListener(selectionRedirector);\n\t\t}\n\t}\n",
    "119435": "\tpublic CellView removeMapping(Object cell) {\n\t\tif (cell != null) {\n\t\t\tCellView view = (CellView) mapping.remove(cell);\n\t\t\treturn view;\n\t\t}\n\t\treturn null;\n\t}\n",
    "119439": "\tpublic void removeGraphSelectionListener(GraphSelectionListener tsl) {\n\t\tlistenerList.remove(GraphSelectionListener.class, tsl);\n\t\tif (listenerList.getListenerCount(GraphSelectionListener.class) == 0\n\t\t\t&& selectionRedirector != null) {\n\t\t\tselectionModel.removeGraphSelectionListener(selectionRedirector);\n\t\t\tselectionRedirector = null;\n\t\t}\n\t}\n",
    "119443": "\tprotected void fireValueChanged(GraphSelectionEvent e) {\n\t\t// Guaranteed to return a non-null array\n\t\tObject[] listeners = listenerList.getListenerList();\n\t\t// Process the listeners last to first, notifying\n\t\t// those that are interested in this event\n\t\tfor (int i = listeners.length - 2; i >= 0; i -= 2) {\n\t\t\tif (listeners[i] == GraphSelectionListener.class) {\n\t\t\t\t((GraphSelectionListener) listeners[i + 1]).valueChanged(e);\n\t\t\t}\n\t\t}\n\t}\n",
    "119447": "\tpublic void setSelectionCell(Object cell) {\n\t\tgetSelectionModel().setSelectionCell(cell);\n\t}\n",
    "119451": "\tpublic void setSelectionCells(Object[] cells) {\n\t\tgetSelectionModel().setSelectionCells(cells);\n\t}\n",
    "119455": "\tpublic void addSelectionCell(Object cell) {\n\t\tgetSelectionModel().addSelectionCell(cell);\n\t}\n",
    "119459": "\tpublic void addSelectionCells(Object[] cells) {\n\t\tgetSelectionModel().addSelectionCells(cells);\n\t}\n",
    "119462": "\tpublic void removeSelectionCell(Object cell) {\n\t\tgetSelectionModel().removeSelectionCell(cell);\n\t}\n",
    "119465": "\tpublic void remove(Object[] roots) {\n\t\tgraphModel.remove(roots);\n\t}\n",
    "119466": "\tpublic Object getSelectionCell() {\n\t\treturn getSelectionModel().getSelectionCell();\n\t}\n",
    "119469": "\tpublic void toBack(Object[] cells) {\n\t\tif (cells != null && cells.length > 0) {\n\t\t\tif (isOrdered()) {\n\t\t\t\tCellView[] views = getMapping(cells, false);\n\t\t\t\tGraphViewLayerEdit edit =\n\t\t\t\t\tnew GraphViewLayerEdit(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tviews,\n\t\t\t\t\t\tGraphViewLayerEdit.BACK);\n\t\t\t\tgraphModel.edit(null, null, null, new UndoableEdit[] { edit });\n\t\t\t} else\n\t\t\t\tgraphModel.toBack(cells);\n\t\t}\n\t}\n",
    "119470": "\tpublic int getSelectionCount() {\n\t\treturn getSelectionModel().getSelectionCount();\n\t}\n",
    "119472": "\tpublic void toFront(Object[] cells) {\n\t\tif (cells != null && cells.length > 0) {\n\t\t\tif (isOrdered()) {\n\t\t\t\tCellView[] views = getMapping(cells, false);\n\t\t\t\tGraphViewLayerEdit edit =\n\t\t\t\t\tnew GraphViewLayerEdit(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tviews,\n\t\t\t\t\t\tGraphViewLayerEdit.FRONT);\n\t\t\t\tgraphModel.edit(null, null, null, new UndoableEdit[] { edit });\n\t\t\t} else\n\t\t\t\tgraphModel.toFront(cells);\n\t\t}\n\t}\n",
    "119473": "\tpublic boolean isCellSelected(Object cell) {\n\t\treturn getSelectionModel().isCellSelected(cell);\n\t}\n",
    "119478": "\tpublic void scrollCellToVisible(Object cell) {\n\t\tRectangle bounds = getCellBounds(cell);\n\t\tif (bounds != null) {\n\t\t\tbounds = new Rectangle(bounds);\n\t\t\tscrollRectToVisible(toScreen(bounds));\n\t\t}\n\t}\n",
    "119479": "\t\tpublic Object getSource() {\n\t\t\treturn GraphLayoutCache.this;\n\t\t}\n",
    "119481": "\tpublic void scrollPointToVisible(Point p) {\n\t\tif (p != null) {\n\t\t\tRectangle bounds = new Rectangle(p);\n\t\t\tif (bounds != null)\n\t\t\t\tscrollRectToVisible(bounds);\n\t\t}\n\t}\n",
    "119486": "\tpublic boolean isEditing() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\treturn graph.isEditing(this);\n\t\treturn false;\n\t}\n",
    "119490": "\tpublic boolean stopEditing() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\treturn graph.stopEditing(this);\n\t\treturn false;\n\t}\n",
    "119493": "\tpublic void cancelEditing() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\tgraph.cancelEditing(this);\n\t}\n",
    "119496": "\t\tpublic Object getSource() {\n\t\t\treturn changeSource;\n\t\t}\n",
    "119497": "\tpublic void startEditingAtCell(Object cell) {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\tgraph.startEditingAtCell(this, cell);\n\t}\n",
    "119498": "\t\tpublic Map getAttributes() {\n\t\t\treturn null;\n\t\t}\n",
    "119499": "\t\tprotected void saveComponentState(JComponent comp) {\n\t\t}\n",
    "119500": "\tpublic Object getEditingCell() {\n\t\tGraphUI graph = getUI();\n\n\t\tif (graph != null)\n\t\t\treturn graph.getEditingCell(this);\n\t\treturn null;\n\t}\n",
    "119501": "\t\tpublic void redo() throws CannotRedoException {\n\t\t\tsuper.redo();\n\t\t\tupdateNext();\n\t\t\texecute();\n\t\t}\n",
    "119504": "\t\tprotected void restoreComponentState(JComponent comp) {\n\t\t\tif (handle != null)\n\t\t\t\thandle.mouseDragged(null);\n\t\t}\n",
    "119505": "\tpublic void graphDidChange() {\n\t\trevalidate();\n\t\trepaint();\n\t}\n",
    "119506": "\t\tpublic void execute() {\n\t\t\tfor (int i = 0; i < cells.length; i++) {\n\t\t\t\tList list = getParentList(cells[i]);\n\t\t\t\tif (list != null) {\n\t\t\t\t\tprev[i] = list.indexOf(cells[i]);\n\t\t\t\t\tif (prev[i] >= 0) {\n\t\t\t\t\t\tlist.remove(prev[i]);\n\t\t\t\t\t\tint n = next[i];\n\t\t\t\t\t\tif (n == FRONT)\n\t\t\t\t\t\t\tn = list.size();\n\t\t\t\t\t\telse if (n == BACK)\n\t\t\t\t\t\t\tn = 0;\n\t\t\t\t\t\tlist.add(n, cells[i]);\n\t\t\t\t\t\tnext[i] = prev[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateListeners();\n\t\t}\n",
    "119507": "\t\tprotected void updateInsertionLocation(JComponent comp, Point p) {\n\t\t\tsetInsertionLocation(p);\n\t\t\tif (handle != null) {\n\t\t\t\t// How to fetch the shift state?\n\t\t\t\tint mod =\n\t\t\t\t\t(dropAction == TransferHandler.COPY)\n\t\t\t\t\t\t? InputEvent.CTRL_MASK\n\t\t\t\t\t\t: 0;\n\t\t\t\thandle.mouseDragged(\n\t\t\t\t\tnew MouseEvent(comp, 0, 0, mod, p.x, p.y, 1, false));\n\t\t\t}\n\t\t}\n",
    "119510": "\t\tprotected List getParentList(Object view) {\n\t\t\tif (view instanceof CellView) {\n\t\t\t\tCellView parent = ((CellView) view).getParentView();\n\t\t\t\tList list = null;\n\t\t\t\tif (parent == null)\n\t\t\t\t\tlist = ((GraphLayoutCache) changeSource).roots;\n\t\t\t\telse if (parent instanceof AbstractCellView)\n\t\t\t\t\tlist = ((AbstractCellView) parent).childViews;\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n",
    "119513": "\tpublic Map getHiddenSet() {\n\t\treturn hiddenSet;\n\t}\n",
    "119515": "\tpublic boolean isHideEdgesOnBecomeInvisible() {\n\t\treturn hideEdgesOnBecomeInvisible;\n\t}\n",
    "119516": "\t\tstatic public EmptySelectionModel sharedInstance() {\n\t\t\treturn sharedInstance;\n\t\t}\n",
    "119518": "\tpublic boolean isHideEdgesOnHide() {\n\t\treturn hideEdgesOnHide;\n\t}\n",
    "119520": "\t\tpublic void setSelectionCells(Object[] cells) {\n\t\t}\n",
    "119521": "\tpublic boolean isRememberCellViews() {\n\t\treturn rememberCellViews;\n\t}\n",
    "119523": "\tpublic boolean isShowAllEdgesForVisibleVertices() {\n\t\treturn showAllEdgesForVisibleVertices;\n\t}\n",
    "119524": "\t\tpublic void addSelectionCells(Object[] cells) {\n\t\t}\n",
    "119525": "\tpublic boolean isShowEdgesOnShow() {\n\t\treturn showEdgesOnShow;\n\t}\n",
    "119527": "\t\tpublic void removeSelectionCells(Object[] cells) {\n\t\t}\n",
    "119530": "\tpublic void setHideEdgesOnBecomeInvisible(boolean hideEdgesOnBecomeInvisible) {\n\t\tthis.hideEdgesOnBecomeInvisible = hideEdgesOnBecomeInvisible;\n\t}\n",
    "119531": "\t\tpublic void valueChanged(GraphSelectionEvent e) {\n\t\t\tGraphSelectionEvent newE;\n\n\t\t\tnewE = (GraphSelectionEvent) e.cloneWithSource(JGraph.this);\n\t\t\tfireValueChanged(newE);\n\t\t}\n",
    "119532": "\tpublic void setHideEdgesOnHide(boolean hideEdgesOnHide) {\n\t\tthis.hideEdgesOnHide = hideEdgesOnHide;\n\t}\n",
    "119533": "\tpublic Dimension getPreferredScrollableViewportSize() {\n\t\treturn getPreferredSize();\n\t}\n",
    "119534": "\tpublic void setRememberCellViews(boolean rememberCellViews) {\n\t\tthis.rememberCellViews = rememberCellViews;\n\t}\n",
    "119536": "\tpublic void setShowAllEdgesForVisibleVertices(boolean showAllEdgesForVisibleVertices) {\n\t\tthis.showAllEdgesForVisibleVertices = showAllEdgesForVisibleVertices;\n\t}\n",
    "119539": "\tpublic void setShowEdgesOnShow(boolean showEdgesOnShow) {\n\t\tthis.showEdgesOnShow = showEdgesOnShow;\n\t}\n",
    "119542": "\tpublic void paint(Graphics g) {\n\t\ttry {\n\t\t\t//if (preview && !isDoubleBuffered)\n\t\t\t//\tsetOpaque(false);\n\t\t\tsuper.paint(g);\n\t\t\tpaintSelectionBorder(g);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\t// JDK Bug: Zero length string passed to TextLayout constructor\n\t\t}\n\t}\n",
    "119543": "\tprotected void paintSelectionBorder(Graphics g) {\n\t\t((Graphics2D) g).setStroke(GraphConstants.SELECTION_STROKE);\n\t\tif (childrenSelected)\n\t\t\tg.setColor(graph.getGridColor());\n\t\telse if (hasFocus && selected)\n\t\t\tg.setColor(graph.getLockedHandleColor());\n\t\telse if (selected)\n\t\t\tg.setColor(graph.getHighlightColor());\n\t\tif (childrenSelected || selected) {\n\t\t\tDimension d = getSize();\n\t\t\tg.drawRect(0, 0, d.width - 1, d.height - 1);\n\t\t}\n\t}\n",
    "119552": "\tpublic boolean getScrollableTracksViewportWidth() {\n\t\tif (getParent() instanceof JViewport) {\n\t\t\treturn (\n\t\t\t\t((JViewport) getParent()).getWidth()\n\t\t\t\t\t> getPreferredSize().width);\n\t\t}\n\t\treturn false;\n\t}\n",
    "119561": "\tpublic boolean getScrollableTracksViewportHeight() {\n\t\tif (getParent() instanceof JViewport) {\n\t\t\treturn (\n\t\t\t\t((JViewport) getParent()).getHeight()\n\t\t\t\t\t> getPreferredSize().height);\n\t\t}\n\t\treturn false;\n\t}\n",
    "119564": "\tpublic boolean isHideGroups() {\n\t\treturn hideGroups;\n\t}\n",
    "119565": "\tpublic void setHideGroups(boolean hideGroups) {\n\t\tthis.hideGroups = hideGroups;\n\t}\n",
    "119567": "\tpublic ConnectionSet getConnectionSet() {\n\t\treturn cs;\n\t}\n",
    "119569": "\tpublic Map getAttributeMap() {\n\t\treturn attributeMap;\n\t}\n",
    "119572": "\tprotected String paramString() {\n\t\tString editableString = (editable ? \"true\" : \"false\");\n\t\tString invokesStopCellEditingString =\n\t\t\t(invokesStopCellEditing ? \"true\" : \"false\");\n\t\treturn super.paramString()\n\t\t\t+ \",editable=\"\n\t\t\t+ editableString\n\t\t\t+ \",invokesStopCellEditing=\"\n\t\t\t+ invokesStopCellEditingString;\n\t}\n",
    "119574": "\tpublic boolean isPlainSupported() {\n\t\treturn (cells != null && cells.length == 1);\n\t}\n",
    "119575": "\tpublic String getPlainData() {\n\t\tif (cells[0] instanceof DefaultGraphCell) {\n\t\t\tObject obj = ((DefaultGraphCell) cells[0]).getUserObject();\n\t\t\tif (obj != null)\n\t\t\t\treturn obj.toString();\n\t\t}\n\t\treturn cells[0].toString();\n\t}\n",
    "119576": "\tpublic void undo(Object source) {\n\t\tif (source == null || !isInProgress())\n\t\t\tsuper.undo();\n\t\telse {\n\t\t\tUndoableEdit edit = editToBeUndone(source);\n\t\t\t//System.out.println(\"undoTo edit=\"+edit);\n\t\t\tif (edit == null)\n\t\t\t\tthrow new CannotUndoException();\n\t\t\tundoTo(edit);\n\t\t}\n\t}\n",
    "119577": "\tpublic boolean isHTMLSupported() {\n\t\treturn isPlainSupported();\n\t}\n",
    "119579": "\tpublic String getHTMLData() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tbuf.append(\"<html><body><p>\");\n\t\tbuf.append(getPlainData());\n\t\tbuf.append(\"</p></body></html>\");\n\t\treturn buf.toString();\n\t}\n",
    "119580": "\tprotected UndoableEdit nextEditToBeUndone(UndoableEdit current) {\n\t\tif (current == null)\n\t\t\treturn editToBeUndone();\n\t\telse {\n\t\t\tint index = edits.indexOf(current) - 1;\n\t\t\tif (index >= 0)\n\t\t\t\treturn (UndoableEdit) edits.get(index);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119582": "\tpublic void redo(Object source) {\n\t\tif (source == null || !isInProgress())\n\t\t\tsuper.redo();\n\t\telse {\n\t\t\tUndoableEdit edit = editToBeRedone(source);\n\t\t\t//System.out.println(\"redoTo edit=\"+edit);\n\t\t\tif (edit == null)\n\t\t\t\tthrow new CannotRedoException();\n\t\t\tredoTo(edit);\n\t\t}\n\t}\n",
    "119583": "\tpublic Object getSource() {\n\t\treturn source;\n\t}\n",
    "119585": "\tpublic Object getTarget() {\n\t\treturn target;\n\t}\n",
    "119586": "\tprotected UndoableEdit nextEditToBeRedone(UndoableEdit current) {\n\t\tif (current == null)\n\t\t\treturn editToBeRedone();\n\t\telse {\n\t\t\tint index = edits.indexOf(current) + 1;\n\t\t\tif (index < edits.size())\n\t\t\t\treturn (UndoableEdit) edits.get(index);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119587": "\tpublic void setSource(Object port) {\n\t\tsource = port;\n\t}\n",
    "119588": "\tpublic void addEntry(Object child, Object parent) {\n\t\tif (child != null) {\n\t\t\tentries.add(new Entry(child, parent));\n\t\t\t// Update Changed Nodes\n\t\t\tchangedNodes.add(child);\n\t\t\tif (parent != null)\n\t\t\t\tchangedNodes.add(parent);\n\t\t}\n\t}\n",
    "119589": "\tpublic void setTarget(Object port) {\n\t\ttarget = port;\n\t}\n",
    "119590": "\tpublic int size() {\n\t\treturn entries.size();\n\t}\n",
    "119591": "\tpublic Object clone() {\n\t\tDefaultEdge c = (DefaultEdge) super.clone();\n\t\tc.source = null;\n\t\tc.target = null;\n\t\treturn c;\n\t}\n",
    "119593": "\tpublic Iterator entries() {\n\t\treturn entries.iterator();\n\t}\n",
    "119596": "\tpublic Set getChangedNodes() {\n\t\treturn changedNodes;\n\t}\n",
    "119597": "\tpublic CellView getParentView() {\n\t\tCellView parent = super.getParentView();\n\t\tif (parent == null)\n\t\t\tparent = lastParent;\n\t\telse\n\t\t\tlastParent = parent;\n\t\treturn parent;\n\t}\n",
    "119598": "\tpublic ParentMap clone(Map map) {\n\t\tParentMap pm = new ParentMap();\n\t\tIterator it = entries();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry e = (Entry) it.next();\n\t\t\tObject child = map.get(e.getChild());\n\t\t\tObject parent = map.get(e.getParent());\n\t\t\tif (child == null)\n\t\t\t\tchild = e.getChild();\n\t\t\tif (parent == null)\n\t\t\t\tparent = e.getParent();\n\t\t\tif (child != null && parent != null)\n\t\t\t\tpm.addEntry(child, parent);\n\t\t}\n\t\treturn pm;\n\t}\n",
    "119599": "\tpublic Rectangle getBounds() {\n\t\tRectangle bounds = new Rectangle(getLocation(null));\n\t\tbounds.x = bounds.x - size / 2;\n\t\tbounds.y = bounds.y - size / 2;\n\t\tbounds.width = bounds.width + size;\n\t\tbounds.height = bounds.height + size;\n\t\treturn bounds;\n\t}\n",
    "119600": "\t\tpublic Object getChild() {\n\t\t\treturn child;\n\t\t}\n",
    "119602": "\t\tpublic Object getParent() {\n\t\t\treturn parent;\n\t\t}\n",
    "119606": "\tprotected Point getNextPoint(EdgeView edge) {\n\t\tint n = edge.getPointCount();\n\t\tif (n > 1) {\n\t\t\tif (edge.getSource() == this)\n\t\t\t\treturn getEdgePoint(edge, 1);\n\t\t\telse if (edge.getTarget() == this)\n\t\t\t\treturn getEdgePoint(edge, n - 2);\n\t\t}\n\t\treturn null;\n\t}\n",
    "119607": "\tpublic void setUserObject(Object obj) {\n\t\tif (userObject instanceof ValueChangeHandler) {\n\t\t\t((ValueChangeHandler) userObject).valueChanged(obj);\n\t\t} else\n\t\t\tsuper.setUserObject(obj);\n\t\tobj = getUserObject();\n\t\tif (obj == null)\n\t\t\tGraphConstants.setValue(attributes, \"\");\n\t\telse\n\t\t\tGraphConstants.setValue(attributes, obj);\n\t}\n",
    "119608": "\tprotected Point getEdgePoint(EdgeView view, int index) {\n\t\tObject obj = view.points.get(index);\n\t\tif (obj instanceof Point)\n\t\t\treturn (Point) obj;\n\t\telse if (obj instanceof PortView) {\n\t\t\tVertexView vertex = (VertexView) ((CellView) obj).getParentView();\n\t\t\tif (vertex != null)\n\t\t\t\treturn vertex.getCenterPoint();\n\t\t}\n\t\treturn null;\n\t}\n",
    "119609": "\tpublic List getChildren() {\n\t\tif (children == null)\n\t\t\treturn Collections.EMPTY_LIST;\n\t\treturn children;\n\t}\n",
    "119615": "\tpublic void setAttributes(Map attributes) {\n\t\tthis.attributes = attributes;\n\t}\n",
    "119617": "\tpublic Object clone() {\n\t\tDefaultGraphCell c = (DefaultGraphCell) super.clone();\n\t\tc.attributes = new Hashtable(attributes);\n\t\tc.userObject = cloneUserObject();\n\t\treturn c;\n\t}\n",
    "119620": "\tpublic String getToolTipText(MouseEvent event) {\n\t\tif (linkHandler.isHoveringOverHyperlink() && (linkHandler.getHoveredURL() != null)) {\n\t\t\t// have to manually toggle tooltip enabled status to prevent empty\n\t\t\t// tooltip from appearing when not hovering over url\n\t\t\tToolTipManager.sharedInstance().setEnabled(true);\n\t\t\treturn linkHandler.getHoveredURL();\n\t\t}\n\t\telse {\n\t\t\tToolTipManager.sharedInstance().setEnabled(false);\n\t\t\treturn null;\n\t\t}\n\t}\n",
    "119621": "\tpublic void setRect(String key, Rectangle r) {\n\t\tString val = r.getX() + \",\" + r.getY() + \",\" + r.getWidth() + \",\" + r.getHeight();\n\t\tthis.setProperty(key, val);\n\t}\n",
    "119624": "\tpublic Point getToolTipLocation(MouseEvent event) {\n\t\treturn new Point(event.getX() + 10, event.getY() + 25);\n\t}\n",
    "119625": "\tpublic Rectangle getRect(String key) {\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint width = 0;\n\t\tint height = 0;\n\t\tString rect = this.getProperty(key);\n\t\ttry {\n\t\t\tStringTokenizer st = new StringTokenizer(rect, \",\");\n\t\t\t     x = (int)Double.parseDouble(st.nextToken());\n\t\t\t     y = (int)Double.parseDouble(st.nextToken());\n\t\t\t width = (int)Double.parseDouble(st.nextToken());\n\t\t\theight = (int)Double.parseDouble(st.nextToken());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Rectangle(x, y, width, height);\n\t}\n",
    "119626": "\tpublic boolean isHoveringOverHyperlink() {\n\t\treturn linkHandler.isHoveringOverHyperlink();\n\t}\n",
    "119627": "\tpublic void save() {\n\t\tUtilities.writePropertiesToFile((Frame)null, this, file,  \"---User Properties--- output from UserProperties.java\");\n\t}\n",
    "119628": "\tpublic String getHoveredURL() {\n\t\treturn linkHandler.getHoveredURL();\n\t}\n",
    "119630": "\t\tpublic boolean isHoveringOverHyperlink() {\n\t\t\t// check if pane is editable as caller could have changed editability after\n\t\t\t// hyperlinkUpdate was fired causing indeterminability in hovering status\n\t\t\tif (pane.isEditable()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn isHovering;\n\t\t\t}\n\t\t}\n",
    "119631": "\tprotected void finalize() throws Throwable {\n\t\tLocaleChangeAdapter.removeContainer(this);\n\t\tPositionManager.removeComponent(this);\n\t\tsuper.finalize();\n\t}\n",
    "119632": "\t\tpublic String getHoveredURL() {\n\t\t\treturn hoveredURLString;\n\t\t}\n",
    "119633": "\tpublic void setName(String name) {\n\t\tsuper.setName(name);\n\t\tPositionManager.updateComponent(this);\n\t\tLocaleChangeAdapter.updateComponent(this);\n\t}\n",
    "119636": "\tpublic void validate() {\n\t\tLocaleChangeAdapter.updateContainer(this);\n\t\tsuper.validate();\n\t}\n",
    "119638": "\tpublic void registerDefaultEscAction() {\n\t\tregisterEscAction(new GPEscAction());\n\t}\n",
    "119640": "\tpublic void registerEscAction(Action action) {\n\t\tthis.getRootPane().registerKeyboardAction(\n\t\t\taction,\n\t\t\tescKeystroke,\n\t\t\tJComponent.WHEN_IN_FOCUSED_WINDOW);\n\t}\n",
    "119642": "\tpublic void unregisterEscAction() {\n\t\tthis.getRootPane().unregisterKeyboardAction(escKeystroke);\n\n\t}\n",
    "119644": "\tpublic void setEscButton(JButton button){\n\t\tregisterEscAction(new GPEscAction(button));\n\t}\n",
    "119647": "\tpublic void setDefaultButton(JButton button){\n\t\tgetRootPane().setDefaultButton(button);\n\t}\n",
    "119649": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(e.getSource().getClass());\n\n\t\t// is the esc button set?\n\t\tif (button != null){\n\t\t\tbutton.doClick();\n\t\t\treturn;\n\t\t}\n\t\t\t \n\n\t\t// is it an internal frame?\n\t\ttry {\n\t\t\tJInternalFrame jif =\n\t\t\t\t(JInternalFrame) SwingUtilities.getAncestorOfClass(\n\t\t\t\t\tJInternalFrame.class,\n\t\t\t\t\t(Component) e.getSource());\n\t\t\tif (jif != null) {\n\t\t\t\tjif.dispose();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tSystem.err.println(ex);\n\t\t}\n\n\t\t// is it an window?\n\t\ttry {\n\t\t\tWindow w =\n\t\t\t\t(Window) SwingUtilities.getAncestorOfClass(\n\t\t\t\t\tWindow.class,\n\t\t\t\t\t(Component) e.getSource());\n\t\t\tif (w != null) {\n\t\t\t\tw.dispose();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tSystem.err.println(ex);\n\t\t}\n\n\t}\n",
    "119653": "\tprotected void finalize() throws Throwable {\n\t\tPositionManager.removeComponent(this);\n\t\tsuper.finalize();\n\t}\n",
    "119661": "\tpublic void localeChanged(LocaleChangeEvent e) {\n\t\tVector copy;\n\t\tsynchronized (containers) {\n\t\t\tcopy = (Vector) containers.clone();\n\t\t}\n\t\tEnumeration oEnum = copy.elements();\n\t\twhile (oEnum.hasMoreElements()) {\n\t\t\tupdateContainer((Container) oEnum.nextElement());\n\t\t}\n\t}\n",
    "119664": "\tpublic Enumeration getKeys() {\n\t\treturn properNames.keys();\n\t}\n",
    "119666": "\tpublic String getString(String key) {\n\t\treturn (String) properNames.get(key);\n\t}\n",
    "119670": "\tpublic void setBounds(Rectangle r) {\n\t\tthis.setBounds(r.x, r.y, r.width, r.height);\n\t}\n",
    "119672": "\tpublic void propertyChange(PropertyChangeEvent evt) {\n\t\tif (evt.getSource() == null)\n\t\t\treturn;\n\n\t\tif (evt.getPropertyName() == JSplitPane.DIVIDER_LOCATION_PROPERTY\n\t\t\t&& ((Integer) evt.getOldValue()).intValue() != -1) {\n\n\t\t\tif (evt.getSource() instanceof JSplitPane) {\n\t\t\t\ttry {\n\t\t\t\t\tJSplitPane jsp = (JSplitPane) evt.getSource();\n\t\t\t\t\tPositionManager.setIntPos(\n\t\t\t\t\t\tjsp,\n\t\t\t\t\t\tPositionManager.DIVIDER_LOCATION,\n\t\t\t\t\t\tjsp.getDividerLocation());\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tSystem.err.println(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "119673": "\tpublic void setLocation(Point p) {\n\t\tthis.setLocation(p.x, p.y);\n\t}\n",
    "119674": "\tpublic void setSnapSelectedView(boolean snapSelectedView) {\n\t\tthis.snapSelectedView = snapSelectedView;\n\t}\n",
    "119675": "\tpublic void setSize(Dimension d) {\n\t\tthis.setSize(d.width, d.height);\n\t}\n",
    "119680": "\tpublic void show() {\n\t\tinit();\n\n\t\tif (hasBeenVisibleAtLeastOnce == false) {\n\t\t\t// set default location to be centered\n\t\t\t// this'buttonSelect implementation of setBounds will deal with checking for persisted value\n\t\t\tDimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n\t\t\tint x = (screenSize.width - this.getWidth()) / 2;\n\t\t\tint y = (screenSize.height - this.getHeight()) / 2;\n\t\t\tthis.setBounds(x, y, this.getWidth(), this.getHeight());\n\t\t}\n\n\t\thasBeenVisibleAtLeastOnce = true;\n\t\tsuper.show();\n\t}\n",
    "119694": "\tpublic void hide() {\n\t\tinit();\n\t\t//Before hiding frame, set properties inside UserProperties then save UserProperties to file in hard disk\n\t\tguiProperties.setRect(property_bounds, this.getBounds());\n\t\tguiProperties.save();\n\t\tsuper.hide();\n\t}\n",
    "119697": "\tprotected void init() {\n\n\t\t// check if not already init'd\n\t\tif (guiProperties == null) {\n\t\t\tguiProperties = UserProperties.getInstance(nameSpace);\n\t\t}\n\n      \t}\n",
    "119701": "\tpublic GPDocument getDocument() {\n\t\treturn document;\n\t}\n",
    "119704": "\tpublic void setDocument(GPDocument document) {\n\t\tthis.remove(this.document);\n\t\tthis.document = document;\n\t\tthis.add(this.document);\n\t\t//this.pack();\n\t}\n",
    "119715": "\tpublic void hide() {\n\t\tinit();\n\t\tguiProperties.setRect(property_bounds, this.getBounds());\n\t\tguiProperties.save();\n\t\tsuper.hide();\n\t}\n",
    "119731": "\tpublic URL getFilename() {\n\t\treturn file;\n\t}\n",
    "119734": "\tpublic void setFilename(URL filename) {\n\t\tthis.file = filename;\n\t\tupdateFrameTitle();\n\t}\n",
    "119750": "\tpublic GPGraph getGraph() {\n\t\treturn graph;\n\t}\n",
    "119752": "\tpublic FileFilter getFileFilter() {\n\t\treturn fileFilter;\n\t}\n",
    "119759": "\tpublic JComponent getWriteAccessory() {\n\t    return null; //compZipSelect;\n\t}\n",
    "119760": "\tprotected GPGraphUI getGraphUI() {\n\t\treturn (GPGraphUI) graph.getUI();\n\t}\n",
    "119762": "\tpublic GraphLayoutCache getGraphLayoutCache() {\n\t\treturn graph.getGraphLayoutCache();\n\t}\n",
    "119768": "\tpublic Hashtable getWriteProperties(JComponent accessory) {\n\t\tHashtable properties = new Hashtable();\n\t\tif (!(accessory instanceof JCheckBox)){\n\t\t\treturn properties;\n\t\t}\n\t\tproperties.put(COMPRESS_WITH_ZIP, new Boolean(((JCheckBox)accessory).isSelected() ));\n\t\treturn properties;\n\t}\n",
    "119805": "\tpublic void updatePageFormat() {\n\t\tPageFormat f = graph.getPageFormat();\n\t\tcolumnRule.setActiveOffset((int) (f.getImageableX()));\n\t\trowRule.setActiveOffset((int) (f.getImageableY()));\n\t\tcolumnRule.setActiveLength((int) (f.getImageableWidth()));\n\t\trowRule.setActiveLength((int) (f.getImageableHeight()));\n\t\tif (graph.isPageVisible()) {\n\t\t\tint w = (int) (f.getWidth());\n\t\t\tint h = (int) (f.getHeight());\n\t\t\tgraph.setMinimumSize(new Dimension(w + 5, h + 5));\n\t\t} else\n\t\t\tgraph.setMinimumSize(null);\n\t\tinvalidate();\n\t\t// Execute fitAction...\n\t\tcomponentResized(null);\n\t\tgraph.repaint();\n\t}\n",
    "119831": "\tpublic GraphUndoManager getGraphUndoManager() {\n\t\treturn graphUndoManager;\n\t}\n",
    "119834": "\tpublic void setGraphUndoManager(GraphUndoManager graphUndoManager) {\n\t\tthis.graphUndoManager = graphUndoManager;\n\t}\n",
    "119837": "\tpublic void delete() {\n\t\tif (selected != null && fullLibraryAccess) {\n\t\t\tGraphCellsComponent tmp = selected;\n\t\t\tGPTransferable t = tmp.getTransferable();\n\t\t\tpanel.getGraph().getModel().remove(t.getCells());\n\t\t\tpanel.remove(tmp);\n\t\t\tsetSelected(null);\n\t\t\tpanel.revalidate();\n\t\t\trepaint();\n\t\t}\n\t}\n",
    "119838": "\tpublic void resetGraphUndoManager() {\n\t\tgraphUndoManager.discardAllEdits();\n\t}\n",
    "119840": "\t\tprotected Transferable createTransferable(JComponent c) {\n\t\t\tif (selected != null) {\n\t\t\t\tdragging = true;\n\t\t\t\treturn selected.getTransferable();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n",
    "119841": "\tpublic GPGraphpad getGraphpad() {\n\t\treturn graphpad;\n\t}\n",
    "119845": "\tpublic void setGraphpad(GPGraphpad graphpad) {\n\t\tthis.graphpad = graphpad;\n\t}\n",
    "119849": "\tpublic Touch getTouch() {\n\t\treturn touch;\n\t}\n",
    "119852": "\tpublic void setTouch(Touch touch) {\n\t\tthis.touch = touch;\n\t}\n",
    "119858": "\t\tpublic void undoableEditHappened(UndoableEditEvent e) {\n\t\t\tif (addEdits)\n\t\t\t\tdocument.getGraphUndoManager().addEdit(e.getEdit());\n\t\t\tdocument.getGraphpad() .getEditUndoAction().update();\n\t\t\tdocument.getGraphpad() .getEditRedoAction().update();\n\t\t}\n",
    "119859": "\tpublic ActionMap getActionMap() {\n\t\treturn actionMap;\n\t}\n",
    "119861": "\tpublic void setActionMap(ActionMap actionMap) {\n\t\tthis.actionMap = actionMap;\n\t}\n",
    "119862": "  public Locale getOldLocale(){\n    return this.oldLocale;\n  }\n",
    "119863": "  public Locale getNewLocale(){\n    return this.newLocale;\n  }\n",
    "119864": "  public void addProperNameProvider(ProperNameProvider provider){\n    properNameProvider.add(provider);\n\n    Enumeration keys = provider.getKeys();\n    while (keys.hasMoreElements()){\n      String key = (String)keys.nextElement();\n      String value = provider.getString(key);\n      if (key != null && value != null){\n        defaultNames.put(key, value);\n      }\n    }\n  }\n",
    "119866": "  public void removeProperNameProvider(ProperNameProvider provider){\n    properNameProvider.remove(provider);\n    requeryDefaultNames();\n  }\n",
    "119869": "  public Enumeration getKeys() {\n    return defaultNames.elements();\n  }\n",
    "119870": "  public Object handleGetObject(String key) {\n    return defaultNames.get(key);\n  }\n",
    "119873": "\tpublic String getFindPattern() {\n\t\treturn findPattern;\n\t}\n",
    "119877": "\tpublic void setFindPattern(String findPattern) {\n\t\tthis.findPattern = findPattern;\n\t}\n",
    "119881": "\tpublic Object getLastFound() {\n\t\treturn lastFound;\n\t}\n",
    "119884": "\tpublic void setLastFound(Object lastFound) {\n\t\tthis.lastFound = lastFound;\n\t}\n",
    "119888": "\tpublic JDialog getOverviewDialog() {\n\t\treturn overviewDialog;\n\t}\n",
    "119891": "\tpublic boolean isGroup(Object cell) {\n\t\t// Map the Cell to its View\n\t\tCellView view = getGraphLayoutCache().getMapping(cell, false);\n\t\tif (view != null)\n\t\t\treturn !view.isLeaf();\n\t\treturn false;\n\t}\n",
    "119892": "\tpublic void setOverviewDialog(JDialog overviewDialog) {\n\t\tthis.overviewDialog = overviewDialog;\n\t}\n",
    "119893": "\tpublic boolean isVertex(Object object) {\n\t\tif (!(object instanceof Port) && !(object instanceof Edge))\n\t\t\treturn !isGroup(object) && object != null;\n\t\treturn false;\n\t}\n",
    "119896": "\tpublic GPSplitPane getSplitPane() {\n\t\treturn splitPane;\n\t}\n",
    "119900": "\tpublic void setSplitPane(GPSplitPane splitPane) {\n\t\tthis.splitPane = splitPane;\n\t}\n",
    "119904": "\tpublic JScrollPane getScrollPane() {\n\t\treturn scrollPane;\n\t}\n",
    "119908": "\tpublic void setScrollPane(JScrollPane scrollPane) {\n\t\tthis.scrollPane = scrollPane;\n\t}\n",
    "119909": "\tpublic String getToolTipText(MouseEvent event) {\n\t\tif (event != null) {\n\t\t\tObject cell = getFirstCellForLocation(event.getX(), event.getY());\n\t\t\tif (cell != null) {\n\t\t\t\tString tmp = convertValueToString(cell);\n\t\t\t\tString s = \"<html>\";\n\t\t\t\tif (tmp != null && tmp.length() > 0)\n\t\t\t\t\ts = s + \"<strong>\" + tmp + \"</strong><br>\";\n\t\t\t\treturn s + getToolTipForCell(cell) + \"</html>\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "119913": "\tpublic Rule getColumnRule() {\n\t\treturn columnRule;\n\t}\n",
    "119914": "\tpublic void updateUI() {\n\t\tsetUI(new GPGraphUI());\n\t\tinvalidate();\n\t}\n",
    "119919": "\tpublic Rule getRowRule() {\n\t\treturn rowRule;\n\t}\n",
    "119920": "\tpublic boolean isNeighbour(Object v1, Object v2) {\n\t\tObject[] edges = getEdgesBetween(v1, v2);\n\t\treturn (edges != null && edges.length > 0);\n\t}\n",
    "119926": "\tprotected void processWindowEvent(WindowEvent e) {\n\t\t//\n\t\tif (e.getID() == WindowEvent.WINDOW_CLOSING) {\n\t\t\t// only close the window when we are not in embedded mode\n\t\t\t// release resources and exit if we are not running embedded, buttonImage.buttonEdge., as\n\t\t\t// part of another application\n\t\t\t//super.processWindowEvent(buttonEdge);\n\t\t\tthis.dispose() ;\n\t\t}\n\t}\n",
    "119927": "\tpublic void setColumnRule(Rule columnRule) {\n\t\tthis.columnRule = columnRule;\n\t}\n",
    "119934": "\tpublic void setRowRule(Rule rowRule) {\n\t\tthis.rowRule = rowRule;\n\t}\n",
    "119940": "\tpublic boolean isEnableTooltips() {\n\t\treturn enableTooltips;\n\t}\n",
    "119947": "\tpublic void setEnableTooltips(boolean enableTooltips) {\n\t\tthis.enableTooltips = enableTooltips;\n\n\t\tif (this.enableTooltips)\n\t\t\tToolTipManager.sharedInstance().registerComponent(graph);\n\t\telse\n\t\t\tToolTipManager.sharedInstance().unregisterComponent(graph);\n\t}\n",
    "119950": "\tpublic void setTextArea(JTextArea ta) {\n\t\tcurrentWindow = ta;\n\t}\n",
    "119952": "\tprivate void clearWindow() {\n\t\tcurrentWindow.setText(\"\");\n\t}\n",
    "119953": "\tpublic GPInternalFrame getInternalFrame() {\n\t\treturn internalFrame;\n\t}\n",
    "119956": "\tpublic void print(boolean b) {\n\t\tif (showOrig)\n\t\t\torig.print(b);\n\t\tif (b)\n\t\t\ttarget.append(\"true\"/*#Frozen*/);\n\t\telse\n\t\t\ttarget.append(\"false\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119958": "\tpublic void println(boolean b) {\n\t\tif (showOrig)\n\t\t\torig.println(b);\n\n\t\tif (b)\n\t\t\ttarget.append(\"true\\n\"/*#Frozen*/);\n\t\telse\n\t\t\ttarget.append(\"false\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119959": "\tprotected void setInternalFrame(GPInternalFrame internalFrame) {\n\t\tthis.internalFrame = internalFrame;\n\t}\n",
    "119960": "\t\t\tprotected Container createContainer() {\n\t\t\t\treturn new MultiLinedEditor.ModifiedEditorContainer();\n\t\t\t}\n",
    "119961": "\tpublic void print(char c) {\n\t\tif (showOrig)\n\t\t\torig.print(c);\n\n\t\tchar[] tmp = new char[1];\n\t\ttmp[0] = c;\n\t\ttarget.append(new String(tmp));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119962": "\tpublic void println(char c) {\n\t\tif (showOrig)\n\t\t\torig.println(c);\n\n\t\tchar[] tmp = new char[2];\n\t\ttmp[0] = c;\n\t\ttmp[1] = '\\n';\n\t\ttarget.append(new String(tmp));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119965": "\tpublic void print(char[] s) {\n\t\tif (showOrig)\n\t\t\torig.print(s);\n\n\t\ttarget.append(new String(s));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119966": "\tpublic void println(char[] s) {\n\t\tif (showOrig)\n\t\t\torig.println(s);\n\n\t\ttarget.append(new String(s) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119968": "\tpublic void print(double d) {\n\t\tif (showOrig)\n\t\t\torig.print(d);\n\n\t\ttarget.append(Double.toString(d));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119971": "\tpublic void println(double d) {\n\t\tif (showOrig)\n\t\t\torig.println(d);\n\n\t\ttarget.append(Double.toString(d) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119972": "\tpublic void print(float f) {\n\t\tif (showOrig)\n\t\t\torig.print(f);\n\n\t\ttarget.append(Float.toString(f));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119973": "\tpublic Hashtable getWriteProperties() {\n\t\treturn writeProperties;\n\t}\n",
    "119974": "\tpublic GraphModelProvider getGraphModelProvider() {\n\t\treturn graphModelProvider;\n\t}\n",
    "119975": "\tpublic void println(float f) {\n\t\tif (showOrig)\n\t\t\torig.println(f);\n\n\t\ttarget.append(Float.toString(f) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119976": "\tpublic void print(int i) {\n\t\tif (showOrig)\n\t\t\torig.print(i);\n\n\t\ttarget.append(Integer.toString(i));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119977": "\tpublic void setWriteProperties(Hashtable writeProperties) {\n\t\tthis.writeProperties = writeProperties;\n\t}\n",
    "119979": "\tpublic void println(int i) {\n\t\tif (showOrig)\n\t\t\torig.println(i);\n\n\t\ttarget.append(Integer.toString(i) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119980": "\tpublic GraphNetworkModel getNetworkModel() {\n\t\treturn networkModel;\n\t}\n",
    "119984": "\tpublic void print(long l) {\n\t\tif (showOrig)\n\t\t\torig.print(l);\n\n\t\ttarget.append(Long.toString(l));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119986": "\tpublic void println(long l) {\n\t\tif (showOrig)\n\t\t\torig.println(l);\n\n\t\ttarget.append(Long.toString(l) + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119989": "\tpublic void setNetworkModel(GraphNetworkModel networkModel) {\n\t\tthis.networkModel = networkModel;\n\t}\n",
    "119990": "\tpublic void print(Object o) {\n\t\tif (showOrig)\n\t\t\torig.print(o);\n\n\t\ttarget.append(o.toString());\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119994": "\tpublic void println(Object o) {\n\t\tif (showOrig)\n\t\t\torig.println(o);\n\n\t\ttarget.append(o.toString() + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "119997": "\tpublic void print(String s) {\n\t\tif (showOrig)\n\t\t\torig.print(s);\n\n\t\ttarget.append(s);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "120002": "\tpublic void println(String s) {\n\t\tif (showOrig)\n\t\t\torig.println(s);\n\n\t\ttarget.append(s + \"\\n\"/*#Frozen*/);\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "120005": "\tpublic void println() {\n\t\tif (showOrig)\n\t\t\torig.println();\n\n\t\ttarget.append(new String(\"\\n\"/*#Frozen*/));\n\t\ttarget.setCaretPosition(target.getText().length());\n\t}\n",
    "120016": "\tpublic String getBarKey() {\n\t\treturn barKey;\n\t}\n",
    "120017": "\tpublic String getBarValue() {\n\t\treturn barValue;\n\t}\n",
    "120020": "\tpublic int getPos() {\n\t\treturn pos;\n\t}\n",
    "120021": "\tpublic void setBarKey(String barKey) {\n\t\tthis.barKey = barKey;\n\t}\n",
    "120022": "\tpublic void setBarValue(String barValue) {\n\t\tthis.barValue = barValue;\n\t}\n",
    "120024": "\tpublic void setPos(int pos) {\n\t\tthis.pos = pos;\n\t}\n",
    "120025": "\tpublic String toString(){\n\t\tStringBuffer b = new StringBuffer();\n\t\tb.append(\"GPBarEntry: barKey=\");\n\t\tb.append(barKey);\n\t\tb.append(\"; pos=\");\n\t\tb.append(pos);\n\t\tb.append(\"; barValue=\");\n\t\tb.append(barValue);\n\t\treturn b.toString() ;\n\t}\n",
    "120039": "\tpublic JMenuBar createMenubar() {\n\t\tJMenuBar mb = new JMenuBar();\n\n\t\tString[] menuKeys = tokenize(MENUBAR, Translator.getString(MENUBAR));\n\t\tfor (int i = 0; i < menuKeys.length; i++) {\n\t\t\tString itemKey = Translator.getString(menuKeys[i] + SUFFIX_MENU);\n\t\t\tif (itemKey == null) {\n\t\t\t\tSystem.err.println(\n\t\t\t\t\t\"Can't find MenuKey: '\"\n\t\t\t\t\t\t+ menuKeys[i]\n\t\t\t\t\t\t+ \"'. I'm ignoring the MenuKey!\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] itemKeys = tokenize(menuKeys[i], itemKey);\n\t\t\tJMenu m = createMenu(menuKeys[i], itemKeys);\n\t\t\tif (m != null)\n\t\t\t\tmb.add(m);\n\t\t}\n\t\treturn mb;\n\t}\n",
    "120043": "\tpublic JPopupMenu createGraphPopupMenu() {\n\t\treturn createPopupMenu(GRAPH_POPUP);\n\t}\n",
    "120046": "\tpublic JPopupMenu createLibraryPopupMenu() {\n\t\treturn createPopupMenu(LIBRARY_POPUP);\n\t}\n",
    "120049": "\tprotected JPopupMenu createPopupMenu(String key) {\n\t\tJPopupMenu pop = new JPopupMenu();\n\t\tString[] itemKeys = tokenize(key, Translator.getString(key));\n\t\tfor (int i = 0; i < itemKeys.length; i++) {\n\t\t\tif (itemKeys[i].equals(\"-\")) {\n\t\t\t\tpop.addSeparator();\n\t\t\t} else {\n\t\t\t\tComponent[] mi = createMenuItem(itemKeys[i]);\n\t\t\t\tfor (int j = 0; j < mi.length; j++) {\n\t\t\t\t\tpop.add(mi[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLocaleChangeAdapter.updateContainer(pop);\n\n\t\treturn pop;\n\t}\n",
    "120050": "\t\tpublic Map diffMap(Map oldState, Map newState) {\n\t\t\tMap diff = new Hashtable();\n\t\t\tIterator it = newState.entrySet().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tMap.Entry entry = (Map.Entry) it.next();\n\t\t\t\tObject key = entry.getKey();\n\t\t\t\tObject newValue = entry.getValue();\n\t\t\t\tObject oldValue = oldState.get(key);\n\t\t\t\tif (oldValue == null || !oldValue.equals(newValue))\n\t\t\t\t\tdiff.put(key, newValue);\n\t\t\t}\n\t\t\treturn diff;\n\t\t}\n",
    "120052": "\tprotected JMenu createMenu(String key) {\n\n\t\treturn createMenu(key, tokenize(key, Translator.getString(key)));\n\t}\n",
    "120114": "\tpublic void update() {\n\t\tEnumeration enumerator = abstractButtons.elements();\n\t\twhile (enumerator.hasMoreElements()) {\n\t\t\tAbstractButton button = (AbstractButton) enumerator.nextElement();\n\t\t\tbutton.setSelected(isSelected(button.getActionCommand()));\n\t\t}\n\t}\n",
    "120116": "\tpublic String getPresentationText(String actionCommand) {\n\t\tif (actionCommand == null)\n\t\t\treturn null;\n\t\t\t\n\t\tfor (int i = 0; i < lookAndFeels.length ; i++){\n\t\t\tif (lookAndFeels[i].getClassName().equals(actionCommand)){\n\t\t\t\treturn lookAndFeels[i].getName() ;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn actionCommand;\n\t}\n",
    "120142": "\tpublic String openDialog(String message, String extension, String desc) {\n\t\treturn dialog(message, true, extension, desc);\n\t}\n",
    "120146": "\tpublic String saveDialog(String message, String extension, String desc) {\n\t\treturn dialog(message, false, extension, desc);\n\t}\n",
    "120150": "\t\tpublic boolean accept(File file) {\n\t\t\treturn file.isDirectory()\n\t\t\t\t|| file.getName().toLowerCase().endsWith(fullExt);\n\t\t}\n",
    "120153": "\t\tpublic String getDescription() {\n\t\t\treturn desc;\n\t\t}\n",
    "120173": "\tprotected ListCellRenderer getItemListCellRenderer() {\n\t\treturn null;\n\t};\n",
    "120176": "\tprotected String getItemPresentationText(Object item) {\n\t\treturn item.toString();\n\t}\n",
    "120191": "\tpublic JToggleButton getButtonActivity() {\n\t\treturn buttonActivity;\n\t}\n",
    "120201": "\tpublic void update() {\n\t\tsuper.update();\n\n\t\tEnumeration enumerator = abstractButtons.elements();\n\t\twhile (enumerator.hasMoreElements()) {\n\t\t\tAbstractButton button = (AbstractButton) enumerator.nextElement();\n\t\t\tbutton.setSelected(isSelected(button.getActionCommand()));\n\t\t}\n\t}\n",
    "120202": "\tpublic void removeAbstractButton(AbstractButton button){\n\t\tabstractButtons.remove(button);\n\t}\n",
    "120210": "\tpublic JToggleButton getButtonDecision() {\n\t\treturn buttonDecision;\n\t}\n",
    "120225": "\tpublic JToggleButton getButtonStart() {\n\t\treturn buttonStart;\n\t}\n",
    "120244": "\tpublic JToggleButton getButtonEnd() {\n\t\treturn buttonEnd;\n\t}\n",
    "120265": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tString name =\n\t\t\tJOptionPane.showInputDialog(Translator.getString(\"URLDialog\", new Object[]{\"foo.gpd\"}));\n\n\t\t// canceled?\n\t\tif (name == null)\n\t\t\treturn;\n\n\t\t// open the graphpad\n\t\ttry {\n\t\t\tgraphpad.addDocument(new URL(name));\n\t\t} catch (MalformedURLException ex) {\n\t\t\tJOptionPane.showMessageDialog(\n\t\t\t\tgraphpad,\n\t\t\t\tex.getLocalizedMessage(),\n\t\t\t\tTranslator.getString(\"Error\"),\n\t\t\t\tJOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n",
    "120268": "\tpublic JToggleButton getButtonSplit() {\n\t\treturn buttonSplit;\n\t}\n",
    "120277": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tJInternalFrame[] ajif = graphpad.getAllFrames();\n\n\t\tfor (int i = 0; i < ajif.length; i++) {\n\t\t\ttry {\n\t\t\t\tajif[i].setMaximum(true);\n\t\t\t} catch (java.beans.PropertyVetoException pvex) {\n\n\t\t\t}\n\t\t}\n\t}\n",
    "120281": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tJInternalFrame[] ajif = graphpad.getAllFrames();\n\n\t\tfor (int i = 0; i < ajif.length; i++) {\n\t\t\ttry {\n\t\t\t\tajif[i].setIcon(true);\n\t\t\t} catch (java.beans.PropertyVetoException pvex) {\n\t\t\t\t// do nothing\n\t\t\t}\n\t\t}\n\t}\n",
    "120291": "\tpublic JToggleButton getButtonJoin() {\n\t\treturn buttonJoin;\n\t}\n",
    "120313": "\tpublic JToggleButton getButtonEdge() {\n\t\treturn buttonEdge;\n\t}\n",
    "120314": "\tpublic String getURL(GPGraph graph, Object cell) {\n\t\tif (cell instanceof DefaultGraphCell) {\n\t\t\tfinal Object userObject = ((DefaultGraphCell) cell).getUserObject();\n\t\t\tif (userObject instanceof GPUserObject) {\n\t\t\t\tObject url = ((GPUserObject) userObject).getProperty(GPUserObject.keyURI);\n\t\t\t\tif (url != null)\n\t\t\t\t\treturn url.toString();\n\t\t\t}\n\t\t}\n\t\treturn cell.toString();\n\t}\n",
    "120316": "\tpublic String getLabel(GPGraph graph, Object cell) {\n\t\treturn graph.convertValueToString(cell.toString());\n\t}\n",
    "120320": "\tpublic String getName() {\n\t\treturn (String) getValue(NAME);\n\t}\n",
    "120331": "\tpublic JToggleButton getButtonLine() {\n\t\treturn buttonLine;\n\t}\n",
    "120337": "\tpublic void actionPerformed(ActionEvent e) {\n\t\tGPInternalFrame gpframe = (GPInternalFrame) this.getSelectedItem(e);\n\t\tgpframe.toFront();\n\t\ttry {\n\t\t\tgpframe.setSelected(true);\n\t\t} catch (PropertyVetoException pve) {\n\t\t}\n\t}\n",
    "120339": "\tprotected JMenu getMenuBarComponent() {\n\t\tJMenu menu = new JMenu(this);\n\t\tmenu.setName(getName());\n\t\tmenus.add(menu);\n\t\treturn menu;\n\t}\n",
    "120340": "\tpublic String getPresentationText(String actionCommand) {\n\t\treturn actionCommand;\n\t}\n",
    "120343": "\tpublic void update(){\n\t\tsuper.update() ;\n\n\t\tJInternalFrame[] iframes = graphpad.getAllFrames();\n\n\t\tfor (int j = 0; j < menus.size(); j++) {\n\t\t\tJMenu menu = (JMenu) menus.get(j);\n\t\t\tmenu.removeAll();\n\n\t\t\tfor (int i = 0; i < iframes.length; i++) {\n\t\t\t\tGPInternalFrame internalFrame = (GPInternalFrame) iframes[i];\n\t\t\t\tmenu.add(\n\t\t\t\t\tgetMenuComponent(\n\t\t\t\t\t\tinternalFrame.getDocument().getFrameTitle(),\n\t\t\t\t\t\tinternalFrame));\n\t\t\t}\n\t\t}\n\t}\n",
    "120344": "\tprotected Component getMenuComponent(String actionCommand) {\n\t\tJMenuItem item = new JMenuItem(this);\n\t\tGPBarFactory.fillMenuButton(item, getName(), actionCommand);\n\t\tString presentationText = getPresentationText(actionCommand);\n\t\tif (presentationText != null)\n\t\t\titem.setText(presentationText);\n\n\t\treturn item;\n\t}\n",
    "120346": "\tpublic JToggleButton getButtonSelect() {\n\t\treturn buttonSelect;\n\t}\n",
    "120348": "\tprotected Component getToolComponent(String actionCommand) {\n\t\tAbstractButton b = new JButton(this) {\n\t\t\tpublic float getAlignmentY() {\n\t\t\t\treturn 0.5f;\n\t\t\t}\n\t\t};\n\t\treturn GPBarFactory.fillToolbarButton(\n\t\t\tb,\n\t\t\tgetName(),\n\t\t\tactionCommand);\n\t}\n",
    "120354": "\tpublic void update() {\n\t\tif (graphpad.getCurrentDocument() == null)\n\t\t\tsetEnabled(false);\n\t\telse\n\t\t\tsetEnabled(true);\n\t}\n",
    "120357": "\tpublic String getPresentationText(String actionCommand) {\n\t\treturn null;\n\t}\n",
    "120363": "\tpublic JToggleButton getButtonText() {\n\t\treturn buttonText;\n\t}\n",
    "120382": "\tpublic JToggleButton getButtonZoomArea() {\n\t\treturn buttonZoomArea;\n\t}\n",
    "120385": "\tpublic String getMessage() {\n\t\treturn message.getText() ;\n\t}\n",
    "120386": "\tpublic String getPresentationName() {\n\t\treturn \"Default Graph Model\";\n\t}\n",
    "120388": "\tpublic String getScale() {\n\t\treturn scale.getText() ;\n\t}\n",
    "120392": "\tpublic void setMessage(String message) {\n\t\tthis.message.setText(message);\n\t}\n",
    "120394": "\tpublic void setScale(String scale) {\n\t\tthis.scale.setText(scale);\n\t}\n",
    "120395": "\tpublic GraphModel createCleanGraphModel() {\n\t\treturn new DefaultGraphModel();\n\t}\n",
    "120397": "\tpublic boolean isMutateAbleTo(Class otherGraphModelClass) {\n\t\treturn false;\n\t}\n",
    "120404": "\tpublic void addPort(Object vertex, Object port) {\n\t\tif (port instanceof DefaultPort) {\n\t\t\tif (vertex instanceof DefaultMutableTreeNode) {\n\t\t\t\t((DefaultMutableTreeNode) vertex).add((DefaultPort) port);\n\t\t\t}\n\t\t}\n\t}\n",
    "120408": "\tpublic GPGraph createCleanGraph(GraphModel model) {\n\t\tGPGraph graph = new GPGraph(model);\n\t\t// TODO: Remove this code when VM is fixed on Mac OS X\n\t\tif (System.getProperty(\"os.name\").equals(\"Mac OS X\")) {\n\t\t\tString s = Translator.getString(\"doubleBufferedOnMacOSX\");\n\t\t\tif (s != null)\n\t\t\t\tgraph.setDoubleBuffered(Boolean.getBoolean(s));\n\t\t}\n\t\treturn graph;\n\t}\n",
    "120412": "\tpublic GraphModelProvider getSelectedGraphModelProvider(){\n\t\tif (lstGraphModelProviders.getModel() .getSize() == 0)\n\t\t\treturn null;\n\t\treturn (GraphModelProvider)lstGraphModelProviders.getSelectedValue() ;\n\t}\n",
    "120426": "\tpublic int getAnswer() {\n\t\treturn answer;\n\t}\n",
    "120432": "\tpublic void show(){\n\n\t\tif (lstGraphModelProviders .getModel() .getSize() <= 1)\n\t\t\treturn;\n\t\telse\n\t\t\tsuper.show();\n\t}\n",
    "120538": "\tprotected Object cloneUserObject() {\n\t\treturn userObject;\n\t}\n",
    "120540": "\tpublic CellHandle getHandle(GraphContext context) {\n\t\tif (GraphConstants.isSizeable(getAllAttributes())\n\t\t\t\t&& context.getGraph().isSizeable())\n\t\t\treturn new JGpdSizeHandle(this, context);\n\t\treturn null;\n\t}\n",
    "120684": "\tpublic void removeGPInternalFrame(GPInternalFrame f) {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf.setVisible(false);\n\t\tdesktop.remove(f);\n\t\tdoc2InternalFrame.remove(f.getDocument());\n\t\tf.cleanUp();\n\t\tJInternalFrame[] frames = desktop.getAllFrames();\n\t\tif (frames.length > 0) {\n\t\t\ttry {\n\t\t\t\tframes[0].setSelected(true);\n\t\t\t} catch (PropertyVetoException e) {\n\t\t\t}\n\t\t}\n\t}\n",
    "120743": "\tpublic GPMarqueeHandler getMarqueeHandler() {\n\t\treturn marqueeHandler;\n\t}\n",
    "121353": "\tprotected JMenu getMenuBarComponent() {\n//\t\tJMenu menu = new JMenu(this);\n//\t\tmenu.setName(getName());\n//\t\tmenus.add(menu);\n\t\treturn null; //menu;\n\t}\n",
    "121420": "\tpublic GPGraph createCleanGraph(GraphModel model) {\n\t\tGPGraph graph = new GPGraph(model);\n\t\t// TODO: Remove this code when VM is fixed on Mac OS X\n\t\tif (System.getProperty(\"os.name\").equals(\"Mac OS X\")) {\n\t\t\tString s = Translator.getString(\"doubleBufferedOnMacOSX\");\n\t\t\tif (s != null)\n\t\t\t\tgraph.setDoubleBuffered(Boolean.getBoolean(s));\n\t\t}\n\t\tgraph.setDragEnabled(true);\n\t\treturn graph;\n\t}\n",
    "121484": "  public void pprop(String name, Object value) {\n    LogoList listTemp = new LogoList();\n    boolean found = false;\n\n    while (!data.empty()) {\n      String pname = (String) data.first();\n      data.butFirstF();\n      Object pValue = data.first();\n      data.butFirstF();\n\n      if (pname.equalsIgnoreCase(name)) {\n        listTemp.fputF(value);\n        listTemp.fputF(name);\n        found = true;\n      } else {\n        listTemp.fputF(pValue);\n        listTemp.fputF(pname);\n      }\n    }\n\n    if (!found) {\n      listTemp.fputF(value);\n      listTemp.fputF(name);\n    }\n\n    data = listTemp;\n  }\n",
    "121487": "  public void rprop(String name) {\n    LogoList listTemp = new LogoList();\n\n    while (!data.empty()) {\n      String pname = (String) data.first();\n      data.butFirstF();\n      Object pValue = data.first();\n      data.butFirstF();\n\n      // copy to new list only if not what we're removing\n      if (!pname.equalsIgnoreCase(name)) {\n        listTemp.fputF(pValue);\n        listTemp.fputF(pname);\n      }\n    }\n\n    data = listTemp;\n  }\n",
    "121488": "  public Object gprop(String name) {\n    LogoList listTemp = data.duplicate();\n\n    while (!listTemp.empty()) {\n      String pname = (String) listTemp.first();\n      listTemp.butFirstF();\n      Object value = listTemp.first();\n      listTemp.butFirstF();\n\n      if (pname.equalsIgnoreCase(name))\n        return value;\n    }\n\n    return null;\n  }\n",
    "121492": "  public LogoList lprops() {\n    LogoList listTemp = new LogoList();\n    LogoList outList = new LogoList();\n\n    while (!data.empty()) {\n      String name = (String) data.first();\n      data.butFirstF();\n      Object value = data.first();\n      data.butFirstF();\n\n      listTemp.fputF(value);\n      listTemp.fputF(name);\n\n      outList.fputF(name);\n    }\n\n    data = listTemp;\n\n    return outList;\n  }\n",
    "121494": "  public String toString() {\n    return data.toString();\n  }\n",
    "121497": "  public LogoMap duplicate() {\n    return new LogoMap(data);\n  }\n",
    "121502": "  public void fputF(Object o) {\n    head = new LogoLink(o, head);\n  }\n",
    "121505": "  public LogoList fput(Object o) {\n    LogoList out = this.duplicate();\n    out.fputF(o);\n    return out;\n  }\n",
    "121508": "  public void lputF(Object o) {\n    if (empty()) {\n      head = new LogoLink(o);\n    } else {\n      LogoLink cur = head;\n      while (cur.next != null) {\n        cur = cur.next;\n      }\n      cur.next = new LogoLink(o);\n    }\n  }\n",
    "121512": "  public LogoList lput(Object o) {\n    LogoList out = this.duplicate();\n    out.lputF(o);\n    return out;\n  }\n",
    "121516": "  public boolean empty() {\n    return head == null;\n  }\n",
    "121518": "  public Object first() {\n    if (!empty()) {\n      return head.data;\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"First does not like [] as input.\");\n      else throw new RuntimeException(\"Cannot use first on an empty list.\");\n    }\n  }\n",
    "121522": "  public Object last() {\n    if (!empty()) {\n      LogoLink cur = head;\n      while (cur.next != null)\n        cur = cur.next;\n      return cur.data;\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"Last does not like [] as input.\");\n      else throw new RuntimeException(\"Cannot use last on an empty list\");\n    }\n  }\n",
    "121524": "  public LogoList butFirst() {\n    LogoList out = duplicate();\n    out.butFirstF();\n    return out;\n  }\n",
    "121526": "  public LogoList butLast() {\n    LogoList out = duplicate();\n    out.butLastF();\n    return out;\n  }\n",
    "121527": "  protected void init(String file, OutputStream out) throws IOException {\n    filename = file;\n    output = new PrintStream(out);\n    tempRead = File.createTempFile(\"file1\",\".temp\");\n    tempWrite = File.createTempFile(\"file2\",\".temp\");\n  }\n",
    "121528": "  public LogoList butFirstF() {\n    if (!empty()) {\n      head = head.next;\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"butfirst does not like \" + this.toString() +\n                                   \" as input.\");\n      else throw new RuntimeException(\"Cannot use butfirst on an empty list\");\n    }\n\n    return this;\n  }\n",
    "121531": "  public LogoList butLastF() {\n    if (!empty()) {\n      if (head.next == null) {\n        // means head is the last one, remove it\n        head = null;\n      } else {\n        LogoLink cur = head;\n        while (cur.next.next != null)\n          cur = cur.next;\n        cur.next = null;\n      }\n    } else {\n      if (logoErrors)\n        throw new RuntimeException(\"butlast does not like [] as input.\");\n      else throw new RuntimeException(\"Cannot use butlast on an empty list\");\n    }\n\n    return this;\n  }\n",
    "121533": "  public int count() {\n    if (empty()) {\n      return 0;\n    } else {\n      int count = 1;\n      LogoLink cur = head;\n\n      while (cur.next != null) {\n        count++;\n        cur = cur.next;\n      }\n\n      return count;\n    }\n  }\n",
    "121535": "  protected void preparse(File file) throws IOException {\n    File tRead = tempRead;\n    try {\n      debug(\"preparsing \" + tempRead.getAbsolutePath() + \" to \" +\n            tempWrite.getAbsolutePath());\n      prepareFiles(file, tempWrite, true);\n      tempOut.println(\"#inserted \" + file.getAbsolutePath());\n\n      String line = tempIn.readLine();\n      while (line != null) {\n\n        if (line.indexOf(\"//\") > 0) {\n          line = line.substring(0, line.indexOf(\"//\"));\n        }\n\n        if (line.length() > 0) {\n          tempOut.println(line);\n        }\n\n        line = tempIn.readLine();\n      }\n\n      debug(\"Preparsed \" + filename);\n    } catch (IOException ex) {\n      tempRead = tRead; // make sure this runs\n      throw ex;\n    }\n    tempRead = tRead;\n  }\n",
    "121539": "  public LogoList duplicate() {\n    LogoList out = new LogoList();\n\n    out.copyListToMemory(head);\n\n    return out;\n  }\n",
    "121543": "  public String toString() {\n    StringBuffer out = new StringBuffer(\"[\");\n\n    LogoLink cur = head;\n\n    while (cur != null) {\n      if (cur.data != null)\n        out.append(cur.data.toString());\n      else out.append(\" \");\n      if (cur.next != null) out.append(\" \");\n\n      cur = cur.next;\n    }\n\n    out.append(\"]\");\n    return out.toString();\n  }\n",
    "121546": "  public void removeAll(Object o) {\n    LogoList copy = duplicate();\n    this.clean();\n\n    while (!copy.empty()) {\n      if (copy.first() != o)\n        fput(copy.first());\n      copy.butFirstF();\n    }\n\n    copy = duplicate();\n    clean();\n    while (!copy.empty()) {\n      fput(copy.first());\n      copy.butFirstF();\n    }\n\n  }\n",
    "121548": "  public void doList(ForEachListener fel) {\n    LogoLink cur = head;\n    while (cur != null) {\n      fel.doFor(cur.data);\n      cur = cur.next;\n    }\n  }\n",
    "121551": "  public boolean contains(Object o) {\n    LogoLink cur = head;\n    boolean found = false;\n\n    while (cur != null && !found) {\n      found = cur.data == o || (cur.data != null && cur.data.equals(o));\n\n      if (o instanceof String && cur.data instanceof String) {\n        found |= ((String)o).equalsIgnoreCase((String)cur.data);\n      }\n\n      cur = cur.next;\n    }\n\n    return found;\n  }\n",
    "121552": "  public void clean() {\n    head = null;\n  }\n",
    "121554": "  protected String writeType(String value, String type) {\n    if (type.matches(\"CHAR\\\\(\\\\d+\\\\).*\") || type.matches(\"VARCHAR.*\")) {\n      return \"'\" + value.trim().replaceAll(\"\\'\",\"\\\\'\") + \"'\";\n//      return \"STRING\";\n    } else {\n//      return type;\n      return value.trim();\n    }\n  }\n",
    "121567": "  protected boolean FSM_compilerDirective(String line) {\n    for(int i = 0; i < line.length(); i++) {\n      if (line.charAt(i) == '#') {\n        return true;\n      } else if (line.charAt(i) == ' ' || line.charAt(i) == '\\t') {\n        // do nothing, its is still possible\n      } else {\n        // proven wrong\n        return false;\n      }\n    }\n    return false;\n  }\n",
    "121585": "  public void debug(String text) {\n    if (debugOn) debugStream.println(text);\n  }\n",
    "121607": "\tprivate JPanel getJContentPane() {\n\t\tif (jContentPane == null) {\n\t\t\tjContentPane = new JPanel();\n\t\t\tjContentPane.setLayout(new BorderLayout());\n\t\t\tjContentPane.add(getJPanel(), java.awt.BorderLayout.CENTER);\n\t\t}\n\t\treturn jContentPane;\n\t}\n",
    "121610": "\tprivate JMenuBar getJJMenuBar() {\n\t\tif (jJMenuBar == null) {\n\t\t\tjJMenuBar = new JMenuBar();\n\t\t\tjJMenuBar.add(getFileMenu());\n\t\t\tjJMenuBar.add(getHelpMenu());\n\t\t}\n\t\treturn jJMenuBar;\n\t}\n",
    "121612": "\tprivate JMenu getFileMenu() {\n\t\tif (fileMenu == null) {\n\t\t\tfileMenu = new JMenu();\n\t\t\tfileMenu.setText(\"File\");\n\t\t\tfileMenu.add(getExitMenuItem());\n\t\t}\n\t\treturn fileMenu;\n\t}\n",
    "121614": "\tprivate JMenu getHelpMenu() {\n\t\tif (helpMenu == null) {\n\t\t\thelpMenu = new JMenu();\n\t\t\thelpMenu.setText(\"Help\");\n\t\t\thelpMenu.add(getAboutMenuItem());\n\t\t}\n\t\treturn helpMenu;\n\t}\n",
    "121616": "\tprivate JMenuItem getExitMenuItem() {\n\t\tif (exitMenuItem == null) {\n\t\t\texitMenuItem = new JMenuItem();\n\t\t\texitMenuItem.setText(\"Exit\");\n\t\t\texitMenuItem.addActionListener(new ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn exitMenuItem;\n\t}\n",
    "121620": "\tprivate JMenuItem getAboutMenuItem() {\n\t\tif (aboutMenuItem == null) {\n\t\t\taboutMenuItem = new JMenuItem();\n\t\t\taboutMenuItem.setText(\"About\");\n\t\t\taboutMenuItem.addActionListener(new ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tJOptionPane\n\t\t\t\t\t\t\t.showMessageDialog(\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\"MPGCalculator \\n\\nBy Yann Laviolette, Stratag\ufffdme Ing\ufffdnierie Conseil\\n(c) 2005 - Under GPL Licence\",\n\t\t\t\t\t\t\t\t\t\"About\", JOptionPane.INFORMATION_MESSAGE);\n\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn aboutMenuItem;\n\t}\n",
    "121627": "\tprivate JTextField getTxtDistance() {\n\t\tif (txtDistance == null) {\n\t\t\ttxtDistance = new JTextField();\n\t\t\ttxtDistance.setPreferredSize(new java.awt.Dimension(10, 20));\n\t\t\ttxtDistance.setSize(new java.awt.Dimension(85, 20));\n\t\t\ttxtDistance.setHorizontalAlignment(javax.swing.JTextField.RIGHT);\n\t\t\ttxtDistance.setLocation(new java.awt.Point(100, 30));\n\t\t}\n\t\treturn txtDistance;\n\t}\n",
    "121629": "\tprivate JTextField getTxtConsumption() {\n\t\tif (txtConsumption == null) {\n\t\t\ttxtConsumption = new JTextField();\n\t\t\ttxtConsumption.setLocation(new java.awt.Point(100, 60));\n\t\t\ttxtConsumption.setHorizontalAlignment(javax.swing.JTextField.RIGHT);\n\t\t\ttxtConsumption.setSize(new java.awt.Dimension(85, 20));\n\t\t}\n\t\treturn txtConsumption;\n\t}\n",
    "121631": "\tprivate JComboBox getCboDistanceUnit() {\n\t\tif (cboDistanceUnit == null) {\n\t\t\tcboDistanceUnit = new JComboBox();\n\t\t\tcboDistanceUnit.setMaximumRowCount(2);\n\t\t\tcboDistanceUnit.setSize(new java.awt.Dimension(85, 20));\n\t\t\tcboDistanceUnit.setLocation(new java.awt.Point(200, 30));\n\t\t}\n\t\treturn cboDistanceUnit;\n\t}\n",
    "121633": "\tprivate JComboBox getCboConsumptionUnit() {\n\t\tif (cboConsumptionUnit == null) {\n\t\t\tcboConsumptionUnit = new JComboBox();\n\t\t\tcboConsumptionUnit.setLocation(new java.awt.Point(200, 60));\n\t\t\tcboConsumptionUnit.setSize(new java.awt.Dimension(85, 20));\n\t\t}\n\t\treturn cboConsumptionUnit;\n\t}\n",
    "121636": "\tprivate JButton getBttnCalculate() {\n\t\tif (bttnCalculate == null) {\n\t\t\tbttnCalculate = new JButton();\n\t\t\tbttnCalculate.setBounds(new java.awt.Rectangle(114, 113, 88, 23));\n\t\t\tbttnCalculate\n\t\t\t\t\t.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n\t\t\tbttnCalculate.setToolTipText(\"Calculates the consumption\");\n\t\t\tbttnCalculate.setText(\"Calculate\");\n\n\t\t\tbttnCalculate\n\t\t\t\t\t.addActionListener(new java.awt.event.ActionListener() {\n\t\t\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {\n\t\t\t\t\t\t\tcontroller.calculate(txtDistance.getText(),\n\t\t\t\t\t\t\t\t\t(String) cboDistanceUnit.getSelectedItem(),\n\t\t\t\t\t\t\t\t\ttxtConsumption.getText(),\n\t\t\t\t\t\t\t\t\t(String) cboConsumptionUnit\n\t\t\t\t\t\t\t\t\t\t\t.getSelectedItem());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\treturn bttnCalculate;\n\t}\n",
    "121639": "\tpublic double calculateMpgKmL(double distanceInKm, double numberOfLiters) {\n\t\tdouble distanceInMiles = distanceInKm * Constants.kmToMile;\n\t\tdouble numberOfGallons = numberOfLiters * Constants.lToGal;\n\n\t\treturn distanceInMiles / numberOfGallons;\n\n\t}\n",
    "121642": "\tpublic double calculateMpgKmGal(double distanceInKm, double numberOfGallons) {\n\t\tdouble distanceInMiles = distanceInKm * Constants.kmToMile;\n\t\treturn distanceInMiles / numberOfGallons;\n\t}\n",
    "121643": "  protected String writeType(String value, String type) {\n    if (type.matches(\"CHAR\\\\(\\\\d+\\\\).*\")\n        || type.matches(\"VARCHAR.*\")\n        || type.matches(\"BLOB.*\")) {\n      return \"'\" + value.trim().replaceAll(\"\\'\",\"\\\\'\") + \"'\";\n//      return \"STRING\";\n    } else {\n//      return type;\n      return value.trim();\n    }\n  }\n",
    "121645": "\tpublic double calculateMpgML(double distanceInMiles, double numberOfLiters) {\n\t\tdouble numberOfGallons = numberOfLiters * Constants.lToGal;\n\n\t\treturn distanceInMiles / numberOfGallons;\n\n\t}\n",
    "121648": "\tpublic double calculateL100KmKmL(double distanceInKm, double numberOfLiters) {\n\t\treturn (numberOfLiters * 100) / distanceInKm;\n\t}\n",
    "121661": "\tpublic void show() {\n\t\tdialog.show();\n\t}\n",
    "121663": "\tpublic void setCurrent(int aCurrent) {\n\t\tcurrent = aCurrent;\n\t}\n",
    "121664": "\tpublic int getCurrent() {\n\t\treturn current;\n\t}\n",
    "121665": "\tpublic boolean show() {\n\t\tdialog.pack();\n\t\tif (result) {\n\t\t\tmYes.getFocus();\n\t\t} else {\n\t\t\tmNo.getFocus();\n\t\t}\n\n\t\tdialog.show();\n\t\treturn result;\n\t}\n",
    "121666": "\tpublic void setDoCancel(ActionListener aDoCancel) {\n\t\tdoCancel = aDoCancel;\n\t}\n",
    "121670": "\tpublic void setMax(int aMax) {\n\t\tmax = aMax;\n\t}\n",
    "121673": "\tpublic int getMax() {\n\t\treturn max;\n\t}\n",
    "121675": "\tpublic void setMessage(String aMessage) {\n\t\tmessage = aMessage;\n\t\tif (msgLabel != null) {\n\t\t\tmsgLabel.setText(message);\n\t\t\twindow.pack();\n\t\t\t//window.show();\n\t\t}\n\t}\n",
    "121678": "\tpublic String getMessage() {\n\t\treturn message;\n\t}\n",
    "121682": "\tpublic void setMin(int aMin) {\n\t\tmin = aMin;\n\t}\n",
    "121685": "\tpublic int getMin() {\n\t\treturn min;\n\t}\n",
    "121687": "\tpublic void close() {\n\t\tif (window != null) {\n\t\t\twindow.close();\n\t\t}\n\t}\n",
    "121699": "\tpublic void setTitle(String aTitle) {\n\t\ttitle = aTitle;\n\t}\n",
    "121707": "\tpublic void setBackground(short background) {\n\t\tverifyColor(background);\n\t\t_background = background;\n\t\t//initChtype();\n\t}\n",
    "121714": "\tpublic void setBlackWhiteAttribute(short blackWhiteAttribute) {\n\t\t_blackWhiteAttribute = blackWhiteAttribute;\n\t}\n",
    "121722": "\tpublic void setColorAttribute(short colorAttribute) {\n\t\t_colorAttribute = colorAttribute;\n\t}\n",
    "121729": "\tpublic void setForeground(short foreground) {\n\t\tverifyColor(foreground);\n\t\t_foreground = foreground;\n\t\t//initChtype();\n\t}\n",
    "121732": "\tpublic short getForeground() {\n\t\treturn _foreground;\n\t}\n",
    "121735": "\tpublic String toString() {\n\t\tif (Toolkit.hasColors()) {\n\t\t\treturn \"[background=\" + getColorName(_background) + \", foreground=\" + getColorName(_foreground) + \"]\";\n\t\t}\n\n\t\treturn \"[modi=\" + getModusName(_blackWhiteAttribute) + \"]\";\n\t}\n",
    "121739": "\tprivate String getColorName(short index) {\n\t\tswitch (index) {\n\t\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\t\treturn \"BLACK\";\n\t\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\t\treturn \"WHITE\";\n\t\t\t\t\t\tcase GREEN:\n\t\t\t\t\t\t\treturn \"GREEN\";\n\t\t\t\t\t\tcase YELLOW:\n\t\t\t\t\t\t\treturn \"YELLOW\";\n\t\t\t\t\t\tcase MAGENTA:\n\t\t\t\t\t\t\treturn \"MAGENTA\";\n\t\t\t\t\t\tcase CYAN:\n\t\t\t\t\t\t\treturn \"CYAN\";\n\t\t\t\t\t\tcase BLUE:\n\t\t\t\t\t\t\treturn \"BLUE\";\n\t\t\t\t\t\tcase RED:\n\t\t\t\t\t\t\treturn \"RED\";\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn \"UNKNOWN COLOR\";\n\t\t}\n\t}\n",
    "121743": "\tpublic FileFilter generateFileFilter(String filterString) {\n\t\treturn new DefaultFileFilter(filterString);\n\t}\n",
    "121745": "\tprivate String getModusName(short index) {\n\t\tswitch (index) {\n\t\t\t\t\t\tcase NORMAL:\n\t\t\t\t\t\t\treturn \"NORMAL\";\n\t\t\t\t\t\tcase REVERSE:\n\t\t\t\t\t\t\treturn \"REVERSE\";\n\t\t\t\t\t\tcase BOLD:\n\t\t\t\t\t\t\treturn \"BOLD\";\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn \"UNKNOWN MODUS\";\n\t\t}\n\t}\n",
    "121751": "\tprivate void verifyAttribute(short attribute) {\n\t\tif ((attribute != NORMAL) && (attribute != REVERSE) && (attribute != BOLD)) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown color attribute:\" + attribute);\n\t\t}\n\t}\n",
    "121756": "\tprivate void verifyColor(short color) {\n\t\tif ((color != BLACK) && (color != RED) && (color != GREEN) && (color != YELLOW) && (color != BLUE) && (color != MAGENTA) && (color != CYAN)\n\t\t\t\t && (color != WHITE)) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown color:\" + color);\n\t\t}\n\t}\n",
    "121787": "\tpublic void setBorderColors(CharColor aColors) {\n\t\t_theme.setColor(Theme.COLOR_WINDOW_BORDER, aColors);\n\t\trepaint();\n\t}\n",
    "121793": "\tpublic CharColor getBorderColors() {\n\t\treturn _theme.getColor(Theme.COLOR_WINDOW_BORDER);\n\t}\n",
    "121806": "\tpublic void setClosingChar(InputChar character) {\n\t\t_closingChar = character;\n\t}\n",
    "121812": "\tpublic InputChar getClosingChar() {\n\t\treturn _closingChar;\n\t}\n",
    "121814": "\tpublic CharColor getDefaultBorderColors() {\n\t\treturn getTheme().getColor(Theme.COLOR_WINDOW_BORDER);\n\t}\n",
    "121817": "\tpublic CharColor getDefaultTitleColors() {\n\t\treturn getTheme().getColor(Theme.COLOR_WINDOW_TITLE);\n\t}\n",
    "121830": "\tpublic void setRootPanel(Panel root) {\n\t\t_root = root;\n\t\t_root.setWindow(this);\n\t\trepaint();\n\t}\n",
    "121831": "\tpublic void setSeparatorString(String value) {\n\t\t_separatorString = value;\n\t}\n",
    "121832": "\tpublic String getSeparatorString() {\n\t\treturn _separatorString;\n\t}\n",
    "121833": "\tpublic void addSeparator(int index) {\n\t\tadd(index, SEPARATOR);\n\t}\n",
    "121834": "\tpublic void addSeparator() {\n\t\taddSeparator(getItemsCount());\n\t}\n",
    "121836": "\tprotected String getItemRepresentation(String item) {\n\t\tif (item == SEPARATOR) {\n\t\t\treturn getSeparatorString();\n\t\t}\n\n\t\treturn item;\n\t}\n",
    "121838": "\tprotected Rectangle getPreferredSize() {\n\t\treturn new Rectangle(getMaxItemLength() + 2, getItemsCount() + 2);\n\t}\n",
    "121839": "\tpublic Panel getRootPanel() {\n\t\t//Ein kommentar\n\t\treturn _root;\n\t}\n",
    "121840": "\tprotected boolean isSelectable(int index) {\n\t\treturn (!(getItem(index) == SEPARATOR));\n\t}\n",
    "121841": "\tprotected boolean handleInput(InputChar ch) {\n\t\tif (!ch.equals(getChangeStatusChar())) {\n\t\t\treturn super.handleInput(ch);\n\t\t}\n\n\t\treturn false;\n\t}\n",
    "121843": "\tprivate int getMaxItemLength() {\n\t\tint result = 0;\n\n\t\tfor (int i = 0; i < getItemsCount(); i++) {\n\t\t\tint length = getItemRepresentation((getItem(i))).length();\n\t\t\tresult = (length > result) ? length : result;\n\t\t}\n\n\t\treturn result;\n\t}\n",
    "121847": "\tpublic void setShadow(boolean value) {\n\t\t_hasShadow = value;\n\t\trepaint();\n\t}\n",
    "121852": "\tpublic boolean hasShadow() {\n\t\treturn _hasShadow;\n\t}\n",
    "121858": "\tpublic void setTitleColors(CharColor aColors) {\n\t\t_theme.setColor(Theme.COLOR_WINDOW_TITLE, aColors);\n\t\trepaint();\n\t}\n",
    "121863": "\tpublic CharColor getTitleColors() {\n\t\treturn _theme.getColor(Theme.COLOR_WINDOW_TITLE);\n\t}\n",
    "121868": "\tpublic void setVisible(boolean aVisible) {\n\t\tif (aVisible != isVisible()) {\n\t\t\tif (aVisible) {\n\t\t\t\tshow();\n\t\t\t} else {\n\t\t\t\thide();\n\t\t\t}\n\t\t}\n\t}\n",
    "121875": "\tpublic boolean isVisible() {\n\t\treturn _visible;\n\t}\n",
    "121880": "\tpublic void addListener(WindowListener listener) {\n\t\t_listenerManager.addListener(listener);\n\t}\n",
    "121887": "\tpublic void close() {\n\t\thide();\n\t\t_closed = true;\n\t\tWindowManager.removeWindow(this);\n\t}\n",
    "121893": "\tpublic void hide() {\n\t\t_visible = false;\n\t\tWindowManager.doWindowVisibilityChange(this);\n\t}\n",
    "121895": "\tpublic CharColor getBorderColors() {\n\t\treturn _colors;\n\t}\n",
    "121896": "\tpublic void setBorderColors(CharColor colors) {\n\t\t_colors = colors;\n\t}\n",
    "121898": "\tprotected CharColor getDefaultBorderColors() {\n\t\treturn __defaultBorderColors;\n\t}\n",
    "121899": "\tprotected Rectangle getClientArea() {\n\t\tRectangle rect = (Rectangle) getSize().clone();\n\t\trect.setLocation(1, 1);\n\t\trect.setWidth(rect.getWidth() - 2);\n\t\trect.setHeight(rect.getHeight() - 2);\n\n\t\treturn rect;\n\t}\n",
    "121900": "\tpublic void moveToTheTop() {\n\t\tWindowManager.moveToTop(this);\n\t}\n",
    "121903": "\tpublic void pack() {\n\t\tcutIfNeeded();\n\t\tconfigureRootPanel();\n\t\t_root.pack();\n\t\tloadFocusableChilds();\n\t\tloadShortcuts();\n\t}\n",
    "121908": "\tpublic void removeListener(WindowListener listener) {\n\t\t_listenerManager.removeListener(listener);\n\t}\n",
    "121911": "\tpublic void show() {\n\t\tif (!isVisible()) {\n\t\t\tWindowManager.createWindow(this);\n\t\t\tpack();\n\t\t\t_visible = true;\n\t\t\tWindowManager.doWindowVisibilityChange(this);\n\t\t}\n\t}\n",
    "121919": "\tprotected Rectangle getRectangle() {\n\t\treturn _rect;\n\t}\n",
    "121922": "\tprotected Rectangle getClipRectangle() {\n\t\tif (hasShadow()) {\n\t\t\treturn new Rectangle(_rect.getX(), _rect.getY(), _rect.getWidth() + 1, _rect.getHeight() + 1);\n\t\t}\n\n\t\treturn _rect;\n\t}\n",
    "121925": "\tprotected void activate() {\n\t\t_listenerManager.handleEvent(new WindowEvent(this, WindowEvent.ACTIVATED));\n\t}\n",
    "121928": "\tprotected void changeFocus(int aWidgetIndex) {\n\t\tif (aWidgetIndex != _currentIndex) {\n\t\t\tif (isFocusableIndex(_currentIndex)) {\n\t\t\t\t((Widget) _focusableChildren.get(_currentIndex)).setFocus(false);\n\t\t\t}\n\n\t\t\t_currentIndex = aWidgetIndex;\n\n\t\t\tif (isFocusableIndex(aWidgetIndex)) {\n\t\t\t\t((Widget) _focusableChildren.get(aWidgetIndex)).setFocus(true);\n\t\t\t}\n\t\t}\n\t}\n",
    "121931": "\tprotected void changeFocus(Widget aWidget) {\n\t\tchangeFocus(_focusableChildren.indexOf(aWidget));\n\t}\n",
    "121935": "\tprotected void changeFocus() {\n\t\t//changeFocus(Math.min(Math.max(0, _currentIndex + 1), _focusableChildren.size() - 1));\n\t\tif (_currentIndex >= _focusableChildren.size() - 1 || _currentIndex < -1) {\n\t\t\tchangeFocus(0);\n\t\t} else {\n\t\t\tchangeFocus(_currentIndex + 1);\n\t\t}\n\t}\n",
    "121943": "\tprotected void closed() {\n\t\t_closed = true;\n\t\t_listenerManager.handleEvent(new WindowEvent(this, WindowEvent.CLOSED));\n\t}\n",
    "121948": "\tprotected void deactivate() {\n\t\t_listenerManager.handleEvent(new WindowEvent(this, WindowEvent.DEACTIVATED));\n\t}\n",
    "121967": "\tprotected void paint() {\n\t\tdrawThingsIfNeeded();\n\t\t_root.paint();\n\t}\n",
    "121986": "\tprotected void resize(int width, int height) {\n\t\t_rect.setWidth(width);\n\t\t_rect.setHeight(height);\n\t}\n",
    "121994": "\tprivate Widget getCurrentWidget() {\n\t\tif (isFocusableIndex(_currentIndex)) {\n\t\t\treturn ((Widget) _focusableChildren.elementAt(_currentIndex));\n\t\t}\n\n\t\treturn null;\n\t}\n",
    "121999": "\tprivate InputChar getDefaultClosingChar() {\n\t\treturn __defaultClosingChar;\n\t}\n",
    "122003": "\tprivate InputChar getDefaultFocusChangeChar() {\n\t\treturn __defaultFocusChangeChar;\n\t}\n",
    "122009": "\tprivate boolean isFocusableIndex(int aIdx) {\n\t\treturn (aIdx >= 0) && (aIdx < _focusableChildren.size());\n\t}\n",
    "122010": "\tpublic String getText() {\n\t\treturn _label;\n\t}\n",
    "122011": "\tpublic void setText(String aText) {\n\t\t_label = aText;\n\t\tif (_label == null) {\n\t\t\t_label = \"\";\n\t\t}\n\t}\n",
    "122012": "\tprotected Rectangle getPreferredSize() {\n\t\tString[] mLines = TextUtils.wrapLines(_label, Integer.MAX_VALUE);\n\n\t\tint mWide = 0;\n\t\tfor (int mIdx = 0; mIdx < mLines.length; mIdx++) {\n\t\t\tmWide = Math.max(mWide, mLines[mIdx].length());\n\t\t}\n\n\t\treturn new Rectangle(mWide, mLines.length);\n\t}\n",
    "122013": "\tprotected void doPaint() {\n\t\tToolkit.printString(_label, getRectangle(), getColors());\n\t}\n",
    "122015": "    public void setLabel(String aLabel) {\n        _label = aLabel;\n    }\n",
    "122018": "\tprivate boolean isShortCut(InputChar inp) {\n\t\treturn (_shortCutsList.indexOf(inp) != -1);\n\t}\n",
    "122023": "    public void setShortCutColors(CharColor aColor) {\n        setColors(Theme.COLOR_WIDGET_SHORTCUT, aColor);\n    }\n",
    "122024": "    public void addListener(ActionListener listener) {\n        _listenerManager.addListener(listener);\n    }\n",
    "122026": "\tprivate Widget getWidgetByShortCut(InputChar inp) {\n\t\treturn (Widget) _shortCutsTable.get(inp);\n\t}\n",
    "122027": "    public void removeListener(ActionListener listener) {\n        _listenerManager.removeListener(listener);\n    }\n",
    "122028": "    public void setShortCut(char c) {\n        _shortCut = new InputChar(c);\n    }\n",
    "122029": "    protected Rectangle getPreferredSize() {\n        return new Rectangle(_label.length() + 4, 1);\n    }\n",
    "122032": "    protected Vector getShortCutsList() {\n        if (getShortCut() == null) {\n            return null;\n        }\n        Vector result = new Vector();\n        result.add(getShortCut());\n        return result;\n    }\n",
    "122033": "\tprivate void configureRootPanel() {\n\t\tif (_root == null) {\n\t\t\t_root = new Panel();\n\t\t}\n\n\t\tint x = _rect.getX();\n\t\tint y = _rect.getY();\n\t\tint width = _rect.getWidth();\n\t\tint height = _rect.getHeight();\n\n\t\tif (_border) {\n\t\t\tx++;\n\t\t\ty++;\n\t\t\twidth -= 2;\n\t\t\theight -= 2;\n\t\t}\n\n\t\t_root.setSize(new Rectangle(width, height));\n\t\t_root.setX(x);\n\t\t_root.setY(y);\n\t}\n",
    "122034": "    protected boolean isFocusable() {\n        return true;\n    }\n",
    "122035": "    protected boolean handleInput(InputChar ch) {\n        if ((ch.equals(__actionChar)) || ((getShortCut() != null) && (getShortCut().equals(ch)))) {\n            doAction();\n            return true;\n        }\n\n        return false;\n    }\n",
    "122036": "    protected void focus() {\n        doPaint();\n    }\n",
    "122038": "    protected void unfocus() {\n        doPaint();\n    }\n",
    "122039": "    private InputChar getShortCut() {\n        return _shortCut;\n    }\n",
    "122041": "    private void drawShortCutIfNeeded() {\n        InputChar shortCut = getShortCut();\n        if (shortCut != null) {\n            String c = shortCut.toString();\n            if (_label != null) {\n                int index = _label.toLowerCase().indexOf(c.toLowerCase());\n                if (index != - 1) {\n                    Toolkit.printString(_label.substring(index, index + 1), getAbsoluteX() + index + 2, getAbsoluteY(), getShortCutColors());\n\n                }\n            }\n        }\n    }\n",
    "122042": "    private void doAction() {\n        _listenerManager.handleEvent(new ActionEvent(this));\n    }\n",
    "122048": "\tprivate void drawThingsIfNeeded() {\n\t\tif (_border) {\n\t\t\tToolkit.drawBorder(_rect, getBorderColors());\n\t\t}\n\n\t\tpaintTitle();\n\t}\n",
    "122057": "\tprivate void loadFocusableChilds() {\n\t\t_focusableChildren = _root.getListOfFocusables();\n\t\tif (!isFocusableIndex(_currentIndex)) {\n\t\t\tchangeFocus();\n\t\t}\n\t}\n",
    "122063": "\tprivate void loadShortcuts() {\n\t\t_shortCutsList.clear();\n\t\t_shortCutsTable.clear();\n\n\t\tVector list = _root.getListOfWidgetsWithShortCuts();\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tWidget widget = (Widget) list.elementAt(i);\n\t\t\tVector shortCuts = widget.getShortCutsList();\n\t\t\t_shortCutsList.addAll(shortCuts);\n\n\t\t\tfor (int j = 0; j < shortCuts.size(); j++) {\n\t\t\t\t_shortCutsTable.put(shortCuts.elementAt(j), widget);\n\t\t\t}\n\t\t}\n\t}\n",
    "122067": "\tprivate void paintTitle() {\n\t\tif (_title != null) {\n\t\t\tToolkit.printString(_title, _rect.getX() + ((_rect.getWidth() - _title.length()) / 2), _rect.getY(), getTitleColors());\n\t\t}\n\t}\n",
    "122076": "\tpublic void setTitle(String aTitle) {\n\t\t_title = aTitle;\n\t\trepaint();\n\t}\n",
    "122080": "\tpublic int compare(Object obj1, Object obj2) {\n\t\tif (obj1 instanceof Widget && obj2 instanceof Widget) {\n\t\t\tWidget widget1 = (Widget) obj1;\n\t\t\tWidget widget2 = (Widget) obj2;\n\n\t\t\tif (isBelow(widget1, widget2)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (isAbove(widget1, widget2) || isLeft(widget1, widget2)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (isRight(widget1, widget2)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn obj2.hashCode() - obj1.hashCode();\n\t}\n",
    "122096": "   public int getPageOffset(int index) {\n\t   return index-getPageStartIndex(getPageNumber(index));\n   }\n",
    "122256": "    public void ejbCreate() {\n        objectkeyHome = lookupObjectkeyBean();\n    }\n",
    "122309": "    public void ejbCreate() {\n        objectKeyFacade = lookupObjectkeyFacadeBean();\n        projectHome = lookupProjectBean();\n        taskHome = lookupTaskBean();\n        usercommentsHome = lookupUsercommentsBean();\n    }\n",
    "122333": "    public void ejbCreate() {\n        objectKeyFacade = lookupObjectkeyFacadeBean();\n        accountHome = lookupAccountBean();\n    }\n",
    "122380": "    public void switchState() {\n        if (state == CCW) {\n            state = CW;\n        } else {\n            state = CCW;\n        }\n    }\n",
    "122407": "    public double getOccupancy(String state) {\n        double ligand = getLigandConcentration();\n        return ligand / (getDissociationConstant(state) + ligand);\n    }\n",
    "122426": "    public Concentration getConcentration(double volume) {\n        return new Concentration(this.getMolecularType(),\n            level / (volume * Molecule.AVOGADRO));\n    }\n",
    "122505": "    public void setRngSeed(long seed) {\n    }\n",
    "122532": "    private void applyGramSchmidtIfNecessary() {\n        rotationsCount++;\n\n        if (!this.isOrthogonal()) {\n            // TODO: generate an error (RotationMatrixNotOrthogonalError). This should be done in RotationMatrix.\n            System.out.println(\"WARNING: Orientation not orthogonal after \" +\n                rotationsCount + \" rotations. \" +\n                \"Consider decreasing the rotationsCountThreshold. (See tests in OrientationTest.java)\");\n        }\n\n        if (rotationsCount >= rotationsCountThreshold) {\n            this.gramSchmidt();\n            rotationsCount = 0;\n        }\n    }\n",
    "122539": "\tpublic void updateReceptorsDynamicValues() {\n\t\tCollection c = cell.getReceptors().getDissociationConstants().keySet();\n\t\tIterator i = c.iterator();\n\t\twhile (i.hasNext()) {\n\t\t\tString s = (String) i.next();\n\t\t\tthis.setDynamicValue(s, cell.getReceptors().getOccupancy(s));\n\t\t}\n\t}\n",
    "122760": "    public void switchState() {\n        if (state == BUNDLED) {\n            state = APART;\n        } else {\n            state = BUNDLED;\n        }\n    }\n",
    "122776": "  public void setModel(SimModel model) {\n    this.model = model;\n    if (model != null) {\n      model.setup();\n    }\n  }\n",
    "122783": "  public SimModel getModel() {\n    return this.model;\n  }\n",
    "122788": "  public int getCellWidth() {\n    return DisplayConstants.CELL_WIDTH;\n  }\n",
    "122793": "  public void setCellWidth(int cellSize) {\n    if (runThread == null)\n      DisplayConstants.CELL_WIDTH = cellSize;\n  }\n",
    "122797": "  public int getCellHeight() {\n    return DisplayConstants.CELL_HEIGHT;\n  }\n",
    "122801": "  public void setCellHeight(int cellSize) {\n    if (runThread == null)\n      DisplayConstants.CELL_HEIGHT = cellSize;\n  }\n",
    "122806": "  public int getCellDepth() {\n    return DisplayConstants.CELL_DEPTH;\n  }\n",
    "122811": "  public void setCellDepth(int cellSize) {\n    if (runThread == null)\n      DisplayConstants.CELL_DEPTH = cellSize;\n  }\n",
    "122813": "    @Test public void testPCall() {\n        PCall call = new PCall() {\n            public void runCode() {\n                setName(CompSettings.getDateString());\n            }\n\n            public Engine engine() {\n                return null; // EngineTypes.GRTE.getEngine();\n            }\n\n            public void finalCode() {\n                log.info(this + \" OK\");\n            }\n        };\n        call.execute();\n        call.execute();\n        call.execute();\n        QueuedExecutor exec = (QueuedExecutor) call.getExecutor();\n        try {\n            Thread.sleep(1000);\n            exec.shutdownNow();\n            Thread.sleep(600);\n        } catch (InterruptedException e) {\n            log.error(\"\", e);\n        }\n        // EngineTypes.GRTE.getEngine().shutdown();\n    }\n",
    "122818": "  public void setSchedule(Schedule schedule) {\n    this.schedule = schedule;\n    setupSchedule();\n  }\n",
    "122822": "  public Schedule getSchedule() {\n    return schedule;\n  }\n",
    "122824": "  public long getCurrentTime() {\n\n    return (long) time; // + timeMod);\n  }\n",
    "122828": "  public double getCurrentTimeDouble() {\n\n    return time; // + timeMod;\n  }\n",
    "122830": "    @Test public void testCalc() {\n\n        CalcEngine parser = new CalcEngine();\n        parser.putVariable(\"s\", new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });\n        double[] res;\n        try {\n\n            parser.parseString(\"d=trend(100);\");\n            res = parser.getVariable(\"D\");\n            Assert.assertEquals(res[99], 100, 0);\n\n            parser.parseString(\"d = s+2\");\n            res = parser.getVariable(\"D\");\n            Assert.assertEquals(res[3], 6, 0);\n\n            parser.parseString(\"d = s|1;A= log  (d )\");\n            res = parser.getVariable(\"a\");\n            Assert.assertEquals(res[9], 0, 0);\n\n        } catch (ParseException ex) {\n            throw new RuntimeException(ex.toString());\n        }\n\n    }\n",
    "122831": "  public void setRandomSeed(long seed) {\n    model.setRngSeed(seed);\n  }\n",
    "122833": "    @Test public void testTypes() {\n        Assert.assertEquals(TSTypes.valueOf(\"DETERMINISTIC\"), TSTypes.DETERMINISTIC);\n        Assert.assertEquals(TSTypes.valueOf(\"dETERMINISTIc\"), TSTypes.DETERMINISTIC);\n        Assert.assertEquals(TSTypes.valueOf(\"ENDOGENOUS\"), TSTypes.ENDOGENOUS);\n        Assert.assertEquals(TSTypes.valueOf(\"eNDOGEnOUS\"), TSTypes.ENDOGENOUS);\n        Assert.assertEquals(TSTypes.valueOf(\"EXOGENOUS\"), TSTypes.EXOGENOUS);\n        Assert.assertEquals(TSTypes.valueOf(\"EXOgENOUs\"), TSTypes.EXOGENOUS);\n    }\n",
    "122835": "  public long getRandomSeed() {\n    return model.getRngSeed();\n  }\n",
    "122841": "  public void startSim() {\n    // necessary to make pauseAt persist over the course of\n    // several runs.\n    setPauseAt(pauseAt);\n\n    fireSimEvent(new SimEvent(this, SimEvent.START_EVENT));\n\n    if (runThread == null) {\n      if (executeBegin) beginModel();\n      schedule = model.getSchedule();\n      setupSchedule();\n    }\n    if (schedule == null) {\n      SimUtilities.showMessage(\"No schedule to run\");\n      System.exit(0);\n    } else if (!go) {\n      go = true;\n      pauseSim = false;\n      doStep = false;\n      if (runThread == null) {\n        runThread = new Thread(simRun);\n        runThread.start();\n      }\n    } else if (go) {\n      pauseSim = false;\n      doStep = false;\n      notifyMonitor();\n    }\n  }\n",
    "122844": "  protected void notifyMonitor() {\n    synchronized (monitor) {\n      monitor.notify();\n    }\n  }\n",
    "122853": "  public Hashtable getModelParameters() {\n    Hashtable props = new Hashtable(23);\n    if (model != null) {\n      model.clearPropertyListeners();\n      try {\n        props = ParameterUtility.getModelProperties(model);\n      } catch (Exception ex) {\n        SimUtilities.showError(\"Error retrieving model properties\", ex);\n        System.exit(0);\n      }\n    }\n\n    return props;\n  }\n",
    "122859": "  public void pauseSim() {\n    pauseSim = true;\n  }\n",
    "122863": "  public void stopSim() {\n    go = false;\n    doStep = false;\n    pauseSim = false;\n    notifyMonitor();\n  }\n",
    "122864": "    @Test public void testTSEquals() {\n\n        double[] newObs = new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        TSDate date = new TSDate(1960.1, 4);\n        TS ts1 = new TS(newObs, \"test_series\", date);\n        TS ts2 = new TS(newObs, \"test_series\", date);\n\n        Assert.assertEquals(ts1, ts2);\n        Assert.assertEquals(ts2, ts1);\n\n        Assert.assertEquals(ts1.hashCode(), ts2.hashCode());\n\n    }\n",
    "122865": "  public boolean isBatch() {\n    return false;\n  }\n",
    "122869": "  public void addSimEventListener(SimEventListener l) {\n    listenerList.add(l);\n  }\n",
    "122870": "  public void removeSimEventListener(SimEventListener l) {\n    listenerList.remove(l);\n  }\n",
    "122874": "  public void fireSimEvent(SimEvent evt) {\n    ArrayList copy;\n    synchronized(listenerList) {\n      copy = (ArrayList)listenerList.clone();\n    }\n\n    for (int i = 0, n = copy.size(); i < n; i++) {\n      SimEventListener l = (SimEventListener)copy.get(i);\n      l.simEventPerformed(evt);\n    }\n  }\n",
    "122876": "  public void putPersistentObj(Object key, Object val) {\n    persistentObj.put(key, val);\n  }\n",
    "122880": "  public Object getPersistentObj(Object key) {\n    return persistentObj.get(key);\n  }\n",
    "122943": "    @Test public void testJHelpContextMgr() {\n        File file = new File(\"testdata/\" + JHelpContextMgr.helpIDFile);\n        JHelpContextMgr newMgr = null;\n\n        ObjectReader constructor = new ObjectReader();\n\n        try {\n            newMgr = (JHelpContextMgr) constructor.read(new FileInputStream(\n                    file));\n\n        } catch (Throwable t) {\n            log.error(\"Error in XML deserialization\", t);\n        }\n        Assert.assertEquals(newMgr.getID(\"com.jstatcom.io.TSImportPanel\"),\n                \"jstatcom.impdata\");\n        JHelpContextMgr.register(new JPanel());\n    }\n",
    "122991": "    private void decreaseCapacity() {\n        if (_size >= _capacity - C0)\n            throw new IllegalStateException();\n        final int c = _capacity;\n        _capacity -= C0;\n        if (c < C1) {\n            _elems1[(c >> R1)] = null;\n            _elems2 = null;\n            _elems3 = null;\n        } else if (c < C2) {\n            _elems2[(c >> R2)][(c >> R1) & M1] = null;\n            _elems3 = null;\n        } else {\n            _elems3[(c >> R3)][(c >> R2) & M2][(c >> R1) & M1] = null;\n        }\n    }\n",
    "122997": "    public int hashCode() {\n        final FastComparator comp = this.getValueComparator();\n        int h = 1;\n        for (Node n = _head, end = _tail; (n = n._next) != end;) {\n            h = 31 * h + comp.hashCodeOf(n._value);\n        }\n        return h;\n    }\n",
    "123095": "    public void lock() {\n        Thread caller = Thread.currentThread();\n        synchronized (this) {\n            if (caller == _owner) {\n                _count++;\n            } else {\n                try {\n                    while (_owner != null) {\n                        this.wait();\n                    }\n                    _owner = caller;\n                    _count = 1;\n                } catch (InterruptedException exception) {\n                    return;\n                }\n            }\n        }\n    }\n",
    "123097": "    public boolean tryLock() {\n        synchronized (this) {\n            if (_owner == null) {\n                lock();\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n",
    "123098": "    public void unlock() {\n        synchronized (this) {\n            if (Thread.currentThread() == _owner) {\n                if (--_count == 0) {\n                    _owner = null;\n                    this.notify();\n                }\n            } else {\n                throw new IllegalMonitorStateException(\n                        \"Current thread does not hold this lock\");\n            }\n        }\n    }\n",
    "123099": "    public Thread getOwner() {\n        synchronized (this) {\n            return _owner;\n        }\n    }\n",
    "123114": "    public FastComparator getValueComparator() {\n        return _valueComp;\n    }\n",
    "123115": "    public boolean add( E value) {\n        throw new UnsupportedOperationException();\n    }\n",
    "123117": "    public boolean remove(Object value) {\n        final FastComparator valueComp = this.getValueComparator();\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            if (valueComp.areEqual(value, valueOf(r))) {\n                delete(r);\n                return true;\n            }\n        }\n        return false;\n    }\n",
    "123118": "    public void clear() {\n        // Removes last record until empty.\n        for (Record head = head(), r = tail().getPrevious(); r != head; r = r\n                .getPrevious()) {\n            delete(r);\n        }\n    }\n",
    "123120": "    public boolean isShared() {\n        return _isShared;\n    }\n",
    "123121": "    public boolean contains(Object value) {\n        final FastComparator valueComp = this.getValueComparator();\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            if (valueComp.areEqual(value, valueOf(r)))\n                return true;\n        }\n        return false;\n    }\n",
    "123123": "    public boolean addAll(Collection <? extends E> c) {\n        if (c instanceof FastCollection)\n            return addAll((FastCollection) c);\n        boolean modified = false;\n        Iterator <? extends E> itr = c.iterator();\n        int pos = c.size();\n        while (--pos >= 0) {\n            if (add(itr.next())) {\n                modified = true;\n            }\n        }\n        return modified;\n    }\n",
    "123125": "    public FastComparator getKeyComparator() {\n        return _keyComparator;\n    }\n",
    "123126": "    public boolean containsAll(Collection <?> c) {\n        if (c instanceof FastCollection)\n            return containsAll((FastCollection) c);\n        Iterator <?> itr = c.iterator();\n        int pos = c.size();\n        while (--pos >= 0) {\n            if (!contains(itr.next())) {\n                return false;\n            }\n        }\n        return true;\n    }\n",
    "123129": "    public FastComparator getValueComparator() {\n        return _values.getValueComparator();\n    }\n",
    "123132": "    public boolean removeAll(Collection <?> c) {\n        boolean modified = false;\n        // Iterates from the tail and removes the record if present in c. \n        for (Record head = head(), r = tail().getPrevious(), previous; r != head; r = previous) {\n            previous = r.getPrevious(); // Saves previous.\n            if (c.contains(valueOf(r))) {\n                delete(r);\n                modified = true;\n            }\n        }\n        return modified;\n    }\n",
    "123133": "    public boolean retainAll(Collection <?> c) {\n        boolean modified = false;\n        // Iterates from the tail and remove the record if not present in c. \n        for (Record head = head(), r = tail().getPrevious(), previous; r != head; r = previous) {\n            previous = r.getPrevious(); // Saves previous.\n            if (!c.contains(valueOf(r))) {\n                delete(r);\n                modified = true;\n            }\n        }\n        return modified;\n    }\n",
    "123134": "    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        } else if (obj instanceof Map) {\n            Map <?,?> that = (Map) obj;\n            if (this.size() == that.size()) {\n                final Set thatEntrySet = that.entrySet();\n                for (Entry e = _head, end = _tail; (e = e._next) != end;) {\n                    if (!thatEntrySet.contains(e)) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n",
    "123135": "    public Text toText() {\n        final Text sep = Text.valueOf(\", \");\n        Text text = Text.valueOf('[');\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            text = text.concat(Text.valueOf(valueOf(r)));\n            if (r.getNext() != end) {\n                text = text.concat(sep);\n            }\n        }\n        return text.concat(Text.valueOf(']'));\n    }\n",
    "123137": "    public boolean equals(Object obj) {\n        if (this instanceof List)\n            return equalsList(obj);\n        return obj == this\n                || (obj instanceof Collection\n                        && ((Collection) obj).size() == size() && containsAll((Collection) obj));\n    }\n",
    "123138": "    public int hashCode() {\n        int code = 0;\n        for (Entry e = _head, end = _tail; (e = e._next) != end;) {\n            code += e.hashCode();\n        }\n        return code;\n    }\n",
    "123141": "    public int hashCode() {\n        if (this instanceof List)\n            return hashCodeList();\n        final FastComparator valueComp = this.getValueComparator();\n        int hash = 0;\n        for (Record r = head(), end = tail(); (r = r.getNext()) != end;) {\n            hash += valueComp.hashCodeOf(valueOf(r));\n        }\n        return hash;\n    }\n",
    "123144": "    public Text toText() {\n        return _entrySet.toText();\n    }\n",
    "123199": "    public  V putDefault( K key,  V defaultValue) {\n        return ( V ) ((FastMap) _mapRef.getDefault()).put(key,\n                defaultValue);\n    }\n",
    "123200": "    public int size() {\n        return ((FastMap) _mapRef.get()).size();\n    }\n",
    "123202": "    public boolean isEmpty() {\n        return ((FastMap) _mapRef.get()).isEmpty();\n    }\n",
    "123203": "    public boolean containsKey(Object key) {\n        return ((FastMap) _mapRef.get()).containsKey(key);\n    }\n",
    "123204": "    public boolean containsValue(Object value) {\n        return ((FastMap) _mapRef.get()).containsValue(value);\n    }\n",
    "123205": "    public  V get(Object key) {\n        return ( V ) ((FastMap) _mapRef.get()).get(key);\n    }\n",
    "123206": "    public  V put( K key,  V value) {\n        return ( V ) localMap().put(key, value);\n    }\n",
    "123207": "    public void putAll(Map <? extends K, ? extends V> map) {\n        localMap().putAll(map);\n    }\n",
    "123209": "    public  V remove(Object key) {\n        return put(( K )key, null);\n    }\n",
    "123211": "    public void clear() {\n        FastMap localMap = localMap();\n        for (FastMap.Entry e = localMap.head(), end = localMap.tail(); (e = (FastMap.Entry) e.getNext()) != end;) {\n            e.setValue(null);\n        }\n    }\n",
    "123245": "\tpublic int read(InputStream in) throws IOException {\n\t\tByteBuffer buffer = getByteBuffer();\n\t\tif (buffer.hasArray()) {\n\t\t\tint offset = buffer.arrayOffset() + getByteBufferPosition();\n\t\t\treturn in.read(buffer.array(), offset, size());\n\t\t} else {\n\t\t\tsynchronized (buffer) {\n\t\t\t\tif (_bytes == null) {\n\t\t\t\t\t_bytes = new byte[size()];\n\t\t\t\t}\n\t\t\t\tint bytesRead = in.read(_bytes);\n\t\t\t\tbuffer.position(getByteBufferPosition());\n\t\t\t\tbuffer.put(_bytes);\n\t\t\t\treturn bytesRead;\n\t\t\t}\n\t\t}\n\t}\n",
    "123247": "\tpublic void write(OutputStream out) throws IOException {\n\t\tByteBuffer buffer = getByteBuffer();\n\t\tif (buffer.hasArray()) {\n\t\t\tint offset = buffer.arrayOffset() + getByteBufferPosition();\n\t\t\tout.write(buffer.array(), offset, size());\n\t\t} else {\n\t\t\tsynchronized (buffer) {\n\t\t\t\tif (_bytes == null) {\n\t\t\t\t\t_bytes = new byte[size()];\n\t\t\t\t}\n\t\t\t\tbuffer.position(getByteBufferPosition());\n\t\t\t\tbuffer.get(_bytes);\n\t\t\t\tout.write(_bytes);\n\t\t\t}\n\t\t}\n\t}\n",
    "123249": "\tpublic String toString() {\n\t\tfinal int size = size();\n\t\tStringBuffer sb = new StringBuffer(size * 3);\n\t\tfinal ByteBuffer buffer = getByteBuffer();\n\t\tfinal int start = getByteBufferPosition();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tint b = buffer.get(start + i) & 0xFF;\n\t\t\tsb.append(HEXA[b >> 4]);\n\t\t\tsb.append(HEXA[b & 0xF]);\n\t\t\tsb.append(((i & 0xF) == 0xF) ? '\\n' : ' ');\n\t\t}\n\t\treturn sb.toString();\n\t}\n",
    "123255": "\tpublic boolean isUnion() {\n\t\treturn false;\n\t}\n",
    "123260": "\tpublic ByteOrder byteOrder() {\n\t\treturn (_outer != null) ? _outer.byteOrder() : ByteOrder.BIG_ENDIAN;\n\t}\n",
    "123266": "    private void addEntry(int hash,  K key,  V value) {\n        // Updates size.\n        if ((_size++ >> R0) >= _entries.length) { // Check if entry table too small. \n            increaseEntryTable();\n        }\n\n        if (_tail._next == null) {\n            increaseCapacity();\n        }\n        final Entry newTail = _tail._next;\n        // Setups entry parameters.\n        _tail._key = key;\n        _tail._value = value;\n        _tail._keyHash = hash;\n        _tail._table = _entries;\n\n        // Connects to bucket.\n        final int index = (hash >> R0) & (_entries.length - 1);\n        Entry[] tmp = _entries[index];\n        if (tmp == NULL_BLOCK) {\n            newBlock(index);\n            tmp = _entries[index];\n        }\n        Entry beside = tmp[hash & M0];\n        _tail._beside = beside;\n        tmp[hash & M0] = _tail;\n\n        // Moves tail forward.\n        _tail = newTail;\n    }\n",
    "123268": "\tpublic boolean isPacked() {\n\t\treturn (_outer != null) ? _outer.isPacked() : false;\n\t}\n",
    "123298": "    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.writeInt(_size);\n        stream.writeInt(_entries.length);\n\n        stream.writeBoolean(_isShared);\n        stream.writeObject(_keyComparator);\n        stream.writeObject(_values.getValueComparator());\n\n        for (Entry e = _head, end = _tail; (e = e._next) != end;) {\n            stream.writeObject(e._key);\n            stream.writeObject(e._value);\n        }\n    }\n",
    "123301": "    @Test public void testJSCSArray2() {\n\n        JSCSArray sArray = new JSCSArray(\"test\");\n\n        String[][] test = new String[5][5];\n        test[2][3] = \"1.345e-20\";\n        test[1][1] = \"Double.NaN\";\n        test[2][4] = \"Double.POSITIVE_INFINITY\";\n        test[1][3] = \"-1233433\";\n\n        sArray = new JSCSArray(\"test\", test);\n        Assert.assertEquals(sArray.isEqual(sArray.copy()), true);\n        Assert.assertEquals(UStringArray.compareStringArrays(sArray.stringArray(),\n                test), true);\n\n    }\n",
    "123302": "        public boolean equals(Object that) {\n            if (that instanceof Map.Entry) {\n                Map.Entry entry = (Map.Entry) that;\n                return _key.equals(entry.getKey())\n                        && ((_value != null) ? _value.equals(entry.getValue())\n                                : (entry.getValue() == null));\n            } else {\n                return false;\n            }\n        }\n",
    "123305": "        public int hashCode() {\n            return _key.hashCode() ^ ((_value != null) ? _value.hashCode() : 0);\n        }\n",
    "123308": "    @Test public void testJSCSArray3() {\n\n        String[][] test = new String[5][5];\n        test[2][3] = \"1.345e-20\";\n        test[1][1] = \"Double.NaN\";\n        test[2][4] = \"Double.POSITIVE_INFINITY\";\n        test[1][3] = \"-1233433\";\n        JSCSArray sArray = new JSCSArray(\"test\", test);\n\n        Assert.assertEquals(sArray.stringAt(0, 0), null);\n        Assert.assertEquals(sArray.stringAt(2, 3), \"1.345e-20\");\n\n    }\n",
    "123355": "    public Utf8ByteBufferWriter setByteBuffer(ByteBuffer byteBuffer) {\n        if (_byteBuffer != null)\n            throw new IllegalStateException(\"Writer not closed or reset\");\n        _byteBuffer = byteBuffer;\n        return this;\n    }\n",
    "123356": "    public void write(char c) throws IOException {\n        if ((c < 0xd800) || (c > 0xdfff)) {\n            write((int) c);\n        } else if (c < 0xdc00) { // High surrogate.\n            _highSurrogate = c;\n        } else { // Low surrogate.\n            int code = ((_highSurrogate - 0xd800) << 10) + (c - 0xdc00)\n                    + 0x10000;\n            write(code);\n        }\n    }\n",
    "123357": "    public void write(int code) throws IOException {\n        if ((code & 0xffffff80) == 0) {\n            _byteBuffer.put((byte) code);\n        } else { // Writes more than one byte.\n            write2(code);\n        }\n    }\n",
    "123360": "    public void write(char cbuf[], int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = cbuf[i++];\n            if (c < 0x80) {\n                _byteBuffer.put((byte) c);\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123361": "    public void write(String str, int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = str.charAt(i++);\n            if (c < 0x80) {\n                _byteBuffer.put((byte) c);\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123362": "    public void write(CharSequence csq) throws IOException {\n        final int length = csq.length();\n        for (int i = 0; i < length;) {\n            char c = csq.charAt(i++);\n            if (c < 0x80) {\n                _byteBuffer.put((byte) c);\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123363": "    public void flush() throws IOException {\n        if (_byteBuffer == null) {\n            throw new IOException(\"Writer closed\");\n        }\n    }\n",
    "123367": "    public Utf8ByteBufferReader setByteBuffer(ByteBuffer byteBuffer) {\n        if (_byteBuffer != null)\n            throw new IllegalStateException(\"Reader not closed or reset\");\n        _byteBuffer = byteBuffer;\n        return this;\n    }\n",
    "123368": "    public boolean ready() throws IOException {\n        if (_byteBuffer != null) {\n            return _byteBuffer.hasRemaining();\n        } else {\n            throw new IOException(\"Reader closed\");\n        }\n    }\n",
    "123370": "    public int read() throws IOException {\n        if (_byteBuffer != null) {\n            if (_byteBuffer.hasRemaining()) {\n                byte b = _byteBuffer.get();\n                return (b >= 0) ? b : read2(b);\n            } else {\n                return -1;\n            }\n        } else {\n            throw new IOException(\"Reader closed\");\n        }\n    }\n",
    "123374": "    public void read(Appendable dest) throws IOException {\n        if (_byteBuffer == null)\n            throw new IOException(\"Reader closed\");\n        while (_byteBuffer.hasRemaining()) {\n            byte b = _byteBuffer.get();\n            if (b >= 0) {\n                dest.append((char) b); // Most common case.\n            } else {\n                int code = read2(b);\n                if (code < 0x10000) {\n                    dest.append((char) code);\n                } else if (code <= 0x10ffff) { // Surrogates.\n                    dest.append((char) (((code - 0x10000) >> 10) + 0xd800));\n                    dest.append((char) (((code - 0x10000) & 0x3ff) + 0xdc00));\n                } else {\n                    throw new CharConversionException(\"Cannot convert U+\"\n                            + Integer.toHexString(code)\n                            + \" to char (code greater than U+10FFFF)\");\n                }\n            }\n        }\n    }\n",
    "123377": "    public Utf8StreamWriter setOutputStream(OutputStream out) {\n        if (_outputStream != null)\n            throw new IllegalStateException(\"Writer not closed or reset\");\n        _outputStream = out;\n        return this;\n    }\n",
    "123380": "    public void write(int code) throws IOException {\n        if ((code & 0xffffff80) == 0) {\n            _bytes[_index] = (byte) code;\n            if (++_index >= _bytes.length) {\n                flushBuffer();\n            }\n        } else { // Writes more than one byte.\n            write2(code);\n        }\n    }\n",
    "123382": "    public void write(char cbuf[], int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = cbuf[i++];\n            if (c < 0x80) {\n                _bytes[_index] = (byte) c;\n                if (++_index >= _bytes.length) {\n                    flushBuffer();\n                }\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123383": "    public void write(String str, int off, int len) throws IOException {\n        final int off_plus_len = off + len;\n        for (int i = off; i < off_plus_len;) {\n            char c = str.charAt(i++);\n            if (c < 0x80) {\n                _bytes[_index] = (byte) c;\n                if (++_index >= _bytes.length) {\n                    flushBuffer();\n                }\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123384": "    public void write(CharSequence csq) throws IOException {\n        final int length = csq.length();\n        for (int i = 0; i < length;) {\n            char c = csq.charAt(i++);\n            if (c < 0x80) {\n                _bytes[_index] = (byte) c;\n                if (++_index >= _bytes.length) {\n                    flushBuffer();\n                }\n            } else {\n                write(c);\n            }\n        }\n    }\n",
    "123385": "    public void flush() throws IOException {\n        flushBuffer();\n        _outputStream.flush();\n    }\n",
    "123389": "    private void flushBuffer() throws IOException {\n        if (_outputStream == null)\n            throw new IOException(\"Stream closed\");\n        _outputStream.write(_bytes, 0, _index);\n        _index = 0;\n    }\n",
    "123391": "    public Utf8StreamReader setInputStream(InputStream inStream) {\n        if (_inputStream != null)\n            throw new IllegalStateException(\"Reader not closed or reset\");\n        _inputStream = inStream;\n        return this;\n    }\n",
    "123392": "    public boolean ready() throws IOException {\n        if (_inputStream == null)\n            throw new IOException(\"Stream closed\");\n        return ((_end - _start) > 0) || (_inputStream.available() != 0);\n    }\n",
    "123395": "    public int read() throws IOException {\n        byte b = _bytes[_start];\n        return ((b >= 0) && (_start++ < _end)) ? b : read2();\n    }\n",
    "123411": "    public void setMinimum( T value) {\n        synchronized (ID_TO_VALUE) {\n            if (value instanceof Comparable) {\n                Object prevValue = get();\n                if (((Comparable) value).compareTo(prevValue) > 0) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else if (value instanceof Integer) {\n                Object prevValue = get();\n                if (((Integer) value).intValue() > ((Integer) prevValue)\n                        .intValue()) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n",
    "123414": "    public void setMaximum( T value) {\n        synchronized (ID_TO_VALUE) {\n            if (value instanceof Comparable) {\n                Object prevValue = get();\n                if (((Comparable) value).compareTo(prevValue) < 0) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else if (value instanceof Integer) {\n                Object prevValue = get();\n                if (((Integer) value).intValue() < ((Integer) prevValue)\n                        .intValue()) {\n                    ID_TO_VALUE.put(_id, value);\n                }\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n",
    "123415": "    public String toString() {\n        return String.valueOf(this.get());\n    }\n",
    "123416": "    public boolean contains(char c) {\n        final int i = c >> 6;\n        return i < _mapping.length ? (_mapping[i] & (1L << (c & 63))) != 0\n                : false;\n    }\n",
    "123417": "    public CharSet plus(CharSet that) {\n        if (that._mapping.length > this._mapping.length)\n            return that.plus(this);\n        CharSet result = this.copy();\n        for (int i = that._mapping.length; --i >= 0;) {\n            result._mapping[i] |= that._mapping[i];\n        }\n        return result;\n    }\n",
    "123418": "    public CharSet minus(CharSet that) {\n        CharSet result = this.copy();\n        for (int i = MathLib.min(this._mapping.length, that._mapping.length); --i >= 0;) {\n            result._mapping[i] &= ~that._mapping[i];\n        }\n        return result;\n    }\n",
    "123420": "    public String toString() {\n        TextBuilder tb = TextBuilder.newInstance();\n        tb.append('{');\n        int length = _mapping.length << 6;\n        for (int i = 0; i < length; i++) {\n            if (this.contains((char) i)) {\n                if (tb.length() > 1) {\n                    tb.append(',');\n                    tb.append(' ');\n                }\n                tb.append('\\'');\n                tb.append((char) i);\n                tb.append('\\'');\n            }\n        }\n        tb.append('}');\n        return tb.toString();\n    }\n",
    "123421": "    private CharSet copy() {\n        CharSet charSet = new CharSet(new long[this._mapping.length]);\n        for (int i = _mapping.length; --i >= 0;) {\n            charSet._mapping[i] = _mapping[i];\n        }\n        return charSet;\n    }\n",
    "123443": "    public TextBuilder append(Text text) {\n        if (text == null)\n            return append(\"null\");\n        final int length = text.length();\n        for (int i = 0; i < length;) {\n            append(text.charAt(i++));\n        }\n        return this;\n    }\n",
    "123456": "    public Text toText() {\n        return Text.valueOf(getClass().getName()).concat(Text.valueOf('@'))\n                .concat(Text.valueOf(System.identityHashCode(this), 16));\n    }\n",
    "123460": "    protected void recycle() {\n        if (((_pool != null) && _pool.isLocal())) {\n            _pool.recycle(this);\n        }\n    }\n",
    "123479": "    public void clear() {\n        if (_inner != null)\n            _inner.clear();\n        _inner = null;\n    }\n",
    "123484": "    public void clear() {\n        super.clear();\n        for (int i = ObjectFactory.Count; i > 0;) {\n            ObjectPool pool = _pools[--i];\n            if (pool != ObjectPool.NULL) {\n                pool.clearAll();\n            }\n        }\n        _inUsePoolsLength = 0;\n    }\n",
    "123500": "    public  T object() {\n        final PoolContext poolContext = Context.poolContext(Thread\n                .currentThread());\n        return (poolContext == null) ? create() : ( T ) poolContext\n                .getLocalPool(_index).next();\n    }\n",
    "123503": "    protected void cleanup( T obj) {\n        throw new UnsupportedOperationException();\n    }\n",
    "123522": "    public void clear() {\n        if (_threads != null) {\n            for (int i=0; i < _threads.length; i++) {\n                _threads[i].terminate();\n            }\n            _threads = null;\n        }        \n    }\n",
    "123538": "    public Throwable getCause() {\n        return _cause;\n    }\n",
    "123540": "    public void clear() {\n        super.clear();\n        _references.clear();\n    }\n",
    "123549": "    public Text toText() {\n        return Text.valueOf(this.get());\n    }\n",
    "123551": "    public String toString() {\n        return \"Concurrent-\" + super.toString();\n    }\n",
    "123557": "    public void terminate() {\n        synchronized (this) {\n            _terminate = true;\n            this.notify();\n        }\n    }\n",
    "123558": "    public void set( T value) {\n        LocalContext ctx = Context.current().inheritedLocalContext;\n        if (ctx != null) {\n            FastMap references = ctx._references;\n            references.put(this, value);\n            _hasBeenLocallyOverriden = true;\n            return;\n        }\n        // No local context, sets default value.\n        _defaultValue = value;\n    }\n",
    "123559": "    public  T getDefault() {\n        return _defaultValue;\n    }\n",
    "123561": "    public  T getLocal() {\n        LocalContext ctx = Context.current().inheritedLocalContext;\n        return (ctx != null) ? ( T ) ctx._references.get(this)\n                : _defaultValue;\n    }\n",
    "123562": "    public void setDefault( T defaultValue) {\n        _defaultValue = defaultValue;\n    }\n",
    "123563": "    public void setContentHandler(ContentHandler handler) {\n        if (handler != null) {\n            _contentHandler = handler;\n        } else {\n            throw new NullPointerException();\n        }\n    }\n",
    "123565": "\tpublic WriterHandler setWriter(Writer writer) {\n\t\t_writer = writer;\n\t\treturn this;\n\t}\n",
    "123566": "    public ContentHandler getContentHandler() {\n        return (_contentHandler == DEFAULT_HANDLER) ? null : _contentHandler;\n    }\n",
    "123567": "\tpublic void setIndent(CharSequence indent) {\n\t\t_indent = indent;\n\t}\n",
    "123569": "\tpublic void setProlog(CharSequence prolog) {\n\t\t_prolog = prolog;\n\t}\n",
    "123571": "    public void setErrorHandler(ErrorHandler handler) {\n        if (handler != null) {\n            _errorHandler = handler;\n        } else {\n            throw new NullPointerException();\n        }\n    }\n",
    "123574": "    public ErrorHandler getErrorHandler() {\n        return (_errorHandler == DEFAULT_HANDLER) ? null : _errorHandler;\n    }\n",
    "123578": "    public void parse(InputStream in) throws IOException, SAXException {\n        _pullParser.setInput(in);\n        parseAll();\n    }\n",
    "123583": "    public void parse(ByteBuffer byteBuffer) throws IOException, SAXException {\n        _pullParser.setInput(byteBuffer);\n        parseAll();\n    }\n",
    "123586": "    public void parse(Reader reader) throws IOException, SAXException {\n        _pullParser.setInput(reader);\n        parseAll();\n    }\n",
    "123605": "    public void warning (SAXParseException e) throws SAXException {}\n",
    "123606": "    public void setEntityResolver(EntityResolver resolver) {\n        _entityResolver = resolver;\n    }\n",
    "123608": "    public void error (SAXParseException e) throws SAXException {}\n",
    "123609": "    public void fatalError (SAXParseException e) throws SAXException {\n\tthrow e;\n    }\n",
    "123613": "    public EntityResolver getEntityResolver() {\n        return _entityResolver;\n    }\n",
    "123620": "    public void setDTDHandler(DTDHandler handler) {\n        _dtdHandler = handler;\n    }\n",
    "123625": "    public DTDHandler getDTDHandler() {\n        return _dtdHandler;\n    }\n",
    "123750": "    public void reset() {\n        _length = 0;\n    }\n",
    "123753": "    public TextBuilder newAttribute(String qName) {\n        addAttribute(qName, null);\n        TextBuilder tb = _textBuilders[_length - 1];\n        _values[_length - 1] = tb;\n        tb.reset();\n        return tb;\n    }\n",
    "123754": "    public void remove(int index) {\n        _qNames[index] = _qNames[--_length];\n        _values[index] = _values[_length];\n        TextBuilder tmp = _textBuilders[_length];\n        _textBuilders[_length] = _textBuilders[index];\n        _textBuilders[index] = tmp;\n    }\n",
    "123755": "    private CharSequence toCharSeq(Object str) {\n        if (str instanceof CharSequence)\n            return (CharSequence) str;\n        return Text.valueOf((String) str);\n    }\n",
    "123757": "    public String toString() {\n        Text text = Text.valueOf('[');\n        final Text equ = Text.valueOf('=');\n        final Text sep = Text.valueOf(\", \");\n        for (int i = 0; i < _length;) {\n            text = text.concat(Text.valueOf(_qNames[i]).concat(equ).concat(\n                    Text.valueOf(_values[i])));\n            if (++i != _length) {\n                text = text.concat(sep);\n            }\n        }\n        return text.concat(Text.valueOf(']')).toString();\n    }\n",
    "123759": "    public void setNamespace(String prefix, String uri) {\n        if ((prefix.length() == 1) && (prefix.charAt(0) == 'j'))\n            throw new IllegalArgumentException(\"Prefix: \\\"j\\\" is reserved.\");        \n        _namespaces.addLast(toCharSeq(prefix));\n        _namespaces.addLast(toCharSeq(uri));\n        if (prefix.length() == 0) { // Default namespace mapped\n            // Use javolution uri for all classes without namespace\n            // (default namespace cannot be used anymore).\n            _xml._packagePrefixes.addLast(\"j\");\n            _xml._packagePrefixes.addLast(\"\");\n        }\n    }\n",
    "123760": "    public void setPackagePrefix(String prefix, String packageName) {\n        setNamespace(prefix, \"java:\" + packageName);\n        _xml._packagePrefixes.addLast(prefix);\n        _xml._packagePrefixes.addLast(packageName);\n    }\n",
    "123761": "    public void write( T  obj, Writer writer) throws IOException {\n        try {\n            _writerHandler.setWriter(writer);\n            write(obj, _writerHandler);\n        } catch (SAXException e) {\n            if (e.getException() instanceof IOException) {\n                throw (IOException) e.getException();\n            }\n        } finally {\n            _writerHandler.reset();\n        }\n    }\n",
    "123763": "    public void write( T  obj, OutputStream out) throws IOException {\n        try {\n            _utf8StreamWriter.setOutputStream(out);\n            _writerHandler.setWriter(_utf8StreamWriter);\n            write(obj, _writerHandler);\n        } catch (SAXException e) {\n            if (e.getException() instanceof IOException) {\n                throw (IOException) e.getException();\n            }\n        } finally {\n            _utf8StreamWriter.reset();\n            _writerHandler.reset();\n        }\n    }\n",
    "123769": "    public void reset() {\n        _xml.reset();\n        _namespaces.clear();\n        _xml._packagePrefixes.clear();\n        _areReferencesEnabled = false;\n        _expandReferences = false;\n        _isClassIdentifierEnabled = true;\n    }\n",
    "123771": "    public void setReferencesEnabled(boolean enabled) {\n        _areReferencesEnabled = enabled;\n    }\n",
    "123773": "    public void setExpandReferences(boolean value) {\n        _expandReferences  = value;\n    }\n",
    "123775": "    public void setClassIdentifierEnabled(boolean enabled) {\n        _isClassIdentifierEnabled = enabled;\n    }\n",
    "123777": "    public void setRootName(String name) {\n        _rootName = name;\n    }\n",
    "123778": "    public  T  read(Reader reader) throws XmlException {\n        _xml._parser.setInput(reader);\n        return ( T ) parse();\n    }\n",
    "123779": "    public  T  read(InputStream in) throws XmlException {\n        _xml._parser.setInput(in);\n        return ( T ) parse();\n    }\n",
    "123780": "    public  T  read(ByteBuffer byteBuffer) throws XmlException {\n        _xml._parser.setInput(byteBuffer);\n        return ( T ) parse();\n    }\n",
    "123783": "    public void reset() {\n        _xml.reset();\n    }\n",
    "123791": "    public int length() {\n        return length;\n    }\n",
    "123792": "    public char charAt(int index) {\n        if ((index < 0) || (index >= length))\n            throw new IndexOutOfBoundsException(\"index: \" + index);\n        return data[offset + index];\n    }\n",
    "123793": "    public CharSequence subSequence(int start, int end) {\n        if ((start < 0) || (end < 0) ||\n                 (start > end) || (end > this.length())) \n            throw new IndexOutOfBoundsException();\n        CharSequenceImpl chars = (CharSequenceImpl) FACTORY.object();\n        chars.data = data;\n        chars.offset = offset + start;\n        chars.length = end - start;\n        return chars;\n    }\n",
    "123794": "    public String toString() {\n        return new String(data, offset, length);\n    }\n",
    "123795": "    public int hashCode() {\n        int h = 0;\n        for (int i = 0, j = offset; i < length; i++) {\n            h = 31 * h + data[j++];\n        }\n        return h;\n    }\n",
    "123797": "    public boolean equals(Object that) {\n        if (that instanceof CharSequenceImpl) {\n            return equals((CharSequenceImpl) that);\n        } else if (that instanceof String) { // J2ME: String not a CharSequence.\n            return equals((String) that);\n        } else if (that instanceof CharSequence) {\n            return equals((CharSequence) that);\n        } else {\n            return false;\n        }\n    }\n",
    "123798": "    public boolean equals(CharSequenceImpl that) {\n        if (that == null)\n            return false;\n        if (this.length != that.length)\n            return false;\n        final char[] thatData = that.data;\n        final int end = offset + length;\n        for (int i = offset, j = that.offset; i < end;) {\n            if (data[i++] != thatData[j++])\n                return false;\n        }\n        return true;\n    }\n",
    "123799": "    public boolean equals(String str) {\n        if (str == null)\n            return false;\n        if (length != str.length())\n            return false;\n        for (int i = 0, j = offset; i < length;) {\n            if (data[j++] != str.charAt(i++))\n                return false;\n        }\n        return true;\n    }\n",
    "123800": "    public boolean equals(CharSequence chars) {\n        if (chars == null)\n            return false;\n        if (this.length != chars.length())\n            return false;\n        for (int i = 0, j = offset; i < length;) {\n            if (data[j++] != chars.charAt(i++))\n                return false;\n\n        }\n        return true;\n    }\n",
    "123804": "    public CharSequenceImpl getDefault() {\n        return _default;\n    }\n",
    "123805": "    public int getNamespaceCount(int depth) {\n        if (depth > _depth)\n            return _nspCounts[_depth];\n        return _nspCounts[depth];\n    }\n",
    "123807": "    public CharSequenceImpl getNamespacePrefix(int pos) {\n        return _namespaces[pos << 1];\n    }\n",
    "123808": "    public CharSequenceImpl getNamespaceUri(int pos) {\n        return _namespaces[(pos << 1) + 1];\n    }\n",
    "123810": "    public CharSequenceImpl getNamespaceUri(String prefix) {\n        if (prefix == null)\n            return _default;\n        for (int i = _nspCounts[_depth] + _mapCount; i > 0;) {\n            CharSequenceImpl pfx = _namespaces[--i << 1];\n            if ((pfx != null) && pfx.equals(prefix))\n                return _namespaces[(i << 1) + 1];\n        }\n        if (XML_PREFIX.equals(prefix))\n            return XML_URI;\n        if (XMLNS_PREFIX.equals(prefix))\n            return XMLNS_URI;\n        return null;\n    }\n",
    "123811": "    public void map(CharSequenceImpl prefix, CharSequenceImpl uri) {\n        final int i = (_nspCounts[_depth] + _mapCount++) << 1;\n        if (i + 1 >= _namespaces.length) resize();\n        _namespaces[i] = prefix;\n        _namespaces[i + 1] = uri;\n        if (prefix == null) { // Maps default namespace.\n            _default = uri;\n        }\n    }\n",
    "123813": "    public void flush() {\n        if (_mapCount != 0) {\n            push();\n            pop();\n        }\n    }\n",
    "123814": "    public void setInput(ByteBuffer byteBuffer) {\n        if (_reader != null)\n            throw new IllegalStateException(\"Parser not reset.\");\n        _byteBufferReader.setByteBuffer(byteBuffer);\n        _inputEncoding = \"UTF-8\";\n        setInput(_byteBufferReader);\n    }\n",
    "123815": "    public void push() {\n        if (++_depth >= _nspCounts.length) resize();\n        _nspCounts[_depth] = _nspCounts[_depth - 1] + _mapCount;\n        _mapCount = 0;\n    }\n",
    "123816": "    public void pop() {\n        _mapCount = 0;\n        final int oldCount = _nspCounts[_depth];\n        final int newCount = _nspCounts[--_depth];\n        for (int i = oldCount; i > newCount;) {\n            if (_namespaces[--i << 1] == null) { // Unmaps default namespace.\n                _default = CharSequenceImpl.EMPTY;\n                for (int j = i; j > 0;) { // Searches current default.\n                    if (_namespaces[--j << 1] == null) {\n                        _default = _namespaces[(j << 1) + 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n",
    "123818": "    private void resize() {\n        final int size = _nspCounts.length; // = _namepaces.length;\n        int[] tmp0 = new int[size * 2];\n        System.arraycopy(_nspCounts, 0, tmp0, 0, size);\n        _nspCounts = tmp0;\n        CharSequenceImpl[] tmp1 = new CharSequenceImpl[size * 2];\n        System.arraycopy(_namespaces, 0, tmp1, 0, size);\n        _namespaces = tmp1;\n        SIZE.setMinimum(new Integer(_namespaces.length));\n    }\n",
    "123821": "    public void setInput(InputStream in) {\n        if (_reader != null)\n            throw new IllegalStateException(\"Parser not reset.\");\n        _inputStreamReader.setInputStream(in);\n        _inputEncoding = \"UTF-8\";\n        setInput(_inputStreamReader);\n    }\n",
    "123846": "    public XmlInputStream setInputStream(InputStream in) {\n        if (_xmlReader._inputStream != null)\n            throw new IllegalStateException(\"Stream not closed or reset\");\n        _xmlReader._inputStream = in;\n        return this;\n    }\n",
    "123847": "    public  T  readObject() throws IOException {\n        try {\n            return _objectReader.read(_xmlReader);\n        } finally {\n           _xmlReader.resume();\n        }\n    }\n",
    "123851": "    public int read() throws IOException {\n        if (_xmlReader._start < _xmlReader._end) {\n            return _xmlReader._bytes[_xmlReader._start++];\n        } else { // Use the reader buffer.\n            return _xmlReader.fillBuffer() ?\n                 _xmlReader._bytes[_xmlReader._start++] : -1;\n        }\n    }   \n",
    "123856": "        public void resume() {\n            _isHalted = false;\n        }\n",
    "123859": "    public Attributes getSaxAttributes() {\n        return _attributes;\n    }\n",
    "123870": "    public Class objectClass() {\n        return _objectClass;\n    }\n",
    "123873": "    public ContentHandler formatter() {\n        return _formatHandler;\n    }\n",
    "123877": "    public XmlOutputStream setOutputStream(OutputStream out) {\n        if (_outputStream != null)\n            throw new IllegalStateException(\"Stream not closed or reset\");\n        _outputStream = out;\n        return this;\n    }\n",
    "123878": "    public void writeObject( T  obj) throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _objectWriter.write(obj, _outputStreamProxy);\n        _outputStream.write(END_XML);\n        _outputStream.flush();\n    }\n",
    "123880": "    public void write(int b) throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _outputStream.write(b);\n    }\n",
    "123881": "    public void flush() throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _outputStream.flush();\n    }\n",
    "123883": "    public void write(byte b[], int off, int len) throws IOException {\n        if (_outputStream == null) throw new IOException(\"Stream closed\");\n        _outputStream.write(b, off, len);\n    }\n",
    "123892": "    public String defaultName() {\n        return null;\n    }\n",
    "123895": "    public int offset() {\n        return _offset;\n    }\n",
    "123898": "    public void add(Object obj, String qName, Class clazz) {\n        if (obj == null)\n            return;\n        try {\n            // Flushes outer start element if any.\n            if (_elemName != null)\n                flushStart();\n\n            // Formats the specified object.\n            CharSequence elemName = _elemName = toCharSeq(qName);\n            format(obj, XmlFormat.getInstance(clazz));\n            if (_elemName != null)\n                flushStart();\n            _formatHandler.endElement(Text.EMPTY, elemName, elemName);\n\n        } catch (SAXException e) {\n            throw new XmlException(e);\n        }\n    }\n",
    "123899": "    public char charAt(int index) {\n        if (index >= _length)\n            throw new IndexOutOfBoundsException();\n        return _chars[index];\n    }\n",
    "123900": "    public CharSequence subSequence(int start, int end) {\n        if ((start < 0) || (start > end) || (end > _length))\n            throw new IndexOutOfBoundsException();\n        return CharacterData.valueOf(_chars, _offset + start, end - start);\n    }\n",
    "123902": "    public String identifier(boolean isReference) {\n        return isReference ? \"j:ref\" : \"j:id\";\n    }\n",
    "123903": "    public void addNotify() {\n        super.addNotify();\n\n        Component parent = getParent();\n        if (parent != null && parent instanceof EqPanel)\n            equationPanelParent = (EqPanel) parent;\n\n        // this method must be called in a new thread, otherwise problems might\n        // result (the real dangerous thing is to run updateLayout() in the\n        // same command stack as addNotify()\n        Runnable thread = new Runnable() {\n            public void run() {\n                updateLagsSymbol();\n            }\n        };\n        SwingUtilities.invokeLater(thread);\n\n    }\n",
    "123904": "    public TextBuilder newAttribute(String name) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        return _formatAttributes.newAttribute(name);\n    }\n",
    "123907": "    public int getColumnWidth() {\n        return ((EqTermDefault) allTerms.get(0)).getColumnWidth();\n    }\n",
    "123908": "    public T allocate(XmlElement xml) {\n        return null;\n    }\n",
    "123909": "    public MouseListener getMouseListenerCoeff() {\n        return ((EqTermDefault) allTerms.get(0)).getMouseListenerCoeff();\n    }\n",
    "123910": "    public void setAttribute(String name, CharSequence value) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        if (value == null)\n            return;\n        _formatAttributes.addAttribute(name, value);\n    }\n",
    "123912": "    public int getPrecision() {\n        return ((EqTermDefault) allTerms.get(0)).getPrecision();\n    }\n",
    "123913": "    public TableCellRenderer getRendererCoeff() {\n        return ((EqTermDefault) allTerms.get(0)).getRendererCoeff();\n    }\n",
    "123915": "    public void setAttribute(String name, String value) {\n        if ((_formatAttributes == null) || (_elemName == null))\n            attributeSettingError();\n        if (value == null)\n            return;\n        CharSequence csqValue = toCharSeq(value);\n        _formatAttributes.addAttribute(name, csqValue);\n    }\n",
    "123916": "    public int getStartLag() {\n        return -1 * ((EqTermDefault) allTerms.get(0)).getLagIndex();\n    }\n",
    "123917": "\tpublic void addColumn(TableColumn tc) {\n\t\tif (part < 0) {\n\t\t\tsuper.addColumn(tc);\n\t\t} else { // display only columns for the given lag\n\t\t\tint i = tc.getModelIndex();\n\t\t\tif ((part * n) <= i && i < ((part + 1) * n))\n\t\t\t\tsuper.addColumn(tc);\n\t\t}\n\t}\n",
    "123918": "\tpublic int getIndex() {\n\t\treturn part;\n\t}\n",
    "123919": "\tpublic int getNumberOfColumns() {\n\t\treturn n;\n\t}\n",
    "123921": "\tpublic void setIndex(int arg) {\n\t\tif (part != arg)\n\t\t\tpart = arg;\n\n\t}\n",
    "123923": "\tpublic void setNumberOfColumns(int arg) {\n\t\tn = Math.max(0, arg);\n\t}\n",
    "123924": "    public String getSymbolNameCoeff() {\n        return ((EqTermDefault) allTerms.get(0)).getSymbolNameCoeff();\n    }\n",
    "123925": "    public JSCNArray getJSCNArraySubsetRes() {\n        if (subsetResDef == null)\n            return null;\n\n        SymbolTable sTable = getSymbolTable();\n        if (sTable == null) // not explicitely set\n            sTable = getSymbolScope().getSymbolTable(this);\n\n        if (sTable != null)\n            return sTable.get(subsetResDef).getJSCNArray();\n\n        return null;\n    }\n",
    "123926": "    public SubMatModel getSubMatModel() {\n        return subMatrixModel;\n    }\n",
    "123927": "    public String getSymbolNameSubsetRes() {\n        if (subsetResDef == null)\n            return null;\n\n        return subsetResDef.name;\n    }\n",
    "123928": "    public String getSymbolNameLags() {\n        if (lagsDef == null)\n            return null;\n\n        return lagsDef.name;\n    }\n",
    "123929": "    private void makeVisible() {\n        int c = getColumnCount();\n        boolean b = isVisible();\n        if (c < 1 && b)\n            setVisible(false);\n        if (c > 0 && !b)\n            setVisible(true);\n    }\n",
    "123930": "    public void setColumnCount(int arg) {\n        if (subMatrixModel == null) {\n            subMatrixModel = new SubMatModel(0);\n            subMatrixModel.setNumberOfColumns(arg);\n            super.setColumnModel(subMatrixModel);\n        } else {\n            int oldCols = getColumnCount();\n            if (oldCols != arg) {\n                subMatrixModel.setNumberOfColumns(arg);\n                createDefaultColumnsFromModel();\n            }\n        }\n        makeVisible();\n\n    }\n",
    "123932": "    public void setColumnModel(TableColumnModel newModel) {\n        if (subMatrixModel != null)\n            throw new IllegalStateException(\"No submatrix model set.\");\n\n        super.setColumnModel(newModel);\n    }\n",
    "123933": "    public String getSymbolNameSubsetRes() {\n        return ((EqTermDefault) allTerms.get(0)).getSymbolNameSubsetRes();\n    }\n",
    "123934": "    public void setAttribute(String name, boolean value) {\n        newAttribute(name).append(value);\n    }\n",
    "123935": "    public void setIndex(int arg) {\n        if (subMatrixModel == null) {\n            subMatrixModel = new SubMatModel(arg);\n            super.setColumnModel(subMatrixModel);\n        } else\n            subMatrixModel.setIndex(arg);\n\n    }\n",
    "123936": "    public void setSymbolNameSubsetRes(String newSymbolNameSubsetRes) {\n        if (newSymbolNameSubsetRes == null) {\n            subsetResDef = null;\n            return;\n        }\n\n        subsetResDef = new JSCTypeDef(newSymbolNameSubsetRes, JSCTypes.NARRAY);\n\n        SymbolTable sTable = getSymbolTable();\n        if (sTable == null) // not explicitely set\n            sTable = getSymbolScope().getSymbolTable(this);\n\n        if (sTable != null) {\n            sTable.get(subsetResDef).addSymbolListener(new SymbolListener() {\n                public void valueChanged(SymbolEvent evt) {\n                    resizeAndRepaint();\n                }\n            });\n        }\n    }\n",
    "123937": "    public String getSymbolNameVariables() {\n        return ((EqTermDefault) allTerms.get(0)).getSymbolNameVariables();\n    }\n",
    "123939": "    public void setVisible(boolean aFlag) {\n        boolean oldValue = isVisible();\n        super.setVisible(aFlag);\n        firePropertyChange(\"visible\", oldValue, isVisible());\n    }\n",
    "123941": "    public void tableChanged(TableModelEvent e) {\n        super.tableChanged(e);\n        makeVisible();\n    }\n",
    "123942": "    public JPopupMenu getTablePopup() {\n        return tablePopup;\n    }\n",
    "123943": "\tpublic int getColumnWidth() {\n\t\treturn alpha.getColumnWidth();\n\t}\n",
    "123945": "    public boolean isEditable() {\n        return ((EqTermDefault) allTerms.get(0)).isEditable();\n    }\n",
    "123946": "\tpublic MouseListener getMouseListenerCoeff() {\n\t\treturn mouseListenerCoeff;\n\t}\n",
    "123947": "    public void setAttribute(String name, int value) {\n        newAttribute(name).append(value);\n    }\n",
    "123948": "\tpublic int getPrecision() {\n\t\treturn alpha.getPrecision();\n\t}\n",
    "123950": "\tpublic TableCellRenderer getRendererCoeff() {\n\t\treturn alpha.getCellRenderer();\n\t}\n",
    "123951": "    public void propertyChange(java.beans.PropertyChangeEvent evt) {\n        if (evt.getSource().equals(allTerms.get(0))\n                && evt.getPropertyName() == \"visible\") {\n            // also sets term visible/invisible\n            setDataAvailable(((Boolean) evt.getNewValue()).booleanValue());\n        }\n    }\n",
    "123952": "\tpublic String getSymbolNameAlphaCoeff() {\n\t\treturn alpha.getSymbolName();\n\t}\n",
    "123953": "\tpublic String getSymbolNameAlphaSubsetRes() {\n\t\treturn alpha.getSymbolNameSubsetRes();\n\t}\n",
    "123954": "    public void setColumnWidth(int colWidth) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setColumnWidth(colWidth);\n    }\n",
    "123955": "\tpublic String getSymbolNameBetaCoeff() {\n\t\treturn ecTerm1.getSymbolNameCoeff();\n\t}\n",
    "123957": "\tpublic String getSymbolNameBetaDetCoeff() {\n\t\treturn ecTerm2.getSymbolNameCoeff();\n\t}\n",
    "123958": "\tpublic String getSymbolNameBetaDetSubsetRes() {\n\t\treturn ecTerm2.getSymbolNameSubsetRes();\n\t}\n",
    "123959": "    public void setEditable(boolean isEditable) {\n        for (int i = 0; i < allTerms.size(); i++)\n            ((EqTermDefault) allTerms.get(i)).setEditable(isEditable);\n    }\n",
    "123960": "    public void setAttribute(String name, long value) {\n        newAttribute(name).append(value);\n    }\n",
    "123961": "\tpublic String getSymbolNameBetaSubsetRes() {\n\t\treturn ecTerm1.getSymbolNameSubsetRes();\n\t}\n",
    "123962": "\tpublic String getSymbolNameDetVarNames() {\n\t\treturn ecTerm2.getSymbolNameVariables();\n\t}\n",
    "123963": "    public void setLeadingSignVisible(boolean isVisible) {\n        ((EqTermDefault) allTerms.get(0)).setLeadingSignVisible(isVisible);\n    }\n",
    "123965": "\tpublic String getSymbolNameEndVarNames() {\n\t\treturn ecTerm1.getSymbolNameVariables();\n\t}\n",
    "123966": "\tpublic boolean isEditable() {\n\t\treturn alpha.isEditable();\n\t}\n"
}
