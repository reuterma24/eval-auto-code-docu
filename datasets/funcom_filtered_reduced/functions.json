{
    "321": "\tpublic int getPushesLowerbound() {\n\t\treturn pushesLowerbound;\n\t}\n",
    "323": "\tpublic void setPushesLowerbound(int pushesLowerbound) {\n\t\tthis.pushesLowerbound = pushesLowerbound;\n\t}\n",
    "324": "\t\tpublic void play() {\n\t\t\t\n\t\t\t// If no sound file is there nothing can be played.\n\t\t\tif(currentSoundFilename.equals(\"\"))\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// Check if the this sound must be read from another file (the user has\n\t\t\t// chosen another sound to be played).\n\t\t\tString settingsFileName = Settings.get(soundSettingsKey);\n\t\t\tif(!currentSoundFilename.equals(settingsFileName)) {\n\t\t\t\tloadClip(settingsFileName);\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Stop the currently playing sound to play the new sound if necessary.\n\t\t\tif (clip.isRunning()) {\n\t\t\t\tclip.stop();\n\t\t\t}\n\t\t\t\n\t\t\t// Rewind to the beginning.\n\t\t\tclip.setFramePosition(0); \n\t\t\t\n\t\t\t// Start playing.\n\t\t\tclip.start();    \n\t\t}\n",
    "343": "\tpublic int getInfluenceValue(int boxNo1, int boxNo2) {\n\t\treturn influence.getInfluenceDistance( board.boxData.getBoxPosition(boxNo1),\n\t\t\t\t                               board.boxData.getBoxPosition(boxNo2) );\n\t}\n",
    "351": "\tpublic void setPositions(int[] positions){\n\t\tthis.positions = positions;\n\t}\n",
    "352": "\tpublic int getPlayerPosition() {\n\t\treturn positions[positions.length-1];\n\t}\n",
    "355": "\tpublic int getPulledBoxNumber() {\n\t\treturn pulledBoxNo;\n\t}\n",
    "357": "\tpublic int getStartBoxPosition() {\n\t\treturn startPosition;\n\t}\n",
    "359": "\tpublic int getTargetBoxPosition() {\n\t\treturn targetPosition;\n\t}\n",
    "361": "    public BoardPositionPackingSequence getPrecedingBoardPosition() {\n    \treturn precedingBoardPosition;\n    }\n",
    "364": "\tpublic int compareTo(BoardPositionPackingSequence boardPosition) {\n\t\treturn boardPosition.getRelevance() - getRelevance();\n\t}\n",
    "373": "\tpublic boolean isForcedPush() {\n\t\treturn isPushForced;\n\t}\n",
    "376": "\tfinal public void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "412": "\tpublic boolean isSolverStoppedDueToOutOfMemory() {\n\t\treturn isSolverStoppedDueToOutOfMemory;\n\t}\n",
    "428": "    final protected IBoardPositionMoves getBestBoardPosition(){\n\n\t\t// Nimmt die Liste aller Stellungen mit einer bestimmten L\u00f6sungspfadl\u00e4nge auf\n\t\tLinkedList<IBoardPositionMoves> boardPositionList;\n\t\t\n\t\tfor(int solutionLength = shortestSolutionPathLength; solutionLength <= longestSolutionPathLength; solutionLength++) {\n\t\t\n\t\t\t// Liste der Stellungen mit der aktuellen Pfadl\u00e4nge holen. \n\t\t\tboardPositionList = boardPositionQueue.get(solutionLength);\n\t\t\t\n\t\t\tif(boardPositionList.size() > 0){\t \n\t\t\t    shortestSolutionPathLength = solutionLength;\n\t\t\t    \n\t\t\t\t// Die zuletzt eingef\u00fcgte Stellung zur\u00fcckgeben\n\t    \t\treturn boardPositionList.removeLast();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n",
    "437": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn precedingBoardPosition;\n\t}\n",
    "440": "\tfinal public int getDirection() {\n\t\treturn positionData >>> 13;\n\t}\n",
    "442": "\tpublic int getBoxNo() {\n\t\treturn positionData & ((1 << 10) - 1);\n\t}\n",
    "445": "\tprotected String creatorName() {\n\t\treturn Texts.getText(\"solver\");\n\t}\n",
    "446": "\tfinal public int getPlayerPosition() {\n\t\treturn playerPosition;\n\t}\n",
    "448": "\tfinal public void setPositions(int[] positions) {\n\t\tthis.positions = positions;\n\t}\n",
    "450": "\tfinal public IBoardPosition getPrecedingBoardPosition() {\n\t\treturn null;\n\t}\n",
    "454": "\tfinal public void setSearchDirection(SearchDirection searchDirection) {\n\n\t\tif (searchDirection == SearchDirection.FORWARD) {\n\t\t\tforwardsSearch  = true;\n\t\t} else {\n\t\t\tbackwardsSearch = true;\n\t\t}\n\t}\n",
    "458": "\tfinal public int getDirection() {\n\t\treturn 0;\n\t}\n",
    "459": "\tpublic int getPushesCount() {\n\n\t\tint pushesCount = 0;\n\n\t\tfor (BoardPosition currentBoardPosition = this; currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition() != null; currentBoardPosition = (BoardPosition) currentBoardPosition\n\t\t\t\t.getPrecedingBoardPosition()) {\n\t\t\tif (currentBoardPosition.getBoxNo() != NO_BOX_PUSHED) {\n\t\t\t\tpushesCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn pushesCount;\n\t}\n",
    "461": "\tfinal public int getBoxNo() {\n\t\treturn NO_BOX_PUSHED;\n\t}\n",
    "463": "\tpublic void setMaximumSolutionLength(short maximumSolutionLength) {\n\t\tmaximumPushesCurrentIteration = maximumSolutionLength;\n\t}\n",
    "464": "\tfinal public int getPlayerPosition() {\n\t\treturn positions[boxCount];\n\t}\n",
    "466": "\tpublic short getMaximumSolutionLength() {\n\t\treturn maximumPushesCurrentIteration;\n\t}\n",
    "467": "\tfinal public int getPushesCount() {\n\t\treturn 0;\n\t}\n",
    "472": "\tprotected String solutionByMeAt(Date date) {\n\t\treturn  Texts.getText(\"createdBy\")\n\t\t      + \" \" + creatorName()\n\t\t      + \" \" + Utilities.dateString(date);\n\t}\n",
    "476": "\tfinal public void setMovesCount(int movesCount) {\n\t\tthis.movesCount = (short) movesCount;\n\t}\n",
    "487": "\tpublic int getIndexPackingSequence() {\n\t\treturn indexPackingSequence;\n\t}\n",
    "489": "\tpublic void setIndexPackingSequence(int indexPackingSequence) {\n\t\tthis.indexPackingSequence = indexPackingSequence;\n\t}\n",
    "494": "\tprotected boolean isBoxInactive(int boxNo) {\n\t\treturn isBoxInactive[boxNo];\n\t}\n",
    "496": "\tfinal public boolean isBoxInactive() {\n\t\treturn (positionData & INACTIVE_BOX) > 0;\n\t}\n",
    "497": "\tpublic void setCorralDeadlock() {\n\t\tisDeadlock = true;\n\t}\n",
    "498": "\tpublic void setNotCorralDeadlock() {\n\t\tisNotDeadlock = true;\n\t}\n",
    "499": "\t\tpublic boolean getValue() {\n\t\t\t/*\n\t\t\t * Since we here are inside of class Settings, we should not get\n\t\t\t * an IllegalAccessException.\n\t\t\t * Hence, we catch the exceptions here, and return false,\n\t\t\t * just in case.\n\t\t\t */\n\t\t\ttry {\n\t\t\t\treturn field.getBoolean(null);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n",
    "500": "\tprotected String solutionByMeNow() {\n\t\treturn solutionByMeAt(null);\n\t}\n",
    "501": "\tpublic void setCorralNo(int corralNo) {\n\t\tthis.corralNo = corralNo;\n\t}\n",
    "503": "\tpublic void setInfoText(String text) {\n\t\tinfoText.setText(text);\n\t}\n",
    "504": "\tpublic int getCorralNo() {\n\t\treturn corralNo;\n\t}\n",
    "506": "\tpublic boolean isCorralDeadlock() {\n\t\treturn isDeadlock;\n\t}\n",
    "507": "\tpublic boolean isNotCorralDeadlock() {\n\t\treturn isNotDeadlock;\n\t}\n",
    "508": "\tpublic boolean isClassified() {\n\t\treturn isDeadlock || isNotDeadlock;\n\t}\n",
    "510": "\tpublic boolean isBeeingAnalyzed() {\n\t\treturn !isDeadlock && !isNotDeadlock;\n\t}\n",
    "513": "\tpublic CBoard getClone() {\n\t\treturn new CBoard(boardElements.clone(), width, height, playerPositionX, playerPositionY);\n\t}\n",
    "514": "\t\tpublic void setValue(boolean value) {\n\t\t\t/*\n\t\t\t * Regarding exceptions see comment in \"getValue\"\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tfield.setBoolean(null, value);\n\t\t\t\tSystem.out.println(\"Setting: DebugVar: \"+field.getName()+\" set to \"+value);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// well... forget it.\n\t\t}\n",
    "517": "\tprivate boolean isEqual(int boxConfigurationNumber, byte[] boxConfiguration) {\n\t\t\n\t\tint indexOfBoxConfiguration = boxConfigurationNumber * packedBoardByteSize;\n\t\t\n\t\t// Compare byte by byte of both box configurations.\n\t\tfor(int byteNo=0; byteNo < boxConfiguration.length; byteNo++) {\n\t\t\tif (boxConfigurations[indexOfBoxConfiguration++] != boxConfiguration[byteNo]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n",
    "523": "\tpublic int getMaxCapacity() {\n\t\treturn maxCapacity;\n\t}\n",
    "524": "\tpublic void add(int boardPositionIndex, int boardPositionPredecessor) {\n\t\t\n\t\t// The moves queue also contains an arbitrary number of span markers.\n\t\t// Therefore after every added board position there must be done\n\t\t// a check whether the memory block is already full.\n\t\tadd(boardPositionIndex      );\n\t\tadd(boardPositionPredecessor);\n\t}\n",
    "531": "\tpublic void jumpOverBoardPosition(int boardPosition) {\n\t\n\t\t// \"Remove\" all values from the queue which are equal to the passed one\n\t\t// FFS/hm: does the caller guarantee that the Q cannot become empty by this?\n\t\twhile(memoryBlockToRead.memory[nextIndexToRead] == boardPosition) {\n\t\t\tremoveBoardPosition();\n\t\t}\n\t}\n",
    "535": "\tpublic int removeLastBoardPosition() {\n\t\t\t\t\t\t\n\t\tif(nextIndexToWrite == 0) {\n\t\t\t\n\t\t\t// The previous memory block becomes the new current memory block.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\n\t\t}\n\t\t\n\t\treturn memoryBlockToWrite.memory[--nextIndexToWrite];\n\t}\n",
    "538": "\tpublic void jumpXBoardPositionsBackwards(int jumpCount) {\n\t\t\n\t\twhile(jumpCount > nextIndexToWrite) {\n\t\t\t\t\t\t\t\n\t\t\t// Assign the previous memory block of the queue.\n\t\t\tmemoryBlockToWrite = memoryBlockToWrite.previousMemoryBlock;\n\t\t\t\n\t\t\tjumpCount -= nextIndexToWrite;\n\t\t\tnextIndexToWrite = MEMORY_BLOCK_SIZE;\t\t\t\t\t\n\t\t}\n\t\tnextIndexToWrite -= jumpCount;\n\t}\n",
    "542": "\tpublic boolean isEmpty() {\n\t\t// This method is only called for the moves queue which has recycling activated.\n\t\treturn memoryBlockToRead == memoryBlockToWrite\n\t\t    && nextIndexToRead   == nextIndexToWrite;\n\t}\n",
    "547": "\tpublic boolean isGenerationStoppedDueToFullStorage() {\n\t\treturn generationStoppedDueToFullStorage;\n\t}\n",
    "551": "\tpublic int getBoxConfigurationNumber() {\n\t\treturn uniqueBoxConfigurationNumber;\n\t}\n",
    "561": "\tpublic boolean isBetterMovesPushesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( movesCount , other.movesCount,\n\t\t                                   pushesCount, other.pushesCount )\n\t\t     < 0 ;\n\t}\n",
    "563": "\tpublic boolean isBetterPushesMovesThan( OptimizerSolution other ) {\n\t\tif (other == null) {\n\t\t\treturn true;\t\t\t// everybody is better than nobody\n\t\t}\n\t\treturn Utilities.intCompare2Pairs( pushesCount, other.pushesCount,\n\t\t                                   movesCount , other.movesCount  )\n\t\t     < 0 ;\n\t}\n",
    "568": "\tpublic void add(OptimizerBoardPosition boardPosition) {\n\n\t\t// Ensure that a real board position has been passed.\n        if (boardPosition == null)\n            throw new NullPointerException();\n\t\t\n\t\t// Double the size of the queue if it is full.\n\t\tif (count >= queue.length) {\n\t\t\tqueue = Arrays.copyOf(queue, queue.length * 2);\t\n\t\t}\t\t\n\t\t\n\t\t// Add the new value at the correct position. \n\t\tsiftUp(count, boardPosition);\n\t\t\n\t\t// One more board position has been stored => increase the counter.\n\t\tcount++;\n\t}\n",
    "570": "\tpublic int size() {\n\t\treturn count;\n\t}\n",
    "572": "\tpublic OptimizerBoardPosition removeFirst() {\n\n\t\tif (count == 0)\n\t\t\treturn null;\n\n\t\t// The head of the queue must be returned.\n\t\tOptimizerBoardPosition result = queue[0];\n\t\t\n\t\t// The head of the queue has (logically) been removed => adjust the size.\n\t\t--count;\n\t\t\n\t\t// Remove the last board position.\n\t\tOptimizerBoardPosition x = queue[count];\n\t\tqueue[count] = null;\n\t\t\n\t\t// If there is at least one board position left in the queue then \n\t\t// shift the board positions so the queue has a new head.\n\t\tif (count != 0)\n\t\t\tsiftDown(0, x);\n\n\t\treturn result;\n\t}\n",
    "576": "\tprivate void addLogTextStyle(final String text, final String stylename) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tStyledDocument doc = optimizerLog.getStyledDocument(); \n\t\t\t\t\tdoc.insertString(doc.getLength(), text+\"\\n\", doc.getStyle(stylename));\t\t\t\n\t\t\t\t} catch (BadLocationException e) {\t/* ignore */ }\n\t\t\t}\n\t\t});\n\t}\n",
    "577": "\t private void siftDown(int position, OptimizerBoardPosition boardPosition) {\n\t\t \n\t\t // Calculate the half of the size as the maximum position the loop must go to.\n\t\t int half = count >>> 1;        \n\t\t \n\t\t while (position < half) {\n\t\t\t int childIndex = (position << 1) + 1; // assuming the left child is the \"better\" board position\n\t\t\t OptimizerBoardPosition child = queue[childIndex];\n\t\t\t int rightChildIndex = childIndex + 1;\n\t\t\t if (rightChildIndex < count && child.compareTo(queue[rightChildIndex]) > 0)\n\t\t\t\t child = queue[childIndex = rightChildIndex];\n\t\t\t if (boardPosition.compareTo(child) <= 0)\n\t\t\t\t break;\n\t\t\t queue[position] = child;\n\t\t\t position = childIndex;\n\t\t }\n\t\t \n\t\t queue[position] = boardPosition;\n\t }\n",
    "580": "\tpublic int getNumberOfStoredBoardPositions() {\n\t\treturn count.get();\n\t}\n",
    "601": "\tpublic void removeAllMarkings() {\n\t\tmarkedSquares = null;\n\t}\n",
    "608": "\tpublic void showDeadlockQueryStats() {\n\t\tdlqTotStats.sumFrom(dlqCurStats);\n\t\tif ( ! dlqTotStats.equals(dlqCurStats)) {\n\t\t\tshow1DLQStats(\"total\", dlqTotStats, 0);\n\t\t}\n\t\t\n\t\tshow1DLQStats(\"this time\", dlqCurStats, dlqTotStats.dlqAsked);\n\t\tdlqCurStats.clear();\n\t}\n",
    "610": "\tprivate int getBoxConfigurationIndex(int boardPositionIndex) {\n\t\t// The board position may just been locked by another thread. However,\n\t\t// this method is only called for already completely stored board positions.\n\t\t// Hence, the index can't hold just the \"LOCKED\" value but must\n\t\t// always also contain a valid box configuration index.\n\t\treturn table.get(boardPositionIndex+BOX_CONFIGURATION_OFFSET)&(~LOCKED); \n\t}\n",
    "613": "\tfinal private boolean hasSubset(byte[] boxConfiguration1, byte[] boxConfigurationArray, int indexInArray) {\n\t\tfor (int i = 0; i < packedBoardByteSize; i++) {\n\t\t\tbyte b2 = boxConfigurationArray[indexInArray + i];\n\t\t\t// \"b2\" is a subset, if all its 1-bits survive the ANDing with the first byte\n\t\t\tif ((boxConfiguration1[i] & b2) != b2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "617": "\tprivate int getPlayerPosition(int boardPositionIndex) {\n\t\t// The player position is only using some of the lower bits of the int it is stored in. Hence, we have to use a bit mask.\n\t\treturn table.get(boardPositionIndex+PLAYER_POSITION_OFFSET)&PLAYER_POSITION_AND_MASK;\n\t}\t\n",
    "619": "\t\tfinal private void doubleTreeSize() {\n\t\n\t\t\t// Double the tree size.\n\t\t\tint[] newArrayPointers = new int[2*2*treeSizeMax];\n\t\t\tSystem.arraycopy(arrayPointers, 0, newArrayPointers, 0, 2*treeSizeMax);\n\t\t\tarrayPointers = newArrayPointers;\n\t\n\t\t\tbyte[] newArrayData = new byte[packedBoardByteSize*2*treeSizeMax];\n\t\t\tSystem.arraycopy(treeData, 0, newArrayData, 0, packedBoardByteSize*treeSizeMax);\n\t\t\ttreeData = newArrayData;\n\t\n\t\t\ttreeSizeMax <<= 1;\n\t\t}\n",
    "626": "\t\tfinal private int treeToSortedListRecursively(int indexInTree, int last) {\n\t\n\t\t\t// If the end of the tree has been reached return the last index.\n\t\t\tif (indexInTree == -1) {\n\t\t\t\treturn last;\n\t\t\t}\n\t\n\t\t\t// Left side of the tree.\n\t\t\tint d = treeToSortedListRecursively(arrayPointers[2*indexInTree], last);\n\t\t\tsortedList[d++] = indexInTree;\n\t\n\t\t\t// Right side of the tree.\n\t\t\treturn (treeToSortedListRecursively(arrayPointers[2*indexInTree+1], d));\n\t\t}\n",
    "637": "\tfinal public int getNumberOfSelectedObject() {\n\t\treturn currentlyMarkedObject;\n\t}\n",
    "638": "\t\tfinal private void binaryTreeToBinaryHeap() {\n\t\t\n\t\t\tbyte[] treeDataTemp = new byte[packedBoardByteSize*treeSize];\n\t\t\n\t\t\tfor (int i=0, indexInVector = 0; i<treeSize; i++) {\n\t\t\t\tSystem.arraycopy(treeData, arrayPointers[i]*packedBoardByteSize, treeDataTemp, indexInVector, packedBoardByteSize);\n\t\t\t\tindexInVector += packedBoardByteSize;\n\t\t\t}\n\t\t\n\t\t\ttreeData = treeDataTemp;\n\t\t\tarrayPointers = null;\n\t\t}\n",
    "641": "\tfinal public void mouseWheelMoved(MouseWheelEvent evt) {\n\n\t\tint scrollDirection = evt.getWheelRotation();\n\n\t\t// Scrollen nach oben\n\t\tif (scrollDirection < 0 && currentlyMarkedObject > 0) {\n\t\t\tcurrentlyMarkedObject--;\n\t\t}\n\n\t\t// Scrollen nach unten\n\t\tif (scrollDirection > 0 && currentlyMarkedObject < 4) {\n\t\t\tcurrentlyMarkedObject++;\n\t\t}\n\n\t\tapplication.redraw(false);\n\t}\n",
    "643": "\tpublic void setProcessedStatus(int boardPositionIndex, boolean processedStatus) {\n\t\t\n\t\t// Set/delete the \"processed\"-flag. This needn't to be done using compareAndSwap\n\t\t// because all of the other information stored at that offset have already been \n\t\t// stored and cannot change anymore while this method is executed.\n\t\tint currentValue = table.get(boardPositionIndex+PLAYER_POSITION_OFFSET);\n\t\tif(processedStatus == true)\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue | PROCESSED_FLAG_BIT_MASK);\n\t\telse\n\t\t\ttable.set(boardPositionIndex+PLAYER_POSITION_OFFSET, currentValue & (~PROCESSED_FLAG_BIT_MASK));\n\t}\n",
    "648": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * View on the levels\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "651": "\t\tprotected void finalize() {\n\t\t\tarrayPointers = null;\n\t\t\tsortedList = null;\n\t\t\ttreeData = null;\n\t\t}\n",
    "653": "\tpublic void stateChanged(final ChangeEvent e) {\n\t\t\t\t\n\t\t// Get the tabbed pane all views are stored in.\n\t\tJTabbedPane tabbedPane = (JTabbedPane) e.getSource();\n\t\t\n\t\t/*\n\t\t * Language settings\n\t\t */\n\t\tif(tabbedPane.getSelectedComponent() == languageSettings) {\n\t\t\n\t\t}\t\t\n\t\t\n\t}\n",
    "656": "\tprivate void createPanel() {\n\t\t\n\t\tsetLayout(new BorderLayout());\n\n\t\tJPanel guiPanel = new JPanel(new GridLayout(0, 1, 0, 10));\n\t\tguiPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createEmptyBorder(10, 10, 10, 10)));\n\n\t\t// Just a quick and dirty test coding ...\n\t\tNimRODFontDialog d = new NimRODFontDialog(null);\n\t\tComponent[] c = d.getContentPane().getComponents();\n\t\tguiPanel.add(c[0]);\n\t\t\n\t\tadd(guiPanel, BorderLayout.NORTH);\n\t}\n",
    "663": "\tprivate void updateElements() {\n\t\tfinal boolean selected = checkboxGUI.isSelected();\n\t\t\n\t\ttextfieldGUI.setEnabled(selected);\n\t\tlabelGUI.setEnabled(selected);\n\t}\n",
    "666": "\tpublic Double getValueAsDouble() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsDouble() : null;\n\t}\n",
    "669": "\tpublic Integer getValueAsInteger() {\n\t\treturn checkboxGUI.isSelected() ? textfieldGUI.getValueAsInteger() : null;\n\t}\n",
    "670": "\tpublic void enterMeForTypeDate(JTable table) {\n\t\ttable.setDefaultRenderer(java.util.Date.class, this);\n\t}\n",
    "672": "\tpublic void addLevel(Level level) {\n\t\tdisplayedLevels.add(level);\n\t\tif (displayedLevels.size() < levelsPerPage) {\n\t\t\tlastLevelIndex = displayedLevels.size() - 1;\n\t\t} else {\n\t\t\tlastLevelIndex = levelsPerPage - 1;\n\t\t}\n\t}\n",
    "675": "\tpublic boolean isFieldActive() {\n\t\treturn textfieldGUI.isEnabled();\n\t}\n",
    "676": "\tpublic void addLevelCollection(final LevelCollection collection, int startNumber, int endNumber) {\n\t\tfor(int levelNo = startNumber; levelNo <= collection.getNumberOfLevels() && levelNo <= endNumber; levelNo++) {\n\t\t\taddLevel(collection.getLevel(levelNo));\n\t\t}\n\t}\n",
    "677": "\tpublic double setValue(double value) {\n\n\t\tdouble rc = value;\n\t\tif (value > maximumValue) {\n\t\t\trc = maximumValue;\n\t\t} else if (value < minimumValue) {\n\t\t\trc = minimumValue;\n\t\t} else {\n\t\t\trc = value;\n\t\t}\n\t\ttextfieldGUI.setValue(rc);\n\n\t\treturn rc;\t\t\n\t}\n",
    "684": "\tpublic void actionPerformed(ActionEvent actionevent) {\n\t\tif (actionevent.getActionCommand() == \"okbutton\") {\n\t\t\tdispose();\n\t\t}\n\t}\n",
    "685": "\tpublic void informAllUnsync(Generator<E> eventgen) {\n\t\t/*\n\t\t * We must not directly use (weakhashmap.keySet()), since it still\n\t\t * is coupled to the weakhashmap itself, which needs synchronization.\n\t\t * Hence we first must obtain a copy.\n\t\t */\n\t\tfor (L listener : getListenersCopy()) {\n\t\t\tfinal E evt = ((eventgen != null) ? eventgen.generate() : null);\n\t\t\tcaller.call(listener, evt);\n\t\t}\n\t}\n",
    "687": "\tpublic void setToStart() {\n\t\tsetTo(true);\n\t}\n",
    "688": "\tpublic void setToStop() {\n\t\tsetTo(false);\n\t}\n",
    "690": "\tprivate void setTo( boolean forStart ) {\n\t\tString textkey = (forStart ? startkey           : stopkey          );\n\t\tString action  = (forStart ? startActionCommand : stopActionCommand);\n\t\t\n\t\tsetText(Texts.getText( textkey ));\n\t\tsetActionCommand( action );\n\t\t\n\t\tsetupBorder(forStart);\n\t\tsetupBgColor(forStart);\n\t}\n",
    "693": "\tprivate void setupBorder(boolean forStart) {\n\t\tsetBorder( useBorder ? makeBorder(forStart) : null );\n\t}\n",
    "694": "\tprivate void setupBgColor(boolean forStart) {\n\t\tif (useBgColor) {\n\t\t\tint rgb = (forStart ? bgColorStart : bgColorStop);\n\t\t\t\n\t\t\tsetBackground( new Color(rgb) );\n\t\t\tsetOpaque(false);\n\t\t} else {\n\t\t\t// FFS/hm: should we actively put away a background color?\n\t\t}\n\t}\n",
    "696": "\tpublic Border makeBorder(boolean forStart) {\n\t\tint rgb = (forStart ? borderColorStart : borderColorStop);\n\t\treturn makeRgbBorder(rgb, useRoundedCorners);\n\t}\n",
    "697": "\tpublic Border makeStartBorder() {\n\t\treturn makeBorder(true);\n\t}\n",
    "699": "\tpublic Border makeStopBorder() {\n\t\treturn makeBorder(false);\n\t}\n",
    "703": "\tpublic void setUseBorder(boolean useBorder) {\n\t\tthis.useBorder = useBorder;\n\t}\n"
}
